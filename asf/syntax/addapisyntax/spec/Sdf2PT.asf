equations

[n] normal(Symbol,*) = Symbol*
    ===>
    normal(Literal ( Symbol,*) -> Rhs Attributes) =
      Literal "(" Symbol* ")" -> Rhs Attributes

[n1] normal() =
[n2] normal(Symbol) = Symbol
[n3] normal(Symbol, Symbol,*) = Symbol normal(Symbol,*)

[0] sdf2pt(Lhs -> Rhs Attributes, cf) =
    prod([asyms(Lhs,cf)],cf(asym(Rhs)),aattributes(Attributes)) 

%%[0] sdf2pt(Lhs -> Rhs Attributes, lex) =
%%    prod([asyms(Lhs,lex)],lex(asym(Rhs)),aattributes(Attributes)) 

[1] asyms(,lex|cf) =

[default] asyms(Symbol, cf)  = cf(asym(Symbol))   
[default] asyms(Symbol, lex) = lex(asym(Symbol))  
[2]       asyms($Literal, lex|cf) = asym($Literal)

[default] asyms(Symbol $Symbol+, cf) = 
          cf(asym(Symbol)), cf(opt(layout)), asyms($Symbol+,cf)  

[default] asyms(Symbol $Symbol+, lex) = 
          lex(asym(Symbol)), asyms($Symbol+,lex)

[3] asyms($Literal $Symbol+, lex) = asym($Literal), asyms($Symbol+,lex)
[3] asyms($Literal $Symbol+, cf) = asym($Literal),cf(opt(layout)),asyms($Symbol+,cf)

[4] asym(sort(c*))             = sort(literal(""" c* """))
[5] asym(Symbol ?)             = opt(asym(Symbol))
[6] asym(Symbol1 | Symbol2)    = alt(asym(Symbol1),asym(Symbol2))

[7] asym(Symbol +)             = iter(asym(Symbol))
[8] asym(Symbol *)             = iter-star(asym(Symbol))
[9] asym({Symbol1 Symbol2}+)   = iter-sep(asym(Symbol1),asym(Symbol2))
[10] asym({Symbol1 Symbol2}*)  = iter-star-sep(asym(Symbol1),asym(Symbol2))
[11] asym(literal(""" c* """)) = lit(literal(""" c* """))
[12] asym(uqliteral(c*))       = lit(literal(""" c* """))
[14] asym($Literal : Symbol)   = asym(Symbol)
[15] asym(($Symbol $Symbol+))  = seq(aseqlist($Symbol $Symbol+))
[16] asym(Symbol1 # Symbol2)   = pair(asym(Symbol1),asym(Symbol2))
[17] asym(<Symbol -CF>)        = cf(asym(Symbol))
[18] asym(<Symbol -LEX>)       = lex(asym(Symbol))
[19] asym(<Symbol -VAR>)       = varsym(asym(Symbol))
[20] asym(LAYOUT)              = layout
[21] asym(())                  = empty
[22] asym(Symbol Natcon +)     = iter-n(asym(Symbol),Natcon)
[23] asym({Symbol1 Symbol2} Natcon +) = iter-sep-n(asym(Symbol1),asym(Symbol2),Natcon)
[24] asym(Set [ Symbol ])      = set(asym(Symbol))
[25] asym((Symbol* => Symbol)) = func([asyms(Symbol*,cf)],asym(Symbol))
[26] asym(<<Symbol*>>)         = perm([asyms(Symbol*,cf)])
[27] asym(sort(c*)[[Symbol,+]]) = parameterized-sort(sort(literal(""" c* """)),[asymsep(Symbol,+)])

[ass-1] asymsep(Symbol) = asym(Symbol)
[ass-1] asymsep(Symbol, Symbol,+) = asym(Symbol),asymsep(Symbol,+)

[13] aattributes()             = no-attrs
[14] aattributes({})           = no-attrs
[15] aattributes({Attribute+}) = attrs([aattrs(Attribute+)])
[15] aattrs(Attribute)         = aattr(Attribute)

[16] aattrs(Attribute, Attribute+) = aattr(Attribute), aattrs(Attribute+)

%% HACK Alert! assoc, left, right and non-assoc are reserved keywords in SDF
%% So, we can not construct them without using lexical constructor functions ;-(

[17] aattr(left)= uqliteral("a""s""s""o""c")(uqliteral("l""e""f""t"))
[18] aattr(right)= uqliteral("a""s""s""o""c")(uqliteral("r""i""g""h""t"))
[19] aattr(assoc)= uqliteral("a""s""s""o""c")(uqliteral("a""s""s""o""c"))
[20] aattr(non-assoc)= uqliteral("a""s""s""o""c")(uqliteral("n""o""n""-""a""s""s""o""c"))
[21] aattr(bracket) = uqliteral("b""r""a""c""k""e""t")
[22] aattr(prefer) = prefer
[23] aattr(avoid) = avoid
[24] aattr(reject) = reject
[25] aattr(id($Literal)) = id($Literal)
[26] aattr(ATerm) = term(ATerm)

[27] aseqlist(Symbol) = asym(Symbol)
[28] aseqlist(Symbol Symbol+) = asym(Symbol), aseqlist(Symbol+)
