equations

[0] add-api-syntax(definition Definition) = definition add-api(Definition)

[1] add-api(Definition) = aa(Definition)

[2] aa(lexical syntax Production*) =
    lexical syntax Production*
%%    aaps(Production*, lex)

[3] aa(context-free syntax Production*) =
    context-free syntax
    aaps(Production*, cf)

[4] aaps(,lex|cf) =

[5] aaps(Production Production*,lex|cf) = 
    aap(Production,lex|cf) 
    aaps(Production*,lex|cf)

[6] constructor(Production,lex|cf) = Production*1,
    predicate(Production,lex|cf)   = Production*2,
    getters(Production,lex|cf)     = Production*3,
    setters(Production,lex|cf)     = Production*4
    ===>
    aap(Production,lex|cf) = 
    Production 
    Production*1
    Production*2
    Production*3
    Production*4

[c] constructor(Lhs -> Rhs {Attribute*1, cons(Literal), Attribute*2},lex|cf) =
      make-constructor(Lhs, Rhs, unquote(Literal), 
        sdf2pt(Lhs -> Rhs {Attribute*1, cons(Literal), Attribute*2}, lex|cf))

[p] predicate(Lhs -> Rhs {Attribute*1, cons(Literal), Attribute*2},lex|cf) =
      make-predicate(Lhs, Rhs, unquote(Literal),
        sdf2pt(Lhs -> Rhs {Attribute*1, cons(Literal), Attribute*2}, lex|cf))

[g] getters(Lhs -> Rhs {Attribute*1, cons(Literal), Attribute*2},lex|cf) =
      make-getters(Lhs, Rhs, unquote(Literal), 
        sdf2pt(Lhs -> Rhs {Attribute*1, cons(Literal), Attribute*2}, lex|cf)) 

[s] setters(Lhs -> Rhs {Attribute*1, cons(Literal), Attribute*2},lex|cf) =
      make-setters(Lhs, Rhs, unquote(Literal),
        sdf2pt(Lhs -> Rhs {Attribute*1, cons(Literal), Attribute*2}, lex|cf))

[default-c] constructor(Production,lex|cf) =
[default-p] predicate(Production,lex|cf) =
[default-g] getters(Production,lex|cf) =
[default-s] setters(Production,lex|cf) =

[mc] get-arguments(Lhs) = $Symbol,*
     ===>
     make-constructor(Lhs,Rhs,Literal,Term) = 
      quote(Literal) ( $Symbol,* ) -> Rhs {asf-constructor(Term)} 

[mp] make-predicate(Lhs,Rhs,uqliteral(c*),Term) = 
       literal(""""i""s""-" c*""") "(" Rhs ")" -> "true" | "false" {asf-predicate(Term)}

[mg] make-getters(Lhs,Rhs,Literal,Term) = make-getters(Lhs,Rhs,0,Term)

[mgs] make-getters(,Rhs,Int,Term) =

[mgs-1] Int = nat-con(c*), Intcon = natcon(c*)
        ===>
        make-getters(Literal : Symbol Symbol*,Rhs,Int,Term) =
          quote(Literal)(Rhs) -> Symbol {asf-getter(Term,Intcon)}
          make-getters(Symbol*,Rhs,Int + 1, Term)

[default-mgs] make-getters(Symbol Symbol*, Rhs, Int, Term) =
                make-getters(Symbol*,Rhs,Int + 1, Term)

[ms] make-setters(Lhs,Rhs,Literal,Term) = make-setters(Lhs,Rhs,0,Term)

[mss] make-setters(,Rhs,Int,Term) =

[mss-1] Int = nat-con(c*), Intcon = natcon(c*),
        unquote(Literal) = uqliteral(c*2)
        ===>
        make-setters(Literal : Symbol Symbol*,Rhs,Int,Term) =
          quote(literal("s""e""t""-"c*2))(Rhs,Symbol) -> Rhs {asf-setter(Term,Intcon)}
          make-setters(Symbol*,Rhs,Int + 1, Term)

[default-mgs] make-setters(Symbol Symbol*, Rhs, Int, Term) =
                make-setters(Symbol*,Rhs,Int + 1, Term)

[uq] unquote(literal("""c*""")) = uqliteral(c*)
[uq] unquote(uqliteral(c*))        = uqliteral(c*)
[default-1] unquote(literal(c*)) = uqliteral(c*)

[q] quote(uqliteral(c*)) = literal("""c*""")
[q] quote(literal("""c*""")) = literal("""c*""")
[default-q] quote(literal(c*)) = literal("""c*""")

[il] is-literal($Literal) = true
[default-il] is-literal(Symbol) = false

[ga] get-arguments() =

[ga-1] is-literal(Symbol) = true
       ===>
       get-arguments(Symbol Symbol*) = get-arguments(Symbol*)

[ga-2] is-literal(Symbol) = false
       ===>
       get-arguments(Symbol Symbol*) = Symbol, get-arguments(Symbol*)