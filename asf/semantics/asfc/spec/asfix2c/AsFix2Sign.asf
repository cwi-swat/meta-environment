%%
%%    Meta-Environment - An environment for language prototyping.
%%    Copyright (C) 2000  Stichting Mathematisch Centrum, Amsterdam, 
%%                        The Netherlands. 
%%
%%    This program is free software; you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation; either version 2 of the License, or
%%    (at your option) any later version.
%%
%%    This program is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with this program; if not, write to the Free Software
%%    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
%%
equations

%% The generation of function definitions is based on the
%% the lexical syntax and context-free syntax definition
%% of a module.

  [a2me-1'1] Amodule[module-name] = Aname1,
             get-org-modname(Aname1) = Aname2,
             Amodule[sections] = Sections
             ============================
             asfix2sign(Amodule,Nametable) =
               syntax2rules(Aname2,Sections,Nametable)

%% The {\sc Sdf} part may be empty.
  [s2r-1'1] syntax2rules(Aname,[],Nametable) = (,Nametable)

%% If the {\sc Sdf} definition is not empty, all
%% subsection are translated.
  [s2r-1'2] SynSecs != [],
            synsecs2sign(Aname,SynSecs,{sort("LAYOUT")},Nametable1) =
              (Funcdef*,Sortlist,Nametable2)
            ==================================
            syntax2rules(Aname,SynSecs,Nametable1) = (Funcdef*,Nametable2)

%% The translation of the subsections is straightforward.
  [ss2e-1'1] synsecs2sign(Aname,[],Sortlist,Nametable) =
               (,Sortlist,Nametable)

  [ss2e-1'2] SynSecs1 != [],
             get-iter-tail(SynSecs1) = SynSecs2,
             synsec2sign(Aname,first(SynSecs1),Sortlist1,Nametable1) =
               (Funcdef*1,Sortlist2,Nametable2),
             synsecs2sign(Aname,SynSecs2,Sortlist2,Nametable2) =
               (Funcdef*2,Sortlist3,Nametable3),
             Funcdef*1 ++ Funcdef*2 = Funcdef*3
             ==================================
             synsecs2sign(Aname,SynSecs1,Sortlist1,Nametable1) =
               (Funcdef*3,Sortlist3,Nametable3)

%% An import section need not be translated.
  [ss2e-2'1] get-cons(SynSec) = imports
             ==========================
             synsec2sign(Aname,SynSec,Sortlist,Nametable) = (,Sortlist,Nametable)

%% Only the export and hidden sections must be translated.
  [ss2e-2'2] get-cons(SynSec) = exports,
             SynSec[grammars] = Sections
             ===========================
             synsec2sign(Aname,SynSec,Sortlist,Nametable) =
               sections2sign(Aname,Sections,Sortlist,Nametable)

  [ss2e-2'3] get-cons(SynSec) = hiddens,
             SynSec[grammars] = Sections
             ===========================
             synsec2sign(Aname,SynSec,Sortlist,Nametable) =
               sections2sign(Aname,Sections,Sortlist,Nametable)

%% These sections are lists, so their elements are translated recursively.
  [s2e-1'1] sections2sign(Aname,[],Sortlist,Nametable) = (,Sortlist,Nametable)

  [s2e-1'2] Sections1 != [],
            get-iter-tail(Sections1) = Sections2,
            section2sign(Aname,first(Sections1),Sortlist1,Nametable1) =
              (Funcdef*1,Sortlist2,Nametable2),
            sections2sign(Aname,Sections2,Sortlist2,Nametable2) =
              (Funcdef*2,Sortlist3,Nametable3),
            Funcdef*1 ++ Funcdef*2 = Funcdef*3
            ==================================
            sections2sign(Aname,Sections1,Sortlist1,Nametable1) =
              (Funcdef*3,Sortlist3,Nametable3)

%% The lexical syntax is translated by a separate function {\tt lexfuncs2sign}.
  [s2e-2'1] get-cons($Section) = lexical-syntax,
            $Section[productions] = LexFuncs
            ===============================
            section2sign(Aname,$Section,Sortlist,Nametable) =
              lexfuncs2sign(LexFuncs,Sortlist,Nametable)

%% The same holds for the context-free syntax.
  [s2e-2'2] get-cons($Section) = context-free-syntax,
            $Section[productions] = CfFuncs,
            cffuncs2sign(Aname,CfFuncs,Nametable1) = (Funcdef*,Nametable2)
            ========================================================
            section2sign(Aname,$Section,Sortlist,Nametable1) =
              (Funcdef*,Sortlist,Nametable2)

%% All other sections, like {\tt sorts}, {\tt variable} and {\tt priorities} need not
%% be translated.
  [default-s2e-2'4] section2sign(Aname,$Section,Sortlist,Nametable) =
                      (,Sortlist,Nametable)

%% The list of lexical functions is processed one by one.
  [lf2e-1'1] lexfuncs2sign([],Sortlist,Nametable) = (,Sortlist,Nametable)

  [lf2e-1'2] LexFuncs1 != [],
             get-iter-tail(LexFuncs1) = LexFuncs2,
             lexfunc2sign(first(LexFuncs1),Sortlist1,Nametable1) =
               (Funcdef*1,Sortlist2,Nametable2),
             lexfuncs2sign(LexFuncs2,Sortlist2,Nametable2) =
               (Funcdef*2,Sortlist3,Nametable3),
             Funcdef*1 ++ Funcdef*2 = Funcdef*3
             ==================================
             lexfuncs2sign(LexFuncs1,Sortlist1,Nametable1) =
               (Funcdef*3,Sortlist3,Nametable3)

%% If a the result sort of a lexical function definition is
%% already in the sort list no function definition will be
%% generated.
  [lf2e-2'1] is-term-production(LexFunc) = true
             ==================================
             lexfunc2sign(LexFunc,Sortlist,Nametable) =
               term-lexfunc2sign(LexFunc,Sortlist,Nametable)

  [lf2e-2'2] is-term-production(LexFunc) = false,
             LexFunc[sym] = Symbol,
             includes-sortname(Symbol,Sortlist) = true
             =========================================
             lexfunc2sign(LexFunc,Sortlist,Nametable) = (,Sortlist,Nametable)

%% The definition for a lexical function consists of lexical constructor
%% function definition and the function definition for the CHAR-list itself.
  [lf2e-2'3] is-term-production(LexFunc) = false,
             LexFunc[sym] = Symbol,
             includes-sortname(Symbol,{Lexsort*}) = false,
             Symbol = sort($L),
             sort2id(Symbol) = Funid1,
             make-caller-func($L) = Funid3,
             nt-lookup("{sort(\"CHAR\")}",Nametable1) =
               (Funid4,Nametable2),
             nt-lookup(Funid3,Nametable2) =
               (Funid5,Nametable3)
             ============================
             lexfunc2sign(LexFunc,{Lexsort*},Nametable1) =
               ("{sort(\"CHAR\")}"( _ );
                Funid5( _ ),{Lexsort*;Symbol},Nametable3)

  [cf2e-1'2] cffuncs2sign(Aname,[],Nametable) = (,Nametable)

  [cf2e-1'1] CfFuncs1 != [],
             get-iter-tail(CfFuncs1) = CfFuncs2,
             cffunc2sign(Aname,first(CfFuncs1),Nametable1) = (Funcdef*1,Nametable2),
             cffuncs2sign(Aname,CfFuncs2,Nametable2) = (Funcdef*2,Nametable3),
             Funcdef*1 ++ Funcdef*2 = Funcdef*3
             ==================================
             cffuncs2sign(Aname,CfFuncs1,Nametable1) = (Funcdef*3,Nametable3)

  [cf2e-2'1] is-term-production(CfFunc) = true,
             term-cffunc2sign(Aname,CfFunc,Nametable1) = (Funcdef*,Nametable2)
             ===========================================================
             cffunc2sign(Aname,CfFunc,Nametable1) = (Funcdef*,Nametable2)

  [cf2e-2'2] is-term-production(CfFunc) = false,
             CfFunc[syms] = CfElems,
             cfelems2args(CfElems,Nametable1) = (Funcdef*1,Term*1,Nametable2),
             cffunc2id(CfFunc) = Funid1,
             CfFunc[attrs] = Attr,
             attrs2terms(Attr) = Term*2,
             nt-lookup(Funid1,Term*2,Nametable2) = (Funid2,Nametable3),
             make-funcdef(Funid2,Term*1) = Funcdef,
             Funcdef ++ Funcdef*1 = Funcdef*2
             ================================
             cffunc2sign(Aname,CfFunc,Nametable1) = (Funcdef*2,Nametable3)

%% Functions without arguments, so-called constants, need not
%% an argument list.
  [default-cf2e-2'3] cffunc2id(CfFunc) = Funid1,
                     CfFunc[attrs] = Attr,
                     attrs2terms(Attr) = Term*,
                     nt-lookup(Funid1,Term*,Nametable1) = (Funid2,Nametable2)
                     ========================================================
                     cffunc2sign(Aname,CfFunc,Nametable1) = (Funid2,Nametable2)

  [cf2a-1'1] cfelems2args([],Nametable) = (,,Nametable)

  [cf2a-1'2] CfElems1 != [],
             get-iter-tail(CfElems1) = CfElems2,
             cfelem2args(first(CfElems1),Nametable1) = (Funcdef*1,Term*1,Nametable2),
             cfelems2args(CfElems2,Nametable2) = (Funcdef*2,Term*2,Nametable3),
             Funcdef*1 ++ Funcdef*2 = Funcdef*3
             ==================================
             cfelems2args(CfElems1,Nametable1) = (Funcdef*3,Term*1,Term*2,Nametable3)

%% Only for sorts and lists arguments in the function definition have to
%% be generated. Furthermore, the function definitions for the specific list constructors
%% have to be generated.
  [cf2a-2'1] gen-var(1) = Varid
             ==================
             cfelem2args(sort($L),Nametable) = (,Varid,Nametable)

  [cf2a-2'2] get-cons(Symbol) = iter-sep,
             gen-var(1) = Varid,
             iter2id(Symbol) = Funid1,
             nt-lookup(Funid1,Nametable1) = (Funid2,Nametable2),
             make-funcdef(Funid1,Varid) = Funcdef
             ====================================
             cfelem2args(Symbol,Nametable1) = (Funcdef,Varid,Nametable2)

  [cf2a-2'3] get-cons(Symbol) = iter,
             gen-var(1) = Varid,
             iter2id(Symbol) = Funid1,
             nt-lookup(Funid1,Nametable1) = (Funid2,Nametable2),
             make-funcdef(Funid1,Varid) = Funcdef
             ====================================
             cfelem2args(Symbol,Nametable1) = (Funcdef,Varid,Nametable2)

  [default-cf2a-2'4] cfelem2args(CfElem,Nametable) = (,,Nametable)

  [a2t-1'1] attrs2terms(no-attrs) =

  [a2t-1'2] Attr != no-attrs,
            get-cons(Attr) = attrs,
            Attr[attrs] = Attrlist
            ======================
            attrs2terms(Attr) = attrlist2terms(Attrlist)

  [a2t-2'2] attrlist2terms([]) =

  [a2t-2'2] Attrlist1 != [],
            get-itersep-tail(Attrlist1) = Attrlist2,
            attr2term(first(Attrlist1)) = Term1,
            attrlist2terms(Attrlist2) = Term*
            =================================
            attrlist2terms(Attrlist1) =  Term1 ++del Term*

  [a2t-3'1] attr2term(l(literal(""" "d""e""l""a""y""i""n""g" Char* """))) = delaying(natcon(Char*))

  [default-a2t-3'2] attr2term(l(literal(""" Char* """))) = funid(Char*)
