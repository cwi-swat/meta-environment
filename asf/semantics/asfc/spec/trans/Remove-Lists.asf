%%
%%    Meta-Environment - An environment for language prototyping.
%%    Copyright (C) 2000  Stichting Mathematisch Centrum, Amsterdam, The Netherlands. 
%%
%%    This program is free software; you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation; either version 2 of the License, or
%%    (at your option) any later version.
%%
%%    This program is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with this program; if not, write to the Free Software
%%    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
%%
equations

  [rlm-1'1] rem-lists-from-ruleopt(Rulesopt1) = (Funcdef*,Rule*),
            addto-sign(Signopt1,Funcdef*) = Signopt2,
            create-new-rulesopt(Rule*) = Rulesopt2
            ======================================
            remove-list-matching(module Modid
                                        Signopt1
                                        Rulesopt1) =
              module Modid
                     Signopt2
                     Rulesopt2

%% If there are not rules there is nothing to be done.
  [rlro-1'1] rem-lists-from-ruleopt() = (,)

  [rlro-1'1] rem-lists-from-ruleopt(rules) = (,)

%% If there are rules all rules are inspected.
%% If it is an instantiation of a specific list pattern,
%% such as lookup-like, or set-like rules, the entire rule
%% must be transformed. This is not yet specified.
  [rlro-1'3] rem-lists-from-rules(Rule+,1) = (Funcdef*,Rule*,Aint)
             =====================================================
             rem-lists-from-ruleopt(rules Rule+) = (Funcdef*,Rule*)

%% If all rules are transformed we are ready.
  [rlrs-1'1] rem-lists-from-rules(,Aint) = (,,Aint)

%% If there are still rules left they are transformed
%% one-by-one.
  [rlrs-1'3] rem-lists-from-rule(Rule,Aint1) = (Funcdef*1,Rule*2,Aint2),
             rem-lists-from-rules(Rule*1,Aint2) = (Funcdef*2,Rule*3,Aint3),
             Funcdef*1 ++ Funcdef*2 =Funcdef*3
             =================================
             rem-lists-from-rules(Rule;Rule*1,Aint1) =
              (Funcdef*3,Rule*2;Rule*3,Aint3)

%% Before the simple list patterns are removed, it is first checked
%% whether more complex patterns like ``lookup-patterns'' can be
%% removed.
  [rlr-1'1] rule-contains-lists(Rule) = false
            =================================
            rem-lists-from-rule(Rule,Aint) = (,Rule,Aint)

  [rlr-1'2] rule-contains-lists(Rule) = true,
            is-default-rule(Rule) = true
            ============================
            rem-lists-from-rule(Rule,Aint) =
              rem-lists-from-default-rule(Rule,Aint)

  [rlr-1'3] rule-contains-lists(Rule) = true,
            is-default-rule(Rule) = false
            =============================
            rem-lists-from-rule(Rule,Aint) =
              rem-lists-from-simple-rule(false,Rule,Aint)

%% If all rules are transformed we are ready.
  [rlvrs-1'1] rem-listvars-from-rules(,Aint) = (,,Aint)

%% If there are still rules left they are transformed
%% one-by-one.
  [rlvrs-1'2] rem-listvars-from-rule(Rule,Aint1) = (Funcdef*1,Rule*2,Aint2),
              rem-listvars-from-rules(Rule*1,Aint2) = (Funcdef*2,Rule*3,Aint3),
              Funcdef*1 ++ Funcdef*2 =Funcdef*3
              =================================
              rem-listvars-from-rules(Rule;Rule*1,Aint1) =
               (Funcdef*3,Rule*2;Rule*3,Aint3)

  [rlvr-1'1] rule-contains-list-vars(Rule1) = false,
             remove-list-cons-from-rule(Rule1) = Rule2
             =========================================
             rem-listvars-from-rule(Rule1,Aint) = (,Rule2,Aint)
                                                  %%%(,Rule1,Aint)

  [rlvr-1'2] rule-contains-list-vars(Rule1) = true,
             is-default-rule(Rule1) = false,
             rename-in-rules(Rule1) = Rule2
             ==============================
             rem-listvars-from-rule(Rule1,Aint) =
               rem-lists-from-simple-rule(false,Rule2,Aint)

  [rlvr-1'2] rule-contains-list-vars(Rule1) = true,
             is-default-rule(Rule1) = true,
             rename-in-rules(Rule1) = Rule2
             ==============================
             rem-listvars-from-rule(Rule1,Aint) =
               rem-lists-from-default-rule(Rule2,Aint)

%% The next 3 rewrite rules inspect whether the function
%% contains a lookup or set pattern. It is assumed that
%% the rule is not a default rule.

  [rlsr-1'1] contains-zero-or-one-list-vars-in-rule(Rule1) = true,
             remove-simple-lists(Rule1) = Rule2,
             rem-listvars-from-rule(Rule2,Aint1) = (Funcdef*,Rule*,Aint2)
             ============================================================
             rem-lists-from-simple-rule(Bool,Rule1,Aint1) = (Funcdef*,Rule*,Aint2)

  [rlsr-1'2] is-special-rule(Rule) = true,
             transform-special-rule(Rule,1) = (Funcdef*1,Rule*1,Aint2),
             rename-in-rules(Rule*1) = Rule*2,
             rem-lists-from-rules(Rule*2,Aint1) = (Funcdef*2,Rule*3,Aint3)
             =============================================================
             rem-lists-from-simple-rule(false,Rule,Aint1) =
               (Funcdef*1;Funcdef*2,Rule*3,Aint3)

  [rlsr-1'3] is-special-rule(Rule1) = false,
             normalize-list-in-rule(Rule1) = Rule2,
             Rule1 != Rule2,
             rename-in-rules(Rule2) = Rule3,
             rem-lists-from-simple-rule(false,Rule3,Aint1) = (Funcdef*,Rule*,Aint2)
             ======================================================================
             rem-lists-from-simple-rule(false,Rule1,Aint1) = (Funcdef*,Rule*,Aint2)

  [rlsr-1'4] normalize-list-in-rule(Rule1) = Rule2,
             Rule1 != Rule2,
             rename-in-rules(Rule2) = Rule3,
             rem-lists-from-simple-rule(true,Rule3,Aint1) = (Funcdef*,Rule*,Aint2)
             =====================================================================
             rem-lists-from-simple-rule(true,Rule1,Aint1) = (Funcdef*,Rule*,Aint2)

  [default-rlsr-1'5] rem-lists-from-simple-rule(Bool,Rule,Aint) = (,Rule,Aint)

%% If a default rule contains list variable it is necessary to
%% introduce a new function symbol, because it is not allowed
%% to have default rules with conditions.
%%%  [rldr-1'1] Term1 = Funid1(Term+1),
%%%             prefix-id("new__",Funid1,Aint1) = Funid2,
%%%             make-new-funcdef(Funid1(Term+1),Funid2) = Funcdef,
%%%             rem-lists-from-simple-rule(Funid2(Term+1) = Term2,succ(Aint1)) = (Funcdef*1,Rule*2,Aint2),
%%%             make-new-args(Term+1,1) = Term+2
%%%             ================================
%%%             rem-lists-from-default-rule(default:Term1 = Term2,Aint1) =
%%%               (Funcdef*1;Funcdef,
%%%                default:Funid1(Term+2) = Funid2(Term+2);
%%%                Rule*2,Aint1)
%%%
%%%  [rldr-1'2] Term1 = Funid1(Term+1),
%%%             prefix-id("new__",Funid1,Aint1) = Funid2,
%%%             make-new-funcdef(Funid1(Term+1),Funid2) = Funcdef,
%%%             rem-lists-from-simple-rule(Cond+ ==> Funid2(Term+1) = Term2,succ(Aint1)) = (Funcdef*1,Rule*2,Aint2),
%%%             make-new-args(Term+1,1) = Term+2
%%%             ================================
%%%             rem-lists-from-default-rule(default:Cond+ ==> Term1 = Term2,Aint1) =
%%%               (Funcdef*1;Funcdef,
%%%                default:Funid1(Term+2) = Funid2(Term+2);
%%%                Rule*2,Aint1)

  [rldr-1'1] rem-lists-from-simple-rule(true,Term1 = Term2,Aint1) =
               (Funcdef*,Rule2,Aint2),
             make-default-rule(Rule2) = Rule3
             ================================
             rem-lists-from-default-rule(default:Term1 = Term2,Aint1) =
               (Funcdef*,Rule3,Aint1)

  [rldr-1'2] Term1 = Funid1(Term+1),
             rem-lists-from-simple-rule(true,Cond+ ==> Term1 = Term2,Aint1) =
               (Funcdef*,Rule2,Aint2),
             make-default-rule(Rule2) = Rule3
             ================================
             rem-lists-from-default-rule(default:Cond+ ==> Term1 = Term2,Aint1) =
               (Funcdef*,Rule3,Aint1)

%% Given a rule with or without conditions the actual transformation
%% can take place. The left-hand side is first processed, followed by
%% the conditions, if any, and finally the right-hand side is processed.
%% All list variables are stored in a variable environment, to make
%% sure that a list is only ``transformed'' once. After the
%% transformation of the entire rule, a new rule is constructed.
  [rlr-1'1] rem-lists-from-lhs-term(Term1,[1,]) = (Term3,Cond*1,Ivarenv1),
            rem-lists-from-rhs-term(Term2,Ivarenv1) = (Term4,Cond*2,Ivarenv2),
            make-conditional-rule(Cond*1 & Cond*2,Term3 = Term4) = Rule
            ===========================================================
            remove-simple-lists(Term1 = Term2) = Rule

  [rlr-1'2] rem-lists-from-lhs-term(Term1,[1,]) = (Term3,Cond*1,Ivarenv1),
            rem-lists-from-conds(Cond+,Ivarenv1) = (Cond*2,Ivarenv2),
            rem-lists-from-rhs-term(Term2,Ivarenv2) = (Term4,Cond*3,Ivarenv3),
            make-conditional-rule(Cond*1 & Cond*2 & Cond*3,Term3 = Term4) = Rule
            ====================================================================
            remove-simple-lists(Cond+ ==>
                                Term1 = Term2) = Rule

%%%  [rlr-1'3] contains-zero-or-one-list-var(Term1) = false,
%%%            rem-lists-from-lhs-term(Term1,[1,]) = (Term3,Cond*1,Ivarenv1),
%%%            rem-lists-from-rhs-term(Term2,Ivarenv1) = (Term4,Cond*2,Ivarenv2),
%%%            make-conditional-rule(Cond*1 & Cond*2,Term3 = Term4) = Rule
%%%            ===========================================================
%%%            remove-simple-lists(Term1 = Term2) = Rule

%%%  [rlr-1'4] contains-zero-or-one-list-var(Term1) = false,
%%%            rem-lists-from-lhs-term(Term1,[1,]) = (Term3,Cond*1,Ivarenv1),
%%%            rem-lists-from-conds(Cond+,Ivarenv1) = (Cond*2,Ivarenv2),
%%%            rem-lists-from-rhs-term(Term2,Ivarenv2) = (Term4,Cond*3,Ivarenv3),
%%%            make-conditional-rule(Cond*1 & Cond*2 & Cond*3,Term3 = Term4) = Rule
%%%            ====================================================================
%%%            remove-simple-lists(Cond+ ==>
%%%                                Term1 = Term2) = Rule

%% The equations to deal with the conditions in a rewrite rule.
  [rlcs-1'1] rem-lists-from-conds(Cond,Ivarenv1) =
               rem-lists-from-cond(Cond,Ivarenv1)

  [rlcs-1'2] rem-lists-from-cond(Cond1,Ivarenv1) = (Cond+2,Ivarenv2),
             rem-lists-from-conds(Cond+1,Ivarenv2) = (Cond+3,Ivarenv3)
             =========================================================
             rem-lists-from-conds(Cond1 & Cond+1,Ivarenv1) = (Cond+2 & Cond+3,Ivarenv3)

%% Note that Term2 represents the matching side.
  [rlc-1'1] rem-lists-from-rhs-term(Term1,Ivarenv1) =
              (Term3,Cond*1,Ivarenv2),
            rem-lists-from-lhs-term(Term2,Ivarenv2) =
              (Term4,Cond*2,Ivarenv3)
            =========================
            rem-lists-from-cond(Term1 =: Term2,Ivarenv1) =
              (Term3 =: Term4 & Cond*1 & Cond*2,Ivarenv3)

%% If a term is a function which does not represent list matching,
%% it arguments are transformed.
  [rllt-1'1] is-list-funid(Funid) = false,
             rem-lists-from-lhs-terms(Term+1,Ivarenv1) =
               (Term+2,Cond*,Ivarenv2)
             =========================
             rem-lists-from-lhs-term(Funid(Term+1),Ivarenv1) =
               (Funid(Term+2),Cond*,Ivarenv2)

%% If a term is a list matching function it is checked how many
%% list variables occur in its argument list. Only the
%% cases in which at most one list variables occur can be transformed.
  [rllt-1'2] is-list-funid(Funid) = true,
             contains-zero-or-one-list-vars-in-list(Term) = true,
             transform-lhs-list-terms(Term,Ivarenv1) =
               (Term+2,Cond*,Ivarenv2),
             make-trans-list-id(Funid) = Funid2
             ==================================
             rem-lists-from-lhs-term(Funid(Term),Ivarenv1) =
               (Funid2(Term+2),Cond*,Ivarenv2)

%% The ``default'' case the original term is returned.
  [default-rllt-1'4] rem-lists-from-lhs-term(Term,Ivarenv) =
                      (Term,,Ivarenv)

%% If a term is a function which does not represent list matching,
%% it arguments are transformed.
  [rlrt-1'1] is-list-funid(Funid) = false,
             rem-lists-from-rhs-terms(Term+1,Ivarenv1) =
               (Term+2,Cond*,Ivarenv2)
             =========================
             rem-lists-from-rhs-term(Funid(Term+1),Ivarenv1) =
               (Funid(Term+2),Cond*,Ivarenv2)

  [rlrt-1'2] is-list-funid(Funid) = true,
             transform-rhs-list-terms(Term+1,Ivarenv1) =
               (Term+2,Cond*,Ivarenv2),
             make-list-args(Term+2) = Term3
             ==============================
             rem-lists-from-rhs-term(Funid(Term+1),Ivarenv1) =
               (Funid(Term3),Cond*,Ivarenv2)

%% If the term is a variable in the right hand side of an equation or
%% the non matching side of a condition this variable is translated into
%% a list.
  [rlrt-1'3] is-list-var-term(Term1) = true,
             includes(Term1,Ivarenv) = true,
             newlistvar(Term1) = Term2
             =========================
             rem-lists-from-rhs-term(Term1,Ivarenv) = (Term2,,Ivarenv)

%% The ``default'' case the original term is returned.
  [default-rlrt-1'4] rem-lists-from-rhs-term(Term,Ivarenv) =
                      (Term,,Ivarenv)

%% The equations to deal with the arguments of non-list functions.
  [rllts-1'1] rem-lists-from-lhs-terms(Term1,Ivarenv1) =
               rem-lists-from-lhs-term(Term1,Ivarenv1)

  [rllts-1'2] rem-lists-from-lhs-term(Term1,Ivarenv1) =
                (Term2,Cond*1,Ivarenv2),
              rem-lists-from-lhs-terms(Term+1,Ivarenv2) =
                (Term+2,Cond*2,Ivarenv3)
              ==========================
              rem-lists-from-lhs-terms(Term1,Term+1,Ivarenv1) =
                (Term2,Term+2,Cond*1 & Cond*2,Ivarenv3)

%% The equations to deal with the arguments of non-list functions.
  [rlrts-1'1] rem-lists-from-rhs-terms(Term1,Ivarenv1) =
                rem-lists-from-rhs-term(Term1,Ivarenv1)

  [rlrts-1'2] rem-lists-from-rhs-term(Term1,Ivarenv1) =
                (Term2,Cond*1,Ivarenv2),
              rem-lists-from-rhs-terms(Term+1,Ivarenv2) =
                (Term+2,Cond*2,Ivarenv3)
              ==========================
              rem-lists-from-rhs-terms(Term1,Term+1,Ivarenv1) =
                (Term2,Term+2,Cond*1 & Cond*2,Ivarenv3)

  [tllt-1'1] is-list-cons(Term2) = false
             ===========================
             transform-lhs-list-terms(cons(Term1,Term2),Ivarenv) =
               transform-lhs-double-terms(Term1,Term2,Ivarenv)

  [tllt-1'3] is-list-cons(Term2) = true
             ==========================
             transform-lhs-list-terms(cons(Term1,Term2),Ivarenv) =
               transform-lhs-multiple-terms(cons(Term1,Term2),Ivarenv)

  [default-tllt-1'4] transform-lhs-list-terms(Term,Ivarenv) =
                       transform-lhs-single-term(Term,Ivarenv)

%% When processing the arguments of a ``list''-function with
%% the function {\tt transform-list-terms} it is known that
%% this list contains at most one list variable.
%% Thus, a single argument is either a list variable or
%% not. If it is not a list variable, a test is generated
%% to check that the argument is a single list element.
  [tlst-1'1] get-int(Ivarenv1) = Aint,
             newlistvar(Aint) = Varid,
             put-int(succ(Aint),Ivarenv1) = Ivarenv2
             =======================================
             transform-lhs-single-term(null,Ivarenv1) =
               (Varid,not_empty_list(Varid) =: f,Ivarenv2)

  [tlst-1'2] Term1 != null,
             is-list-var-term(Term1) = false,
             contains-zero-or-one-list-vars-in-term(Term1) = true,
             rem-lists-from-lhs-term(Term1,Ivarenv1) = (Term2,Cond*,Ivarenv2),
             get-int(Ivarenv2) = Aint,
             newlistvar(Aint) = Varid,
             put-int(succ(Aint),Ivarenv2) = Ivarenv3
             =======================================
             transform-lhs-single-term(Term1,Ivarenv1) =
               (Varid,is_single_element(Varid) =: t &
                      make-new-cond(list_head(Varid),Term2) & Cond*,Ivarenv3)

  [tlst-1'2] Term1 != null,
             is-list-var-term(Term1) = false,
             contains-zero-or-one-list-vars-in-term(Term1) = false,
             get-int(Ivarenv1) = Aint,
             newlistvar(Aint) = Varid,
             put-int(succ(Aint),Ivarenv1) = Ivarenv2
             =======================================
             transform-lhs-single-term(Term1,Ivarenv1) =
               (Varid,is_single_element(Varid) =: t &
                      make-new-cond(list_head(Varid),Term1),Ivarenv2)

%% If the single term is a list variable it is transformed via
%% the function {\tt transform-list-var}.
  [tlst-1'3] is-list-var-term(Term1) = true
             ==============================
             transform-lhs-single-term(Term1,Ivarenv1) =
               transform-lhs-list-var(Term1,Ivarenv1)

%% A list with exactly 2 members is treated as an exceptional case,
%% it can be considered as the stop condition of the recurion.
%% There are three alternatives:
%% \begin{enumerate}
%% \item Both elements do not represent a list variable: ``head-tail''.
%% \item The first element is a list variable: ``prefix-last''.
%% \item The last element is a list variable: ``head-tail''.
%% \end{enumerate}
%% In all three cases a new variable is introduced to represent
%% the list and via access functions the first or the last element
%% of the list is obtained.
  [tldt-1'1] is-list-var-term(Term1) = false,
             rem-lists-from-lhs-term(Term1,Ivarenv1) = (Term3,Cond*1,Ivarenv2),
             is-list-var-term(Term2) = false,
             rem-lists-from-lhs-term(Term2,Ivarenv2) = (Term4,Cond*2,Ivarenv3),
             get-int(Ivarenv3) = Aint,
             newlistvar(Aint) = Varid1,
             newlistvar(succ(Aint)) = Varid2,
             put-int(succ(succ(Aint)),Ivarenv3) = Ivarenv4
             =======================================
             transform-lhs-double-terms(Term1,Term2,Ivarenv1) =
               (Varid1,not_empty_list(Varid1) =: t &
                       make-new-cond(list_head(Varid1),Term3) &
                       Cond*1 &
                       list_tail(Varid1) =: Varid2 &
                       is_single_element(Varid2) =: t &
                       make-new-cond(list_head(Varid2),Term4) & Cond*2 ,Ivarenv4)

  [tldt-1'2] is-list-var-term(Term1) = false,
             rem-lists-from-lhs-term(Term1,Ivarenv1) = (Term3,Cond*1,Ivarenv2),
             is-list-var-term(Term2) = true,
             transform-lhs-list-var(Term2,Ivarenv2) = (Term4,Cond*2,Ivarenv3),
             get-int(Ivarenv3) = Aint,
             newlistvar(Aint) = Varid2,
             put-int(succ(Aint),Ivarenv3) = Ivarenv4
             =======================================
             transform-lhs-double-terms(Term1,Term2,Ivarenv1) =
               (Varid2,not_empty_list(Varid2) =: t &
                       make-new-cond(list_head(Varid2),Term3) &
                       Cond*1 &
                       list_tail(Varid2) =: Term4 &
                       Cond*2,Ivarenv4)

  [tldt-1'3] is-list-var-term(Term1) = true,
             transform-lhs-list-var(Term1,Ivarenv1) = (Term3,Cond*1,Ivarenv2),
             is-list-var-term(Term2) = false,
             rem-lists-from-lhs-term(Term2,Ivarenv2) = (Term4,Cond*2,Ivarenv3),
             get-int(Ivarenv3) = Aint,
             newlistvar(Aint) = Varid,
             put-int(succ(Aint),Ivarenv3) = Ivarenv4
             =======================================
             transform-lhs-double-terms(Term1,Term2,Ivarenv1) =
               (Varid,not_empty_list(Varid) =: t &
                      list_prefix(Varid) =: Term3 & Cond*1 &
                      make-new-cond(list_last(Varid),Term4) & Cond*2,
                Ivarenv4)

%% If list of terms consists of three or more elements the
%% first element is inspected and depending on whether this is
%% a list variable or not the rest of the list is processed.
%% If the first element is not a list variable we can process
%% this first element via the ``head-tail'' mechanism.
%% So, a new variable is created and conditions to
%% obtain the head and the tail of the list are created.
%% The rest of the list is recursively processed.

  [tlmt-1'1] is-list-var-term(Term1) = false,
             rem-lists-from-lhs-term(Term1,Ivarenv1) = (Term3,Cond*1,Ivarenv2),
             get-int(Ivarenv2) = Aint,
             newlistvar(Aint) = Varid,
             put-int(succ(Aint),Ivarenv2) = Ivarenv3,
             transform-lhs-list-terms(Term2,Ivarenv3) =
               (Varid2,Cond*2,Ivarenv4)
             ==========================
             transform-lhs-multiple-terms(cons(Term1,Term2),Ivarenv1) =
               (Varid,%%%make-new-cond(list-head(Varid),make-element-term(Term3)) &
                      not_empty_list(Varid) =: t &
                      make-new-cond(list_head(Varid),Term3) &
                      Cond*1 &
                      list_tail(Varid) =: Varid2 & Cond*2,Ivarenv4)

%% If the first element is  list variable we must process the
%% list with a ``prefix-last'' mechanism. This is performed
%% via the function {\tt transform-no-list-terms}.
  [tlmt-1'2] is-list-var-term(Term1) = true,
             get-int(Ivarenv1) = Aint,
             newlistvar(Aint) = Varid,
             put-int(succ(Aint),Ivarenv1) = Ivarenv2,
             transform-no-list-terms(cons(Term1,Term2),Ivarenv2) =
               (Varid2,Cond*,Ivarenv3)
             =========================
             transform-lhs-multiple-terms(cons(Term1,Term2),Ivarenv1) =
               (Varid2,Cond*,Ivarenv3)

%% Functions to deal with simple list patterns on non matching positions.
  [trlt-1'1] transform-rhs-list-terms(null,Ivarenv) =
               (null,,Ivarenv)

  [trlt-1'2] Term1 != null,
             is-list-var-term(Term1) = false
             ===============================
             transform-rhs-list-terms(Term1,Ivarenv1) =
               rem-lists-from-rhs-term(Term1,Ivarenv1)

%% If the single term is a list variable it is transformed via
%% the function {\tt transform-list-var}.
  [trlt-1'3] is-list-var-term(Term1) = true
            ===============================
             transform-rhs-list-terms(Term1,Ivarenv1) =
               transform-rhs-list-var(Term1,Ivarenv1)

  [trlt-1'4] Term1 != null,
             is-list-var-term(Term1) = false,
             rem-lists-from-rhs-term(Term1,Ivarenv1) =
               (Term2,Cond*1,Ivarenv2),
             transform-rhs-list-terms(Term+1,Ivarenv2) =
               (Term+2,Cond*2,Ivarenv3)
             ==========================
             transform-rhs-list-terms(Term1,Term+1,Ivarenv1) =
              (Term2,Term+2,Cond*1 & Cond*2,Ivarenv3)

%% If the single term is a list variable it is transformed via
%% the function {\tt transform-list-var}.
  [trlt-1'5] is-list-var-term(Term1) = true,
             transform-rhs-list-var(Term1,Ivarenv1) =
               (Term2,Cond*1,Ivarenv2),
             transform-rhs-list-terms(Term+1,Ivarenv2) =
              (Term+2,Cond*2,Ivarenv3)
             =========================
             transform-rhs-list-terms(Term1,Term+1,Ivarenv1) =
               (Term2,Term+2,Cond*1 & Cond*2,Ivarenv3)

%% This function processes the list from tail to head because
%% it knows its head will be a list variable. The ``prefix-last''
%% construction is generated via conditions and new variables.
%% If the list consists of only two elements: first is the list variable
%% the recursion stops.
  [tnlt-1'1] is-list-cons(Term2) = false,
             transform-lhs-list-var(Term1,Ivarenv1) = (Term3,Cond*1,Ivarenv2),
             rem-lists-from-lhs-term(Term2,Ivarenv2) = (Term4,Cond*2,Ivarenv3),
             get-int(Ivarenv3) = Aint,
             newlistvar(Aint) = Varid,
             put-int(succ(Aint),Ivarenv3) = Ivarenv4
             =======================================
             transform-no-list-terms(cons(Term1,Term2),Ivarenv1) =
               (Varid,
                list_prefix(Varid) =: Term3 & Cond*1 &
                not_empty_list(Varid) =: t &
                make-new-cond(list_last(Varid),Term4) & Cond*2,
                Ivarenv4)

  [tnlt-1'2] is-list-cons(Term2) = true,
             get-last-element(Term2) = Term3,
             rem-lists-from-lhs-term(Term3,Ivarenv1) = (Term4,Cond*1,Ivarenv2),
             get-int(Ivarenv2) = Aint,
             newlistvar(Aint) = Varid,
             put-int(succ(Aint),Ivarenv2) = Ivarenv3,
             get-prefix-list(Term2) = Term5,
             transform-no-list-terms(cons(Term1,Term5),Ivarenv3) =
               (Varid2,Cond*2,Ivarenv4)
             ==========================
             transform-no-list-terms(cons(Term1,Term2),Ivarenv1) =
               (Varid,
                list_prefix(Varid) =: Varid2 &
                not_empty_list(Varid) =: t &
                make-new-cond(list_last(Varid),Term4) & Cond*1 & Cond*2,
                Ivarenv4)

%% Equations to deal with list variables, if a list variable represents zero or
%% elements the name is only changed. If a list variable represents one or
%% elements, the name is changed and a condition is generated to check
%% for non-emptyness.
  [trli-1'1] includes(*Varid1,Ivarenv) = true,
             newlistvar(*Varid1) = Varid2
             ============================
             transform-rhs-list-var(*Varid1,Ivarenv) = (Varid2,,Ivarenv)

  [trli-1'2] includes(+Varid1,Ivarenv) = true,
             newlistvar(+Varid1) = Varid2
             ============================
             transform-rhs-list-var(+Varid1,Ivarenv) =
               (Varid2,,Ivarenv)

  [default-trli-1'3] transform-rhs-list-var(Term,Ivarenv) = (Term,,Ivarenv)

  [tli-1'1] includes(*Varid1,Ivarenv1) = false,
            enter(*Varid1,Ivarenv1) = Ivarenv2,
            newlistvar(*Varid1) = Varid2
            ============================
            transform-lhs-list-var(*Varid1,Ivarenv1) = (Varid2,,Ivarenv2)

  [tli-1'2] includes(*Varid1,Ivarenv) = true,
            newlistvar(*Varid1) = Varid2
            ============================
            transform-lhs-list-var(*Varid1,Ivarenv) = (Varid2,,Ivarenv)

  [tli-1'3] includes(+Varid1,Ivarenv1) = false,
            enter(+Varid1,Ivarenv1) = Ivarenv2,
            newlistvar(+Varid1) = Varid2
            ============================
            transform-lhs-list-var(+Varid1,Ivarenv1) =
              (Varid2,not_empty_list(Varid2) =: t,Ivarenv2)

  [tli-1'4] includes(+Varid1,Ivarenv) = true,
            newlistvar(+Varid1) = Varid2
            ============================
            transform-lhs-list-var(+Varid1,Ivarenv) =
              (Varid2,,Ivarenv)
