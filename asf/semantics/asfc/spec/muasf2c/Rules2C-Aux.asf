equations

[wek-0] wrap-extra-kids(trafo,ActualArgs,1) = ATempty
[wek-1] wrap-extra-kids(trafo,ActualArg, ActualArg*,2) = ATmakeList1(ActualArg*)
[wek-2] wrap-extra-kids(trafo,ActualArg, ActualArg*,3) = ATmakeList2(ActualArg*)
[wek-3] wrap-extra-kids(trafo,ActualArg, ActualArg*,4) = ATmakeList3(ActualArg*)
[wek-4] wrap-extra-kids(trafo,ActualArg, ActualArg*,5) = ATmakeList4(ActualArg*)
[wek-5] wrap-extra-kids(trafo,ActualArg, ActualArg*,6) = ATmakeList5(ActualArg*)
[wek-6] wrap-extra-kids(trafo,ActualArg, ActualArg*,7) = ATmakeList6(ActualArg*)
%% WARNING: HIER MOET NOG 1 AFGETROKKEN WORDEN VAN Int
[default-wek] wrap-extra-kids(trafo,ActualArg, ActualArg*,Int) = 
               ATmakeList(Int,ActualArg*)

[wek-1] wrap-extra-kids(accu,ActualArg1,ActualArg2,ActualArg*,2) = ATempty
[wek-2] wrap-extra-kids(accu,ActualArg1,ActualArg2,ActualArg*,3)= ATmakeList1(ActualArg*)
[wek-3] wrap-extra-kids(accu,ActualArg1,ActualArg2,ActualArg*,4)= ATmakeList2(ActualArg*)
[wek-4] wrap-extra-kids(accu,ActualArg1,ActualArg2,ActualArg*,5)= ATmakeList3(ActualArg*)
[wek-5] wrap-extra-kids(accu,ActualArg1,ActualArg2,ActualArg*,6)= ATmakeList4(ActualArg*)
[wek-6] wrap-extra-kids(accu,ActualArg1,ActualArg2,ActualArg*,7)= ATmakeList5(ActualArg*)
[default-wek] 
        wrap-extra-kids(accu,ActualArg1,ActualArg2,ActualArg*,Int)=
          ATmakeList(Int,ActualArg*)

[wek-1] wrap-extra-kids(accutrafo,ActualArg1,ActualArg2,ActualArg*,2) = ATempty
[wek-2] wrap-extra-kids(accutrafo,ActualArg1,ActualArg2,ActualArg*,3)= ATmakeList1(ActualArg*)
[wek-3] wrap-extra-kids(accutrafo,ActualArg1,ActualArg2,ActualArg*,4)= ATmakeList2(ActualArg*)
[wek-4] wrap-extra-kids(accutrafo,ActualArg1,ActualArg2,ActualArg*,5)= ATmakeList3(ActualArg*)
[wek-5] wrap-extra-kids(accutrafo,ActualArg1,ActualArg2,ActualArg*,6)= ATmakeList4(ActualArg*)
[wek-6] wrap-extra-kids(accutrafo,ActualArg1,ActualArg2,ActualArg*,7)= ATmakeList5(ActualArg*)
[default-wek] 
        wrap-extra-kids(accutrafo,ActualArg1,ActualArg2,ActualArg*,Int)=
          ATmakeList(Int,ActualArg*)

[mts-0] remove-returns-list(Funid) = Funid2,
        get-traversal-strategy(Funid2) = bottom-up,
        get-traversal-type(Funid2) != accutrafo,
        make-traversal-expression(Funid2,ActualArg*,Aint) = Expression,
        traversal-result-argument(Funid2) = Expression2,
        Stat = (Expression2 = Expression);
        ===>
        make-traversal-stats(Funid,ActualArg*,Aint) = Stat

[mts-1] remove-returns-list(Funid) = Funid2,
        get-traversal-strategy(Funid2) = bottom-up,
        get-traversal-type(Funid2) = accutrafo,
        make-traversal-expression(Funid2,ActualArg*,Aint) = Expression,
        Stat+ = (arg0 = Expression); 
               (arg1 = accutrafo_tuple_second(arg0));
               (arg0 = accutrafo_tuple_first(arg0));
        ===>
        make-traversal-stats(Funid,ActualArg*,Aint) = Stat+

[default-mts] make-traversal-stats(Funid,ActualArg*,Aint) =

[mte-0] remove-returns-list(Funid) = Funid2,
        get-traversal-type(Funid2) = trafo,
        Funid2 = funid(Char*),
        wrap-extra-kids(trafo, ActualArg*,Aint) = Expression
        ====>
        make-traversal-expression(Funid,ActualArg*,Aint) =
         call_kids_trafo(identifier(Char*),arg0,Expression)

[mte-1] remove-returns-list(Funid) = Funid2,
        get-traversal-type(Funid2) = accu,
        Funid2 = funid(Char*),
        wrap-extra-kids(accu, ActualArg*,Aint) = Expression
        ====>
        make-traversal-expression(Funid,ActualArg*,Aint) =
         call_kids_accu(identifier(Char*),arg0,arg1,Expression)

[mte-2] remove-returns-list(Funid) = Funid2,
        get-traversal-type(Funid2) = accutrafo,
        Funid2 = funid(Char*),
        wrap-extra-kids(accutrafo, ActualArg*,Aint) = Expression
        ====>
        make-traversal-expression(Funid,ActualArg*,Aint) =
         call_kids_accutrafo(identifier(Char*), arg0, arg1, Expression)

[gra] get-traversal-type(Funid) = trafo
      ====>
      traversal-result-argument(Funid) = arg0

[gra] get-traversal-type(Funid) = accu
      ====>
      traversal-result-argument(Funid) = arg1

[gra] get-traversal-type(Funid) = accutrafo
      ====>
      traversal-result-argument(Funid) = make_accutrafo_tuple(arg0,arg1)

  [mcr-1'1] make-c-rules() =

  [mcr-1'2] make-c-rule(Rule) = C-rule,
            make-c-rules(Rule*) = C-rule*
            =============================
            make-c-rules(Rule;Rule*) = C-rule;C-rule*

  [mcr-2'1] get-funid(Term1) = Funid,
            get-funargs(Term1) = Term+,
            code-args(Term+,0) = (Fv-path*,Cenv1),
            funargs2cexp(Term+,0) = Cenv2
            =============================
            make-c-rule(Term1 = Term2) = [Fv-path*||Term2|Cenv1|Cenv2|Funid]

  [mcr-2'2] get-funid(Term1) = Funid,
            get-funargs(Term1) =
            ====================
            make-c-rule(Term1 = Term2) = [||Term2|()|()|Funid]

  [mcr-2'3] get-funid(Term1) = Funid,
            get-funargs(Term1) = Term+,
            code-args(Term+,0) = (Fv-path*,Cenv1),
            funargs2cexp(Term+,0) = Cenv2
            =============================
            make-c-rule(Cond* ==> Term1 = Term2) = [Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid]

  [mcr-2'4] get-funid(Term1) = Funid,
            get-funargs(Term1) =
            ====================
            make-c-rule(Cond* ==> Term1 = Term2) = [|Cond*|Term2|()|()|Funid]

  [mcr-2'5] get-funid(Term1) = Funid,
            get-funargs(Term1) = Term+,
            code-args(Term+,0) = (Fv-path*,Cenv1),
            funargs2cexp(Term+,0) = Cenv2
            =============================
            make-c-rule(default:Term1 = Term2) = [Fv-path*||Term2|Cenv1|Cenv2|Funid]

  [mcr-2'6] get-funid(Term1) = Funid,
            get-funargs(Term1) =
            ====================
            make-c-rule(default:Term1 = Term2) = [||Term2|()|()|Funid]

  [mcr-2'7] get-funid(Term1) = Funid,
            get-funargs(Term1) = Term+,
            code-args(Term+,0) = (Fv-path*,Cenv1),
            funargs2cexp(Term+,0) = Cenv2
            =============================
            make-c-rule(default:Cond* ==> Term1 = Term2) = [Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid]

  [mcr-2'8] get-funid(Term1) = Funid,
            get-funargs(Term1) =
            ====================
            make-c-rule(default:Cond* ==> Term1 = Term2) = [|Cond*|Term2|()|()|Funid]

  [ca-1'1] code-args(,Aint*) = (,())

  [ca-1'2] is-var-term(Term) = true,
           code-args(Term*,Aint*,succ(Aint)) = (Fv-path*,Cenv1),
           make-atmp(Aint*,Aint) = CConstant,
           Cenv1 ++ ((Term,CConstant)) = Cenv2
           ===================================
           code-args(Term,Term*,Aint*,Aint) = ((Term,Aint*,Aint),Fv-path*,Cenv2)

  [ca-1'3] is-var-term(Term) = false,
           get-funargs(Term) = ,
           code-args(Term*,Aint*,succ(Aint)) = (Fv-path*,Cenv)
           ===================================================
           code-args(Term,Term*,Aint*,Aint) = ((Term,Aint*,Aint),Fv-path*,Cenv)

  [ca-1'4] is-var-term(Term) = false,
           get-funargs(Term) = Term+,
           get-funid(Term) = Funid,
           code-args(Term+,Aint*,Aint,0) = (Fv-path*1,Cenv1),
           code-args(Term*,Aint*,succ(Aint)) = (Fv-path*2,Cenv2)
           =====================================================
           code-args(Term,Term*,Aint*,Aint) =
             (((Funid,Aint*,Aint),Fv-path*1),Fv-path*2,Cenv1++Cenv2)

  [fa2ce-1'1] funargs2cexp(Term,natcon(Char*)) = ((Term,identifier("a""r""g" Char*)))

  [fa2ce-1'2] Aint = natcon(Char*),
              funargs2cexp(Term+,succ(Aint)) = Cenv4
              ======================================
              funargs2cexp(Term,Term+,Aint) = ((Term,identifier("a""r""g" Char*))) ++ Cenv4

  [mce-1'1] is-char(Funid) = true,
            make-atmp(Aint+) = ActualArg1,
            translate-char(Funid) = ActualArg2
            ==================================
            make-c-expression((Funid,Aint+),Namepair*) =
              is_char(ActualArg1,ActualArg2)

  [mce-1'2] make-atmp(Aint+) = CConstant,
            is-char(Funid) = false,
            get-funid(Funid,Namepair*) = Funid2,
            remove-returns-list(Funid2) = funid(Char*)
            =========================================
            make-c-expression((Funid,Aint+),Namepair*) =
              check_sym(CConstant,identifier(Char* "s""y""m"))

  [mce-2'1] is-char(Funid) = true,
            translate-char(Funid) = ActualArg2
            ==================================
            make-c-expression(Funid,Expression,Namepair*) =
              is_char(Expression,ActualArg2)

  [mce-2'2] is-char(Funid) = false,
            get-funid(Funid,Namepair*) = Funid2,
            remove-returns-list(Funid2) = funid(Char*)
            =========================================
            make-c-expression(Funid,Expression,Namepair*) =
              check_sym(Expression,identifier(Char* "s""y""m"))

  [go-1'1] get-ofs([Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) = Funid

%% If there are no rewrite rules we are finished.
  [soofa-1'1] select-on-ofs-first-arg() = (,)

%% If a rule has a variable as first argument it is appended to the second set.
  [soofa-1'2] select-on-ofs-first-arg(C-rule*) = (C-rule*1,C-rule*2)
              ======================================================
              select-on-ofs-first-arg([|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                (C-rule*1,[|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*2)

%% If a rule has a variable as first argument it is appended to the second set.
  [soofa-1'3] is-var-term(Term1) = true,
              select-on-ofs-first-arg(C-rule*) = (C-rule*1,C-rule*2)
              ==========================================================
              select-on-ofs-first-arg([(Term1,Aint+),Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                (C-rule*1,[(Term1,Aint+),Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*2)

%% If a rule has not a variable as first argument, its ofs is used to select
%% the other rules of the set.
  [soofa-1'4] is-var-term(Term1) = false,
              get-funid(Term1) = Funid2,
              select-on-ofs-first-arg(Funid2,C-rule*) = (C-rule*1,C-rule*2,C-rule*3)
              ======================================================================
              select-on-ofs-first-arg([(Term1,Aint+),Fv-path*|
                                       Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                ([(Term1,Aint+),Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1,
                 C-rule*2)

  [soofa-1'5] get-funid(Term1) = Funid2,
              select-on-ofs-first-arg(Funid2,C-rule*) = (C-rule*1,C-rule*2,C-rule*3)
              ======================================================================
              select-on-ofs-first-arg([((Term1,Aint+),Fv-path+),Fv-path*|
                                       Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                ([((Term1,Aint+),Fv-path+),Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1,
                 C-rule*2)

%% If there are no rewrite rules we are finished.
  [soofa-2'1] select-on-ofs-first-arg(Funid,) = (,,)

%% If a rule has a variable as first argument it is appended to the second set.
  [soofa-2'2] is-var-term(Term1) = true,
              select-on-ofs-first-arg(Funid1,C-rule*) = (C-rule*1,C-rule*2,C-rule*3)
              ======================================================================
              select-on-ofs-first-arg(Funid1,
                                      [(Term1,Aint+),Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                (C-rule*1,
                 C-rule*2;[(Term1,Aint+),Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid],
                 C-rule*3)

%% If a rule has not a variable as first argument, but the ofs of the first
%% argument equal the funid looked for this rule is added to the first set.
  [soofa-2'3] is-var-term(Term1) = false,
              get-funid(Term1) = Funid1,
              select-on-ofs-first-arg(Funid1,C-rule*) = (C-rule*1,C-rule*2,C-rule*3)
              ======================================================================
              select-on-ofs-first-arg(Funid1,[(Term1,Aint+),Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                ([(Term1,Aint+),Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1,C-rule*2,C-rule*3)

%% Otherwise, it is added to the second set.
  [soofa-2'4] is-var-term(Term1) = false,
              get-funid(Term1) = Funid3,
              Funid1 != Funid3,
              select-on-ofs-first-arg(Funid1,C-rule*) = (C-rule*1,C-rule*2,C-rule*3)
              ======================================================================
              select-on-ofs-first-arg(Funid1,[(Term1,Aint+),Fv-path*|
                                              Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                (C-rule*1,[(Term1,Aint+),Fv-path*|
                           Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*2,C-rule*3)

  [soofa-2'5] get-funid(Term1) = Funid1,
              select-on-ofs-first-arg(Funid1,C-rule*) = (C-rule*1,C-rule*2,C-rule*3)
              ======================================================================
              select-on-ofs-first-arg(Funid1,[((Term1,Aint+),Fv-path+),Fv-path*|
                                              Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                ([((Term1,Aint+),Fv-path+),Fv-path*|
                  Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1,
                 C-rule*2,C-rule*3)

%% Otherwise, it is added to the second set.
  [soofa-2'6] get-funid(Term1) = Funid3,
              Funid1 != Funid3,
              select-on-ofs-first-arg(Funid1,C-rule*) = (C-rule*1,C-rule*2,C-rule*3)
              ======================================================================
              select-on-ofs-first-arg(Funid1,[((Term1,Aint+),Fv-path+),Fv-path*|
                                              Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                (C-rule*1,
                 [((Term1,Aint+),Fv-path+),Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*2,
                 C-rule*3)

%% If there are no rewrite rules we are finished.
  [soslp-1'1] select-on-same-list-pat() = (,)

%% If a rule has a variable as first argument it is appended to the second set.
  [soslp-1'2] select-on-same-list-pat(Fv-path,C-rule*) = (C-rule*1,C-rule*2)
              ==============================================================
              select-on-same-list-pat([Fv-path,Fv-path*|
                                       Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                ([Fv-path,Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1,
                 C-rule*2)

%% If there are no rewrite rules we are finished.
  [soslp-2'1] select-on-same-list-pat(Fv-path,) = (,)

  [soslp-2'2] select-on-same-list-pat(Fv-path,C-rule*) = (C-rule*1,C-rule*2)
              ==============================================================
              select-on-same-list-pat(Fv-path,[Fv-path,Fv-path*|
                                      Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                ([Fv-path,Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1,
                 C-rule*2)

%% Otherwise, it is added to the second set.
  [soslp-2'3] Fv-path1 != Fv-path2,
              select-on-same-list-pat(Fv-path1,C-rule*) = (C-rule*1,C-rule*2)
              ===============================================================
              select-on-same-list-pat(Fv-path1,[Fv-path2,Fv-path*|
                                      Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*) =
                (C-rule*1,
                 [Fv-path2,Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*2)

%% If there are no rewrite rules we are finished.
  [rofa-1'1] remove-ofs-first-arg() =

%% If a rule has a variable as first argument it is appended to the second set.
  [rofa-1'2] remove-ofs-first-arg(C-rule*1) = C-rule*2
             =========================================
             remove-ofs-first-arg([(Term1,Aint+),Fv-path+|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1) =
               [Fv-path+|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*2

  [rofa-1'3] remove-ofs-first-arg(C-rule*1) = C-rule*2
             =========================================
             remove-ofs-first-arg([((Term1,Aint+),Fv-path+),Fv-path*|
                                   Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1) =
               [Fv-path+,Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*2

%% If there are no rewrite rules we are finished.
  [rfa-1'1] remove-first-arg() =

%% If a rule has a variable as first argument it is appended to the second set.
  [rfa-1'2] remove-first-arg(C-rule*1) = C-rule*2
            ====================================
            remove-first-arg([Fv-path,Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1) =
               [Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*2

  [gfvp-1'1] get-first-vf-path([(Term1,Aint+),Fv-path*|
                                Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1) = (Term1,Aint+)

  [gfvp-1'2] get-first-vf-path([((Term1,Aint+),Fv-path+),Fv-path*|
                                Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1) = (Term1,Aint+)

  [isvp-1'1] is-single-vf-path([(Term1,Aint+)|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1) = true

  [default-isvp-1'2] is-single-vf-path(C-rule+) = false

  [isvp-1'1] is-empty-vf-path([|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1) = true

  [default-isvp-1'2] is-empty-vf-path(C-rule+) = false

  [ma-1'1] make-atmp(natcon(Char+)) = identifier("a""r""g" Char+) %%%identifier("t""m""p" Char+)

  [ma-1'2] make-atmp2(Aint+) = identifier(Char+2)
           ======================================
           make-atmp(Aint+,natcon(Char+1)) = identifier(Char+2 Char+1)

  [ma-2'1] make-atmp2(natcon(Char+)) = identifier("a""t""m""p" Char+)

  [ma-2'1] make-atmp2(Aint+) = identifier(Char+2)
           ======================================
           make-atmp2(Aint+,natcon(Char+1)) = identifier(Char+2 Char+1)

  [mss-1'1] make-select-stat(Aint) =

  [mss-1'2] Aint = natcon(Char+1),
            make-atmp2(Aint+,Aint) = CConstant1,
            make-atmp(Aint+) = CConstant2
            =============================
            make-select-stat(Aint+,Aint) =
              ATerm CConstant1 = identifier("a""r""g""_"Char+1)(CConstant2);

  %% we make different select stats for ignored function symbols. Their
  %% arguments are selected already, we only need the correct variables to be
  %% declared. 

  [miss-1'1] make-ignored-select-stat(Aint) =

  [miss-1'2] make-atmp2(Aint+,Aint) = CConstant1,
            make-atmp(Aint+) = CConstant2
            =============================
            make-ignored-select-stat(Aint+,Aint) =
              ATerm CConstant1 = CConstant2;

  [mad-1'1] make-atmp2(Aint+,Aint) = CConstant
            ==================================
            make-array-decl(Aint+,Aint) =
              ATerm CConstant[2];

  [md-1'1] make-atmp2(Aint+,Aint) = CConstant
           ===================================
           make-decl(Aint+,Aint) =
              ATerm CConstant;

  [soc-1'1] select-on-conds() = (,)

  [soc-1'2] select-on-conds(C-rule*) = (C-rule*1,C-rule*2)
            ==============================================
            select-on-conds([Fv-path*||Term2|Cenv1|Cenv2|Funid]; C-rule*) =
              (C-rule*1,[Fv-path*||Term2|Cenv1|Cenv2|Funid]; C-rule*2)

  [soc-1'3] select-on-conds(C-rule*) = (C-rule*1,C-rule*2)
            ==============================================
            select-on-conds([Fv-path*|Cond+|Term2|Cenv1|Cenv2|Funid]; C-rule*) =
              ([Fv-path*|Cond+|Term2|Cenv1|Cenv2|Funid]; C-rule*1,C-rule*2)

%% Selecting all conditional rewrite rules with the same left-hand side
%% in the first condition.
%% The first element of the {\tt RuleTuple} contains in this
%% case all conditional rewrite rules which have the same left-hand side
%% in its first condition,
%% the second argument contains all other conditional rewrite rules.
  [sslc-1'1] select-same-lhs-cond(C-rule,) = (C-rule,)

%% The left-hand side matches so the rule is added to the
%% first list in the tuple.
  [sslc-1'2] select-same-lhs-cond(C-rule,
                                  C-rule*) = (C-rule*1,C-rule*2)
             ===================================================
             select-same-lhs-cond(C-rule,C-rule; C-rule*) =
               (C-rule*1,C-rule*2)

%% The left-hand side matches so the rule is added to the
%% first list in the tuple.
  [sslc-1'3] C-rule1 != C-rule2,
             C-rule1 = [Fv-path*1|Ct-lhs1 =: Ct-rhs1 & Cond*1|Term1|Cenv1|Cenv2|Funid1],
             C-rule2 = [Fv-path*2|Ct-lhs2 =: Ct-rhs2 & Cond*2|Term2|Cenv3|Cenv4|Funid2],
             Ct-lhs1 = Ct-lhs2,
             select-same-lhs-cond(C-rule1,
                                  C-rule*) = (C-rule*1,C-rule*2)
             ===================================================
             select-same-lhs-cond(C-rule1,C-rule2; C-rule*) =
               (C-rule2; C-rule*1,C-rule*2)

  [sslc-1'4] C-rule1 != C-rule2,
             C-rule1 = [Fv-path*1|Ct-lhs1 =: Ct-rhs1 & Cond*1|Term1|Cenv1|Cenv2|Funid1],
             C-rule2 = [Fv-path*2| |Term2|Cenv3|Cenv4|Funid2],
             select-same-lhs-cond(C-rule1,
                                  C-rule*) = (C-rule*1,C-rule*2)
             ===================================================
             select-same-lhs-cond(C-rule1,C-rule2; C-rule*) =
               (C-rule*1,C-rule2; C-rule*2)

%% The left-hand side differ, so it is added to the second list
%% in the tuple.
  [sslc-1'5] Ct-lhs1 != Ct-lhs2,
             select-same-lhs-cond([Fv-path*1|Ct-lhs1 =: Ct-rhs1 & Cond*1|
                                  Term1|Cenv1|Cenv2|Funid1],
                                  C-rule*) = (C-rule*1,C-rule*2)
             ===================================================
             select-same-lhs-cond([Fv-path*1|Ct-lhs1 =: Ct-rhs1 & Cond*1|
                                   Term1|Cenv1|Cenv2|Funid1],
                                  [Fv-path*2|Ct-lhs2 =: Ct-rhs2 & Cond*2|
                                   Term2|Cenv3|Cenv4|Funid2]; C-rule*) =
               (C-rule*1,[Fv-path*2|Ct-lhs2 =: Ct-rhs2 & Cond*2|
                          Term2|Cenv3|Cenv4|Funid2]; C-rule*2)

%% Selecting all conditional rewrite rules with the same left-hand side
%% in the first condition.
%% The first element of the {\tt RuleTuple} contains in this
%% case all conditional rewrite rules which have the same left-hand side
%% in its first condition,
%% the second argument contains all other conditional rewrite rules.
  [sslc-1'1] select-same-rhs-cond(C-rule,) = (C-rule,)

%% The left-hand side matches so the rule is added to the
%% first list in the tuple.
  [sslc-1'2] select-same-rhs-cond(C-rule,
                                  C-rule*) = (C-rule*1,C-rule*2)
             ===================================================
             select-same-rhs-cond(C-rule,C-rule; C-rule*) =
               (C-rule*1,C-rule*2)

  [sslc-1'3] C-rule1 != C-rule2,
             C-rule1 = [Fv-path*1|Ct-lhs1 =: Ct-rhs1 & Cond*1|Term1|Cenv1|Cenv2|Funid1],
             C-rule2 = [Fv-path*2|Ct-lhs2 =: Ct-rhs2 & Cond*2|Term2|Cenv3|Cenv4|Funid2],
             Ct-lhs1 = Ct-lhs2,
             Ct-rhs1 = Ct-rhs2,
             select-same-rhs-cond(C-rule1,
                                  C-rule*) = (C-rule*1,C-rule*2)
             ===================================================
             select-same-rhs-cond(C-rule1,
                                  C-rule2; C-rule*) =
               (C-rule2; C-rule*1,C-rule*2)

%% The left-hand side differ, so it is added to the second list
%% in the tuple.
  [sslc-1'4] Ct-rhs1 != Ct-rhs2,
             select-same-rhs-cond([Fv-path*1|Ct-lhs =: Ct-rhs1 & Cond*1|
                                  Term1|Cenv1|Cenv2|Funid1],
                                  C-rule*) = (C-rule*1,C-rule*2)
             ===================================================
             select-same-rhs-cond([Fv-path*1|Ct-lhs =: Ct-rhs1 & Cond*1|
                                   Term1|Cenv1|Cenv2|Funid1],
                                  [Fv-path*2|Ct-lhs =: Ct-rhs2 & Cond*2|
                                   Term2|Cenv3|Cenv4|Funid2]; C-rule*) =
               (C-rule*1,[Fv-path*2|Ct-lhs =: Ct-rhs2 & Cond*2|
                          Term2|Cenv3|Cenv4|Funid2]; C-rule*2)

  [sslc-1'1] select-conds-on-first-term(Term,) = (,)

%% The left-hand side matches so the rule is added to the
%% first list in the tuple.
  [sslc-1'2] select-conds-on-first-term(Term,
                                       C-rule*) = (C-rule*1,C-rule*2)
             ========================================================
             select-conds-on-first-term(Term,
                                       [Fv-path*2|term_equal(Term,Term2) =: Ct-rhs2 & Cond*2|
                                        Term4|Cenv3|Cenv4|Funid]; C-rule*) =
               ([Fv-path*2|term_equal(Term,Term2) =: Ct-rhs2 & Cond*2|
                 Term4|Cenv3|Cenv4|Funid]; C-rule*1,C-rule*2)

%% The left-hand side differ, so it is added to the second list
%% in the tuple.
  [default-sslc-1'3] select-conds-on-first-term(Term1,
                                                C-rule*) = (C-rule*1,C-rule*2)
                     ========================================================
                     select-conds-on-first-term(Term1,
                                                [Fv-path*|Cond*|
                                                 Term4|Cenv3|Cenv4|Funid]; C-rule*) =
                       (C-rule*1,[Fv-path*|Cond*|Term4|Cenv3|Cenv4|Funid]; C-rule*2)

  [sslc-1'1] select-conds-on-second-term(Term,) = (,)

%% The left-hand side matches so the rule is added to the
%% first list in the tuple.
  [sslc-1'2] select-conds-on-second-term(Term,
                                         C-rule*) = (C-rule*1,C-rule*2)
             ==========================================================
             select-conds-on-second-term(Term,
                                       [Fv-path*2|term_equal(Term1,Term) =: Ct-rhs2 & Cond*2|
                                        Term4|Cenv3|Cenv4|Funid]; C-rule*) =
               ([Fv-path*2|term_equal(Term1,Term) =: Ct-rhs2 & Cond*2|
                 Term4|Cenv3|Cenv4|Funid]; C-rule*1,C-rule*2)

%% The left-hand side differ, so it is added to the second list
%% in the tuple.
  [default-sslc-1'3] select-conds-on-second-term(Term1,
                                                 C-rule*) = (C-rule*1,C-rule*2)
                     ==========================================================
                     select-conds-on-second-term(Term1,
                                                 [Fv-path*|Cond*|
                                                  Term4|Cenv3|Cenv4|Funid]; C-rule*) =
                       (C-rule*1,[Fv-path*|Cond*|Term4|Cenv3|Cenv4|Funid]; C-rule*2)

  [sslc-1'1] replace-first-term(Term,Cenv,) =

%% The left-hand side matches so the rule is added to the
%% first list in the tuple.
  [sslc-1'2] replace-first-term(Term1,Cenv1,C-rule*1) = C-rule*2
             ===================================================
             replace-first-term(Term1,Cenv1,
                                [Fv-path*2|term_equal(Term2,Term3) =: Ct-rhs2 & Cond*2|
                                       Term4|Cenv2|Cenv3|Funid]; C-rule*1) =
               [Fv-path*2|term_equal(Term1,Term3) =: Ct-rhs2 & Cond*2|
                Term4|Cenv2++Cenv1|Cenv3++Cenv1|Funid]; C-rule*2

  [sslc-1'1] replace-second-term(Term,Cenv,) =

%% The left-hand side matches so the rule is added to the
%% first list in the tuple.
  [sslc-1'2] replace-second-term(Term1,Cenv1,C-rule*1) = C-rule*2
             ====================================================
             replace-second-term(Term1,Cenv1,
                                 [Fv-path*2|term_equal(Term2,Term3) =: Ct-rhs2 & Cond*2|
                                  Term4|Cenv2|Cenv3|Funid]; C-rule*1) =
               [Fv-path*2|term_equal(Term2,Term1) =: Ct-rhs2 & Cond*2|
                Term4|Cenv2++Cenv1|Cenv3++Cenv1|Funid]; C-rule*2

%% If there are no rewrite rules we are finished.
  [rfc-1'1] remove-first-cond() =

%% If a rule has a variable as first argument it is appended to the second set.
  [rfc-1'2] remove-first-cond(C-rule*1) = C-rule*2
            ======================================
            remove-first-cond([Fv-path*|Cond & Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1) =
               [Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid];C-rule*2

%% If there are no rewrite rules we are finished.
  [rfc-2'1] remove-first-cond-and-add-env(,Cenv) =

%% If a rule has a variable as first argument it is appended to the second set.
  [rfc-2'2] remove-first-cond-and-add-env(C-rule*1,Cenv) = C-rule*2
            =======================================================
            remove-first-cond-and-add-env([Fv-path*|Cond & Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1,Cenv) =
               [Fv-path*|Cond*|Term2|Cenv1++Cenv|Cenv2++Cenv|Funid];C-rule*2

%% If there are no rewrite rules we are finished.
  [ae-2'1] add-env(,Cenv) =

%% If a rule has a variable as first argument it is appended to the second set.
  [ae-2'2] add-env(C-rule*1,Cenv) = C-rule*2
           =================================
           add-env([Fv-path*|Cond*|Term2|Cenv1|Cenv2|Funid]; C-rule*1,Cenv) =
               [Fv-path*|Cond*|Term2|Cenv1++Cenv|Cenv2++Cenv|Funid];C-rule*2

  [mc-1'1] remove-c-brackets(Stat*1) = Stat*2
           ==================================
           make-cond(Ltest,Stat*1) = if(Ltest) {Stat*2}

  [mc-1'2] make-cond(Ltest,Stat*,) = make-cond(Ltest,Stat*)

  [mc-1'3] remove-c-brackets(Stat*1) = Stat*3,
           remove-c-brackets(Stat*2) = Stat*4,
           if(Ltest) {Stat*3} ++ Stat*4 = Stat*5
           =====================================
           make-cond(Ltest,Stat*1,Stat*2) = Stat*5

  [mc-2'1] make-cond(Stat+0 if(Ltest) {Stat*1},) = Stat+0 if(Ltest) {Stat*1}

  [mc-2'2] remove-c-brackets(Stat*2) = Stat*3,
           Stat+0 if(Ltest) {Stat*1} ++ Stat*3 = Stat*4
           ============================================
           make-cond(Stat+0 if(Ltest) {Stat*1},Stat*2) = Stat*4

  [default-mc-2'3] make-cond(Stat+1,Stat*2) = {Stat+1 ++ Stat*2}

  [rb-1'1] remove-c-brackets({Stat*}) = Stat*

  [rb-1'2] Decl* ++d Stat* = Stat
           ======================
           remove-c-brackets({Decl* Stat*}) = Stat

  [default-rb-1'3] remove-c-brackets(Stat*) = Stat*

  [mta-1'1] make-tmp-array(0) =

  [default-mta-1'2] make-tmp-array(natcon(Char*)) =
                      ATerm tmp[integer-constant(Char*)];

  [mta-1'1] make-ltmp-array(0) =

  [default-mta-1'2] make-ltmp-array(natcon(Char*)) =
                      ATerm ltmp[integer-constant(Char*)];

  [mc-1'1] remove-c-brackets(Stat*1) = Stat*2
           ==================================
           make-if-then-else(Ltest,Stat*1) = if(Ltest) {Stat*2}

  [mc-3'1] make-if-then-else(t,Ltest,Stat*1,) = make-if-then-else(Ltest,Stat*1)

  [mc-3'2] make-if-then-else(f,Ltest,Stat*1,) = make-if-then-else(!Ltest,Stat*1)

  [mc-3'3] remove-c-brackets(Stat*1) = Stat*3,
           Stat*2 != ,
           remove-c-brackets(Stat*2) = Stat*4
           ==================================
           make-if-then-else(t,Ltest,Stat*1,Stat*2) = if(Ltest) {Stat*3} else {Stat*4}

  [mc-3'4] remove-c-brackets(Stat*1) = Stat*3,
           Stat*2 != ,
           remove-c-brackets(Stat*2) = Stat*4
           ==================================
           make-if-then-else(f,Ltest,Stat*1,Stat*2) = if(!Ltest) {Stat*3} else {Stat*4}

  [ca-1'1] cnt-args() = 0

  [ca-1'2] cnt-args(ActualArg,ActualArg*) = 1 + cnt-args(ActualArg*)
