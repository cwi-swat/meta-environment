module muasf2c/Rules2C-Aux

imports utils/Integers-Extended
imports c/C-Basics
imports muasf/MuASF-Equations-Ops


exports
  sorts C-Rule C-RuleList C-RuleListPair FV-Path FV-PathList PathList-Cenv
        SlI-tuple SRI-tuple C-RuleListTriple
  context-free syntax
    "(" Term "," {IntCon ","}+ ")"                              -> FV-Path
    {FV-Path ","}*                                            -> FV-PathList
    "(" {FV-Path ","}+ ")"                                    -> FV-Path
    "[" {FV-Path ","}* "|" {Cond "&"}* "|"
        Term "|" C-env "|" C-env "|" FunId "]"                -> C-Rule
    {C-Rule ";"}*                                             -> C-RuleList
    "(" {C-Rule ";"}* "," {C-Rule ";"}* ")"                   -> C-RuleListPair
    "(" {C-Rule ";"}* "," {C-Rule ";"}* "," {C-Rule ";"}* ")" -> C-RuleListTriple
    "(" FV-PathList "," C-env ")"                             -> PathList-Cenv
    "(" Statement-list-opt "," Statement-list-opt ","
        {C-Rule ";"}* "," IntCon ")"                          -> SRI-tuple
    "(" Statement-list-opt "," IntCon ")"                     -> SlI-tuple

exports
  context-free syntax
    make-c-rules({Rule ";"}*)                           -> C-RuleList
    make-c-rule(Rule)                                   -> C-Rule
    code-args({Term ","}*,{IntCon ","}*)                -> PathList-Cenv
    funargs2cexp({Term ","}+,IntCon)                    -> C-env
    make-c-expression(FunId,Expression,{NamePair ","}*) -> Expression
    make-c-expression(FV-Path,{NamePair ","}*)          -> Expression
    get-ofs({C-Rule ";"}+)                              -> FunId

exports
  context-free syntax

    select-on-ofs-first-arg({C-Rule ";"}*)             -> C-RuleListPair
    select-on-ofs-first-arg(FunId,{C-Rule ";"}*)       -> C-RuleListTriple
    select-on-same-list-pat({C-Rule ";"}*)             -> C-RuleListPair
    select-on-same-list-pat(FV-Path,{C-Rule ";"}*)     -> C-RuleListPair
    select-on-conds({C-Rule ";"}*)                     -> C-RuleListPair
    select-same-lhs-cond(C-Rule,{C-Rule ";"}*)         -> C-RuleListPair
    select-same-rhs-cond(C-Rule,{C-Rule ";"}*)         -> C-RuleListPair
    select-conds-on-first-term(Term,{C-Rule ";"}*)     -> C-RuleListPair
    select-conds-on-second-term(Term,{C-Rule ";"}*)    -> C-RuleListPair
    replace-first-term(Term,C-env,{C-Rule ";"}*)       -> C-RuleList
    replace-second-term(Term,C-env,{C-Rule ";"}*)      -> C-RuleList
    remove-ofs-first-arg({C-Rule ";"}*)                -> C-RuleList
    remove-first-arg({C-Rule ";"}*)                    -> C-RuleList
    remove-first-cond({C-Rule ";"}*)                   -> C-RuleList
    remove-first-cond-and-add-env({C-Rule ";"}*,C-env) -> C-RuleList
    add-env({C-Rule ";"}*,C-env)                       -> C-RuleList

exports
  context-free syntax
    get-first-vf-path({C-Rule ";"}+)     -> FV-Path
    is-empty-vf-path({C-Rule ";"}*)      -> Bool
    is-single-vf-path({C-Rule ";"}*)     -> Bool
    make-atmp({IntCon ","}*)             -> Identifier
    make-atmp2({IntCon ","}+)            -> Identifier
    make-select-stat({IntCon ","}*)      -> Declaration-list-opt
    make-ignored-select-stat({IntCon ","}*) -> Declaration-list-opt

    make-array-decl({IntCon ","}+)       -> Declaration-list
    make-decl({IntCon ","}+)             -> Declaration-list
    make-tmp-array(IntCon)               -> Declaration-list-opt
    make-ltmp-array(IntCon)              -> Declaration-list-opt
    cnt-args({Expression ","}*)          -> Int

exports
  context-free syntax
    make-cond(Expression,
              Statement-list-opt,Statement-list-opt)       -> Statement-list-opt
    make-cond(Expression,Statement-list-opt)               -> Statement-list-opt
    make-cond(Statement-list-opt,Statement-list-opt)       -> Statement-list-opt
    make-if-then-else(Term,Expression, Statement-list-opt,
                      Statement-list-opt)                  -> Statement-list-opt
    make-if-then-else(Expression, Statement-list-opt)      -> Statement-list-opt

exports
  context-free syntax
    wrap-extra-kids(TraversalType, Argument-expression-list,Int) -> Expression
    make-traversal-stats(FunId,Argument-expression-list, IntCon) -> Statement-list-opt
    make-traversal-expression(FunId,Argument-expression-list,IntCon) -> Expression
    traversal-result-argument(FunId) -> Expression

hiddens
  context-free syntax
    remove-c-brackets(Statement-list-opt) -> Statement-list-opt

exports
  variables
    "C-rule"[0-9]*     -> C-Rule
    "C-rule*"[0-9]*    -> {C-Rule ";"}*
    "C-rule+"[0-9]*    -> {C-Rule ";"}+
    "Fv-path"[0-9]*    -> FV-Path
    "Fv-path*"[0-9]*   -> {FV-Path ","}*
    "Fv-path+"[0-9]*   -> {FV-Path ","}+
    "Aint*"[0-9]*      -> {IntCon ","}*
    "Aint+"[0-9]*      -> {IntCon ","}+
    "Int"[0-9]*        -> Int
    "Aexp"[0-9]*       -> Expression
    "Expr"[0-9]*       -> Expression
    "Expression"[0-9]* -> Expression
    "Cint"[0-9]*       -> Integer-constant
hiddens
  variables
    "Char"[0-9]*    -> CHAR
    "Char*"[0-9]*   -> CHAR*
    "Char+"[0-9]*   -> CHAR+
    "Ct-lhs"[0-9]*  -> Term
    "Ct-rhs"[0-9]*  -> Term
