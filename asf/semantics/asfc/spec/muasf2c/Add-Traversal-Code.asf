equations

%% The extra arguments to each traversal function are passed to the
%% generic asc-support call_kids... functions. Because their number is
%% unknown they are wrapped by an ATermList:

[] extra() = ATempty
[] extra(Expression) = ATmakeList1(Expression)
[] extra(Expression1, Expression2) = ATmakeList2(Expression1, Expression2)
[] extra(Expr*) = ATmakeList(count-args(Expr*), Expr*)

[] count-args() = 0
[] count-args(Expression, Expr*) = integer-constant(Char*2)
   when integer-constant(Char*) := count-args(Expr*),
        natcon(Char*2) := 1 + natcon(Char*)

equations

%% Some phase in the compiler introduces (sometimes) overly nested blocks which
%% harm the matches in this module
[nested-blocks] {{Decls Stat+}} = {Decls Stat+}

equations

%% whatever other peoples opinion, traversals are never normal forms:
[never-normal]
  identifier("m""a""k""e""_""n""f" Char*) := Id1,
  identifier(Char*2 "s""y""m") := Id2,
  is-traversal-funid(funid(Char*2)) == true,
  Id3 := identifier(Char*2)
  ===>
  Id1(Id2, ActualArg+) = Id3(ActualArg+)
 
equations

%% In some cases add-traversal-code duplicates one Declaration into
%% two Declarations, which is represented by a Declaration tuple. 
%% This rules flattens the tuples in a normal declaration list ASAP.

[flatten] Declaration*1 <Declaration1, Declaration2> Declaration*2 =
          Declaration*1 Declaration1 Declaration2 Declaration*2

%% We have one rule for each combination of traversal attributes:
%% |{bottom-up, top-down} X {accu,trafo,accutrafo} X {break,continue}| = 12

equations

[default-do-nothing-for-non-traversals]
  add-traversal-code(Funid, Extra, Declaration) = Declaration

[bottom-up-trafo-continue]
  is-traversal-bottom-up(Funid) == true,
  is-traversal-trafo(Funid) == true,
  is-traversal-continue(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, Extra,
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      Statement+
      FUNC_EXIT(NormalForm);
    }) = 
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      arg0 = call_kids_trafo(Id, arg0, extra(Extra));
      Statement+
      FUNC_EXIT(arg0);
    }

[bottom-up-accu-continue]
  is-traversal-bottom-up(Funid) == true,
  is-traversal-accu(Funid) == true,
  is-traversal-continue(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs); 
      Statement+
      FUNC_EXIT(NormalForm);
    }) = 
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      arg1 = call_kids_accu(Id, arg0, arg1, extra(Extra));
      Statement+
      FUNC_EXIT(arg1);
    }

[bottom-up-accu-trafo-continue]
  is-traversal-bottom-up(Funid) == true,
  is-traversal-accutrafo(Funid) == true,
  is-traversal-continue(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      Statement+
      FUNC_EXIT(NormalForm);
    }) = 
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      {
       ATerm tuple = call_kids_accutrafo(Id, arg0, arg1, extra(Extra));
       {
         arg0 = accutrafo_tuple_first(tuple);
         arg1 = accutrafo_tuple_second(tuple);
       }
      }
      Statement+
      FUNC_EXIT(make_accutrafo_tuple(arg0, arg1));
    }

equations 

[bottom-up-trafo-break]
  is-traversal-bottom-up(Funid) == true,
  is-traversal-trafo(Funid) == true,
  is-traversal-break(Funid) == true,
  identifier(Char*) := Id,
  Id2 := identifier(Char* "_""i""m""p""l")
  ===>
  add-traversal-code(Funid, arg0, Extra,
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      Statement+
      FUNC_EXIT(NormalForm);
    }) = <
    static ATerm Id2 (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      { ATerm result = call_kids_trafo_with_fail(Id2, arg0, extra(Extra));
        if (result) {
          FUNC_EXIT(result);
        }
      }
      Statement+
      FUNC_EXIT(NULL);
    },
    ATerm Id (Arg*) {
      ATerm result = Id2(arg0, Extra);
      if (result) {
        return result;
      }
      return arg0;
    }
    >

[bottom-up-accu-break]
  is-traversal-bottom-up(Funid) == true,
  is-traversal-accu(Funid) == true,
  is-traversal-break(Funid) == true,
  identifier(Char*) := Id,
  Id2 := identifier(Char* "_""i""m""p""l")
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs); 
      Statement+
      FUNC_EXIT(NormalForm);
    }) = < 
    static ATerm Id2 (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      { ATerm result = call_kids_accu_with_fail(Id2, arg0, arg1, extra(Extra));
        if (result) {
          FUNC_EXIT(result);
        }
      }
      Statement+
      FUNC_EXIT(NULL);
    },
    ATerm Id ( Arg* ) {
      ATerm result = Id2 ( arg0, arg1, Extra);
      if (result) {
        return result;
      }
      return arg1;
    }>

[bottom-up-accutrafo-break]
  is-traversal-bottom-up(Funid) == true,
  is-traversal-accutrafo(Funid) == true,
  is-traversal-break(Funid) == true,
  identifier(Char*) := Id,
  Id2 := identifier(Char* "_""i""m""p""l")
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs); 
      Statement+
      FUNC_EXIT(NormalForm);
    }) = <
    static ATerm Id2 (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      { ATerm result = 
        call_kids_accutrafo_with_fail(Id2, arg0, arg1, extra(Extra));
        if (result) {
          FUNC_EXIT(result);
        }
      }
      Statement+
      FUNC_EXIT(NULL);
    },
    ATerm Id (Arg*) {
      ATerm result = Id2(arg0, arg1, Extra);
      if (result) {
        return result;
      }
      return make_accutrafo_tuple(arg0, arg1);
    }>

equations

[top-down-trafo-break]
  is-traversal-top-down(Funid) == true,
  is-traversal-trafo(Funid) == true,
  is-traversal-break(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, Extra,
    ATerm Id ( Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs); 
      Statement+
      FUNC_EXIT(NormalForm);
    }) = 
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      Statement+
      FUNC_EXIT(call_kids_trafo(Id, arg0, extra(Extra)));
    }

[top-down-accu-break]
  is-traversal-top-down(Funid) == true,
  is-traversal-accu(Funid) == true,
  is-traversal-break(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
    ATerm Id ( Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs); 
      Statement+
      FUNC_EXIT(NormalForm);
    }) = 
    ATerm Id ( Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      Statement+
      FUNC_EXIT(call_kids_accu(Id, arg0, arg1, extra(Extra)));
    }

[top-down-accutrafo-break]
  is-traversal-top-down(Funid) == true,
  is-traversal-accutrafo(Funid) == true,
  is-traversal-break(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
    ATerm Id ( Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs); 
      Statement+
      FUNC_EXIT(NormalForm);
    }) = 
    ATerm Id ( Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      Statement+
      FUNC_EXIT(call_kids_accutrafo(Id, arg0, arg1, extra(Extra)));
    }

equations

[top-down-trafo-continue]
  is-traversal-top-down(Funid) == true,
  is-traversal-trafo(Funid) == true,
  is-traversal-continue(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, Extra,
    ATerm Id ( Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs); 
      Statement+
      FUNC_EXIT(NormalForm);
    }) = 
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      {
        make-tail-calls(Statement+, trafo, Id, arg0, Extra)
      }
      FUNC_EXIT(call_kids_trafo(Id, arg0, extra(Extra)));
    }

[top-down-accu-continue]
  is-traversal-top-down(Funid) == true,
  is-traversal-accu(Funid) == true,
  is-traversal-continue(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
    ATerm Id ( Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs); 
      Statement+
      FUNC_EXIT(NormalForm);
    }) = 
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      {
        make-tail-calls(Statement+, accu, Id, arg0, arg1, Extra)
      }
      FUNC_EXIT(call_kids_accu(Id, arg0, arg1, extra(Extra)));
    }

[top-down-accutrafo-continue]
  is-traversal-top-down(Funid) == true,
  is-traversal-accutrafo(Funid) == true,
  is-traversal-continue(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
    ATerm Id ( Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs); 
      Statement+
      FUNC_EXIT(NormalForm);
    }) = 
    ATerm Id (  Arg* ) {
      Decls
      FUNC_ENTRY(EntryArgs);
      {make-tail-calls(Statement+, accutrafo, Id, arg0, arg1, Extra)}
      FUNC_EXIT(call_kids_accutrafo(Id, arg0, arg1, extra(Extra)));
    }

equations

[mtt-trafo] 
  make-tail-calls(Statement*1 FUNC_EXIT(Expression); Statement*2,
                  trafo, Id, arg0, Extra) =
  Statement*1
  FUNC_EXIT(call_kids_trafo(Id, Expression, extra(Extra)));
  Statement*2

[mtt-accu]
  make-tail-calls(Statement*1 FUNC_EXIT(Expression); Statement*2,
                  accu, Id, arg0, arg1, Extra) =
  Statement*1
  FUNC_EXIT(call_kids_accu(Id, arg0, Expression, extra(Extra)));
  Statement*2

[mtt-accutrafo]
  make-tail-calls(Statement*1 FUNC_EXIT(Expression); Statement*2,
                  accutrafo, Id, arg0, arg1, Extra) =
  Statement*1
  {
    ATerm tuple = Expression;
    {
      ATerm first = accutrafo_tuple_first(tuple);
      {
        ATerm second = accutrafo_tuple_second(tuple);
        {
          FUNC_EXIT(call_kids_accutrafo(Id, first, second, extra(Extra)));
        }
      }
    }
  }
  Statement*2

equations

%% For the traversal functions that have no equations whatsoever,
%% which is a user error usually, but still valid ASF+SDF which
%% should behave just as the interpreter behaves. 

[empty-trafo] 
  is-traversal-trafo(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, Extra,
  ATerm Id ( Arg* ) {
    CONS_ENTRY ( EntryArgs); 
    CONS_EXIT ( NormalForm );
  }) =
  ATerm Id ( Arg* ) {
    FUNC_ENTRY ( EntryArgs); 
    FUNC_EXIT ( arg0 );
  } 

[empty-accu] 
  is-traversal-accu(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
  ATerm Id ( Arg* ) {
    CONS_ENTRY ( EntryArgs); 
    CONS_EXIT ( NormalForm );
  }) =
  ATerm Id ( Arg* ) {
    FUNC_ENTRY ( EntryArgs); 
    FUNC_EXIT ( arg1 );
  } 

[empty-accutrafo] 
  is-traversal-accutrafo(Funid) == true
  ===>
  add-traversal-code(Funid, arg0, arg1, Extra,
  ATerm Id ( Arg* ) {
    CONS_ENTRY ( EntryArgs); 
    CONS_EXIT ( NormalForm );
  }) =
  ATerm Id ( Arg* ) {
    FUNC_ENTRY ( EntryArgs); 
    FUNC_EXIT ( make_accutrafo_tuple(arg0,arg1) );
  } 
