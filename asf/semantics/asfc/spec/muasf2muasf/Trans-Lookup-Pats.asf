%%
%%    Meta-Environment - An environment for language prototyping.
%%    Copyright (C) 2000  Stichting Mathematisch Centrum, Amsterdam, The Netherlands. 
%%
%%    This program is free software; you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation; either version 2 of the License, or
%%    (at your option) any later version.
%%
%%    This program is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with this program; if not, write to the Free Software
%%    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
%%
equations

  [tll-1'1] Term1 = Funid1(Term+),
            prefix-id("lookup__",Funid1,Aint1) = Funid2
            ===========================================
            transform-lookup-like(Term1 = Term2,Aint1) =
              transform-lhs(Funid2,Term1,Term2,1)

  [tll-1'2] Term1 = Funid1(Term+),
            prefix-id("lookup__",Funid1,Aint1) = Funid2,
            is-lookup-lhs(Term1) = true
            ===========================
            transform-lookup-like(Cond+ ==> Term1 = Term2,Aint1) =
              transform-lhs(Funid2,Cond+,Term1,Term2,1)

  [tll-1'3] Term1 = Funid1(Term+),
            prefix-id("lookup__",Funid1,Aint1) = Funid2,
            is-lookup-lhs(Term1) = false,
            lookup-conds(Cond+) = true
            ==========================
            transform-lookup-like(Cond+ ==> Term1 = Term2,Aint1) =
              transform-lookup-conds(Funid2(Term+),Cond+,,Term1,Term2,1)

%% The function {\tt transform-lhs} transforms a list matching
%% pattern into a set of recursive functions.
  [tl-1'1] lookup-pattern(init-lhs,Term+1,Aint) = Term+2,
           lookup-pattern(init-cond,Term+1,Aint) = Term+4,
           lookup-pattern(init-new,Term+1,Aint) = Term+5,
           newvar(succ(Aint),OkV) = Varid,
           %%%make-new-funcdef(Funid2(Term+1,Varid),Funid1) = Funcdef,
           make-new-funcdef(Funid2(Term+4),Funid1) = Funcdef,
           lookup-pattern(def-lhs,Term+1,Aint) = Term+6,
           lookup-pattern(def-rhs,Term+1,Aint) = Term+7
           ============================================
           transform-lhs(Funid1,Funid2(Term+1),Term2,Aint) =
             (Funcdef,Funid1(Term+4) =: ok(Varid) ==>
               Funid2(Term+2) = Varid;
               Funid1(Term+5) = ok(Term2);
               default:Funid1(Term+6) = Funid1(Term+7),succ(succ(Aint)))

  [tl-1'1] lookup-pattern(init-lhs,Term+1,Aint) = Term+2,
           lookup-pattern(init-cond,Term+1,Aint) = Term+4,
           lookup-pattern(init-new,Term+1,Aint) = Term+5,
           newvar(succ(Aint),OkV) = Varid,
           %%%make-new-funcdef(Funid2(Term+1,Varid),Funid1) = Funcdef,
           make-new-funcdef(Funid2(Term+4),Funid1) = Funcdef,
           lookup-pattern(def-lhs,Term+1,Aint) = Term+6,
           lookup-pattern(def-rhs,Term+1,Aint) = Term+7
           ============================================
           transform-lhs(Funid1,Cond+,Funid2(Term+1),Term2,Aint) =
             (Funcdef,Funid1(Term+4) =: ok(Varid) ==>
               Funid2(Term+2) = Varid;
               Cond+ ==> Funid1(Term+5) = ok(Term2);
               default:Funid1(Term+6) = Funid1(Term+7),succ(succ(Aint)))

%% Functions to initialize the lookup pattern in the argument list.
  [lp-1'1] is-list-funid(Funid2) = true,
           is-star-var(Term1) = true,
           contains-lookup-pattern(Funid2(cons(Term1,Term2))) = true,
           newvar(Aint) = Varid
           ====================
           lookup-pattern(init-lhs,Funid2(cons(Term1,Term2)),Aint) =
             Funid2(*Varid)

  [lp-1'2] is-list-funid(Funid2) = true,
           is-plus-var(Term1) = true,
           contains-lookup-pattern(Funid2(cons(Term1,Term2))) = true,
           newvar(Aint) = Varid1,
           newvar(succ(Aint)) = Varid2
           ===========================
           lookup-pattern(init-lhs,Funid2(cons(Term1,Term2)),Aint) =
             Funid2(cons(Varid1,*Varid2))

  [lp-1'3] is-list-funid(Funid2) = true,
           is-star-var(Term1) = true,
           contains-lookup-pattern(Funid2(cons(Term1,Term2))) = true,
           newvar(Aint) = Varid
           ====================
           lookup-pattern(init-cond,Funid2(cons(Term1,Term2)),Aint) =
             Funid2(null),Funid2(*Varid)

  [lp-1'4] is-list-funid(Funid2) = true,
           is-plus-var(Term1) = true,
           contains-lookup-pattern(Funid2(cons(Term1,Term2))) = true,
           newvar(Aint) = Varid1,
           newvar(succ(Aint)) = Varid2
           ===========================
           lookup-pattern(init-cond,Funid2(cons(Term1,Term2)),Aint) =
             Funid2(Varid1),Funid2(*Varid2)

%% Functions to modify the lookup pattern.
  [lp-1'5] is-list-cons(Term2) = false,
           is-list-funid(Funid2) = true,
           contains-lookup-pattern(Funid2(cons(Term1,Term2))) = true
           =========================================================
           lookup-pattern(init-new,Funid2(cons(Term1,Term2)),Aint) =
              Funid2(Term1),Funid2(Term2)

%% Functions to modify the lookup pattern.
  [lp-1'6] is-list-funid(Funid2) = true,
           contains-lookup-pattern(Funid2(cons(Term1,cons(Term2,Term3)))) = true
           =====================================================================
           lookup-pattern(init-new,Funid2(cons(Term1,cons(Term2,Term3))),Aint) =
              Funid2(Term1),Funid2(cons(Term2,Term3))

%% Functions to modify the lookup pattern to be used in the left
%% hand side of a default rule.
  [lp-1'7] is-list-cons(Term2) = false,
           is-list-funid(Funid2) = true,
           contains-lookup-pattern(Funid2(cons(Term1,Term2))) = true,
           newvar(Aint,Vdef) = Varid1,
           newvar(Aint,Vdeflist) = Varid2
           ====================
           lookup-pattern(def-lhs,Funid2(cons(Term1,Term2)),Aint) =
             Funid2(Term1),Funid2(cons(Varid1,*Varid2))

  [lp-1'8] is-list-funid(Funid2) = true,
           contains-lookup-pattern(Funid2(cons(Term1,cons(Term2,Term3)))) = true,
           newvar(Aint,Vdef) = Varid1,
           newvar(Aint,Vdeflist) = Varid2
           ====================
           lookup-pattern(def-lhs,Funid2(cons(Term1,cons(Term2,Term3))),Aint) =
             Funid2(Term1),Funid2(cons(Varid1,*Varid2))

%% Functions to modify the lookup pattern to be used in the right
%% hand side of a default rule.
  [lp-1'9] is-list-cons(Term2) = false,
           is-list-funid(Funid2) = true,
           contains-lookup-pattern(Funid2(cons(Term1,Term2))) = true,
           newvar(Aint,Vdef) = Varid1,
           newvar(Aint,Vdeflist) = Varid2
           ====================
           lookup-pattern(def-rhs,Funid2(cons(Term1,Term2)),Aint) =
             Funid2(cons(Term1,Varid1)),Funid2(*Varid2)

  [lp-1'10] is-list-funid(Funid2) = true,
            contains-lookup-pattern(Funid2(cons(Term1,cons(Term2,Term3)))) = true,
            newvar(Aint,Vdef) = Varid1,
            newvar(Aint,Vdeflist) = Varid2
            ====================
            lookup-pattern(def-rhs,Funid2(cons(Term1,cons(Term2,Term3))),Aint) =
              Funid2(cons(Term1,Varid1)),Funid2(*Varid2)

  [lp-1'11] lookup-pattern(Pattype,Term,Term+,Aint) = lookup-patterns(Pattype,Term,Term+,Aint)

%% Only if the outermost function is a function with a list expression as argument then
%% the outermost function symbol should be distributed over all transformed result
%% arguments.
  [lp-1'12] is-list-funid(Funid1) = false,
            is-list-funid(Funid2) = true,
            lookup-pattern(Pattype,Funid2(Term+1),Aint) = Term+2%%%,
            %%%add-funid(Funid1,Term+2) = Term+3
            =================================
            lookup-pattern(Pattype,Funid1(Funid2(Term+1)),Aint) = Term+2

%%%  [lp-1'13] is-list-funid(Funid1) = false,
%%%            is-list-funid(Funid2) = false,
%%%            lookup-pattern(Pattype,Funid2(Term+1),Aint) = Term+2
%%%            ====================================================
%%%            lookup-pattern(Pattype,Funid1(Funid2(Term+1)),Aint) = Funid1(Term+2)

  [lp-1'14] Pattype != init-lhs,
            is-list-funid(Funid1) = false,
            find-lookup-pattern(Pattype;Funid1;;Term+1;Aint) = Term+2
            =========================================================
            lookup-pattern(Pattype,Funid1(Term+1),Aint) = Term+2  %%% was Funid1(Term,Term+1)

  [lp-1'15] is-list-funid(Funid) = false,
            lookup-patterns(init-lhs,Term+1,Aint) = Term+2
            ===================================================
            lookup-pattern(init-lhs,Funid(Term+1),Aint) = Funid(Term+2) %%% was Funid1(Term,Term+1)

  [default-lp-1'16] lookup-pattern(Pattype,Term,Aint) = Term

%% Functions to initialize the lookup pattern in the argument list.
  [lp-3'1] lookup-patterns(Pattype,Term,Aint) = lookup-pattern(Pattype,Term,Aint)

  [lp-3'2] lookup-pattern(Pattype,Term1,Aint) = Term+2,
           lookup-patterns(Pattype,Term+1,Aint) = Term+3
           =============================================
           lookup-patterns(Pattype,Term1,Term+1,Aint) = Term+2,Term+3

  [flp-1'1] contains-lookup-pattern(Term) = true,
            lookup-pattern(Pattype,Term,Aint) = Term+2
            ==========================================
            find-lookup-pattern(Pattype;Funid;Term*1;Term,Term*2;Aint) = Term*1,Term+2,Term*2
              %%%make-lookup-term(Funid;Term*1;Term+2;Term*2)

  [flp-1'2] contains-lookup-pattern(Term) = false
            =====================================
            find-lookup-pattern(Pattype;Funid;Term*;Term,Term+;Aint) =
              find-lookup-pattern(Pattype;Funid;Term*,Term;Term+;Aint)

  [tlc-1'1] lookup-cond(Term1 =: Term2) = false,
            term-contains-var(Term2) = true
            ===============================
            transform-lookup-conds(Funid1(Term+1),Term1 =: Term2 & Cond+1,
                            Cond*2,Term3,Term4,Aint) =
              transform-lookup-conds(Funid1(Term+1,Term2),Cond+1,
                              Cond*2 & Term1 =: Term2,Term3,Term4,Aint)

  [tlc-1'1] lookup-cond(Term1 =: Term2) = false,
            term-contains-var(Term2) = false
            ===================================
            transform-lookup-conds(Funid1(Term+1),Term1 =: Term2 & Cond+1,
                            Cond*2,Term3,Term4,Aint) =
              transform-lookup-conds(Funid1(Term+1),Cond+1,
                              Cond*2 & Term1 =: Term2,Term3,Term4,Aint)

  [tlc-1'2] lookup-cond(Term1 =: Term2) = true,
            newvar(succ(Aint),OkV) = Varid,
            make-new-funcdef(Funid1(Term+1,Term1),Funid1) = Funcdef,
            make-conditional-rule(Cond*1,Funid1(Term+1,Term2) = ok(Term4)) = Rule
            =====================================================================
            transform-lookup-conds(Funid1(Term+1),Term1 =: Term2 & Cond*1,
                            Cond*2,Term3,Term4,Aint) =
              (Funcdef,
               Cond*2 & Funid1(Term+1,Term1) =: ok(Varid)
               ==>
               Term3 = Varid;
               Rule,succ(succ(Aint)))

  [default-tlc-1'3] transform-lookup-conds(Term1,Cond & Cond+1,
                                    Cond*2,Term3,Term4,Aint) =
                      transform-lookup-conds(Term1,Cond+1,
                                      Cond*2 & Cond,Term3,Term4,Aint)
