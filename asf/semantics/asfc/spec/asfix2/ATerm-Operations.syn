%%
%%    Meta-Environment - An environment for language prototyping.
%%    Copyright (C) 2000  Stichting Mathematisch Centrum, Amsterdam, The Netherlands. 
%%
%%    This program is free software; you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation; either version 2 of the License, or
%%    (at your option) any later version.
%%
%%    This program is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with this program; if not, write to the Free Software
%%    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
%%
%%%% $Id$
%%
%% \SubModule{Type Predicates and Retracts}
%%
%% Type predicates distinguish the constructor used to create a term.
%% Retracts map values from a higher sort back to the basic sort
%% of a value.
%%
%% \smallskip

imports ATerms
exports
  context-free syntax
    is-list(ATerm)                           -> Bool
    is-con(ATerm)                            -> Bool
    is-fun(ATerm)                            -> Bool
    is-app(ATerm)                            -> Bool

    is-lit(ATerm)                            -> Bool
    is-int(ATerm)                            -> Bool
%%%    is-real(ATerm)                           -> Bool

    aterms(ATerm)                            -> ATerms
    atermlist(ATerm)                         -> ATermList
    literal(ATerm)                           -> Literal

%% \def\COND{ % this section is placed after the equations for the functions above
%%
%% \SubModule{Equality, Conditional and Concatenation}
%%
%% Equality of terms.
%% Conditional on terms.
%% Concatenation of argument lists.
%% Failure
%%
%% \smallskip

exports
  context-free syntax
    ATerm "==" ATerm                         -> Bool
    if Bool then ATerm else ATerm fi         -> ATerm
    if Bool then ATermList else ATermList fi -> ATermList
    ATerms "++a" ATerms                      -> ATerms {right}
    fail                                     -> AFun
    "(" ATerm ")"                            -> ATerm {bracket}
    "(" ATerms ")"                           -> ATerms {bracket}
    "(" ATermList ")"                        -> ATermList {bracket}
  priorities
    ATerm "," ATerms -> ATerms
  > ATerms "++a" ATerms -> ATerms

%% }
%% \def\HOF{ % this section is placed after the equations for the functions above
%%
%% \SubModule{Higher-Order Functions}
%%
%% We introduce a framework for defining higher-order functions
%% on ATerms. To this end, we introduce the functions
%% \spec{holds} and \spec{apply} that will be used to define
%% predicates, respectively, ATerm-valued functions occurring as
%% arguments for the higher-order functions to be defined below.
%% The functions \spec{holds} and \spec{apply} take as arguments
%% an ATerm (representing a function on ATerms) and one or more
%% ATerms (representing the arguments for that function).
%%
%% Several standard functions that combine functions into new
%% functions are defined.
%%
%% \smallskip
%%

exports
  context-free syntax
    apply(ATerm, ATerms)                     -> ATerm
    applyf                                   -> AFun
    holds(ATerm, ATerms)                     -> Bool

    eq                                       -> AFun
    identity(ATerm)                          -> ATerm
    identity                                 -> AFun
    yes(ATerm)                               -> Bool
    yes                                      -> AFun
    comp                                     -> AFun
  variables
    "Pred" [0-9']* -> ATerm
    "Fun"  [0-9']* -> ATerm
hiddens
  variables
    "Args" [0-9']* -> ATerms

%%}
%%
%% \def\ANN{
%%
%% \SubModule{Annotations}
%%
%% We define several basic operations for handling terms with annotations.
%%
%% \smallskip

exports
  context-free syntax
    term(ATerm)               -> ATerm
    termf                     -> AFun
    ann(ATerm)                -> ATermList
    ATerm "@" ATermList       -> ATerm
    set-ann(ATerm, ATermList) -> ATerm
    has-ann(ATerm)            -> Bool

%% }
