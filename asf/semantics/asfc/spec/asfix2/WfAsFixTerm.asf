equations

%% \paragraph{Type equality.}
%% The function {\tt eq-type} determines the equality of two types.
%% The constant \spec{type-error} denotes a type error and should be taken into account.

%% White space should not affect the type of a term, hence we map any \spec{ws($L$)} to \spec{w("")}.
%% For the purpose of typing, a list separator behaves like a literal.

  [eq-asfix-type-1]  eq-asfix-type(T, T) = if T == asfix-type-error then false else true fi
  [eq-asfix-type-2]  eq-asfix-type(ql(L), T) = eq-asfix-type(l(de-escape(L)), T)
  [eq-asfix-type-3]  eq-asfix-type(T, ql(L)) = eq-asfix-type(T, l(de-escape(L)))
  [eq-asfix-type-4]  eq-asfix-type(sep(L), T) = eq-asfix-type(l(L), T)
  [eq-asfix-type-5]  eq-asfix-type(T, sep(L)) = eq-asfix-type(T, l(L))
  [eq-asfix-type-6]  eq-asfix-type(w(L1), w(L2)) = true
  [eq-asfix-type-7]  eq-asfix-type([T1], [T2]) = eq-asfix-type(T1, T2)
  [eq-asfix-type-8]  eq-asfix-type([T1, Ts1], [T2, Ts2]) =
                     eq-asfix-type(T1, T2) /\ eq-asfix-type([Ts1], [Ts2])
  [default-eq-asfix-type-9]
               eq-asfix-type(T1, T2) = false

%% \paragraph{The type of an AsFixTerm.}
%% Determine the type of an AsFixTerm (represented as ATerm).

  [asfix-type-of-1]  asfix-type-of(AFun) = AFun

%% In \ASFIX, the type of literals is always determined by their context and it is an error
%% when they occur without a context.

  [asfix-type-of-2]  asfix-type-of(L) = asfix-type-error
  [asfix-type-of-3]  asfix-type-of([]) = []
  [asfix-type-of-4]  asfix-type-of([T]) = [asfix-type-of(T)]
  [asfix-type-of-5]  asfix-type-of([T , Ts]) =  [asfix-type-of(T), aterms(asfix-type-of([Ts]))]
  [asfix-type-of-6]  asfix-type-of(ACon {Ts}) = asfix-type-of(ACon)
  [asfix-type-of-6]  asfix-type-of(AFun {Ts}) = asfix-type-of(AFun)
  [asfix-type-of-6]  asfix-type-of(AFun(Ts1) {Ts2}) = asfix-type-of(AFun(Ts1))
  [asfix-type-of-6]  asfix-type-of(Tl {Ts}) = asfix-type-of(Tl)

  [asfix-type-of-7]
               T' = appl(Ts),
               is(Production,T'[prod]) = true,
               eq-asfix-type(T'[prod][syms], asfix-type-of(T'[args])) = true
               =============================================
               asfix-type-of(appl(Ts)) = T'[prod][sym]

 [asfix-type-of-8]
               T' = list(T),
               is-cons(iter-sep, T'[sym]) = true,
               match-list-type-with-sep(atermlist(T'[sym][sym]), T'[sym][sep],
                                        T'[sym][iter], atermlist(T'[elems])) = true
               =========================================================
               asfix-type-of(list(T)) = T'[sym]

 [asfix-type-of-9]
               T' = list(T),
               is-cons(iter, T'[sym]) = true,
               match-list-type(T'[sym][sym], T'[sym][iter], atermlist(T'[elems])) = true
               ====================================================
               asfix-type-of(list(T)) = T'[sym]

  [asfix-type-of-10]  asfix-type-of(var(Ts)) = var(Ts)[sym]
  [asfix-type-of-11]  asfix-type-of(meta-var(Ts)) = meta-var(Ts)[sym]
  [asfix-type-of-12]  asfix-type-of(lex(Ts)) = lex(Ts)[sym]
  [asfix-type-of-13]  asfix-type-of(w(L)) = w(L)
  [asfix-type-of-14]  asfix-type-of(l(L)) = l(L)
  [asfix-type-of-15]  asfix-type-of(ql(L)) = ql(L)
  [asfix-type-of-16]  asfix-type-of(sep(L)) = sep(L)
  [asfix-type-of-17]  asfix-type-of(sort(L)) = sort(L)
  [asfix-type-of-18]  asfix-type-of(id(L)) = id(L)
  [asfix-type-of-19]  asfix-type-of(iter(Ts)) = iter(Ts)
  [asfix-type-of-20]  asfix-type-of(iter-sep(Ts)) = iter-sep(Ts)

%% Map all type-incorrect AsFixTerms onto the constant {\tt type-error}.

  [default-asfix-type-of-21]
               asfix-type-of(T) = asfix-type-error

%% \paragraph{Functions related to the type of lists.}
%% For the uniform treatment of lists with
%% and without separators, define the separator of a list without separators to be
%% the empty string.

 [sep-1] iter(T1, T2)[sep] = l("")

%% Define the constructors for lists.

 [ilt-1] is-list-type(T) = is-cons(iter, T) \/ is-cons(iter-sep, T)

%% The type of list elements should either be a matching list type or the
%% required element type.

  [eq-type-in-list-1]
        is-list-type(T2) /\ eq-asfix-type(T2[sym],T1) /\ eq-asfix-type(T2[sep],T3) = true
        =========================================================================
        eq-type-in-list(T1, T2, T3) = true

  [default-eq-type-in-list-2]
          eq-type-in-list(T1, T2, T3) = eq-asfix-type(T1, T2)

%% \ASFIX\ lists will be represented using a similar approach as in Section~\ref{Mod:ParseTrees}:
%% \begin{itemize}
%% \item For lists without separator, we put the layout between
%% between consecutive elements in the list. For instance, the list
%%  of constructs $T_1 ,..., T_n$ will be represented by:
%% {\tt [$T_1$, ws($L_1$), $T_2$, ws($L_2$) $,...,$ ws($T_{n-1}$), $T_n$]}.
%% \item For lists with separator, we put the white space before
%% the separator, the separator (again, represented by the function symbol \spec{sep}),
%% and the white space following the separator between consecutive elements.
%% For instance, the list
%% of constructs $T_1 ,..., T_n$ separated by $L$ will be represented by:
%% {\tt [$T_1$, ws($L_1$), sep($L$), ws($L_1'$), $T_2$, ws($L_2$), sep($L$), ws($L_2'$) $,...,$
%% ws($T_{n-1}'$), $T_n$]}.
%% \end{itemize}
%% The cases of lists with and without separator
%% are treated in a uniform fashion by using the function \spec{get-list-tail}
%% (defined in Section~\ref{Mod:ParseTrees})
%% which returns a 4-tuple of the form:
%% \begin{quote}
%% {\tt [{\em white space before separator}, {\em separator}, {\em white space following separator}, {\em
%% remainder of list}]}
%% \end{quote}

%% The match between a required list sort and given list elements is
%% done by the auxiliary function \spec{match-list-type-with-sep} (for lists with
%% separators) and \spec{match-list-type} (for lists without separators).

  [mlt-ws-1]
           match-list-type-with-sep(Tl1, Sep, l("*"), []) = true

  [mlt-ws-2]
           match-list-type-with-sep(Tl, Sep, Iter, [T, w(L1), sep(L2), w(L3), Ts]) =
             eq-asfix-type(Sep, l(L2)) /\
             eq-type-in-list(Tl, asfix-type-of(first(Tl)), Sep) /\
             match-list-type-with-sep(Tl, Sep, l("*"), [Ts])

  [mlt-ws-3]
           match-list-type-with-sep(Tl, Sep, Iter, [T]) = eq-type-in-list(Tl, type-of(T), Sep)

  [default-mlt-ws-4]
           match-list-type-with-sep(Tl, Sep, Iter, Tl) = false

  [mlt-1]  match-list-type(T1, l("*"), []) = true

  [mlt-2]  match-list-type(T1, Iter,  [T, w(L1), Ts]) =
           eq-type-in-list(T1, type-of(T), l("")) /\ match-list-type(T1, l("*"), [Ts])

  [mlt-3]  match-list-type(T1, Iter, [T]) = eq-type-in-list(T1, asfix-type-of(T), l(""))

  [default-mlt-4]
           match-list-type(T1, Iter, Tl) = false

%% \paragraph{Well-formed AsFixTerms.}
%% Finally, define the well-formedness predicate for AsFixTerms.

  [wf-AsFixTerm-1]
        holds(wf-AsFixTerm, T) =
       if asfix-type-of(T) == asfix-type-error then false else true fi
