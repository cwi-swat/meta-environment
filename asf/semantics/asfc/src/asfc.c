/*

    Meta-Environment - An environment for language prototyping.
    Copyright (C) 2000  Stichting Mathematisch Centrum, Amsterdam, 
                        The Netherlands. 

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

*/
/* A first version of the COMPILER in ToolBus C. 
   This program is written by Mark van den Brand and
   improved by Pieter Olivier.

   The following functions are available:
   void rec_terminate(ATerm t)
   ATerm generate_code(char *modname, ATerm module)
*/

#include <assert.h>
#include <atb-tool.h>
#include <string.h>
#include <ctype.h>
#include <AsFix.h>
#include <aterm2.h>
#include <stdio.h>
#include <unistd.h>  

#include <sys/times.h>
#include <stdlib.h>
#include <limits.h>
/* For cpu time calculation */
#include <time.h>

#include "reshuffle.h"


#include <SDF-utils.h>  
#include <asc-support.h>
#include <asc-apply.h>

#include "asfc.tif.h"

ATbool run_verbose;

static char myname[] = "asfc";
static char myversion[] = "1.3";

static char *outputDirName = NULL;

/*
    The argument vector: list of option letters, colons denote option
    arguments.  See Usage function, immediately below, for option
    explanation.
 */

static char myarguments[] = "hi:o:cvV";

extern void resolve_all();
extern void register_all();
extern void init_all();

void AFinitExpansionTerms();
void AFinitAsFixPatterns();
ATerm AFexpandAsFixModule(ATerm mod);

void rec_terminate(int cid, ATerm t) 
{
  clock_t cputime;
  float cpusecs;

  /* read the cpu time up till now*/
  cputime = clock();
  cpusecs = (float) ((float) cputime / (float) CLOCKS_PER_SEC);

  if(run_verbose) {
    ATfprintf(stderr, "Compiler used %f seconds cpu time\n", cpusecs);
  }

  exit(0);
}

void set_output_dir(int cid, char *dirName)
{
  int len = strlen(dirName) + 1;

  outputDirName = (char *) realloc(outputDirName, len);

  if (outputDirName == NULL) {
    ATerror("compiler: unable to allocate %d bytes\n", len);
  }
  else {
    strcpy(outputDirName, dirName);
  }
}

char *
get_output_dir(void)
{
  if (outputDirName != NULL) {
    return outputDirName;
  }
  else if (getenv("COMPILER_OUTPUT") != NULL) {
    return getenv("COMPILER_OUTPUT");
  }
  else {
    return ".";
  }
}


/*{{{  Converting back to readable C-code */
void ToC_code(PT_ParseTree ptCcode, FILE *file)
{
  int c, prev = ' ';
  int instring = 0;
  int escaped = 0;
  int firststring = 1;
  static char *buf = NULL;
  char *bp;
  int size3 = 0, size;

  ATfprintf(file, "/* This C code is generated by the AsfSdfCompiler version %s */\n\n",
            myversion);
  buf = PT_yieldParseTree(ptCcode);
  size = strlen(buf);

  bp = buf;
  do {
    size3++;
    c = *bp++;
    if ((bp-buf) >= size) {
      fprintf(stderr, "could not find '#' marker, "
              "maybe the reduction failed?\n");
      exit (1);
    }
  } while(c != '#');

  while(c != '"') {
    fputc(c, file);
    size3++;
    c = *bp++;
  }
  fputc(' ', file);
  fputc(c, file);
  size3++;    
  c = *bp++;

  while(c != '"') {
    fputc(c, file);
    size3++;
    c = *bp++;
  }
  fputs("\"\n", file);

  do {
    size3++;
    c = *bp++;
    if(c >= 0) {
      if(!instring && c == '\n')
        c = ' ';
      if(!(instring || prev != ' ' || c != ' '))
        ;
      else  
        fputc(c, file);
      prev = c;
    }
    if(instring) {
      if(!escaped && c == '"') {
        instring = 0;
        if(firststring) {
          firststring = 0;
          fputc('\n', file);
        }
      }
      escaped = 0;
      if(!escaped && c == '\\')
        escaped = 1;
    } else {
      if(c == '"')
        instring = 1;
      else {   
        if(c == ';' || c == '}' || c == '{') {
          fputc('\n', file);
          prev = ' ';
        }
      }
    }
  } while(size3 != size);
}        

/*}}}  */   
/*{{{  ATerm make_compiler_term(ATerm term) */

static PT_ParseTree make_compiler_term(PT_Tree term)
{
  PT_Tree appl = ASC_applyFunction("asfix2c", "AsFix2C", "CProgram", 1, 
                                   term);
  return PT_makeParseTreeTree("", appl, "");
}

/*}}}  */
/*{{{  static PT_Tree expand_to_asfix(ATerm mod) */


static PT_ParseTree expand_to_asfix(ATerm mod)
{
  ATerm arg;

  arg = AFexpandAsFixModule(mod);
  return make_compiler_term(PT_makeTreeFromTerm(arg));
}

/*}}}  */
/*{{{  void generateCode(char *modname, ATerm module) */

void generateCode(char *modname, ATerm module)
{
  char *fname;
  PT_ParseTree ptCcode;
  PT_Tree term;
  PT_ParseTree expandedModule;
  ATerm reduct;
  int len;
  FILE *output;
  char *path;
  
  if (run_verbose) {
    ATwarning("generating code for %s\n", modname);
  }
  
  expandedModule = expand_to_asfix(module);
  term = PT_getParseTreeTree(expandedModule);
  reduct = innermost(term);
  assert(reduct != NULL);

  ptCcode = toasfix(reduct);

  path = get_output_dir();
  len = strlen(path) + 1 + strlen(modname) + strlen(".c");
  fname = malloc(len + 1);
  if (!fname) {
    ATerror("Not enough memory\n");
  }
  sprintf(fname, "%s/%s.c", path, modname );

  output = fopen(fname, "w");
  if (!output)  {
    ATwarning("Cannot open file %s\n", fname);
  }
  else {
    ToC_code(ptCcode, output);
    ATfprintf(output, "\n");
    fclose(output);
  }

  free(fname);
}

/*}}}  */

ATerm compile_module(int cid, char *moduleName, 
                     ATerm syntax, ATerm equations)
{
  PT_ParseTree   pt;
  SDF_SDF        sdf;
  SDF_Definition definition;
  SDF_ModuleList moduleList;
  ASF_CondEquationList eqsList;

  pt         = PT_makeParseTreeFromTerm(syntax);
  sdf        = SDF_makeSDFFromTerm(
                 PT_makeTermFromTree(PT_getParseTreeTree(pt)));
  definition = SDF_getSDFDefinition(sdf);
  moduleList = SDF_getDefinitionList(definition);
  eqsList    = ASF_makeCondEquationListFromTerm(equations);

  compileModules(moduleName, moduleList, eqsList);

  return ATmake("snd-value(compilation-done)");
}                              

/*{{{  void usage(void) */

/*
 * Usage: displays helpful usage information
 */

void usage(void)
{
  ATwarning(
            "Usage: %s [options]\n"
            "Options:\n"
            "\t-h              display help information (usage)\n"
            "\t-i filename     input from file (default stdin)\n"
            "\t-o filename     output to file (default stdout)\n"
            "\t-v              verbose mode\n"
            "\t-V              reveal program version (i.e. %s)\n",
            myname, myversion);
  exit(0);
}

/*}}}  */
/*{{{  void version(void) */

void version(void)
{
  ATwarning("%s v%s\n", myname, myversion);
  exit(0);
}

/*}}}  */
/*{{{  int main(int argc, char *argv[]) */

int main(int argc, char *argv[])
{
  FILE *iofile;

  int cid;
  int c, toolbus_mode = 0;
  char *input = "-";
  char *output = "-";

  extern char *optarg;
  extern int   optind;

  ATerm bottomOfStack, module;
  PT_Tree term;
  PT_ParseTree expandedModule;
  PT_ParseTree ptCcode;
  ATerm reduct;

  clock_t cputime;

  run_verbose = ATfalse;
 
  /* See how much CPU time we use */
  /* Set the clock to zero */

  /*  Check whether we're a ToolBus process  */
  for(c=1; !toolbus_mode && c<argc; c++) {
    toolbus_mode = !strcmp(argv[c], "-TB_TOOL_NAME");
  }

  cputime = clock();

  AFinit(argc, argv, &bottomOfStack);
  AFinitExpansionTerms();
  AFinitAsFixPatterns();

  SDF_initSDFApi();

  ASC_initRunTime(INITIAL_TABLE_SIZE);
  register_all();
  resolve_all();
  init_all();

  if (toolbus_mode) {
#ifndef WIN32 /* Code with Toolbus calls, non Windows */
    ATBinit(argc, argv, &bottomOfStack);  
    cid = ATBconnect(NULL, NULL, -1, asfc_handler);
    ATBeventloop();
#else
    ATwarning("compiler: Toolbus cannot be used in Windows.\n");
#endif
  } else {
    while ((c = getopt(argc, argv, myarguments)) != -1) {
      switch (c) {
      case 'v':  run_verbose = ATtrue;  break;
      case 'i':  input=optarg;          break;
      case 'o':  output=optarg;         break;
      case 'V':  version();             break;
      case 'c':  ATsetChecking(ATtrue); break;    

      case 'h':  /* drop intended */
      default:   usage();               break;
      }
    }

    if (!strcmp(input, "") || !strcmp(input, "-")) {
      iofile = stdin;
    } else if (!(iofile = fopen(input, "r"))) {
      ATerror("%s: cannot open %s\n", myname, input);
    }

    module = ATreadFromFile(iofile);

    expandedModule = expand_to_asfix(module);
    term = PT_getParseTreeTree(expandedModule);

    if (run_verbose) {
      ATwarning("Reducing ...\n");
    }

    reduct = innermost(term);

    if (run_verbose) {
      ATwarning("Reducing finished.\n");
    }

    ptCcode = toasfix(reduct);

    if (!strcmp(output, "") || !strcmp(output, "-")) {
      iofile = stdout;
    } else if (!(iofile = fopen(output, "w"))) {
      ATerror("%s: cannot open %s\n", myname, output);
    }

    if (run_verbose) {
      ATwarning("Writing: %s\n", output);
    }

    ToC_code(ptCcode, iofile);
    ATfprintf(iofile, "\n");
    fclose(iofile);
  }

  return 0;
}

/*}}}  */
