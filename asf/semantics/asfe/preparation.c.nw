
<<preparation.c*>>=
#include <ctype.h>
#include <asfix.h>
#include "preparation.h"

<<lexicals>>
<<preparation>>
<<restoration>>
@

%{{{ Preparation

\subsection{Preparation}
<<preparation>>=
<<prepare_list>>
<<prepare_conds>>
<<prepare_equ>>
<<prepare_term>>
<<RWprepareTerm>>
<<RWprepareEqs>>
@

%{{{ aterm_list *prepare_list(arena *ar, aterm_list *l, Tbool lexcons)

Prepare a list of AsFix terms. This includes removing any layout,
and translating lexical constructors into lists.

<<prepare_list>>=
aterm *prepare_term(arena *ar, aterm *el, Tbool lexcons);

aterm_list *prepare_list(arena *ar, aterm_list *l, Tbool lexcons)
{
  aterm *el;
  aterm_list *result = t_empty(t_world(l));

  while(!t_is_empty(l)) {
    do {
      el = t_list_first(l);
      l = t_list_next(l);
    } while(asfix_is_whitespace(el) || asfix_is_list_sep(el));
    result = TlistAppend(ar, result, prepare_term(ar, el, lexcons)); 
  }
  return result;
}
@

%}}}
%{{{ aterm_list *prepare_conds(arena *ar, aterm_list *conds)

Remove all layout from a list of conditions.

<<prepare_conds>>=
aterm_list *prepare_conds(arena *ar, aterm_list *conds)
{
  aterm *cond, *lhs, *w[2], *lit, *rhs;
  aterm *newlhs, *newrhs, *newcond;
  aterm_list *newconds = t_empty(NULL);

  while(!t_is_empty(conds)) {
    do {
      cond = t_list_first(conds);
      conds = t_list_next(conds);
    } while(asfix_is_whitespace(cond) || asfix_is_list_sep(cond));
    if(Tmatch(cond, "condition(<term>,<term>,<term>,<term>,<term>)",
			&lhs, &w[0], &lit, &w[1], &rhs)) {
      newlhs = prepare_term(ar, lhs, Tfalse);
      newrhs = prepare_term(ar, rhs, Tfalse);
      newcond = Tmake(ar, "condition(<term>,<term>,<term>,<term>,<term>)",
			newlhs, w[0], lit, w[1], newrhs);
      newconds = TlistAppend(ar, newconds, newcond);
    }
  }
  return newconds;
}
@

%}}}
%{{{ aterm_list *prepare_equ(arena *ar, aterm *equ)

Prepare an equation for rewriting. This includes removing the layout,
and translating lexicals into lists.

<<prepare_equ>>=
aterm_list *prepare_equ(arena *ar, aterm *equ)
{
  aterm *w[6], *l[2], *modname, *tag, *lhs, *rhs;
  aterm *newlhs, *newrhs;
  aterm_list *conds, *newconds;

  if(Tmatch(equ, "ceq-equ(<term>,<term>,<term>,<term>,<term>,<term>,<term>,<term>,<term>)",    
	&modname, &w[0], &tag, &w[1], &lhs, &w[2], &l[0], &w[3], &rhs)) {
    newlhs = prepare_term(ar, lhs, Tfalse);
    newrhs = prepare_term(ar, rhs, Tfalse);
    return Tmake(ar, "ceq-equ(<term>,<term>,<term>,<term>,<term>,<term>,<term>,<term>,<term>)",
	modname, w[0], tag, w[1], newlhs, w[2], l[0], w[3], newrhs);
  }

  if(Tmatch(equ, "ceq-impl(<term>,<term>,<term>,<term>,<term>,<term>,<term>,"\
				"<term>,<term>,<term>,<term>,<term>,<term>)",
	&modname, &w[0], &tag, &w[1], &conds, &w[2], &l[0], &w[3], 
	&lhs, &w[4], &l[1], &w[5], &rhs)) {
    newlhs = prepare_term(ar, lhs, Tfalse);
    newrhs = prepare_term(ar, rhs, Tfalse);
    newconds = prepare_conds(ar, conds);
    return Tmake(ar, "ceq-impl(<term>,<term>,<term>,<term>,<term>,<term>," \
			"<term>,<term>,<term>,<term>,<term>,<term>,<term>)",
	modname, w[0], tag, w[1], newconds, w[2], l[0], w[3], 
	newlhs, w[4], l[1], w[5], newrhs);
  }

  if(Tmatch(equ, "ceq-when(<term>,<term>,<term>,<term>,<term>,<term>,<term>,"\
				"<term>,<term>,<term>,<term>,<term>,<term>)",
	&modname, &w[0], &tag, &w[1], &lhs, &w[2], &l[0], &w[3],
	&rhs, &w[4], &l[1], &w[5], &conds)) {
    newlhs = prepare_term(ar, lhs, Tfalse);
    newrhs = prepare_term(ar, rhs, Tfalse);
    newconds = prepare_conds(ar, conds);
    return Tmake(ar, "ceq-when(<term>,<term>,<term>,<term>,<term>,<term>" \
			"<term>,<term>,<term>,<term>,<term>,<term>,<term>)",
	modname, w[0], tag, w[1], newlhs, w[2], l[0], w[3],
	newrhs, w[4], l[1], w[5], newconds);
  }
  Tprintf(stderr, "equation: %t not supported..\n", equ);
  assert(0);
  return NULL;	/* Silence the compiler */
}
@

%}}}
%{{{ aterm *prepare_term(arena *ar, aterm *t, Tbool lexcons)

Remove the layout of a term.

<<prepare_term>>=
aterm *prepare_term(arena *ar, aterm *t, Tbool lexcons)
{
  aterm_list *args, *elems, *newargs;

  if(asfix_is_appl(t)) {
    args = asfix_get_appl_args(t);
    if(asfix_is_lex_constructor(t))
      newargs = prepare_list(ar, args, Ttrue);
    else
      newargs = prepare_list(ar, args, Tfalse);
    return asfix_put_appl_args(ar, t, newargs);
  }

  if(asfix_is_list(t)) {
    aterm_list *result;
    elems = asfix_get_list_elems(t);
    result = asfix_put_list_elems(ar, t, prepare_list(ar, elems, lexcons));
    return result;
  }

  if(asfix_is_lex(t) && !lexcons)
    return lexical_to_list(ar, t);

  return t;
}
@

%}}}

%{{{ aterm *RWprepareTerm(arena *ar, aterm *t)

<<RWprepareTerm>>=
aterm *RWprepareTerm(arena *ar, aterm *t)
{
  return prepare_term(ar, t, Tfalse);
}
@

%}}}
%{{{ aterm_list *RWprepareEqs(arena *ar, aterm_list *eqs)

Prepare a list of equations for rewriting.

<<RWprepareEqs>>=
aterm_list *RWprepareEqs(arena *ar, aterm_list *eqs)
{
  aterm *el;
  aterm_list *result = t_empty(t_world(*ar));

  while(!t_is_empty(eqs)) {
    do {
      el = t_list_first(eqs);
      eqs = t_list_next(eqs);
    } while(asfix_is_whitespace(el) || asfix_is_list_sep(el));
    result = TlistAppend(ar, result, prepare_equ(ar, el)); 
  }
  return result;
}
@

%}}}

%}}}
%{{{ Restoration

\subsection{Restoration}

<<restoration>>=
<<restore_list>>
<<restore_args>>
<<RWrestoreTerm>>
@

%{{{ aterm_list *restore_list(arena *ar, aterm *sym, aterm_list *l)

Restore a list after reweriting. Insert whitespace and optionally
separators.

<<restore_list>>=
aterm_list *restore_list(arena *ar, aterm *sym, aterm_list *l)
{
  aterm *lit;
  aterm *el, *sep, *newsep, *ws[2];
  aterm_list *newl = t_empty(t_world(l));

  ws[0] = Tmake(ar, "w(\" \")");
  ws[1] = Tmake(ar, "w(\"\\n\")");
  if(asfix_is_itersep(sym)) {
    sep = asfix_get_separator(sym);
    assertp(Tmatch(sep, "ql(<term>)", &lit));
    newsep = Tmake(ar, "sep(<term>)", lit);
    while(!t_is_empty(l)) {
      el = t_list_first(l);
      newl  = TlistAppend(ar, newl, RWrestoreTerm(ar, el));
      l = t_list_next(l);
      if(!t_is_empty(l))
	newl = TlistConcat(ar, newl, TmkList_n(ar, 3, ws[0], newsep, ws[1]));
    }
  } else {
    while(!t_is_empty(l)) {
      el = t_list_first(l);
      newl  = TlistAppend(ar, newl, RWrestoreTerm(ar, el));
      l = t_list_next(l);
      if(!t_is_empty(l))
        newl = TlistAppend(ar, newl, ws[0]);
    }
  }
  return newl;
}
@

%}}}
%{{{ aterm_list *restore_args(arena *ar, aterm_list *l)

Restore a list of arguments after rewriting. This includes
the restoration of layout between arguments.

<<restore_args>>=
aterm_list *restore_args(arena *ar, aterm_list *l)
{
  aterm *arg, *ws;
  aterm_list *newl = t_empty(t_world(l));

  ws = Tmake(ar, "w(\" \")");
  while(!t_is_empty(l)) {
    arg = t_list_first(l);
    newl = TlistAppend(ar, newl, RWrestoreTerm(ar, arg));
    l = t_list_next(l);
    if(!t_is_empty(l))
      newl = TlistAppend(ar, newl, ws);
  }
  return newl;
}
@

%}}}
%{{{ aterm *RWrestoreTerm(arena *ar, aterm *t)

<<RWrestoreTerm>>=
aterm *RWrestoreTerm(arena *ar, aterm *t)
{
  aterm_list *args, *elems;
  aterm *sym;

  if(asfix_is_appl(t)) {
    if(asfix_is_lex_constructor(t))
      return list_to_lexical(ar, t);
    args = asfix_get_appl_args(t);
    return asfix_put_appl_args(ar, t, restore_args(ar, args));    
  }

  if(asfix_is_list(t)) {
    elems = asfix_get_list_elems(t);
    sym   = asfix_get_list_sym(t);
    return asfix_put_list_elems(ar, t, restore_list(ar, sym, elems));
  }

  return t;
}
@

%}}}

%}}}
%{{{ lexicals

\subsection{Lexicals}
<<lexicals>>=
<<lexical_to_list>>
<<list_to_lexical>>
@

%{{{ aterm *lexical_to_list(arena *ar, aterm *lextrm)

{\tt lexical\_to\_list} converts a lexical into a list.

<<lexical_to_list>>=
aterm *lexical_to_list(arena *ar, aterm *lextrm)
{
  aterm *sort, *newtrm, *newlex, *newname, *newiter;
  aterm *newargs, *newfargs, *newprod, *newappl;
  int i, l;
  char cbuf[4] = "\" \"", *lexstr, *sortstr;
  aterm_list *newtrmlist = t_empty(t_world(lextrm));

  sort = asfix_get_lex_sort(lextrm);
  assertp(Tmatch(sort, "sort(<str>)", &sortstr));
  sortstr = strdup(sortstr);
  for(i=0; sortstr[i]; i++)
     sortstr[i] = tolower(sortstr[i]);
  /* Get the string name that represents the lexical */
  lexstr = t_sym_name(t_appl_sym(asfix_get_lex_str(lextrm)));
  l = strlen(lexstr);
  for(i=0; i<l; i++) {
    cbuf[1] = lexstr[i];
    newtrm = Tmake(ar, "lex(<str>,sort(\"CHAR\"))", cbuf, sort);
    newtrmlist = TlistAppend(ar, newtrmlist, newtrm);
  }
  newname  = Tmake(ar, "l(<str>)", sortstr);
  newiter  = Tmake(ar, "iter(sort(\"CHAR\"),w(\"\"),l(\"+\"))");
  newlex   = Tmake(ar, "list(<term>,w(\"\"),<list>)", newiter, newtrmlist);
  newfargs = Tmake(ar, "[<term>,w(\"\"),ql(\"(\"),w(\"\"),<term>,w(\"\"),ql(\")\")]",newname, newiter);
  newargs  = Tmake(ar, "[<term>,l(\"(\"),<term>,l(\")\")]", newname, newlex);
  newprod  = Tmake(ar, "prod(id(\"caller\"),w(\"\"),<term>,w(\"\")," \
			"l(\"->\"),w(\"\"),<term>,w(\"\"),no-attrs)",newfargs,sort);
  newappl  = Tmake(ar, "appl(<term>,w(\"\"),<term>)", newprod, newargs);

  free(sortstr);
  return newappl;
}
@

%}}}
%{{{ aterm *list_to_lexical(arena *a, aterm *lexappl)

{\tt list_to_lexical} converts  a list representing a lexical into a
lexical again. 

<<list_to_lexical>>=
aterm *list_to_lexical(arena *ar, aterm *lexappl)
{
  aterm *modname, *lit, *sort, *w[4], *prod, *sym, *lexlist;
  aterm *listarg, *charsort, *newlexappl;
  char *lexstr, *newlexstr;
  aterm_list *args, *lexargs, *listargs;
  int len, i;

  assertp(Tmatch(lexappl, "appl(<term>,<term>,<list>)", &prod, &w[0], &lexargs));
  assertp(Tmatch(prod, "prod(<term>,<term>,<list>,<term>,<term>,<term>," \
	"<term>,<term>,no-attrs)", &modname, &w[0], &args, &w[1], 
						&lit, &w[2], &sort, &w[3]));
  lexlist = TlistIndex(lexargs, 2);
  assertp(Tmatch(lexlist,"list(<term>,<term>,<list>)",&sym,&w[0],&listargs));
  len = TlistSize(listargs);
  newlexstr = (char *)malloc(len+1);
  i = 0;
  while(!t_is_empty(listargs)) {
    listarg = t_list_first(listargs);
    if(Tmatch(listarg, "lex(<str>,<term>)", &lexstr, &charsort))
      newlexstr[i++] = lexstr[1];
    listargs = t_list_next(listargs);
  }
  newlexstr[i] = '\0';
  newlexappl = Tmake(ar, "lex(<str>,<term>)", newlexstr, sort);
  free(newlexstr);
  return newlexappl;
}
@

%}}}

%}}}
