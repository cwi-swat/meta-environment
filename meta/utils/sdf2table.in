#! /bin/sh
# $Id$
Revision='$Revision$'

prefix=@prefix@
exec_prefix=@exec_prefix@
bindir=@bindir@
libdir=@libdir@

PATH="$PATH:$bindir"

RM=rm
PARSER="${bindir}/parse-sdf2 -1"
GENERATOR="${bindir}/gen-table"

verbose=0;
error=0;

###
#  Handle the command line, &c.
###

myname=`basename $0`
myversion=`echo $Revision| cut -d' ' -f2`

# The argument vector: list of option letters, colons denote option
# arguments.  See Usage function, immediately below, for option
# explanation.
myarguments="bfhi:o:stvV"

# Usage: displays helpful usage information
Usage() {
cat << E_O_USAGE >&2
Usage: $myname [options]
Options:
    -b              write output in Binary AsFix (BAF) format
    -f              use handcrafted normalizer ('fast')
    -h              display help information (usage)
    -i _file_       input from _file_ (default: all file arguments)
    -o _file_       output to _file_ (default: _inputfile_.tbl)
    -s              use generated normalizer ('slow')
    -t              write output in plain text format
    -v              verbose mode
    -V              reveal program version (i.e. $myversion)
E_O_USAGE
	exit 1
}

Version() {
    echo "$myname v$myversion" >&2
}

# getopt handles command line...
args=`getopt $myarguments $* 2> /dev/null`
if test $? != 0
then
        Usage
        exit 2
fi
set -- $args

# Argument interpretation...
while [ $#  -gt 0 ]
do
    case "$1"
    in
	-b)
            PGOPTS="$PGOPTS $1" ;;
        -f)
            PGOPTS="$PGOPTS $1" ;;
        -h)
            Usage ; exit 0 ;;
        -i)
            shift ; Files="$1 $Files" ;;
        -o)
            shift ; output=$1 ;;
        -s)
            PGOPTS="$PGOPTS $1" ;;
	-t)
            PGOPTS="$PGOPTS $1" ;;
        -v)
            verbose=1 ; VERBOSE="$1"; PGOPTS="$PGOPTS $1";;
        -V)
            Version ; exit 0 ;;
        --)
            ;;
    # Add additional command line options here...
    *)
            Files="$Files $1" ;;
    esac
    shift
done


###
#  Get to the real work now...
###


Warn () {
	echo $*                                   	>&2
}

Error () {
	Warn $*
	error=1
}

Abort () {
	Error $*
	exit 2
}

Notify () {
	if [ $verbose -gt 0 ] ; then
		Warn $*
	fi
}


#
## Main bit...
#

if [ -z "$Files" ] ; then
	Files="-"
fi

for f in $Files
do
	if [ "$f" = "-" ] ; then
                af1name=${TMPDIR:-/var/tmp}/stdin.$$.asfix1
		tblname=${output:-"-"}
	else
		base=`basename $f`.sdf2
		dir=`dirname $f`
                af1name=${TMPDIR:-/var/tmp}/$base.asfix1
		tblname=${output:-$dir/$base.tbl}
	fi
	Notify "Parsing $f..."
	if $PARSER $VERBOSE -i $f -o $af1name
	then
	        Notify "Generating parse table ..."
	        if $GENERATOR $PGOPTS -i $af1name -o $tblname
		then
			${RM} -f $af1name
		else
			Warn "Error rewriting $f"
			error=1
		fi
	else
		Warn "Error parsing $f (see $af1name)"
		error=1
	fi
done

exit $error;
