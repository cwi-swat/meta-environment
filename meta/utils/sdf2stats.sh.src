#! /bin/sh
#
#   Meta-Environment - An environment for language prototyping.
#   Copyright (C) 2000  Stichting Mathematisch Centrum, Amsterdam,
#                       The Netherlands.
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
#
#   $Id$    

Revision='$Revision$'

bindir=__BINDIR__
datadir=__DATADIR__
pgen=__SDF__

PATH="$bindir:$PATH"

TABLE="${pgen}/share/pgen/Sdf2.baf"
EQS="${datadir}/CountProds.asf.baf"
PARSE="sglr -p $TABLE -s SDF -1"
APPLYFUNC="apply-function -f count-prods -s IntPair -m CountProds"
EVALUATOR="evaluator -e $EQS"
ASOURCE="asource"
RM="rm"

###
#  Handle the command line, &c.
###

myname=`basename $0`
myversion=`echo $Revision| cut -d' ' -f2`

# The argument vector: list of option letters, colons denote option
# arguments.  See Usage function, immediately below, for option
# explanation.
myarguments="i:hV"

# Usage: displays helpful usage information
Usage() {
cat << E_O_USAGE >&2
Usage: $myname [options]
Options:
        -h       : display usage information
        -i file  : input from |file|                    [-]
        -V       : reveal program version (i.e. $myversion)
E_O_USAGE
}

Version() {
    echo "$myname v$myversion" >&2
}

# getopt handles command line...
args=`getopt $myarguments $* 2> /dev/null`
if test $? != 0
then
        Usage
        exit 2
fi
set -- $args 

# Argument interpretation...
while [ $#  -gt 0 ]
do
    case "$1"
    in                 
        -i)
            Files="$2 $Files"; shift ;;         
        -h)
            Usage ; exit 0 ;;
        -V)
            Version ; exit 0 ;; 
        --)
            ;;
        *)
            Files="$Files $1" ;;
    esac
    shift
done  

###
#  Get to the real work now...
###


Warn () {
        echo $*                                         >&2
}

Error () {
        Warn $*
        error=1
}

Abort () {
        Error $*
        exit 2
}        

Notify () {
        if [ $verbose -gt 0 ] ; then
                Warn $*
        fi
}


#
## Main bit...
#

if [ -z "$Files" ] ; then
        Files="-"
fi   

for f in $Files
do                      
if [ "$f" = "-" ] ; then
	echo "Please give input file!"             >&2
	exit 1
else
	if $PARSE -i $f -o $f.af1
	then
		$APPLYFUNC -i $f.af1 -o $f.af1.fnc
		$RM $f.af1
		$EVALUATOR -i $f.af1.fnc -o $f.af1.red
		$RM $f.af1.fnc
		$ASOURCE -i $f.af1.red -o sdf2-stats.txt
		$RM $f.af1.red
	else
		echo "Parse error!"             >&2
		exit 1
	fi 
fi
done
