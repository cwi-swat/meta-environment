
#
# $Id$


# GraphBrowser: UI for ASF+SDF meta-environment
#               (and viewer for ASF+SDF import graphs)
#


#----------------------------------------------------------------------
# help texts
#----------------------------------------------------------------------

#set toolname "Meta-Environment"
set toolname "Graph Browser"
set metaname "Meta-Environment"
set use_tide "__USE_TIDE__" 

set help_meta "$metaname

A Meta-environment for ASF+SDF
Copyright (C) 2000/2001  CWI

$metaname development team:
Mark van den Brand, Hayco de Jong, Merijn de Jonge,
Tobias Kuipers, Leon Moonen, Pieter Olivier, 
Jeroen Scheerder, Jurgen Vinju

Department of Software Technology, CWI"

set help_about "$toolname  -  ASF+SDF Import Graph Browser
Copyright (C) 2000/2001  Leon Moonen <leon@cwi.nl>

$toolname provides a graphical view of an ASF+SDF import graph.
The layout of this graph is computed using the dot layout algorithm
developed by AT&T."

set help_mouse "               $toolname - Mouse Operations

Mouse Button:
  - Pops up a contextual menu on the canvas.
  - Selects modules in the Modules list.
Secondary Button (usually Middle or Rightmost, if it exists):
  - Repositions the canvas under the window.
  - Scrolls through the module list.
Tertiary Button (usually Rightmost, if it exists):
  - Pops up a contextual menu on canvas and Modules list.

The dot layout algorithm can be (re-)applied by clicking on
the ``button'' in the lower right corner of the canvas."

#----------------------------------------------------------------------
# packages
#----------------------------------------------------------------------
package require Tcldot

#----------------------------------------------------------------------
# constants
#----------------------------------------------------------------------

# switch to enable/disable printing of diagnostics to stderr
set DIAG 0
# switch to enable/disable debug support
set DEBUG 0

# Cf. Golden Rectangle
set MAXWINSIZE {1078 666}
set MINWINSIZE {356 220}

# width of scrollbars
set SBW 8

# style for "shadowed" modules (i.e. modules that aren't loaded
# but we know they are there)
set SHADOWSTYLE ellipse
set MODULESTYLE box

#----------------------------------------------------------------------
# global variables (bweghh!)
#----------------------------------------------------------------------
global saveFill fileName printCommand g c statuslist

# animation of loading of modules
set animate 0

# resizing after loading of modules
set autoresize 1

# toggle during opening of modules (to turn of animation)
set opening 0

set openhelp 0

# counter for window id's
set windowcnt 1

# message in the status window
set status "Idle"

# initialize statuslist
set statuslist {}

#----------------------------------------------------------------------
# TB interaction functions
#----------------------------------------------------------------------

# INGOING  (note some proc's are also used internally)

#---
# snd-do(delete-module(Mod))
#-
# "Deletes" the named module i.e. turns it into shadowstyle
# and deletes all edges that start in that module.
# The proc update-graph is performed afterwards.
#---
proc delete-module { mod } {
    global g SHADOWSTYLE
    GBin "delete-module($mod)"
    set node [$g findnode [StripId $mod]]
    $node setattributes shape $SHADOWSTYLE

    foreach edge [$node listoutedges] {
	$edge delete
    }
    update-graph
}

#---
# snd-do(new-graph([Mod1, Mod2,...[[Mod, Mod1], [Mod2, Mod3], ... , [Modn, Modm]]))
#-
# Creates a new import graph based on a list of modules (nodes) and
# their import relations (directed edges). The modules are those that
# occur in the module database. The import relation is given as a list
# of pairs where an element [A,B] denotes A imports B. Modules and
# edges are added only once.

#---
proc new-graph { modlist implist } {
    global g MODULESTYLE
    GBin "new-graph($modlist, $implist)"


    foreach graphnode [$g listnodes] {
	$graphnode delete
    }

    foreach mod $modlist {
	$g addnode [StripId $mod] shape $MODULESTYLE
    }

    foreach rel $implist {
	AddUniqueEdge $g [$g addnode [StripId [lindex $rel 0]]] \
	    [$g addnode [StripId [lindex $rel 1]]]
    }

    update-graph
}


#---
# snd-do(finished-opening-modules(Mod))
#-
# notifies finishing of opening of modules (to turn on/off animation)
#---
proc finished-opening-modules { mod } {
    global opening

    set opening 0
    update-graph
}


#---
# snd-do(update-graph)
#-
# redraws the canvas based on the internal TclDot graph-structure
#---
proc update-graph {} {
    global g c opening animate autoresize

    if {$animate || !$opening} {
	$c delete all
	$g layout .b.h .a.v
	eval [$g render]
	set bbox [$c bbox all]
	if {$bbox == {}} { set bbox {0 0 0 0} }
	$c configure -scrollregion $bbox
	UpdateModuleList $g
    }
    if {$autoresize  && !$opening} {
        ViewAll
    }
}


# No longer an external function. Now used internally. Use ui-status notes
# instead. See msm-c.tb for more details.
# For backwards compatibility it can still be called.
#---
# snd-do(set-status(s))
#-
# sets the status message to s
#---
proc set-status { str } {
    global status
    set status [TCLstring $str]
}

#---
# snd-do(add-statusf(id,format,args))
#-
# sets status message to format(args), for process with id id. Only called from process
# Status-display. Should not be used directly.
#---
proc add-statusf { id format args } {
#  Why do we need to strip of a list layer here??
	  set nwargs [lindex $args 0] 
	  set format [TCLstring $format]

    set str [eval "format \"$format\" $nwargs"]
    
	  add-status $id $str
}

#---
# snd-do(add-status(id,str))
#-
# sets status message to format, for process with id id. Only called from process
# Status-display. Should not be used directly.
#---
proc add-status { id str } {
    global statuslist

    set str [TCLstring $str]
    set pair {}
    lappend pair $id
    lappend pair $str
    set statuslist [linsert $statuslist 0 $pair]
    set-status $str
}

#---
# snd-do(end-status(id))
#-
# remove all status messages for process id from the status list. Only called
# from process Status-display. Should not be called directly.
#---
proc end-status { id } {
    global statuslist
    
    set listrm {}
    for {set i [expr [llength $statuslist]-1]} {$i >= 0} {incr i -1} {
	if {[lindex [lindex $statuslist $i] 0] == $id} {
	    lappend listrm $i
	}
    }
    set corr 0
    foreach i $listrm {
	set i [expr $i - $corr]
	set statuslist [lreplace $statuslist $i $i]
	incr corr
    }
    if {$statuslist == {}} {
	set-status "Idle"
    } else {
	set-status [lindex [lindex $statuslist 0] 1]
    }
}

#---
# snd-do(module-info(Mod, [["dir",...],...,[x,y]]))
#-
# Pops up an information window with info on module Mod. The info
# is read from a list of tuples, where both elements of a tuple
# are interpreted as strings.
#---
proc module-info { mod infolist } {
    global windowcnt SBW toolname
    GBin "module-info($mod,$infolist)"
    set mod [StripId $mod]
    set w ".info$windowcnt"
    set windowcnt [expr $windowcnt + 1]
    catch {destroy $w}
    toplevel $w
    wm title $w "$toolname Info on $mod"
    wm iconname $w "Info on $mod"

    frame $w.info -relief raised -bd 2
    pack $w.info -side top -fill x

    scrollbar $w.info.yscroll -width $SBW -command "$w.info.list yview"
    scrollbar $w.info.xscroll -width $SBW -orient horizontal \
        -command "$w.info.list xview"

    # note: choose monospaced font for listbox!!!
    listbox $w.info.list -width 40 -height 8 -setgrid 1 -selectmode none \
        -yscroll "$w.info.yscroll set" -xscroll "$w.info.xscroll set" \
        -font -adobe-courier-bold-r-normal--*-120-*-*-m-*-iso8859-1

    grid $w.info.list    -row 0 -column 0 -rowspan 1 -columnspan 1 -sticky news
    grid $w.info.yscroll -row 0 -column 1 -rowspan 1 -columnspan 1 -sticky news
    grid $w.info.xscroll -row 1 -column 0 -rowspan 1 -columnspan 1 -sticky news
    grid rowconfig    $w.info 0 -weight 1 -minsize 0
    grid columnconfig $w.info 0 -weight 1 -minsize 0

    frame $w.buttons
    pack  $w.buttons -side bottom -expand y -fill x -pady 2m
    button $w.buttons.dismiss -text Dismiss -command "destroy $w"
    pack $w.buttons.dismiss -side left -expand 1

    set longest 0
    foreach tup $infolist {
        set length [string length [lindex $tup 0]]
	if {$length > $longest} { set longest $length }
    }
    set formatstr [format "%%-%ds : %%s" $longest]
    foreach tup $infolist {
        $w.info.list insert end [format $formatstr \
		[TCLstring [lindex $tup 0]] [TCLstring [lindex $tup 1]]]
    }
}


#---
# snd-do(errorf(fmt,args))
#-
# pops up a formatted error window which cannot be ignored
#---
proc errorf {fmt args} {
# Why do we need to strip of a list layer here??
    set nwargs [lindex $args 0]
    set fmt [TCLstring $fmt]

    set errormsg [eval "format \"$fmt\" $nwargs"]

    set button [tk_messageBox -icon error -type ok \
	-title Message -parent . -message $errormsg]
}

#---
# snd-do(error(Msg))
#-
# pops up an error window which cannot be ignored
#---
proc error {msg} {
    set button [tk_messageBox -icon error -type ok \
	-title Message -parent . -message [TCLstring $msg]]
}



#---
# rec-ack-event(e)
#-
# prints diagnostics
#---
proc rec-ack-event { arg } {
    global g
    GBin "rec-ack-event($arg)"

    TBack $arg
}


#---
# rec-terminate(m)
#-
# prints diagnostics, the termination message and exits
#---
proc rec-terminate { arg } {
    GBin "rec-ack-event($arg)"
    exit
}


#----------------------------------------------------------------------
# event handling functions
#----------------------------------------------------------------------

# as the mouse moves over an object change its shading
proc mouse_anyenter {c} {
    global saveFill
    set obj [string range [lindex [$c gettags current] 0] 1 end]
    set type [string range $obj 0 3]

    if {$type == "node"} {
        GBmsg "$type $obj"
	set saveFill [list $obj [lindex [$c itemconfigure 1$obj -fill] 4]]
	$c itemconfigure 1$obj -fill black -stipple gray12
    }
}

# as the mouse moves out of an object restore its shading
proc mouse_anyleave {c} {
    global saveFill
    set obj [string range [lindex [$c gettags current] 0] 1 end]
    set type [string range $obj 0 3]
    if {$type == "node"} {
	$c itemconfigure 1[lindex $saveFill 0] \
		-fill [lindex $saveFill 1] -stipple {}
    }
}

proc mouse_b1_press {c x y} {
    global g SHADOWSTYLE

    set obj [GetObject $c]
    if {$obj != {}} {
	set type [string range $obj 0 3]
	if {$type == "node"} {
  	  if {[$obj queryattributes shape] == $SHADOWSTYLE} {
            tk_popup .shadowmodule-popup $x $y
	  } else {
            tk_popup .module-popup $x $y
          }
	} else {
          tk_popup .canvas-popup $x $y
        }
    } else {
        tk_popup .canvas-popup $x $y
    }
}

#----------------------------------------------------------------------
# other functions
#----------------------------------------------------------------------


#--
# GBevent(event)
#-
# sends 'snd-event(event)' to the TB
#--
proc GBevent { event } {
    TBsend "snd-event($event)"
    GBmsg "outgoing event: $event"
}


#--
# GBpost(event)
#-
# posts 'snd-event(event)' to the TB
#--
proc GBpost { event } {
    TBpost $event
    GBmsg "posting event: $event"
}


#--
# GBvalue(value)
#-
# sends 'snd-value(value)' to the TB
#--
proc GBvalue { value } {
    TBsend "snd-value($value)"
    GBmsg "outgoing value: $value"
}


#--
# GBin(s)
#-
# prints diagnostics on stderr
#--
proc GBin { s } {
    GBmsg "incoming: $s"
}


#--
# GBmsg(msg)
#-
# prints diagnostics on stderr
#--
proc GBmsg { msg } {
    global DIAG
    if {$DIAG} {puts stderr "GB: $msg"}
}


#--
# GetObject(c)
#-
# returns the id of the object that is currently selected on canvas c
#--
proc GetObject { c } {
    return [string range [lindex [$c gettags current] 0] 1 end]
}


#--
# GetObjectName(c)
#-
# returns the name of the object that is currently selected on canvas c
# (object needs to have a showname function which is the case with TclDot
# object)
#--
proc GetObjectName { c } {
    return [[GetObject $c] showname]
}


#--
# SelectedModules()
#-
# returns the list of modules currently selected in the modules listbox
#--
proc SelectedModules {} {
    set selection {}
    foreach ind [.modules.list curselection] {
	lappend selection [.modules.list get $ind]
    }
    return $selection
}


#--
# EditModules(ML)
#-
# generates the toolbus event to request editing of modules ML
#--
proc EditModules { modlist } {
    foreach mod $modlist {
	GBpost [format "edit-module(%s)" [ToId $mod]]
    }
}

proc EditSyntaxModules { modlist } {
    foreach mod $modlist {
	GBpost [format "edit-module(%s)" [ToId $mod]]
    }
}

proc EditEquationsModules { modlist } {
    foreach mod $modlist {
	GBpost [format "edit-eqs-module(%s)" [ToId $mod]]
    }
}


#--
# EditTerm(M,F)
#-
# generates the toolbus event to request editing of a term in F over module M
# 
#--
proc EditTerm {mod file} {
    GBevent [format "edit-term(%s,%s)" [ToId $mod] [ToId $file]]
}


#--
# SaveModules(ML)
#-
# generates the toolbus event to request saving of modules ML
#--
proc SaveModules { modlist } {
    foreach mod $modlist {
        GBpost [format "save-module(%s)" [ToId $mod]]
    }
}


#--
# RevertModules(ML)
#-
# generates the toolbus event to request reverting of modules ML
#--
proc RevertModules { modlist } {
    foreach mod $modlist {
        GBpost [format "revert-module(%s)" [ToId $mod]]
    }
}


#--
# PrintModules(ML)
#-
# generates the toolbus event to request print the ascii text of modules ML
#--
proc PrintModules { modlist } {
    foreach mod $modlist {
        GBpost [format "print-module(%s)" [ToId $mod]]
    }
}


#--
# DeleteModules(ML)
#-
# generates the toolbus event to delete modules ML.
#--
proc DeleteModules { modlist } {
    foreach mod $modlist {
        GBpost [format "delete-module(%s)" [ToId $mod]]
    }
}


#--
# CompileModules(ML)
#-
# generates the toolbus event to request compilation of modules ML
#--
proc CompileModules { modlist } {
    foreach mod $modlist {
	set posting \
	[format "compile-module(%s)" [ToId $mod]]
	GBpost $posting
    }
}

#--
# DumpParseTable(M)
#-
# generates the toolbus event to request dump the parse table for module M
#--
proc DumpParseTable { module } {
  GBevent "dump-parse-table([ToId $module])"
}
   
#--
# DumpEquations(M)
#-
# generates the toolbus event to request dump of equations for module M
#--
proc DumpEquations { module } {
  GBevent "dump-equations([ToId $module])"
}

#--
# RenameModule(M)
#-
# generates the toolbus event to request renaming of a module M
#--
proc RenameModule { mod newmod newpath} {
    GBevent "rename-module([ToId $mod],[ToId $newmod], [ToId $newpath])"
}

#--
# CopyModule(M)
#-
# generates the toolbus event to request copying of a module M
#--
proc CopyModule { mod newmod newpath} {
    GBevent "copy-module([ToId $mod],[ToId $newmod], [ToId $newpath])"
}

#--
# RenameModuleWidget(M)
#-
# generates a widget to enter the new name for the selected module.
#--
proc RenameModuleWidget {module} {
  global syntax_ext

  set sdftype {{SDF}}
  lappend sdftype $syntax_ext
  set anytype {{Any}    *          }
  lappend types $sdftype
  lappend types $anytype

  set file [tk_getSaveFile -initialfile [lindex [split $module "/"] end]  \
            -filetypes $types -title "Rename Module..."]

  if [ expr [ string length $file ] > 0 ] {
    set newmodule [lindex [split $file "/"] end]
    RenameModule $module $newmodule $file 
  }
}

#--
# CopyModuleWidget(M)
#-
# generates a widget to enter the new name for the selected module.
#--
proc CopyModuleWidget {module} {
  global syntax_ext

  set sdftype {{SDF}}
  lappend sdftype $syntax_ext
  set anytype {{Any}    *          }
  lappend types $sdftype
  lappend types $anytype

  set file [tk_getSaveFile -initialfile [lindex [split $module "/"] end]  \
            -filetypes $types -title "Copy Module..."]

  if [ expr [ string length $file ] > 0 ] {
    set newmodule [lindex [split $file "/"] end]
    CopyModule $module $newmodule $file 
  }
}

#--
# NewModule(M)
#-
# generates the toolbus event to request addition of a new module
# and destroys the widget $w.
#--
proc NewModule { file } {
    global opening syntax_ext

    set opening 1

# Get the module name...
    set mod [GetBasename $file "$syntax_ext"]
# ... and open it.
    GBevent [format "new-module(%s,%s)" [ToId $file] [ToId $mod]]
}


#--
# OpenModule(M)
#-
# generates the toolbus event to request addition of a module
# and destroys the widget $w.
#--
proc OpenModule { file mod } {
    global opening

    set opening 1
    GBevent [format "open-module(%s,%s)" [ToId $file] [ToId $mod]]
}


#--
# OpenModuleHelper(w)
#-
# calls OpenModule for requested module and destroys the widget $w.
#--
proc OpenModuleHelper {w} {
    OpenModule [$w.openModule get]
    destroy $w
}


#--
# ClearAll
#-
# generates the toolbus event to request clearing of all modules
#--
proc ClearAll {c g} {
    GBevent "clear-all"
    $g delete
    set g [make-and-init-new-graph]
    $c delete all
    update-graph
}


#--
# SaveAll
#-
# generates the toolbus event to request saving of all modules
#--
proc SaveAll {} {
    GBevent "save-all"
}


#--
# RefreshButtons
#-
# generates the toolbus event to request refreshing of buttons
#--
proc RefreshButtons {} {
    GBevent "refresh-buttons"
}



#--
# GetModuleInfo(ML)
#-
# generates the toolbus event to request module info for modules ML
#--
proc GetModuleInfo { modlist } {
    foreach mod $modlist {
        GBpost [format "get-module-info(%s)" [ToId $mod]]
    }
}


#--
# ToId(m)
#-
# returns id("m")
#--
proc ToId { mod } {
    return [TBstring $mod]
}


#--
# StripId(id("m"))
#-
# returns m
#--
proc StripId { trm } {
    return [TCLstring $trm]
#return [string range $trm 4 [expr [string length $trm] - 3]]
}


#--
# ViewAll
#-
# enlarges the window to contain the full graph (clipped MAX/MIN WINSIZE)
#--
proc ViewAll {} {
    global c MAXWINSIZE MINWINSIZE
    set bbox [$c bbox all]
    if {$bbox == {}} { set bbox {0 0 0 0} }

    set w [expr [lindex $bbox 2] - [lindex $bbox 0]]
    set h [expr [lindex $bbox 3] - [lindex $bbox 1]]

    if [expr $w > [lindex $MAXWINSIZE 0]] {set w [lindex $MAXWINSIZE 0]}
    if [expr $h > [lindex $MAXWINSIZE 1]] {set h [lindex $MAXWINSIZE 1]}
    if [expr $w < [lindex $MINWINSIZE 0]] {set w [lindex $MINWINSIZE 0]}
    if [expr $h < [lindex $MINWINSIZE 1]] {set h [lindex $MINWINSIZE 1]}

    $c configure -scrollregion $bbox -width $w -height $h
}

proc OpenModuleWidget {} {
  OpenWidget "Open Module..." "."
}

proc initialize-ui {name libloc syn_ext sem_ext t_ext} {
global metaname library_dir syntax_ext semantics_ext term_ext

  set metaname [TCLstring $name] 
  wm title . $metaname

  set library_dir [TCLstring $libloc]
  set syntax_ext  [TCLstring $syn_ext]
  set semantics_ext  [TCLstring $sem_ext]
  set term_ext  [TCLstring $t_ext]
}

proc OpenLibModuleWidget {} {
  global library_dir

  OpenWidget "Open Library Module ..." $library_dir
}

proc OpenWidget {title location} {
  global syntax_ext
  
  set sdftype {{SDF}}
  lappend sdftype $syntax_ext
  set anytype {{Any}    *          }
  lappend types $sdftype
  lappend types $anytype

  set file [tk_getOpenFile -initialdir $location -filetypes $types \
                                       -title $title]
  set mod [GetBasename $file "$syntax_ext"]
  if [ expr [ string length $mod ] > 0 ] {
    OpenModule $file $mod
  }
}

proc GetBasename {fnam ext} {
  set start [string last "/" $fnam]
  if [expr $start < 0]  {
    set start 0
  } else {
    set start [expr $start + 1 ]
  }
  set end [string last $ext $fnam]
  if [expr $end < 0]  {
    set end [string length $fnam]
  } else {
    set end [expr $end - 1 ]
  }
  set fnam [string range  $fnam $start $end]

  return $fnam
}

proc NewModuleWidget {} {
  global syntax_ext

  set sdftype {{SDF}}
  lappend sdftype $syntax_ext
  set anytype {{Any}    *          }
  lappend types $sdftype
  lappend types $anytype

  set file [tk_getSaveFile -filetypes $types -title "New Module..."]

  if [ expr [ string length $file ] > 0 ] {
    NewModule $file
  }
}

proc EditTermWidget {mod operation} {
global term_ext

  set termtype {{Terms}}
  lappend termtype $term_ext
  set anytype {{Any}    *          }
  lappend types $termtype
  lappend types $anytype

if {$operation == "open"} {
  set file [tk_getOpenFile -filetypes $types -title "Edit Term over $mod"]
} else {
  set file [tk_getSaveFile -filetypes $types -title "New Term over $mod"]
}

if [ expr [ string length $file ] > 0 ] {
    EditTerm $mod $file
  }
}


proc AddUniqueEdge { graph from to } {
    if [catch {$graph findedge [$from showname] [$to showname]} ] {
	$from addedge $to
    }
}

#--
# OnlineHelp()
#-
# generates the toolbus event to start/stop the online help facility.
#--

proc JitterBug {on} {
  if { $on } {
    GBevent [format "jitterbug-wanted"]
  }
}

proc OnlineHelp {on} { 
  if { $on } {
    GBevent [format "online-help"]
  } else {
    GBevent [format "no-online-help"]
  }
}

proc Help {msg just class} {
    global metaname
    set w ".help$class"
    catch {destroy $w}
    toplevel $w
    wm title $w "$metaname Help"
    wm iconname $w $metaname
    frame $w.menu -relief raised -bd 2
    pack $w.menu -side top -fill x
    label $w.msg -justify $just -text $msg
    pack $w.msg -side top -pady 2m -padx 2m
    frame $w.buttons
    pack  $w.buttons -side bottom -expand y -fill x -pady 2m
    button $w.buttons.dismiss -text Dismiss -command "destroy $w"
    pack $w.buttons.dismiss -side left -expand 1
}

proc Print {} {
    global g printCommand
    if {[catch {open "| $printCommand" w} f]} {
        Warning "Unable to open pipe to printer command:\n$printCommand; return"
    }
    $g write $f ps
    close $f
    message "Graph printed to:\n$printCommand"
}

proc setPrinterCommand {w} {
    global printCommand
    set printCommand [$w.printCommand get]
    message "Printer command changed to:\n$printCommand"
    destroy $w
}

proc printSetup {} {
    global printCommand
    set w .printer
    catch {destroy $w}
    toplevel $w
    wm title $w "Printer"
    wm iconname $w "Printer"
    label $w.message -text "Printer command:"
    entry $w.printCommand
    $w.printCommand insert end $printCommand
    bind $w.printCommand <Return> "setPrinterCommand $w"
    frame $w.buttons
    button $w.buttons.confirm -text OK -command "setPrinterCommand $w"
    button $w.buttons.cancel -text Cancel -command "destroy $w"
    pack $w.buttons.confirm $w.buttons.cancel -side left -expand 1
    pack $w.message $w.printCommand -side top -anchor w
    pack $w.buttons -side bottom -expand y -fill x -pady 2m
}


proc fileDialog {w operation} {
    #   Type names		Extension(s)	Mac File Type(s)
    #
    #---------------------------------------------------------
    set types {
	{"Import graph terms"   {.ig}	        }
	{"Layouted graph files"	{.dot}	        }
	{"Postscript Files"	{.ps .eps .epsi}}
	{"Image Files"		{.gif}		}
	{"Image Files"		{.jpeg .jpg}	}
	{"Image Files"		""		{GIFF JPEG}}
	{"All files"		*}
    }
    if {$operation == "open"} {
	set file [tk_getOpenFile -filetypes $types -parent $w]
    } else {
	set file [tk_getSaveFile -filetypes $types -parent $w \
	    -initialfile Untitled -defaultextension .dot]
    }
    return $file
}

proc saveFileAs {type} {
  set file [fileDialog . save]
  if [ expr [ string length $file ] > 0 ] {
    saveFileByName $file $type
  }
}

proc saveFileByName {name type} {
    global fileName g
    if {[catch {open $name w} f]} {
        Warning "Unable to open file for write:\n$name; return"
    }
    if {$type == "ig"} {
	set fileName $name
	set nodes {}
	set edges {}
	foreach node [$g listnodes] {
	    lappend nodes [ToId [$node showname]]
	}
	foreach node [$g listnodes] {
	    foreach edge [$node listoutedges] {
		set theedge [$edge listnodes]
		lappend edges [format "\[%s,%s\]" \
			[ToId [[lindex $theedge 0] showname]] \
			[ToId [[lindex $theedge 1] showname]]]
	    }
	}
	puts $f [format "graph(nodes(\[%s\]),edges(\[%s\]))" \
		[join $nodes ,] [join $edges ,]]
    } else {
	$g write $f $type
    }
    close $f
}


proc Message {m} {
    set button [tk_messageBox -icon info -type ok \
	-title Message -parent . -message $m]
}


proc Warning {m} {
    set button [tk_messageBox -icon warning -type ok \
	-title Warning -parent . -message $m]
}


proc UpdateModuleList { graph } {
    set modlist {}
    foreach node [$graph listnodes] {
        lappend modlist [$node showname]
    }
    .modules.list delete 0 end
    foreach mod [lsort $modlist] {
        .modules.list insert end $mod
    }
}

proc toggle-debugging {name elem op} {
    global DEBUG

    if {$DEBUG == 1} {
        GBpost "debugging(on)"
    } else {
        GBpost "debugging(off)"
    }
}


proc define-menu-bar {} {
    global toolname metaname DEBUG use_tide

    frame .menu -relief raised -borderwidth 1

    menubutton .menu.file -text "File" -underline 0 -menu .menu.file.menu
    set m .menu.file.menu
    menu $m -tearoff 0
    $m add command -label "New"  -underline 0 -command {NewModuleWidget}
    $m add command -label "Open..." -underline 0 -command {OpenModuleWidget}
    $m add command -label "Open Library..." -underline 0 -command {OpenLibModuleWidget}
    $m add separator
    $m add command -label "Save All" -underline 0 -command {SaveAll}
    $m add command -label "Clear All" -underline 0 -command {ClearAll $c $g}
    $m add separator
    $m add command -label "Refresh Buttons" -underline 0 -command {RefreshButtons}
    $m add separator
    $m add cascade -label "Export" -underline 1 -menu $m.export

    menu $m.export -tearoff 0
    $m.export add command -label "Import-Graph..." -underline 0 -command {saveFileAs ig}
    $m.export add command -label "GIF..." -underline 0 -command {saveFileAs gif}
    $m.export add command -label "ISMAP..." -underline 0 -command {saveFileAs ismap}
    $m.export add command -label "HPGL..." -underline 0 -command {saveFileAs hpgl}
    $m.export add command -label "MIF..." -underline 0 -command {saveFileAs mif}
    $m.export add command -label "PCL..." -underline 1 -command {saveFileAs pcl}
    $m.export add command -label "PostScript..." -underline 0 -command {saveFileAs ps}
    $m add separator
    $m add command -label "Print Setup..." -underline 0 -command {printSetup}
    $m add command -label "Print" -underline 0 -command {Print}
    $m add separator
    $m add command -label "Quit" -underline 0 -command {GBevent button(quit)}

    menubutton .menu.edit -text "Edit" -underline 0 -menu .menu.edit.menu
    set m .menu.edit.menu
    menu $m -tearoff 0
    $m add command -label "Preferences..." -state disabled  -underline 1 -command {}

#    menubutton .menu.specification -text "Specification" -underline 0 \
#	-menu .menu.specification.menu
#    set m .menu.specification.menu
#    menu $m

    menubutton .menu.window -text "Graph" -underline 0 -menu .menu.window.menu
    set m .menu.window.menu
    menu $m -tearoff 0
    $m add command -label "View All" -underline 0 -command {ViewAll}
    $m add check -label "Autoresize After Loading" -underline 0 -variable autoresize
    $m add separator
    $m add check -label "Animate While Loading" -underline 0 -variable animate

    menubutton .menu.help -text "Help" -underline 0 -menu .menu.help.menu
    set m .menu.help.menu
    menu $m -tearoff 0
    $m add command -label "About $metaname" -underline 0 \
        -command {Help $help_meta center a}
    $m add command -label "About $toolname" -underline 6 \
        -command {Help $help_about center b}
    $m add command -label "Mouse Operations" -underline 0 \
        -command {Help $help_mouse left c}
    $m add check -label "Online Help" -underline 10 -variable openhelp \
        -command {OnlineHelp $openhelp}
    $m add check -label "JitterBug Activated" -underline 0 -variable openJitterBug \
        -command {JitterBug $openJitterBug}

    menubutton .menu.debug -text "Debug" -underline 0 -menu .menu.debug.menu
    set m .menu.debug.menu
    menu $m -tearoff 0
    $m add check -label "Diagnostic Messages"  -variable DIAG
    if { $use_tide } {
      $m add check -label "Reduction Debugging"  -variable DEBUG
    }

    trace variable DEBUG w toggle-debugging

#        .menu.specification {left} 
    pack append .menu .menu.file {left} .menu.edit {left} \
        .menu.window {left} .menu.debug {left} .menu.help {right}

    tk_menuBar .menu.file .menu.specification .menu.window .menu.help
    focus .menu
}

proc define-modules-frame {} {
    global SBW
    frame .modules -borderwidth 2 -relief groove
    scrollbar .modules.yscroll -width $SBW -orient vertical \
        -command {.modules.list yview}
    scrollbar .modules.xscroll -width $SBW -orient horizontal \
        -command {.modules.list xview}
    listbox .modules.list -width 16 -height 8 -relief flat \
	-selectmode extended -yscroll {.modules.yscroll set} \
	-xscroll {.modules.xscroll set}

    frame .modules.buttons

    button .modules.buttons.editsdfmod -text "Edit Syntax" \
	-command {EditSyntaxModules [SelectedModules]}
    button .modules.buttons.editeqsmod -text "Edit Equations" \
	-command {EditEquationsModules [SelectedModules]}
    button .modules.buttons.editterm -text "Edit Term" \
	-command {foreach i [SelectedModules] {
	    EditTermWidget $i "open"
	}}
    button .modules.buttons.newterm -text "New Term" \
  -command {foreach i [SelectedModules] {
      EditTermWidget $i "new"
  } } 
    button .modules.buttons.savemod -text "Save" \
        -command {SaveModules [SelectedModules]}
    button .modules.buttons.revertmod -text "Revert" \
	-command {RevertModules [SelectedModules]}
    button .modules.buttons.deletemod -text "Delete" \
	-command {DeleteModules [SelectedModules]}
    button .modules.buttons.compile -text "Compile..." \
	-command {CompileModules [SelectedModules]}
    button .modules.buttons.printmod -text "Print" \
	-command {PrintModules [SelectedModules]}
    button .modules.buttons.modinfo -text "Info" \
	-command {GetModuleInfo [SelectedModules]}
    button .modules.buttons.saveall -text "Save All" \
        -command {SaveAll}

    pack append .modules.buttons \
        .modules.buttons.editsdfmod {top fillx} \
        .modules.buttons.editeqsmod {top fillx} \
	.modules.buttons.editterm {top fillx} \
        .modules.buttons.savemod {top fillx} \
        .modules.buttons.saveall {top fillx} \
        .modules.buttons.revertmod {top fillx} \
        .modules.buttons.deletemod {top fillx} \
        .modules.buttons.compile {top fillx} \
        .modules.buttons.printmod {top fillx} \
        .modules.buttons.modinfo {top fillx}

    grid .modules.list    -row 0 -column 0 -rowspan 1 \
        -columnspan 1 -sticky news
    grid .modules.yscroll -row 0 -column 1 -rowspan 1 \
        -columnspan 1 -sticky news
    grid .modules.xscroll -row 1 -column 0 -rowspan 1 \
        -columnspan 1 -sticky news
    grid .modules.buttons -row 0 -column 2 -rowspan 2 \
        -columnspan 1 -sticky news

    grid rowconfig    .modules 0 -weight 1 -minsize 0
    grid rowconfig    .modules 1 -weight 0

    grid columnconfig .modules 0 -weight 1 -minsize 0
    grid columnconfig .modules 1 -weight 0
    grid columnconfig .modules 2 -weight 0
}

proc define-graph-frame {} {
    global c SBW
    frame .graph -borderwidth 2 -relief groove

    set c [canvas .graph.canvas -cursor crosshair \
        -xscrollcommand {.graph.xscroll set} \
        -yscrollcommand {.graph.yscroll set} \
        -borderwidth 0]

    $c xview scroll 10 unit
    $c yview scroll 10 unit

    scrollbar .graph.xscroll -width $SBW -orient horizontal \
        -command "$c xview"
    scrollbar .graph.yscroll -width $SBW -orient vertical \
        -command "$c yview"

    set buttonwidth [expr $SBW - 2]
    button .graph.layout -width $buttonwidth -height $buttonwidth \
    	-bitmap gray50 -command "update-graph"

    grid .graph.canvas  -row 0 -column 0 -rowspan 1 \
        -columnspan 1 -sticky news
    grid .graph.yscroll -row 0 -column 1 -rowspan 1 \
        -columnspan 1 -sticky news
    grid .graph.xscroll -row 1 -column 0 -rowspan 1 \
        -columnspan 1 -sticky news
    grid .graph.layout -row 1 -column 1 -rowspan 1 \
        -columnspan 1 -sticky news

    grid rowconfig    .graph 0 -weight 1 -minsize 0
    grid rowconfig    .graph 1 -weight 0

    grid columnconfig .graph 0 -weight 1 -minsize 0
    grid columnconfig .graph 1 -weight 0
}

proc define-status-frame {} {
    frame .status -relief raised
    label .status.label -text "Status:"
    label .status.msg -borderwidth 2 -relief sunken -anchor w -textvariable status
    pack append .status .status.label {left} .status.msg {left expand fill}
}

proc define-module-popup {} {
    set m .module-popup
    menu $m -tearoff 0
    $m add command -label "Edit Syntax" \
        -command {EditSyntaxModules [GetObjectName $c]}
    $m add command -label "Edit Equations" \
        -command {EditEquationsModules [GetObjectName $c]}
    $m add command -label "Edit Term" \
        -command {EditTermWidget [GetObjectName $c] "open"}
    $m add command -label "New Term" \
        -command {EditTermWidget [GetObjectName $c] "new"}
    $m add separator
    $m add command -label "Save Module" \
        -command {SaveModules [GetObjectName $c]}
    $m add command -label "Revert Module" \
        -command {RevertModules [GetObjectName $c]}
    $m add command -label "Delete Module" \
        -command {DeleteModules [GetObjectName $c]}
    $m add command -label "Rename Module" \
        -command {RenameModuleWidget [GetObjectName $c]}
    $m add command -label "Copy Module" \
        -command {CopyModuleWidget [GetObjectName $c]}
    $m add separator
    $m add command -label "Compile Module..." \
        -command {CompileModules [GetObjectName $c]}
    $m add command -label "Dump Equations..." \
        -command {DumpEquations [GetObjectName $c]}
    $m add command -label "Dump Parse Table..." \
        -command {DumpParseTable [GetObjectName $c]}
    $m add separator
    $m add command -label "Print Module" \
        -command {PrintModules [GetObjectName $c]}
    $m add command -label "Module Info" \
        -command {GetModuleInfo [GetObjectName $c]}
}

proc define-shadowmodule-popup {} {
    set m .shadowmodule-popup
    menu $m -tearoff 0
    $m add command -label "Create this module" \
        -command {NewModule [GetObjectName $c]}
}

proc define-modlist-popup {} {
    set m .modlist-popup

    menu $m -tearoff 0
     $m add command -label "Edit Syntax" \
        -command {EditSyntaxModules [SelectedModules]}
    $m add command -label "Edit Equations" \
        -command {EditEquationsModules [SelectedModules]}
    $m add command -label "Edit Term" \
        -command {EditTermWidget [SelectedModules] "open"}
    $m add command -label "New Term" \
        -command {EditTermWidget [SelectedModules] "new"}
    $m add separator
    $m add command -label "Save Module" \
        -command {SaveModules [SelectedModules]}
    $m add command -label "Revert Module" \
        -command {RevertModules [SelectedModules]}
    $m add command -label "Delete Module" \
        -command {DeleteModules [SelectedModules]}
    $m add command -label "Rename Module..." \
        -command {RenameModuleWidget [SelectedModules]}
    $m add command -label "Copy Module..." \
        -command {CopyModuleWidget [SelectedModules]}
    $m add separator
    $m add command -label "Compile Module..." \
        -command {CompileModules [SelectedModules]}
    $m add command -label "Dump Equations..." \
        -command {DumpEquations [SelectedModules]}
    $m add command -label "Dump Parse Table..." \
        -command {DumpParseTable [SelectedModules]}  
    $m add separator
    $m add command -label "Print Module" \
        -command {PrintModules [SelectedModules]}
    $m add command -label "Module Info" \
        -command {GetModuleInfo [SelectedModules]}
}

proc define-canvas-popup {} {
    set m .canvas-popup
    menu $m -tearoff 0
    $m add command -label "New..." -command "NewModuleWidget"
    $m add command -label "Open..." -command "OpenModuleWidget"
    $m add command -label "Open Library..." -command "OpenLibModuleWidget"
}

proc make-and-init-new-graph {} {
  global SHADOWSTYLE
  set g [dotnew digraph]
  $g setnodeattributes shape $SHADOWSTYLE
  return $g
}


#----------------------------------------------------------------------
# "main" program
#----------------------------------------------------------------------

set g [make-and-init-new-graph]
set saveFill {}
set fileName {no_name.dot}
set printCommand {lpr}

wm title . $metaname
wm iconname . $metaname

define-menu-bar
define-graph-frame
# Snap to MINWINSIZE on startup
ViewAll
define-modules-frame
define-status-frame

grid .menu    -row 0 -column 0 -rowspan 1 -columnspan 2 -sticky news
grid .graph   -row 1 -column 0 -rowspan 1 -columnspan 1 -sticky news
grid .modules -row 1 -column 1 -rowspan 1 -columnspan 1 -sticky news
grid .status  -row 2 -column 0 -rowspan 1 -columnspan 2 -sticky news

grid rowconfig    . 0 -weight 0
grid rowconfig    . 1 -weight 1 -minsize 0
grid rowconfig    . 2 -weight 0

grid columnconfig . 0 -weight 1 -minsize 0
grid columnconfig . 1 -weight 0

define-module-popup
define-shadowmodule-popup
define-modlist-popup
define-canvas-popup

bind $c <ButtonPress-1> "mouse_b1_press $c %X %Y"
bind $c <ButtonPress-3> "mouse_b1_press $c %X %Y"

$c bind all <Any-Enter> "mouse_anyenter $c"
$c bind all <Any-Leave> "mouse_anyleave $c"

bind $c <ButtonPress-2> "$c scan mark %x %y"
bind $c <B2-Motion> "$c scan dragto %x %y"

bind .modules.list <ButtonPress-3> "tk_popup .modlist-popup %X %Y"

