<HTML>
<HEAD>
<TITLE>Scenarios</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Scenarios</H1>
Here we describe a number of scenarios on which the design and therefore
the implementation of the new Meta-Environment is based. Each scenario
describes a list of actions that is performed to complete a certain
task. These actions are informal descriptions of a subtask, which 
in turn can be scenarios themselves.

The sole purpose of these scenarios is to develop an understanding for
the interaction between the different components, and their responsibilities.

Sofar, we have developed scenarios for the following tasks:
<UL>
<LI> <A HREF="#ParsingTerms">Scenario for Parsing Terms</A>
<LI> <A HREF="#ParserGenerator">Scenario for Generating Parse Tables</A>
<LI> <A HREF="#HybridEditing">Scenario for Hybrid Editing</A>
<LI> <A HREF="#UpdatingTerms">Scenario for Updating Terms</A>
<LI> <A HREF="#UpdatingSyntax">Scenario for Updating the Syntax of 
	a Module</A>
<LI> <A HREF="#UpdatingEquations">Scenario for Updating the Equations of
	a Module</A>
<LI> <A HREF="#Shutdown">Scenario for shutting down the system</A>
</UL>


<H2><A NAME="ParsingTerms">Scenario for Parsing Terms</A></H2>

Case: a user wants to parse a term over a certain module.
We assume that at least this module and all modules imported by it
are in the module database.

<OL>
<LI> After indication by the user, the <EM>term editor</EM>
generates a parse request.
This parse request contains the complete text of the term,
a unique identification for it (URL?), and the name of
the module over which the text has to be parsed.
<LI> The <EM>parser</EM> intercepts this request and check if it
already has a parse table for this module.
<LI> The <EM>parser</EM> generates a requesting the most up-to-date
syntax for the given top module. This request contains a list
of version numbers for the modules on which the old parse table
was based.
<LI> The <EM>module database</EM> intercepts the request for the
new syntax, and checks if it is up-to-date.
If not, the <EM>module database</EM> retrieves the newest syntax 
for the given top module and sends it back.
<LI> If a new version of the syntax is available, the parser
starts the <A NAME="ParserGenerator">Scenario for Generating Parse Tables</A>.
<LI> The <EM>parser</EM> now knows it has the correct parse table,
so it parses the text and either produces an error messages or
a new parse tree.
<LI> A parse result containing the unique identification of the term and
either the error message or the constructed parse tree is generated.
<LI> The term editor intercepts this parse result.
If the user has edited the text in the meantime this parse result is ignored
by the editor. 
Otherwise if the parse result contains an error message
this is presented to the user. If the parse result contains
a parse tree the editor switches to 'structure editing mode'.
</OL>


<H2><A NAME="ParserGenerator">Scenario for Generating Parse Tables</A></H2>

Case: the module database requests a new parse table.

<OL>
<LI> The <EM>parser</EM> generates a
request to generate a new parse-table. 
This request contains the name of the module for
which the parse-table has to be build, the complete syntax
of the module and its submodules, and a list of tuples
consisting of module ids and version numbers.
<LI> The <EM>parser generator</EM> intercepts this request
and generates a new parse table based on the syntax.
<LI> The resulting parse table, together with the list of
module name/version number tuples is send back to the
<EM>parser</EM>.
</ol>

An alternative scenario could be that given the module name the top module
is identified and the parse table is generated for this top module.
The generated parse table must then contain information which transitions
are valid for each specific module. This will reduce the number of tables
that must be maintained by the parser considerably (to one?).


<H2><A NAME="HybridEditing">Scenario for Hybrid Editing</A></H2>

Case: The <EM>hybrid editor</EM>, a combination of a
<EM>text editor</EM> and a <EM>structure editor</EM>, can be used
to edit terms, and syntax and equations of modules.

<OL>
<LI> The <EM>hybrid editor</EM> component intercepts an edit request,
     and asks the <EM>module database</EM> or <EM>term database</EM>
     to supply the AsFix term representation of the object that is to
     be edited. This AsFix representation is then stored in the 
     <EM>structure editor.</EM>
<LI> The <EM>hybrid editor</EM> component creates a new <EM>text
     editor</EM> window
     and displays the text representation of this AsFix term.
     When the syntax on which the object being edited is based is valid,
     the editor starts in text editing mode. Otherwise, the editor starts
     in structure editing mode.
     The text editing window contains some indication that the term
     is unchanged.
<LI> When the user wants to perform a structure editing operation, the
     <EM>text editor</EM> requests the <EM>structure editor</EM> to
     perform the operation.
<LI> The <EM>structure editor</EM> performs the operation, and
     informs the <EM>text editor</EM> of the modifications.
<LI> The 'changed' indication in the <EM>text editor</EM> now indicates
     that the contents of the editor has changed. The <EM>text editor</EM>
     remains in 'structure editing mode'.
<LI> When the user wants to perform a text editing operation,
     the <EM>text editor</EM> performs the operation.
<LI> The 'changed' indicator indicates that the contents has changed and
     the <EM>text editor</EM> goes into 'text editing mode'.
<LI> To switch to structure editing mode again, the text in the
     editor must be reparsed. This does NOT mean that the AsFix representation
     of the object in the <EM>module database</EM> or <EM>term database</EM>
     is updated. The user must do an explicit update to accomplish this!
<LI> To update (save?) the AsFix represention of the object being edited
     in the <EM>AsFix database</EM>,
     the user must explicitly indicate this. The term is send to the
     apropriate database so it can update its internal representation.
     See the <A HREF="#UpdatingTerms">scenario for updating terms</A>,
     the <A HREF="#UpdatingSyntax">scenario for updating the syntax
     of a module</A>, and the <A HREF="#UpdatingEquations">scenario
     for updating equations</A> for what happens when a term, syntax,
     or equation section is updated.
<LI> When the user wants to update the term, but the editor is not
     in structure editing mode (i.e. the term has not yet been parsed),
     a special AsFix representation of the text is send to the apropriate
     database for updating.
</OL>


<H2><A NAME="UpdatingTerms">Scenario for Updating Terms</A></H2>

Some components in the system can change terms. The most prominent one
is the <EM>hybrid editor</EM>, but in the future other components
should also be able to change terms.

<OL>
<LI> The <EM>term database</EM> intercepts the request to change
     the contents of a term. The request consists of a unique identification
     (URL?) of the term and the new value of the term.
<LI> The <EM>term database</EM> stores the new value in its internal
     database, assigns a new version number to the term, 
     and sends a notification that the term has been changed.
     The notification only contains the unique identification of the term and
     its version number.
</OL>



<H2><A NAME="UpdatingSyntax">Scenario for Updating the Syntax of a Module</A></H2>


Some components in the system can change the syntax of a module. 
The most prominent one is the <EM>hybrid editor</EM>, that can be used
to edit the SDF definition of a module. But in the future other components
should also be able to change the syntax of modules.

<OL>
<LI> The <EM>module database</EM> intercepts the request to change
     the syntax of a module. The request consists of a unique identification
     (URL?) of the module and the new syntax definition represented in
     AsFix.
<LI> A new version number that is based on the <EM>equation part</EM>
     of the module is assigned to the syntax <EM>and</EM> equation
     part of the module. This means that the version number of the
     equation part can never be lower than the version number of the
     syntax part.
<LI> The <EM>module database</EM> flags the syntax part of any modules 
     that depend on the changed module as 'invalid'.
<LI> The <EM>module database</EM> stores the new syntax in its internal
     database.
</OL>


<H2><A NAME="UpdatingEquations">Scenario for Updating the Equations of a Module</A></H2>


Some components in the system can change the equations of a module. 
The most prominent one is the <EM>hybrid editor</EM>, that can be used
to edit equations. But in the future other components should also be able 
to change the equations of a module.

<OL>
<LI> The <EM>Module database</EM> intercepts the request to change
     the equations of a module. This request contains a list of
     module name/version number pairs to indicate the syntax 
     on which the equations are based.
<LI> When the syntax is still up-to-date, the equations are kept
     in tree form, otherwise they are translated into text form.
<LI> The old equations are replaced, and a new version number is
     assigned to the equations.
</OL>

<H2><A NAME="Shutdown">Scenario for Shutting Down the System,</A></H2>

Shutting down a distributed system is not trivial. Some components might
have changed data that must be saved, and sometimes confirmation from
the user is required.

<OL>
<LI> The user indicates in the <EM>control tool</EM> that he/she wants
     to shutdown.
<LI> The <EM>control tool</EM> generates a shutdown event. The
     SHUTDOWN process sends a shutdown message to all registered
     components ordered by priority, and waits for confirmation from
     each component before proceeding. (At startup all components that
     are interested in shutdown messages can register themselves with
     a priority)
<LI> When the last confirmation has been received, the system is halted.
</OL>

</BODY>
</HTML>

