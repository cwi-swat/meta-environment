process ModuleDB is
let
Id        : term,
T1        : term,
Path      : str,
Table     : str,
T2        : term,
Module    : term,
Syntax    : term,
NewSyntax : term,
Eqs       : term,
Name      : term,
Mdb       : module-db,
Modules   : list,
Equations : list,
Pairs     : list,
Status    : str
in

/* First, execute the module db */
execute(module-db, Mdb?).

/* And initialize it */
snd-do(Mdb, create-module-db).
(
/* When compiling modules, they need to be reshuffled such that a new
   module is generated for each context-free function in the spec
*/
  rec-msg(reshuffle-module(Name?)).
  snd-do(Mdb, compile-module(Name)).
/* Everytime a new module is finished it is returned, so that it can
   already be compiled. This way, we don't have to wait for the whole
   reshuffleing to finish.
*/
  ( rec-event(Mdb, generate-code(Name?,Module?)).
    snd-msg(generate-code(Name,Module)).
    snd-ack-event(Mdb, generate-code(Name, Module))
  ) *
/* When we're done, we're done */
  rec-event(Mdb,done).
  snd-msg(reshuffle-done).
  snd-ack-event(Mdb,done)
+
/* If we get the request to empty the db, we'll do it. */
  rec-msg(clear-module-db).
  snd-do(Mdb, clear-module-db)
+
/* Delete one module from the db */
  rec-msg(delete-module(Name?)).
  snd-eval(Mdb, delete-module(Name)).
  rec-value(Mdb, done).
  snd-msg(done)
+
/* Revert one module from the db */
  rec-msg(revert-module-in-db(Name?)).
  snd-eval(Mdb, delete-module(Name)).
  rec-value(Mdb, done).
  snd-msg(done)
+
/* See if a module is in the db */
  rec-msg(is-module-in-db(Name?)).
  snd-eval(Mdb, exists(Name)).
  ( rec-value(Mdb, result(exists(Name?))).
    snd-msg(exists-in-module-db(Name))
  +
    rec-value(Mdb, result(notexists(Name?))).
    snd-msg(not-exists-in-module-db(Name))
  )
+
/* Add a module to the database */
  rec-msg(add-module-to-db(Module?)).
  snd-eval(Mdb,add-module(Module)).
  rec-value(Mdb,imports(Name?,need-modules(Modules?))).
  snd-msg(need-modules(Modules)).
/* If a new module is added, we tell the world the new import relations */
  snd-eval(Mdb,calc-import-rels(Name)).
  rec-value(Mdb,irels(Pairs?)).
  snd-note(import-relations(irels(Pairs)))
+
  rec-msg(add-empty-module-to-db(Module?)).
  snd-eval(Mdb,add-empty-module(Module)).
  rec-value(Mdb,done).
  snd-msg(done)
+
/* Path is the directory in which the file containing Module lives.
   Module is the parsed SDF2 representation in Asfix1 */
  rec-msg(add-sdf2-module-to-db(Path?,Module?,Status?)).
  snd-eval(Mdb,add-sdf2-module(Path,Module,Status)).
  rec-value(Mdb,imports(Name?,need-modules(Modules?))).
  snd-msg(need-modules(Modules)).
/* If a new module is added, we tell the world the new import relations */
  snd-eval(Mdb,calc-import-rels(Name)).
  rec-value(Mdb,irels(Pairs?)).
  snd-note(import-relations(irels(Pairs)))
+
/* Get the list of modules for which the equations are not yet
   available in the database */
  rec-msg(update-eqs-for-modules(Module?)).
  snd-eval(Mdb,update-eqs-for-modules(Module)).
  rec-value(Mdb,modules(Modules?)).
  snd-msg(eqs-for-modules(Modules))
+
/* Add the equations to the database for the given module name */
  rec-msg(add-eqs-to-db(Module?,Path?,Eqs?,Status?)).
  snd-eval(Mdb,add-eqs-module(Module,Path,Eqs,Status)).
  rec-value(Mdb,done).
  snd-msg(done)
+
/* Add parse table to the database for the given module name */
  rec-msg(add-table-to-db(Module?,Table?)).
  snd-eval(Mdb,add-parse-table(Module,Table)).
  rec-value(Mdb,done).
  snd-msg(done)
+
/* Add parse table to the database for the given module name */
  rec-msg(get-sdf2-path-from-db(Module?)).
  snd-eval(Mdb,get-sdf2-path(Module)).
  rec-value(Mdb,path(Path?)).
  snd-msg(path(Path))
+
/* Add parse table to the database for the given module name */
  rec-msg(get-eqs-path-from-db(Module?)).
  snd-eval(Mdb,get-eqs-path(Module)).
  rec-value(Mdb,path(Path?)).
  snd-msg(path(Path))
+
/* Add parse table to the database for the given module name */
  rec-msg(get-table-from-db(Module?)).
  snd-eval(Mdb,get-parse-table(Module)).
  ( rec-value(Mdb,table(Table?)).
    snd-msg(table(Table))
  +
    rec-value(Mdb,no-table).
    snd-msg(no-table)
  )
+
/* Return a list of all modules imported by this one*/
  rec-msg(get-all-imported-modules(Module?)).
  snd-eval(Mdb, get-all-imported-modules(Module)).
  rec-value(Mdb, all-imports(Modules?)).
  snd-msg(all-imported-modules(Modules))
+
/* Return a list of all modules */
  rec-msg(get-all-modules).
  snd-eval(Mdb, get-all-modules).
  rec-value(Mdb, all-modules(Modules?)).
  snd-msg(all-modules(Modules))
+

/* Get all equations for a list of modules */
  rec-msg(get-all-equations(Modules?)).
  snd-eval(Mdb, get-new-equations(Modules)).
  rec-value(Mdb, equations(Equations?)).
  snd-msg(all-equations(Equations))
+
/* Get the syntax for a list of modules */
  rec-msg(retrieve-syntax(Module?)).
  snd-eval(Mdb, retrieve-syntax(Module)).
  rec-value(Mdb, syntax(Syntax?)).
  snd-msg(total-syntax(Syntax))
+
  rec-msg(get-sdf2-asfix(Module?)).
  snd-eval(Mdb, get-sdf2-asfix(Module)).
  (
    rec-value(Mdb, syntax(Syntax?)).
    snd-msg(syntax(Syntax))
  +
    rec-value(Mdb, syntax-unchanged(Syntax?)).
    snd-msg(syntax-unchanged(Syntax))
  +
    rec-value(Mdb, unavailable).
    snd-msg(unavailable)
  )
+
  rec-msg(get-eqs-asfix(Module?)).
  snd-eval(Mdb, get-eqs-asfix(Module)).
  ( rec-value(Mdb, eqs(Eqs?)).
    snd-msg(eqs(Eqs))
  +
    rec-value(Mdb, eqs-unchanged(Eqs?)).
    snd-msg(eqs-unchanged(Eqs))
  +
    rec-value(Mdb, no-eqs).
    snd-msg(no-eqs)
  +
    rec-value(Mdb, unavailable).
    snd-msg(unavailable)
  )
+
  rec-msg(add-pgen-func(Module?,Syntax?)).
  snd-eval(Mdb, add-pgen-func(Module,Syntax)).
  rec-value(Mdb, decorated-syntax(NewSyntax?)).
  snd-msg(decorated-syntax(NewSyntax))
) *
delta
endlet


tool module-db is { command = "module-db" }

