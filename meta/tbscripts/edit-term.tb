/*
  $Id$
*/

process ParseTerm(EditorId: term, ModuleName: str) is
let
  ErrorFoci  : term
in
  snd-msg(set-parsetable(trm(ModuleName))) .
  (
    rec-msg(parsetable-not-set(trm(ModuleName))) .
    snd-note(ui-status(errorf(
      "Unable to open parse table for %s", [ModuleName])))
  +
    rec-msg(parsetable-set(trm(ModuleName))) .
    snd-msg(parse-focusses(EditorId, trm(ModuleName))) .
    (
      rec-msg(parse-ok(trm(ModuleName))) .
      snd-msg(clear-focus(EditorId))
    +
      rec-msg(parse-failed(trm(ModuleName), ErrorFoci?)) .
      snd-msg(set-focus(EditorId, ErrorFoci))
    )
  )  
endlet

process GetTextFromFile(FileName: str, Text: str?) is
let
  Name      : str,
  TimeStamp : term, 
  Path      : str
in
  snd-msg(open-file(FileName)).
  (
    rec-msg(opened-file(Name?, text(Text?), Path?, TimeStamp?))
  +
    rec-msg(error-opening(Name?)) .
    Text := error-text
  )
endlet

process ParseText(Text: str, ModuleName: str, Nonterminal: str, Tree: term?) is
let
  Id        : term,
  Co        : int,
  Li        : int,
  I         : int,
  Ch        : int,
  Char      : term, 
  Ambs      : list,
  Cycle     : term,
  ErrList   : list
in
  Id := process-id . 
  snd-msg(open-modules([ModuleName])) .
  rec-msg(finished-opening-modules) .
  snd-msg(set-parsetable(trm(ModuleName))) .
  (
    rec-msg(parsetable-not-set(trm(ModuleName))) .
    snd-note(ui-status(errorf(
      "Unable to open parse table for %s", [ModuleName]))) .
    Tree := error-tree
  +
    rec-msg(parsetable-set(trm(ModuleName))) .
    snd-msg(Id, parse-string-as-asfix2me(trm(ModuleName), Nonterminal, Text)) . 
    snd-note(ui-status(statf(Id,"Parsing %s",[ModuleName]))).
    (
      rec-msg(parse-result-asfix2me(Id, parse-tree(Tree?)))
    +
      rec-msg(parse-result-asfix2me(Id?,parse-error(ErrList?,
                                                    ambiguities(I?, Ambs?)))).
      snd-note(ui-status(errorf("Parse of %s returned %d ambiguities",
                                [ModuleName,I]))) .
      Tree := error-tree
    +
      rec-msg(parse-result-asfix2me(Id?,parse-error(ErrList?,
                                                    cycle(Cycle?)))).
      snd-note(ui-status(errorf("Parse returned a cycle: %t\n",
                                [Cycle]))) . 
      Tree := error-tree 
    +
      rec-msg(parse-result-asfix2me(Id?,parse-error(ErrList?,eof))).
      snd-note(ui-status(errorf("EOF unexpected while parsing %s\n",
                                [ModuleName]))) . 
      Tree := error-tree
    + 
      rec-msg(parse-result-asfix2me(Id?,
                                    parse-error([character(Ch?),
                                                 line(Li?),
                                                 col(Co?),
                                                 char(Char?)],plain))).
      snd-note(ui-status(errorf(
               "Character %d unexpected in %s, line %d, column %d\n",
               [Ch, ModuleName, Li, Co]))) . 
      Tree := error-tree
    ) .
    snd-note(ui-status(endstat(Id)))
  )  
endlet

process GetTree(EditorId: term, ModuleName: str, Tree: term?) is
let
  DirtyFoci  : term
in
  snd-msg(get-dirty-focuses(EditorId)) .
  rec-msg(dirty-focuses(DirtyFoci?)) .
  if equal(DirtyFoci, []) then
    snd-msg(get-tree(EditorId)) .
    rec-msg(tree(Tree?))
  else
    snd-msg(invalidate-tree(EditorId)) .
    ParseTerm(EditorId, ModuleName) .
    snd-msg(get-dirty-focuses(EditorId)) .
    rec-msg(dirty-focuses(DirtyFoci?)) . 
    if equal(DirtyFoci, []) then
      snd-msg(get-tree(EditorId)) .
      rec-msg(tree(Tree?))
    else 
      Tree := error-tree
    fi
  fi
endlet

process ReplaceRoot(EditorId: term, Tree: term) is
let
  TotalTree   : term,
  Text        : str,
  Focus       : term
in
  snd-msg(move-focus-to-root(EditorId)) .
  rec-msg(focus(Focus?)) .
  snd-msg(replace-focussed-tree(EditorId, Tree)) .
  rec-msg(focus(Focus?)) .
  snd-msg(get-tree(EditorId)) .
  rec-msg(tree(TotalTree?)) .
  snd-msg(unparse(TotalTree)) .
  rec-msg(unparsed-text(Text?)) .
  snd-msg(replace-text(EditorId, Text)) .
  snd-msg(set-focus(EditorId, Focus))
endlet


process GetFocus(EditorId: term, Tree: term?) is
  snd-msg(get-focussed-tree(EditorId)) .
  (
    rec-msg(tree(Tree?))
  +
    rec-msg(no-tree) .
    Tree := error-tree
  )

process ReplaceFocus(EditorId: term, Tree: term) is
let
  TotalTree   : term,
  Text        : str,
  Focus       : term
in
  snd-msg(replace-focussed-tree(EditorId, Tree)) .
  rec-msg(focus(Focus?)) .
  snd-msg(get-tree(EditorId)) .
  rec-msg(tree(TotalTree?)) .
  snd-msg(unparse(TotalTree)) .
  rec-msg(unparsed-text(Text?)) .
  snd-msg(replace-text(EditorId, Text)) .
  snd-msg(set-focus(EditorId, Focus))
endlet

process CheckTreeSort(Tree: term, Sort: str, RTree: term?) is
let 
  TreeSort : str 
in
  snd-msg(check-tree-sort(Sort, Tree)) .
  ( 
    rec-msg(wrong-sort(TreeSort?)) .
    snd-note(ui-status(errorf("top sort %s of tree does not match %s", 
                              [TreeSort, Sort]))) .
    RTree := error-tree
  +
    rec-msg(sort-ok) .
    RTree := Tree
  )
endlet

process ReduceTerm(Tree: term, ModuleName: str, NormalForm: term?) is
let
  Id          : int,
  ErrList     : list,
  Equations   : term
in
  Id := process-id .
  snd-msg(open-modules([ModuleName])) .
  rec-msg(finished-opening-modules) .
  snd-note(ui-status(stat(Id, "Retrieving equations"))) .
  snd-msg(process-eqs(ModuleName)) .
  rec-msg(eqs-processed(ModuleName)) .
  snd-msg(get-all-equations(ModuleName)) .
  (
    rec-msg(all-equations(Equations?)) .
    snd-note(ui-status(endstat(Id))).
 
    snd-note(ui-status(stat(Id, "Rewriting"))) .
    snd-msg(rewrite(ModuleName, Equations, Tree)).
    (
      rec-msg(rewrite-result(NormalForm?)).
      RestoreBracketsInTree(NormalForm,ModuleName,NormalForm?)
    +
      rec-msg(rewrite-errors(ErrList?)) .
      NormalForm := error-tree .
      snd-msg(display-rewrite-errors(ErrList))
    ) .
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(equations-incomplete) .
    NormalForm := error-tree .
    snd-note(ui-status(endstat(Id))) .
    snd-note(ui-status(errorf("Equations incomplete for %s", [ModuleName])))
  )
endlet

process RestoreBracketsInTree(Tree : term, ModuleName : str, NewTree : term?) is
let
  Table : term,
  Path : str
in
  snd-msg(get-parsetable(trm(ModuleName))).
  (
    rec-msg(parse-table(Table?, Path?)) .
    snd-msg(restore-brackets(Tree, Table)) .
    rec-msg(brackets-restored(NewTree?)) 
  +
    rec-msg(no-parse-table) .
    NewTree := error-tree
  )
endlet

process ActivateEditor(Tree: term, ModuleName: str, FileName: str) is
let
  Text        : str,
  Path        : str,
  Name        : str,
  TimeStamp   : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(unparse(Tree)) . 
    rec-msg(unparsed-text(Text?)) .
 
    snd-msg(save-text-file(FileName, Text)) .
    rec-msg(save-done(FileName)) .
    snd-msg(edit-term-file-with-tree(ModuleName, FileName, Tree))
  fi
endlet

process EditTerm(EditorId: term, ModuleName: str, Text: str, Tree : term) is
let
  NormalForm  : term,
  Focus       : term,
  DirtyFoci   : term,
  ErrList     : list,
  ArgList     : list,
  Stack       : list,
  Killed      : term,
  ActionTree  : term,
  EditorId2   : term,
  STree       : term,
  RTree       : term,
  Trees       : list,
  ButtonName  : str,
  SortName    : str,
  FilePath    : str,
  NewModName  : str,
  FileName    : str,
  EditorName  : str,
  FuncName    : str,
  FunSym      : str,
  Nonterminal : str,
  Message     : str,
  String      : str,
  NrOfArgs    : int
in
  subscribe(syntax-changed(ModuleName)) . 
  if equal(quote(Tree), none) then 
    snd-msg(initialize-structure-editor(EditorId, Text)) 
  else 
    snd-msg(initialize-structure-editor-with-tree(EditorId, Tree)) 
  fi  . 
  rec-msg(initial-focus(Focus?)) .
  snd-msg(set-focus(EditorId, Focus)) .
  Killed := false .
  (
    (
      (
        rec-note(syntax-changed(ModuleName)) .
        snd-msg(invalidate-tree(EditorId))
      +
        rec-msg(extra-button-action(EditorId, ButtonName?)) .
        snd-msg(extra-button-action(ButtonName, ModuleName, EditorId)) 
      +
        rec-msg(apply(FuncName?, SortName?, NrOfArgs?), 
                Stack?, EditorId) .
        ArgList := [] .
        (
          if greater(NrOfArgs, 0) then
            STree := first(Stack) .
            Stack := next(Stack) .
            NrOfArgs := sub(NrOfArgs, 1) .
            ArgList := join(ArgList, STree)
          fi 
        ) *
        if equal(NrOfArgs, 0) then
          tau
        fi .
        snd-msg(apply-function(FuncName, SortName, ArgList)) .
        rec-msg(tree(RTree?)) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack))
        else
          snd-msg(error-stack)
        fi
      +
        rec-msg(parse-action(NewModName?), Stack?, EditorId) .
        snd-msg(invalidate-tree(EditorId)) .
        ParseTerm(EditorId, NewModName) .
        snd-msg(stack(Stack))
      +
        rec-msg(get-root, Stack?, EditorId) .
        GetTree(EditorId, ModuleName, RTree?) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack))
        else
          snd-msg(error-stack)
        fi
      +
        rec-msg(set-root, Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        ReplaceRoot(EditorId, STree) .
        snd-msg(stack(Stack))
      +
        rec-msg(get-focus, Stack?, EditorId) .
        GetFocus(EditorId, RTree?) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack))
        else
          snd-msg(error-stack)
        fi
      +
        rec-msg(set-focus, Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        ReplaceFocus(EditorId, STree) .
        snd-msg(stack(Stack))
      +
        rec-msg(check-sort(SortName?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        CheckTreeSort(STree, SortName, RTree?) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack))
        else
          snd-msg(error-stack)
        fi
      +
        rec-msg(reduce(NewModName?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        ReduceTerm(STree, NewModName, RTree?) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack))
        else
          snd-msg(error-stack)
        fi
      +
        rec-msg(get-other-focus(NewModName?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
	FunSym := fun(STree) .
	if equal(FunSym, "path") then
	  FilePath := first(args(STree)) .
          snd-msg(check-editor-id(FilePath, NewModName)) .
          (
            rec-msg(existing-editor(FilePath?, EditorId2?)).
            GetFocus(EditorId2, RTree?) .
            if not-equal(RTree, error-tree) then
              Stack := join(RTree, Stack) .
              snd-msg(stack(Stack))
            else
              snd-msg(error-stack)
            fi
          +
            rec-msg(non-existing-editor(FilePath?)).
            snd-note(ui-status(errorf("editor for %s not active", 
                                      [FilePath]))) .
            snd-msg(error-stack)
          )
	else
	  snd-msg(error-stack)
	fi
      +
        rec-msg(edit(NewModName?, EditorName?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        ActivateEditor(STree, NewModName, EditorName) .
        snd-msg(stack(Stack))
      +
        rec-msg(parse(NewModName?, Nonterminal?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
	FunSym := fun(STree) .
	if equal(FunSym, "file") then
	  FilePath := first(args(STree)) .
	  GetTextFromFile(FilePath, String?) .
	  tau.
          ParseText(String, NewModName, Nonterminal, RTree?)
	else 
	  if equal(FunSym, "str") then
	    String := first(args(STree)) .
	    ParseText(String,  NewModName, Nonterminal, RTree?)
	  else
	    RTree := error-tree
	  fi
	fi .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack))
        else
          snd-msg(error-stack)
        fi
      +
        rec-msg(get-argument(NrOfArgs?), Stack?, EditorId) .
        STree := first(Stack) .
        snd-msg(get-argument-given-number(STree, NrOfArgs)) .
        rec-msg(tree(RTree?)) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack))
        else
          snd-msg(error-stack)
        fi
      +
        rec-msg(exists(FileName?), Stack?, EditorId) .
        snd-msg(exists-file(FileName)) .
	(
	  rec-msg(file-exists(FileName)) .
          snd-msg(stack(Stack))
	+
	  rec-msg(file-not-exists(FileName)) .
          snd-note(ui-status(errorf("%s does not exist", 
                                    [FileName]))) .
          snd-msg(error-stack)
	)
      +
        rec-msg(locate(FileName?), Stack?, EditorId) .
        snd-msg(locate-file(FileName)) .
	(
	  rec-msg(file-location(FileName, FilePath?)) .
	  RTree := quote(path(FilePath)) .
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack))
	+
	  rec-msg(file-not-exists(FileName)) .
          snd-note(ui-status(errorf("%s does not exist", 
                                    [FileName]))) .
          snd-msg(error-stack)
	)
      +
        rec-msg(push-filename(FileName?), Stack?, EditorId) .
	RTree := quote(file(FileName)) .
        Stack := join(RTree, Stack) .
        snd-msg(stack(Stack))
      +
        rec-msg(push-string(String?), Stack?, EditorId) .
	RTree := quote(str(String)) .
        Stack := join(RTree, Stack) .
        snd-msg(stack(Stack))
      +
        rec-msg(message(Message?), Stack?, EditorId) .
	snd-note(ui-status(errorf("%s", [Message]))) .
        snd-msg(stack(Stack))
      ) *
      if equal(Killed, true) then
        tau
      fi
    )
    ||
    rec-msg(kill-editor(EditorId)).
    Killed := true .
    snd-msg(kill-editor-done(EditorId))
  )
endlet
