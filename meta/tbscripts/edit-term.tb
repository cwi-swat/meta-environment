/*
  $Id$
*/

process ApplyFunction(FuncName : str, SortName : str, ArgList : list, Tree: term?) is
  snd-msg(apply-function(FuncName, SortName, ArgList)) .
  rec-msg(tree(Tree?))

process IfEqualTrees(Tree1 : term, Tree2 : term, Result : bool?) is
  snd-msg(equal-trees(Tree1, Tree2)) .
  (
    rec-msg(true) .
    Result := true
  +
    rec-msg(false) .
    Result := false
  )

process Exists(FileName:str, Result: bool?) is
  snd-msg(exists-file(FileName)) .
  (
    rec-msg(file-exists(FileName)) .
    Result := true
  +
    rec-msg(file-not-exists(FileName)) .
    snd-note(ui-status(errorf("%s does not exist", 
                              [FileName]))) .
    Result := false
  )

process ParseTerm(EditorId: term, ModuleName: str) is
let
  ErrorFoci  : term
in
  snd-msg(set-parsetable(trm(ModuleName))) .
  (
    rec-msg(parsetable-not-set(trm(ModuleName))) .
    snd-note(ui-status(errorf(
      "Unable to open parse table for %s", [ModuleName])))
  +
    rec-msg(parsetable-set(trm(ModuleName))) .
    snd-msg(parse-focusses(EditorId, trm(ModuleName))) .
    (
      rec-msg(parse-ok(trm(ModuleName))) .
      snd-msg(clear-focus(EditorId))
    +
      rec-msg(parse-failed(trm(ModuleName), ErrorFoci?)) .
      snd-msg(set-focus(EditorId, ErrorFoci))
    )
  )  
endlet

process ParseTerm2(EditorId: term, ModuleName: str) is
let
  ErrorFoci : term,
  Text      : str,
  Focus     : term,
  SortName  : str,
  Tree      : term,
  Error     : term
in
  snd-msg(move-focus-to-root(EditorId)) .
  rec-msg(set-focus(EditorId, Focus?)) .
  snd-msg(get-focus-text(EditorId, Focus)) .
  rec-msg(focus-text(EditorId, Text?)) .
  snd-msg(get-focus-sort(SortName, Focus)) .
  rec-msg(focus-sort(SortName?)) .
  ParseText(Text, ModuleName, SortName, Tree?, Error?) .
  tau .
  ProcessParseError(ModuleName, Error)
endlet

process GetTextFromFile(FileName: str, Text: str?) is
let
  Name      : str,
  TimeStamp : term, 
  Path      : str
in
  snd-msg(open-file(FileName)).
  (
    rec-msg(opened-file(Name?, text(Text?), Path?, TimeStamp?))
  +
    rec-msg(error-opening(Name?)) .
    Text := error-text
  )
endlet

process ParseText(Text: str, ModuleName: str, Nonterminal: str, 
                  Tree: term?, ParseError: term?) is
let
  Id         : term,
  ErrList    : list,
  ErrContent : term
in
  Id := process-id . 
  snd-msg(open-modules([ModuleName])) .
  rec-msg(finished-opening-modules) .
  snd-msg(set-parsetable(trm(ModuleName))) .
  (
    rec-msg(parsetable-not-set(trm(ModuleName))) .
    snd-note(ui-status(errorf(
      "Unable to open parse table for %s", [ModuleName]))) .
    Tree := error-tree .
    ParseError := no-errors
  +
    rec-msg(parsetable-set(trm(ModuleName))) .
    snd-msg(Id, parse-string-as-asfix2me(trm(ModuleName), Nonterminal, Text)) . 
    snd-note(ui-status(statf(Id,"Parsing %s",[ModuleName]))).
    (
      rec-msg(parse-result-asfix2me(Id, parse-tree(Tree?))) .
      ParseError := no-errors
    +
      rec-msg(parse-result-asfix2me(Id?,parse-error(ErrList?, ErrContent?))) .
      Tree := error-tree .
      ParseError := quote(parse-error(ErrList, ErrContent))
    ) .
    snd-note(ui-status(endstat(Id)))
  )  
endlet

process ProcessParseError(ModuleName : str, ParseError: term) is
let
  Co           : int,
  Li           : int,
  I            : int,
  Ch           : int,
  Cycle        : term,
  ErrorList    : list,
  ErrorContent : term,
  FunSym       : str
in
  FunSym := fun(ParseError) .
  if not-equal(FunSym, "no-errors") then
    ErrorList := first(args(ParseError)) .
    ErrorContent := first(next(args(ParseError))) .
    FunSym := fun(ErrorContent) .
    if equal(FunSym, "ambiguities") then
      I := first(args(ErrorContent)) .
      snd-note(ui-status(errorf("Parse of %s returned %d ambiguities",
                                [ModuleName,I])))
    else
      tau
    fi .
    if equal(FunSym, "cycle") then
      Cycle := first(args(ErrorContent)) .
      snd-note(ui-status(errorf("Parse returned a cycle: %t\n",
                                [Cycle])))
    else
      tau
    fi .
    if equal(FunSym, "eof") then
      snd-note(ui-status(errorf("EOF unexpected while parsing %s\n",
                                    [ModuleName]))) 
    else
      tau
    fi .
    if equal(FunSym, "plain") then
      Ch := first(args(first(ErrorList))) .
      Li := first(args(first(next(ErrorList)))) .
      Co := first(args(first(next(next(ErrorList))))) .
      snd-note(ui-status(errorf(
               "Character %d unexpected in %s, line %d, column %d\n",
               [Ch, ModuleName, Li, Co])))
    else
      tau
    fi
  else
    tau
  fi
endlet

process GetTree(EditorId: term, ModuleName: str, Tree: term?) is
let
  DirtyFoci  : term
in
  snd-msg(get-dirty-focuses(EditorId)) .
  rec-msg(dirty-focuses(DirtyFoci?)) .
  if equal(DirtyFoci, []) then
    snd-msg(get-tree(EditorId)) .
    rec-msg(tree(Tree?))
  else
    snd-msg(invalidate-tree(EditorId)) .
    ParseTerm(EditorId, ModuleName) .
    snd-msg(get-dirty-focuses(EditorId)) .
    rec-msg(dirty-focuses(DirtyFoci?)) . 
    if equal(DirtyFoci, []) then
      snd-msg(get-tree(EditorId)) .
      rec-msg(tree(Tree?))
    else 
      Tree := error-tree
    fi
  fi
endlet

process ReplaceRoot(EditorId: term, Tree: term) is
let
  TotalTree   : term,
  Text        : str,
  Focus       : term
in
  snd-msg(move-focus-to-root(EditorId)) .
  rec-msg(set-focus(EditorId, Focus?)) .
  snd-msg(replace-focussed-tree(EditorId, Tree)) .
  rec-msg(focus(Focus?)) .
  snd-msg(get-tree(EditorId)) .
  rec-msg(tree(TotalTree?)) .
  snd-msg(unparse(TotalTree)) .
  rec-msg(unparsed-text(Text?)) .
  snd-msg(replace-text(EditorId, Text)) .
  snd-msg(move-focus-to-root(EditorId)) .
  rec-msg(set-focus(EditorId, Focus?)) .
  snd-msg(set-focus(EditorId, Focus))
endlet


process GetFocus(EditorId: term, Tree: term?) is
  snd-msg(get-focussed-tree(EditorId)) .
  (
    rec-msg(tree(Tree?))
  +
    rec-msg(no-tree) .
    Tree := error-tree
  )

process ReplaceFocus(EditorId: term, Tree: term) is
let
  TotalTree   : term,
  Text        : str,
  Focus       : term
in
  snd-msg(replace-focussed-tree(EditorId, Tree)) .
  rec-msg(focus(Focus?)) .
  snd-msg(get-tree(EditorId)) .
  rec-msg(tree(TotalTree?)) .
  snd-msg(unparse(TotalTree)) .
  rec-msg(unparsed-text(Text?)) .
  snd-msg(replace-text(EditorId, Text)) .
  snd-msg(move-focus-to-root(EditorId)) .
  rec-msg(set-focus(EditorId, Focus?)) .
  snd-msg(set-focus(EditorId, Focus))
endlet

process CheckTreeSort(Tree: term, Sort: str, RTree: term?) is
let 
  TreeSort : str 
in
  snd-msg(check-tree-sort(Sort, Tree)) .
  ( 
    rec-msg(wrong-sort(TreeSort?)) .
    snd-note(ui-status(errorf("top sort %s of tree does not match %s", 
                              [TreeSort, Sort]))) .
    RTree := error-tree
  +
    rec-msg(sort-ok) .
    RTree := Tree
  )
endlet

process ReduceTerm(Tree: term, ModuleName: str, NormalForm: term?) is
let
  Id          : int,
  ErrList     : list,
  Equations   : term
in
  Id := process-id .
  snd-msg(open-modules([ModuleName])) .
  rec-msg(finished-opening-modules) .
  snd-note(ui-status(stat(Id, "Retrieving equations"))) .
  snd-msg(process-eqs(ModuleName)) .
  rec-msg(eqs-processed(ModuleName)) .
  snd-msg(get-all-equations(ModuleName)) .
  (
    rec-msg(all-equations(Equations?)) .
    snd-note(ui-status(endstat(Id))).
 
    snd-note(ui-status(stat(Id, "Rewriting"))) .
    snd-msg(rewrite(ModuleName, Equations, Tree)) .
    (
      rec-msg(rewrite-result(NormalForm?)) .
      RestoreBracketsInTree(NormalForm, ModuleName, NormalForm?)
    +
      rec-msg(rewrite-errors(ErrList?)) .
      NormalForm := error-tree .
      snd-msg(display-rewrite-errors(ErrList))
    ) .
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(equations-incomplete) .
    NormalForm := error-tree .
    snd-note(ui-status(endstat(Id))) .
    snd-note(ui-status(errorf("Equations incomplete for %s", [ModuleName])))
  )
endlet

process RestoreBracketsInTree(Tree : term, ModuleName : str, NewTree : term?) is
let
  Table : term,
  Path : str
in
  snd-msg(get-parsetable(trm(ModuleName))).
  (
    rec-msg(parse-table(Table?, Path?)) .
    snd-msg(restore-brackets(Tree, Table)) .
    rec-msg(brackets-restored(NewTree?)) 
  +
    rec-msg(no-parse-table) .
    NewTree := error-tree
  )
endlet

process ActivateEditorWithTree(Tree: term, ModuleName: str, FileName: str) is
let
  Text        : str
in
  if not-equal(Tree, error-tree) then
    snd-msg(unparse(Tree)) . 
    rec-msg(unparsed-text(Text?)) .
    snd-msg(save-text-file(FileName, Text)) .
    rec-msg(save-done(FileName)) .
    snd-msg(edit-term-file-with-tree(ModuleName, FileName, Tree))
  fi
endlet

process ActivateEditorWithString(Text: str, ModuleName: str, FileName: str) is
  snd-msg(save-text-file(FileName, Text)) .
  rec-msg(save-done(FileName)) .
  snd-msg(edit-term-file(ModuleName, FileName))

process EditTerm(EditorId: term, ModuleName: str, Text: str, Tree : term) is
let
  Focus      : term,
  ArgList    : list,
  Stack      : list,
  Killed     : term,
  EditorId2  : term,
  STree      : term,
  RTree      : term,
  Error      : term,
  Trees      : list,
  ButtonName : str,
  SortName   : str,
  FilePath   : str,
  NewModName : str,
  FileName   : str,
  EditorName : str,
  FuncName   : str,
  FunSym     : str,
  String     : str,
  NrOfArgs   : int
in
  subscribe(syntax-changed(ModuleName)) . 
  if equal(quote(Tree), none) then 
    snd-msg(initialize-structure-editor(EditorId, Text)) 
  else 
    snd-msg(initialize-structure-editor-with-tree(EditorId, Tree)) 
  fi  . 
  rec-msg(initial-focus(Focus?)) .
  snd-msg(set-focus(EditorId, Focus)) .
  Killed := false .
  (
    (
      (
        rec-note(syntax-changed(ModuleName)) .
        snd-msg(invalidate-tree(EditorId))
      +
        rec-msg(extra-button-action(EditorId, ButtonName?)) .
        snd-msg(extra-button-action(ButtonName, ModuleName, EditorId)) 
      +
        rec-msg(apply(FuncName?, SortName?, NrOfArgs?), 
                Stack?, EditorId) .
        ArgList := [] .
        (
          if greater(NrOfArgs, 0) then
            STree := first(Stack) .
            Stack := next(Stack) .
            NrOfArgs := sub(NrOfArgs, 1) .
            ArgList := join(ArgList, STree)
          fi 
        ) *
        if equal(NrOfArgs, 0) then
          tau
        fi .
        snd-msg(apply-function(FuncName, SortName, ArgList)) .
        rec-msg(tree(RTree?)) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack), EditorId)
        else
          snd-msg(error-stack, EditorId)
        fi
      +
        rec-msg(parse-action(NewModName?), Stack?, EditorId) .
        snd-msg(invalidate-tree(EditorId)) .
        ParseTerm(EditorId, NewModName) .
        snd-msg(stack(Stack), EditorId)
      +
        rec-msg(get-root, Stack?, EditorId) .
        GetTree(EditorId, ModuleName, RTree?) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack), EditorId)
        else
          snd-msg(error-stack, EditorId)
        fi
      +
        rec-msg(set-root, Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        ReplaceRoot(EditorId, STree) .
        snd-msg(stack(Stack), EditorId)
      +
        rec-msg(get-focus, Stack?, EditorId) .
        GetFocus(EditorId, RTree?) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack), EditorId)
        else
          snd-msg(error-stack, EditorId)
        fi
      +
        rec-msg(set-focus, Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        ReplaceFocus(EditorId, STree) .
        snd-msg(stack(Stack), EditorId)
      +
        rec-msg(check-sort(SortName?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        CheckTreeSort(STree, SortName, RTree?) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack), EditorId)
        else
          snd-msg(error-stack, EditorId)
        fi
      +
        rec-msg(reduce(NewModName?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        ReduceTerm(STree, NewModName, RTree?) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack), EditorId)
        else
          snd-msg(error-stack, EditorId)
        fi
      +
        rec-msg(get-other-focus(NewModName?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
	FunSym := fun(STree) .
	if equal(FunSym, "path") then
	  FilePath := first(args(STree)) .
          snd-msg(check-editor-id(FilePath, NewModName)) .
          (
            rec-msg(existing-editor(FilePath?, EditorId2?)).
            GetFocus(EditorId2, RTree?) .
            if not-equal(RTree, error-tree) then
              Stack := join(RTree, Stack) .
              snd-msg(stack(Stack), EditorId)
            else
              snd-msg(error-stack, EditorId)
            fi
          +
            rec-msg(non-existing-editor(FilePath?)).
            snd-note(ui-status(errorf("editor for %s not active", 
                                      [FilePath]))) .
            snd-msg(error-stack, EditorId)
          )
	else
	  snd-msg(error-stack, EditorId)
	fi
      +
        rec-msg(edit(NewModName?, EditorName?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
	FunSym := fun(STree) .
	if equal(FunSym, "str") then
	  String := first(args(STree)) .
          ActivateEditorWithString(String, NewModName, EditorName)
        else
          ActivateEditorWithTree(STree, NewModName, EditorName) 
        fi .
        snd-msg(stack(Stack), EditorId)
      + 
        rec-msg(send, Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
        snd-msg(tree-send(STree)) .
        snd-msg(stack(Stack), EditorId)
      +
        rec-msg(recieve, Stack?, EditorId) .
        rec-msg(tree-send(RTree?)) .
        Stack := join(RTree, Stack) .
        snd-msg(stack(Stack), EditorId)
      +
        rec-msg(parse(NewModName?, SortName?), Stack?, EditorId) .
        STree := first(Stack) .
        Stack := next(Stack) .
	FunSym := fun(STree) .
	if or(equal(FunSym, "file"), equal(FunSym, "path")) then
	  FilePath := first(args(STree)) .
	  GetTextFromFile(FilePath, String?) .
	  tau .
          ParseText(String, NewModName, SortName, RTree?, Error?) .
	  tau .
	  ProcessParseError(NewModName, Error)
	else 
	  if equal(FunSym, "str") then
	    String := first(args(STree)) .
	    ParseText(String, NewModName, SortName, RTree?, Error?) .
	    tau .
	    ProcessParseError(NewModName, Error)
	  else
	    RTree := error-tree
	  fi
	fi .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack), EditorId)
        else
          snd-msg(error-stack, EditorId)
        fi
      +
        rec-msg(get-argument(NrOfArgs?), Stack?, EditorId) .
        STree := first(Stack) .
        snd-msg(get-argument-given-number(STree, NrOfArgs)) .
        rec-msg(tree(RTree?)) .
        if not-equal(RTree, error-tree) then
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack), EditorId)
        else
          snd-msg(error-stack, EditorId)
        fi
      +
        rec-msg(exists(FileName?), Stack?, EditorId) .
        snd-msg(exists-file(FileName)) .
	(
	  rec-msg(file-exists(FileName)) .
          snd-msg(stack(Stack), EditorId)
	+
	  rec-msg(file-not-exists(FileName)) .
          snd-note(ui-status(errorf("%s does not exist", 
                                    [FileName]))) .
          snd-msg(error-stack, EditorId)
	)
      +
        rec-msg(locate(FileName?), Stack?, EditorId) .
        snd-msg(locate-file(FileName)) .
	(
	  rec-msg(file-location(FileName, FilePath?)) .
	  RTree := quote(path(FilePath)) .
          Stack := join(RTree, Stack) .
          snd-msg(stack(Stack), EditorId)
	+
	  rec-msg(file-not-exists(FileName)) .
          snd-note(ui-status(errorf("%s does not exist", 
                                    [FileName]))) .
          snd-msg(error-stack, EditorId)
	)
      +
        rec-msg(push-filename(FileName?), Stack?, EditorId) .
	RTree := quote(file(FileName)) .
        Stack := join(RTree, Stack) .
        snd-msg(stack(Stack), EditorId)
      +
        rec-msg(push-string(String?), Stack?, EditorId) .
	RTree := quote(str(String)) .
        Stack := join(RTree, Stack) .
        snd-msg(stack(Stack), EditorId)
      +
        rec-msg(message(String?), Stack?, EditorId) .
	snd-note(ui-status(errorf("%s", [String]))) .
        snd-msg(stack(Stack), EditorId)
      ) *
      if equal(Killed, true) then
        tau
      fi
    )
    ||
    rec-msg(kill-editor(EditorId)).
    Killed := true .
    snd-msg(kill-editor-done(EditorId))
  )
endlet
