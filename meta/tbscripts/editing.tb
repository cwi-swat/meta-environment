process FindModuleFilename(ModuleId: str, Type: term, Path: str?) is
let
  Extension: str,
  Basedir: str
in
  snd-msg(get-path-from-db(ModuleId))
  .
  (
    rec-msg(path(Basedir?))
    . snd-msg(file-extension-hook(Type))
    . rec-msg(file-extension-hook-result(Extension?))
    . BuildPath(Basedir, ModuleId, Extension, Path?)
  +
    rec-msg(no-path)
    . LocateFile(ModuleId, Type, Path?)
  )
endlet

process GetPath(Sid: term, Path: str?) is
  snd-msg(em-get-path(Sid))
  . rec-msg(em-path(Sid, Path?))

process GetModuleId(Sid: term, ModuleId: str?) is
  snd-msg(em-get-modulename(Sid))
  . rec-msg(em-modulename(Sid, ModuleId?))

process GetEditorType(Path: str, EditorType: term?) is
let
  Extension: str
in
  snd-msg(io-get-path-extension(Path))
  . rec-msg(io-extension(Path, Extension?))
  .
  if equal(Extension, ".sdf") then
    EditorType := syntax-editor
  else
    if equal(Extension, ".asf") then
      EditorType := equations-editor
    else
      EditorType := term-editor
    fi
  fi
endlet

process Edit(Path: str, Sid: term?) is
  snd-msg(em-create-session(Path))
  . rec-msg(em-session(Path, Sid?))

process IsStructureEditorRegistered(Sid: term, Registered: bool?) is
  snd-msg(em-is-editor-registered(Sid, structure))
  .
  (
    rec-msg(em-editor-registered(Sid, structure))
    . Registered := true
  +
    rec-msg(em-editor-not-registered(Sid, structure))
    . Registered := false
  )

process IsTextEditorRegistered(Sid: term, Registered: bool?) is
  snd-msg(em-is-editor-registered(Sid, text))
  .
  (
    rec-msg(em-editor-registered(Sid, text))
    . Registered := true
  +
    rec-msg(em-editor-not-registered(Sid, text))
    . Registered := false
  )

process EditText(Sid: term, Type: term, AlreadyExists: bool?) is
let
  Events: list,
  Path: str,
  ModuleId: str
in
  IsTextEditorRegistered(Sid, AlreadyExists?)
  .
  if equal(AlreadyExists, true) then
    snd-msg(te-editor-to-front(Sid))
  else
    snd-msg(em-register-editor(Sid, text))
    . GetPath(Sid, Path?)
    . snd-msg(te-edit-text(Sid, EDITOR, Path))
    . snd-msg(cm-get-events(Type))
    . rec-msg(cm-events(Events?))
    . snd-msg(te-add-actions(Sid, Events))
  fi
endlet

process EditStructure(Sid: term, Tree: term) is
let
  Registered: bool
in
  IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    snd-msg(se-delete(Sid))
  else
    snd-msg(em-register-editor(Sid, structure))
  fi
  . snd-msg(se-create(Sid, Tree))
endlet

process SynchronizeFocus(Sid: term) is
let
  Focus: term,
  Sortname: str
in
  snd-msg(se-get-sort-at-cursor(Sid))
  .
  (
    rec-msg(se-sort-at-cursor(Sid, Sortname?))
    . snd-msg(te-display-message(Sid, Sortname))
    . snd-msg(se-get-focus-at-cursor(Sid))
    . rec-msg(se-focus-at-cursor(Sid, Focus?))
    . snd-msg(te-set-focus(Sid, Focus))
  +
    rec-msg(se-no-cursor(Sid))
  )
endlet

process MenuSelected(Sid: term, EditorType: term) is
let
  Actions: list,
  Args: list,
  Event: term,
  ModuleId: str
in
  rec-msg(te-menu-event(Sid, Event?))
  . snd-msg(em-request-transaction(Sid))
  .
  (
    rec-msg(em-no-transaction(Sid))
  +
    rec-msg(em-transaction-started(Sid))
    . Args := []
    . GetModuleId(Sid, ModuleId?)
    . snd-msg(cm-get-module-actions(EditorType, Event, ModuleId))
    . rec-msg(cm-module-actions(Actions?))
    . snd-msg(perform-actions(Sid, Actions))
    . rec-msg(actions-performed(Sid, Actions))
    . snd-msg(em-end-transaction(Sid))
  )
endlet

process MouseClicked(Sid: term) is
let
  Offset: int,
  Registered: bool,
  Tid: term
in
  rec-msg(te-mouse-click-at-offset(Sid, Offset?))
  . snd-msg(em-request-transaction(Sid))
  .
  (
    rec-msg(em-no-transaction(Sid))
  +
    rec-msg(em-transaction-started(Sid))
    . IsStructureEditorRegistered(Sid, Registered?)
    .
    if equal(Registered, true) then
      snd-msg(se-set-cursor-at-offset(Sid, Offset))
      . SynchronizeFocus(Sid)
    else
      tau
    fi
    . snd-msg(em-end-transaction(Sid))
  )
endlet

process TextChanged(Sid: term) is
let
  Registered: bool
in
  rec-msg(te-contents-changed(Sid))
  . snd-msg(em-request-transaction(Sid))
  .
  (
    rec-msg(em-no-transaction(Sid))
  +
    rec-msg(em-transaction-started(Sid))
    . IsStructureEditorRegistered(Sid, Registered?)
    .
    if equal(Registered, true) then
      DeleteStructureEditor(Sid)
      . snd-msg(te-clear-focus(Sid))
      . snd-msg(te-display-message(Sid,
                                   "Editor contents have changed, focus is unavailable until next parse."))
    else
      tau
    fi
    . snd-msg(em-end-transaction(Sid))
  )
endlet

process EditorDisconnected(Sid: term) is
  (
    rec-msg(te-text-editor-disconnected(Sid))
  +
    rec-msg(kill-editor(Sid))
  )

process DeleteTextEditor(Sid: term) is
  snd-msg(te-kill-text-editor(Sid))
  . snd-msg(em-unregister-editor(Sid, text))

process DeleteStructureEditor(Sid: term) is
  snd-msg(se-delete(Sid))
  . snd-msg(em-unregister-editor(Sid, structure))

process DeleteSession(Sid: term) is
let
  Registered: bool
in
  IsTextEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    DeleteTextEditor(Sid)
  else
    tau
  fi
  . IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    DeleteStructureEditor(Sid)
  else
    tau
  fi
  . snd-msg(em-delete-session(Sid))
endlet

process DeleteSessions(ModuleId: str) is
let
  Sid: term,
  Sids: list
in
  snd-msg(em-get-sessions-by-modulename(ModuleId))
  . rec-msg(em-sessions(ModuleId, Sids?))
  .
  (
    if not-equal(Sids, []) then
      Sid := first(Sids)
      . DeleteSession(Sid)
      . Sids := next(Sids)
    fi
  )
  *
  if equal(Sids, []) then
    tau
  fi
endlet

process GetSyntaxTree(ModuleId: str, Tree: term?, Available: bool?) is
  snd-msg(get-syntax-tree(ModuleId))
  .
  (
    rec-msg(syntax(Tree?))
    . Available := true
  +
    rec-msg(unavailable)
    . Available := false
  )

process EditSyntax(Path: str) is
let
  AlreadyExists: bool,
  Available: bool,
  EditorType: term,
  HasText: bool,
  HasStructure: bool,
  ModuleId: str,
  ParseSucceeded: bool,
  Sid: term,
  Tree: term
in
  EditorType := syntax-editor
  . Edit(Path, Sid?)
  . EditText(Sid, EditorType, AlreadyExists?)
  . snd-msg(syntax-editor-started(Path, Sid))
  .
  if equal(AlreadyExists, false) then
    snd-msg(ts-get-str-value("path-modulename", Path))
    .
    (
      rec-msg(ts-value(ModuleId?))
      . snd-msg(em-bind-session(Sid, ModuleId))
      . rec-msg(em-session-bound(Sid, ModuleId))
      . GetSyntaxTree(ModuleId, Tree?, Available?)
      .
      if equal(Available, true) then
	EditStructure(Sid, Tree)
      else
	tau
      fi
    +
      rec-msg(ts-no-value)
    )
    .
    (
      MenuSelected(Sid, EditorType)
    +
      MouseClicked(Sid)
    +
      TextChanged(Sid)
    )
    *
    EditorDisconnected(Sid)
    . IsTextEditorRegistered(Sid, HasText?)
    . IsStructureEditorRegistered(Sid, HasStructure?)
    .
    if and(HasText, not(HasStructure)) then
      ParseSyntax(Sid, sdf, ParseSucceeded?)
    else
      tau
    fi
    . DeleteSession(Sid)
  else
    tau
  fi
endlet

process GetEquationsTree(ModuleId: str, Tree: term?, Available: bool?) is
  snd-msg(get-equations-for-module(ModuleId))
  .
  (
    rec-msg(equations(Tree?))
    . Available := true
  +
    rec-msg(no-equations)
    . Available := false
  )

process EditEquations(Path: str) is
let
  AlreadyExists: bool,
  Available: bool,
  EditorType: term,
  ModuleId: str,
  Sid: term,
  Tree: term
in
  EditorType := equations-editor
  . Edit(Path, Sid?)
  . EditText(Sid, EditorType, AlreadyExists?)
  . snd-msg(equations-editor-started(Path, Sid))
  .
  if equal(AlreadyExists, false) then
    snd-msg(ts-get-str-value("path-modulename", Path))
    .
    (
      rec-msg(ts-value(ModuleId?))
      . snd-msg(em-bind-session(Sid, ModuleId))
      . rec-msg(em-session-bound(Sid, ModuleId))
      . GetEquationsTree(ModuleId, Tree?, Available?)
      .
      if equal(Available, true) then
	EditStructure(Sid, Tree)
      else
	tau
      fi
    +
      rec-msg(ts-no-value)
    )
    .
    (
      MenuSelected(Sid, EditorType)
    +
      MouseClicked(Sid)
    +
      TextChanged(Sid)
    )
    *
    EditorDisconnected(Sid)
    . DeleteSession(Sid)
  else
    tau
  fi
endlet

process GetTermTree(Filename: str, Tree: term?, Available: bool?) is
  snd-msg(get-term-tree(Filename))
  .
  (
    rec-msg(term-tree(Filename, Tree?))
    . Available := true
  +
    rec-msg(no-term-tree(Filename))
    . Available := false
  )

process CheckSanity(Path: str, RequestedModuleId: str, Valid: bool?) is
let
  CurrentModuleId: str,
  Sid: term
in
  snd-msg(em-get-session-by-path(Path))
  .
  (
    rec-msg(em-session(Path, Sid?))
    . snd-msg(em-get-modulename(Sid))
    . rec-msg(em-modulename(Sid, CurrentModuleId?))
    . Valid := equal(CurrentModuleId, RequestedModuleId)
  +
    rec-msg(em-no-such-session(Path))
    . Valid := true
  )
endlet

process EditTerm(Path: str, ModuleId: str) is
let
  Actions: list,
  AlreadyExists: bool,
  Available: bool,
  EditorType: term,
  Error: str,
  Sid: term,
  Tree: term,
  Valid: bool
in
  EditorType := term-editor
  . CheckSanity(Path, ModuleId, Valid?)
  .
  if equal(Valid, true) then
    Edit(Path, Sid?)
    . EditText(Sid, EditorType, AlreadyExists?)
    . snd-msg(term-editor-started(Path, ModuleId, Sid))
    .
    if equal(AlreadyExists, false)
    then
      snd-msg(em-bind-session(Sid, ModuleId))
      . rec-msg(em-session-bound(Sid, ModuleId))
      . GetTermTree(Path, Tree?, Available?)
      .
      if equal(Available, true) then
	EditStructure(Sid, Tree)
      else
	tau
      fi
      .
      (
	MenuSelected(Sid, EditorType)
      +
	MouseClicked(Sid)
      +
	TextChanged(Sid)
      )
      *
      EditorDisconnected(Sid)
      . DeleteSession(Sid)
    else
      tau
    fi
  else
    Error := "Term is already being edited over a different module."
    . snd-msg(term-editor-not-started(Path, ModuleId, Error))
  fi
endlet

process GetModuleForPath(Path: str, ModuleId: str?) is
  snd-msg(ts-get-str-value("path-modulename", Path))
  .
  (
    rec-msg(ts-value(ModuleId?))
  +
    rec-msg(ts-no-value)
    . ModuleId := ""
  )

process GetModuleByExtension(Path: str, ModuleId: str?, Available: bool?) is
let
  Extension: str
in
  snd-msg(io-get-path-extension(Path))
  . rec-msg(io-extension(Path, Extension?))
  . snd-msg(get-extension-modulename(Extension))
  .
  (
    rec-msg(extension-modulename(Extension, ModuleId?))
    . Available := true
  +
    rec-msg(no-extension-modulename(Extension))
    . Available := false
  )
endlet

process StartEditor(Path: str, EditorType: term) is
let
  Available: bool,
  ErrorMsg: str,
  ModuleId: str,
  Pid: int,
  Sid: term
in
  if equal(EditorType, term-editor) then
    GetModuleByExtension(Path, ModuleId?, Available?)
    .
    if equal(Available, true) then
      create(EditTerm(Path, ModuleId), Pid?)
      .
      (
        rec-msg(term-editor-started(Path, ModuleId, Sid?))
      +
        rec-msg(term-editor-not-started(Path, ModuleId, ErrorMsg?))
        . Error(ErrorMsg, [])
      )
    else
      snd-note(ui-status(errorf("Unable to determine modulename for: %s",
                                [Path])))
    fi
  else
    if equal(EditorType, syntax-editor) then
      create(EditSyntax(Path), Pid?)
      . rec-msg(syntax-editor-started(Path, Sid?))
    else
      create(EditEquations(Path), Pid?)
      . rec-msg(equations-editor-started(Path, Sid?))
    fi
  fi
endlet
