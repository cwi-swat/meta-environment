process ActivateEditor(Modulename : str, Filename : str, Tree : term) is
let
  FunSym : str,
  String : str
in
  FunSym := fun(Tree)
  .
  if equal(FunSym, "str") then
    String := first(args(Tree))
    . ActivateEditorWithString(String, Modulename, Filename)
  else
    ActivateEditorWithTree(Tree, Modulename, Filename)
  fi
endlet

process DisplayMessage(EditorId : term, Message : str) is
  snd-msg(te-display-message(EditorId, Message))

process GetActiveModule(EditorId : term, ModuleName : str?) is
  snd-msg(em-get-modulename(EditorId))
  .
  (
    rec-msg(em-modulename(EditorId, ModuleName?))
  +
    rec-msg(em-no-such-session(EditorId)) 
    . printf("FIX ME: PushActiveModule: No such session, sending dummy modulename\n")
    . ModuleName := "basic/Whitespace"
  +
    rec-msg(em-session-not-bound(EditorId))
    . printf("FIX ME: PushActiveModule: Session not bound, sending dummy modulename\n")
    . ModuleName := "basic/Whitespace"
  )

 
process SetRoot(EditorId : term, Tree : term) is
  ReplaceFocus(EditorId, Tree)

process GetTree(Sid: term, Tree: term?, Available: bool?) is
let
  Modulename: str,
  Registered: bool
in
  GetActiveModule(Sid, Modulename?)
  . ParseTerm(Sid, Modulename)
  . IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    GetParsetree(Sid, Tree?)
    . Available := true
  else
    Available := false
  fi
endlet

process GetFocus(Sid: term, Tree: term?) is
let
  Registered: bool
in
  IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    snd-msg(se-get-cursor(Sid))
    .
    (
      rec-msg(se-cursor(Sid, Tree?))
    +
      rec-msg(se-no-cursor(Sid))
      . Tree := no-tree
    )
  else
    Tree := no-tree
  fi
endlet

process GetParsetree(Sid: term, Parsetree: term?) is
  snd-msg(se-get-parse-tree(Sid))
  . rec-msg(se-parse-tree(Sid, Parsetree?))

process ReplaceFocus(Sid: term, Tree: term) is
let
  Text: str,
  Filename: str,
  Error: str
in
  snd-msg(unparse(Tree))
  . rec-msg(unparsed-text(Text?))
  . GetPath(Sid, Filename?)
  . snd-msg(io-write-text-list(Filename, [Text]))
  .
  (
    rec-msg(io-file-written)
    . snd-msg(te-reread-contents(Sid))
  +
    rec-msg(io-file-not-written(Error?))
    . snd-note(ui-status(errorf("%s: %s", [Filename, Error])))
  )
  . snd-msg(se-update(Sid, Tree))
  . snd-msg(te-clear-focus(Sid))
endlet

process CheckTreeSort(Tree: term, Sort: str, RTree: term?) is
let
  TreeSort: str
in
/*
  snd-msg(se-check-tree-sort(Sort, Tree))
  .
  (
    rec-msg(se-wrong-sort(TreeSort?))
    . snd-note(ui-status(errorf("Top sort %s of tree does not match %s",
                                [TreeSort, Sort])))
    . RTree := error-tree
  +
    rec-msg(se-sort-ok)
    . RTree := Tree
  )
*/
  RTree := Tree
endlet
process GetRoot(EditorId : term, Tree : term?) is
let
  Available : bool
in
  GetTree(EditorId, Tree?, Available?)
  .
  if equal(Available, true) then
    tau
  else
    Tree := no-tree
  fi
endlet

process GetPath(Sid: term, Path: str?) is
  snd-msg(em-get-path(Sid))
  . rec-msg(em-path(Sid, Path?))

process GetModuleId(Sid: term, ModuleId: str?) is
  snd-msg(em-get-modulename(Sid))
  .
  (
    rec-msg(em-modulename(Sid, ModuleId?))
  +
    rec-msg(em-session-not-bound(Sid))
    . printf("FIX ME: GetModuleId: Session not bound, setting dummy module\n")
    . ModuleId := "basic/Whitespace"
  )

process GetEditorType(Path: str, EditorType: term?) is
let
  Extension: str
in
  snd-msg(io-get-path-extension(Path))
  . rec-msg(io-extension(Path, Extension?))
  .
  if equal(Extension, ".sdf") then
    EditorType := syntax-editor
  else
    if equal(Extension, ".asf") then
      EditorType := equations-editor
    else
      EditorType := term-editor
    fi
  fi
endlet

process Edit(Path: str, Sid: term?) is
  snd-msg(em-create-session(Path))
  . rec-msg(em-session(Path, Sid?))

process IsStructureEditorRegistered(Sid: term, Registered: bool?) is
  snd-msg(em-is-editor-registered(Sid, structure))
  .
  (
    rec-msg(em-editor-registered(Sid, structure))
    . Registered := true
  +
    rec-msg(em-editor-not-registered(Sid, structure))
    . Registered := false
  )

process IsTextEditorRegistered(Sid: term, Registered: bool?) is
  snd-msg(em-is-editor-registered(Sid, text))
  .
  (
    rec-msg(em-editor-registered(Sid, text))
    . Registered := true
  +
    rec-msg(em-editor-not-registered(Sid, text))
    . Registered := false
  )

process EditText(Sid: term, Type: term, Name: str, AlreadyExists: bool?) is
let
  Events: list,
  Path: str,
  Categories: term
in
  IsTextEditorRegistered(Sid, AlreadyExists?)
  .
  if equal(AlreadyExists, true) then
    snd-msg(te-editor-to-front(Sid))
  else
    snd-msg(em-register-editor(Sid, text))
    . GetPath(Sid, Path?)
    . snd-msg(te-edit-text(Sid, Path))
    /*. snd-msg(cm-get-events(Type))*/
    /*. rec-msg(cm-events(Events?))*/
    /*. snd-msg(te-add-actions(Sid, Events))*/
    . snd-msg(cm-get-module-events(Type, Name))
    . rec-msg(cm-module-events(Events?))
    . snd-msg(te-add-actions(Sid, Events))
    . snd-msg(get-text-categories)
    . rec-msg(text-categories(Categories?)) 
    . snd-msg(te-register-text-categories(Sid, Categories))
  fi
endlet

process EditStructure(Sid: term, Tree: term) is
let
  Registered: bool,
  Slices: term
in
  IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    snd-msg(se-delete(Sid))
  else
    snd-msg(em-register-editor(Sid, structure))
  fi
  . snd-msg(se-create(Sid, Tree))
  . snd-msg(se-get-tree-slices(Sid))
  . rec-msg(se-tree-slices(Sid, Slices?))
  . snd-msg(te-highlight-slices(Sid, Slices))
endlet

process SynchronizeFocus(Sid: term) is
let
  Focus: term,
  Sortname: str
in
  snd-msg(se-get-sort-at-cursor(Sid))
  .
  (
    rec-msg(se-sort-at-cursor(Sid, Sortname?))
    . snd-msg(se-get-focus-at-cursor(Sid))
    . rec-msg(se-focus-at-cursor(Sid, Focus?))
    . snd-msg(te-set-focus(Sid, Focus))
    . snd-msg(te-display-message(Sid, Sortname))
  +
    rec-msg(se-no-cursor(Sid))
  )
endlet

process MenuSelected(Sid: term, EditorType: term) is
let
  Action: str,
  Event: term,
  ModuleId: str
in
  rec-msg(te-menu-event(Sid, Event?))
  . snd-msg(em-request-transaction(Sid))
  .
  (
    rec-msg(em-no-transaction(Sid))
  +
    rec-msg(em-transaction-started(Sid))
    . GetModuleId(Sid, ModuleId?)
    . snd-msg(cm-get-module-action(EditorType, Event, ModuleId))
    . rec-msg(cm-module-action(Action?))
    . Action(Sid)
    . snd-msg(em-end-transaction(Sid))
  )
endlet

process MouseClicked(Sid: term) is
let
  Column: int,
  Line: int,
  Offset: int,
  Pid: int,
  Registered: bool
in
  (
    rec-msg(te-mouse-click-at-offset(Sid, Offset?))
    . create(OffsetHandler(Sid, Offset), Pid?)
  +
    rec-msg(te-mouse-click-at-line-column(Sid, Line?, Column?))
    . create(LineColumnHandler(Sid, Line, Column), Pid?)
  ) 
  . snd-msg(em-request-transaction(Sid))
  .
  (
    rec-msg(em-no-transaction(Sid))
  +
    rec-msg(em-transaction-started(Sid))
    . IsStructureEditorRegistered(Sid, Registered?)
    .
    if equal(Registered, true) then
      snd-msg(handle-mouse-event(Pid))
      . SynchronizeFocus(Sid)
    else
      tau
    fi
    . snd-msg(em-end-transaction(Sid))
  )
endlet

process OffsetHandler(Sid: term, Offset: int) is
let
  Pid: int
in
  Pid := process-id
  . rec-msg(handle-mouse-event(Pid))
  . snd-msg(se-set-cursor-at-offset(Sid, Offset))
endlet

process LineColumnHandler(Sid: term, Line: int, Column: int) is
let
  Pid: int
in
  Pid := process-id
  . rec-msg(handle-mouse-event(Pid))
  . snd-msg(se-set-cursor-at-line-column(Sid, Line, Column))
endlet

process TextChanged(Sid: term) is
let
  Registered: bool
in
  rec-msg(te-contents-changed(Sid))
  . snd-msg(em-request-transaction(Sid))
  .
  (
    rec-msg(em-no-transaction(Sid))
  +
    rec-msg(em-transaction-started(Sid))
    . IsStructureEditorRegistered(Sid, Registered?)
    .
    if equal(Registered, true) then
      DeleteStructureEditor(Sid)
      . snd-msg(te-clear-focus(Sid))
      . snd-msg(te-display-message(Sid,
                                   "Editor contents have changed, focus is unavailable until next parse."))
    else
      tau
    fi
    . snd-msg(em-end-transaction(Sid))
  )
endlet

process EditorDisconnected(Sid: term) is
  (
    rec-msg(te-text-editor-disconnected(Sid))
  +
    rec-msg(kill-editor(Sid))
  )

process DeleteTextEditor(Sid: term) is
  snd-msg(te-kill-text-editor(Sid))
  . snd-msg(em-unregister-editor(Sid, text))

process DeleteStructureEditor(Sid: term) is
  snd-msg(se-delete(Sid))
  . snd-msg(em-unregister-editor(Sid, structure))

process DeleteSession(Sid: term) is
let
  Registered: bool
in
  IsTextEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    DeleteTextEditor(Sid)
  else
    tau
  fi
  . IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    DeleteStructureEditor(Sid)
  else
    tau
  fi
  . snd-msg(em-delete-session(Sid))
endlet

process DeleteSessions(ModuleId: str) is
let
  Sid: term,
  Sids: list
in
  snd-msg(em-get-sessions-by-modulename(ModuleId))
  .
  (
    rec-msg(em-sessions(ModuleId, Sids?))
    .
    (
      if not-equal(Sids, []) then
        Sid := first(Sids)
        . DeleteSession(Sid)
	/*. snd-msg(kill-editor(Sid))*/
        . Sids := next(Sids)
      fi
    )
    *
    if equal(Sids, []) then
      tau
    fi
  +
    rec-msg(em-no-such-session(Sid))
  )
endlet

process GetSyntaxTree(ModuleId: str, Tree: term?, Available: bool?) is
  snd-msg(get-syntax-tree(ModuleId))
  .
  (
    rec-msg(syntax(Tree?))
    . Available := true
  +
    rec-msg(unavailable)
    . Available := false
  )

process EditSyntax(Path: str) is
let
  AlreadyExists: bool,
  Available: bool,
  EditorType: term,
  HasText: bool,
  HasStructure: bool,
  ModuleId: str,
  Sid: term,
  Tree: term
in
  EditorType := syntax-editor
  . Edit(Path, Sid?)
  . EditText(Sid, EditorType, "", AlreadyExists?)
  . snd-msg(syntax-editor-started(Path, Sid))
  .
  if equal(AlreadyExists, false) then
    snd-msg(ts-get-str-value("path-modulename", Path))
    .
    (
      rec-msg(ts-value(ModuleId?))
      . snd-msg(em-bind-session(Sid, ModuleId))
      . rec-msg(em-session-bound(Sid, ModuleId))
      . GetSyntaxTree(ModuleId, Tree?, Available?)
      .
      if equal(Available, true) then
        EditStructure(Sid, Tree)
      else
        tau
      fi
    +
      rec-msg(ts-no-value)
      . snd-msg(ts-get-str-value("path-weak-modulename", Path))
      .
      (
        rec-msg(ts-value(ModuleId?))
        . snd-msg(em-bind-session(Sid, ModuleId))
        . rec-msg(em-session-bound(Sid, ModuleId))
      +
        rec-msg(ts-no-value)
      )
    )
    .
    (
      MenuSelected(Sid, EditorType)
    +
      MouseClicked(Sid)
    +
      TextChanged(Sid)
    )
    *
    EditorDisconnected(Sid)
    . IsTextEditorRegistered(Sid, HasText?)
    . IsStructureEditorRegistered(Sid, HasStructure?)
    . DeleteSession(Sid)
    .
    if and(HasText, not(HasStructure)) then
      OpenSyntax(Path, sdf)
    else
      tau
    fi
  else
    tau
  fi
endlet

process GetEquationsTree(ModuleId: str, Tree: term?, Available: bool?) is
  snd-msg(get-equations-for-module(ModuleId))
  .
  (
    rec-msg(equations(Tree?))
    . Available := true
  +
    rec-msg(no-equations)
    . Available := false
  )

process EditEquations(Path: str) is
let
  AlreadyExists: bool,
  Available: bool,
  EditorType: term,
  ModuleId: str,
  Sid: term,
  Tree: term
in
  EditorType := equations-editor
  . Edit(Path, Sid?)
  . EditText(Sid, EditorType, "", AlreadyExists?)
  . snd-msg(equations-editor-started(Path, Sid))
  .
  if equal(AlreadyExists, false) then
    snd-msg(ts-get-str-value("path-modulename", Path))
    .
    (
      rec-msg(ts-value(ModuleId?))
      . snd-msg(em-bind-session(Sid, ModuleId))
      . rec-msg(em-session-bound(Sid, ModuleId))
      . GetEquationsTree(ModuleId, Tree?, Available?)
      .
      if equal(Available, true) then
        EditStructure(Sid, Tree)
      else
        tau
      fi
    +
      rec-msg(ts-no-value)
    )
    .
    (
      MenuSelected(Sid, EditorType)
    +
      MouseClicked(Sid)
    +
      TextChanged(Sid)
    )
    *
    EditorDisconnected(Sid)
    . DeleteSession(Sid)
  else
    tau
  fi
endlet

process GetTermTree(Filename: str, Tree: term?, Available: bool?) is
  snd-msg(get-term-tree(Filename))
  .
  (
    rec-msg(term-tree(Filename, Tree?))
    . Available := true
  +
    rec-msg(no-term-tree(Filename))
    . Available := false
  )

process GetModuleByPath(Path: str, ModuleId: str?, Available: bool?) is
let
  Sid: term
in
  snd-msg(em-get-session-by-path(Path))
  .
  (
    rec-msg(em-session(Path, Sid?))
    . snd-msg(em-get-modulename(Sid))
    . rec-msg(em-modulename(Sid, ModuleId?))
    . Available := true
  +
    rec-msg(em-no-such-session(Path))
    . Available := false
  )
endlet

process CheckSanity(Path: str, RequestedModuleId: str, Valid: bool?) is
let
  Available: bool,
  CurrentModuleId: str
in
  GetModuleByPath(Path, CurrentModuleId?, Available?)
  . 
  if equal(Available, true) then
    Valid := equal(CurrentModuleId, RequestedModuleId)
  else
    Valid := true
  fi
endlet

process EditTerm(Path: str, ModuleId: str) is
let
  AlreadyExists: bool,
  Available: bool,
  EditorType: term,
  Error: str,
  Sid: term,
  Tree: term,
  Valid: bool
in
  EditorType := term-editor
  . CheckSanity(Path, ModuleId, Valid?)
  .
  if equal(Valid, true) then
    Edit(Path, Sid?)
    . EditText(Sid, EditorType, ModuleId, AlreadyExists?)
    . snd-msg(term-editor-started(Path, ModuleId, Sid))
    .
    if equal(AlreadyExists, false) then
      snd-msg(em-bind-session(Sid, ModuleId))
      . rec-msg(em-session-bound(Sid, ModuleId))
      . GetTermTree(Path, Tree?, Available?)
      .
      if equal(Available, true) then
        EditStructure(Sid, Tree)
      else
        tau
      fi
      .
      (
        MenuSelected(Sid, EditorType)
      +
        MouseClicked(Sid)
      +
        TextChanged(Sid)
      )
      *
      EditorDisconnected(Sid)
      . DeleteSession(Sid)
    else
      tau
    fi
  else
    Error := "Term is already being edited over a different module."
    . snd-msg(term-editor-not-started(Path, ModuleId, Error))
  fi
endlet

process GetModuleForPath(Path: str, ModuleId: str?) is
  snd-msg(ts-get-str-value("path-modulename", Path))
  .
  (
    rec-msg(ts-value(ModuleId?))
  +
    rec-msg(ts-no-value)
    . ModuleId := ""
  )

process GetModuleByExtension(Path: str, ModuleId: str?, Available: bool?) is
let
  Extension: str
in
  snd-msg(io-get-path-extension(Path))
  . rec-msg(io-extension(Path, Extension?))
  . snd-msg(get-extension-modulename(Extension))
  .
  (
    rec-msg(extension-modulename(Extension, ModuleId?))
    . Available := true
  +
    rec-msg(no-extension-modulename(Extension))
    . Available := false
  )
endlet

process StartEditor(Path: str, EditorType: term) is
let
  Available: bool,
  ErrorMsg: str,
  ModuleId: str,
  Pid: int,
  Sid: term
in
  if equal(EditorType, term-editor) then
    GetModuleByExtension(Path, ModuleId?, Available?)
    .
    if equal(Available, false) then
      GetModuleByPath(Path, ModuleId?, Available?)
    fi
    . 
    if equal(Available, true) then
      create(EditTerm(Path, ModuleId), Pid?)
      .
      (
        rec-msg(term-editor-started(Path, ModuleId, Sid?))
      +
        rec-msg(term-editor-not-started(Path, ModuleId, ErrorMsg?))
        . Error(ErrorMsg, [])
      )
    else
      snd-note(ui-status(errorf("Unable to determine modulename for: %s",
                                [Path])))
    fi
  else
    if equal(EditorType, syntax-editor) then
      create(EditSyntax(Path), Pid?)
      . rec-msg(syntax-editor-started(Path, Sid?))
    else
      create(EditEquations(Path), Pid?)
      . rec-msg(equations-editor-started(Path, Sid?))
    fi
  fi
endlet

process MoveCursorLeftAction(EditorId : term) is
  MoveCursor(EditorId, left)

process MoveCursorRightAction(EditorId : term) is
  MoveCursor(EditorId, right)

process MoveCursorUpAction(EditorId : term) is
  MoveCursor(EditorId, up)

process MoveCursorDownAction(EditorId : term) is
  MoveCursor(EditorId, down)

process MoveCursor(Sid: term, Direction: term) is
let
  Registered: bool
in
  IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    snd-msg(se-move-cursor(Sid, Direction))
    . SynchronizeFocus(Sid)
  else
    tau
  fi
endlet

process ActivateEditorWithTree(Tree: term, Modulename: str, Filename: str) is
let
  Error: term,
  Pid: int,
  Sid: term,
  Text: str,
  ErrorMessage: str
in
  if not-equal(Tree, error-tree) then
    snd-msg(unparse(Tree))
    . rec-msg(unparsed-text(Text?))
    . snd-msg(io-write-text-list(Filename, [Text]))
    .
    (
      rec-msg(io-file-written)
      . create(EditTerm(Filename, Modulename), Pid?)
      .
      (
        rec-msg(term-editor-started(Filename, Modulename, Sid?))
      +
        rec-msg(term-editor-not-started(Filename, Modulename, ErrorMessage?))
        . Error(ErrorMessage, [])
      )
    +
      rec-msg(io-file-not-written(Error?))
      . snd-note(ui-status(errorf("%s: %t", [Filename, Error])))
    )
  fi
endlet

process ActivateEditorWithString(Text: str, Modulename: str, Filename: str) is
let
  Error: term,
  Pid: int,
  Sid: term,
  ErrorMessage: str
in
  snd-msg(io-write-text-list(Filename, [Text]))
  .
  (
    rec-msg(io-file-written)
    . create(EditTerm(Filename, Modulename), Pid?)
    .
    (
      rec-msg(term-editor-started(Filename, Modulename, Sid?))
    +
      rec-msg(term-editor-not-started(Filename, Modulename, ErrorMessage?))
      . Error(ErrorMessage, [])
    )
  +
    rec-msg(io-file-not-written(Error?))
    . snd-note(ui-status(errorf("%s: %t", [Filename, Error])))
  )
endlet

process EditLocation(Pid: int, Location: term) is
let
  EditorType: term,
  Path: str,
  Sid: term
in
  snd-msg(get-location-filename(Location))
  . rec-msg(location-filename(Path?))
  . GetEditorType(Path, EditorType?)
  . StartEditor(Path, EditorType)
  . snd-msg(em-get-session-by-path(Path))
  .
  (
    rec-msg(em-session(Path, Sid?))
    . snd-msg(session(Pid, Sid))
  +
    rec-msg(em-no-such-session(Path))
    . snd-msg(no-such-session(Pid))
  )
endlet

process ShowOriginAction(EditorId : term) is
let
  Origin: term
in
  GetFocusOrigin(EditorId, Origin?)
  . if equal(Origin, no-origin) then
      DisplayMessage(EditorId, "No origin information available")
    else
      ShowAreaAction("Origin", Origin)
    fi
endlet
    
process ShowAreaAction(Message : str, Location : term) is
let
  Pid: int,
  Subject : term
in
  snd-msg(es-make-subject(Message, Location))
  . rec-msg(es-subject(Subject?))
  . create(ShowSubjectHandler(Subject), Pid?)
  . EditLocation(Pid, Location)
endlet

process ShowFeedbackLocation(Location : term) is
let
  Pid: int
in
  create(ShowErrorHandler(Location), Pid?)
  . EditLocation(Pid, Location)
endlet

process ShowSubjectHandler(Subject: term) is
let
  Pid: int,
  Sid: term
in
  Pid := process-id
  .
  (
    rec-msg(session(Pid, Sid?))
    . ShowSubject(Sid, Subject)
  +
    rec-msg(no-such-session(Pid))
  )
endlet

process ShowErrorHandler(Location: term) is
let
  Pid: int,
  Sid: term
in
  Pid := process-id
  .
  (
    rec-msg(session(Pid, Sid?))
    . ShowLocation(Sid, Location)
  +
    rec-msg(no-such-session(Pid))
  )
endlet

process CleanupEditTerm(Sid: term, Path : str) is
  subscribe(em-session-deleted(<term>))
  . rec-note(em-session-deleted(Sid))
  . snd-msg(ui-remove-feedback-summary("sglr", Path))

process GetFocusOrigin(EditorId : term, Origin: term?) is
let
  Cursor : term
in
  snd-msg(se-get-cursor(EditorId))
  . rec-msg(se-cursor(EditorId, Cursor?))
  . snd-msg(pa-get-origin(Cursor))
  .
  (
    rec-msg(pa-origin(Origin?))
  +
    rec-msg(pa-no-origin)
    . Origin := no-origin
  )
endlet

