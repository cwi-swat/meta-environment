process CreateModuleAction(Filename : str) is
let
  Directory : str,
  Pid: int
in
  snd-msg(io-relative-to-absolute(["."]))
  . rec-msg(io-absolute-directories([Directory?]))
  . create(NewModuleContentHandler(), Pid?)
  . CreateModule(Pid, Directory, Filename, sdf)
endlet

process CheckSort(Tree : term, SortName : str, Result : term?) is
let
  ResultTree : term
in
  CheckTreeSort(Tree, SortName, ResultTree?)
  .
  if not-equal(ResultTree, error-tree) then
    Result := true
  else
    Result := false
  fi
endlet

process ApplyFunction(FuncName : str, SortName : str, Arguments : list, Tree : term?) is
  snd-msg(apply-function(FuncName, SortName, Arguments))
  . rec-msg(tree(Tree?))

process GetFocusOrigin(EditorId : term, Origin: term?) is
let
  Cursor : term
in
  snd-msg(se-get-cursor(EditorId))
  . rec-msg(se-cursor(EditorId, Cursor?))
  . snd-msg(pa-get-origin(Cursor))
  .
  (
    rec-msg(pa-origin(Origin?))
  +
    rec-msg(pa-no-origin)
    . Origin := no-origin
  )
endlet

process ShowOriginAction(EditorId : term) is
let
  Origin: term
in
  GetFocusOrigin(EditorId, Origin?)
  . if equal(Origin, no-origin) then
      DisplayMessage(EditorId, "No origin information available")
    else
      ShowAreaAction("Origin", Origin)
    fi
endlet
    
process DebugReduce(EditorId : term,
                    Modulename : str,
		    Tree : term,
		    ResultTree : term?) is
  /* TODO: changed reduce action to take an extra argument,
     that will break all currently existing scripts, so we
     leave it at this for the moment. In 1.6 this can be changed?
   */
  snd-msg(debugging(on))
  . ReduceTerm(Tree, Modulename, ResultTree?)
  . 
  if not-equal(ResultTree, error-tree) then
    snd-msg(promote-posinfo-to-origin(ResultTree))
    . rec-msg(promoted-posinfo-to-origin(ResultTree?))
    . AnnotateTree(ResultTree, "reduct.out", ResultTree?)
    . snd-msg(put-term-tree("reduct.out", ResultTree))
  else
    tau
  fi 
  . snd-msg(debugging(off)) 

process DebugReduceAction(EditorId : term) is
let
  Modulename : str,
  Tree : term,
  ResultTree : term,
  Direction : term,
  Available : bool
in
  GetTree(EditorId, Tree?, Available?)
  .
  if equal(Available, true) then
    GetActiveModule(EditorId, Modulename?)
    . DebugReduce(EditorId, Modulename, Tree, ResultTree?)
    . 
    if not-equal(ResultTree, error-tree) then
      ActivateEditorWithTree(ResultTree, Modulename, "reduct.out")
    else 
      tau
    fi
  else
    tau
  fi
endlet

process RunAsfTestsAction(Modulename : str) is
  snd-msg(run-asf-tests(Modulename))

process EditorRunAsfTestsAction(EditorId : term) is
let
  Modulename : str
in
  GetActiveModule(EditorId, Modulename?)
  . snd-msg(run-asf-tests(Modulename))
endlet

process DebugRunAsfTestsAction(Modulename : str) is
  snd-msg(debugging(on))
  . snd-msg(run-asf-tests(Modulename))

process MoveCursorLeftAction(EditorId : term) is
  MoveCursor(EditorId, left)

process MoveCursorRightAction(EditorId : term) is
  MoveCursor(EditorId, right)

process MoveCursorUpAction(EditorId : term) is
  MoveCursor(EditorId, up)

process MoveCursorDownAction(EditorId : term) is
  MoveCursor(EditorId, down)
  
process ExecuteAction(EditorId : term, Action : str,
                      Tree : term, ResultTree : term?) is
  snd-msg(gen-adapter-term-evaluate(EditorId, Action, Tree))
  . rec-msg(gen-adapter-term-result(EditorId, ResultTree?))

process CopyModuleAction(Modulename : str) is
let
  Path : str,
  Directory : str,
  Filename : str,
  Extension : str
in
  PromptForFileWithExtension("Copy module to", "", ".sdf", Path?)
  . SplitFileName(Path, Filename?, Directory?, Extension?)
  . CopySdfModule(Modulename, Directory, Filename)
  . CopyAsfModule(Modulename, Directory, Filename)
endlet

process DeleteModuleAction(Modulename : str) is
let
  Answer : term
in
  AskQuestion("Are you sure you want delete this module (from disk)?", Answer?)
  . if equal(Answer, cancel) then
      tau
    else
      if equal(Answer, yes) then
        DeleteModule(Modulename)
      else
        tau
      fi 
    fi
endlet

process ActionAddPosInfo(EditorId : term, Tree : term, ResultTree : term?) is
let
  Filename : str
in
  GetPath(EditorId, Filename?)
  . AnnotateTree(Tree, Filename, ResultTree?)
endlet

process RenameModuleAction(Modulename : str) is
let
  Directory : str,
  Filename : str,
  Extension : str,
  Path : str
in
  PromptForFileWithExtension("Rename module to", "", ".sdf", Path?)
  . SplitFileName(Path, Filename?, Directory?, Extension?)
  . RenameModule(Modulename, Directory, Filename)
endlet

process AsfSdfApiGenAction(Modulename : str) is
let
  Path : str
in
  PromptForFileWithExtension("Generate New Module", "", ".sdf", Path?)
  . snd-msg(asfsdfapigen(Modulename, Path))
  . rec-msg(asfsdfapigen-done)
endlet

process AskQuestion(Question : str, Answer : term?) is
  snd-msg(ask-question(Question))
  . rec-msg(ask-question-result(Answer?))

process CloseModuleAction(Modulename : str) is
let
  Answer     : term,
  Recursive  : bool
in
  AskQuestion("Do you want to recursively close the imported modules?", Answer?)
  . if equal(Answer, cancel) then
      tau
    else
      if equal(Answer, yes) then
        Recursive := true
      else
        Recursive := false
      fi 
      . CloseModule(Modulename, Recursive)
    fi
endlet

process ClearHistoryAction is
  snd-msg(clear-history)

process CompileModuleAction(Modulename : str) is
let
  Path : str
in
  PromptForFileWithExtension("Target C file", "", ".c", Path?)
  . snd-msg(compile-module(Modulename, Path))
  . rec-msg(compilation-ready(Modulename))
endlet

process ActivateEditor(Modulename : str, Filename : str, Tree : term) is
let
  FunSym : str,
  String : str
in
  FunSym := fun(Tree)
  .
  if equal(FunSym, "str") then
    String := first(args(Tree))
    . ActivateEditorWithString(String, Modulename, Filename)
  else
    ActivateEditorWithTree(Tree, Modulename, Filename)
  fi
endlet

process UnPackTree(Tree : term, UnpackedTree : term?) is
  snd-msg(io-unpack-term(Tree))
  . rec-msg(io-term(UnpackedTree?))

process PackTree(Tree : term, PackedTree : term?) is
  snd-msg(io-pack-term(Tree))
  . rec-msg(io-term(PackedTree?))

process EditorEditSyntaxAction(EditorId : term) is
let 
  Modulename : str
in
  GetActiveModule(EditorId, Modulename?)
  . EditSyntaxAction(Modulename)
endlet

process EditSyntaxAction(Modulename : str) is
let
  Path: str,
  Pid: int,
  Sid: term
in
  LocateFile(Modulename, sdf, Path?)
  . create(EditSyntax(Path), Pid?)
  . rec-msg(syntax-editor-started(Path, Sid?))
  . create(CleanupEditTerm(Sid), Pid?)
endlet

process EditorEditEquationsAction(EditorId : term) is
let 
  Modulename : str
in
  GetActiveModule(EditorId, Modulename?)
  . EditEquationsAction(Modulename)
endlet

process EditEquationsAction(Modulename : str) is
let
  Path: str,
  SdfPath: str,
  AsfExt: str,
  Pid: int,
  Sid: term
in
  LocateFile(Modulename, sdf, SdfPath?)
  .
  if equal(SdfPath, "") then
    tau
  else
    snd-msg(file-extension-hook(asf))
    . rec-msg(file-extension-hook-result(AsfExt?))
    . ReplaceExtension(SdfPath, AsfExt, Path?)
    . snd-msg(ts-put-str-value("path-modulename", Path, Modulename))
    . create(EditEquations(Path), Pid?)
    . create(CleanupEditTerm(Sid), Pid?)
    . rec-msg(equations-editor-started(Path, Sid?))
  fi
endlet

process NewModuleAction is
let
  Extension : str,
  Directory : str,
  Pid: int,
  FileName : str,
  Path : str
in
  PromptForFileWithExtension("New Module", "", ".sdf", Path?)
  . SplitFileName(Path, FileName?, Directory?, Extension?)
  . create(NewModuleContentHandler(), Pid?)
  . CreateModule(Pid, Directory, FileName, sdf)
endlet

process OpenModuleAction is
let
  Extension : str,
  Directory : str,
  Path : str,
  Filename : str
in
  PromptForFileWithExtension("Open Module", "", ".sdf", Path?)
  .
  if equal(Path, "") then
    tau
  else
    SplitFileName(Path, Filename?, Directory?, Extension?)
    . BuildPath(Directory, Filename, Extension, Path?)
    . snd-note(start-modules-batch)
    . OpenModule(Path, sdf, Filename)
    . snd-note(end-modules-batch)
  fi
endlet

process DumpEquationsAction(Modulename : str) is
let
  Path : str
in
  PromptForFileWithExtension("Export Equations", "", ".eqs", Path?)
  . snd-msg(dump-equations-given-file(Modulename, Path))
  . rec-msg(equations-dumped)
endlet

process DumpParseTableAction(Modulename : str) is
let
  Path : str
in
  PromptForFileWithExtension("Export Term ParseTable", "", ".trm.tbl", Path?)
  . DumpParseTable(Modulename, Path, trm)
endlet

process EditorDumpParseTableAction(EditorId : term) is
let
  Path : str,
  Modulename : str
in
  GetActiveModule(EditorId, Modulename?)
  . PromptForFileWithExtension("Export Term ParseTable", "", ".trm.tbl", Path?)
  . DumpParseTable(Modulename, Path, trm)
endlet

process DumpEquationsParseTableAction(Modulename : str) is
let
  Path : str
in
  PromptForFileWithExtension("Export Equations ParseTable", "", ".eqs.tbl", Path?)
  . DumpParseTable(Modulename, Path, eqs)
endlet

process EditorDumpEquationsParseTableAction(EditorId : term) is
let
  Path : str,
  Modulename : str
in
  GetActiveModule(EditorId, Modulename?)
  . PromptForFileWithExtension("Export Equations ParseTable", "", ".eqs.tbl", Path?)
  . DumpParseTable(Modulename, Path, eqs)
endlet

process DumpSdfDefinitionAction(Modulename : str) is
let
  Path : str
in
  PromptForFileWithExtension("Export SDF Definition", "", ".def", Path?)
  . snd-msg(dump-sdf-definition(Modulename, Path))
  . rec-msg(sdf-definition-dumped)
endlet

process PrettyPrint(EditorId : term,
                    Modulename : str, 
		    Tree : term, 
		    RTree : term?) is
let
  Filename : str
in
  PrettyPrintTerm(Modulename, Tree, RTree?)
  .
  if not-equal(RTree, error-tree) then
    GetPath(EditorId, Filename?)
    . AnnotateTree(RTree, Filename, RTree?)
  else
    tau
  fi
endlet

process PrettyPrintAction(EditorId : term) is
let
  Modulename : str,
  Tree : term,
  RTree : term,
  Available : bool
in
  GetTree(EditorId, Tree?, Available?)
  .
  if equal(Available, true) then
    GetActiveModule(EditorId, Modulename?)
    . PrettyPrint(EditorId, Modulename, Tree, RTree?)
    . 
    if not-equal(RTree, error-tree) then
      ReplaceFocus(EditorId, RTree)
    else 
      tau
    fi
  else
    tau
  fi
endlet

process DisplayMessage(EditorId : term, Message : str) is
  snd-msg(te-display-message(EditorId, Message))

process ShowAreaAction(Message : str, Location : term) is
let
  Pid: int,
  Subject : term
in
  snd-msg(es-make-subject(Message, Location))
  . rec-msg(es-subject(Subject?))
  . create(ShowSubjectHandler(Subject), Pid?)
  . EditLocation(Pid, Location)
endlet

process ShowFeedbackLocation(Location : term) is
let
  Pid: int
in
  create(ShowErrorHandler(Location), Pid?)
  . EditLocation(Pid, Location)
endlet

process SaveTermStoreAction is
let
  FileName : str
in
  PromptForFileWithExtension("Save Term Store", "", ".termstore", FileName?)
  . SaveTermStore(FileName)
endlet


process ReadTermStoreAction is
let
  FileName : str
in
  PromptForFileWithExtension("Read Term Store", "", ".termstore", FileName?)
  . CloseAll
  . InitializeTermStore(FileName)
endlet

process ExitAction is
  shutdown("")

process GetRoot(EditorId : term, Tree : term?) is
let
  Available : bool
in
  GetTree(EditorId, Tree?, Available?)
  .
  if equal(Available, true) then
    tau
  else
    Tree := no-tree
  fi
endlet

process SaveTermStore(Path : str) is
let
  EditorId : term,
  Error: term
in
  (
    snd-msg(register-termstore-name(Path))
    . rec-msg(termstore-name-registered)
    . snd-msg(save-termstore)
    .
    (
      rec-msg(saved)
    +
      rec-msg(not-saved(Error?))
      . snd-note(ui-status(errorf("Saving failed: %t", [Error])))
    )
  )
endlet

process SetRoot(EditorId : term, Tree : term) is
  ReplaceFocus(EditorId, Tree)
  
process EqualTrees(Tree1 : term, Tree2 : term, Result : term?) is
let
  Value : term
in
  snd-msg(equal-trees(Tree1, Tree2))
  .  rec-msg(Value?)
  . 
  if equal(Value, quote(true)) then
    Result := true
  else
    Result := false
  fi
endlet
    
process GetActiveModule(EditorId : term, ModuleName : str?) is
  snd-msg(em-get-modulename(EditorId))
  .
  (
    rec-msg(em-modulename(EditorId, ModuleName?))
  +
    rec-msg(em-no-such-session(EditorId)) 
    . printf("FIX ME: PushActiveModule: No such session, sending dummy modulename\n")
    . ModuleName := "basic/Whitespace"
  +
    rec-msg(em-session-not-bound(EditorId))
    . printf("FIX ME: PushActiveModule: Session not bound, sending dummy modulename\n")
    . ModuleName := "basic/Whitespace"
  )

process PrintModuleAction(Modulename : str) is
let
  Path : str
in
  PromptForFileWithExtension("Module Text (ASF+SDF)", "", ".txt", Path?)
  . snd-msg(print-module(Modulename, Path))
  . rec-msg(module-printed(Modulename))
endlet
 
process PromptForFile(Title : str, Path : str, Modulename : str, Filename : str?) is
let
  Extension : str
in
  snd-msg(get-modulename-extension(Modulename))
  .
  (
    rec-msg(modulename-extension(Modulename, Extension?))
  +
    rec-msg(no-modulename-extension(Modulename))
    . snd-msg(file-extension-hook(trm))
    . rec-msg(file-extension-hook-result(Extension?))
  )
  . snd-msg(ask-for-file(Title, Path, Extension))
  . rec-msg(ask-for-file-result(Filename?))
endlet

process PromptForFileWithExtension(String : str, 
                                   Path : str, 
				   Extension : str, 
				   Filename : str?) is
  snd-msg(ask-for-file(String, Path, Extension))
  . rec-msg(ask-for-file-result(Filename?))

process Reduce(EditorId : term, Modulename : str, Tree : term, RTree : term?) is
  snd-msg(debugging(off)) 
  . ReduceTerm(Tree, Modulename, RTree?)
  .
  if not-equal(RTree, error-tree) then
    snd-msg(promote-posinfo-to-origin(RTree))
    . rec-msg(promoted-posinfo-to-origin(RTree?))
    . AnnotateTree(RTree, "reduct.out", RTree?)
    . snd-msg(put-term-tree("reduct.out", RTree))
  else
    tau
  fi

process ReduceAction(EditorId : term) is
let
  Modulename : str,
  Tree : term,
  RTree : term,
  Available : bool
in
  GetTree(EditorId, Tree?, Available?)
  .
  if equal(Available, true) then
    GetActiveModule(EditorId, Modulename?)
    . Reduce(EditorId, Modulename, Tree, RTree?)
    . 
    if not-equal(RTree, error-tree) then
      ActivateEditorWithTree(RTree, Modulename, "reduct.out")
    else 
      tau
    fi
  else
    tau
  fi
endlet

process ShowTreeAction(EditorId : term) is
let
  Modulename : str,
  Tree : term
in
  GetActiveModule(EditorId, Modulename?)
  . GetFocus(EditorId, Tree?)
  .
  if not-equal(Tree, no-tree) then
    ShowTree(Modulename, Tree, false)
  else
    tau
  fi
endlet

process ShowFullTreeAction(EditorId : term) is
let
  Modulename : str,
  Tree : term
in
  GetActiveModule(EditorId, Modulename?)
  . GetFocus(EditorId, Tree?)
  .
  if not-equal(Tree, no-tree) then
    ShowTree(Modulename, Tree, true)
  else
    tau
  fi
endlet

process CleanupEditTerm(Sid: term) is
let
  Path: str
in
  subscribe(em-session-deleted(<term>))
  . rec-note(em-session-deleted(Sid))
  . snd-msg(ui-remove-feedback-summary("sglr", "sid(42)"))
endlet

process ActionEditTerm(Filename : str, Modulename : str) is
let
  Sid: term,
  Pid: int,
  ErrorMessage : str
in
  create(EditTerm(Filename, Modulename), Pid?)
  .
  (
    rec-msg(term-editor-started(Filename, Modulename, Sid?))
    . create(CleanupEditTerm(Sid), Pid?)
  +
    rec-msg(term-editor-not-started(Filename, Modulename, ErrorMessage?))
    . Error(ErrorMessage, [])
  )
endlet

process EditorEditTermAction(EditorId : term) is
let
  Modulename : str
in
  GetActiveModule(EditorId, Modulename?)
  . EditTermAction(Modulename)
endlet

process EditTermAction(Modulename : str) is
let
  Filename : str
in
  PromptForFile("Edit Term", "", Modulename, Filename?) 
  . ActionEditTerm(Filename, Modulename)
endlet

process SplitFileName(Path : str, 
                      FileName : str?,
		      Directory : str?, 
		      Extension : str?) is
  snd-msg(io-get-path-filename(Path))
  . rec-msg(io-filename(Path, FileName?))
  . snd-msg(io-get-path-directory(Path))
  . rec-msg(io-directory(Path, Directory?))
  . snd-msg(io-get-path-extension(Path))
  . rec-msg(io-extension(Path, Extension?))

process UnParseTerm(Tree: term, Text: str?) is
  snd-msg(unparse(Tree))
  . rec-msg(unparsed-text(Text?))

process ParseErrorToSummary(ParseError:term, Sid: term, Summary:term?) is
  snd-msg(es-make-summary("sglr", "sid(42)", [ParseError]))
  . rec-msg(es-summary(Summary?))

process GetTree(Sid: term, Tree: term?, Available: bool?) is
let
  Modulename: str,
  Registered: bool
in
  GetActiveModule(Sid, Modulename?)
  . ParseTerm(Sid, Modulename)
  . IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    GetParsetree(Sid, Tree?)
    . Available := true
  else
    Available := false
  fi
endlet

process GetFocus(Sid: term, Tree: term?) is
let
  Registered: bool
in
  IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    snd-msg(se-get-cursor(Sid))
    .
    (
      rec-msg(se-cursor(Sid, Tree?))
    +
      rec-msg(se-no-cursor(Sid))
      . Tree := no-tree
    )
  else
    Tree := no-tree
  fi
endlet

process GetParsetree(Sid: term, Parsetree: term?) is
  snd-msg(se-get-parse-tree(Sid))
  . rec-msg(se-parse-tree(Sid, Parsetree?))

process ReplaceFocus(Sid: term, Tree: term) is
let
  Text: str,
  Filename: str,
  Error: str
in
  snd-msg(unparse(Tree))
  . rec-msg(unparsed-text(Text?))
  . GetPath(Sid, Filename?)
  . snd-msg(io-write-text-list(Filename, [Text]))
  .
  (
    rec-msg(io-file-written)
    . snd-msg(te-reread-contents(Sid))
  +
    rec-msg(io-file-not-written(Error?))
    . snd-note(ui-status(errorf("%s: %s", [Filename, Error])))
  )
  . snd-msg(se-update(Sid, Tree))
  . snd-msg(te-clear-focus(Sid))
endlet

process CheckTreeSort(Tree: term, Sort: str, RTree: term?) is
let
  TreeSort: str
in
/*
  snd-msg(se-check-tree-sort(Sort, Tree))
  .
  (
    rec-msg(se-wrong-sort(TreeSort?))
    . snd-note(ui-status(errorf("Top sort %s of tree does not match %s",
                                [TreeSort, Sort])))
    . RTree := error-tree
  +
    rec-msg(se-sort-ok)
    . RTree := Tree
  )
*/
  RTree := Tree
endlet

process ReduceTerm(Tree: term, Modulename: str, NormalForm: term?) is
let
  Summary: term,
  Equations: term,
  Id: int,
  Pid: int,
  Specification: term
in
  Id := process-id
  . OpenModules([Modulename], sdf)
  . snd-note(ui-status(stat(Id, "Retrieving equations")))
  . create(GetSpecification(Modulename), Pid?)
  .
  (
    rec-msg(specification(Specification?))
    . GetSpecificationEquations(Specification, Equations?)
    . snd-note(ui-status(endstat(Id)))
    . snd-msg(interpret-term-hook(Modulename, Equations, Tree))
    . rec-msg(interpret-term-hook-result(NormalForm?))
  +
    rec-msg(specification-incomplete(Summary?))
    . snd-note(ui-status(endstat(Id)))
    . snd-msg(ui-show-feedback-summary(Summary))
    . NormalForm := error-tree
  )
endlet

process ActivateEditorWithTree(Tree: term, Modulename: str, Filename: str) is
let
  Error: term,
  Pid: int,
  Sid: term,
  Text: str,
  ErrorMessage: str
in
  if not-equal(Tree, error-tree) then
    snd-msg(unparse(Tree))
    . rec-msg(unparsed-text(Text?))
    . snd-msg(io-write-text-list(Filename, [Text]))
    .
    (
      rec-msg(io-file-written)
      . create(EditTerm(Filename, Modulename), Pid?)
      .
      (
        rec-msg(term-editor-started(Filename, Modulename, Sid?))
      +
        rec-msg(term-editor-not-started(Filename, Modulename, ErrorMessage?))
        . Error(ErrorMessage, [])
      )
    +
      rec-msg(io-file-not-written(Error?))
      . snd-note(ui-status(errorf("%s: %t", [Filename, Error])))
    )
  fi
endlet

process ActivateEditorWithString(Text: str, Modulename: str, Filename: str) is
let
  Error: term,
  Pid: int,
  Sid: term,
  ErrorMessage: str
in
  snd-msg(io-write-text-list(Filename, [Text]))
  .
  (
    rec-msg(io-file-written)
    . create(EditTerm(Filename, Modulename), Pid?)
    .
    (
      rec-msg(term-editor-started(Filename, Modulename, Sid?))
    +
      rec-msg(term-editor-not-started(Filename, Modulename, ErrorMessage?))
      . Error(ErrorMessage, [])
    )
  +
    rec-msg(io-file-not-written(Error?))
    . snd-note(ui-status(errorf("%s: %t", [Filename, Error])))
  )
endlet

process AddImportAction(Modulename: str) is
let
  Id: int,
  Import: str,
  Options: list
in
  Id := process-id
  . snd-msg(get-all-module-names)
  . rec-msg(all-module-names(Options?))
  . snd-msg(show-list-choice(Modulename, "Choose a module to import", Options))
  .
  (
    rec-msg(list-choice(Modulename, Import?))
    . snd-note(ui-status(statf(Id, "Adding import %s to %s",
                               [Import, Modulename])))
    . AddImport(Modulename, Import)
    . snd-note(ui-status(endstat(Id)))
  +
    rec-msg(cancel-list-choice(Modulename))
  )
endlet

process RemoveImportAction(Modulename: str) is
let
  Id: int,
  Import: str,
  Options: list
in
  Id := process-id
  . snd-msg(get-imported-modules(Modulename))
  . rec-msg(imported-modules(Options?))
  . snd-msg(show-list-choice(Modulename, "Choose an import to remove", Options))
  .
  (
    rec-msg(list-choice(Modulename, Import?))
    . snd-note(ui-status(statf(Id, "Removing import %s from %s",
                               [Import, Modulename])))
    . RemoveImport(Modulename, Import)
    . snd-note(ui-status(endstat(Id)))
  +
    rec-msg(cancel-list-choice(Modulename))
  )
endlet

process ShowSubjectHandler(Subject: term) is
let
  Pid: int,
  Sid: term
in
  Pid := process-id
  .
  (
    rec-msg(session(Pid, Sid?))
    . ShowSubject(Sid, Subject)
  +
    rec-msg(no-such-session(Pid))
  )
endlet

process ShowErrorHandler(Location: term) is
let
  Pid: int,
  Sid: term
in
  Pid := process-id
  .
  (
    rec-msg(session(Pid, Sid?))
    . ShowLocation(Sid, Location)
  +
    rec-msg(no-such-session(Pid))
  )
endlet

process EditLocation(Pid: int, Location: term) is
let
  EditorType: term,
  Path: str,
  Sid: term
in
  snd-msg(get-location-filename(Location))
  . rec-msg(location-filename(Path?))
  . GetEditorType(Path, EditorType?)
  . StartEditor(Path, EditorType)
  . snd-msg(em-get-session-by-path(Path))
  .
  (
    rec-msg(em-session(Path, Sid?))
    . snd-msg(session(Pid, Sid))
  +
    rec-msg(em-no-such-session(Path))
    . snd-msg(no-such-session(Pid))
  )
endlet

process NewModuleContentHandler is
let
  ModuleId: str,
  Pid: int
in
  Pid := process-id
  .
  (
    rec-msg(get-module-contents(Pid, ModuleId?))
    . snd-msg(module-contents(Pid, ["module ", ModuleId, "\n"]))
  +
    rec-msg(cancel-content-handler(Pid))
  )
endlet

process MoveCursor(Sid: term, Direction: term) is
let
  Registered: bool
in
  IsStructureEditorRegistered(Sid, Registered?)
  .
  if equal(Registered, true) then
    snd-msg(se-move-cursor(Sid, Direction))
    . SynchronizeFocus(Sid)
  else
    tau
  fi
endlet
