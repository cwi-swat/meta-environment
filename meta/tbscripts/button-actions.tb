/* This file contains the implementation of a small stack language.
 *
 * The stack operations are retrieved from the configuration manager,
 * then for each primitive Meta-Environment operation in the button
 * language there is a handler. Arguments are popped of the stack before
 * calling Meta-Environment functionality, the result is sometimes pushed
 * back on the stack. 
 *
 * The interpreter stops when all actions are performed or an error has
 * occurred.
 */

process ButtonActionReceiver is
let
  ButtonName : list,
  EditorType : str,
  ModuleName : str,
  Actions    : list,
  EditorId   : term,
  Argument   : term
in
  (
    (
    rec-msg(extra-button-action(ButtonName?, EditorType?, ModuleName?,EditorId?)) .
    Argument := none
    +
    rec-msg(extra-button-action(ButtonName?, Argument?, EditorType?, ModuleName?,
                                EditorId?))
    ) .
    snd-msg(get-button-actions(ButtonName,EditorType,ModuleName)).
    rec-msg(button-actions(ButtonName,EditorType,ModuleName,Actions?)).
    PerformButtonActions(EditorId, Argument, Actions) 
  )* delta
endlet

process PerformButtonActions(EditorId : term, StackTop : term, Actions : list) is
let
  ButtonActions : list,
  ButtonAction  : term,
  FunName       : str,
  Stack         : list
in
  if equal(StackTop,none) then
    Stack := [] 
  else
    Stack := [StackTop]
  fi .
  ButtonActions := quote(Actions) .
  (
    if not-equal(ButtonActions, []) then
      ButtonAction := first(ButtonActions) .
      ButtonActions := next(ButtonActions) .
      FunName := fun(ButtonAction) .
      if equal(FunName, "if-equal") then
        IfEqual(ButtonAction, Stack, ButtonActions, Stack?, ButtonActions?)
      else
        snd-msg(ButtonAction, Stack, EditorId) .
        (
          rec-msg(stack(Stack?), EditorId)
        +
          rec-msg(empty-stack, EditorId) .
          ButtonActions := []
        +
          rec-msg(error-stack, EditorId) .
          ButtonActions := [].
          snd-note(ui-status(
            errorf("An error occurred while processing the action: %t",
                   [ButtonAction])))
        )
      fi
    fi
  )*
  if equal(ButtonActions, []) then
    tau
  fi
endlet

process StackPopTerm(Stack : list, NewStack : list?, Top : term?) is
  Top := first(Stack).
  NewStack := next(Stack)

process StackPopString(Stack : list, NewStack : list?, Top : str?) is
let
  TopTerm : term
in
  StackPopTerm(Stack,NewStack?,TopTerm?).
  Top := first(args(TopTerm))
endlet

process StackPushTerm(Stack : list, NewStack : list?, Top : term) is
  NewStack := join(Top, Stack)

process StackPushString(Stack : list, NewStack : list?, Top : str) is
  StackPushTerm(Stack,NewStack?,quote(str(Top)))
 
process StackPushInt(Stack : list, NewStack : list?, Top : int) is
  StackPushTerm(Stack,NewStack?, quote(int(Top)))

process StackPushFile(Stack : list, NewStack : list?, Top : str) is
  StackPushTerm(Stack,NewStack?, quote(file(Top)))
 
process StackPushPath(Stack : list, NewStack : list?, Top : str) is
  StackPushTerm(Stack,NewStack?, quote(path(Top)))

process ReturnSuccess(EditorId : term, Stack : list) is
  snd-msg(stack(Stack), EditorId)

process ReturnFailed(EditorId : term, Stack : list) is
  snd-msg(error-stack, EditorId)

process ReturnAbort(EditorId : term, Stack : list) is
  snd-msg(empty-stack, EditorId)

process ButtonActionExecutor is
let
  ModuleName : str,
  ArgList    : list,
  Stack      : list,
  EditorId   : term,
  EditorId2  : term,
  STree      : term,
  SList	     : list,
  RTree      : term,
  Error      : term,
  Trees      : list,
  ButtonName : str,
  SortName   : str,
  FilePath   : str,
  NewModName : str,
  FileName   : str,
  EditorName : str,
  FuncName   : str,
  FunSym     : str,
  String     : str,
  NrOfArgs   : int,
  Location   : int,
  Integer    : int,
  Action       : str,
  OutStr       : str,
  InStr        : str,
  Name : str,
  Path : str,
  Tree : term,
  Text : str,
  TimeStamp : int
in
   (
      rec-msg(apply(FuncName?, SortName?, NrOfArgs?), Stack?, EditorId?) .
      ArgList := [] .
      (
        if greater(NrOfArgs, 0) then
          StackPopTerm(Stack,Stack?,STree?).
          NrOfArgs := sub(NrOfArgs, 1) .
          ArgList := join(ArgList, STree)
        fi 
      ) *
      if equal(NrOfArgs, 0) then
        tau
      fi .
      snd-msg(apply-function(FuncName, SortName, ArgList)) .
      rec-msg(tree(RTree?)) .
      if not-equal(RTree, error-tree) then
        StackPushTerm(Stack,Stack?,RTree).
        ReturnSuccess(EditorId,Stack)
      else
        ReturnFailed(EditorId, Stack)
      fi
      +
      rec-msg(activate(Action?), Stack?, EditorId?) .
      snd-msg(gen-adapter-activate(EditorId, Action)).
      rec-msg(gen-adapter-result(EditorId, OutStr?)).
      if not-equal(OutStr, "") then
        StackPushString(Stack,Stack?,OutStr)
      else
        tau
      fi.
      ReturnSuccess(EditorId,Stack)
    +
      rec-msg(activate-given-tree(Action?), Stack?, EditorId?) .
      StackPopTerm(Stack,Stack?,STree?).
      FunSym := fun(STree) .
      if not-equal(FunSym, "str") then
        snd-msg(gen-adapter-term-to-string-evaluate(EditorId,Action,STree)).
        rec-msg(gen-adapter-term-to-string-result(EditorId,OutStr?))
      else
        InStr := first(args(STree)) .
        snd-msg(gen-adapter-string-to-string-evaluate(EditorId,Action,InStr)).
        rec-msg(gen-adapter-string-to-string-result(EditorId,OutStr?))
      fi.
      if not-equal(OutStr, "") then
          StackPushString(Stack,Stack?,OutStr)
      else
          tau
      fi.
      ReturnSuccess(EditorId,Stack)
    +
      rec-msg(execute-action(Action?), Stack?, EditorId?) .
      StackPopTerm(Stack,Stack?,STree?).
      snd-msg(gen-adapter-term-evaluate(EditorId,Action, STree)).
      rec-msg(gen-adapter-term-result(EditorId,RTree?)).
      if not-equal(RTree, error-tree) then
        StackPushTerm(Stack,Stack?,RTree).
        ReturnSuccess(EditorId,Stack)
      else
        ReturnFailed(EditorId,Stack)
      fi
    +
    rec-msg(move-left, Stack?, EditorId?).
    snd-msg(move-focus(EditorId,"Left")) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(move-right, Stack?, EditorId?).
    snd-msg(move-focus(EditorId,"Right")) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(move-up, Stack?, EditorId?).
    snd-msg(move-focus(EditorId,"Up")) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(move-down, Stack?, EditorId?).
    snd-msg(move-focus(EditorId,"Down")) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(parse-action, Stack?, EditorId?) .
    StackPopString(Stack,Stack?,NewModName?) .
    ParseTerm(EditorId, NewModName) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(parse-syntax-action, Stack?, EditorId?).
    StackPopString(Stack,Stack?,NewModName?) .
    ParseSyntax(EditorId,NewModName).
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(parse-equations-action, Stack?, EditorId?).
    StackPopString(Stack,Stack?,NewModName?) .
    ParseEquations(EditorId,NewModName).
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(get-root, Stack?, EditorId?) .
    GetTree(EditorId, ModuleName, RTree?) .
    if not-equal(RTree, error-tree) then
      StackPushTerm(Stack,Stack?,RTree).
      ReturnSuccess(EditorId,Stack)
    else
      ReturnFailed(EditorId,Stack)
    fi
      +
        rec-msg(set-root, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
        ReplaceRoot(EditorId, STree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(get-focus, Stack?, EditorId?) .
        GetFocus(EditorId, RTree?) .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnFailed(EditorId,Stack)
        fi
      +
        rec-msg(set-focus, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?).
        ReplaceFocus(EditorId, STree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(check-sort(SortName?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?).
        CheckTreeSort(STree, SortName, RTree?) .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnAbort(EditorId,Stack)
        fi
      +
        rec-msg(reduce, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,NewModName?) .
        StackPopTerm(Stack,Stack?,STree?) .
        ReduceTerm(STree, NewModName, RTree?) .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnAbort(EditorId,Stack)
        fi
      +
        rec-msg(get-other-focus(NewModName?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?).
        FunSym := fun(STree) .
        if equal(FunSym, "path") then
          FilePath := first(args(STree)) .
          snd-msg(check-editor-id(FilePath, NewModName)) .
          (
            rec-msg(existing-editor(FilePath?, EditorId2?)).
            GetFocus(EditorId2, RTree?) .
            if not-equal(RTree, error-tree) then
              StackPushTerm(Stack,Stack?,RTree) .
              ReturnSuccess(EditorId,Stack)
            else
              snd-note(ui-status(errorf("please set a focus %s", 
                                        [FilePath]))) .
              ReturnAbort(EditorId,Stack)
            fi
          +
            rec-msg(non-existing-editor(FilePath?)).
            snd-note(ui-status(errorf("editor for %s not active", 
                                      [FilePath]))) .
            ReturnAbort(EditorId,Stack)
          )
        else
          ReturnFailed(EditorId,Stack)
        fi
      +
        rec-msg(push-editor-name, Stack?, EditorId?) .
        snd-msg(get-editor-name(EditorId)) .
        rec-msg(editor-name(FileName?)) .
        StackPushString(Stack,Stack?,FileName) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(activate-editor, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,NewModName?) .
        StackPopString(Stack,Stack?,FileName?) .
        StackPopTerm(Stack,Stack?,STree?) .
        FunSym := fun(STree) .
        if equal(FunSym, "str") then
          String := first(args(STree)) .
          ActivateEditorWithString(String, NewModName, FileName)
        else
          ActivateEditorWithTree(STree, NewModName, FileName) 
        fi .    
        ReturnSuccess(EditorId,Stack)
      + 
        rec-msg(send, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
        snd-msg(tree-send(STree)) .
        snd-msg(stack(Stack), EditorId?)
      +
        rec-msg(receive, Stack?, EditorId?) .
        rec-msg(tree-send(RTree?)) .
        StackPushTerm(Stack,Stack?,RTree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(parse(NewModName?, SortName?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
          FunSym := fun(STree) .
          if or(equal(FunSym, "file"), equal(FunSym, "path")) then
            FilePath := first(args(STree)) .
            GetTextFromFile(FilePath, String?) .
            ParseText(String, NewModName, SortName, RTree?, Error?) .
            ProcessParseError(NewModName, Error, "trm")
          else 
            if equal(FunSym, "str") then
              String := first(args(STree)) .
              ParseText(String, NewModName, SortName, RTree?, Error?) .
              ProcessParseError(NewModName, Error, "trm")
            else
              RTree := error-tree
            fi
          fi .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnAbort(EditorId,Stack)
        fi
      +
        rec-msg(get-argument(NrOfArgs?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
        StackPushTerm(Stack,Stack?,STree) .
        snd-msg(get-argument-given-number(STree, NrOfArgs)) .
        rec-msg(tree(RTree?)) .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnFailed(EditorId,Stack)
        fi
      +
        rec-msg(exists(FileName?), Stack?, EditorId?) .
        snd-msg(exists-file(FileName)) .
        (
          rec-msg(file-exists(FileName)) .
          ReturnSuccess(EditorId,Stack)
        +
          rec-msg(file-not-exists(FileName)) .
          snd-note(ui-status(errorf("%s does not exist", 
                                    [FileName]))) .
          ReturnAbort(EditorId,Stack)
        )
      +
        rec-msg(locate(FileName?), Stack?, EditorId?) .
        snd-msg(locate-file(FileName)) .
        (
          rec-msg(file-location(FileName, FilePath?)) .
          StackPushPath(Stack,Stack?,FilePath) .
          ReturnSuccess(EditorId,Stack)
        +
          rec-msg(file-not-exists(FileName)) .
          snd-note(ui-status(errorf("%s does not exist", 
                                    [FileName]))) .
          ReturnAbort(EditorId,Stack)
        )
      +
        rec-msg(push-active-module, Stack?, EditorId?) .
        subscribe(delete-editor(EditorId)) .
        snd-msg(get-editor-modulename(EditorId)) .
        (
          rec-msg(editor-modulename(EditorId,ModuleName?)) .
          StackPushString(Stack,Stack?,ModuleName) .
          ReturnSuccess(EditorId,Stack)
        +
          rec-note(delete-editor(EditorId)) .
          ReturnFailed(EditorId, Stack)
        )
      +
        rec-msg(push-modulename(String?), Stack?, EditorId?) .
        StackPushString(Stack,Stack?,String) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(push-filename(FileName?), Stack?, EditorId?) .
        StackPushFile(Stack,Stack?,FileName) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(push-string(String?), Stack?, EditorId?) .
        StackPushString(Stack,Stack?,String) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(push-integer(Integer?), Stack?, EditorId?) .
        StackPushInt(Stack,Stack?,Integer) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(message(String?), Stack?, EditorId?) .
        snd-note(ui-status(errorf("%s", [String]))) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(show-tree, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?).
        ShowTree(STree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(show-area(NewModName?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
        FileName := first(args(STree)) .
        snd-msg(edit-term-file(NewModName, FileName)) .
        rec-msg(editor-opened(NewModName, EditorId2?)).
        ParseTerm(EditorId2, NewModName) .
        snd-msg(set-focus-at-posinfo(EditorId2, STree)) .    
        ReturnSuccess(EditorId,Stack)        
      +
        rec-msg(show-list, Stack?, EditorId?) .
        StackPopTerm(Stack, Stack?, STree?) .
        SList := first(args(STree)) .
	snd-msg(update-list-view(SList)) .
        ReturnSuccess(EditorId,Stack)        
      +
        rec-msg(show-tree, Stack?, EditorId?) .
        StackPopTerm(Stack, Stack?, STree?) .
        ShowTree(STree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(save-tree(Name?, Path?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,Tree?) .
        FunSym := fun(Tree) .
        if not-equal(FunSym, "str") then
          snd-msg(save-tree(Name,Path,Tree)) .
          rec-msg(save-done(Name))
        else
          Text := first(args(Tree)) .
          snd-msg(save-text-file(Path,Text)).
          rec-msg(save-done(Path))
        fi .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(read-tree(Path?), Stack?, EditorId?) . 
        snd-msg(open-file(Path)).
        (
          rec-msg(opened-file(Name?,tree(Tree?),Path?,TimeStamp?)).
          StackPushTerm(Stack,Stack?,Tree) .
          ReturnSuccess(EditorId,Stack)
        +
          rec-msg(error-opening(Path?)).
          ReturnAbort(EditorId,Stack) /* This could be ReturnFailed as well */
        )
  ) * delta
endlet

process IfEqual(ButtonAction : term,
                Stack : list,
                ButtonActions : list,
                RStack : list?,
                RButtonActions : list?) is
let
  Tree1       : term,
  Tree2       : term,
  ThenActions : list,
  ElseActions : list,
  IStack      : list
in
  Tree1 := first(Stack) .
  IStack := next(Stack) .
  Tree2 := first(IStack) .
  IStack := next(IStack) .
  snd-msg(equal-trees(Tree1, Tree2)) .
  (
    rec-msg(true) .
    ThenActions := first(args(ButtonAction)) .
    RButtonActions := join(ThenActions, ButtonActions)
  +
    rec-msg(false) .
    ElseActions := first(next(args(ButtonAction))) .
    RButtonActions := join(ElseActions, ButtonActions)
  ) .
  RStack := IStack
endlet

/****************************************************/
/* below here are implementations of button actions */
/****************************************************/

process ShowTree(Tree: term) is
let
  Graph : term,
  Id : int
in
  Id := process-id.
  snd-note(ui-status(stat(Id,"Computing graph layout..."))) .
  snd-msg(tree2graph(Tree)) .
  rec-msg(graph(Graph?)) .
  snd-msg(display-graph("parsetree", Graph)).
  snd-note(ui-status(endstat(Id)))
endlet

process ParseTerm(EditorId: term, ModuleName: str) is
let
  Focus  : term
in
  InvalidateEditor(EditorId).
  snd-msg(parse-focusses(EditorId, trm(ModuleName))) .
  (
    rec-msg(parse-ok(trm(ModuleName))) .
    snd-note(clear-focus(EditorId))
  +
    rec-msg(parse-failed(trm(ModuleName), Focus?))
  )
endlet

process GetTextFromFile(FileName: str, Text: str?) is
let
  Name      : str,
  TimeStamp : term, 
  Path      : str
in
  snd-msg(open-file(FileName)).
  (
    rec-msg(opened-file(Name?, text(Text?), Path?, TimeStamp?))
  +
    rec-msg(error-opening(Name?)) .
    Text := error-text
  )
endlet

process ParseText(Text: str, ModuleName: str, Nonterminal: str, 
                  Tree: term?, ParseError: term?) is
let
  Id         : term,
  ErrList    : list,
  ErrContent : term,
  ModuleId   : term
in
  Id := process-id . 
  snd-msg(open-modules([ModuleName])) .
  rec-msg(finished-opening-modules) .
  ModuleId := quote(trm(ModuleName)) .
  ParseString(ModuleId, Nonterminal, Text, Tree?, ParseError?)
endlet
 
process ParseSyntax(EditorId : term, ModuleName : str) is
let
  Tree : term,
  Focus : term,
  Modules : list
in
      InvalidateEditor(EditorId).
      snd-msg(parse-focusses(EditorId, trm("Sdf2"))) .
      (
        rec-msg(parse-ok(trm("Sdf2"))) .
        snd-msg(get-tree(EditorId)) .
        (
          rec-msg(tree(Tree?)) .
          snd-msg(update-module-in-db(ModuleName, Tree, "Sdf2")).
          (
            rec-msg(extra-modules(Modules?)).
            snd-msg(open-modules(Modules)).
            rec-msg(finished-opening-modules) .
            snd-note(clear-focus(EditorId))
          +
            rec-msg(error-opening(ModuleName, name-inconsistent)).
            snd-msg(invalidate-sdf-in-db(ModuleName)).
            InvalidateEditor(EditorId).
            snd-note(ui-status(
              errorf("Changing the name of %s is not permitted.",[ModuleName])))
          )
        +
          rec-msg(no-tree) /* editor dissappeared */
        )
      +
        rec-msg(parse-failed(trm("Sdf2"), Focus?)) .
        snd-msg(invalidate-sdf-in-db(ModuleName))
      ) 
endlet

process ParseEquations(EditorId : term, ModuleName : str) is
let
  Tree : term,
  Focus : term
in
  InvalidateEditor(EditorId).
  snd-msg(parse-focusses(EditorId, eqs(ModuleName))) .
  (
    rec-msg(parse-ok(eqs(ModuleName))) .
    snd-msg(get-tree(EditorId)) .
    (
      rec-msg(tree(Tree?)) .
      snd-msg(postprocess-semantics-hook(Tree)).
      rec-msg(postprocess-semantics-hook-result(Tree?)).
      snd-msg(update-eqs-tree-in-db(ModuleName, tree(Tree))) .
      rec-msg(eqs-updated) .
      snd-note(clear-focus(EditorId))
    +
      rec-msg(no-tree)
    )
  +
    rec-msg(parse-failed(eqs(ModuleName), Focus?))
  )
endlet

process GetTree(EditorId: term, ModuleName: str, Tree: term?) is
let
  DirtyFoci  : term
in
  Tree := error-tree.
  snd-msg(get-dirty-focuses(EditorId)) .
  rec-msg(dirty-focuses(DirtyFoci?)) .
  if equal(DirtyFoci, []) then
    snd-msg(get-tree(EditorId)) .
    (
      rec-msg(tree(Tree?))
    +
      rec-msg(no-tree)
    )
  else
    ParseTerm(EditorId, ModuleName) .
    snd-msg(get-dirty-focuses(EditorId)) .
    rec-msg(dirty-focuses(DirtyFoci?)) . 
    if equal(DirtyFoci, []) then
      snd-msg(get-tree(EditorId)) .
      (
        rec-msg(tree(Tree?))
      +
        rec-msg(no-tree)
      )
    else 
      tau
    fi
  fi
endlet

process ReplaceRoot(EditorId: term, Tree: term) is
let
  TotalTree : term,
  Text      : str,
  Focus     : term,
  FileName  : str
in
  snd-msg(move-focus-to-root(EditorId)) .
  rec-msg(focus-moved(EditorId, Focus?)) .
  snd-msg(replace-focussed-tree(EditorId, Tree)) .
  rec-msg(focus(Focus?)) .
  snd-msg(get-tree(EditorId)) .
  (
    rec-msg(tree(TotalTree?)) .
    snd-msg(unparse(TotalTree)) .
    rec-msg(unparsed-text(Text?)) .
    snd-msg(get-editor-name(EditorId)) .
    rec-msg(editor-name(FileName?)) .
    snd-msg(save-text-file(FileName, Text)) .
    rec-msg(save-done(FileName)) .
    snd-note(reload-file(EditorId, FileName)) .
    snd-msg(move-focus-to-root(EditorId)) .
    rec-msg(focus-moved(EditorId, Focus?)) .
    snd-note(set-focus(EditorId, Focus))
  +
    rec-msg(no-tree)
  )
endlet


process GetFocus(EditorId: term, Tree: term?) is
  snd-msg(get-focussed-tree(EditorId)) .
  (
    rec-msg(tree(Tree?))
  +
    rec-msg(no-tree) .
    Tree := error-tree
  )

process ReplaceFocus(EditorId: term, Tree: term) is
let
  TotalTree : term,
  Text      : str,
  Focus     : term,
  FileName  : str
in
  snd-msg(replace-focussed-tree(EditorId, Tree)) .
  rec-msg(focus(Focus?)) .
  snd-msg(get-tree(EditorId)) .
  (
    rec-msg(tree(TotalTree?)) .
    snd-msg(unparse(TotalTree)) .
    rec-msg(unparsed-text(Text?)) .
    snd-msg(get-editor-name(EditorId)) .
    rec-msg(editor-name(FileName?)) .
    snd-msg(save-text-file(FileName, Text)) .
    rec-msg(save-done(FileName)) .
    snd-note(reload-file(EditorId, FileName)) .
    snd-note(set-focus(EditorId, Focus))
  +
    rec-msg(no-tree)
  )
endlet

process CheckTreeSort(Tree: term, Sort: str, RTree: term?) is
let 
  TreeSort : str 
in
  snd-msg(check-tree-sort(Sort, Tree)) .
  ( 
    rec-msg(wrong-sort(TreeSort?)) .
    snd-note(ui-status(errorf("Top sort %s of tree does not match %s", 
                              [TreeSort, Sort]))) .
    RTree := error-tree
  +
    rec-msg(sort-ok) .
    RTree := Tree
  )
endlet

process ReduceTerm(Tree: term, ModuleName: str, NormalForm: term?) is
let
  Id          : int,
  ErrList     : list,
  Equations   : term
in
  Id := process-id .
  snd-msg(open-modules([ModuleName])) .
  rec-msg(finished-opening-modules) .
  snd-note(ui-status(stat(Id, "Retrieving equations"))) .
  snd-msg(process-eqs(ModuleName)) .
  rec-msg(eqs-processed(ModuleName)) .
  snd-msg(get-all-equations(ModuleName)) .
  (
    rec-msg(all-equations(Equations?)) .
    snd-note(ui-status(endstat(Id))).
    snd-msg(interpret-term-hook(ModuleName, Equations, Tree)).
    rec-msg(interpret-term-hook-result(NormalForm?))
  +
    rec-msg(equations-incomplete) .
    NormalForm := error-tree .
    snd-note(ui-status(endstat(Id))) .
    snd-note(ui-status(errorf("Equations incomplete for %s.asf", [ModuleName])))
  )
endlet

process ActivateEditorWithTree(Tree: term, ModuleName: str, FileName: str) is
let
  Text        : str,
  EditorId    : term,
  NewModuleName : str
in
  if not-equal(Tree, error-tree) then
    snd-msg(unparse(Tree)) . 
    rec-msg(unparsed-text(Text?)) .
    snd-msg(save-text-file(FileName, Text)) .
    rec-msg(save-done(FileName)) .
    snd-msg(edit-term-file-with-tree(ModuleName, FileName, Tree)) .
    rec-msg(editor-opened(ModuleName, EditorId?))
  fi
endlet

process ActivateEditorWithString(Text: str, ModuleName: str, FileName: str) is
let
  EditorId    : term,
  NewModuleName : str
in
  snd-msg(save-text-file(FileName, Text)) .
  rec-msg(save-done(FileName)) .
  snd-msg(edit-term-file(ModuleName, FileName)) .
  rec-msg(editor-opened(ModuleName, EditorId?))
endlet
