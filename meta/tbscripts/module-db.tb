#include <module-manager.tb>
#include <sdf-modules.idef>
#include <sdf-renaming.idef>
#include <term-store.idef>
#define DEBUG printf("FILE: %s LINE: %d\n", __FILE__, __LINE__)

#define POSINFO_DEPTH 4

process ModuleDB is
let
  DependingModules: list,
  EqsText: str,
  EqsTree: term,
  ErrorMsg: str,
  Extension: str,
  Filename: str,
  LocalText: str,
  ModuleId: term,
  ModuleIds: list,
  Modulename: str,
  Modules: list,
  Name: str,
  NewName: str,
  OldName: str,
  Pairs: list,
  Path: str,
  Syntax: term,
  SyntaxText: str,
  SyntaxTree: term,
  Table: term,
  Tablename: str,
  TermTree: term,
  Type: term
in
  MDB-InitializeModuleDb()
  . snd-msg(termstore-initialized)
  . MDB-InitializeFileExtensions()
  .
  (
    rec-msg(update-eqs-tree-in-db(ModuleId?, tree(EqsTree?)))
    . GetModulePath(ModuleId, ASF_NAMESPACE, Filename?)
    . snd-msg(add-posinfo-to-depth(Filename, EqsTree, POSINFO_DEPTH))
    . rec-msg(tree-with-pos-info(EqsTree?))
    . snd-msg(ts-put-term-value("asf-tree", ModuleId, EqsTree))
    . EqsTree := UNDEFINED
    . snd-msg(eqs-updated)
  +
    rec-msg(put-term-tree(Filename?, TermTree?))
    . snd-msg(ts-put-term-value("term-tree", Filename, TermTree))
  +
    rec-msg(get-term-tree(Filename?))
    . snd-msg(ts-get-term-value("term-tree", Filename))
    .
    (
      rec-msg(ts-value("term-tree", Filename, TermTree?))
      . snd-msg(term-tree(Filename, TermTree))
      . TermTree := UNDEFINED
    +
      rec-msg(ts-no-value("term-tree", Filename))
      . snd-msg(no-term-tree(Filename))
    )
  )
  *
  delta
endlet

/* Used by ModuleDB */
process MDB-InitializeModuleDb is
  snd-msg(ts-add-table("extensions", "str"))
  . snd-msg(ts-add-table("sdf-tree", "term"))
  . snd-msg(ts-add-table("sdf-text", "str"))
  . snd-msg(ts-add-table("asf-tree", "term"))
  . snd-msg(ts-add-table("asf-text", "str"))
  . snd-msg(ts-add-table("term-tree", "term"))

/* Used by ModuleDB */
process MDB-InitializeFileExtensions is
let
  SyntaxExt: str,
  RulesExt: str,
  TermExt: str
in
  snd-msg(get-file-extensions)
  . rec-msg(set-file-extensions(syntax(SyntaxExt?), rules(RulesExt?),
                                term(TermExt?)))
  . snd-msg(ts-put-str-value("extensions", "syntax", SyntaxExt))
  . snd-msg(ts-put-str-value("extensions", "equations", RulesExt))
  . snd-msg(ts-put-str-value("extensions", "term", TermExt))
endlet

/* Used in process-eqs.tb */
process MDB-AddEquationsPosInfo(ModuleId: term, In: term, Out: term?) is
  MDB-AddPosInfo(ModuleId, asf, In, Out?)

/* Used by MDB-AddEquationsPosInfo */
process MDB-AddPosInfo(ModuleId: term, Type: term, In: term, Out: term?) is
let
  AsfExt: str,
  AsfPath: str,
  SdfPath: str
in
  printf("Another codeclone of EditEquationsAction\n").
  GetModulePath(ModuleId, SDF_NAMESPACE, SdfPath?)
  .  
  if equal(SdfPath, "") then
    snd-msg(no-equations(ModuleId))
  else
    snd-msg(file-extension-hook(asf))
    . rec-msg(file-extension-hook-result(AsfExt?))
    . ReplaceExtension(SdfPath, AsfExt, AsfPath?)
   . AnnotateTree(In, AsfPath, Out?)
  fi
endlet

process GetModules(ModuleIds: list, Modules: list?) is
  TODO("remove database dependency here by reusing parse scenario, which by accident caches for efficiency")
  .
  snd-msg(ts-get-values("sdf-tree", ModuleIds))
  .
  (
    rec-msg(ts-values("sdf-tree", ModuleIds, Modules?))
  +
    rec-msg(ts-no-values("sdf-tree", ModuleIds))
    . Modules := []
  )

process GetSyntaxDefinition(ModuleId: term, Syntax: term?) is
let
  ModuleIds: list,
  Modules: list
in
  MM-GetAllModuleDependencies(ModuleId, ModuleIds?)
  . GetModules(ModuleIds, Modules?)
  . 
  if equal(Modules, []) then
    Syntax := UNDEFINED
  else
    snd-msg(sm-make-sdf-definition(Modules))
    .
    (
      rec-msg(sm-sdf-definition(Syntax?))
    +
      rec-msg(sm-no-sdf-definition)
      . Syntax := UNDEFINED
    )
  fi
endlet
