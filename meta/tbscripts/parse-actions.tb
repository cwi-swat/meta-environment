#include <asfsdf-module-actions.tb>

process UnParseTerm(Tree: term, Text: str?) is
  snd-msg(unparse(Tree))
  . rec-msg(unparsed-text(Text?))

process ParseErrorToSummary(ParseError:term, Sid: term, Summary:term?) is
let 
  Path : str
in
  snd-msg(em-get-path(Sid)) 
  .
  (
    rec-msg(em-path(Sid, Path?))
    . snd-msg(es-make-summary("sglr", Path, [ParseError]))
    . rec-msg(es-summary(Summary?))
  +
    rec-msg(no-such-session(Sid))
  )
endlet

process ParseAction(EditorId : term) is
let
  ModuleId : term
in
  GetModuleId(EditorId, ModuleId?)
  . ParseTerm(EditorId, ModuleId)
endlet

process ParseSyntaxAction(EditorId : term) is
let
  ParseSucceeded: bool,
  Pid : int,
  ModuleId : term
in
  ParseSyntax(EditorId, ParseSucceeded?)
  .
  if equal(ParseSucceeded, true) then
    GetModuleId(EditorId, ModuleId?)
    . create(CheckSyntaxSpecification(ModuleId), Pid?)
  else
    tau
  fi
endlet

process ParseEquationsAction(EditorId : term) is
let
  ModuleId : term
in
  GetModuleId(EditorId, ModuleId?)
  . ParseEquations(EditorId, ModuleId)
endlet

process ParseTerm(Sid: term, ModuleId: term) is
let
  Nonterminal: term,
  ParseError: term,
  Path: str,
  Pid: int,
  Summary: term,
  Table: term
in
  GetParseTable(ModuleId, trm, Table?)
  . snd-msg(other-top-sort-hook(trm))
  . rec-msg(other-top-sort-hook-result(sort(Nonterminal?)))
  . GetPath(Sid, Path?)
  . snd-msg(ui-remove-feedback-summary("sglr", Path))
  . create(ParseEditor(Sid, Table, Nonterminal), Pid?)
  .
  (
    rec-msg(parse-editor-ok(Sid))
    . snd-msg(te-clear-focus(Sid))
    . snd-msg(te-display-message(Sid, "Parse OK"))
  +
    rec-msg(parse-editor-failed(Sid, ParseError?))
    . ParseErrorToSummary(ParseError, Sid, Summary?)
    . snd-msg(ui-show-feedback-summary(Summary))
  )
endlet

process ParseSyntax(Sid: term, ParseSucceeded: bool?) is
let
  Id: int,
  ModuleId: term,
  ParseError: term,
  Path: str,
  Pid: int,
  Summary: term,
  Table: term,
  Error: term,
  AnnotatedTree: term,
  Sort: term,
  Tree: term,
  Type: term
in
  Id := process-id
  . GetModuleId(Sid, ModuleId?)
  . Type := sdf
  . snd-msg(get-parsetable(Type))
  .
  (
    rec-msg(parsetable(Type, Table?))
    . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", available)
    . snd-msg(syntax-top-sort-hook(Type))
    . rec-msg(syntax-top-sort-hook-result(sort(Sort?)))
    . GetModulePath(ModuleId, SDF_NAMESPACE, Path?)
    . snd-msg(ui-remove-feedback-summary("sglr", Path))
    . create(ParseEditor(Sid, Table, Sort), Pid?)
    .
    (
      rec-msg(parse-editor-ok(Sid))
      . ParseSucceeded := true
      . GetParsetree(Sid, Tree?)
      . AnnotateTree(Tree, Path, AnnotatedTree?)
      . SetModuleSyntaxTree(ModuleId, AnnotatedTree)
      . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", parsed)
    +
      rec-msg(parse-editor-failed(Sid, ParseError?))
      . ParseErrorToSummary(ParseError, Sid, Summary?)
      . snd-msg(ui-show-feedback-summary(Summary))
      . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", error)
    )
  +
    rec-msg(no-parsetable(Type, Error?))
    . Error("TODO fix the error No parse table: %t\n", [Error])
  )
  . snd-note(ui-status(endstat(Id)))
endlet


process ParseEquations(Sid: term, ModuleId: term) is
let
  Id: int,
  Modulename: str,
  Nonterminal: term,
  ParseError: term,
  Path: str,
  Pid: int,
  Summary: term,
  Table: term,
  Tree: term
in
  Id := process-id
  . GetParseTable(ModuleId, eqs, Table?)
  .
  if not-equal(Table, UNDEFINED) then
    MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", available)
    . snd-msg(get-rules-top-sort)
    . rec-msg(set-rules-top-sort(sort(Nonterminal?)))
    . GetPath(Sid, Path?)
    . snd-msg(ui-remove-feedback-summary("sglr", Path))
    . create(ParseEditor(Sid, Table, Nonterminal), Pid?)
    .
    (
      rec-msg(parse-editor-ok(Sid))
      . snd-msg(se-get-parse-tree(Sid))
      . rec-msg(se-parse-tree(Sid, Tree?))
      . TODO("replace by listener pattern")
      . MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
      . snd-msg(postprocess-semantics-hook(Modulename, Tree))
      . rec-msg(postprocess-semantics-hook-result(Modulename, Tree?))
      . snd-msg(update-eqs-tree-in-db(ModuleId, tree(Tree)))
      . rec-msg(eqs-updated)
      . snd-msg(te-clear-focus(Sid))
      . snd-msg(te-display-message(Sid, "Parse successful"))
      . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", parsed)
    +
      rec-msg(parse-editor-failed(Sid, ParseError?))
      . ParseErrorToSummary(ParseError, Sid, Summary?)
      . snd-msg(ui-show-feedback-summary(Summary))
      . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", error)
    )
  else
    tau
  fi
endlet


