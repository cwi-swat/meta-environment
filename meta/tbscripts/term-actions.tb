#ifndef __TERM_ACTIONS__
#define __TERM_ACTIONS__

#include <pretty-print-utils.tb>
#include <term-utils.tb>

process EqualTrees(Tree1 : term, Tree2 : term, Result : term?) is
let
  Value : term
in
  TODO("term-actions.tb bevat niet-action processes").
  snd-msg(equal-trees(Tree1, Tree2))
  .  rec-msg(tree-is-equal(Value?))
  . 
  if equal(Value, quote(true)) then
    Result := true
  else
    Result := false
  fi
endlet

process ActionAddPosInfo(EditorId : term, Tree : term, ResultTree : term?) is
let
  Filename : str
in
  GetPath(EditorId, Filename?)
  . AnnotateTree(Tree, Filename, ResultTree?)
endlet

process CheckSort(Tree : term, SortName : str, Result : term?) is
let
  ResultTree : term
in
  CheckTreeSort(Tree, SortName, ResultTree?)
  .
  if not-equal(ResultTree, error-tree) then
    Result := true
  else
    Result := false
  fi
endlet

process ApplyFunction(FuncName : str, SortName : str, Arguments : list, Tree : term?) is
  snd-msg(apply-function(FuncName, SortName, Arguments))
  . rec-msg(tree(Tree?))

process PrettyPrint(EditorId : term,
                    Modulename : str, 
		    Tree : term, 
		    RTree : term?) is
let
  Filename : str
in
  PrettyPrintTerm(Modulename, Tree, RTree?)
  .
  if not-equal(RTree, error-tree) then
    GetPath(EditorId, Filename?)
    . AnnotateTree(RTree, Filename, RTree?)
  else
    tau
  fi
endlet

process PrettyPrintAction(EditorId : term) is
let
  Modulename : str,
  Tree : term,
  RTree : term,
  Available : bool
in
  GetTree(EditorId, Tree?, Available?)
  .
  if equal(Available, true) then
    TODO("Modulename has to be ModuleId!!")
    . GetModuleId(EditorId, Modulename?)
    . PrettyPrint(EditorId, Modulename, Tree, RTree?)
    . 
    if not-equal(RTree, error-tree) then
      ReplaceFocus(EditorId, RTree)
    else 
      tau
    fi
  else tau
  fi
endlet

process ParseAction(EditorId : term) is

let
  ModuleId : term
in
  GetModuleId(EditorId, ModuleId?)
  . ParseTerm(EditorId, ModuleId)
endlet
#endif /*__TERM_ACTIONS__*/
