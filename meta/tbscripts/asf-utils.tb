#ifndef __ASF_UTILS__
#define __ASF_UTILS__

#define ASF_TREE_CACHE "asf-annotated-tree"

process OpenASFModule(ModuleId: term) is
let
  AsfExt: str,
  AsfPath: str,
  Editable: bool,
  LibraryModule: bool,
  Modulename: str,
  Path: str,
  Present: bool,
  Registered: bool,
  SdfPath: str
in
  MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
  . printf("Opening ASF Module for %t\n", Modulename)
  . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "name", Modulename)
  . GetModulePath(ModuleId, SDF_NAMESPACE, SdfPath?)
  . ReplaceExtension(SdfPath, ASF_EXTENSION, AsfPath?)
  . SetModulePath(ModuleId, ASF_NAMESPACE, AsfPath)
  . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", unknown)
  . snd-msg(io-exists-file(AsfPath))
  .
  (
    rec-msg(io-file-exists)
    . SetModulePath(ModuleId, ASF_NAMESPACE, AsfPath)
    . IsLibraryModule(ModuleId, LibraryModule?)
    . Editable := not(LibraryModule)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "editable", Editable)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", available)
    . printf("ASF module found for %t\n", Modulename)
  +
    rec-msg(io-file-not-exists)
    . printf("No ASF module found for %t\n", Modulename)
  )
endlet

process CheckASFModule(ModuleId: term) is
let
  Summary : term,
  Errors: list,
  Modulename: str,
  Tree: term
in
  GetASFParseTree(ModuleId, Tree?)
  .
  if not-equal(Tree, UNDEFINED) then
    snd-msg(check-asf(Tree))
    . rec-msg(messages(Errors?))
    . MM-GetAttribute(ModuleId, ASF_NAMESPACE, "name", Modulename?) 
    . snd-msg(ui-remove-feedback-summary("asf-checker", Modulename))
    . snd-msg(es-make-summary("asf-checker", Modulename, Errors))
    . rec-msg(es-summary(Summary?))
    . snd-msg(ui-show-feedback-summary(Summary))
  else
    TODO("no equations to check\n")
  fi
endlet

/* TODO: ensure cache is initialized before first call */
toolbus(InitCache(ASF_TREE_CACHE, ASF_NAMESPACE, edited))
toolbus(ClearCacheHandler(ASF_TREE_CACHE, SDF_NAMESPACE, "status", <term>,available))

process GetASFParseTree(ModuleId: term, Result: term?) is
let
  Id: int,
  ParseTable: term,
  Path: str,
  Pid: int,
  Text: str,
  Type: term,
  Tree: term,
  Annotated: term
in
  Id := process-id
  . GetCachedValue(ASF_TREE_CACHE, ModuleId, Tree?)
  . Tree := UNDEFINED
  .
  if equal(Tree, UNDEFINED) then
    Type := eqs
    . GetModulePath(ModuleId, ASF_NAMESPACE, Path?)
    . ReadFile(Path, Text?)
    .
    if not-equal(Text, "") then
      GetParseTable(ModuleId, Type, ParseTable?)
      . create(ASFParseTreeHandler(ModuleId, Path), Pid?)
      . ParseText(Pid, Text, ParseTable, ASF_TOPSORT)
      .
      (
        rec-msg(asf-parse-handler-done(Pid, ModuleId, Tree?))
        . AnnotateTree(Tree, Path, Annotated?) 
        . Result := Annotated
        . PutCachedValue(ASF_TREE_CACHE, ModuleId, Result)
	. MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", parsed)
      +
        rec-msg(asf-parse-handler-error(Pid))
        . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", error)
        . Result := UNDEFINED
      )
    else 
      Result := UNDEFINED
      . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", unknown)
      . TODO("valid error message\n")
    fi
  else
    tau
  fi 
endlet

process ASFParseTreeHandler(ModuleId: term, Path: str) is
let
  ErrorMessage: term,
  Nonterminal: term,
  ParseError: term,
  ParseResult: term,
  Pid: int,
  Summary: term,
  Table: term
in
  Pid := process-id
  .
  (
    (
      rec-msg(parse-tree(Pid, ParseResult?))
      . snd-msg(ui-remove-feedback-summary("sglr", Path))
    +
      rec-msg(parse-forest(Pid, ParseResult?, ErrorMessage?))
      . AddFilenameToParseError(ErrorMessage, Path, ParseError?)
      . snd-msg(es-make-summary("sglr", Path, [ParseError]))
      . rec-msg(es-summary(Summary?))
      . snd-msg(ui-remove-feedback-summary("sglr", Path))
      . snd-msg(ui-show-feedback-summary(Summary))
    )
    . snd-msg(asf-parse-handler-done(Pid, ModuleId, ParseResult))
  +
    rec-msg(parse-error(Pid, ErrorMessage?))
    . AddFilenameToParseError(ErrorMessage, Path, ParseError?)
    . snd-msg(es-make-summary("sglr", Path, [ParseError]))
    . rec-msg(es-summary(Summary?))
    . snd-msg(asf-parse-handler-error(Pid))
    . snd-msg(ui-remove-feedback-summary("sglr", Path))
    . snd-msg(ui-show-feedback-summary(Summary))
  )
endlet

process Compile-module is
let
  Equations: term,
  Error: str,
  Id: term,
  ModuleId: term,
  OutputFile: str,
  Pid: int,
  Specification: term
in
  Id := process-id
  .
  (
    rec-msg(compile-module(ModuleId?, OutputFile?))
    . snd-note(ui-status(start(Id, "Compile Module")))
    . create(GetSpecification(ModuleId), Pid?)
    .
    (
      rec-msg(specification(Specification?))
      . GetSpecificationEquations(Specification, Equations?)
      . snd-msg(compile-semantics-hook(ModuleId, OutputFile, Equations))
      . rec-msg(compile-semantics-hook-done(ModuleId))
    +
      rec-msg(specification-incomplete(Error?))
      . printf("CompileModule: %t\n", Error)
      . snd-note(ui-status(statf(Id, "Specification incomplete")))
    )
    . snd-msg(compilation-ready(ModuleId))
    . snd-note(ui-status(stop(Id)))
  )
  *
  delta
endlet

process DumpEquations is
let
  Equations: term,
  Error: term,
  Filename: str,
  Id: int,
  ModuleId: term,
  Path: str,
  Pid: int,
  SdfPath: str,
  Specification: term
in
  Id := process-id
  .
  (
    (
      rec-msg(dump-equations(ModuleId?))
      . Filename := ""
    +
      rec-msg(dump-equations-given-file(ModuleId?, Filename?))
    )
    . create(GetSpecification(ModuleId), Pid?)
    .
    (
      rec-msg(specification(Specification?))
      . GetSpecificationEquations(Specification, Equations?)
      .
      if equal(Filename, "") then
	GetModulePath(ModuleId, SDF_NAMESPACE, SdfPath?)
	. ReplaceExtension(SdfPath, ".eqs", Path?)
      else
        tau
      fi
      . snd-msg(io-unpack-and-write-term-in-baf(Filename, Equations))
      .
      (
        rec-msg(io-file-written)
      +
        rec-msg(io-file-not-written(Error?))
        . snd-note(ui-status(errorf("%s: %t", [Filename, Error])))
      )
    +
      rec-msg(specification-incomplete(Error?))
      . printf("DumpEquations: %t\n", Error)
    )
    . snd-note(ui-status(stop(Id)))
    . snd-msg(equations-dumped)
  )
  *
  delta
endlet

process DeleteModule(Modulename: str) is
let
  Changed: list,
  Id: int,
  Path: str,
  Extension: str,
  Status: term
in
  TODO("split into ASF and SDF responsabilities")
  . Id := process-id
  . snd-note(ui-status(statf(Id, "Deleting %s", [Modulename])))
  . snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(get-path-from-db(Modulename))
  .
  (
    rec-msg(path(Path?))
    . RemoveModuleFromDisk(Path, Modulename)
  +
    rec-msg(no-path)
  )
  . DeleteSessions(Modulename)
  . snd-msg(delete-module-from-db(Modulename))
  . rec-msg(changed-modules(Changed?))
  . SaveSdfModules(Changed, Status?)
  . snd-note(ui-status(endstat(Id)))
endlet

process RenameModule(Modulename: str, Directory: str, Filename: str) is
let
  Extension: str,
  Id: int,
  NewModule: str,
  Path: str
in
  TODO("split into ASF and SDF responsabilities")
  . Id := process-id
  . snd-note(ui-status(statf(Id, "Renaming %s", [Modulename])))
  . CopySdfModule(Modulename, Directory, Filename)
  . CopyAsfModule(Modulename, Directory, Filename)
  . snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Filename, Extension, Path?)
  /*. GetModuleForPath(Path, NewModule?)*/
  . RenameImports(Modulename, NewModule)
  . DeleteModule(Modulename)
  . snd-note(ui-status(endstat(Id)))
endlet

process CopyAsfModule(SrcModulename: str, Directory: str, Filename: str) is
let
  DestPath: str,
  Error: str,
  Extension: str,
  SrcPath: str
in
  LocateFile(SrcModulename, asf, SrcPath?)
  . snd-msg(io-exists-file(SrcPath))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(file-extension-hook(asf))
    . rec-msg(file-extension-hook-result(Extension?))
    . BuildPath(Directory, Filename, Extension, DestPath?)
    . snd-msg(io-exists-file(DestPath))
    .
    (
      rec-msg(io-file-exists)
      . Error("Refusing to overwrite existing file: %s", [DestPath])
    +
      rec-msg(io-file-not-exists)
      . snd-msg(io-copy-file(SrcPath, DestPath))
      .
      (
        rec-msg(io-file-copied(SrcPath, DestPath))
      +
        rec-msg(io-file-not-copied(SrcPath, DestPath, Error?))
        . Error("Unable to copy: %s", [Error])
      )
    )
  +
    rec-msg(io-file-not-exists)
  )
endlet

#ifdef DEAD 
process AddImport(Modulename: str, Import: str) is
let
  Depending: list,
  Status: term
in
  TODO("split asf and sdf")
  . DeleteSessions(Modulename)
  . GetDependingModules(Modulename, Depending?)
  . MDB-InvalidateModules(Depending, sdf)
  . AddImportInDB(Modulename, Import)
  . SaveAsfSdfModule(Modulename, Status?)
endlet

process RemoveImport(Modulename: str, Import: str) is
let
  Depending: list,
  Status: term
in
  TODO("split asf and sdf")
  .DeleteSessions(Modulename)
  . GetDependingModules(Modulename, Depending?)
  . MDB-InvalidateModules(Depending, sdf)
  . RemoveImportInDB(Modulename, Import)
  . SaveAsfSdfModule(Modulename, Status?)
endlet
#endif

process SaveAsfSdfModule(Modulename: str, Status: term?) is
  snd-msg(save-module(Modulename, asfsdf))
  . rec-msg(saved-module(Modulename, Status?))

process RemoveModuleFromDisk(Directory: str, Modulename: str) is
let
  Extension: str,
  Path: str
in
  snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Modulename, Extension, Path?)
  . RemoveFile(Path)
  . snd-msg(file-extension-hook(asf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Modulename, Extension, Path?)
  . snd-msg(io-exists-file(Path))
  .
  (
    rec-msg(io-file-exists)
    . RemoveFile(Path)
  +
    rec-msg(io-file-not-exists)
  )
endlet

process CheckEquationConsistency(Modulename: str, Path: str) is
let
  Filename: str,
  FileText: str,
  RepositoryText: str,
  Extension: str,
  Error : term
in
  snd-msg(file-extension-hook(asf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-get-filename(Path, Modulename, Extension))
  . rec-msg(io-filename(Filename?))
  . snd-msg(io-exists-file(Filename))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(io-read-file(Filename))
    .
    (
      rec-msg(io-file-contents(FileText?))
      . snd-msg(update-eqs-text-in-db(Modulename, FileText))
      . rec-msg(eqs-text-updated(Modulename))
    +
      rec-msg(io-error-reading(Error?))
      . printf("TODO: fix this error %t\n", Error)
    )
  +
    rec-msg(io-file-not-exists)
    . snd-msg(get-eqs-text(Modulename))
    .
    (
      rec-msg(eqs-text(Modulename, RepositoryText?))
      . snd-msg(remove-eqs-from-db(Modulename))
      . rec-msg(eqs-removed-from-db)
    +
      rec-msg(no-eqs-text(Modulename))
    )
  )
endlet

process CheckModuleConsistency(Modulename: str) is
let
  Directory: str,
  Extension: str,
  Path: str,
  Type: term
in
  snd-msg(get-path-from-db(Modulename))
  . rec-msg(path(Path?))
  . CheckSyntaxConsistency(Modulename, Path, sdf)
  . CheckEquationConsistency(Modulename, Path)
endlet


process PrintModule is
let
  Id: term,
  SdfText: str,
  AsfText: str,
  AsfTree: term,
  ModuleId: term,
  Modulename: str,
  Path: str,
  Filename: str,
  ErrMsg: str
in
  TODO("reimplement")
/*
    rec-msg(print-module(ModuleId?, Filename?))
        . snd-msg(io-write-text-list(Filename, [SdfText, "\n", AsfText])) */
endlet


process GetSpecification(ModuleId: term) is
let
  Error: term,
  CurModule: term,
  Equations: term,
  Imports: list,
  Modulename: str,
  Modules: list,
  Opened: bool,
  Pid: int,
  Specification: term,
  Id : int,
  Count : int,
  Done : int
in
  Id := process-id
  . snd-note(ui-status(start(Id, "Get Specification")))
  . MM-GetAllModuleDependencies(ModuleId, Modules?)
  . CheckModulesOpened(Modules, Opened?)
  . 
  if equal(Opened, true) then
    GetImportsForRenaming(ModuleId, Modules, Imports?)
    . Count := size(Modules)
    . Specification := []
    . TODO("remove computation by using listeners?")
    . 
    if and(not-equal(Modules, []), equal(Error, undefined)) then
      CurModule := first(Modules)
      . GetASFParseTree(CurModule, Equations?)
      .
      if equal(Equations, UNDEFINED) then
	tau
      else
	/* normalization should occur BEFORE renaming 
	 * proposal: merge the renaming and normalization tools,
	 * possibly including the get-imports tool. 
	 */
	MM-GetAttribute(CurModule, SDF_NAMESPACE, "name", Modulename?)
	. snd-note(ui-status(statf(Id, "Normalizing %s",[Modulename])))
	. snd-msg(normalize-module(Equations)) 
	. rec-msg(normalize-module-result(Equations?))
	. snd-note(ui-status(statf(Id, "Renaming %s",[Modulename])))
	. snd-msg(sr-rename-module(Imports, Modulename, Equations))
	. rec-msg(sr-renamed-module(Equations?))
	. Specification := join(Specification, Equations)
      fi
      . Modules := next(Modules)
      . Done := sub(Count, size(Modules))
      . printf("\rDone %d/%d\n", Done, Count )
    fi
    *
    (
      if not-equal(Error, undefined) then
	snd-msg(specification-incomplete(Error))
      fi
    +
      if equal(Modules, []) then
	snd-msg(specification(Specification)) 
      fi
    )
  else
    printf("Not all modules are openend: %t\n", Modules)
  fi
  . snd-note(ui-status(stop(Id)))
endlet

process GetSpecificationEquations(Specification: term, Equations: term?) is
  snd-msg(extract-equations(Specification))
  . rec-msg(extract-equations-result(Equations?))

process GetSpecificationTests(Specification: term, Tests: term?) is
  snd-msg(extract-tests(Specification))
  . rec-msg(extract-tests-result(Tests?))

process Save-modules is
let
  Id: term,
  Syntax: term,
  Snapshot: term,
  Module: term,
  Path: str,
  Text: str,
  Error: term,
  FileName: str,
  TermStoreName: str,
  Extension: str,
  ModuleType: term,
  Status: term
in
  Id := process-id
  .
  TODO("separate asf, sdf, term-store en module-db rotzooi\n")
  .
  (
    rec-msg(save-module(Module?, ModuleType?))
    . Status := success
    . snd-note(ui-status(statf(Id, "Saving %s", [Module])))
    . snd-msg(get-path-from-db(Module))
    .
    (
      rec-msg(path(Path?))
      . snd-msg(file-extension-hook(sdf))
      . rec-msg(file-extension-hook-result(Extension?))
      . snd-msg(io-get-filename(Path, Module, Extension))
      . rec-msg(io-filename(FileName?))
      . snd-msg(get-syntax-tree(Module))
      .
      (
        rec-msg(syntax(Syntax?))
        . snd-msg(unparse(Syntax))
        . rec-msg(unparsed-text(Text?))
        . snd-msg(io-write-text-list(FileName, [Text]))
        .
        (
          rec-msg(io-file-written)
        +
          rec-msg(io-file-not-written(Error?))
          . snd-note(ui-status(errorf("Saving failed: %t", [Error])))
          . Status := error
        )
      )
      .
      if equal(ModuleType, quote(asfsdf)) then
        snd-msg(get-eqs-text(Module))
        .
        (
          rec-msg(eqs-text(Module, Text?))
          . snd-msg(file-extension-hook(asf))
          . rec-msg(file-extension-hook-result(Extension?))
          . snd-msg(io-get-filename(Path, Module, Extension))
          . rec-msg(io-filename(FileName?))
          . snd-msg(io-write-text-list(FileName, [Text]))
          .
          (
            rec-msg(io-file-written)
          +
            rec-msg(io-file-not-written(Error?))
            . snd-note(ui-status(errorf("Saving failed: %t", [Error])))
            . Status := error
          )
        +
          rec-msg(no-eqs-text(Module))
        )
      else
        tau
      fi
    +
      rec-msg(no-path)
    )
    . snd-note(ui-status(endstat(Id)))
    . snd-msg(saved-module(Module, Status))
  +
    rec-msg(save-termstore)
    . snd-note(ui-status(statf(Id, "Saving term-store", [])))
    . snd-msg(get-termstore-name)
    . rec-msg(termstore-name(TermStoreName?))
    . snd-msg(ts-get-snapshot)
    . rec-msg(ts-snapshot(Snapshot?))
    . snd-msg(io-write-term-in-baf(TermStoreName, Snapshot))
    .
    (
      rec-msg(io-file-written)
      . snd-msg(saved)
    +
      rec-msg(io-file-not-written(Error?))
      . snd-msg(not-saved(Error))
    )
    . snd-note(ui-status(endstat(Id)))
  )
  *
  delta
endlet
#endif /* __ASF_UTILS__ */

