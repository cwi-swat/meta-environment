/* $Id$ */       

process SetParseTable(ModuleName : str, Type : term, Continue : term?) is
let
  TermType   : term
in
  if and(equal(Type, trm), equal(ModuleName, "Sdf2")) then
    snd-msg(open-language(sdf)) .
    (
      rec-msg(open-language-failed) .
      snd-note(ui-status(errorf(
        "Unable to open parse table for %s", [ModuleName]))) .
      Continue := false
    +
      rec-msg(open-language-succeeded(TermType?)) .
      Continue := true
    )
  else
    snd-msg(set-parsetable(ModuleName, Type)) .
    (
      rec-msg(parsetable-not-set(ModuleName)) .
      snd-note(ui-status(errorf(
        "Unable to open parse table for %s", [ModuleName]))) .
      Continue := false
    +
      rec-msg(parsetable-set(ModuleName)) .
      Continue := true
    )
  fi
endlet

process ParseString(ModuleName : str, Type : term, Nonterminal : str, Text : str,
		    Tree : term?, ParseError : term?) is
let
  Id         : term,
  ModuleId   : term,
  ErrList    : list,
  ErrContent : term,
  Continue   : term
in
  Id := process-id .     
  SetParseTable(ModuleName, Type, Continue?) .
  if equal(Type, eqs) then
    ModuleId := quote(eqs(ModuleName))
  else
    ModuleId := quote(trm(ModuleName))
  fi .
  if equal(Continue, true) then 
    snd-note(ui-status(statf(Id,"Parsing %s", [ModuleId]))).
    snd-msg(Id, parse-string-as-asfix2me(ModuleId, Nonterminal, Text)).
    (
      rec-msg(parse-result-asfix2me(Id, parse-tree(Tree?))) .
      ParseError := no-errors
    +
      rec-msg(parse-result-asfix2me(Id, ambiguous-tree(Tree?, 
						       ErrList?, 
						       ErrContent?))) .
      ParseError := quote(ambiguous-parse(ErrList, ErrContent))
    +
      rec-msg(parse-result-asfix2me(Id, parse-error(ErrList?, ErrContent?))) .
      Tree := error-tree .
      ParseError := quote(parse-error(ErrList, ErrContent))
    ) .
    snd-note(ui-status(endstat(Id)))
  else
    Tree := error-tree .
    ParseError := no-parse-table
  fi
endlet

process ProcessTree(ModuleName : str, EditorId : term, 
		    Focus : term, Tree : term) is
let
  FileName : str,
  NewTree : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(get-editor-filename(EditorId)) .
    rec-msg(editor-filename(FileName?)) .
    snd-msg(add-posinfo-packed(FileName, Tree)) .
    rec-msg(tree-with-pos-info(NewTree?)) .
    snd-msg(replace-focus(EditorId, Focus, NewTree)) .
    NewTree := no-tree .
    snd-msg(parse-ok(ModuleName))
  else
    tau
  fi
endlet

process ProcessParseError(ModuleName : str, ParseError: term, Type : str) is
let
  Co           : int,
  Li           : int,
  I            : int,
  Ch           : int,
  Cycle        : term,
  ErrorList    : list,
  ErrorContent : term,
  FunSym       : str
in
  FunSym := fun(ParseError) .
  if not-equal(FunSym, "no-errors") then
    ErrorList := first(args(ParseError)) .
    ErrorContent := first(next(args(ParseError))) .
    FunSym := fun(ErrorContent) .
    if equal(FunSym, "ambiguities") then
      I := first(args(ErrorContent)) .
      if greater(I, 1) then
        snd-note(ui-status(errorf("Parse of %s%s returned %d ambiguities",
                                  [ModuleName,Type,I])))
      else 
        snd-note(ui-status(errorf("Parse of %s%s returned 1 ambiguity",
                                  [ModuleName,Type])))
      fi
    else
      tau
    fi .
    if equal(FunSym, "cycle") then
      Cycle := first(args(ErrorContent)) .
      snd-note(ui-status(errorf("Parse returned a cycle: %t\n",
                                [Cycle])))
    else
      tau
    fi .
      if equal(FunSym, "eof") then
      snd-note(ui-status(errorf("EOF unexpected while parsing %s%s\n",
                                [ModuleName,Type])))
    else
      tau
    fi .
    if equal(FunSym, "plain") then
      Ch := first(args(first(ErrorList))) .
      Li := first(args(first(next(ErrorList)))) .
      Co := first(args(first(next(next(ErrorList))))) .
      snd-note(ui-status(errorf(
               "Character %d unexpected in %s%s, line %d, column %d\n",
               [Ch, ModuleName, Type, Li, Co])))
    else
      tau
    fi
  else
    tau
  fi
endlet

process PrepareParseErrorForEditor(ModuleName : str, EditorId : term,
			           Focus : term, ParseError : term) is
let
  Pos          : int,
  Co           : int,
  Li           : int,
  I            : int,
  Ch           : int,
  Cycle        : term,
  ErrorList    : list,
  ErrorContent : term,
  FunSym       : str,
  FileName     : str
in
  FunSym := fun(ParseError) .
  if equal(FunSym, "no-parse-table") then
    snd-msg(display-message(EditorId, "No parse table available")) .
    snd-msg(parse-failed(ModuleName, Focus))
  else
    if not-equal(FunSym, "no-errors") then
      ErrorList := first(args(ParseError)) .
      snd-msg(get-editor-filename(EditorId)) .
      rec-msg(editor-filename(FileName?)) .
      snd-msg(get-error-position(Focus, ErrorList)) .
      rec-msg(error-position(Pos?)) .
      snd-msg(set-cursor-at-location(EditorId, Pos)) .
      snd-msg(display-message(EditorId, "Parse error near cursor")) .
      ErrorContent := first(next(args(ParseError))) .
      FunSym := fun(ErrorContent) .
      if equal(FunSym, "ambiguities") then
        I := first(args(ErrorContent)) .
        if greater(I, 1) then
            snd-note(ui-status(errorf("Parse of %s returned %d ambiguities",
                                    [FileName,I])))
        else 
          snd-note(ui-status(errorf("Parse of %s returned 1 ambiguity",
                                    [FileName])))
        fi
      else
        tau
      fi .
      if equal(FunSym, "cycle") then
        Cycle := first(args(ErrorContent)) .
        snd-note(ui-status(errorf("Parse returned a cycle: %t\n", [Cycle]))) .
        snd-msg(parse-failed(ModuleName, Focus))
      else
        tau
      fi .
      if equal(FunSym, "eof") then
        snd-note(ui-status(errorf("EOF unexpected while parsing %s\n",
                                  [FileName]))) .
        snd-msg(parse-failed(ModuleName, Focus))
      else
        tau
      fi .
      if equal(FunSym, "plain") then
        snd-msg(parse-failed(ModuleName, Focus))
      else
        tau
      fi
    else
      tau
    fi
  fi
endlet
