/*
  $Id$
*/       

process SetParseTable(ModuleId : term, Continue : term?) is
let
  Type       : str,
  ModuleName : str
in
  Type := fun(ModuleId) .
  ModuleName := first(args(ModuleId)).
  if and(equal(Type, "trm"), equal(ModuleName, "Sdf2")) then
    snd-msg(open-sdf2-language) .
    (
      rec-msg(sdf2-language-not-opened) .
      snd-note(ui-status(errorf(
        "Unable to open parse table for %s", [ModuleName]))) .
      Continue := false
    +
      rec-msg(sdf2-language-opened) .
      Continue := true
    )
  else
    snd-msg(set-parsetable(ModuleId)) .
    (
      rec-msg(parsetable-not-set(ModuleId)) .
      snd-note(ui-status(errorf(
        "Unable to open parse table for %s", [ModuleName]))) .
      Continue := false
    +
      rec-msg(parsetable-set(ModuleId)) .
      Continue := true
    )
  fi
endlet

process ParseString(ModuleId : term, Nonterminal : str, Text : str,
		    Tree : term?, ParseError : term?) is
let
  Id         : term,
  ErrList    : list,
  ErrContent : term,
  Continue   : term
in
  Id := process-id .     
  SetParseTable(ModuleId, Continue?) .
  if equal(Continue, true) then 
    snd-note(ui-status(statf(Id,"Parsing %s", [ModuleId]))).
    snd-msg(Id, parse-string-as-asfix2me(ModuleId, Nonterminal, Text)).
    (
      rec-msg(parse-result-asfix2me(Id, parse-tree(Tree?))) .
      ParseError := no-errors
    +
      rec-msg(parse-result-asfix2me(Id, ambiguous-tree(Tree?, 
						       ErrList?, 
						       ErrContent?))) .
      ParseError := quote(ambiguous-parse(ErrList, ErrContent))
    +
      rec-msg(parse-result-asfix2me(Id, parse-error(ErrList?, ErrContent?))) .
      Tree := error-tree .
      ParseError := quote(parse-error(ErrList, ErrContent))
    ) .
    snd-note(ui-status(endstat(Id)))
  else
    Tree := error-tree .
    ParseError := no-parse-table
  fi
endlet

process ProcessTree(ModuleId : term, EditorId : term, 
		    Focus : term, Tree : term) is
let
  FileName : str,
  NewTree : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(get-editor-name(EditorId)) .
    rec-msg(editor-name(FileName?)) .
    snd-msg(add-posinfo(FileName, Tree)) .
    rec-msg(tree-with-pos-info(NewTree?)) .
    snd-msg(replace-focus(EditorId, Focus, NewTree)) .
    snd-msg(parse-ok(ModuleId))
  else
    tau
  fi
endlet

process ProcessParseError(ModuleName : str, ParseError: term, Type : str) is
let
  Co           : int,
  Li           : int,
  I            : int,
  Ch           : int,
  Cycle        : term,
  ErrorList    : list,
  ErrorContent : term,
  FunSym       : str
in
  FunSym := fun(ParseError) .
  if not-equal(FunSym, "no-errors") then
    ErrorList := first(args(ParseError)) .
    ErrorContent := first(next(args(ParseError))) .
    FunSym := fun(ErrorContent) .
    if equal(FunSym, "ambiguities") then
      I := first(args(ErrorContent)) .
      if greater(I, 1) then
        snd-note(ui-status(errorf("Parse of %s.%s returned %d ambiguities",
                                  [ModuleName,Type,I])))
      else 
        snd-note(ui-status(errorf("Parse of %s.%s returned 1 ambiguity",
                                  [ModuleName,Type])))
      fi
    else
      tau
    fi .
    if equal(FunSym, "cycle") then
      Cycle := first(args(ErrorContent)) .
      snd-note(ui-status(errorf("Parse returned a cycle: %t\n",
                                [Cycle])))
    else
      tau
    fi .
      if equal(FunSym, "eof") then
      snd-note(ui-status(errorf("EOF unexpected while parsing %s.%s\n",
                                [ModuleName,Type])))
    else
      tau
    fi .
    if equal(FunSym, "plain") then
      Ch := first(args(first(ErrorList))) .
      Li := first(args(first(next(ErrorList)))) .
      Co := first(args(first(next(next(ErrorList))))) .
      snd-note(ui-status(errorf(
               "Character %d unexpected in %s.%s, line %d, column %d\n",
               [Ch, ModuleName, Type, Li, Co])))
    else
      tau
    fi
  else
    tau
  fi
endlet

process PrepareParseErrorForEditor(ModuleId : term, EditorId : term,
			           Focus : term, ParseError : term) is
let
  Pos          : int,
  Co           : int,
  Li           : int,
  I            : int,
  Ch           : int,
  Cycle        : term,
  ErrorList    : list,
  ErrorContent : term,
  FunSym       : str,
  ModuleName   : str,
  Type         : str
in
  ModuleName := first(args(ModuleId)).
  Type := fun(ModuleId) .  
  if equal(Type, "eqs") then 
    Type := "asf"
  else
    tau
  fi .
  FunSym := fun(ParseError) .
  if not-equal(FunSym, "no-errors") then
    ErrorList := first(args(ParseError)) .
    snd-msg(get-error-position(Focus, ErrorList)) .
    rec-msg(error-position(Pos?)) .
    snd-note(display-error(EditorId, Pos)) .
    ErrorContent := first(next(args(ParseError))) .
    FunSym := fun(ErrorContent) .
    if equal(FunSym, "ambiguities") then
      I := first(args(ErrorContent)) .
      if greater(I, 1) then
        snd-note(ui-status(errorf("Parse of %s.%s returned %d ambiguities",
                                  [ModuleName,Type,I])))
      else 
        snd-note(ui-status(errorf("Parse of %s.%s returned 1 ambiguity",
                                  [ModuleName,Type])))
      fi
    else
      tau
    fi .
    if equal(FunSym, "cycle") then
      Cycle := first(args(ErrorContent)) .
      snd-note(ui-status(errorf("Parse returned a cycle: %t\n", [Cycle]))) .
      snd-msg(parse-failed(ModuleId, Focus))
    else
      tau
    fi .
    if equal(FunSym, "eof") then
      snd-note(ui-status(errorf("EOF unexpected while parsing %s.%s\n",
                                [ModuleName, Type]))) .
      snd-msg(parse-failed(ModuleId, Focus))
    else
      tau
    fi .
    if equal(FunSym, "plain") then
      snd-msg(parse-failed(ModuleId, Focus))
    else
      tau
    fi
  else
    tau
  fi
endlet
