/* $Id$ */       

process ParseString(ModuleName: str, Type: term, 
                    Checking: term, Nonterminal: str, Text: str,
		    ParseResult: term?, Errors: list?) is
let
  Error: term,
  Id: term,
  ModuleId: term,
  Table: term
in
  Id := process-id .     
  GetParseTable(ModuleName, Type, Checking, Table?) .
  if equal(Type, eqs) then
    ModuleId := quote(eqs(ModuleName))
  else
    ModuleId := quote(trm(ModuleName))
  fi .
  if equal(Table, no-table) then 
    ParseResult := to-be-removed
    . Errors := no-parse-table
    . printf("ParseString: no-parse-table unhandled\n")
  else
    snd-note(ui-status(statf(Id,"Parsing %s", [ModuleId])))
    . Errors := []
    . snd-msg(sglr-parse(Text, Table, Nonterminal))
    .
    (
      rec-msg(sglr-parse-tree(ParseResult?))
    +
      rec-msg(sglr-parse-forest(ParseResult?, Errors?))
    +
      rec-msg(sglr-parse-error(Errors?))
    )
    . snd-note(ui-status(endstat(Id)))
  fi
endlet

process ProcessParseError(ParseError: term) is
  if equal(fun(ParseError), "no-errors") then
    tau
  else
    snd-note(remove-feedback-summary(ParseError)) .
    snd-note(show-feedback-summary(ParseError)) 
  fi

process HandleParseError(Sid: term, Error: term) is
let
  Filename: str,
  Result: term,
  Summary: term
in
  GetFilename(Sid, Filename?)
  . snd-msg(es-add-filename-in-error(Filename, Error))
  . rec-msg(es-filename-in-error(Filename, Result?))
  . snd-msg(es-make-summary("sglr", Filename, [Result]))
  . rec-msg(es-summary(Summary?))
  . ShowSummary(Sid, Summary)
  . ProcessParseError(Summary)
endlet
