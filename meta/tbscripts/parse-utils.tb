/* $Id$ */       

process ObtainParseTable(ModuleName : str, Type : term, Table : term?) is
let
  TermType : term
in
  if equal(Type, sdf) then
    snd-msg(open-language(sdf)) .
    (
      rec-msg(parse-table(TermType?, Table?))
    +
      rec-msg(no-parse-table) .
      Table := no-table
    )
  else
    snd-msg(get-parsetable(ModuleName, Type)) .
    (
      rec-msg(parse-table(Table?))
    +
      rec-msg(no-parse-table(ModuleName)) .
      Table := no-table
    )
  fi
endlet

process ParseString(ModuleName : str, Path : str, Type : term, 
                    Nonterminal : str, Text : str,
		    Tree : term?, ParseError : term?) is
let
  Id         : term,
  ModuleId   : term,
  Table      : term
in
  Id := process-id .     
  ObtainParseTable(ModuleName, Type, Table?) .
  if equal(Type, eqs) then
    ModuleId := quote(eqs(ModuleName))
  else
    ModuleId := quote(trm(ModuleName))
  fi .
  if not-equal(Table, no-table) then 
    snd-note(ui-status(statf(Id,"Parsing %s", [ModuleId]))).
    snd-msg(Id, parse-string-given-table(ModuleId, Table, Nonterminal, Text, Path)).
    rec-msg(parse-result-asfix2me(Id, Tree?, ParseError?)) .
    snd-note(ui-status(endstat(Id)))
  else
    Tree := error-tree .
    ParseError := no-parse-table
  fi
endlet

process ProcessTree(ModuleName : str, EditorId : term, 
		    Focus : term, Tree : term, ParseError : term) is
let
  FileName : str,
  FunSym   : str,
  NewTree  : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(get-editor-filename(EditorId)) .
    rec-msg(editor-filename(FileName?)) .
    snd-msg(add-posinfo-packed(FileName, Tree)) .
    rec-msg(tree-with-pos-info(NewTree?)) .
    snd-msg(replace-focus(EditorId, Focus, NewTree)) .
    NewTree := no-tree .
    FunSym := fun(ParseError) .
    if equal(FunSym, "no-errors") then
      snd-msg(parse-ok(ModuleName))
    else
      tau
    fi
  else
    tau
  fi
endlet

process ProcessParseError(Path : str, ParseError: term) is
let
  FunSym       : str
in
  FunSym := fun(ParseError) .
  snd-note(remove-feedback-summary("sglr", Path)) .
  if not-equal(FunSym, "no-errors") then
    snd-note(show-feedback-summary(ParseError)) 
  else
    tau
  fi
endlet

process PrepareParseErrorForEditor(ModuleName : str, EditorId : term,
			           Focus : term, ParseError : term) is
let
  Location : term,
  FunSym   : str,
  FileName : str
in
  FunSym := fun(ParseError) .
  if equal(FunSym, "no-parse-table") then
    snd-msg(display-message(EditorId, "No parse table available")) .
    snd-msg(parse-failed(ModuleName, Focus))
  else
    snd-msg(get-editor-filename(EditorId)) .
    rec-msg(editor-filename(FileName?)) .
    snd-note(remove-feedback-summary("sglr", FileName)) .
    if not-equal(FunSym, "no-errors") then
      snd-msg(get-error-location(ParseError)) .
      rec-msg(error-location(Location?)) .
      snd-msg(set-cursor-at-location(EditorId, Location)) .
      snd-msg(display-message(EditorId, "Parse error near cursor")) .
      snd-note(show-feedback-summary(ParseError)) .
      snd-msg(parse-failed(ModuleName, Focus))
    else
      tau
    fi
  fi
endlet
