/* $Id$ */

process CloseModule(ModuleId: str, Recursive: bool) is
let
  Changed: list,
  Depending: list,
  Id: int,
  ToBeClosed: list
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Closing %s", [ModuleId])))
  .
  if equal(Recursive, quote(true))
  then
    ComputeModulesToBeClosed(ModuleId, ToBeClosed?)
    .
    if equal(ToBeClosed, [])
    then
      Error("Unable to close %s, it would break some import(s).", [ModuleId])
    else
      CloseModules(ToBeClosed)
    fi
  else 
    GetDependingModules(ModuleId, Depending?)
    .
    if equal(Depending, [])
    then
      CloseModules([ModuleId])
    else
      Error("Unable to close %s, it would break the import of: %t",
            [ModuleId, Depending])
    fi
  fi
  . snd-note(ui-status(endstat(Id)))
endlet

process CloseModules(ToBeClosed: list) is
let
  ModuleId: str,
  Modules: list
in
  Modules := ToBeClosed
  .
  if not-equal(Modules, [])
  then
    ModuleId := first(Modules)
    . DeleteSessions(ModuleId)
    . snd-msg(close-module-in-db(ModuleId))
    . rec-msg(module-closed(ModuleId))
    . Modules := next(Modules)
  fi
  *
  if equal(Modules, [])
  then
    tau
  fi
endlet

process GetDependingModules(ModuleId: str, DependingModules: list?) is
let
  ImportRelations: list
in
  snd-msg(ts-get-key-value-pairs("import-relations"))
  . rec-msg(ts-pairs(ImportRelations?))
  . snd-msg(sm-get-all-depending-module-names(ImportRelations, ModuleId))
  . rec-msg(sm-all-depending-module-names(DependingModules?)) 
endlet

process ComputeModulesToBeClosed(ModuleId: str, ToBeClosed: list?) is
let
  Depending: list,
  CurModule: str,
  Imports: list,
  Needed: list,
  Runner: list
in
  snd-msg(get-all-imported-module-names(ModuleId))
  . rec-msg(all-imported-module-names(Imports?))
  . Needed := []
  . Runner := Imports
  .
  if not-equal(Runner, [])
  then
    CurModule := first(Runner)
    . GetDependingModules(CurModule, Depending?)
    . Runner := next(Runner)
    .
    if not(subset(Depending, Imports))
    then
       Needed := join(CurModule, Needed) 
    else
       tau
    fi
  fi
  *
  if equal(Runner, []) then
    ToBeClosed := diff(Imports, Needed)
  fi
endlet  

process DeleteModule(ModuleName: str) is
let
  Directories: list,
  Changed: list,
  Id: int,
  Path: str,
  Extension: str,
  Status: term
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Deleting %s", [ModuleName])))
  . snd-msg(get-search-paths)
  . rec-msg(search-paths(Directories?))
  . snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(get-path-from-db(ModuleName))
  .
  ( 
    rec-msg(path(Path?))
    . RemoveModuleFromDisk(Path, ModuleName, Status?)
  +
    rec-msg(no-path)
  )
  . DeleteSessions(ModuleName)
  . snd-msg(delete-module-from-db(ModuleName))
  . rec-msg(changed-modules(Changed?))
  . SaveSdfModules(Changed, Status?)
  . snd-note(ui-status(endstat(Id)))
endlet

process RenameModule(ModuleId: str, Directory: str, Filename: str) is
let
  Extension: str,
  Id: int,
  NewModule: str,
  Path: str,
  Status: term
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Renaming %s", [ModuleId])))
  . CopySdfModule(ModuleId, Directory, Filename)
  . CopyAsfModule(ModuleId, Directory, Filename)
  . snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Filename, Extension, Path?)
  . GetModuleForPath(Path, NewModule?)
  . RenameImports(ModuleId, NewModule)
  . DeleteModule(ModuleId)
  . snd-note(ui-status(endstat(Id)))
endlet

process CreateModule(Pid: int, Directory: str, Filename: str, Type: term) is
let
  BaseDir: str,
  Contents: list,
  Error: term,
  Extension: str,
  ModuleId: str,
  Path: str,
  SearchPaths: list
in
  snd-msg(get-search-paths)
  . rec-msg(search-paths(SearchPaths?))
  . snd-msg(sm-get-new-module-name(SearchPaths, Directory, Filename))
  .
  (
    rec-msg(sm-new-module-name(BaseDir?, ModuleId?))
    . snd-msg(is-module-in-db(ModuleId))
    .
    (
      rec-msg(exists-in-module-db(ModuleId))
      . snd-note(ui-status(errorf("Module %s already exists", [ModuleId])))
    +
      rec-msg(not-exists-in-module-db(ModuleId))
      . snd-msg(file-extension-hook(Type))
      . rec-msg(file-extension-hook-result(Extension?))
      . BuildPath(BaseDir, ModuleId, Extension, Path?)
      . snd-msg(io-exists-file(Path))
      .
      (
	rec-msg(io-file-exists)
	. snd-note(ui-status(errorf("File %s already exists", [Path])))
      +
	rec-msg(io-file-not-exists)
	. snd-msg(get-module-contents(Pid, ModuleId))
	. rec-msg(module-contents(Pid, Contents?))
	. snd-msg(io-write-text-file(Path, Contents))
	.
	(
	  rec-msg(io-file-written)
	  . OpenModule(Path, Type)
	+
	  rec-msg(io-file-not-written(Error?))
	  . snd-note(ui-status(errorf("%s: %s", [Path, Error])))
	)
      )
    )
  +
    rec-msg(sm-new-module-name-inconsistent)
    . snd-note(ui-status(errorf(
      "Module %s in %s is inconsistent with search paths", [ModuleId, Path])))
  )
endlet

process CopySdfModule(SrcModuleId: str, Directory: str, Filename: str) is
let
  Id: int,
  Pid: int
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Copying %s to %s", [SrcModuleId, Filename])))
  . create(CopySdfContentHandler(SrcModuleId), Pid?)
  . CreateModule(Pid, Directory, Filename, sdf)
  . snd-note(ui-status(endstat(Id)))
endlet

process CopyAsfModule(SrcModuleId: str, Directory: str, Filename: str) is
let
  DestPath: str,
  Error: str,
  Extension: str,
  SrcPath: str
in
  LocateFile(SrcModuleId, asf, SrcPath?)
  . snd-msg(io-exists-file(SrcPath))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(file-extension-hook(asf))
    . rec-msg(file-extension-hook-result(Extension?))
    . BuildPath(Directory, Filename, Extension, DestPath?)
    . snd-msg(io-exists-file(DestPath))
    .
    (
      rec-msg(io-file-exists)
      . Error("Refusing to overwrite existing file: %s", [DestPath])
    +
      rec-msg(io-file-not-exists)
      . snd-msg(io-copy-file(SrcPath, DestPath))
      .
      (
	rec-msg(io-file-copied(SrcPath, DestPath))
      +
	rec-msg(io-file-not-copied(SrcPath, DestPath, Error?))
	. Error("Unable to copy: %s", [Error])
      )
    )
  +
    rec-msg(io-file-not-exists)
  )
endlet

process CopySdfContentHandler(SrcModuleId: str) is
let
  Contents: str,
  DestModuleId: str,
  Pid: int,
  Syntax: term
in
  Pid := process-id
  . rec-msg(get-module-contents(Pid, DestModuleId?))
  . snd-msg(ts-get-term-value("sdf-tree", SrcModuleId))
  . rec-msg(ts-value(Syntax?))
  . snd-msg(sm-rename-modulename-in-module(Syntax, DestModuleId))
  . rec-msg(sm-modulename-renamed-in-module(Syntax?))
  . snd-msg(unparse(Syntax))
  . rec-msg(unparsed-text(Contents?))
  . snd-msg(module-contents(Pid, [Contents]))
endlet

process AddImport(ModuleId: str, Import: str)  is
let
  Depending: list,
  Status: term
in
  DeleteSessions(ModuleId)
  . GetDependingModules(ModuleId, Depending?)
  . MDB-InvalidateModules(Depending, sdf)
  . AddImportInDB(ModuleId, Import)
  . SaveAsfSdfModule(ModuleId, Status?) 
endlet  

process RemoveImport(ModuleId: str, Import: str) is
let
  Depending: list,
  Status : term
in
  DeleteSessions(ModuleId)
  . GetDependingModules(ModuleId, Depending?)
  . MDB-InvalidateModules(Depending, sdf)
  . RemoveImportInDB(ModuleId, Import)
  . SaveAsfSdfModule(ModuleId, Status?)
endlet  

process GetRealModuleName(Name : str, Path : str, Status : term?,
                          RealName : str?, RealPath : str?)
is
let
  ErrMsg : str,
  Paths : list
in
  Status := success .
  snd-msg(get-search-paths) .
  rec-msg(search-paths(Paths?)) .
  snd-msg(sm-get-new-module-name(Paths, Path, Name)) .
  (
    rec-msg(sm-new-module-name(RealPath?, RealName?)) 
  +
    rec-msg(sm-new-module-name-inconsistent) .
    Status := module-name-inconsistent .
    RealName := "" .
    RealPath := ""
  )
endlet

process SaveSdfModules(Modules : list, Status : term?) is
let
  Runner : list,
  Module : str
in
  Runner := Modules.
  if not-equal(Runner, []) then
    Module := first(Runner) .
    snd-msg(save-module(Module, sdf)) .
    rec-msg(saved-module(Module, Status?)) .
    Runner := next(Runner)
  fi * 
  if equal(Runner, []) then
    tau
  fi
endlet

process SaveAsfSdfModule(Module : str, Status : term?) is
   snd-msg(save-module(Module, asfsdf)) .
   rec-msg(saved-module(Module, Status?))

process RemoveModuleFromDisk(Path : str, Module : str, Status : term?) is
let
  Extension : str,
  Error : str
in
  snd-msg(file-extension-hook(sdf)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-remove-file(Path, Module, Extension)) .
  (
    rec-msg(io-file-removed(Path, Module, Extension)) .
    snd-msg(file-extension-hook(asf)) .
    rec-msg(file-extension-hook-result(Extension?)) .
    snd-msg(io-remove-file(Path, Module, Extension)) .
    (
      rec-msg(io-file-removed(Path, Module, Extension)) 
    +
      rec-msg(io-file-not-removed(Path, Module, Extension, Error?)) 
      /* error ignored because there does not have to be a asf file
       * TODO: do not try to delete a non-existing file */
    )
  +
    rec-msg(io-file-not-removed(Path, Module, Extension, Error?)) .
    Status := remove-error .
    snd-note(ui-status(errorf("Could not remove file: %s", [Error])))
  )
endlet

process CloseModuleInDBandInvalidateDependingModules(ModuleName : str) is
  DeleteEditorAndInvalidateDependingModules(ModuleName)
  . snd-msg(close-module-in-db(ModuleName))
  . rec-msg(module-closed(ModuleName))

  
process RenameImports(OldImport: str, NewImport: str) is
let
  Imports: list,
  ImportRelations: list,
  ModuleId: str,
  Depending: list
in
  snd-msg(ts-get-key-value-pairs("import-relations"))
  . rec-msg(ts-pairs(ImportRelations?))
  . snd-msg(sm-get-depending-module-names(ImportRelations, OldImport))
  . rec-msg(sm-depending-module-names(Depending?))
  .
  if not-equal(Depending, [])
  then
    ModuleId := first(Depending)
    . RenameImport(ModuleId, OldImport, NewImport)
    . Depending := next(Depending)
  fi
  *
  if equal(Depending, [])
  then
    tau
  fi
endlet

process RenameImport(ModuleId: str, OldImport: str, NewImport: str) is
let
  Status: term,
  Tree: term
in
  snd-msg(ts-get-term-value("sdf-tree", ModuleId))
  . rec-msg(ts-value(Tree?))
  . snd-msg(sm-remove-import-from-module(Tree, OldImport))
  . rec-msg(sm-import-removed-from-module(Tree?))
  . snd-msg(sm-add-import-to-module(Tree, NewImport))
  . rec-msg(sm-import-added-to-module(Tree?))
  . MDB-StoreModuleTree(ModuleId, Tree)
  . snd-msg(save-module(ModuleId, sdf))
  . rec-msg(saved-module(ModuleId, Status?))
endlet

process AddImportInDB(Mod : str, Import : str)
is
  snd-msg(add-import-in-db(Mod, Import)) .
  rec-msg(add-import-done(Mod))

process RemoveImportInDB(Mod : str, Import : str)
is
  snd-msg(remove-import-in-db(Mod, Import)) .
  rec-msg(remove-import-done)

process CheckExistence(Name : str, Path : str, Status : term?) is
let
  FileName : str,
  Extension : str
in
  snd-msg(is-module-in-db(Name)) .
  (
    rec-msg(exists-in-module-db(Name)).
    Status := module-exists-in-db
  +
    rec-msg(not-exists-in-module-db(Name))
  ).
  snd-msg(file-extension-hook(sdf)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-get-filename(Name, Path, Extension)) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-exists-file(FileName)) .
  (
    rec-msg(io-file-exists) .
    Status := module-exists-on-disk
  +
    rec-msg(io-file-not-exists)
  )
endlet

process DeleteEditorAndInvalidateDependingModules(Modulename: str) is
let
  Depending: list
in
  DeleteSessions(Modulename)
  . GetDependingModules(Modulename, Depending?)
  . MDB-InvalidateModules(Depending, sdf)
endlet

process DeleteEditorsForModulename(Modulename: str) is
let
  Depending : list,
  Mod : str
in
  DeleteSessions(Modulename)
  . GetDependingModules(Modulename, Depending?)
  . if not-equal(Depending, []) then
    Mod := first(Depending)
    . DeleteSessions(Mod)
    . Depending := next(Depending)
  fi * 
  if equal(Depending, []) then
    tau
  fi 
endlet

process HandleRenameModuleErrors(Old : str, New : str, Status : term) is
  if not-equal(Status, success) then
    snd-note(ui-status(errorf("Error during renaming of %s to %s: %s\n", 
                            [Old, New, Status])))
  else
    tau
  fi

process HandleCopyModuleErrors(Old : str, New : str, Status : term) is
  if not-equal(Status, success) then
    snd-note(ui-status(errorf("Error during copying of %s to %s: %s\n", 
                            [Old, New, Status])))
  else
    tau
  fi

process CheckSyntaxConsistency(ModuleName : str, Path : str) is
let
  ErrorMessage : str,
  FileName : str,
  FileText : str,
  RepositoryText : str,
  Tree : term,
  DependingModules : list,
  Imports : list,
  Error : term,
  Extension : str,
  Type : term
in
  Type := quote(sdf) .
  snd-msg(file-extension-hook(Type)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-get-filename(Path, ModuleName, Extension)) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-exists-file(FileName)) . 
  (
    rec-msg(io-file-exists) .
    snd-msg(io-read-file(FileName)) . 
    rec-msg(io-file-contents(FileText?)) .
    snd-msg(update-module-text-in-db(ModuleName, FileText, no-tree, Type)) .
    (
      rec-msg(no-updating-needed)
    +
      rec-msg(updating-succeeded(DependingModules?)) .
      /*Parse-Syntax(FileText, Type, Tree?, Error?) .*/
      printf("this bites\n").
      if equal(Error, no-errors) then
        snd-msg(update-module-in-db(ModuleName, Tree, Type)) .
	(
          rec-msg(updating-succeeded(Imports?)).
          OpenModules(Imports, Type) .
	  DrawImportGraph()
        +
	  rec-msg(error-opening(ModuleName, name-inconsistent)) .
          Error("Check consistency: module name %s contains an error", [ModuleName])
        )
      else
        printf("CheckSyntaxConsistency: error ignored: %t\n", Error)
      fi
    )
  +
    rec-msg(io-file-not-exists) .
    snd-msg(close-module-in-db(ModuleName))
    . rec-msg(module-closed(ModuleName))
  )
endlet

process CheckEquationConsistency(ModuleName : str, Path : str) is
let
  FileName : str,
  FileText : str,
  RepositoryText : str,
  Extension : str
in
  snd-msg(file-extension-hook(asf)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-get-filename(Path, ModuleName, Extension)) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-exists-file(FileName)) . 
  (
    rec-msg(io-file-exists) .
    snd-msg(io-read-file(FileName)) . 
    rec-msg(io-file-contents(FileText?)) .
    snd-msg(update-eqs-text-in-db(ModuleName, FileText)) .
    rec-msg(eqs-text-updated(ModuleName))
  +
    rec-msg(io-file-not-exists) .
    snd-msg(get-eqs-text(ModuleName)) .
    (
      rec-msg(eqs-text(ModuleName, RepositoryText?)) .
      snd-msg(remove-eqs-from-db(ModuleName)) .
      rec-msg(eqs-removed-from-db)
    +
      rec-msg(no-eqs-text(ModuleName))
    )
  )
endlet

process CheckModuleConsistency(ModuleName : str) is
let
  Path : str
in
  snd-msg(get-path-from-db(ModuleName)) .
  rec-msg(path(Path?)) .
  CheckSyntaxConsistency(ModuleName, Path) .
  CheckEquationConsistency(ModuleName, Path)
endlet

process InitializeTermStore(Name : str) is
  if not-equal(Name, "") then
    snd-msg(register-termstore-name(Name)) .
    rec-msg(termstore-name-registered) .
    TermStoreActivation
  else
    tau
  fi

process TermStoreActivation is
let
  TermStoreContents : term,
  ErrorMessage : str,
  ModuleNames : list,
  ModuleName : str,
  Name : str,
  Id : int
in
  Id := process-id.
  snd-msg(get-termstore-name) .
  rec-msg(termstore-name(Name?)) .
  snd-msg(io-exists-file(Name)) .
  (
    rec-msg(io-file-exists) .
    snd-note(ui-status(stat(Id, "Retrieving saved term-store"))) .
    snd-msg(io-read-packed-term-file(Name)) .
    (
      rec-msg(io-file-contents(TermStoreContents?)) .
      snd-msg(ts-load-snapshot(TermStoreContents)) .
      rec-msg(ts-snapshot-loaded) .
      snd-msg(get-all-module-names) .
      rec-msg(all-module-names(ModuleNames?)) .
      snd-note(ui-status(stat(Id, "Checking consistency of term-store content"))) .
      if not-equal(ModuleNames, []) then
        ModuleName := first(ModuleNames) .
        ModuleNames := next(ModuleNames) .
        CheckModuleConsistency(ModuleName)
      fi *
      if equal(ModuleNames, []) then
        tau
      fi .
      snd-note(ui-status(endstat(Id))) .
      DrawImportGraph()
    +
      rec-msg(io-error-reading(ErrorMessage?))
    ) .
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(io-file-not-exists) .
    snd-note(ui-status(errorf("Termstore %s does not exist!", [Name])))
  )
endlet

process TermStoreName is
let
  TermStoreName : str
in
  TermStoreName := "meta.termstore" .
  (
    rec-msg(register-termstore-name(TermStoreName?)) .
    snd-msg(termstore-name-registered)
  +
    rec-msg(get-termstore-name) .
    snd-msg(termstore-name(TermStoreName)) 
  )*delta
endlet
