/* $Id$ */

process Module-Utilities is
let
  Id : int,
  ModuleName1 : str,
  ModuleName2 : str,
  Extension : str,
  Path : str,
  Type : term,
  Option1 : term
in
  Id := process-id.
  (
    rec-msg(rename-module(ModuleName1?, ModuleName2?, Path?)) .
    snd-note(ui-status(statf(Id, 
             "Renaming %s to %s",[ModuleName1,ModuleName2]))).
    DoRenameModule(ModuleName1, ModuleName2, Path).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(import-module(ModuleName1?, ModuleName2?)).
    snd-note(ui-status(statf(Id, 
             "Adding %s to imports of %s",[ModuleName2,ModuleName1]))).
    DoImportModule(ModuleName1, ModuleName2).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(delete-module(ModuleName1?)) .
    snd-note(ui-status(statf(Id, "Deleting %s",[ModuleName1]))).
    DoDeleteModule(ModuleName1).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(unimport-module(ModuleName1?, ModuleName2?)).
    snd-note(ui-status(statf(Id, 
             "Removing %s from imports of %s",[ModuleName2,ModuleName1]))).
    DoUnimportModule(ModuleName1, ModuleName2).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(revert-module(ModuleName1?))
    . snd-note(ui-status(statf(Id, "Reverting %s",[ModuleName1])))
    . RevertModule(ModuleName1)
    . snd-note(ui-status(endstat(Id)))
  +
    rec-msg(close-module(ModuleName1?, Option1?)).
    snd-note(ui-status(statf(Id, 
             "Closing %s",[ModuleName1]))).
    DoCloseModule(ModuleName1, Option1).
    snd-note(ui-status(endstat(Id)))
  ) *
  delta
endlet

process DoCloseModule(ModuleName : str, Recursive : term) is
let
  Status : term,
  Changed : list
in
  Status := success.
  if equal(Recursive,recursive) then
    DoRecursiveCloseModule(ModuleName, Status?)
  else 
    SoftCloseModuleInDB(ModuleName, Status?)
  fi.
  if not(equal(Status, success)) then
    snd-note(ui-status(errorf("Module %s not closed because other modules depend on it", [ModuleName])))
  else
    DrawImportGraph()
  fi
endlet


process DoRecursiveCloseModule(ModuleName : str, Status : term?) is
let
  TransitiveImports : list,
  Runner : list,
  StillNeededModules : list,
  Import : str,
  ToBeClosed : list
in
  snd-msg(get-all-imported-module-names(ModuleName)) .
  rec-msg(all-imported-module-names(TransitiveImports?)) .
  GetNeededModules(TransitiveImports, StillNeededModules?) .
  ToBeClosed := diff(TransitiveImports, StillNeededModules) .
  if not(equal(ToBeClosed, [])) then
    Import := first(ToBeClosed) .
    ToBeClosed := next(ToBeClosed) .
    HardCloseModuleInDB(Import)
  fi *
  if equal(ToBeClosed, []) then
    snd-msg(is-module-in-db(ModuleName)) .
    (
      rec-msg(not-exists-in-module-db(ModuleName)) .
      Status := success
    +
      rec-msg(exists-in-module-db(ModuleName)) .
      Status := module-not-closed
    )
  fi
endlet

process GetNeededModules(Modules : list, Needed : list?) is
let
  Runner : list,
  Head : str,
  Depending : list
in
  Needed := [] .
  Runner := Modules .
  if not(equal(Runner, [])) then
    Head := first(Runner) .
    Runner := next(Runner) .
    MDB-GetAllDependingModules(Head, Depending?) .
    if not(subset(Depending, Modules)) then
       Needed := join(Head, Needed) 
    else
       tau
    fi
  fi *
  if equal(Runner, []) then
    tau
  fi
endlet  

process RevertModule(Modulename : str) is
  CloseModuleInDBandInvalidateDependingModules(Modulename)
  . OpenModules([Modulename], sdf)
  . DrawImportGraph()
  . snd-msg(module-reverted(Modulename))

process DoDeleteModule(ModuleName : str) is
let
  Directories : list,
  Changed : list,
  Path : str,
  Extension : str,
  Status : term
in
    snd-msg(get-search-paths) . 
    rec-msg(search-paths(Directories?)) .
    snd-msg(file-extension-hook(sdf)) .
    rec-msg(file-extension-hook-result(Extension?)) .
    snd-msg(get-path-from-db(ModuleName)) .
    ( 
      rec-msg(path(Path?)) .
      RemoveModuleFromDisk(Path, ModuleName, Status?)
    +
      rec-msg(no-path)
    ) .
    DeleteSessions(ModuleName).
    snd-msg(delete-module-from-db(ModuleName)) .
    rec-msg(changed-modules(Changed?)) .
    SaveSdfModules(Changed, Status?) .
    DrawImportGraph()
endlet

process DoRenameModule(Old : str, New : str, Path : str) is
let
  Status : term,
  Changed : list,
  RealNew : str,
  RealPath : str,
  OldPath : str
in
  Status := success.
  GetRealModuleName(New, Path, Status?, RealNew?, RealPath?).
  snd-msg(get-path-from-db(Old)) .
  rec-msg(path(OldPath?)) .
  if equal(Status, success) then
    CheckExistence(RealNew, RealPath, Status?).
    if equal(Status, success) then
      DeleteSessions(Old). 
      if equal(Status, success) then
        RenameModuleInDB(Old, RealNew, RealPath, Changed?) .
        SaveSdfModules(Changed, Status?).
	if equal(Status, success) then
	  SaveAsfSdfModule(RealNew, Status?). 
	  if equal(Status, success) then
	    RemoveModuleFromDisk(OldPath, Old, Status?)
          else 
            RenameModuleInDB(RealNew, Old, RealPath, Changed?) .
            SaveSdfModules(Changed, Status?)
          fi
	else 
          RenameModuleInDB(RealNew, Old, RealPath, Changed?) .
          SaveSdfModules(Changed, Status?)
	fi
      else tau fi
    else tau fi
  else tau fi.
  HandleRenameModuleErrors(Old, RealNew, Status)
endlet

process CreateModule(Pid: int, Directory: str, Filename: str, Type: term) is
let
  BaseDir: str,
  Contents: list,
  Error: term,
  Extension: str,
  ModuleId: str,
  Path: str,
  SearchPaths: list
in
  snd-msg(get-search-paths)
  . rec-msg(search-paths(SearchPaths?))
  . snd-msg(sm-get-new-module-name(SearchPaths, Directory, Filename))
  .
  (
    rec-msg(sm-new-module-name(BaseDir?, ModuleId?))
    . snd-msg(is-module-in-db(ModuleId))
    .
    (
      rec-msg(exists-in-module-db(ModuleId))
      . snd-note(ui-status(errorf("Module %s already exists", [ModuleId])))
    +
      rec-msg(not-exists-in-module-db(ModuleId))
      . snd-msg(file-extension-hook(Type))
      . rec-msg(file-extension-hook-result(Extension?))
      . BuildPath(BaseDir, ModuleId, Extension, Path?)
      . snd-msg(io-exists-file(Path))
      .
      (
	rec-msg(io-file-exists)
	. snd-note(ui-status(errorf("File %s already exists", [Path])))
      +
	rec-msg(io-file-not-exists)
	. snd-msg(get-module-contents(Pid, ModuleId))
	. rec-msg(module-contents(Pid, Contents?))
	. snd-msg(io-write-text-file(Path, Contents))
	.
	(
	  rec-msg(io-file-written)
	  . OpenModule(Path, Type)
	+
	  rec-msg(io-file-not-written(Error?))
	  . snd-note(ui-status(errorf("%s: %s", [Path, Error])))
	)
      )
    )
  +
    rec-msg(sm-new-module-name-inconsistent)
    . snd-note(ui-status(errorf(
      "Module %s in %s is inconsistent with search paths", [ModuleId, Path])))
  )
endlet

process CopySdfModule(SrcModuleId: str, Directory: str, Filename: str) is
let
  Id: int,
  Pid: int
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Copying %s to %s", [SrcModuleId, Filename])))
  . create(CopySdfContentHandler(SrcModuleId), Pid?)
  . CreateModule(Pid, Directory, Filename, sdf)
  . snd-note(ui-status(endstat(Id)))
endlet

process CopyAsfModule(SrcModuleId: str, Directory: str, Filename: str) is
let
  DestPath: str,
  Error: str,
  Extension: str,
  SrcPath: str
in
  LocateFile(SrcModuleId, asf, SrcPath?)
  . snd-msg(io-exists-file(SrcPath))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(file-extension-hook(asf))
    . rec-msg(file-extension-hook-result(Extension?))
    . BuildPath(Directory, Filename, Extension, DestPath?)
    . snd-msg(io-exists-file(DestPath))
    .
    (
      rec-msg(io-file-exists)
      . Error("Refusing to overwrite existing file: %s", [DestPath])
    +
      rec-msg(io-file-not-exists)
      . snd-msg(io-copy-file(SrcPath, DestPath))
      .
      (
	rec-msg(io-file-copied(SrcPath, DestPath))
      +
	rec-msg(io-file-not-copied(SrcPath, DestPath, Error?))
	. Error("Unable to copy: %s", [Error])
      )
    )
  +
    rec-msg(io-file-not-exists)
  )
endlet

process CopySdfContentHandler(SrcModuleId: str) is
let
  Contents: str,
  DestModuleId: str,
  Pid: int,
  Syntax: term
in
  Pid := process-id
  . rec-msg(get-module-contents(Pid, DestModuleId?))
  . snd-msg(ts-get-term-value("sdf-tree", SrcModuleId))
  . rec-msg(ts-value(Syntax?))
  . snd-msg(sm-rename-modulename-in-module(Syntax, DestModuleId))
  . rec-msg(sm-modulename-renamed-in-module(Syntax?))
  . snd-msg(unparse(Syntax))
  . rec-msg(unparsed-text(Contents?))
  . snd-msg(module-contents(Pid, [Contents]))
endlet

process DoImportModule(Mod : str, RealImport : str)  is
let
  Status : term
in
  DeleteEditorAndInvalidateDependingModules(Mod). 
  AddImportInDB(Mod, RealImport).
  SaveAsfSdfModule(Mod, Status?) 
endlet  

process DoUnimportModule(Mod : str, RealImport : str) is
let
  Status : term
in
  DeleteEditorAndInvalidateDependingModules(Mod). 
  RemoveImportInDB(Mod, RealImport) .
  SaveAsfSdfModule(Mod, Status?)
endlet  

process GetRealModuleName(Name : str, Path : str, Status : term?,
                          RealName : str?, RealPath : str?)
is
let
  ErrMsg : str,
  Paths : list
in
  Status := success .
  snd-msg(get-search-paths) .
  rec-msg(search-paths(Paths?)) .
  snd-msg(sm-get-new-module-name(Paths, Path, Name)) .
  (
    rec-msg(sm-new-module-name(RealPath?, RealName?)) 
  +
    rec-msg(sm-new-module-name-inconsistent) .
    Status := module-name-inconsistent .
    RealName := "" .
    RealPath := ""
  )
endlet

process SaveSdfModules(Modules : list, Status : term?) is
let
  Runner : list,
  Module : str
in
  Runner := Modules.
  if not-equal(Runner, []) then
    Module := first(Runner) .
    snd-msg(save-module(Module, sdf)) .
    rec-msg(saved-module(Module, Status?)) .
    Runner := next(Runner)
  fi * 
  if equal(Runner, []) then
    tau
  fi
endlet

process SaveAsfSdfModule(Module : str, Status : term?) is
   snd-msg(save-module(Module, asfsdf)) .
   rec-msg(saved-module(Module, Status?))

process RemoveModuleFromDisk(Path : str, Module : str, Status : term?) is
let
  Extension : str,
  Error : str
in
  snd-msg(file-extension-hook(sdf)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-remove-file(Path, Module, Extension)) .
  (
    rec-msg(io-file-removed(Path, Module, Extension)) .
    snd-msg(file-extension-hook(asf)) .
    rec-msg(file-extension-hook-result(Extension?)) .
    snd-msg(io-remove-file(Path, Module, Extension)) .
    (
      rec-msg(io-file-removed(Path, Module, Extension)) 
    +
      rec-msg(io-file-not-removed(Path, Module, Extension, Error?)) 
      /* error ignored because there does not have to be a asf file
       * TODO: do not try to delete a non-existing file */
    )
  +
    rec-msg(io-file-not-removed(Path, Module, Extension, Error?)) .
    Status := remove-error .
    snd-note(ui-status(errorf("Could not remove file: %s", [Error])))
  )
endlet

process SoftCloseModuleInDB(ModuleName : str, Status : term?) is
let 
  Depending : list,
  Changed : list
in
  snd-msg(get-all-depending-modules(ModuleName)).
  rec-msg(all-depending-modules(Depending?)).
  if equal(Depending,[]) then
    HardCloseModuleInDB(ModuleName).
    Status := success
  else
    Status := modules-depend-on-this-module
  fi
endlet

process HardCloseModuleInDB(ModuleName : str) is
let
  Changed : list
in
  DeleteSessions(ModuleName).
  snd-msg(close-module-in-db(ModuleName)).
  rec-msg(changed-modules(Changed?))
endlet

process CloseModuleInDBandInvalidateDependingModules(ModuleName : str) is
let
  Changed : list
in
  DeleteEditorAndInvalidateDependingModules(ModuleName).
  snd-msg(close-module-in-db(ModuleName)).
  rec-msg(changed-modules(Changed?)) 
endlet

  
process RenameModuleInDB(Old : str, New : str, Path : str, Changed : list?)
is
  snd-msg(rename-module-in-db(Old, New, Path)) .
  rec-msg(renaming-module-done(Old, Changed?)) 

process CopyModuleInDB(Old : str, New : str, Path : str)
is
  snd-msg(copy-module-in-db(Old, New, Path)) .
  rec-msg(copy-module-done(Old))

process AddImportInDB(Mod : str, Import : str)
is
  snd-msg(add-import-in-db(Mod, Import)) .
  rec-msg(add-import-done(Mod))

process RemoveImportInDB(Mod : str, Import : str)
is
  snd-msg(remove-import-in-db(Mod, Import)) .
  rec-msg(remove-import-done)

process CheckExistence(Name : str, Path : str, Status : term?) is
let
  FileName : str,
  Extension : str
in
  snd-msg(is-module-in-db(Name)) .
  (
    rec-msg(exists-in-module-db(Name)).
    Status := module-exists-in-db
  +
    rec-msg(not-exists-in-module-db(Name))
  ).
  snd-msg(file-extension-hook(sdf)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-get-filename(Name, Path, Extension)) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-exists-file(FileName)) .
  (
    rec-msg(io-file-exists) .
    Status := module-exists-on-disk
  +
    rec-msg(io-file-not-exists)
  )
endlet

process DeleteEditorAndInvalidateDependingModules(Modulename: str) is
let
  Depending: list
in
  DeleteSessions(Modulename)
  . snd-msg(get-all-depending-modules(Modulename))
  . rec-msg(all-depending-modules(Depending?))
  . MDB-InvalidateModules(Depending, sdf)
  . snd-msg(notify-about-changed-modules(Depending, sdf))
  . rec-msg(notify-about-changed-modules-done)
endlet

process DeleteEditorsForModulename(Modulename: str) is
let
  Depending : list,
  Mod : str
in
  DeleteSessions(Modulename)
  . snd-msg(get-all-depending-modules(Modulename))
  . rec-msg(all-depending-modules(Depending?))
  . if not-equal(Depending, []) then
    Mod := first(Depending)
    . DeleteSessions(Mod)
    . Depending := next(Depending)
  fi * 
  if equal(Depending, []) then
    tau
  fi 
endlet

process HandleRenameModuleErrors(Old : str, New : str, Status : term) is
  if not-equal(Status, success) then
    snd-note(ui-status(errorf("Error during renaming of %s to %s: %s\n", 
                            [Old, New, Status])))
  else
    tau
  fi

process HandleCopyModuleErrors(Old : str, New : str, Status : term) is
  if not-equal(Status, success) then
    snd-note(ui-status(errorf("Error during copying of %s to %s: %s\n", 
                            [Old, New, Status])))
  else
    tau
  fi

process CheckSyntaxConsistency(ModuleName : str, Path : str) is
let
  ErrorMessage : str,
  FileName : str,
  FileText : str,
  RepositoryText : str,
  Tree : term,
  DependingModules : list,
  Imports : list,
  Error : term,
  Extension : str,
  Type : term
in
  Type := quote(sdf) .
  snd-msg(file-extension-hook(Type)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-get-filename(Path, ModuleName, Extension)) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-exists-file(FileName)) . 
  (
    rec-msg(io-file-exists) .
    snd-msg(io-read-file(FileName)) . 
    rec-msg(io-file-contents(FileText?)) .
    snd-msg(update-module-text-in-db(ModuleName, FileText, no-tree, Type)) .
    (
      rec-msg(no-updating-needed)
    +
      rec-msg(updating-succeeded(DependingModules?)) .
      /*Parse-Syntax(FileText, Type, Tree?, Error?) .*/
      printf("this bites\n").
      if equal(Error, no-errors) then
        snd-msg(update-module-in-db(ModuleName, Tree, Type)) .
	(
          rec-msg(updating-succeeded(Imports?)).
          OpenModules(Imports, Type) .
	  DrawImportGraph()
        +
	  rec-msg(error-opening(ModuleName, name-inconsistent)) .
          Error("Check consistency: module name %s contains an error", [ModuleName])
        )
      else
        printf("CheckSyntaxConsistency: error ignored: %t\n", Error)
      fi
    )
  +
    rec-msg(io-file-not-exists) .
    snd-msg(close-module-in-db(ModuleName)) .
    rec-msg(changed-modules(DependingModules?))
  )
endlet

process CheckEquationConsistency(ModuleName : str, Path : str) is
let
  FileName : str,
  FileText : str,
  RepositoryText : str,
  Extension : str
in
  snd-msg(file-extension-hook(asf)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-get-filename(Path, ModuleName, Extension)) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-exists-file(FileName)) . 
  (
    rec-msg(io-file-exists) .
    snd-msg(io-read-file(FileName)) . 
    rec-msg(io-file-contents(FileText?)) .
    snd-msg(update-eqs-text-in-db(ModuleName, FileText)) .
    rec-msg(eqs-text-updated(ModuleName))
  +
    rec-msg(io-file-not-exists) .
    snd-msg(get-eqs-text(ModuleName)) .
    (
      rec-msg(eqs-text(ModuleName, RepositoryText?)) .
      snd-msg(remove-eqs-from-db(ModuleName)) .
      rec-msg(eqs-removed-from-db)
    +
      rec-msg(no-eqs-text(ModuleName))
    )
  )
endlet

process CheckModuleConsistency(ModuleName : str) is
let
  Path : str
in
  snd-msg(get-path-from-db(ModuleName)) .
  rec-msg(path(Path?)) .
  CheckSyntaxConsistency(ModuleName, Path) .
  CheckEquationConsistency(ModuleName, Path)
endlet

process InitializeTermStore(Name : str) is
  if not-equal(Name, "") then
    snd-msg(register-termstore-name(Name)) .
    rec-msg(termstore-name-registered) .
    TermStoreActivation
  else
    tau
  fi

process TermStoreActivation is
let
  TermStoreContents : term,
  ErrorMessage : str,
  ModuleNames : list,
  ModuleName : str,
  Name : str,
  Id : int
in
  Id := process-id.
  snd-msg(get-termstore-name) .
  rec-msg(termstore-name(Name?)) .
  snd-msg(io-exists-file(Name)) .
  (
    rec-msg(io-file-exists) .
    snd-note(ui-status(stat(Id, "Retrieving saved term-store"))) .
    snd-msg(io-read-packed-term-file(Name)) .
    (
      rec-msg(io-file-contents(TermStoreContents?)) .
      snd-msg(ts-load-snapshot(TermStoreContents)) .
      rec-msg(ts-snapshot-loaded) .
      snd-msg(get-all-module-names) .
      rec-msg(all-module-names(ModuleNames?)) .
      snd-note(ui-status(stat(Id, "Checking consistency of term-store content"))) .
      if not-equal(ModuleNames, []) then
        ModuleName := first(ModuleNames) .
        ModuleNames := next(ModuleNames) .
        CheckModuleConsistency(ModuleName)
      fi *
      if equal(ModuleNames, []) then
        tau
      fi .
      snd-note(ui-status(endstat(Id))) .
      DrawImportGraph()
    +
      rec-msg(io-error-reading(ErrorMessage?))
    ) .
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(io-file-not-exists) .
    snd-note(ui-status(errorf("Termstore %s does not exist!", [Name])))
  )
endlet

process TermStoreName is
let
  TermStoreName : str
in
  TermStoreName := "meta.termstore" .
  (
    rec-msg(register-termstore-name(TermStoreName?)) .
    snd-msg(termstore-name-registered)
  +
    rec-msg(get-termstore-name) .
    snd-msg(termstore-name(TermStoreName)) 
  )*delta
endlet
