#include <module-manager.tb>

process CloseModule(ModuleId: term, Recursive: bool) is
let
  Dependencies: list,
  Id: int,
  Modulename: str,
  CloseModules: list,
  NewTerm: term
in
  Id := process-id
  . MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
  .
  if equal(Recursive, true) then
    MM-GetClosableModules(ModuleId, CloseModules?)
    .
    if equal(CloseModules, []) then
      Error("Unable to close %s, it would break some import(s).", [Modulename])
    else
      CloseModules(CloseModules)
    fi
  else
    MM-GetModuleDependencies(ModuleId, Dependencies?)
    .
    if equal(Dependencies, []) then
      CloseModules([ModuleId])
    else
      Error("Unable to close %s, it would break the import of: %t",
            [Modulename, Dependencies])
    fi
  fi
endlet

process CloseModules(CloseModules: list) is
let
  ModuleId: term,
  Modules: list
in
  Modules := quote(CloseModules)
  . TODO("why quote previous statement")
  .
  if not-equal(Modules, []) then
    ModuleId := first(Modules)
    . DeleteSessions(ModuleId)
    . MM-DeleteModule(ModuleId)
    . Modules := next(Modules)
  fi
  *
  if equal(Modules, []) then
    tau
  fi
endlet

process DeleteModule(Modulename: str) is
let
  Changed: list,
  Id: int,
  Path: str,
  Extension: str,
  Status: term
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Deleting %s", [Modulename])))
  . snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(get-path-from-db(Modulename))
  .
  (
    rec-msg(path(Path?))
    . RemoveModuleFromDisk(Path, Modulename)
  +
    rec-msg(no-path)
  )
  . DeleteSessions(Modulename)
  . snd-msg(delete-module-from-db(Modulename))
  . rec-msg(changed-modules(Changed?))
  . SaveSdfModules(Changed, Status?)
  . snd-note(ui-status(endstat(Id)))
endlet

process RenameModule(Modulename: str, Directory: str, Filename: str) is
let
  Extension: str,
  Id: int,
  NewModule: str,
  Path: str
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Renaming %s", [Modulename])))
  . CopySdfModule(Modulename, Directory, Filename)
  . CopyAsfModule(Modulename, Directory, Filename)
  . snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Filename, Extension, Path?)
  /*. GetModuleForPath(Path, NewModule?)*/
  . RenameImports(Modulename, NewModule)
  . DeleteModule(Modulename)
  . snd-note(ui-status(endstat(Id)))
endlet

process CreateNewModule(Pid: int, Directory: str, Filename: str, Type: term) is
let
  BaseDir: str,
  Contents: list,
  Error: term,
  Extension: str,
  ModuleId: term,
  Modulename: str,
  Path: str,
  SearchPaths: list
in
  snd-msg(get-module-paths)
  . rec-msg(module-paths(SearchPaths?))
  . snd-msg(sm-get-new-module-name(SearchPaths, Directory, Filename))
  .
  (
    rec-msg(sm-new-module-name(BaseDir?, Modulename?))
    . MM-GetModuleIdByAttribute(SDF_NAMESPACE, "name", Modulename, ModuleId?)
    .
    if equal(ModuleId, UNDEFINED) then
      snd-msg(file-extension-hook(Type))
      . rec-msg(file-extension-hook-result(Extension?))
      . BuildPath(BaseDir, Modulename, Extension, Path?)
      . snd-msg(io-exists-file(Path))
      .
      (
        rec-msg(io-file-exists)
        . CancelCreateNewModule(Pid, "File %s already exists", [Path])
      +
        rec-msg(io-file-not-exists)
        . snd-msg(get-module-contents(Pid, Modulename))
        . rec-msg(module-contents(Pid, Contents?))
        . snd-msg(io-write-text-list(Path, Contents))
        .
        (
          rec-msg(io-file-written)
          . OpenModule(Modulename, ModuleId?)
        +
          rec-msg(io-file-not-written(Error?))
          . snd-note(ui-status(errorf("%s: %s", [Path, Error])))
        )
      )
    else
      CancelCreateNewModule(Pid, "Module %s already exists", [Modulename])
    fi
  +
    rec-msg(sm-new-module-name-inconsistent)
    . CancelCreateNewModule(Pid,
                         "Module %s in %s is inconsistent with module paths",
                         [Modulename, Path])
  )
endlet

process CancelCreateNewModule(Pid: int, Error: str, Args: list) is
  snd-note(ui-status(errorf(Error, Args)))
  . snd-msg(cancel-content-handler(Pid))

process CopySdfModule(SrcModulename: str, Directory: str, Filename: str) is
let
  Id: int,
  Pid: int
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Copying %s to %s", [SrcModulename, Filename])))
  . create(CopySdfContentHandler(SrcModulename), Pid?)
  . CreateNewModule(Pid, Directory, Filename, sdf)
  . snd-note(ui-status(endstat(Id)))
endlet

process CopyAsfModule(SrcModulename: str, Directory: str, Filename: str) is
let
  DestPath: str,
  Error: str,
  Extension: str,
  SrcPath: str
in
  LocateFile(SrcModulename, asf, SrcPath?)
  . snd-msg(io-exists-file(SrcPath))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(file-extension-hook(asf))
    . rec-msg(file-extension-hook-result(Extension?))
    . BuildPath(Directory, Filename, Extension, DestPath?)
    . snd-msg(io-exists-file(DestPath))
    .
    (
      rec-msg(io-file-exists)
      . Error("Refusing to overwrite existing file: %s", [DestPath])
    +
      rec-msg(io-file-not-exists)
      . snd-msg(io-copy-file(SrcPath, DestPath))
      .
      (
        rec-msg(io-file-copied(SrcPath, DestPath))
      +
        rec-msg(io-file-not-copied(SrcPath, DestPath, Error?))
        . Error("Unable to copy: %s", [Error])
      )
    )
  +
    rec-msg(io-file-not-exists)
  )
endlet

process CopySdfContentHandler(SrcModulename: str) is
let
  Contents: str,
  DestModulename: str,
  Pid: int,
  Syntax: term
in
  Pid := process-id
  .
  (
    rec-msg(get-module-contents(Pid, DestModulename?))
    . snd-msg(ts-get-term-value("sdf-tree", SrcModulename))
    . rec-msg(ts-value("sdf-tree", SrcModulename, Syntax?))
    . snd-msg(sm-rename-modulename-in-module(Syntax, DestModulename))
    . rec-msg(sm-modulename-renamed-in-module(Syntax?))
    . snd-msg(unparse(Syntax))
    . rec-msg(unparsed-text(Contents?))
    . snd-msg(module-contents(Pid, [Contents]))
  +
    rec-msg(cancel-content-handler(Pid))
  )
endlet

#ifdef DEAD 
process AddImport(Modulename: str, Import: str) is
let
  Depending: list,
  Status: term
in
  DeleteSessions(Modulename)
  . GetDependingModules(Modulename, Depending?)
  . MDB-InvalidateModules(Depending, sdf)
  . AddImportInDB(Modulename, Import)
  . SaveAsfSdfModule(Modulename, Status?)
endlet

process RemoveImport(Modulename: str, Import: str) is
let
  Depending: list,
  Status: term
in
  DeleteSessions(Modulename)
  . GetDependingModules(Modulename, Depending?)
  . MDB-InvalidateModules(Depending, sdf)
  . RemoveImportInDB(Modulename, Import)
  . SaveAsfSdfModule(Modulename, Status?)
endlet
#endif

process SaveSdfModules(Modules: list, Status: term?) is
let
  Runner: list,
  Module: str
in
  Runner := Modules
  .
  if not-equal(Runner, []) then
    Module := first(Runner)
    . snd-msg(save-module(Module, sdf))
    . rec-msg(saved-module(Module, Status?))
    . Runner := next(Runner)
  fi
  *
  if equal(Runner, []) then
    tau
  fi
endlet

process SaveAsfSdfModule(Modulename: str, Status: term?) is
  snd-msg(save-module(Modulename, asfsdf))
  . rec-msg(saved-module(Modulename, Status?))

process RemoveModuleFromDisk(Directory: str, Modulename: str) is
let
  Extension: str,
  Path: str
in
  snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Modulename, Extension, Path?)
  . RemoveFile(Path)
  . snd-msg(file-extension-hook(asf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Modulename, Extension, Path?)
  . snd-msg(io-exists-file(Path))
  .
  (
    rec-msg(io-file-exists)
    . RemoveFile(Path)
  +
    rec-msg(io-file-not-exists)
  )
endlet

process RenameImports(OldImport: str, NewImport: str) is
let
  ImportRelations: list,
  ModuleId: str,
  Depending: list
in
  snd-msg(ts-get-key-value-pairs("import-relations"))
  . rec-msg(ts-pairs("import-relations", ImportRelations?))
  . snd-msg(sm-get-depending-module-names(ImportRelations, OldImport))
  . rec-msg(sm-depending-module-names(Depending?))
  .
  if not-equal(Depending, []) then
    ModuleId := first(Depending)
    . RenameImport(ModuleId, OldImport, NewImport)
    . Depending := next(Depending)
  fi
  *
  if equal(Depending, []) then
    tau
  fi
endlet

process RenameImport(Modulename: str, OldImport: str, NewImport: str) is
let
  Status: term,
  Tree: term
in
  snd-msg(ts-get-term-value("sdf-tree", Modulename))
  . rec-msg(ts-value("sdf-tree", Modulename, Tree?))
  . snd-msg(sm-remove-import-from-module(Tree, OldImport))
  . rec-msg(sm-import-removed-from-module(Tree?))
  . snd-msg(sm-add-import-to-module(Tree, NewImport))
  . rec-msg(sm-import-added-to-module(Tree?))
  /* . MDB-StoreModuleTree(Modulename, Tree) dead */
  . snd-msg(save-module(Modulename, sdf))
  . rec-msg(saved-module(Modulename, Status?))
endlet

process AddImportInDB(Modulename: str, Import: str) is
  snd-msg(add-import-in-db(Modulename, Import))
  . rec-msg(add-import-done(Modulename))

process RemoveImportInDB(Modulename: str, Import: str) is
  snd-msg(remove-import-in-db(Modulename, Import))
  . rec-msg(remove-import-done)

process CheckSyntaxConsistency(Modulename: str, Path: str, Type: term) is
let
  Filename: str,
  FileText: str,
  Tree: term,
  DependingModules: list,
  Imports: list,
  Error: term,
  Extension: str
in
  snd-msg(file-extension-hook(Type))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-get-filename(Path, Modulename, Extension))
  . rec-msg(io-filename(Filename?))
  . snd-msg(io-exists-file(Filename))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(io-read-file(Filename))
    .
    (
      rec-msg(io-file-contents(FileText?))
      . snd-msg(update-module-text-in-db(Modulename, FileText, UNDEFINED, Type))
      .
      (
	rec-msg(no-updating-needed)
      +
	rec-msg(updating-succeeded(DependingModules?))
	. printf("this bites\n")
	.
	if equal(Error, no-errors) then
	  snd-msg(update-module-in-db(Modulename, Tree, Type))
	  .
	  (
	    rec-msg(updating-succeeded(Imports?))
	    /*. OpenModules(Imports, Type)*/
	  +
	    rec-msg(error-opening(Modulename, name-inconsistent))
	    . Error("Check consistency: module name %s contains an error",
		    [Modulename])
	  )
	else
	  printf("CheckSyntaxConsistency: error ignored: %t\n", Error)
	fi
      )
    +
      rec-msg(io-error-reading(Error?))
      . printf("TODO: fix this error message %t\n", Error)
      . snd-msg(close-module-in-db(Modulename))
      . rec-msg(module-closed(Modulename))
    )
  +
    rec-msg(io-file-not-exists)
    . snd-msg(close-module-in-db(Modulename))
    . rec-msg(module-closed(Modulename))
  )
endlet

process CheckEquationConsistency(Modulename: str, Path: str) is
let
  Filename: str,
  FileText: str,
  RepositoryText: str,
  Extension: str,
  Error : term
in
  snd-msg(file-extension-hook(asf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-get-filename(Path, Modulename, Extension))
  . rec-msg(io-filename(Filename?))
  . snd-msg(io-exists-file(Filename))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(io-read-file(Filename))
    .
    (
      rec-msg(io-file-contents(FileText?))
      . snd-msg(update-eqs-text-in-db(Modulename, FileText))
      . rec-msg(eqs-text-updated(Modulename))
    +
      rec-msg(io-error-reading(Error?))
      . printf("TODO: fix this error %t\n", Error)
    )
  +
    rec-msg(io-file-not-exists)
    . snd-msg(get-eqs-text(Modulename))
    .
    (
      rec-msg(eqs-text(Modulename, RepositoryText?))
      . snd-msg(remove-eqs-from-db(Modulename))
      . rec-msg(eqs-removed-from-db)
    +
      rec-msg(no-eqs-text(Modulename))
    )
  )
endlet

process CheckModuleConsistency(Modulename: str) is
let
  Directory: str,
  Extension: str,
  Path: str,
  Type: term
in
  snd-msg(get-path-from-db(Modulename))
  . rec-msg(path(Path?))
  . CheckSyntaxConsistency(Modulename, Path, sdf)
  . CheckEquationConsistency(Modulename, Path)
endlet

process InitializeTermStore(Name: str) is
  if not-equal(Name, "") then
    snd-msg(register-termstore-name(Name))
    . rec-msg(termstore-name-registered)
    . TermStoreActivation
  else
    tau
  fi

process TermStoreActivation is
let
  Checking: bool,
  TermStoreContents: term,
  Error: term,
  ModuleNames: list,
  ModuleName: str,
  Name: str,
  Id: int,
  Pairs: list
in
  Id := process-id
  . snd-note(ui-status(start(Id, "Load TermStore")))
  . snd-msg(get-termstore-name)
  . rec-msg(termstore-name(Name?))
  . snd-msg(io-exists-file(Name))
  .
  (
    rec-msg(io-file-exists)
    . snd-note(ui-status(stat(Id, "Retrieving saved term-store")))
    . snd-msg(io-read-term(Name))
    .
    (
      rec-msg(io-term(TermStoreContents?))
      . snd-msg(ts-load-snapshot(TermStoreContents))
      . rec-msg(ts-snapshot-loaded)
      . snd-msg(get-all-module-names)
      . rec-msg(all-module-names(ModuleNames))
      . snd-note(ui-status(stat(Id,
                                "Checking consistency of term-store content")))
      .
      if not-equal(ModuleNames, []) then
        ModuleName := first(ModuleNames)
        . ModuleNames := next(ModuleNames)
        . CheckModuleConsistency(ModuleName)
      fi
      *
      if equal(ModuleNames, []) then
        tau
      fi
    +
      rec-msg(io-error-reading(Error?))
      . printf("TODO: fix this error %t\n", Error)
    )
    . snd-note(ui-status(endstat(Id)))
  +
    rec-msg(io-file-not-exists)
    . snd-note(ui-status(errorf("Termstore %s does not exist!", [Name])))
  )
  . snd-note(ui-status(stop(Id)))
endlet

process TermStoreName is
let
  TermStoreName: str
in
  TermStoreName := "meta.termstore"
  .
  (
    rec-msg(register-termstore-name(TermStoreName?))
    . snd-msg(termstore-name-registered)
  +
    rec-msg(get-termstore-name)
    . snd-msg(termstore-name(TermStoreName))
  )
  *
  delta
endlet

process RemoveFile(Path: str) is
let
  Summary: term
in
  snd-msg(io-remove-file(Path))
  .
  (
    rec-msg(io-file-removed(Path))
  +
    rec-msg(io-file-not-removed(Path, Summary?))
    . snd-msg(ui-show-feedback-summary(Summary))
  )
endlet
