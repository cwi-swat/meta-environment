process CloseModule(ModuleId: str, Recursive: bool) is
let
  Depending: list,
  Id: int,
  ToBeClosed: list
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Closing %s", [ModuleId])))
  .
  if equal(Recursive, quote(true)) then
    ComputeModulesToBeClosed(ModuleId, ToBeClosed?)
    .
    if equal(ToBeClosed, []) then
      Error("Unable to close %s, it would break some import(s).", [ModuleId])
    else
      CloseModules(ToBeClosed)
    fi
  else
    GetDependingModules(ModuleId, Depending?)
    .
    if equal(Depending, []) then
      CloseModules([ModuleId])
    else
      Error("Unable to close %s, it would break the import of: %t",
            [ModuleId, Depending])
    fi
  fi
  . snd-note(ui-status(endstat(Id)))
endlet

process CloseModules(ToBeClosed: list) is
let
  ModuleId: str,
  Modules: list
in
  Modules := ToBeClosed
  .
  if not-equal(Modules, []) then
    ModuleId := first(Modules)
    . DeleteSessions(ModuleId)
    . snd-msg(close-module-in-db(ModuleId))
    . rec-msg(module-closed(ModuleId))
    . Modules := next(Modules)
  fi
  *
  if equal(Modules, []) then
    tau
  fi
endlet

process GetDependingModules(ModuleId: str, DependingModules: list?) is
let
  ImportRelations: list
in
  snd-msg(ts-get-key-value-pairs("import-relations"))
  . rec-msg(ts-pairs(ImportRelations?))
  . snd-msg(sm-get-all-depending-module-names(ImportRelations, ModuleId))
  . rec-msg(sm-all-depending-module-names(DependingModules?))
endlet

process ComputeModulesToBeClosed(ModuleId: str, ToBeClosed: list?) is
let
  Depending: list,
  CurModule: str,
  Imports: list,
  Needed: list,
  Runner: list
in
  snd-msg(get-all-imported-module-names(ModuleId))
  . rec-msg(all-imported-module-names(Imports?))
  . Needed := []
  . Runner := Imports
  .
  if not-equal(Runner, []) then
    CurModule := first(Runner)
    . GetDependingModules(CurModule, Depending?)
    . Runner := next(Runner)
    .
    if not(subset(Depending, Imports)) then
      Needed := join(CurModule, Needed)
    else
      tau
    fi
  fi
  *
  if equal(Runner, []) then
    ToBeClosed := diff(Imports, Needed)
  fi
endlet

process DeleteModule(ModuleName: str) is
let
  Directories: list,
  Changed: list,
  Id: int,
  Path: str,
  Extension: str,
  Status: term
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Deleting %s", [ModuleName])))
  . snd-msg(get-module-paths)
  . rec-msg(module-paths(Directories?))
  . snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(get-path-from-db(ModuleName))
  .
  (
    rec-msg(path(Path?))
    . RemoveModuleFromDisk(Path, ModuleName)
  +
    rec-msg(no-path)
  )
  . DeleteSessions(ModuleName)
  . snd-msg(delete-module-from-db(ModuleName))
  . rec-msg(changed-modules(Changed?))
  . SaveSdfModules(Changed, Status?)
  . snd-note(ui-status(endstat(Id)))
endlet

process RenameModule(ModuleId: str, Directory: str, Filename: str) is
let
  Extension: str,
  Id: int,
  NewModule: str,
  Path: str
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Renaming %s", [ModuleId])))
  . CopySdfModule(ModuleId, Directory, Filename)
  . CopyAsfModule(ModuleId, Directory, Filename)
  . snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Filename, Extension, Path?)
  . GetModuleForPath(Path, NewModule?)
  . RenameImports(ModuleId, NewModule)
  . DeleteModule(ModuleId)
  . snd-note(ui-status(endstat(Id)))
endlet

process CreateModule(Pid: int, Directory: str, Filename: str, Type: term) is
let
  BaseDir: str,
  Contents: list,
  Error: term,
  Extension: str,
  ModuleId: str,
  Path: str,
  SearchPaths: list
in
  snd-msg(get-module-paths)
  . rec-msg(module-paths(SearchPaths?))
  . snd-msg(sm-get-new-module-name(SearchPaths, Directory, Filename))
  .
  (
    rec-msg(sm-new-module-name(BaseDir?, ModuleId?))
    . snd-msg(is-module-in-db(ModuleId))
    .
    (
      rec-msg(exists-in-module-db(ModuleId))
      . CancelCreateModule(Pid, "Module %s already exists", [ModuleId])
    +
      rec-msg(not-exists-in-module-db(ModuleId))
      . snd-msg(file-extension-hook(Type))
      . rec-msg(file-extension-hook-result(Extension?))
      . BuildPath(BaseDir, ModuleId, Extension, Path?)
      . snd-msg(io-exists-file(Path))
      .
      (
        rec-msg(io-file-exists)
        . CancelCreateModule(Pid, "File %s already exists", [Path])
      +
        rec-msg(io-file-not-exists)
        . snd-msg(get-module-contents(Pid, ModuleId))
        . rec-msg(module-contents(Pid, Contents?))
        . snd-msg(io-write-text-list(Path, Contents))
        .
        (
          rec-msg(io-file-written)
          . OpenModule(Path, Type, ModuleId)
        +
          rec-msg(io-file-not-written(Error?))
          . snd-note(ui-status(errorf("%s: %s", [Path, Error])))
        )
      )
    )
  +
    rec-msg(sm-new-module-name-inconsistent)
    . CancelCreateModule(Pid,
                         "Module %s in %s is inconsistent with module paths",
                         [ModuleId, Path])
  )
endlet

process CancelCreateModule(Pid: int, Error: str, Args: list) is
  snd-note(ui-status(errorf(Error, Args)))
  . snd-msg(cancel-content-handler(Pid))

process CopySdfModule(SrcModuleId: str, Directory: str, Filename: str) is
let
  Id: int,
  Pid: int
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Copying %s to %s", [SrcModuleId, Filename])))
  . create(CopySdfContentHandler(SrcModuleId), Pid?)
  . CreateModule(Pid, Directory, Filename, sdf)
  . snd-note(ui-status(endstat(Id)))
endlet

process CopyAsfModule(SrcModuleId: str, Directory: str, Filename: str) is
let
  DestPath: str,
  Error: str,
  Extension: str,
  SrcPath: str
in
  LocateFile(SrcModuleId, asf, SrcPath?)
  . snd-msg(io-exists-file(SrcPath))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(file-extension-hook(asf))
    . rec-msg(file-extension-hook-result(Extension?))
    . BuildPath(Directory, Filename, Extension, DestPath?)
    . snd-msg(io-exists-file(DestPath))
    .
    (
      rec-msg(io-file-exists)
      . Error("Refusing to overwrite existing file: %s", [DestPath])
    +
      rec-msg(io-file-not-exists)
      . snd-msg(io-copy-file(SrcPath, DestPath))
      .
      (
        rec-msg(io-file-copied(SrcPath, DestPath))
      +
        rec-msg(io-file-not-copied(SrcPath, DestPath, Error?))
        . Error("Unable to copy: %s", [Error])
      )
    )
  +
    rec-msg(io-file-not-exists)
  )
endlet

process CopySdfContentHandler(SrcModuleId: str) is
let
  Contents: str,
  DestModuleId: str,
  Pid: int,
  Syntax: term
in
  Pid := process-id
  .
  (
    rec-msg(get-module-contents(Pid, DestModuleId?))
    . snd-msg(ts-get-term-value("sdf-tree", SrcModuleId))
    . rec-msg(ts-value(Syntax?))
    . snd-msg(sm-rename-modulename-in-module(Syntax, DestModuleId))
    . rec-msg(sm-modulename-renamed-in-module(Syntax?))
    . snd-msg(unparse(Syntax))
    . rec-msg(unparsed-text(Contents?))
    . snd-msg(module-contents(Pid, [Contents]))
  +
    rec-msg(cancel-content-handler(Pid))
  )
endlet

process AddImport(ModuleId: str, Import: str) is
let
  Depending: list,
  Status: term
in
  DeleteSessions(ModuleId)
  . GetDependingModules(ModuleId, Depending?)
  . MDB-InvalidateModules(Depending, sdf)
  . AddImportInDB(ModuleId, Import)
  . SaveAsfSdfModule(ModuleId, Status?)
endlet

process RemoveImport(ModuleId: str, Import: str) is
let
  Depending: list,
  Status: term
in
  DeleteSessions(ModuleId)
  . GetDependingModules(ModuleId, Depending?)
  . MDB-InvalidateModules(Depending, sdf)
  . RemoveImportInDB(ModuleId, Import)
  . SaveAsfSdfModule(ModuleId, Status?)
endlet

process SaveSdfModules(Modules: list, Status: term?) is
let
  Runner: list,
  Module: str
in
  Runner := Modules
  .
  if not-equal(Runner, []) then
    Module := first(Runner)
    . snd-msg(save-module(Module, sdf))
    . rec-msg(saved-module(Module, Status?))
    . Runner := next(Runner)
  fi
  *
  if equal(Runner, []) then
    tau
  fi
endlet

process SaveAsfSdfModule(Module: str, Status: term?) is
  snd-msg(save-module(Module, asfsdf))
  . rec-msg(saved-module(Module, Status?))

process RemoveModuleFromDisk(Directory: str, Module: str) is
let
  Extension: str,
  Path: str
in
  snd-msg(file-extension-hook(sdf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Module, Extension, Path?)
  . RemoveFile(Path)
  . snd-msg(file-extension-hook(asf))
  . rec-msg(file-extension-hook-result(Extension?))
  . BuildPath(Directory, Module, Extension, Path?)
  . snd-msg(io-exists-file(Path))
  .
  (
    rec-msg(io-file-exists)
    . RemoveFile(Path)
  +
    rec-msg(io-file-not-exists)
  )
endlet

process RenameImports(OldImport: str, NewImport: str) is
let
  ImportRelations: list,
  ModuleId: str,
  Depending: list
in
  snd-msg(ts-get-key-value-pairs("import-relations"))
  . rec-msg(ts-pairs(ImportRelations?))
  . snd-msg(sm-get-depending-module-names(ImportRelations, OldImport))
  . rec-msg(sm-depending-module-names(Depending?))
  .
  if not-equal(Depending, []) then
    ModuleId := first(Depending)
    . RenameImport(ModuleId, OldImport, NewImport)
    . Depending := next(Depending)
  fi
  *
  if equal(Depending, []) then
    tau
  fi
endlet

process RenameImport(ModuleId: str, OldImport: str, NewImport: str) is
let
  Status: term,
  Tree: term
in
  snd-msg(ts-get-term-value("sdf-tree", ModuleId))
  . rec-msg(ts-value(Tree?))
  . snd-msg(sm-remove-import-from-module(Tree, OldImport))
  . rec-msg(sm-import-removed-from-module(Tree?))
  . snd-msg(sm-add-import-to-module(Tree, NewImport))
  . rec-msg(sm-import-added-to-module(Tree?))
  . MDB-StoreModuleTree(ModuleId, Tree)
  . snd-msg(save-module(ModuleId, sdf))
  . rec-msg(saved-module(ModuleId, Status?))
endlet

process AddImportInDB(Mod: str, Import: str) is
  snd-msg(add-import-in-db(Mod, Import))
  . rec-msg(add-import-done(Mod))

process RemoveImportInDB(Mod: str, Import: str) is
  snd-msg(remove-import-in-db(Mod, Import))
  . rec-msg(remove-import-done)

process CheckSyntaxConsistency(ModuleName: str, Path: str, Type: term) is
let
  FileName: str,
  FileText: str,
  Tree: term,
  DependingModules: list,
  Imports: list,
  Error: term,
  Extension: str
in
  snd-msg(file-extension-hook(Type))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-get-filename(Path, ModuleName, Extension))
  . rec-msg(io-filename(FileName?))
  . snd-msg(io-exists-file(FileName))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(io-read-file(FileName))
    .
    (
      rec-msg(io-file-contents(FileText?))
      . snd-msg(update-module-text-in-db(ModuleName, FileText, no-tree, Type))
      .
      (
	rec-msg(no-updating-needed)
      +
	rec-msg(updating-succeeded(DependingModules?))
	. printf("this bites\n")
	.
	if equal(Error, no-errors) then
	  snd-msg(update-module-in-db(ModuleName, Tree, Type))
	  .
	  (
	    rec-msg(updating-succeeded(Imports?))
	    . OpenModules(Imports, Type)
	  +
	    rec-msg(error-opening(ModuleName, name-inconsistent))
	    . Error("Check consistency: module name %s contains an error",
		    [ModuleName])
	  )
	else
	  printf("CheckSyntaxConsistency: error ignored: %t\n", Error)
	fi
      )
    +
      rec-msg(io-error-reading(Error?))
      . printf("TODO: fix this error message %t\n", Error)
      . snd-msg(close-module-in-db(ModuleName))
      . rec-msg(module-closed(ModuleName))
    )
  +
    rec-msg(io-file-not-exists)
    . snd-msg(close-module-in-db(ModuleName))
    . rec-msg(module-closed(ModuleName))
  )
endlet

process CheckEquationConsistency(ModuleName: str, Path: str) is
let
  FileName: str,
  FileText: str,
  RepositoryText: str,
  Extension: str,
  Error : term
in
  snd-msg(file-extension-hook(asf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-get-filename(Path, ModuleName, Extension))
  . rec-msg(io-filename(FileName?))
  . snd-msg(io-exists-file(FileName))
  .
  (
    rec-msg(io-file-exists)
    . snd-msg(io-read-file(FileName))
    .
    (
      rec-msg(io-file-contents(FileText?))
      . snd-msg(update-eqs-text-in-db(ModuleName, FileText))
      . rec-msg(eqs-text-updated(ModuleName))
    +
      rec-msg(io-error-reading(Error?))
      . printf("TODO: fix this error %t\n", Error)
    )
  +
    rec-msg(io-file-not-exists)
    . snd-msg(get-eqs-text(ModuleName))
    .
    (
      rec-msg(eqs-text(ModuleName, RepositoryText?))
      . snd-msg(remove-eqs-from-db(ModuleName))
      . rec-msg(eqs-removed-from-db)
    +
      rec-msg(no-eqs-text(ModuleName))
    )
  )
endlet


process CheckModuleConsistency(ModuleName: str) is
let
  Directory: str,
  Extension: str,
  Path: str,
  Type: term
in
  snd-msg(get-path-from-db(ModuleName))
  . rec-msg(path(Path?))
  /* Motivation for the do-consistency-check-hook
     How to do consistency check is package dependent. E.g. an ASDF module
     should not be checked the same way as an asf+sdf module. */
  . snd-msg(do-consistency-check-hook(ModuleName, Path))
  . rec-msg(do-consistency-check-hook-result)
endlet

process InitializeTermStore(Name: str) is
  if not-equal(Name, "") then
    snd-msg(register-termstore-name(Name))
    . rec-msg(termstore-name-registered)
    . TermStoreActivation
  else
    tau
  fi


process TermStoreActivation is
let
  Checking: bool,
  TermStoreContents: term,
  Error: term,
  ModuleNames: list,
  ModuleName: str,
  Name: str,
  Id: int,
  Pairs: list
in
  Id := process-id
  . snd-msg(get-termstore-name)
  . rec-msg(termstore-name(Name?))
  . snd-msg(io-exists-file(Name))
  .
  (
    rec-msg(io-file-exists)
    . snd-note(ui-status(stat(Id, "Retrieving saved term-store")))
    . snd-msg(io-read-term(Name))
    .
    (
      rec-msg(io-term(TermStoreContents?))
      . snd-msg(ts-load-snapshot(TermStoreContents))
      . rec-msg(ts-snapshot-loaded)
      /* Motivation for the termstore-consistency-check-hook
         When loading an initial termstore as is the case in the ASDF package,
         we might not need the consistency check. */
      . snd-msg(termstore-consistency-check-hook)
      . rec-msg(termstore-consistency-check-hook-result(Checking?))
      .
      if equal(Checking, quote(true)) then
      /* Motivation for the get-modulenames-for-consistency-checking-hook
         It might not bee all modules, which should be included in an
         consistency check. E.g. if an initial termstore is part of a given
         termstore, one might not want to do consistency check of the modules
         of the initial termstore, because, they should never change doing the
         lifetime of a meta env. distribution. */
	snd-msg(get-modulenames-for-consistency-checking-hook)
	. rec-msg(get-modulenames-for-consistency-checking-hook-result(ModuleNames?))
	. snd-note(ui-status(stat(Id,
                                "Checking consistency of term-store content")))
	.
	if not-equal(ModuleNames, []) then
	  ModuleName := first(ModuleNames)
	  . ModuleNames := next(ModuleNames)
	  . CheckModuleConsistency(ModuleName)
	fi
	*
	if equal(ModuleNames, []) then
	  tau
	fi
	. snd-note(ui-status(endstat(Id)))
      else
        tau
      fi
    +
      rec-msg(io-error-reading(Error?))
      . printf("TODO: fix this error %t\n", Error)
    )
    . snd-note(ui-status(endstat(Id)))
  +
    rec-msg(io-file-not-exists)
    . snd-note(ui-status(errorf("Termstore %s does not exist!", [Name])))
  )
endlet


process TermStoreName is
let
  TermStoreName: str
in
  TermStoreName := "meta.termstore"
  .
  (
    rec-msg(register-termstore-name(TermStoreName?))
    . snd-msg(termstore-name-registered)
  +
    rec-msg(get-termstore-name)
    . snd-msg(termstore-name(TermStoreName))
  )
  *
  delta
endlet

process RemoveFile(Path: str) is
let
  Summary: term
in
  snd-msg(io-remove-file(Path))
  .
  (
    rec-msg(io-file-removed(Path))
  +
    rec-msg(io-file-not-removed(Path, Summary?))
    . snd-msg(ui-show-feedback-summary(Summary))
  )
endlet
