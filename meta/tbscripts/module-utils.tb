/* $Id$ */

process Module-Utilities is
let
  Id : int,
  ModuleName1 : str,
  ModuleName2 : str,
  Extension : str,
  Path : str,
  Type : term,
  Option1 : term
in
  Id := process-id.
  (
    rec-msg(rename-module(ModuleName1?, ModuleName2?, Path?)) .
    snd-note(ui-status(statf(Id, 
             "Renaming %s to %s",[ModuleName1,ModuleName2]))).
    DoRenameModule(ModuleName1, ModuleName2, Path).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(copy-module(ModuleName1?, ModuleName2?, Path?)).
    DoCopyModule(ModuleName1, ModuleName2, Path).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(import-module(ModuleName1?, ModuleName2?, Path?)).
    snd-note(ui-status(statf(Id, 
             "Adding %s to imports of %s",[ModuleName2,ModuleName1]))).
    DoImportModule(ModuleName1, ModuleName2, Path).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(delete-module(ModuleName1?)) .
    snd-note(ui-status(statf(Id, 
             "Deleting %s",[ModuleName1]))).
    DoDeleteModule(ModuleName1).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(unimport-module(ModuleName1?, ModuleName2?, Path?)).
    snd-note(ui-status(statf(Id, 
             "Removing %s from imports of %s",[ModuleName2,ModuleName1]))).
    DoUnimportModule(ModuleName1, ModuleName2, Path).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(revert-module(ModuleName1?, Type?)).
    snd-note(ui-status(statf(Id, "Reverting %s",[ModuleName1]))).
    DoRevertModule(ModuleName1, Type).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(close-module(ModuleName1?, Option1?)).
    snd-note(ui-status(statf(Id, 
             "Closing %s",[ModuleName1]))).
    DoCloseModule(ModuleName1, Option1).
    snd-note(ui-status(endstat(Id)))
  ) *
  delta
endlet

process DoCloseModule(ModuleName : str, Recursive : term) is
let
  Status : term,
  Changed : list
in
  Status := success.
  if equal(Recursive,recursive) then
    DoRecursiveCloseModule(ModuleName, Status?)
  else 
    SoftCloseModuleInDB(ModuleName, Status?).
    if equal(Status,success) then
      CloseModuleInUI(ModuleName)
    else tau fi
  fi.
  if not(equal(Status, success)) then
    snd-note(ui-status(errorf("Module %s not closed because other modules depend on it", [ModuleName])))
  else tau fi
endlet

process DoRecursiveCloseModule(ModuleName : str, Status : term?) is
let
  Imports : list,
  MoreImports : list,
  Closed : list,
  Import : str
in
  Status := success.
  snd-msg(get-imported-modules(ModuleName)).
  rec-msg(imported-modules(Imports?)).
  SoftCloseModuleInDB(ModuleName, Status?).
  if equal(Status, success) then
    CloseModuleInUI(ModuleName).
    Closed := [].
    if not(equal(Imports, [])) then
      Import := first(Imports).
      Imports := next(Imports).
      FilterElement(Import, Imports?).
      snd-msg(get-imported-modules(Import)).
      rec-msg(imported-modules(MoreImports?)).
      SoftCloseModuleInDB(Import, Status?).
      if equal(Status,success) then
        Closed := join(Import, Closed).
        /* continue only if closing succeeded */
        Imports := join(Imports, MoreImports)
      else tau fi
    fi*
    if equal(Imports,[]) then 
      CloseModulesInUI(Closed).
      /* only give error if top module could not be closed */
      Status := success 
    fi
  else tau fi
endlet

process FilterElement(Elem : term, List : list?) is
let
  OldList : list,
  NewList : list,
  Head : term

in
  OldList := List.
  NewList := [].
  if not(equal(OldList,[])) then
    Head := first(OldList).
    OldList := next(OldList).
    if not(equal(Elem,Head)) then
      NewList := join(Head, NewList)
    else tau fi
  fi *
  if equal(OldList,[]) then 
    List := NewList
  fi
endlet

process DoRevertModule(ModuleName : str, Type : term) is
  if equal(Type, syntax-editor) then
    HardCloseModuleInDB(ModuleName).
    snd-msg(open-modules([ModuleName], sdf)) .
    rec-msg(finished-opening-modules).
    snd-msg(module-reverted(ModuleName))
  else
    tau
  fi

process DoDeleteModule(ModuleName : str) is
let
  Directories : list,
  Changed : list,
  Path : str,
  Extension : str
in
    snd-msg(get-search-paths) . 
    rec-msg(search-paths(Directories?)) .
    snd-msg(file-extension-hook(sdf)) .
    rec-msg(file-extension-hook-result(Extension?)) .
    snd-msg(get-path-from-db(ModuleName)) .
    ( 
      rec-msg(path(Path?)) .
      RemoveModuleFromDisk(Path, ModuleName)
    +
      rec-msg(no-path)
    ) .
    DeleteEditors(ModuleName).
    snd-msg(delete-module-from-db(ModuleName)) .
    rec-msg(changed-modules(Changed?)) .
    CloseModuleInUI(ModuleName).
    SaveSdfModules(Changed).
    snd-msg(notify-about-changed-modules(Changed, sdf)) .
    rec-msg(notify-about-changed-modules-done)
endlet

process DoRenameModule(Old : str, New : str, Path : str) is
let
  Status : term,
  Changed : list,
  RealNew : str,
  RealPath : str,
  OldPath : str
in
  Status := success.
  GetRealModuleName(New, Path, Status?, RealNew?, RealPath?).
  snd-msg(get-path-from-db(Old)) .
  rec-msg(path(OldPath?)) .
  if equal(Status, success) then
    CheckExistence(RealNew, RealPath, Status?).
    if equal(Status, success) then
      DeleteEditors(Old). 
      if equal(Status, success) then
        RenameModuleInDB(Old, RealNew, RealPath, Changed?) .
        SaveSdfModules(Changed).
        SaveAsfSdfModule(RealNew). 
        RemoveModuleFromDisk(OldPath, Old)
      else tau fi
    else tau fi
  else tau fi.
  HandleRenameModuleErrors(Old, RealNew, Status)
endlet

process DoCopyModule(Old : str, New : str, Path : str)  is
let
  Status : term,
  Changed : list,
  RealNew : str,
  RealPath : str
in
  Status := success.
  GetRealModuleName(New, Path, Status?, RealNew?, RealPath?).
  if equal(Status, success) then
    CheckExistence(RealNew, RealPath, Status?).
    if equal (Status, success) then
      CopyModuleInDB(Old, RealNew, RealPath).
      SaveAsfSdfModule(RealNew)
    else tau fi
  else tau fi.
  HandleCopyModuleErrors(Old, RealNew, Status) . tau
endlet

process DoImportModule(Mod : str, Import : str, Path : str)  is
let
  Status : term,
  Changed : list,
  RealImport : str,
  RealPath : str
in
  GetRealModuleName(Import, Path, Status?, RealImport?, RealPath?) .
  snd-msg(is-module-in-db(RealImport)) .
  (
    rec-msg(exists-in-module-db(RealImport)) .
    DeleteEditors(Mod). 
    AddImportInDB(Mod, RealImport).
    SaveAsfSdfModule(Mod) 
  +
    rec-msg(not-exists-in-module-db(RealImport)) .
    snd-note(ui-status(
      errorf("Error during adding import %s to %s: module not open", 
             [Import, Mod])))
  )
endlet

process DoUnimportModule(Mod : str, Import : str, Path : str) is
let
  Status : term,
  Changed : list,
  RealImport : str,
  RealPath : str
in
  GetRealModuleName(Import, Path, Status?, RealImport?, RealPath?) .
  snd-msg(is-module-in-db(RealImport)) .
  (
    rec-msg(exists-in-module-db(RealImport)) .
    DeleteEditors(Mod). 
    RemoveImportInDB(Mod, RealImport, RealPath) .
    SaveAsfSdfModule(Mod)
  +
    rec-msg(not-exists-in-module-db(RealImport)) .
    snd-note(ui-status(
      errorf("Error during removing import %s to %s: module not open", 
             [Import, Mod])))
  )
endlet

process GetRealModuleName(Name : str, Path : str, Status : term?,
                          RealName : str?, RealPath : str?)
is
let
  ErrMsg : str,
  Paths : list
in
  Status := success .
  snd-msg(get-search-paths) .
  rec-msg(search-paths(Paths?)) .
  snd-msg(sm-get-new-module-name(Paths, Path, Name)) .
  (
    rec-msg(sm-new-module-name(RealPath?, RealName?)) 
  +
    rec-msg(sm-new-module-name-inconsistent) .
    Status := module-name-inconsistent .
    RealName := "" .
    RealPath := ""
  )
endlet

process SaveSdfModules(Modules : list) is
let
  Runner : list,
  Module : str
in
  Runner := Modules.
  if not-equal(Runner, []) then
    Module := first(Runner) .
    snd-msg(save-sdf-module(Module)) .
    rec-msg(saved-sdf-module(Module)) .
    Runner := next(Runner)
  fi * 
  if equal(Runner, []) then
    tau
  fi
endlet

process SaveAsfSdfModule(Module : str) is
   snd-msg(save-asfsdf-module(Module)) .
   rec-msg(saved-asfsdf-module(Module))

process RemoveModuleFromDisk(Path : str, Module : str) is
let
  Extension : str
in
  snd-msg(file-extension-hook(sdf)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-remove-file(Path, Module, Extension)) .
  rec-msg(io-file-removed) .
  snd-msg(file-extension-hook(asf)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-remove-file(Path, Module, Extension)) .
  rec-msg(io-file-removed)
endlet

process SoftCloseModuleInDB(ModuleName : str, Status : term?) is
let 
  Depending : list,
  Changed : list
in
  snd-msg(get-all-depending-modules(ModuleName)).
  rec-msg(all-depending-modules(Depending?)).
  if equal(Depending,[]) then
    HardCloseModuleInDB(ModuleName).
    Status := success
  else
    Status := modules-depend-on-this-module
  fi
endlet

process HardCloseModuleInDB(ModuleName : str) is
let
  Changed : list
in
  DeleteEditors(ModuleName).
  snd-msg(close-module-in-db(ModuleName)).
  rec-msg(changed-modules(Changed?)).
  snd-msg(notify-about-changed-modules(Changed, sdf)) .
  rec-msg(notify-about-changed-modules-done)
endlet

  
process CloseModuleInUI(ModuleName : str) is
  snd-msg(ui-delete-modules([ModuleName]))

process CloseModulesInUI(Modules : list) is
  snd-msg(ui-delete-modules(Modules))

process RenameModuleInDB(Old : str, New : str, Path : str, Changed : list?)
is
  snd-msg(rename-module-in-db(Old, New, Path)) .
  rec-msg(renaming-module-done(Old, Changed?)) 

process CopyModuleInDB(Old : str, New : str, Path : str)
is
  snd-msg(copy-module-in-db(Old, New, Path)) .
  rec-msg(copy-module-done(Old))

process AddImportInDB(Mod : str, Import : str)
is
  snd-msg(add-import-in-db(Mod, Import)) .
  rec-msg(add-import-done(Mod))

process RemoveImportInDB(Mod : str, Import : str, Path : str)
is
  snd-msg(remove-import-in-db(Mod, Import, Path)) .
  rec-msg(remove-import-done)

process CheckExistence(Name : str, Path : str, Status : term?) is
let
  FileName : str,
  Extension : str
in
    snd-msg(is-module-in-db(Name)) .
    (
      rec-msg(exists-in-module-db(Name)).
      Status := module-exists-in-db
    +
      rec-msg(not-exists-in-module-db(Name))
    ).
    snd-msg(file-extension-hook(sdf)) .
    rec-msg(file-extension-hook-result(Extension?)) .
    snd-msg(io-get-filename(Name, Path, Extension)) .
    rec-msg(io-filename(FileName?)) .
    snd-msg(io-exists-file(FileName)) .
    (
      rec-msg(io-file-exists) .
      Status := module-exists-on-disk
      +
      rec-msg(io-file-not-exists)
    )
endlet

process DeleteEditors(Module : str) is
let
  Depending : list,
  Mod : str
in
  snd-msg(delete-editors-for-module(Module)).
  snd-msg(get-all-depending-modules(Module)) .
  rec-msg(all-depending-modules(Depending?)).
  if not-equal(Depending, []) then
    Mod := first(Depending) .
    snd-msg(delete-editors-for-module(Mod)) .
    Depending := next(Depending)
  fi * 
  if equal(Depending, []) then
    tau
  fi 
endlet

process HandleRenameModuleErrors(Old : str, New : str, Status : term) is
  if not-equal(Status, success) then
    snd-note(ui-status(errorf("Error during renaming of %s to %s: %s\n", 
                            [Old, New, Status])))
  else
    tau
  fi

process HandleCopyModuleErrors(Old : str, New : str, Status : term) is
  if not-equal(Status, success) then
    snd-note(ui-status(errorf("Error during copying of %s to %s: %s\n", 
                            [Old, New, Status])))
  else
    tau
  fi

process CheckSyntaxConsistency(ModuleName : str, Path : str) is
let
  ErrorMessage : str,
  FileName : str,
  FileText : str,
  RepositoryText : str,
  Tree : term,
  DependingModules : list,
  Imports : list,
  Status : term,
  Extension : str,
  Type : term
in
  Type := quote(sdf) .
  snd-msg(file-extension-hook(Type)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-get-filename(Path, ModuleName, Extension)) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-exists-file(FileName)) . 
  (
    rec-msg(io-file-exists) .
    snd-msg(io-read-file(FileName)) . 
    rec-msg(io-file-contents(FileText?)) .
    snd-msg(update-module-text-in-db(ModuleName, FileText, no-tree, Type)) .
    (
      rec-msg(no-updating-needed)
    +
      rec-msg(updating-succeeded(DependingModules?)) .
      Error("Check consistency: syntax of module %s changed on disk", [ModuleName]) .
      Status := success .
      Parse-Syntax(FileText, Type, Status?, Tree?) .
      if equal(Status, success) then
        snd-msg(update-module-in-db(ModuleName, Tree, Type)) .
	(
          rec-msg(updating-succeeded(Imports?)).
          snd-msg(open-modules(Imports, Type)) .
          rec-msg(finished-opening-modules)
        +
	  rec-msg(error-opening(ModuleName, name-inconsistent)) .
          Error("Check consistency: module name %s contains an error", [ModuleName])
        )
      else
        Error("Check consistency: syntax of module %s contains an error", [ModuleName])
      fi
    )
  +
    rec-msg(io-file-not-exists) .
    snd-msg(close-module-in-db(ModuleName)) .
    rec-msg(changed-modules(DependingModules?)) .
    Error("Check consistency: syntax of module %s removed on disk", [ModuleName])
  )
endlet

process CheckEquationConsistency(ModuleName : str, Path : str) is
let
  FileName : str,
  FileText : str,
  RepositoryText : str,
  Extension : str
in
  snd-msg(file-extension-hook(asf)) .
  rec-msg(file-extension-hook-result(Extension?)) .
  snd-msg(io-get-filename(Path, ModuleName, Extension)) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-exists-file(FileName)) . 
  (
    rec-msg(io-file-exists) .
    snd-msg(io-read-file(FileName)) . 
    rec-msg(io-file-contents(FileText?)) .
    snd-msg(update-eqs-text-in-db(ModuleName, text(FileText))) .
    (
      rec-msg(no-updating-needed)
    +
      rec-msg(eqs-text-updated(ModuleName)) .
      Error("Check consistency: equations of module %s changed on disk", [ModuleName])
    +
      rec-msg(eqs-text-added(ModuleName)) .
      Error("Check consistency: equations of module %s did not exist yet", [ModuleName])
    )
  +
    rec-msg(io-file-not-exists) .
    snd-msg(get-eqs-text(ModuleName)) .
    (
      rec-msg(eqs-text(ModuleName, RepositoryText?)) .
      snd-msg(remove-eqs-from-db(ModuleName)) .
      rec-msg(eqs-removed-from-db) .
      Error("Check consistency: equations of module %s removed on disk", [ModuleName])
    +
      rec-msg(no-eqs-text(ModuleName))
    )
  )
endlet

process CheckModuleConsistency(ModuleName : str) is
let
  Path : str
in
  snd-msg(get-path-from-db(ModuleName)) .
  rec-msg(path(Path?)) .
  CheckSyntaxConsistency(ModuleName, Path) .
  CheckEquationConsistency(ModuleName, Path)
endlet

process InitializeTermStore(Name : str) is
  if not-equal(Name, "") then
    snd-msg(register-termstore-name(Name)) .
    rec-msg(termstore-name-registered) .
    TermStoreActivation
  else
    tau
  fi

process TermStoreActivation is
let
  TermStoreContents : term,
  ErrorMessage : str,
  ModuleNames : list,
  ModuleName : str,
  Name : str,
  Id : int
in
  Id := process-id.
  snd-msg(get-termstore-name) .
  rec-msg(termstore-name(Name?)) .
  snd-msg(io-exists-file(Name)) .
  (
    rec-msg(io-file-exists) .
    snd-note(ui-status(stat(Id, "Retrieving saved term-store"))) .
    snd-msg(io-read-packed-term-file(Name)) .
    (
      rec-msg(io-file-contents(TermStoreContents?)) .
      snd-msg(ts-load-snapshot(TermStoreContents)) .
      rec-msg(ts-snapshot-loaded) .
      snd-msg(get-all-module-names) .
      rec-msg(all-module-names(ModuleNames?)) .
      snd-note(ui-status(stat(Id, "Checking consistency of term-store content"))) .
      if not-equal(ModuleNames, []) then
        ModuleName := first(ModuleNames) .
        ModuleNames := next(ModuleNames) .
        CheckModuleConsistency(ModuleName)
      fi *
      if equal(ModuleNames, []) then
        tau
      fi .
      snd-note(ui-status(endstat(Id))) .
      DrawImportGraph()
    +
      rec-msg(io-error-reading(ErrorMessage?))
    ) .
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(io-file-not-exists)
  )
endlet

process TermStoreName is
let
  TermStoreName : str
in
  TermStoreName := "meta.termstore" .
  (
    rec-msg(register-termstore-name(TermStoreName?)) .
    snd-msg(termstore-name-registered)
  +
    rec-msg(get-termstore-name) .
    snd-msg(termstore-name(TermStoreName)) 
  )*delta
endlet
