/*
  $Id$
*/       

process ParseFocusses is
let
  Id           : term,
  Focus        : term,
  DirtyFoci    : list,
  Text         : str,
  Type         : str,
  ModuleName   : str,
  EditorId     : term,
  Nonterminal  : str,
  Tree         : term,
  Errors       : term,
  ModuleId     : term
in                     
  Id := process-id .     
  (
    rec-msg(parse-focusses(EditorId?, ModuleId?)) .
    Type := fun(ModuleId) .
    ModuleName := first(args(ModuleId)).
    if equal(Type, "eqs") then
      snd-msg(get-rules-top-sort) .
      rec-msg(set-rules-top-sort(sort(Nonterminal?)))
    else
      Nonterminal := ""
    fi . 
    snd-msg(get-dirty-focuses(EditorId)) .
    rec-msg(dirty-focuses(DirtyFoci?)) . 
    if not-equal(DirtyFoci, []) then
      Focus := first(DirtyFoci).
      DirtyFoci := next(DirtyFoci).
      snd-note(get-focus-text(EditorId, Focus)).
      rec-msg(focus-text(EditorId, Text?)).
      UpdateTextInModuleDb(Type, ModuleName, Text).
      ParseString(ModuleId, Nonterminal, Text, Tree?, Errors?) .
      PrepareParseErrorForEditor(ModuleId, EditorId, Focus, Errors) .
      ProcessTree(ModuleId, EditorId, Focus, Tree)
    else
      snd-msg(parse-ok(ModuleId))
    fi 
  )
  *
  delta
endlet

process UpdateTextInModuleDb(Type : str, ModuleName : str, Text : str) is
  if equal(Type, "eqs") then
    snd-msg(update-eqs-text-in-db(ModuleName, text(Text))) .
    rec-msg(eqs-text-updated(ModuleName))
  else
    tau
  fi
