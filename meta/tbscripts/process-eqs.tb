/* $Id$ */

/*{{{ process ReadEquations(ModuleId: str, Equations: str?) */

process ReadEquations(ModuleId: str, Equations: str?)  is
let
  Directory: str,
  ErrorMessage: str,
  Extension: str,
  Filename: str
in
  snd-msg(ts-get-str-value("module-paths", ModuleId))
  . rec-msg(ts-value(Directory?))
  . snd-msg(file-extension-hook(asf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-get-filename(Directory, ModuleId, Extension))
  . rec-msg(io-filename(Filename?))
  . snd-msg(io-read-file(Filename))
  .
  (
    rec-msg(io-file-contents(Equations?))
  +
    rec-msg(io-error-reading(ErrorMessage?)) 
    . Equations := ""
  )
endlet

/*}}}  */

process GetEquations(ModuleId: str) is
let
  Equations: term,
  Text: str
in
  snd-msg(ts-get-term-value("asf-tree", ModuleId))
  .
  (
    rec-msg(ts-value(Equations?))
    . snd-msg(equations(ModuleId, Equations))
  +
    rec-msg(ts-no-value)
    . ReadEquations(ModuleId, Text?)
    . ParseEquationsText(ModuleId, Text)
    .
    (
      rec-msg(parse-equations-ok(ModuleId, Equations?))
      . snd-msg(ts-put-term-value("asf-tree", ModuleId, Equations))
      . snd-msg(equations(ModuleId, Equations))
    +
      rec-msg(parse-equations-failed(ModuleId))
      . snd-msg(ts-remove-term-value("asf-tree", ModuleId))
      . snd-msg(no-equations(ModuleId))
    )
  )
endlet

process ParseEquationsText(ModuleId: str, Text: str) is
let
  Nonterminal: term,
  Pid: int,
  Table: term
in
  GetParseTable(ModuleId, eqs, true, Table?)
  . snd-msg(get-rules-top-sort)
  . rec-msg(set-rules-top-sort(sort(Nonterminal?)))
  . create(ParseEquationsHandler(ModuleId), Pid?)
  . ParseText(Pid, Text, Table, Nonterminal)
endlet

process ParseEquationsHandler(ModuleId: str) is
let
  Equations: term,
  ParseError: term,
  Pid: int,
  ParseResult: term
in
  Pid := process-id
  .
  (
    rec-msg(parse-tree(Pid, ParseResult?))
    . MDB-AddEquationsPosInfo(ModuleId, ParseResult, Equations?)
    . snd-msg(postprocess-semantics-hook(ModuleId, Equations))
    . rec-msg(postprocess-semantics-hook-result(ModuleId, Equations?))
    . snd-msg(parse-equations-ok(ModuleId, Equations))
  +
    (
      rec-msg(parse-forest(Pid, ParseResult?, ParseError?))
    +
      rec-msg(parse-error(Pid, ParseError?))
    )
    . printf("ParseEquationsHandler: %t\n", ParseError)
    . snd-msg(parse-equations-failed(ModuleId))
  )
endlet

process ParseSpecification(ModName : str) is
let
  ModuleName: str,
  Module: str,
  Modules: list,
  EqsText: str,
  EqsTree: term,
  Nonterminal: str,
  ParseTree: term,
  Error: term,
  ModuleId: term,
  Extension: str,
  Path: str,
  FileName: str
in
  snd-msg(get-rules-top-sort) .
  rec-msg(set-rules-top-sort(sort(Nonterminal?))) .
  snd-msg(eqs-not-available-for-modules(ModName)) .
  rec-msg(eqs-needed-for-modules(Modules?))
  . printf("equations needed for module %s -> %t\n", ModName, Modules)
  .
  (
   if not-equal(Modules, []) then
     Module := first(Modules).
     Modules := next(Modules).
     snd-msg(get-eqs-text(Module)).
     (
      rec-msg(eqs-text(Module, EqsText?)) .
      snd-msg(get-path-from-db(Module)) .
      rec-msg(path(Path?)) .
      snd-msg(file-extension-hook(asf)) .
      rec-msg(file-extension-hook-result(Extension?)) .
      snd-msg(io-get-filename(Path, Module, Extension)) .
      rec-msg(io-filename(FileName?)) .
      printf("ParseAllEquations: fixme\n")
      /*
      ParseString(Module, FileName, eqs, false, Nonterminal, EqsText, 
                  ParseTree?, Error?) .
      ProcessParseError(Error) .
      ProcessEqsTree(Module, ParseTree) .
      ParseTree := no-tree
      */
    +
      rec-msg(no-eqs-text(Module)) 
    )
    fi
  )*
  if equal(Modules,[]) then 
    tau
  fi 
endlet

process GetImportsForRenaming(ModuleName : str, ModuleNames : list, 
                              Imports : term?) is
let 
  Modules : list
in
  snd-msg(get-modules(ModuleNames)) .
  (
    rec-msg(modules(Modules?)) .
    snd-msg(sm-get-all-needed-imports(Modules, ModuleName)) .
    Modules := [] .
    rec-msg(sm-all-needed-imports(Imports?))  
  +
    rec-msg(no-modules) .
    Imports := []
  )
endlet

process GetSpecification(ModuleId: str) is
let
  CurModule: str,
  Equations: term,
  Imports: term,
  Modules: list,
  Pid: int,
  Specification: term
in
  ParseSpecification(ModuleId)
  . snd-msg(all-equations-available(ModuleId))
  .
  (
    rec-msg(all-equations-available)
    . snd-msg(get-all-imported-module-names(ModuleId))
    . rec-msg(all-imported-module-names(Modules?))
    . snd-msg(add-initial-eqs-module-names-hook(Modules))
    . rec-msg(initial-eqs-module-names-added(Modules?))
    . GetImportsForRenaming(ModuleId, Modules, Imports?)
    . Specification := []
    .
    if not-equal(Modules, []) then
      CurModule := first(Modules)
      . create(GetEquations(CurModule), Pid?)
      .
      (
	 rec-msg(equations(CurModule, Equations?))
	 . snd-msg(sr-rename-module(Imports, CurModule, Equations))
	 . rec-msg(sr-renamed-module(Equations?))
	 . Specification := join(Specification, Equations)
      +
	 rec-msg(no-equations(CurModule))
      )
      . Modules := next(Modules)
    fi
    *
    if equal(Modules,[]) then  
      snd-msg(postprocess-collected-semantics-hook(ModuleId, Specification))
      . rec-msg(postprocess-collected-semantics-hook-result(ModuleId, Specification?))
      . snd-msg(specification(Specification))
    fi 
  +
    rec-msg(all-equations-incomplete)
    . snd-msg(specification-incomplete)
  )
endlet
