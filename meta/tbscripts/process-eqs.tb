/*
  $Id$
 */

process ProcessEqsTree(Module : str, Tree : term) is
let
  NewTree : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(postprocess-semantics-hook(Tree)) .
    rec-msg(postprocess-semantics-hook-result(NewTree?)) .
    snd-msg(update-eqs-tree-in-db(Module, tree(NewTree))) .
    rec-msg(eqs-updated)
  else
    tau
  fi
endlet

process ProcessEqs is
let
  Id          : term,
  ModName     : str,
  ModuleName  : str,
  Module      : str,
  Modules     : list,
  EqsText     : str,
  EqsTree     : term,
  Nonterminal : str,
  ParseTree   : term,
  Errors      : term,
  ModuleId    : term
in
  Id := process-id.
  (
    rec-msg(process-eqs(ModName?)).
    snd-msg(get-rules-top-sort) .
    rec-msg(set-rules-top-sort(sort(Nonterminal?))) .
    snd-msg(eqs-not-available-for-modules(ModName)) .
    rec-msg(eqs-needed-for-modules(Modules?)).
    (
     if not-equal(Modules, []) then
       Module  := first(Modules).
       Modules := next(Modules).
       /* Get the text representation of the unparsed equations section. 
        */
       snd-msg(get-eqs-text(Module)).
       (
        rec-msg(eqs-text(Module, EqsText?)).
	ModuleId := quote(eqs(Module)) .
	ParseString(ModuleId, 
		    Nonterminal, EqsText, ParseTree?, Errors?) .
	ProcessParseError(Module, Errors) .
	ProcessEqsTree(Module, ParseTree)
      +
        rec-msg(no-eqs-text(Module))
      )
      fi
    )*
    if equal(Modules,[]) then 
      snd-msg(eqs-processed(ModName))
    fi 
  )* delta
endlet

process ProcessRenamedImports(Renamings : term, 
			      ImportsList : list, 
                              Equations : term?) is
let
  Id      : term,
  Import  : term,
  Imports : list
in
  Id := process-id .
  Imports := ImportsList .
  Equations := [] .
  (
    if not-equal(Imports, []) then
      Import  := first(Imports) .
      Imports := next(Imports) /*.
      printf("import = %t\n", Import)
      */
    fi
  )*
  if equal(Imports,[]) then 
    tau
  fi 
endlet

process GetEquations is
let
  Id           : term,
  ModuleName   : str,
  Equations    : term,
  AllEquations : term,
  Modules      : list,
  NewModules   : list,
  Imports      : list,
  Module       : term,
  Renamings    : term,
  FormalName   : term,
  Parameters   : term
in
  Id := process-id .
  (
    rec-msg(get-all-equations(ModuleName?)) .
    snd-msg(all-equations-available(ModuleName)) .
    (
      rec-msg(equations-available) .
      NewModules   := [] .
      snd-msg(get-all-imported-modules(ModuleName)) .
      rec-msg(all-modules(Modules?)) .
      (
        if not-equal(Modules, []) then
          Module  := first(Modules) .
          Modules := next(Modules) .
          snd-msg(get-equations-for-module(Module)) .
          (
	    rec-msg(plain-equations(Equations?)) .
	    NewModules := join(Equations, NewModules)
          +
            rec-msg(renaming-equations(Renamings?, Imports?, Equations?)) .
	    snd-msg(rename-semantics-hook(Renamings, Equations)).
	    rec-msg(rename-semantics-hook-result(Equations?)).
	    NewModules := join(Equations, NewModules) .
	    ProcessRenamedImports(Renamings, Imports, Equations?) .
	    NewModules := join(Equations, NewModules)
          +
	    rec-msg(no-equations)
          )
        fi
      )*
      if equal(Modules,[]) then  
        snd-msg(postprocess-collected-semantics-hook(NewModules)).
	rec-msg(postprocess-collected-semantics-hook-result(AllEquations?)).
	snd-msg(all-equations(AllEquations))
      fi 
    +
      rec-msg(equations-incomplete) .
      snd-msg(equations-incomplete)
    )
  )*delta
endlet
