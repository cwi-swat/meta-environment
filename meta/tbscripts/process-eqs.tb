/*
  $Id$
 */

process ProcessEqsTree(Module : str, Tree : term) is
let
  NewTree : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(postprocess-semantics-hook(Tree)) .
    rec-msg(postprocess-semantics-hook-result(NewTree?)) .
    snd-msg(update-eqs-tree-in-db(Module, tree(NewTree))) .
    rec-msg(eqs-updated)
  else
    tau
  fi
endlet

process ProcessEqs is
let
  ModName     : str,
  ModuleName  : str,
  Module      : str,
  Modules     : list,
  EqsText     : str,
  EqsTree     : term,
  Nonterminal : str,
  ParseTree   : term,
  Errors      : term,
  ModuleId    : term
in
  (
    rec-msg(process-eqs(ModName?)).
    snd-msg(get-rules-top-sort) .
    rec-msg(set-rules-top-sort(sort(Nonterminal?))) .
    snd-msg(eqs-not-available-for-modules(ModName)) .
    rec-msg(eqs-needed-for-modules(Modules?)).
    (
     if not-equal(Modules, []) then
       Module  := first(Modules).
       Modules := next(Modules).
       /* Get the text representation of the unparsed equations section. 
        */
       snd-msg(get-eqs-text(Module)).
       (
        rec-msg(eqs-text(Module, EqsText?)).
	ModuleId := quote(eqs(Module)) .
	ParseString(ModuleId, 
		    Nonterminal, EqsText, ParseTree?, Errors?) .
	ProcessParseError(Module, Errors, "asf") .
	ProcessEqsTree(Module, ParseTree)
      +
        rec-msg(no-eqs-text(Module))
      )
      fi
    )*
    if equal(Modules,[]) then 
      snd-msg(eqs-processed(ModName))
    fi 
  )* delta
endlet

process ProcessRenamedImports(ImportTupleList : list, 
                              Equations : term?) is
let
  ImportTuple  : term,
  ImportTuples : list,
  TupleArgs    : list,
  Import       : term,
  Imports      : list,
  Renamings    : term,
  NewRenamings : term,
  NewImports   : list,
  NewEquations : term
in
  Equations := [] .
  ImportTuples := ImportTupleList .
  (
    if not-equal(ImportTuples, []) then
      ImportTuple  := first(ImportTuples) .
      ImportTuples := next(ImportTuples) .
      TupleArgs := args(ImportTuple) .
      Renamings := first(TupleArgs) .
      Imports := first(next(TupleArgs)) .
      (
        if not-equal(Imports, []) then
          Import  := first(Imports) .
          Imports := next(Imports) .
          snd-msg(get-equations-for-renamed-import(Import, Renamings)) .
          (
            rec-msg(renamed-equations(NewRenamings?, NewImports?, NewEquations?)) .
	    snd-msg(rename-semantics-hook(NewRenamings, NewEquations)) .
	    rec-msg(rename-semantics-hook-result(NewEquations?)) .
	    Equations := join(NewEquations, Equations) .
            ImportTuple := quote(tuple(NewRenamings, NewImports)) .
            ImportTuples := join(ImportTuples, ImportTuple)
          +
            rec-msg(no-equations)
          )
        fi
      )*
      if equal(Imports, []) then 
        tau
      fi 
    fi
  )*
  if equal(ImportTuples, []) then 
    tau
  fi 
endlet

process GetEquations is
let
  ModuleName   : str,
  Equations    : term,
  AllEquations : term,
  Modules      : list,
  NewEquations : list,
  Imports      : list,
  Module       : term,
  Renamings    : term,
  FormalName   : term,
  Parameters   : term,
  ImportTuple  : term
in
  (
    rec-msg(get-all-equations(ModuleName?)) .
    snd-msg(all-equations-available(ModuleName)) .
    (
      rec-msg(equations-available) .
      NewEquations   := [] .
      snd-msg(get-all-imported-modules(ModuleName)) .
      rec-msg(all-modules(Modules?)) .
      (
        if not-equal(Modules, []) then
          Module  := first(Modules) .
          Modules := next(Modules) .
          snd-msg(get-equations-for-module(Module)) .
          (
	    rec-msg(plain-equations(Equations?)) .
	    NewEquations := join(Equations, NewEquations)
          +
            rec-msg(renaming-equations(Renamings?, Imports?, Equations?)) .
	    snd-msg(rename-semantics-hook(Renamings, Equations)).
	    rec-msg(rename-semantics-hook-result(Equations?)).
	    NewEquations := join(Equations, NewEquations) .
            ImportTuple := quote(tuple(Renamings, Imports)) .
	    ProcessRenamedImports([ImportTuple], Equations?) .
	    NewEquations := join(Equations, NewEquations)
          +
	    rec-msg(no-equations)
          )
        fi
      )*
      if equal(Modules,[]) then  
        snd-msg(postprocess-collected-semantics-hook(ModuleName, NewEquations)).
	rec-msg(postprocess-collected-semantics-hook-result(ModuleName, AllEquations?)).
	snd-msg(all-equations(AllEquations))
      fi 
    +
      rec-msg(equations-incomplete) .
      snd-msg(equations-incomplete)
    )
  )*delta
endlet
