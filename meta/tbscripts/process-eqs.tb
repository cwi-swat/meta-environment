/*
  $Id$
 */
process ProcessEqs is
let
  Id          : term,
  ModName     : str,
  Module      : term,
  Modules     : list,
  I           : int,
  Ch          : int,
  Li          : int,
  Co          : int,
  Char        : term,
  ErrList     : list,
  Ambs        : list,
  Cycle       : list,
  EqsText     : str,
  EqsTree     : term,
  Nonterminal : str,
  Msgs        : list
in
  Id := process-id.
  (
    rec-msg(process-eqs(ModName?)).
    snd-msg(get-rules-top-sort) .
    rec-msg(set-rules-top-sort(sort(Nonterminal?))) .
    snd-msg(eqs-not-available-for-modules(ModName)) .
    rec-msg(eqs-needed-for-modules(Modules?)).
    (
     if not-equal(Modules, []) then
       Module  := first(Modules).
       Modules := next(Modules).
       /* Get the text representation of the unparsed equations section. 
        */
       snd-msg(get-eqs-text(Module)).
       (
         rec-msg(eqs-text(Module?, EqsText?)).
         snd-msg(set-parsetable(eqs(Module))).
         (
	   rec-msg(parsetable-set(eqs(Module))).
           snd-note(ui-status(statf(Id,"Parsing equations of %s",[Module]))).
           snd-msg(Id,parse-string-as-asfix2me(eqs(Module), Nonterminal, EqsText)).
           (
             rec-msg(parse-result-asfix2me(Id?, parse-tree(EqsTree?))).
             snd-msg(check-asf(EqsTree)) .
             rec-msg(messages(Msgs?)) . 
             snd-msg(display-asf-errors(Msgs)) .
             snd-msg(update-eqs-tree-in-db(Module, tree(EqsTree))) .
             rec-msg(eqs-updated)
           + 
             rec-msg(parse-result-asfix2me(Id?,parse-error(ErrList?,
                                                         ambiguities(I?, Ambs?)))).
             snd-note(ui-status(errorf("Parse of %s returned %d ambiguities",
                                       [Module,I])))
           + 
             rec-msg(parse-result-asfix2me(Id?,parse-error(ErrList?,
                                                         cycle(Cycle?)))).
             snd-note(ui-status(errorf("Parse returned a cycle: %t\n",
                                       [Cycle])))
           +
             rec-msg(parse-result-asfix2me(Id?,parse-error(ErrList?,eof))). 
             snd-note(ui-status(errorf("EOF unexpected while parsing %s\n",
                                       [Module])))
           +
             rec-msg(parse-result-asfix2me(Id?,
                                         parse-error([character(Ch?),
                                                      line(Li?),
                                                      col(Co?),
                                                      char(Char?)],plain))).
             snd-note(ui-status(errorf(
                      "Character %d unexpected in %s, line %d, column %d\n",
                      [Ch, Module, Li, Co])))
           )
         +
	   rec-msg(parsetable-not-set(eqs(Module))).
	   snd-note(ui-status(errorf("Unable to open parse table for %s",
				     [Module])))
         ) .
         snd-note(ui-status(endstat(Id)))
      +
        rec-msg(no-eqs-text(Module))
      )
      fi
    )*
    if equal(Modules,[]) then 
      snd-msg(eqs-processed(ModName))
    fi 
  )* delta
endlet

process GetEquations is
let
  Id           : term,
  ModuleName   : str,
  Equations    : term,
  AllEquations : term,
  Modules      : list,
  Module       : term,
  Renamings    : term,
  FormalName   : term,
  Parameters   : term
in
  Id := process-id .
  (
    rec-msg(get-all-equations(ModuleName?)) .
    snd-msg(all-equations-available(ModuleName)) .
    (
      rec-msg(equations-available) .
      AllEquations := [] .
      snd-msg(get-all-imported-modules(ModuleName)) .
      rec-msg(all-modules(Modules?)) .
      (
        if not-equal(Modules, []) then
          Module  := first(Modules) .
          Modules := next(Modules) .
          snd-msg(get-equations-for-module(Module)) .
          (
            (
	      rec-msg(plain-equations(Equations?)) 
              +
              rec-msg(renaming-equations(Renamings?, Equations?)) .
              snd-msg(rename(Renamings, Equations)) .
              rec-msg(equations(Equations?)) 
	    ).
	    snd-msg(union-equations(AllEquations, Equations)) .
	    rec-msg(equations(AllEquations?))
          +
	    rec-msg(no-equations)
          )
        fi
      )*
      if equal(Modules,[]) then 
        snd-msg(all-equations(AllEquations))
      fi 
    +
      rec-msg(equations-incomplete) .
      snd-msg(equations-incomplete)
    )
  )*delta
endlet
