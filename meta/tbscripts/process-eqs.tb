process BuildEquationsFilename(ModuleId: str, Filename: str?) is
let
  Directory: str,
  Extension: str
in
  snd-msg(ts-get-str-value("module-path", ModuleId))
  . rec-msg(ts-value(Directory?))
  . snd-msg(file-extension-hook(asf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-get-filename(Directory, ModuleId, Extension))
  . rec-msg(io-filename(Filename?))
endlet

process ParseEquationsText(ModuleId: str, Text: str) is
let
  Checking: term,
  Nonterminal: term,
  Pid: int,
  Table: term
in
  /* Motivation for the get-parse-equation-checking-hook
     Since the asf which we generate should be valid under any circumstance
     it is not necessary to check it. Therefor we need to be able to disable
     the checking option to GetParseTable in ParseEquationsText. */
  snd-msg(get-parse-equation-checking-hook)
  . rec-msg(get-parse-equation-checking-hook-result(Checking?))
  . GetParseTable(ModuleId, eqs, Checking, Table?)
  . snd-msg(get-rules-top-sort)
  . rec-msg(set-rules-top-sort(sort(Nonterminal?)))
  . create(ParseEquationsHandler(ModuleId), Pid?)
  . ParseText(Pid, Text, Table, Nonterminal)
endlet

process ParseEquationsHandler(ModuleId: str) is
let
  Equations: term,
  ParseError: term,
  Pid: int,
  ParseResult: term
in
  Pid := process-id
  .
  (
    rec-msg(parse-tree(Pid, ParseResult?))
    . MDB-AddEquationsPosInfo(ModuleId, ParseResult, Equations?)
    . snd-msg(postprocess-semantics-hook(ModuleId, Equations))
    . rec-msg(postprocess-semantics-hook-result(ModuleId, Equations?))
    . snd-msg(parse-equations-ok(ModuleId, Equations))
  +
    (
      rec-msg(parse-forest(Pid, ParseResult?, ParseError?))
    +
      rec-msg(parse-error(Pid, ParseError?))
    )
    . snd-msg(parse-equations-failed(ModuleId, ParseError))
  )
endlet

process GetAsfModule(ModuleId: str) is
let
  Error: term,
  Equations: term,
  Summary: term,
  Text: str
in
  snd-msg(ts-get-term-value("asf-tree", ModuleId))
  .
  (
    rec-msg(ts-value(Equations?))
    . snd-msg(equations(ModuleId, Equations))
  +
    rec-msg(ts-no-value)
    /* Motivation for the get-asf-equations-text-hook
       The asf generated for the asdf modules should not be saved on the
       disk, and therefor we can not use the previous implementation.
       We need to load the text from the termstore. */
    . snd-msg(get-asf-equations-text-hook(ModuleId))
    . rec-msg(get-asf-equations-text-hook-result(Text?))
    .
    if equal(Text, "") then
      snd-msg(no-equations(ModuleId))
    else
      ParseEquationsText(ModuleId, Text)
      .
      (
        rec-msg(parse-equations-ok(ModuleId, Equations?))
        . snd-msg(ts-put-term-value("asf-tree", ModuleId, Equations))
        . snd-msg(equations(ModuleId, Equations))
      +
        rec-msg(parse-equations-failed(ModuleId, Error?))
        . ParseErrorToSummary(Error, ModuleId, Summary?)
        . snd-msg(error-in-equations(ModuleId, Summary))
      )
    fi
  )
endlet

process GetImportsForRenaming(ModuleName: str, ModuleNames: list, Imports: term?) is
let
  Modules: list
in
  snd-msg(get-modules(ModuleNames))
  .
  (
    rec-msg(modules(Modules?))
    . snd-msg(sm-get-all-needed-imports(Modules, ModuleName))
    . rec-msg(sm-all-needed-imports(Imports?))
  +
    rec-msg(no-modules)
    . Imports := []
  )
endlet

process GetSpecification(ModuleId: str) is
let
  Error: term,
  CurModule: str,
  Equations: term,
  Imports: list,
  Modules: list,
  Pid: int,
  Specification: term
in
  MDB-GetAllImportedModulenames(ModuleId, Modules?)
  . GetImportsForRenaming(ModuleId, Modules, Imports?)
  . Specification := []
  .
  if and(not-equal(Modules, []), equal(Error, undefined)) then
    CurModule := first(Modules)
    . create(GetAsfModule(CurModule), Pid?)
    .
    (
      rec-msg(no-equations(CurModule))
    +
      rec-msg(equations(CurModule, Equations?))
      . snd-msg(sr-rename-module(Imports, CurModule, Equations))
      . rec-msg(sr-renamed-module(Equations?))
      . Specification := join(Specification, Equations)
    +
      rec-msg(error-in-equations(CurModule, Error?))
    )
    . Modules := next(Modules)
  fi
  *
  (
    if not-equal(Error, undefined) then
      snd-msg(specification-incomplete(Error))
    fi
  +
    if equal(Modules, []) then
      snd-msg(specification(Specification))
    fi
  )
endlet

process GetSpecificationEquations(Specification: term, Equations: term?) is
  snd-msg(extract-equations(Specification))
  . rec-msg(extract-equations-result(Equations?))

process GetSpecificationTests(Specification: term, Tests: term?) is
  snd-msg(extract-tests(Specification))
  . rec-msg(extract-tests-result(Tests?))
