#include <asf-namespace.h>
#include <sdf-namespace.h>
#include <module-manager.tb>
#include <equations-parsetable.tb>

process ASFModuleOpener is
let
  Event: attribute-changed-event,
  ModuleId: term,
  NewPath: term
in
  MM-Subscribe-Attribute-Changed(<term>,SDF_NAMESPACE,"status",<term>,available)  .
  (
    rec-note(mm-attribute-changed(Event?))
    . ACE-GetModuleId(Event, ModuleId?)
    . OpenASFModule(ModuleId)
  )
  *
  delta
endlet

toolbus(ASFModuleOpener)

process OpenASFModule(ModuleId: term) is
let
  AsfExt: str,
  AsfPath: str,
  Editable: bool,
  LibraryModule: bool,
  Modulename: str,
  Path: str,
  Present: bool,
  Registered: bool,
  SdfPath: str
in
  MM-HasAttribute(ModuleId, ASF_NAMESPACE, "status", Registered?)
  . 
  if not-equal(Registered,true) then 
    MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "name", Modulename)
    . GetModulePath(ModuleId, SDF_NAMESPACE, SdfPath?)
    . ReplaceExtension(SdfPath, ASF_EXTENSION, AsfPath?)
    . SetModulePath(ModuleId, ASF_NAMESPACE, AsfPath)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", unknown)
  else
    tau
  fi
  . snd-msg(io-exists-file(AsfPath))
  .
  (
    rec-msg(io-file-exists)
    . SetModulePath(ModuleId, ASF_NAMESPACE, AsfPath)
    . IsLibraryModule(ModuleId, LibraryModule?)
    . Editable := not(LibraryModule)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "editable", Editable)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", available)
  +
    rec-msg(io-file-not-exists)
  )
endlet

process CheckASFModule(ModuleId: term, Tree: term) is
let
  Summary : term,
  Errors: list,
  Modulename: str
in
  MM-GetAttribute(ModuleId, ASF_NAMESPACE, "name", Modulename?) 
  . snd-msg(check-asf(Modulename, Tree))
  . rec-msg(messages(Errors?))
  . snd-msg(ui-remove-feedback-summary("asf-checker", Modulename))
  . snd-msg(es-make-summary("asf-checker", Modulename, Errors))
  . rec-msg(es-summary(Summary?))
  . snd-msg(ui-show-feedback-summary(Summary))
endlet

process ASFModuleChecker is
let
  Event: attribute-changed-event,
  ModuleId: term,
  NewPath: term,
  Tree: term
in
  MM-Subscribe-Attribute-Changed(<term>,ASF_NAMESPACE,"status",<term>,parsed)  .
  (
    rec-note(mm-attribute-changed(Event?))
    . ACE-GetModuleId(Event, ModuleId?)
    . CheckASFModule(ModuleId, Tree)
  )
  *
  delta
endlet

/*toolbus(ASFModuleChecker)*/

process ASFModuleParser is
let
  Event: attribute-changed-event,
  ModuleId: term
in
  MM-Subscribe-Attribute-Changed(<term>,ASF_NAMESPACE,"status",<term>,available)
  .
  (
    rec-note(mm-attribute-changed(Event?))
    . ACE-GetModuleId(Event, ModuleId?)
    . GetASFParseTree(ModuleId)
  )
  *
  delta
endlet

toolbus(ASFModuleParser)

process GetASFParseTree(ModuleId: term) is
let
  Id: int,
  ParseTable: term,
  Path: str,
  Pid: int,
  Result: term,
  Text: str,
  Type: term
in
  Id := process-id
  . Type := eqs
  . GetModulePath(ModuleId, ASF_NAMESPACE, Path?)
  . ReadFile(Path, Text?)
  .
  if not-equal(Text, "") then
    GetParseTable(ModuleId, Type, ParseTable?)
    . create(ASFParseTreeHandler(ModuleId), Pid?)
    . ParseText(Pid, Text, ParseTable, ASF_TOPSORT)
    .
    (
      rec-msg(asf-parse-handler-done(Pid, ModuleId))
      . SetModuleEquationsText(ModuleId, Text)
    +
      rec-msg(asf-parse-handler-done(Pid))
    )
    /* Use Listener? */
    /*. AddEquationsPosInfo(ModuleId, Tree, Result?)*/
  else 
    TODO("valid error message")
  fi
endlet

process ASFParseTreeHandler(ModuleId: term) is
let
  ErrorMessage: term,
  Nonterminal: term,
  ParseError: term,
  ParseResult: term,
  Path: str,
  Pid: int,
  Summary: term,
  Table: term
in
  Pid := process-id
  .
  (
    (
      rec-msg(parse-tree(Pid, ParseResult?))
    +
      rec-msg(parse-forest(Pid, ParseResult?, ErrorMessage?))
      . AddFilenameToParseError(ErrorMessage, Path, ParseError?)
      . snd-msg(es-make-summary("sglr", Path, [ParseError]))
      . rec-msg(es-summary(Summary?))
      . snd-msg(ui-show-feedback-summary(Summary))
    )
    . SetModuleEquationsTree(ModuleId, ParseResult)
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", parsed)
    . snd-msg(asf-parse-handler-done(Pid, ModuleId))
  +
    rec-msg(parse-error(Pid, ErrorMessage?))
    . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", error)
    . AddFilenameToParseError(ErrorMessage, Path, ParseError?)
    . snd-msg(es-make-summary("sglr", Path, [ParseError]))
    . rec-msg(es-summary(Summary?))
    . snd-msg(asf-parse-handler-done(Pid))
  )
endlet

/*** HIERO ***/
process AddEquationsPosInfo(ModuleId: term, In: term, Out: term?) is
let
  Path: str
in
  GetModulePath(ModuleId, ASF_NAMESPACE, Path?)
  . AnnotateTree(In, Path, Out?) 
endlet

/*
process GetAsfModule(ModuleId: term) is
let
  AsfExt: str,
  AsfPath: str,
  Error: term,
  Modulename: str,
  ParseError: term,
  SdfPath: str,
  Summary: term,
  Text: str,
  Tree: term
in
  snd-msg(ts-get-term-value("asf-tree", ModuleId))
  .
  (
    rec-msg(ts-value("asf-tree", ModuleId, Tree?))
    . snd-msg(equations(ModuleId, Tree))
  +
    rec-msg(ts-no-value("asf-tree", ModuleId))
    . TODO("codeclone with EditEquationsAction")
    . GetModulePath(ModuleId, SDF_NAMESPACE, SdfPath?)
    .  
    if equal(SdfPath, "") then
      snd-msg(no-equations(ModuleId))
    else
      snd-msg(file-extension-hook(asf))
      . rec-msg(file-extension-hook-result(AsfExt?))
      . ReplaceExtension(SdfPath, AsfExt, AsfPath?)
      . MM-SetAttribute(ModuleId, ASF_NAMESPACE, "status", unknown)
      . SetModulePath(ModuleId, ASF_NAMESPACE, AsfPath)
      . ReadFile(AsfPath, Text?)
      .
      if equal(Text, "") then
        snd-msg(no-equations(ModuleId))
      else
        ParseEquationsText(ModuleId, Text, Tree?)
        .
	if equal(Tree, UNDEFINED) then
	  MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
          . AddFilenameToParseError(Error, Modulename, ParseError?)
          . snd-msg(es-make-summary("sglr", Modulename, [ParseError]))
          . rec-msg(es-summary(Summary?))
          . snd-msg(error-in-equations(ModuleId, Summary))
	else
          snd-msg(ts-put-term-value("asf-tree", ModuleId, Tree))
          . snd-msg(equations(ModuleId, Tree))
	fi
      fi
    fi
  )
endlet
*/

process GetImportsForRenaming(ModuleId: term, ModuleIds: list, Imports: term?) is
let
  Modulename: str,
  Modules: list
in
  GetModules(ModuleIds, Modules?)
  .
  if equal(Modules, []) then
    Imports := []
  else
    MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?)
    . snd-msg(sm-get-all-needed-imports(Modules, Modulename))
    . rec-msg(sm-all-needed-imports(Imports?))
  fi
endlet

process GetSpecification(ModuleId: term) is
let
  Error: term,
  CurModule: term,
  Equations: term,
  Imports: list,
  Modulename: str,
  Modules: list,
  Pid: int,
  Specification: term,
  Id : int,
  Count : int,
  Done : int
in
  Id := process-id
  . snd-note(ui-status(start(Id, "Get Specification")))
  . MM-GetAllModuleDependencies(ModuleId, Modules?)
  . GetImportsForRenaming(ModuleId, Modules, Imports?)
  . Count := size(Modules)
  . Specification := []
  . TODO("remove computation by using listeners?")
  . 
  if and(not-equal(Modules, []), equal(Error, undefined)) then
    CurModule := first(Modules)
    . GetModuleEquationsTree(CurModule, Equations?)
    .
    if equal(Equations, UNDEFINED) then
      tau
    else
      /* normalization should occur BEFORE renaming 
       * proposal: merge the renaming and normalization tools,
       * possibly including the get-imports tool. 
       */
      MM-GetAttribute(CurModule, SDF_NAMESPACE, "name", Modulename?)
      . snd-note(ui-status(statf(Id, "Normalizing %s",[Modulename])))
      . snd-msg(normalize-module(Equations)) 
      . rec-msg(normalize-module-result(Equations?))
      . snd-note(ui-status(statf(Id, "Renaming %s",[Modulename])))
      . snd-msg(sr-rename-module(Imports, Modulename, Equations))
      . rec-msg(sr-renamed-module(Equations?))
      . Specification := join(Specification, Equations)
    +
      rec-msg(error-in-equations(CurModule, Error?))
    )
    . Modules := next(Modules)
    . Done := sub(Count, size(Modules))
    . printf("\rDone %d/%d\n", Done, Count )
  fi
  *
  (
    if not-equal(Error, undefined) then
      snd-msg(specification-incomplete(Error))
    fi
  +
    if equal(Modules, []) then
      snd-msg(specification(Specification)) 
    fi
  )
  . snd-note(ui-status(stop(Id)))
endlet

process GetSpecificationEquations(Specification: term, Equations: term?) is
  snd-msg(extract-equations(Specification))
  . rec-msg(extract-equations-result(Equations?))

process GetSpecificationTests(Specification: term, Tests: term?) is
  snd-msg(extract-tests(Specification))
  . rec-msg(extract-tests-result(Tests?))

process SetModuleEquationsText(ModuleId: term, Text: str) is
  snd-msg(ts-put-str-value("asf-text", ModuleId, Text))

process SetModuleEquationsTree(ModuleId: term, Tree: term) is
  snd-msg(ts-put-term-value("asf-tree", ModuleId, Tree))

process GetModuleEquationsTree(ModuleId: term, Tree: term?) is
  snd-msg(ts-get-term-value("asf-tree", ModuleId))
  .
  (
    rec-msg(ts-value("asf-tree", ModuleId, Tree?))
  +
    rec-msg(ts-no-value("asf-tree", ModuleId))
    . Tree := UNDEFINED
  )

process DeleteModuleEquationsTree(ModuleId: term) is
  snd-msg(ts-remove-value("asf-tree", ModuleId))
