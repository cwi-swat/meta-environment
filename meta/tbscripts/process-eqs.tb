/* $Id$ */

process ProcessEqsTree(Module : str, Tree : term) is
let
  NewTree : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(postprocess-semantics-hook(Module, Tree)) .
    rec-msg(postprocess-semantics-hook-result(Module, NewTree?)) .
    snd-msg(update-eqs-tree-in-db(Module, tree(NewTree))) .
    NewTree := no-tree .
    rec-msg(eqs-updated)
  else
    tau
  fi
endlet

process ParseAllEquations(ModName : str) is
let
  ModuleName  : str,
  Module      : str,
  Modules     : list,
  EqsText     : str,
  EqsTree     : term,
  Nonterminal : str,
  ParseTree   : term,
  Errors      : term,
  ModuleId    : term,
  Extension   : str
in
  snd-msg(get-rules-top-sort) .
  rec-msg(set-rules-top-sort(sort(Nonterminal?))) .
  snd-msg(eqs-not-available-for-modules(ModName)) .
  rec-msg(eqs-needed-for-modules(Modules?)).
  (
   if not-equal(Modules, []) then
     Module  := first(Modules).
     Modules := next(Modules).
     snd-msg(get-eqs-text(Module)).
     (
      rec-msg(eqs-text(Module, EqsText?)).
      ParseString(Module, eqs, Nonterminal, EqsText, ParseTree?, Errors?) .
      snd-msg(file-extension-hook(asf)) .
      rec-msg(file-extension-hook-result(Extension?)) .
      ProcessParseError(Module, Errors, Extension) .
      ProcessEqsTree(Module, ParseTree) .
      ParseTree := no-tree
    +
      rec-msg(no-eqs-text(Module)) 
    )
    fi
  )*
  if equal(Modules,[]) then 
    tau
  fi 
endlet

process GetImportsForRenaming(ModuleName : str, ModuleNames : list, 
                              Imports : term?) is
let 
  Modules : list
in
  snd-msg(get-modules(ModuleNames)) .
  rec-msg(modules(Modules?)) .
  snd-msg(sm-get-all-needed-imports(Modules, ModuleName)) .
  Modules := [] .
  rec-msg(sm-all-needed-imports(Imports?))  
endlet

process GetSpecification is
let
  ModuleName   : str,
  Equations    : term,
  AllEquations : term,
  Modules      : list,
  NewEquations : list,
  Imports      : term,
  Module       : str,
  Renamings    : term,
  FormalName   : term,
  Parameters   : term,
  ImportTuple  : term,
  ModuleNames : list,
  RenamedEquations : list,
  ImportedModuleName : str,
  Specification : term
in
  (
    rec-msg(get-specification(ModuleName?)) .
    ParseAllEquations(ModuleName) .
    snd-msg(all-equations-available(ModuleName)) .
    (
      rec-msg(equations-available) .
      NewEquations   := [] .
      snd-msg(get-all-imported-module-names(ModuleName)) .
      rec-msg(all-imported-module-names(ModuleNames?)) .
      GetImportsForRenaming(ModuleName, ModuleNames, Imports?) .
      if not-equal(ModuleNames, []) then
        Module  := first(ModuleNames) .
        ModuleNames := next(ModuleNames) .
        snd-msg(get-equations-for-module(Module)) .
        (
           rec-msg(equations(Equations?)) .
	   snd-msg(sr-rename-module(Imports, Module, Equations)) .
	   Equations := no-tree .
	   rec-msg(sr-renamed-module(RenamedEquations?)) .
	   NewEquations := join(NewEquations, RenamedEquations) .
	   RenamedEquations := []
        +
	   rec-msg(no-equations)
        )
      fi
      *
      if equal(ModuleNames,[]) then  
        Specification := NewEquations .
	snd-msg(specification(Specification)) .
	NewEquations := []
      fi 
    +
      rec-msg(equations-incomplete) .
      snd-msg(specification-incomplete)
    )
  )*delta
endlet

process GetEquations is
let
  ModuleName   : str,
  Equations    : term,
  AllEquations : term,
  NewEquations : term
in
  (
    rec-msg(get-all-equations(ModuleName?)) .
    snd-msg(get-specification(ModuleName)) .
    (
      rec-msg(specification(NewEquations?)) .
      snd-msg(postprocess-collected-semantics-hook(ModuleName, NewEquations)).
      NewEquations := [] .
      rec-msg(postprocess-collected-semantics-hook-result(ModuleName, AllEquations?)).
      snd-msg(all-equations(AllEquations)) .
      AllEquations := no-tree
    +
      rec-msg(specification-incomplete) .
      snd-msg(equations-incomplete)
    )
  )
  * delta
endlet
