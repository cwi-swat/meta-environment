/* $Id$ */

process ProcessEqsTree(Module : str, Tree : term) is
let
  NewTree : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(postprocess-semantics-hook(Tree)) .
    rec-msg(postprocess-semantics-hook-result(NewTree?)) .
    snd-msg(update-eqs-tree-in-db(Module, tree(NewTree))) .
    rec-msg(eqs-updated)
  else
    tau
  fi
endlet

process ParseAllEquations(ModName : str) is
let
  ModuleName  : str,
  Module      : str,
  Modules     : list,
  EqsText     : str,
  EqsTree     : term,
  Nonterminal : str,
  ParseTree   : term,
  Errors      : term,
  ModuleId    : term
in
  snd-msg(get-rules-top-sort) .
  rec-msg(set-rules-top-sort(sort(Nonterminal?))) .
  snd-msg(eqs-not-available-for-modules(ModName)) .
  rec-msg(eqs-needed-for-modules(Modules?)).
  (
   if not-equal(Modules, []) then
     Module  := first(Modules).
     Modules := next(Modules).
     snd-msg(get-eqs-text(Module)).
     (
      rec-msg(eqs-text(Module, EqsText?)).
      ModuleId := quote(eqs(Module)) .
      ParseString(ModuleId, Nonterminal, EqsText, ParseTree?, Errors?) .
      ProcessParseError(Module, Errors, "asf") .
      ProcessEqsTree(Module, ParseTree)
    +
      rec-msg(no-eqs-text(Module)) 
    )
    fi
  )*
  if equal(Modules,[]) then 
    tau
  fi 
endlet

process GetImportsForRenaming(ModuleName : str, Imports : term?) is
let 
  Modules : list
in
  printf("DEBUG:all sdf-modules not needed!(%f,%d)\n", __FILE__, __LINE__) .
  snd-msg(get-all-modules) .
  rec-msg(all-modules(Modules?)) .
  snd-msg(sm-get-all-needed-imports(Modules, ModuleName)) .
  rec-msg(sm-all-needed-imports(Imports?))  
endlet


process GetEquations is
let
  ModuleName   : str,
  Equations    : term,
  AllEquations : term,
  Modules      : list,
  NewEquations : list,
  Imports      : term,
  Module       : str,
  Renamings    : term,
  FormalName   : term,
  Parameters   : term,
  ImportTuple  : term,
  ModuleNames : list,
  RenamedEquations : list,
  ImportedModuleName : str
in
  (
    rec-msg(get-all-equations(ModuleName?)) .
    ParseAllEquations(ModuleName) .
    snd-msg(all-equations-available(ModuleName)) .
    (
      rec-msg(equations-available) .
      NewEquations   := [] .
      snd-msg(get-all-imported-module-names(ModuleName)) .
      rec-msg(all-imported-module-names(ModuleNames?)) .
      GetImportsForRenaming(ModuleName, Imports?) .
      if not-equal(ModuleNames, []) then
        Module  := first(ModuleNames) .
        ModuleNames := next(ModuleNames) .
        snd-msg(get-equations-for-module(Module)) .
        (
           rec-msg(equations(Equations?)) .
	   snd-msg(sr-rename-module(Imports, Module, Equations)) .
	   rec-msg(sr-renamed-module(RenamedEquations?)) .
	   NewEquations := join(NewEquations, RenamedEquations)
        +
	   rec-msg(no-equations)
        )
      fi
      *
      if equal(ModuleNames,[]) then  
        snd-msg(postprocess-collected-semantics-hook(ModuleName, NewEquations)).
	rec-msg(postprocess-collected-semantics-hook-result(ModuleName, AllEquations?)).
	snd-msg(all-equations(AllEquations))
      fi 
    +
      rec-msg(equations-incomplete) .
      snd-msg(equations-incomplete)
    )
  )*delta
endlet
