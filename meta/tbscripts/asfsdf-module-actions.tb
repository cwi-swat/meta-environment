#ifndef __ASFSDF_MODULE_ACTIONS__
#define __ASFSDF_MODULE_ACTIONS__

process GetSearchPaths(Paths: list?) is
  snd-msg(cm-get-module-paths)
  . rec-msg(cm-module-paths(Paths?))

process PrintModuleAction(ModuleId : term) is
let
  Cancel: bool,
  Path : str
in
  PromptForFileWithExtension("Module Text (ASF+SDF)", [], ".txt", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    snd-msg(print-module(ModuleId, Path))
    . rec-msg(module-printed(ModuleId))
  fi
endlet

process NewModuleContentHandler is
let
  ModuleId: str,
  Pid: int
in
  Pid := process-id
  .
  (
    rec-msg(get-module-contents(Pid, ModuleId?))
    . snd-msg(module-contents(Pid, ["module ", ModuleId, "\n"]))
  +
    rec-msg(cancel-content-handler(Pid))
  )
endlet

#ifdef DEAD
process AddImportAction(Modulename: str) is
let
  Id: int,
  Import: str,
  Options: list
in
  Id := process-id
  . snd-msg(get-all-module-names)
  . rec-msg(all-module-names(Options?))
  . snd-msg(show-list-choice(Modulename, "Choose a module to import", Options))
  .
  (
    rec-msg(list-choice(Modulename, Import?))
    . snd-note(ui-status(statf(Id, "Adding import %s to %s",
                               [Import, Modulename])))
    . AddImport(Modulename, Import)
    . snd-note(ui-status(endstat(Id)))
  +
    rec-msg(cancel-list-choice(Modulename))
  )
endlet

process RemoveImportAction(Modulename: str) is
let
  Id: int,
  Import: str,
  Options: list
in
  Id := process-id
  . snd-msg(get-imported-modules(Modulename))
  . rec-msg(imported-modules(Options?))
  . snd-msg(show-list-choice(Modulename, "Choose an import to remove", Options))
  .
  (
    rec-msg(list-choice(Modulename, Import?))
    . snd-note(ui-status(statf(Id, "Removing import %s from %s",
                               [Import, Modulename])))
    . RemoveImport(Modulename, Import)
    . snd-note(ui-status(endstat(Id)))
  +
    rec-msg(cancel-list-choice(Modulename))
  )
endlet

#endif

process NewModuleAction is
let
  Cancel: bool,
  Extension : str,
  Directory : str,
  Pid: int,
  FileName : str,
  Path : str,
  Paths: list
in
  GetSearchPaths(Paths?)
  . PromptForFileWithExtension("New Module", Paths, ".sdf", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    SplitFilename(Path, FileName?, Directory?, Extension?)
    . create(NewModuleContentHandler(), Pid?)
    . CreateNewModule(Pid, Directory, FileName, sdf)
  fi
endlet

process OpenModuleAction is
let
  Cancel: bool,
  Extension : str,
  Directory : str,
  Path : str,
  Filename : str,
  RelativeFilename : str,
  ModuleId : term,
  Paths: list,
  FoundPath: str
in
  GetSearchPaths(Paths?)
  . PromptForFileWithExtension("Open Module", Paths, ".sdf", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    if equal(Path, "") then
      tau
    else
      SplitFilename(Path, Filename?, Directory?, Extension?)
      . snd-msg(io-get-relative-filename(Paths, Path, Extension))
      . rec-msg(io-filename(Paths, Path, Extension, RelativeFilename?))
      . BuildPath(Directory, RelativeFilename, Extension, FoundPath?)
      . printf("Found: %t, orignal: %t\n", FoundPath, Path)
      .
      if equal(FoundPath, Path) then
        OpenModule(RelativeFilename, ModuleId?)
      else
        Error("The chosen Module is shadowed by another module in the search path: %t", [FoundPath])
      fi
    fi
  fi
endlet

process DumpEquationsAction(ModuleId : term) is
let
  Cancel: bool,
  Path : str
in
  PromptForFileWithExtension("Export Equations", [], ".eqs", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    snd-msg(dump-equations-given-file(ModuleId, Path))
    . rec-msg(equations-dumped)
  fi
endlet

process DumpParseTableAction(ModuleId : term) is
let
  Cancel: bool,
  Path : str
in
  PromptForFileWithExtension("Export Term ParseTable", [], ".trm.tbl", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    DumpParseTable(ModuleId, Path, trm)
  fi
endlet

process EditorDumpParseTableAction(EditorId : term) is
let
  Cancel: bool,
  Path : str,
  ModuleId : term
in
  GetModuleId(EditorId, ModuleId?)
  . PromptForFileWithExtension("Export Term ParseTable", [], ".trm.tbl", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    DumpParseTable(ModuleId, Path, trm)
  fi
endlet

process DumpEquationsParseTableAction(ModuleId : term) is
let
  Cancel: bool,
  Path : str
in
  PromptForFileWithExtension("Export Equations ParseTable", [], ".eqs.tbl", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    DumpParseTable(ModuleId, Path, eqs)
  fi
endlet

process EditorDumpEquationsParseTableAction(EditorId : term) is
let
  Cancel: bool,
  Path : str,
  ModuleId : term
in
  GetModuleId(EditorId, ModuleId?)
  . PromptForFileWithExtension("Export Equations ParseTable", [], ".eqs.tbl", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    DumpParseTable(ModuleId, Path, eqs)
  fi
endlet

process DumpSdfDefinitionAction(ModuleId : term) is
let
  Cancel: bool,
  Path : str
in
  PromptForFileWithExtension("Export SDF Definition", [], ".def", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    snd-msg(dump-sdf-definition(ModuleId, Path))
    . rec-msg(sdf-definition-dumped)
  fi
endlet

process CompileModuleAction(ModuleId : term) is
let
  Cancel: bool,
  Path : str
in
  PromptForFileWithExtension("Target C file", [], ".c", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    snd-msg(compile-module(ModuleId, Path))
    . rec-msg(compilation-ready(ModuleId))
  fi
endlet

process CloseModuleAction(ModuleId : term) is
let
  Answer     : term,
  Recursive  : bool
in
  AskQuestion("Do you want to recursively close the imported modules?", Answer?)
  . if equal(Answer, cancel) then
      tau
    else
      if equal(Answer, yes) then
        Recursive := true
      else
        Recursive := false
      fi 
      . CloseModule(ModuleId, Recursive)
    fi
endlet

process RenameModuleAction(Modulename : str) is
let
  Cancel: bool,
  Directory : str,
  Filename : str,
  Extension : str,
  Path : str,
  Paths : list
in
  GetSearchPaths(Paths?)
  . PromptForFileWithExtension("Rename module to", Paths, ".sdf", Cancel?, Path?)
  . 
  if equal(Cancel, true) then
    tau
  else
    SplitFilename(Path, Filename?, Directory?, Extension?)
    . RenameModule(Modulename, Directory, Filename)
  fi
endlet

process CopyModuleAction(Modulename : str) is
let
  Cancel: bool,
  Path : str,
  Directory : str,
  Filename : str,
  Extension : str,
  Paths : list
in
  GetSearchPaths(Paths?)
  . PromptForFileWithExtension("Copy module to", Paths, ".sdf", Cancel?, Path?)
  .
  if equal(Cancel, true) then
    tau
  else
    SplitFilename(Path, Filename?, Directory?, Extension?)
    . CopySdfModule(Modulename, Directory, Filename)
    . CopyAsfModule(Modulename, Directory, Filename)
  fi
endlet

process DeleteModuleAction(Modulename : str) is
let
  Answer : term
in
  AskQuestion("Are you sure you want delete this module (from disk)?", Answer?)
  . if equal(Answer, cancel) then
      tau
    else
      if equal(Answer, yes) then
        DeleteModule(Modulename)
      else
        tau
      fi 
    fi
endlet

process CreateModuleAction(Filename : str) is
let
  Directory : str,
  Pid: int
in
  TODO("werk niet als . niet in het zoekpad sit\n")
  . snd-msg(io-relative-to-absolute(["."]))
  . rec-msg(io-absolute-directories([Directory?]))
  . create(NewModuleContentHandler(), Pid?)
  . CreateNewModule(Pid, Directory, Filename, sdf)
endlet

process CheckSyntaxSpecification(ModuleId : term) is
let
  Syntax    : term,
  ErrorMessage : str,
  Feedback  : term,
  Id : int,
  Modulename : str
in
  Id := process-id .
  snd-msg(get-all-syntax-definitions(ModuleId, eqs)) .
  (
    rec-msg(syntax(Syntax?)) .
    MM-GetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename?).
    snd-msg(check-asfsdf(Syntax, Modulename)) .
    rec-msg(feedback(Feedback?)) .
    snd-msg(display-sdf-errors(Modulename, Feedback)) .
    Syntax := UNDEFINED
  +
    rec-msg(no-syntax(ErrorMessage?))
  )
endlet

#endif /*__ASFSDF_MODULE_ACTIONS__*/
