/* $Id$ */
/* This is a very simple T-script to build a minimal stand-alone 
   meta-environment */
/* $Log$
 * Revision 1.3  1997/08/04 11:08:43  markvdb
 * Small modifications in ToolBus script.
 *
# Revision 1.2  1997/07/22  08:40:49  markvdb
# First version of incomplete compiler based on ToolBus and new Meta-Environment
# checked in. Ohne Gewahr!
#
# Revision 1.1.1.1  1997/03/04  10:09:13  olivierp
# This is the first (internal) release of the new Meta-environment
# based on the aterm-lib shared term library. The repository name
# 'new-meta' will probably change when we come up with a better name.
# The preliminary results with this (unoptimized) version seem to be
# very favorable:
# - Rewrite speed has not deteriorated noticably.
# - Core size has improved spectacuraly: The Pico-eval example now has a
#   memory footprint of about 16/17 MB, while with the 'old' ToolBus library
#   the same example had a memory footprint of about 100MB!
#
 * Revision 1.18  1997/02/25 16:37:31  gipe
 * The clear-all function has been implemented for all tools connected
 * to msm.
 *
 * Revision 1.17  1997/02/25 10:28:32  kuipers
 * * Replaced all occurrances of set-status, and error(f) with corresponding
 *   notes. All messages for the user are now in notes and handled by a single
 *   process: Status-display.
 * -- Tobias
 *
 * Revision 1.16  1997/02/25 09:10:31  gipe
 * * changed warnings into error(f)'s
 *
 * Revision 1.15  1997/02/24 11:02:50  gipe
 * * added warning when file does not exist (the message in the status bar
 *   is "updated" to fast for the user to notice...)
 * * changed some comments from the style * a-lot-of-lines * to the style where
 *   each line is prefixed with a * (not so easy to miss...)
 * * changed unimplemented printf's for clear-all, revert-all and revert-module(M)
 *   to warnings
 *
 * --Leon.
 *
 * Revision 1.14  1997/02/21 16:21:14  kuipers
 * * Added a new process: Status-display. This process controls all messages
 *   for the UI status line. Processes that want to display something need to
 *   send a note of type ui-status, instead of accessing the UI directly.
 *   For sending a message:
 *   snd-note(ui-status(stat(Id,"My message...")))
 *   where Id is the process-id, or any unique term. A process can send any
 *   number of messages, only the last one will be displayed.
 *   When your process is finished you should also tell the status-display.
 *   To remove all messages from your process from the message-queue send a
 *   note of the form:
 *   snd-note(ui-status(endstat(Id)))
 *   where Id is the process-id, or any unique term. It has to be the same
 *   Id as you used for sending the messages.
 *   If all processes have sent a endstat note (the message queue is empty)
 *   the status line will display "Idle".
 * * Changed all status messages to the UI according to the above scheme.
 *
 * --Tobias
 *
 * Revision 1.13  1997/02/21 14:42:07  gipe
 * in ModView:
 * * added "About MSM" to help menu
 * * removed CVS Log directive (see page 55 of CVS manual)
 * * added buttons for edit/delete/revert/info of selected modules
 * * improved module-info widget (two-column-mode)
 * * use grid as geometry manager for building the windows
 *   (much better than pack for tabular-like geometry)
 * * fixed small bug for size layout button which caused the scrollbars
 *   to be of different size
 *
 * in TB script:
 * * print error for unsupported events (clear-all, revert-all, revert-module)
 * * added dummy support for get-module-info
 * * added ack-events for all of these to prevent protocol errors
 *
 * -- Leon
 *
 * Revision 1.12  1997/02/20 16:38:57  kuipers
 * * Added acknowledge for edit-module event. We can now edit more than one
 *   module...
 *   --Tobias
 *
 * Revision 1.11  1997/02/18 14:55:23  gipe
 * New version of the interpreter is ready it has been tested with
 * the Pico-typechecker and Pico-evaluator. None of the bugs detected.
 * Remaining issues are:
 * - Efficiency improvements;
 * - Testing of expressions with brackets;
 * - Porting to shared term-library;
 * - Documentation and restructurering of the code.
 *
 * -- Mark
 *
 * Revision 1.10  1997/02/18 12:57:21  kuipers
 * * Added support for viewing terms that are rewritten. An edit term command
 *   now initiates the following action sequence:
 *   View term that is to be rewritten
 *   Rewrite the term
 *   View the result
 * * Moved a lot of functionality out of the UI process to more appropriate (new)
 *   processes.
 * * Made names of terms that are communicated more consistent. Terms that are
 *   communicated are a tuple of: the name of the process that receives the
 *   communication, and the term to be communicated itself.
 * * Problems/bugs: Opening a file that does not exist results in deadlock.
 *     Yet more processes can be defined, and parallelism should be increased.
 *   --Tobias
 *
*/

/* For some reason cpp doesn't work the same on a Sun and a Sgi. Define
   -DSGI on ToolBus commandline for SGI */

#ifdef SGI
#include "/ufs/kuipers/metaenv/msm/tb/editor.tb"
#else
#include "editor.tb"
#endif

tool tree-db is {
       command = "tree-db"
}
tool compiler is {
       command = "compiler"
}
tool import-db is {
       command = "import-db"
}
tool evaluator is {
       command = "evaluator"
}
tool user-interface is {
       command = "graph-browser"
}
tool in-output is {
       command = "in-output"
}
tool arm is {
       command = "arm-adapter"
}
tool to-epic is {
       command = "to-epic"
}


process Open-modules(Tmp: list) is
let
  Id   : term,
  Name : term,
  Str  : str,
  T    : term,
  M1s  : list,
  M2s  : list,
  Ms   : list,
  Pairs: list
in
Id := process-id.
snd-note(ui-status(stat(Id,"Opening Modules"))).
Ms := Tmp.
(
  if not-equal(Ms, []) then
    Name := first(Ms).
    Ms   := next(Ms).
    /* First we should check here whether this module has already been 
       opened...
    */
    snd-msg(mdb,exists(Name)).
    ( rec-msg(open,exists(Name?))
      +
      /* If it is not open, open it. */
      rec-msg(open,notexists(Name?)).
      ( snd-msg(io,open-file(Name)).
        ( rec-msg(opened-file(Name?,T?)).
          /* Tell ui we opened a file (i.e. for status bar) 
          snd-msg(ui,opened-module(Name)). */
          /* Tell mdb we add module Name containing term T */
          snd-msg(mdb,add-module(Name,T)).
          /* mdb returns the imports section of Name as M1s */
          rec-msg(open,imports(M1s?)).
          snd-msg(prep,add-module(Name,T)).
          rec-msg(open,done).
          /*snd-msg(ui,imports(Name,M1s)).*/
          /* Tell im to update import db with this information (Name imports 
             M1s). */
          snd-msg(im,add-imports(Name,M1s)).
          /* im tells which modules still need to be opened 
          (= imports - already_imported) 
          */
          rec-msg(open,need-modules(M2s?)).
          /* Add those modules to the list */
          Ms := join(Ms,M2s).
          snd-msg(im,calc-import-rels(Name)).
          rec-msg(open,irels(Pairs?)).
          snd-msg(ui,irels(Pairs)) 
        +
        /* File would not open (unreadable, not exist, wrong path...) */
          rec-msg(error-opening(Str?)).
	  printf("the string is %s\n",Str).
          snd-note(ui-status(stat(Id,"Cannot open module"))).
          snd-msg(ui,cannot-open-module(Str)).
          snd-note(ui-status(endstat(Id)))
        )
      )
    )
  fi
) *
  if equal(Ms,[]) then
  /* We are finished. Inform UI */
    snd-msg(ui, finished-opening-modules)
  fi.
  snd-note(ui-status(endstat(Id)))
endlet

process Status-display(UI: user-interface)  is
let
Lst: list,
Str: str,
Id: term
in
  subscribe(ui-status(<term>)).
  ( rec-note(ui-status(stat(Id?,Str?))).
    snd-do(UI,add-status(Id, Str))
    +
    rec-note(ui-status(endstat(Id?))).
    snd-do(UI,end-status(Id))
    +
    rec-note(ui-status(error(Str?))).
    snd-do(UI,error(Str))
    +
    rec-note(ui-status(errorf(Str?,Lst?))).
    snd-do(UI,errorf(Str,Lst))
  ) *
  delta
endlet

process Retrieve-eqs(Mod: term) is
let
Id    : term,
Mod2: term,
Mods: list,
Eqs: list
in
  Id := process-id.
  snd-note(ui-status(stat(Id,"Retrieving equations"))).
  snd-msg(im,get-all-imports(Mod)).
  rec-msg(im,all-imports(Mods?)).
  snd-msg(mdb,get-equations(Mods)).
  rec-msg(retr,equations(Eqs?)).
  snd-msg(eqdb,add-equations(Mod,Eqs)).
  rec-msg(retr,equ-added(Mod2?)).
  snd-msg(rewr,finished-retrieval).
  snd-note(ui-status(endstat(Id)))
endlet

process Rewrite(Mod: term,T: term) is
let
Id: term,
List: lst,
Retr: int,
Rt: term,
Tmp: term
in
  Id := process-id.
  snd-note(ui-status(stat(Id,"Rewriting"))).
  snd-msg(eqdb,exists(Mod)).
  ( rec-msg(rewr,exists(Tmp?))
    +
    rec-msg(rewr,notexists(Tmp?)).
    create(Retrieve-eqs(Mod), Retr?).
    rec-msg(rewr,finished-retrieval)
  ).
  snd-msg(eqdb,rewrite(Mod,T)).
  rec-msg(rewr,done(Rt?)).
  snd-msg(text,view-mod(Rt)).
  snd-note(ui-status(endstat(Id)))
endlet

process Edit-module(Mod: term) is
let
Id    : term,
T     : term
in
Id := process-id.
snd-note(ui-status(stat(Id,"Opening module editor"))).
snd-msg(mdb,get-module(Mod)).
rec-msg(edit,module(T?)).
snd-msg(text,view-mod(T)).
snd-note(ui-status(endstat(Id)))
endlet

process Edit-term(Mod: term, Term: term) is
let
Id    : term,
Rewr  : int,
Str   : str,
Name  : term,
T     : term
in
  Id := process-id.
  snd-note(ui-status(stat(Id,"Opening term editor"))).
  snd-msg(io,open-term(Term)).
  ( rec-msg(opened-file(Name?,T?)).
/* This is to dissappear. Currently, editing a term is synonym for 
 * rewriting a term, since we do not have an editor. In a later stage
 * the Rewrite process should be created by the editor/user.
 */
    create(Rewrite(Mod,T),Rewr?).
    snd-msg(text,view-mod(T)).
    snd-note(ui-status(endstat(Id)))
    +
    rec-msg(error-opening(Str?)).
    snd-note(ui-status(stat(Id,"Opening term failed"))).
    snd-note(ui-status(endstat(Id)))
  )
endlet

process Ui is
let
SD    : int,
Om    : int,
EM    : int,
ET    : int,
UI    : user-interface,
Id    : term,
Name  : term,
Str   : term,
Str1  : term,
Graph : term,
Mod   : term,
Pairs : list,
ModName : str,
T       : str
in
  Id := process-id.
  execute(user-interface,UI?).
  create(Status-display(UI),SD?).
  ( /* Add a new module */
    ( rec-event(UI, add-module(Str?)).
      create(Open-modules([quote(Str)]),Om?).
      ( rec-msg(ui,imports(Name?,Str1?)).
        snd-do(UI,imports(Name,Str1))
      + rec-msg(ui,irels(Pairs?)).
        snd-do(UI,add-imports(Pairs))
      + rec-msg(ui,cannot-open-module(ModName?)).
	snd-note(ui-status(errorf("cannot open module \"%s\"",[ModName])))
      ) *
      rec-msg(ui,finished-opening-modules).
      snd-ack-event(UI, add-module(Str))
    ) +
    ( rec-event(UI,delete-module(Str?)).
      snd-note(ui-status(stat(Id,"Deleting ..."))).
      snd-msg(mdb,delete(Str)).
      rec-msg(mdb,done).
      snd-msg(prep,delete(Str)).
      rec-msg(prep,done).
      snd-msg(im,delete(Str)).
      rec-msg(im,done).
      snd-msg(eqdb,delete(Str)).
      rec-msg(eqdb,done).
      snd-note(ui-status(endstat(Id))).
      snd-ack-event(UI, delete-module(Str))
    ) +
    ( rec-event(UI,edit-module(Str?)).
      create(Edit-module(Str),EM?).
      snd-ack-event(UI,edit-module(Str))
    ) +
    ( rec-event(UI,revert-module(id(ModName?))).            /* Not yet implemented */ 
      snd-note(ui-status(errorf("TB: not implemented: revert-module(%s)",[ModName]))).
      snd-ack-event(UI,revert-module(id(ModName)))
    ) +
    ( rec-event(UI,get-module-info(Str?)).          /* Not yet implemented */ 
      snd-do(UI,module-info(Str,[["sorry","not implemented"],
          ["example",""],["dir","/home/leon/asf+sdf/spec/"],["size","10kb"]])).
      snd-ack-event(UI,get-module-info(Str))
    ) +
    ( rec-event(UI,revert-all).                     /* Not yet implemented */
      snd-note(ui-status(error("TB: not implemented: revert-all"))).
      snd-ack-event(UI,revert-all)

    ) +
    ( rec-event(UI,clear-all).                      /* Not yet implemented */ 
      /*snd-note(ui-status(error("TB: not implemented: clear-all"))).*/
      snd-note(ui-status(stat(Id,"Clearing ..."))).
      snd-msg(mdb,clear-all).
      rec-msg(mdb,done).
      snd-msg(prep,clear-all).
      rec-msg(prep,done).
      snd-msg(im,clear-all).
      rec-msg(ui,done).
      snd-msg(eqdb,clear-all).
      rec-msg(ui,done).
      snd-note(ui-status(endstat(Id))). 
      snd-ack-event(UI,clear-all)
   ) +
   ( rec-event(UI,compile-all).
     snd-note(ui-status(stat(Id,"Compiling ..."))).
     snd-msg(com,compile-all).
     rec-msg(com,done).
     snd-note(ui-status(endstat(Id))). 
     snd-ack-event(UI,compile-all)
   ) +
   ( rec-event(UI,compile-module(Str?)).
     snd-note(ui-status(stat(Id,"Compiling ..."))).
     snd-msg(com,compile-module(Str)).
     rec-msg(com,done).
     snd-note(ui-status(endstat(Id))).
     snd-ack-event(UI,compile-module(Str))
   ) +
   ( rec-event(UI,edit-term(Mod?,Str?)).
     create(Edit-term(Mod,Str),ET?).
     snd-ack-event(UI,edit-term(Mod,Str))
   ) 
  ) *
  rec-event(UI,button(quit)).
  shutdown("MSM exiting")
endlet

    

process Mdb is
let
TDB  : tree-db,
DB   : str,
T    : term,
T1   : term,
Name : term,
M    : term,
I    : list,
Sec  : term,
Mods : list,
Eqs  : list
in
/* Start up MDB and initialize the database */
  execute(tree-db,TDB?).
  snd-do(TDB,create-module-db).
  (
/* Add module with name Name and content M */
    ( rec-msg(mdb,exists(Name?)).
      snd-eval(TDB,exists(Name)).
/* The module-database-tool is asked whether this module is
   already in the database. */
      rec-value(TDB,result(T?)).
      snd-msg(open,T)
    )
    +
    ( rec-msg(mdb,add-module(Name?,M?)).
      snd-eval(TDB,add-module(M)).
/* Module added. I is the import section of the 
 * module. add-module always returns the import-section of a module, because
 * it is the only way we can see what other modules need to be opened.
 */
      rec-value(TDB,imports(Name?,I?)).
      snd-msg(open,imports(I))
    )
    +
    ( rec-msg(mdb,delete(Name?)).
      snd-eval(TDB,delete-module(Name)).
      rec-value(TDB,deleted(Name?)).
/* Module is deleted. */
      snd-msg(mdb,done)
    )
/* Clearing the module database. */
    +
    ( rec-msg(mdb,clear-all).
      snd-do(TDB,clear-module-db).
      snd-msg(mdb,done)
    ) 
    +
/* Retrieve a single module */
    ( rec-msg(mdb,get-module(Name?)).
      snd-eval(TDB,get-module(Name)).
      rec-value(TDB,getmod(T?)).
      snd-msg(edit,module(T))
    )
    +
/*
 *    ( rec-msg(mdb,edit-module(Name?)).
 *      snd-eval(TDB,expand-module(Name)).
 *      rec-value(TDB,expanded(Name?)).
 *      snd-msg(mdb,done)
 *    )
 *    +
 */
    ( rec-msg(mdb,get-equations(Mods?)).
      snd-eval(TDB,get-equations(Mods)).
      rec-value(TDB,equations(Eqs?)).
      snd-msg(retr,equations(Eqs))
    )
    +
/* Get section named Sec from module Name */
    ( rec-msg(mdb, get-mod-section(Name?,Sec?)).
      snd-eval(TDB,get-section(Name,Sec)).
      rec-value(TDB,T1?).
      snd-msg(section(Name,Sec,T1))
    )
  ) *
  delta
endlet


process Im is
let
T    : term,
DB   : str,
Name : term,
Ms   : list,
M1s  : list,
IM   : import-db,
Graph : term
in
/* Start the Import Manager and initialize its database */
  execute(import-db,IM?).
  snd-do(IM,create-import-db).
  ( ( 
/* Module Name imports modules MS */
      rec-msg(im,add-imports(Name?,Ms?)).
/* Tell IM to add imported modules */
      snd-eval(IM,add-imports(Name,Ms)).
/* T is the updated database, M1s is the list of modules that are 
 * imported by the modules in the database, but are not yet in the
 * database themselves
 */
      rec-value(IM,need-modules(M1s?)).
/* Tell process open-modules to open the other modules */
      snd-msg(open,need-modules(M1s))
    )
    +
    (
      rec-msg(im,calc-import-rels(Name?)).
      snd-eval(IM,calc-import-rels(Name)).
      rec-value(IM,irels(M1s?)).
      snd-msg(open,irels(M1s))
    )
    +
    ( rec-msg(im,delete(Name?)).
      snd-eval(IM,delete-imports(Name)).
      rec-value(IM,deleted(Name?)).
/* Module is deleted. */
      snd-msg(im,done)
    )
    +
/* Clearing the import database. */
    ( rec-msg(im,clear-all).
      snd-do(IM,clear-import-db).
      snd-msg(ui,done)
    )
    + 
    ( rec-msg(im,get-all-imports(Name?)).
      snd-eval(IM,get-all-imported-modules(Name)).
      rec-value(IM,all-imports(M1s?)).
      snd-msg(im,all-imports(M1s))
    )
    +
    ( rec-msg(im,get-all-modules).
      snd-eval(IM,get-all-modules).
      rec-value(IM,all-modules(M1s?)).
      snd-msg(im,all-modules(M1s))
    )
/* Create an import graph that can be read by Leon's UI tool, with
 * top module Name
 */
    +
    ( rec-msg(im,create-imp-graph(Name?)).
/* Tell IM to create graph */
      snd-eval(IM,create-graph(Name)).
      rec-value(IM,graph(Name,Graph?)).
/* And send it back to UI */
      snd-msg(ui,imp-graph(Name,Graph))
    )
  ) *
  delta
endlet

process Eqdb is
let
E : evaluator,
Name : term,
Eqs  : list,
T    : term,
Str  : str
in
/* Start up DB and initialize the database */
  execute(evaluator,E?).
  snd-do(E,create-equations-db).
  (
/* Add module with name Name and content M */
    ( rec-msg(eqdb,exists(Name?)).
      snd-eval(E,exists(Name)).
/* The equations-database-tool is asked whether this module is
 * already in the database. 
 */
      rec-value(E,result(T?)).
      snd-msg(rewr,T)
    )
    +
    ( rec-msg(eqdb,add-equations(Name?,Eqs?)).
      snd-eval(E,add-equations(Name,Eqs)).
/* Module added. I is the import section of the 
 * module. add-module always returns the import-section of a module, because
 * it is the only way we can see what other modules need to be  opened.  
 */
      rec-value(E,equ-added(Name?)).
      snd-msg(retr,equ-added(Name))
    )
    +
    ( rec-msg(eqdb,rewrite(Name?,T?)).
      snd-eval(E,interpret(Name,T)).
      rec-value(E,result(T?)).
      snd-msg(rewr,done(T))
    )
    +
    ( rec-msg(eqdb,delete(Name?)).
      snd-do(E,clear-equations-db).
      snd-msg(eqdb,done)
    )
    +
/* Clearing the import database. */
    ( rec-msg(eqdb,clear-all).
      snd-do(E,clear-equations-db).
      snd-msg(ui,done)
    ) 
  ) *
  delta
endlet

process Io is
let
IO   : in-output,
Name : str,
T    : term
in
  execute(in-output,IO?).
  ( ( rec-msg(io, open-file(id(Name?))).
      snd-eval(IO, open-file("module",Name))
      +
      rec-msg(io,open-term(id(Name?))).
      snd-eval(IO,open-file("term",Name))
    ).
    ( rec-value(IO,opened-file(Name?,T?)).
      snd-msg(opened-file(id(Name),T))
    + rec-value(IO,error-opening(Name?)).
      snd-msg(error-opening(Name))
    )
  )*
  delta 
endlet

process Compiler is
let
Name : term,
M    : term,
Success : term,
Mods : list,
Rnxmod : term,
Amod : term
in
  snd-msg(arm,load-arm-files(["AFuns.arm","ANumerals.arm","ATermLists.arm",
                              "ATermPrint.arm","ATermTools.arm","ATerms.arm",
                              "ATypes.arm","AVars.arm","AsFix-Basics.arm",
                              "AsFix2EQs.arm","AsFix2Epic.arm","AsFix2Sign.arm",
                              "AsFix2muASF.arm","AsFix2muASFnames.arm",
                              "AsFixParseTrees.arm","AsFixPrint.arm",
                              "Booleans.arm",
                              "Check-List-Pats.arm","EPIC.arm",
                              "Grammars.arm","Layout.arm","Literals.arm",
                              "Many-to-Single.arm","Matching.arm",
                              "MsLiterals.arm","MuASF-Basics.arm",
                              "MuASF-ManySorted.arm","MuASF-Signs.arm",
                              "MuASF-SingleSorted.arm","MuASF2EPIC.arm",
                              "MuASFc-SingleSorted.arm",
                              "MuASFdf-ManySorted.arm",
                              "MuASFdf-SingleSorted.arm",
                              "MuASFl-ManySorted.arm",
                              "MuASFl-SingleSorted.arm",
                              "MuASFmc-ManySorted.arm",
                              "MuASFmc-SingleSorted.arm",
                              "MuASFnpc-ManySorted.arm",
                              "MuASFnpc-SingleSorted.arm",
                              "MuLiterals.arm","Numerals.arm",
                              "ParseTrees.arm","RemAsFixWspace.arm",
                              "Remove-Conds.arm","Remove-Conds-Aux.arm",
                              "Remove-Lists.arm","Substitution.arm",
                              "Trans-Lookup-Pats.arm","Trans-Set-Pats.arm",
                              "VarEnv.arm",
                              "Equal.arm","Lists.arm","assocrt.arm"],
                             ["/home/markvdb/AsFix2/asfix2/spec/",
                              "/home/markvdb/AsFix2EP/muASF2/",
                              "/home/markvdb/AsFix2EP/EP/lib/"])).
  rec-msg(arm,Success?).
  snd-msg(arm,link-arm).
  (
    ( rec-msg(com,compile-all).
      snd-msg(im,get-all-modules).
      rec-msg(im,all-modules(Mods?)).
      snd-msg(prep,compile-modules(Mods)).
      rec-msg(prep,ok).
      snd-msg(com,done)
    ) 
    +
    ( rec-msg(com,compile-module(Name?)).
      snd-msg(im,get-all-imports(Name)).
      rec-msg(im,all-imports(Mods?)).
      snd-msg(prep,compile-modules(Mods)).
      rec-msg(prep,ok).
      snd-msg(com,done)
    ) 
    +
    ( rec-msg(com,compile(Name?,Rnxmod?)).
      snd-msg(arm,compile(Rnxmod)).
      rec-msg(arm,toepic(Amod?)).
      snd-msg(epic,convert(Name,Amod)).
      rec-msg(epic,done).
      snd-msg(com,done)
    )
  )* delta
endlet

process Toepic is
let
EPIC : to-epic,
Amod : term,
Name : term
in
  execute(to-epic,EPIC?).
  ( 
    rec-msg(epic, convert(Name?,Amod?)).
    snd-eval(EPIC,rnx-to-epic(Name,Amod)) .
    rec-value(EPIC,done) .
    snd-msg(epic,done)
  )* delta
endlet

process Prepare is
let
COM  : compiler,
T    : term,
T1   : term,
Name : term,
M    : term,
Rnxmod : term,
Mods : list
in
/* Start up COM and initialize the database */
  execute(compiler,COM?).
  snd-do(COM,create-module-db).
  (
    ( rec-msg(prep,add-module(Name?,M?)).
      snd-eval(COM,add-module(M)).
      rec-value(COM,ok(Name?)).
      snd-msg(open,done)
    )
    +
    ( rec-msg(prep,delete(Name?)).
      snd-eval(COM,delete-module(Name)).
      rec-value(COM,deleted(Name?)).
      snd-msg(prep,done)
    )
/* Clearing the module database. */
    +
    ( rec-msg(prep,clear-all).
      snd-do(COM,clear-module-db).
      snd-msg(prep,done)
    ) 
    +
    ( rec-msg(prep,compile-modules(Mods?)).
      snd-do(COM,compile-modules(Mods)).
      snd-msg(prep,ok).
      ( rec-event(COM,compile(Name?,Rnxmod?,Mods?)).
        snd-ack-event(COM,compile(Name,Rnxmod,Mods)).
        snd-msg(com,compile(Name,Rnxmod)).
        rec-msg(com,done)
      )*rec-event(COM,done).
      snd-ack-event(COM,done)
    )
  ) *
  delta
endlet

process ARM is
let
  Files  : list,
  Dirs : list,
  Success : term,
  Arm : arm,
  Rnxmod : term,
  Result : term
in
  execute(arm,Arm?).
  ( (
      rec-msg(arm, load-arm-files(Files?, Dirs?)) .
      snd-eval(Arm, load-arm(Files, Dirs)) .
      rec-value(Arm, load-arm(Files, Dirs, Success?)) .
      snd-msg(arm, Success)
    )
    +
    (
      rec-msg(arm, link-arm) .
      snd-do(Arm, link-arm)
    )
    +
    ( 
      rec-msg(arm, compile(Rnxmod?)).
      snd-eval(Arm,reduce(term(Rnxmod))) .
      rec-value(Arm,reduct(Result?)) .
      snd-msg(arm,toepic(Result))
    )
  )* delta
endlet


toolbus(Ui,Io,Im,Eqdb,Mdb,Compiler,Prepare,Toepic,ARM,Text-edit,Source)
