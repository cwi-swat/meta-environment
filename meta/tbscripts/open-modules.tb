/* $Id$ */

/*{{{ process BuildPath(Directory: str, Filename: str, Extension: str, Path: str?) */

process BuildPath(Directory: str, Filename: str, Extension: str, Path: str?) is
  snd-msg(io-get-filename(Directory, Filename, Extension))
  . rec-msg(io-filename(Path?))

/*}}}  */

process DrawImportGraph is
let
  ImportRelations : list
in
  snd-msg(get-import-relations) .
  rec-msg(import-relations(ImportRelations?)) .
  snd-msg(display-import-graph(ImportRelations)) .
  ImportRelations := []
endlet

process DealWithMultipleOccurrences(Chosen : str, Name : str,
                                    Extension : str, Peers : list) is
let
  Directories : list,
  Directory : str,
  FileName : str
in
  Directories := Peers .
  if not-equal(Directories, []) then
    Directory := first(Directories) .
    Directories := next(Directories) .
    BuildPath(Directory, Name, Extension, FileName?) .
    snd-msg(io-compare-files(FileName, Chosen)) .
    (
      rec-msg(io-files-equal) 
    +
      rec-msg(io-files-differ) .
      snd-note(ui-status(messagef(
      "Multiple occurrences of %s. Continuing with %s", [Name, Chosen]))) 
    )
  fi
  *
  if equal(Directories, []) then
    tau
  fi
endlet

process OpenModules is 
let
  ModuleId: str,
  Modules: list,
  Imports: list,
  Path: str,
  FileName: str,
  Type: term
in
  (
    rec-msg(open-modules(Modules?, Type?))
    .
    if not-equal(Modules, [])
    then
      ModuleId := first(Modules)
      . Modules := next(Modules)
      . LocateFile(ModuleId, Type, Path?)
      .
      if not-equal(Path, "")
      then
	snd-msg(ts-contains-key("path-modulename", Path))
	.
	(
	  rec-msg(ts-contains-key)
	+
	  rec-msg(ts-not-contains-key)
	  . OpenSyntax(Path, Type)
	  . GetModuleImports(ModuleId, Imports?)
	  . Modules := join(Imports, Modules)
	)
      else 
	Error("Opening module %s failed: file not found!", [ModuleId])
      fi
    fi
    *
    if equal(Modules, []) then
      snd-msg(finished-opening-modules)
    fi
  ) *
  delta
endlet

process Error(Message : str, MessageArgs : list) is
  snd-note(ui-status(errorf(Message, MessageArgs)))
  
process HandleOpenModuleErrors(Module: str, Error: term) is
let
  FunSym: str
in
  FunSym := fun(Error) .
  printf("HandleOpenModuleErrors: %t\n", Error) .
  if not-equal(Error, no-errors) then
    if not-equal(FunSym, "summary") then
      if equal(Error, name-inconsistent) then
        Error("Name of module %s inconsistent", [Module])
      else
        Error("Opening module %s failed: %s", [Module, Error])
      fi
    else
      snd-note(show-feedback-summary(Error))
    fi
  else
    tau
  fi
endlet

process OpenSyntax(Path: str, Type: term) is
let
  Error: term,
  Id: int,
  Message: str,
  ModuleId: str,
  ParseTable: term,
  Pid: int,
  Sort: term,
  Text: str
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Opening %s", [Path])))
  . snd-msg(io-read-file(Path))
  .
  (
    rec-msg(io-file-contents(Text?))
    . snd-msg(get-parse-table(Type))
    .
    (
      rec-msg(parse-table(Type, ParseTable?))
      . snd-msg(syntax-top-sort-hook(Type))
      . rec-msg(syntax-top-sort-hook-result(sort(Sort?)))
      . create(OpenSyntaxParseHandler(Path), Pid?)
      . ParseText(Pid, Text, ParseTable, Sort)
      .
      (
	rec-msg(open-syntax-parse-handler-done(Pid, ModuleId?))
	. SetModuleSyntaxText(ModuleId, Text)
      +
	rec-msg(open-syntax-parse-handler-done(Pid))
      )
    +
      rec-msg(no-parse-table(Type, Error?))
      . Error("No parse table: %t\n", [Error])
    )
  +
    rec-msg(io-error-reading(Message?))
    . Error("io-error-reading: %s\n", [Message])
  )
  . snd-note(ui-status(endstat(Id)))
endlet

process OpenSyntaxParseHandler(Path: str) is
let
  AnnotatedTree: term,
  Directory: str,
  Error: term,
  Extension: str,
  Filename: str,
  Imports: list,
  ModuleId: str,
  ParseResult: term,
  Pid: int,
  Summary: term
in
  Pid := process-id
  .
  (
    (
      rec-msg(parse-tree(Pid, ParseResult?))
    +
      rec-msg(parse-forest(Pid, ParseResult?, Error?))
      . ParseErrorToSummary(Error, Path, Summary?)
      . ShowSummaryInGUI(Summary)
    )
    . AnnotateTree(ParseResult, Path, AnnotatedTree?)
    . snd-msg(sm-get-module-id(ParseResult))
    . rec-msg(sm-module-id(ModuleId?))
    . snd-msg(io-get-path-directory(Path))
    . rec-msg(io-directory(Path, Directory?))
    . snd-msg(sm-get-module-path(Directory, ModuleId))
    . rec-msg(sm-module-path(Directory?))
    . snd-msg(io-get-path-extension(Path))
    . rec-msg(io-extension(Path, Extension?))
    . BuildPath(Directory, ModuleId, Extension, Filename?)
    .
    if equal(Filename, Path)
    then
      snd-msg(ts-put-str-value("module-path", ModuleId, Directory))
      . MDB-RegisterPath(Path, ModuleId)
      . SetModuleSyntaxTree(ModuleId, AnnotatedTree)
      . snd-msg(sm-get-imported-module-names(ParseResult))
      . rec-msg(sm-imported-module-names(Imports?))
      . SetModuleImports(ModuleId, Imports)
    else
      Error("Module %s should be in a file named %s\n", [ModuleId, Filename])
    fi
    . snd-msg(open-syntax-parse-handler-done(Pid, ModuleId))
  +
    rec-msg(parse-error(Pid, Error?))
    . ParseErrorToSummary(Error, Path, Summary?)
    . ShowSummaryInGUI(Summary)
    . snd-msg(open-syntax-parse-handler-done(Pid))
  )
endlet
