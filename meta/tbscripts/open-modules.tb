/* $Id$ */

process Open-initial-module is
let
  Path : str,
  Module : str,
  RealModule : str,
  Imports : list,
  Status : term
in
  (
    rec-msg(open-initial-module(Path?, Module?)).
    snd-msg(is-module-in-db(Module)).
    (
      rec-msg(not-exists-in-module-db(Module)) .
      Status := success.
      Open-Module(Module, Path, Status?, RealModule?, Imports?).
      snd-msg(open-modules(Imports)).
      rec-msg(finished-opening-modules).
      Invalidate-Dirty-ParseTables([RealModule])
    +
      rec-msg(exists-in-module-db(Module))
    ).
    snd-msg(finished-opening-initial-module)
  ) *
  delta
endlet

process Open-modules is 
let
  Id : int,
  Modules : list,
  Module : str,
  RealModules : list,
  RealModule : str,
  Imports : list,
  Status : term
in
  Id := process-id.
  (
    rec-msg(open-modules(Modules?)).
    snd-note(ui-status(stat(Id,"Opening Modules"))). 
    RealModules := [].
    if not-equal(Modules, []) then
      Module := first(Modules).
      Modules := next(Modules).
      snd-msg(is-module-in-db(Module)).
      (
        rec-msg(exists-in-module-db(Module))
      +
        rec-msg(not-exists-in-module-db(Module)).
        Status := success.
        Open-Module(Module, "", Status?, RealModule?, Imports?).
        Modules := join(Imports, Modules).
        RealModules := join(RealModules, RealModule)
      )
    fi *
    if equal(Modules, []) then
      Invalidate-Dirty-ParseTables(RealModules) .
      snd-msg(finished-opening-modules)
    fi.
    snd-note(ui-status(endstat(Id)))
  ) *
  delta
endlet

process Invalidate-Dirty-ParseTables(Modules : list) is
let
  Runner : list,
  Module : str
in
  Runner := Modules.
  if not-equal(Runner, []) then
    Module := first(Runner).
    Runner := next(Runner).
    snd-msg(invalidate-parse-tables(Module))
  fi *
  if equal(Runner, []) then
    tau
  fi
endlet

process Open-Module (Module : str, Path : str, Status : term?, 
                     RealModule : str?, Imports : list?) 
is
let
  Id : int,
  RealPath : str
in
  Id := process-id.
  snd-note(ui-status(statf(Id,"Opening %s",[Module]))).
  Imports := [].
  (
    Open-Syntax(Module, Path, Status?, RealModule?, RealPath?, Imports?).
    if equal(Status, success) then
      Open-ParseTables(RealModule, RealPath).
      Open-Equations(RealModule, RealPath)
    else
      RealModule := Module.
      Handle-Open-Module-Errors(RealModule, Status)
    fi
  ).
  snd-note(ui-status(endstat(Id)))
endlet

process Add-Empty-Module(Module : str) is
  snd-msg(add-empty-module-to-db(Module)).
  rec-msg(empty-module-added)

process Error(Message : str, MessageArgs : list) is
  snd-note(ui-status(errorf(Message, MessageArgs)))
  
process Handle-Open-Module-Errors(Module : str, Status : term) is
  if not-equal(Status, success) then
    Error("Opening module %s failed: %s", [Module, Status])
//    Add-Empty-Module(Module)
  else
    tau
  fi

process Open-Syntax (Module : str, Path : str, Status : term?, 
                     RealModule : str?, RealPath : str?, Imports : list?) 
is
let
  Tree : term,
  Text : str,
  Time : term,
  Dummy : str
in
  Tree := no-tree.
  /* Either the path is specified by the user, or we used the search-path */
  if equal(Path, "") then
    snd-msg(open-syntax-file(Module)) 
  else
    snd-msg(open-file(Path))
  fi.
  (
    rec-msg(opened-file(Path,tree(Tree?), RealPath?, Time?))
  +
    rec-msg(opened-file(Module, tree(Tree?), RealPath?, Time?))
  +
    (
      rec-msg(opened-file(Path,text(Text?), RealPath?,Time?))
    +
      rec-msg(opened-file(Module,text(Text?), RealPath?,Time?))
    ).
    Parse-Syntax(Text, Status?, Tree?)
  +
    rec-msg(error-opening(Module)).
    Status := no-such-file
  ).
  if equal(Status,success) then
    Imports := [].
    snd-msg(add-sdf-module-to-db(Module, RealPath, Tree, Time)).
    (
      rec-msg(real-module-name(Module, RealModule?)).
      rec-msg(need-modules(Imports?))
    +
      rec-msg(error-opening(Module, Status?))
    )
  else
    tau
  fi
endlet

process Parse-Syntax (Text : str, Status : term?, Tree : term?) is
let
  Id : int,
  Errors : list,
  Error : term
in
  Id := process-id.
  snd-msg(open-sdf2-language).
  rec-msg(sdf2-language-opened).
  snd-msg(Id,parse-string-as-asfix2me(trm("Sdf2"),"Module",Text)).
  ( 
    rec-msg(parse-result-asfix2me(Id?, parse-tree(Tree?)))
  +
    rec-msg(parse-result-asfix2me(Id?, parse-error(Errors?, Error?))).
    Status := parse-error 
  )
endlet

process Open-ParseTables (Module : str, Path : str) is
let
  Table : term,
  Time : term
in
  snd-msg(open-parse-table(Module, Path, asf)).
  (
    rec-msg(table-on-disk(Table?, Time?)).
    snd-msg(add-parse-table-to-db(eqs(Module), Table, Time)).
    rec-msg(parse-table-added)
  +
    rec-msg(no-table-on-disk)
  ).
  snd-msg(open-parse-table(Module, Path, trm)).
  (
    rec-msg(table-on-disk(Table?, Time?)).
    snd-msg(add-parse-table-to-db(trm(Module), Table, Time)).
    rec-msg(parse-table-added)
  +
    rec-msg(no-table-on-disk)
  )
endlet

process Open-Equations (Module : str, Path : str)  is
let
  Time : term,
  Tree : term,
  Text : str,
  RealPath : str
in
  snd-msg(open-rules-file(Module, Path)).
  (
    rec-msg(opened-file(Module, text(Text?) , RealPath?, Time?)).
    snd-msg(add-eqs-to-db(Module, RealPath, text(Text), Time)) .
    rec-msg(eqs-added)
  +
    rec-msg(opened-file(Module, tree(Tree?) , RealPath?, Time?)).
    snd-msg(unparse(Tree)) .
    rec-msg(unparsed-text(Text?)) .
    snd-msg(add-eqs-to-db(Module, RealPath, tree(Tree), text(Text), Time)) .
    rec-msg(eqs-added)
  +
    rec-msg(error-opening(Module))
  )
endlet
