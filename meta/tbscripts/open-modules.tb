#include <module-manager.tb>
#include <sdf-modules.tb>
#include <parse-focuses.tb>
#include <term-actions.tb>

#include "sdf-namespace.h"

#define EMPTY_PATH ""

process LocateFile(Modulename: str, Type: term, Path: str?) is
let
  Extension: str,
  Directory: str,
  Directories: list,
  ExtraModules : list
in
  snd-msg(cm-get-module-paths)
  . rec-msg(cm-module-paths(Directories?))
  . snd-msg(file-extension-hook(Type))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-find-file(Directories, Modulename, Extension))
  .
  (
    rec-msg(io-file-not-found)
    . Path := ""
  +
    rec-msg(io-file-found(Directories?))
    . TODO("Directory is not a str\n")
    . Directory := first(Directories)
    . Directories := next(Directories)
    .
    if not-equal(Directories, []) then
      DealWithMultipleOccurrences(Directory, Modulename, Extension, Directories)
    else
      tau
    fi
    . BuildPath(Directory, Modulename, Extension, Path?)
  )
endlet

process BuildPath(Directory: str, Filename: str, Extension: str, Path: str?) is
  snd-msg(io-get-filename(Directory, Filename, Extension))
  . rec-msg(io-filename(Path?))

process ReplaceExtension(SrcPath: str, NewExtension: str, DstPath: str?) is
let
  Directory: str,
  OldExtension: str,
  Filename: str
in
  SplitFilename(SrcPath, Filename?, Directory?, OldExtension?)
  . BuildPath(Directory, Filename, NewExtension, DstPath?)
endlet

process DealWithMultipleOccurrences(Chosen: str, Name: str, Extension: str,
                                    Peers: list) is
let
  Directories: list,
  Directory: str,
  FileName: str,
  PeerName: str
in
  Directories := Peers
  .
  if not-equal(Directories, []) then
    Directory := first(Directories)
    . Directories := next(Directories)
    . BuildPath(Directory, Name, Extension, FileName?)
    . BuildPath(Chosen, Name, Extension, PeerName?)
    . snd-msg(io-compare-files(PeerName, FileName))
    .
    (
      rec-msg(io-files-equal)
    +
      rec-msg(io-files-differ)
      . snd-note(ui-status(messagef("Multiple occurrences of %s. Continuing with %s",
                                    [Name, PeerName])))
    )
  fi
  *
  if equal(Directories, []) then
    tau
  fi
endlet

process IsLibraryModule(ModuleId: term, LibraryModule: bool?) is
let
  Directories: list,
  Extension: str,
  Filename: str,
  Modulename: str,
  Path: str,
  Prefix: str
in
  snd-msg(cm-get-library-paths)
  . rec-msg(cm-library-paths(Directories?))
  . GetModulePath(ModuleId, SDF_NAMESPACE, Path?)
  . snd-msg(io-get-relative-filename(Directories, Path, ".sdf"))
  . rec-msg(io-filename(Directories, Path, ".sdf", Prefix?, Filename?))
  .
  if equal(Filename, "") then
    LibraryModule := false
  else
    LibraryModule := true
  fi
endlet

process CreateModule(Modulename: str, ModuleId: term?) is
  MM-GetModuleIdByAttribute(SDF_NAMESPACE, "name", Modulename, ModuleId?)
  .
  if equal(ModuleId, UNDEFINED) then
    MM-CreateModule(ModuleId?)
    . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename)
    . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", unknown)
  else
    tau
  fi

process OpenModule(Modulename: str, ModuleId: term?) is
let
  Editable: bool,
  LibraryModule: bool,
  Path: str,
  SdfExt: str
in
  CreateModule(Modulename, ModuleId?)
  . GetModulePath(ModuleId, SDF_NAMESPACE, Path?)
  .
  if equal(Path, EMPTY_PATH) then
    LocateFile(Modulename, sdf, Path?)
    .
    if equal(Path, EMPTY_PATH) then
      Error("Unable to locate module: %s", [Modulename])
      . snd-msg(file-extension-hook(sdf))
      . rec-msg(file-extension-hook-result(SdfExt?))
      . BuildPath(".", Modulename, SdfExt, Path?)
      . SetModulePath(ModuleId, SDF_NAMESPACE, Path)
      . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "editable", true)
      . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", unavailable)
    else
      SetModulePath(ModuleId, SDF_NAMESPACE, Path)
      . IsLibraryModule(ModuleId, LibraryModule?)
      . Editable := not(LibraryModule)
      . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "editable", Editable)
      . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", available)
    fi
  else
    tau
  fi
endlet

process SDFModuleParser is
let
  Event: attribute-changed-event,
  ModuleId: term,
  NewPath: term
in
  MM-Subscribe-Attribute-Changed(<term>,SDF_NAMESPACE,"status",<term>,available)
  .
  (
    rec-note(mm-attribute-changed(Event?))
    . ACE-GetModuleId(Event, ModuleId?)
    . OpenSyntax(ModuleId)
  )
  *
  delta
endlet

toolbus(SDFModuleParser)

process SDFSetModuleImports is
let
  Event: attribute-changed-event,
  Import: str,
  ImportId: term,
  Imports: list,
  ModuleId: term,
  Tree: term
in
  MM-Subscribe-Attribute-Changed(<term>,SDF_NAMESPACE,"status",<term>,parsed)
  .
  (
    rec-note(mm-attribute-changed(Event?))
    . ACE-GetModuleId(Event, ModuleId?)
    . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", opening)
    . GetModuleSyntaxTree(ModuleId, Tree?)
    . GetImportedModulenames(Tree, Imports?)
    .
    if not-equal(Imports, []) then 
      Import := first(Imports)
      . Imports := next(Imports)
      . OpenModule(Import, ImportId?)
      . MM-AddModuleDependency(ModuleId, ImportId)
    fi
    *
    if equal(Imports, []) then
      MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", opened)
    fi
  )
  *
  delta
endlet

toolbus(SDFSetModuleImports)

process SDFRemoveDependencies is
let
  Event: attribute-changed-event,
  ModuleId: term
in
  MM-Subscribe-Attribute-Changed(<term>,SDF_NAMESPACE,"status",<term>,error)
  . MM-Subscribe-Attribute-Changed(<term>,SDF_NAMESPACE,"status",<term>,unknown)
  .
  (
    rec-note(mm-attribute-changed(Event?))
    . ACE-GetModuleId(Event, ModuleId?)
    . DeleteModuleSyntaxTree(ModuleId)
    . MM-DeleteModuleDependencies(ModuleId)
  )
  *
  delta
endlet

toolbus(SDFRemoveDependencies)

process Error(Message: str, MessageArgs: list) is
  snd-note(ui-status(errorf(Message, MessageArgs)))

process OpenSyntax(ModuleId: term) is
let
  Error: term,
  Id: int,
  Modulename: str,
  ParseTable: term,
  Path: str,
  Pid: int,
  Text: str,
  Type: term
in
  Id := process-id
  . Type := sdf
  . GetModulePath(ModuleId, SDF_NAMESPACE, Path?)
  . ReadFile(Path, Text?)
  .
  if not-equal(Text, "") then
    GetParseTable(ModuleId, Type, ParseTable?)
    . create(OpenSyntaxParseHandler(ModuleId), Pid?)
    . ParseText(Pid, Text, ParseTable, "Module")
    .
    (
      rec-msg(open-syntax-parse-handler-done(Pid, ModuleId))
      . SetModuleSyntaxText(ModuleId, Text)
    +
      rec-msg(open-syntax-parse-handler-done(Pid))
    )
  else
    Error("TODO fix this error io-error-reading: %t\n", [Error])
  fi
endlet

process OpenSyntaxParseHandler(ModuleId: term) is
let
  AnnotatedTree: term,
  Directory: str,
  ErrorMessage: term,
  Extension: str,
  File: str,
  Imports: list,
  Modulename: str,
  ParseError: term,
  ParseResult: term,
  Path: str,
  Pid: int,
  CheckPid: int,
  Summary: term
in
  Pid := process-id
  . GetModulePath(ModuleId, SDF_NAMESPACE, Path?)
  .
  (
    (
      rec-msg(parse-tree(Pid, ParseResult?))
    +
      rec-msg(parse-forest(Pid, ParseResult?, ErrorMessage?))
      . AddFilenameToParseError(ErrorMessage, Path, ParseError?)
      . snd-msg(es-make-summary("sglr", Path, [ParseError]))
      . rec-msg(es-summary(Summary?))
      . snd-msg(ui-show-feedback-summary(Summary))
    )
    . snd-msg(sm-get-module-id(ParseResult))
    . rec-msg(sm-module-id(Modulename?))
    . snd-msg(io-get-path-directory(Path))
    . rec-msg(io-directory(Path, Directory?))
    . snd-msg(sm-get-module-path(Directory, Modulename))
    . rec-msg(sm-module-path(Directory?))
    . snd-msg(io-get-path-extension(Path))
    . rec-msg(io-extension(Path, Extension?))
    . BuildPath(Directory, Modulename, Extension, File?)
    .
    if equal(File, Path) then
      SetModuleSyntaxTree(ModuleId, ParseResult)
      . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", parsed)
      . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "name", Modulename)
      /* Use Listener to check Syntax Specification */
      /*. create (CheckSyntaxSpecification(ModuleId), CheckPid?)*/
    else
      Error("Module %s should be in a file named %s\n", [Modulename, File])
      . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", error)
    fi
    . snd-msg(open-syntax-parse-handler-done(Pid, ModuleId))
  +
    rec-msg(parse-error(Pid, ErrorMessage?))
    . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "status", error)
    . AddFilenameToParseError(ErrorMessage, Path, ParseError?)
    . snd-msg(es-make-summary("sglr", Path, [ParseError]))
    . rec-msg(es-summary(Summary?))
    . snd-msg(ui-show-feedback-summary(Summary))
    . snd-msg(open-syntax-parse-handler-done(Pid))
  )
endlet

process AnnotateTreeListener is
let
  AnnotatedTree: term,
  Event: attribute-changed-event,
  ModuleId: term,
  Path: str,
  Tree: term
in
  MM-Subscribe-Attribute-Changed(<term>,SDF_NAMESPACE,"status",<term>,parsed)
  .
  (
    rec-note(mm-attribute-changed(Event?))
    . ACE-GetModuleId(Event, ModuleId?)
    . GetModuleSyntaxTree(ModuleId, Tree?)
    . GetModulePath(ModuleId, SDF_NAMESPACE, Path?)
    . AnnotateTree(Tree, Path, AnnotatedTree?)
    . SetModuleSyntaxTree(ModuleId, AnnotatedTree)
    . MM-SetAttribute(ModuleId, SDF_NAMESPACE, "annotated", true)
  )
  *
  delta
endlet

toolbus(AnnotateTreeListener)

process SetModuleSyntaxText(ModuleId: term, Text: str) is
  snd-msg(ts-put-str-value("sdf-text", ModuleId, Text))

process SetModuleSyntaxTree(ModuleId: term, Tree: term) is
  snd-msg(ts-put-term-value("sdf-tree", ModuleId, Tree))

process GetModuleSyntaxTree(ModuleId: term, Tree: term?) is
  snd-msg(ts-get-term-value("sdf-tree", ModuleId))
  .
  (
    rec-msg(ts-value("sdf-tree", ModuleId, Tree?))
  +
    rec-msg(ts-no-value("sdf-tree", ModuleId))
    . Tree := UNDEFINED
  )

process DeleteModuleSyntaxTree(ModuleId: term) is
  snd-msg(ts-remove-value("sdf-tree", ModuleId))

process SetModuleEquationsTree(ModuleId: term, Tree: term) is
  snd-msg(ts-put-term-value("asf-tree", ModuleId, Tree))

process GetModuleEquationsTree(ModuleId: term, Tree: term?) is
  snd-msg(ts-get-term-value("asf-tree", ModuleId))
  .
  (
    rec-msg(ts-value("asf-tree", ModuleId, Tree?))
  +
    rec-msg(ts-no-value("asf-tree", ModuleId))
    . Tree := UNDEFINED
  )

process DeleteModuleEquationsTree(ModuleId: term) is
  snd-msg(ts-remove-value("asf-tree", ModuleId))

process GetModulePath(ModuleId: term, Namespace: term, Path: str?) is
let
  Term: path,
  HasAttribute: bool
in
  MM-HasAttribute(ModuleId, Namespace, "path", HasAttribute?)
  .
  if equal(HasAttribute, true) then
    MM-GetAttribute(ModuleId, Namespace, "path", Term?)
    . Path := first(args(Term))
  else
    Path := EMPTY_PATH
  fi
endlet

process SetModulePath(ModuleId: term, Namespace: term, Path: str) is
let
  Term: path
in
  Term := quote(path(Path))
  . MM-SetAttribute(ModuleId, Namespace, "path", Term)
endlet

