process LocateFile(ModuleId: str, Type: term, Path: str?) is
let
  Extension: str,
  Directory: str,
  Directories: list,
  ExtraModules : list
in
  snd-msg(get-module-paths)
  . rec-msg(module-paths(Directories?))
  /* Motivation for the extra-mod-path-hook
     We need to be able to locate files outside the current directory and
     the asf-library. Furthermore we must avoid collision with files
     created by the user. */
  . snd-msg(extra-mod-path-hook)
  . rec-msg(extra-mod-path-hook-result(ExtraModules?))
  .
  if not-equal(ExtraModules, []) then
    Directories := ExtraModules
  else
    tau
  fi


  . snd-msg(file-extension-hook(Type))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-find-file(Directories, ModuleId, Extension))
  .
  (
    rec-msg(io-file-not-found)
    . Path := ""
  +
    rec-msg(io-file-found(Directories?))
    . Directory := first(Directories)
    . Directories := next(Directories)
    .
    if not-equal(Directories, []) then
      DealWithMultipleOccurrences(Directory, ModuleId, Extension, Directories)
    else
      tau
    fi
    . BuildPath(Directory, ModuleId, Extension, Path?)
  )
endlet

process BuildPath(Directory: str, Filename: str, Extension: str, Path: str?) is
  snd-msg(io-get-filename(Directory, Filename, Extension))
  . rec-msg(io-filename(Path?))

process ReplaceExtension(SrcPath: str, Extension: str, DstPath: str?) is
let
  Directory: str,
  Filename: str
in
  snd-msg(io-get-path-directory(SrcPath))
  . rec-msg(io-directory(SrcPath, Directory?))
  . snd-msg(io-get-path-filename(SrcPath))
  . rec-msg(io-filename(SrcPath, Filename?))
  . BuildPath(Directory, Filename, Extension, DstPath?)
endlet

process DealWithMultipleOccurrences(Chosen: str, Name: str, Extension: str,
                                    Peers: list) is
let
  Directories: list,
  Directory: str,
  FileName: str,
  PeerName: str
in
  Directories := Peers
  .
  if not-equal(Directories, []) then
    Directory := first(Directories)
    . Directories := next(Directories)
    . BuildPath(Directory, Name, Extension, FileName?)
    . BuildPath(Chosen, Name, Extension, PeerName?)
    . snd-msg(io-compare-files(PeerName, FileName))
    .
    (
      rec-msg(io-files-equal)
    +
      rec-msg(io-files-differ)
      . snd-note(ui-status(messagef("Multiple occurrences of %s. Continuing with %s",
                                    [Name, PeerName])))
    )
  fi
  *
  if equal(Directories, []) then
    tau
  fi
endlet

process OpenModule(Path: str, Type: term, ModuleId: str) is
let
  Modulename: str,
  Imports: list
in
  snd-msg(ts-put-str-value("path-weak-modulename", Path, ModuleId))
  . OpenSyntax(Path, Type)
  . snd-msg(ts-get-str-value("path-modulename", Path))
  .
  (
    rec-msg(ts-value(Modulename?))
    . GetModuleImports(Modulename, Imports?)
    . OpenModules(Imports, Type)
  +
    rec-msg(ts-no-value)
  )
endlet

process OpenModules(Modules: list, Type: term) is
let
  Imports: list,
  ModuleId: str,
  Path: str,
  Todo: list
in
  Todo := Modules
  . snd-note(start-modules-batch)
  .
  if not-equal(Todo, []) then
    ModuleId := first(Todo)
    . Todo := next(Todo)
    . LocateFile(ModuleId, Type, Path?)
    .
    if equal(Path, "") then
      Error("Unable to locate module: %s", [ModuleId])
    else
      snd-msg(ts-contains-key("path-modulename", Path))
      .
      (
        rec-msg(ts-contains-key)
      +
        rec-msg(ts-not-contains-key)
        . snd-msg(ts-put-str-value("path-weak-modulename", Path, ModuleId))
        . OpenSyntax(Path, Type)
        . GetModuleImports(ModuleId, Imports?)
        . Todo := join(Imports, Todo)
      )
    fi
  fi
  *
  if equal(Todo, []) then
    snd-note(end-modules-batch)
  fi
endlet

process Error(Message: str, MessageArgs: list) is
  snd-note(ui-status(errorf(Message, MessageArgs)))

process OpenSyntax(Path: str, Type: term) is
let
  Error: term,
  Id: int,
  ModuleId: str,
  ParseTable: term,
  Pid: int,
  Sort: term,
  Text: str
in
  Id := process-id
  . snd-note(ui-status(statf(Id, "Opening %s", [Path])))
  . snd-msg(io-read-file(Path))
  .
  (
    rec-msg(io-file-contents(Text?))
    . snd-msg(get-parse-table(Type))
    .
    (
      rec-msg(parse-table(Type, ParseTable?))
      . snd-msg(syntax-top-sort-hook(Type))
      . rec-msg(syntax-top-sort-hook-result(sort(Sort?)))
      /* Motivation for the get-open-syntax-parse-handler-hook
         The choice of syntax parse handler is dependent of the type of module,
         which needs to be parsed. */
      . snd-msg(get-open-syntax-parse-handler-hook(Type, Path))
      . rec-msg(get-open-syntax-parse-handler-hook-result(Pid?))
      . ParseText(Pid, Text, ParseTable, Sort)
      .
      (
        rec-msg(open-syntax-parse-handler-done(Pid, ModuleId?))
	.
	if equal(Type, sdf) then
	  SetModuleSyntaxText(ModuleId, Text)
	else
        /* Motivation for the set-module-syntax-text-hook
           Which table the module text needs to be saved in is depending on the
           type of module. */
	  snd-msg(set-module-syntax-text-hook(Type, ModuleId, Text))	
	fi
      +
        rec-msg(open-syntax-parse-handler-done(Pid))
      )
    +
      rec-msg(no-parse-table(Type, Error?))
      . Error("TODO fix the error No parse table: %t\n", [Error])
    )
  +
    rec-msg(io-error-reading(Error?))
    . Error("TODO fix this error io-error-reading: %t\n", [Error])
  )
  . snd-note(ui-status(endstat(Id)))
endlet

process OpenSyntaxParseHandler(Path: str) is
let
  AnnotatedTree: term,
  Directory: str,
  Error: term,
  Extension: str,
  Filename: str,
  Imports: list,
  ModuleId: str,
  ParseResult: term,
  Pid: int,
  Summary: term
in
  Pid := process-id
  .
  (
    (
      rec-msg(parse-tree(Pid, ParseResult?))
    +
      rec-msg(parse-forest(Pid, ParseResult?, Error?))
      . ParseErrorToSummary(Error, Path, Summary?)
      . snd-msg(ui-show-feedback-summary(Summary))
    )
    . AnnotateTree(ParseResult, Path, AnnotatedTree?)
    . snd-msg(sm-get-module-id(ParseResult))
    . rec-msg(sm-module-id(ModuleId?))
    . snd-msg(io-get-path-directory(Path))
    . rec-msg(io-directory(Path, Directory?))
    . snd-msg(sm-get-module-path(Directory, ModuleId))
    . rec-msg(sm-module-path(Directory?))
    . snd-msg(io-get-path-extension(Path))
    . rec-msg(io-extension(Path, Extension?))
    . BuildPath(Directory, ModuleId, Extension, Filename?)
    .
    if equal(Filename, Path) then
      snd-msg(ts-put-str-value("module-path", ModuleId, Directory))
      /*. printf("registering %s -> %s\n", Path, ModuleId)*/
      . snd-msg(ts-put-str-value("path-modulename", Path, ModuleId))
      . SetModuleSyntaxTree(ModuleId, AnnotatedTree)
      . snd-msg(sm-get-imported-module-names(ParseResult))
      . rec-msg(sm-imported-module-names(Imports?))
      . SetModuleImports(ModuleId, Imports)
    else
      Error("Module %s should be in a file named %s\n", [ModuleId, Filename])
    fi
    . snd-msg(open-syntax-parse-handler-done(Pid, ModuleId))
  +
    rec-msg(parse-error(Pid, Error?))
    . ParseErrorToSummary(Error, Path, Summary?)
    . snd-msg(ui-show-feedback-summary(Summary))
    . snd-msg(open-syntax-parse-handler-done(Pid))
  )
endlet
