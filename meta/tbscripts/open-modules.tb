/* $Id$ */

process Open-initial-module is
let
  Path : str,
  Module : str,
  RealModule : str,
  Imports : list,
  Status : term
in
  (
    rec-msg(open-initial-module(Path?, Module?)).
    snd-msg(is-module-in-db(Module)).
    (
      rec-msg(not-exists-in-module-db(Module)) .
      Status := success.
      Open-Module(Module, Path, Status?, RealModule?, Imports?).
      snd-msg(open-modules(Imports)).
      rec-msg(finished-opening-modules).
      Invalidate-Dirty-ParseTables([RealModule])
    +
      rec-msg(exists-in-module-db(Module))
    )
  ) *
  delta
endlet

process DrawImportGraph is
let
  Nodes : list,
  Vertices : list
in
  snd-msg(get-import-graph) .
  rec-msg(import-graph(Nodes?, Vertices?)) .
  snd-msg(display-import-graph(Nodes,Vertices))
endlet

process LocateFile(Name : str, Extension : str, Path : str?) is
let
  Directories : list,
  Chosen : str
in
  snd-msg(get-search-paths) .
  rec-msg(search-paths(Directories?)) .
  snd-msg(find-file(Directories, Name, Extension)) .
  (
    rec-msg(file-not-found) .
    Path := "" 
  +
    rec-msg(file-found(Directories?)) .
    Path := first(Directories) .
    Directories := next(Directories) .
    if not-equal(Directories, []) then
      snd-msg(get-filename(Path, Name, Extension)) .
      rec-msg(filename(Chosen?)) .
      DealWithMultipleOccurrences(Chosen, Name, Extension, Directories)
    else
      tau
    fi
  )
endlet

process DealWithMultipleOccurrences(Chosen : str, Name : str,
                                    Extension : str, Peers : list) is
let
  Directories : list,
  Directory : str,
  FileName : str
in
  Directories := Peers .
  if not-equal(Directories, []) then
    Directory := first(Directories) .
    Directories := next(Directories) .
    snd-msg(get-filename(Directory, Name, Extension)) .
    rec-msg(filename(FileName?)) .
    snd-msg(compare-files(FileName, Chosen)) .
    (
      rec-msg(files-equal) .
      snd-note(ui-status(errorf("Multiple occurrences of %s:\n%s and %s",
                                [Name,Chosen,FileName])))
    +
      rec-msg(files-differ)
    )
  fi
  *
  if equal(Directories, []) then
    tau
  fi
endlet

process Open-modules is 
let
  Id : int,
  Modules : list,
  Module : str,
  RealModules : list,
  RealModule : str,
  Imports : list,
  Status : term,
  Path : str
in
  Id := process-id.
  (
    rec-msg(open-modules(Modules?)).
    snd-note(ui-status(stat(Id,"Opening Modules"))). 
    RealModules := [].
    if not-equal(Modules, []) then
      Module := first(Modules).
      Modules := next(Modules).
      snd-msg(is-module-in-db(Module)).
      (
        rec-msg(exists-in-module-db(Module))
      +
        rec-msg(not-exists-in-module-db(Module)).
        Status := success.
	LocateFile(Module, ".sdf", Path?) .
        Open-Module(Module, Path, Status?, RealModule?, Imports?).
        Modules := join(Imports, Modules).
        RealModules := join(RealModules, RealModule)
      )
    fi *
    if equal(Modules, []) then
      Invalidate-Dirty-ParseTables(RealModules) .
      DrawImportGraph() .
      snd-msg(finished-opening-modules)
    fi.
    snd-note(ui-status(endstat(Id)))
  ) *
  delta
endlet

process Invalidate-Dirty-ParseTables(Modules : list) is
let
  Runner : list,
  Module : str
in
  Runner := Modules.
  if not-equal(Runner, []) then
    Module := first(Runner).
    Runner := next(Runner).
    snd-msg(invalidate-parse-tables(Module))
  fi *
  if equal(Runner, []) then
    tau
  fi
endlet

process Open-Module(Module : str, Path : str, Status : term?, 
                    RealModule : str?, Imports : list?) 
is
let
  Id : int,
  RealPath : str
in
  Id := process-id.
  snd-note(ui-status(statf(Id,"Opening %s",[Module]))).
  Imports := [].
  (
    Open-Syntax(Module, Path, Status?, RealModule?, Imports?).
    if equal(Status, success) then
      Open-Equations(RealModule, Path)
    else
      RealModule := Module.
      Handle-Open-Module-Errors(RealModule, Status)
    fi
  ).
  snd-note(ui-status(endstat(Id)))
endlet

process Error(Message : str, MessageArgs : list) is
  snd-note(ui-status(errorf(Message, MessageArgs)))
  
process Handle-Open-Module-Errors(Module : str, Status : term) is
  if not-equal(Status, success) then
    Error("Opening module %s failed: %s", [Module, Status])
  else
    tau
  fi

process Open-Syntax(Module : str, Path : str, Status : term?, 
                    RealModule : str?, Imports : list?) is
let
  Tree : term,
  Text : str,
  Dummy : str,
  Message : str
in
  Tree := no-tree.
  if not-equal(Path, "") then
    snd-msg(read-file(Path, ".sdf")) .
    (
      rec-msg(file-contents(Text?)) .
      Parse-Syntax(Text, Status?, Tree?)
    +
      rec-msg(error-reading(Message?)) .
      Status := no-such-file
    )
  else
     Status := no-such-file
  fi .
  if equal(Status, success) then
    Imports := [].
    snd-msg(add-sdf-module-to-db(Module, Path, Text, Tree)).
    (
      rec-msg(adding-succeeded(Module, RealModule?, Imports?))
    +
      rec-msg(error-opening(Module, Status?))
    )
  else
    tau
  fi
endlet

process Parse-Syntax (Text : str, Status : term?, Tree : term?) is
let
  Id : int,
  Errors : list,
  Error : term
in
  Id := process-id.
  snd-msg(open-sdf2-language).
  rec-msg(sdf2-language-opened).
  snd-msg(Id,parse-string-as-asfix2me(trm("Sdf2"),"Module",Text)).
  ( 
    rec-msg(parse-result-asfix2me(Id?, parse-tree(Tree?)))
  +
    rec-msg(parse-result-asfix2me(Id?, parse-error(Errors?, Error?))).
    Status := parse-error 
  )
endlet

process Open-Equations (Module : str, Path : str)  is
let
  Tree : term,
  Text : str,
  RealPath : str,
  ErrorMessage : str
in
  snd-msg(read-file(Path, ".asf")).
  (
    rec-msg(file-contents(Text?)) .
    snd-msg(add-eqs-to-db(Module, text(Text))) .
    rec-msg(eqs-added)
  +
    rec-msg(error-reading(ErrorMessage?))
  )
endlet
