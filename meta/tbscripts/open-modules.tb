/* $Id$ */

process Open-initial-module is
let
  Path : str,
  Module : str,
  Extension : str,
  Imports : list,
  Type : term
in
  (
    rec-msg(open-initial-module(Path?, Module?, Extension?)) .
    if equal(Extension, "") then
      Type := quote(sdf)
    else 
      snd-msg(extension-to-type-hook(Extension)) .
      rec-msg(extension-to-type-hook-result(Type?))
    fi .
    snd-msg(is-module-in-db(Module)).
    (
      rec-msg(not-exists-in-module-db(Module)) .
      Open-Module(Path, Module, Type, Imports?).
      snd-msg(open-modules(Imports, Type)).
      rec-msg(finished-opening-modules)
    +
      rec-msg(exists-in-module-db(Module))
    )
  ) *
  delta
endlet

process DrawImportGraph is
let
  ImportRelations : list
in
  snd-msg(get-import-relations) .
  rec-msg(import-relations(ImportRelations?)) .
  printf("ImportRelations: %t\n", ImportRelations) .
  snd-note(display-import-graph(ImportRelations)) .
  ImportRelations := []
endlet

process LocateFile(Name : str, Extension : str, Path : str?) is
let
  Directories : list,
  Chosen : str
in
  snd-msg(get-search-paths) .
  rec-msg(search-paths(Directories?)) .
  snd-msg(io-find-file(Directories, Name, Extension)) .
  (
    rec-msg(io-file-not-found) .
    Path := "" 
  +
    rec-msg(io-file-found(Directories?)) .
    Path := first(Directories) .
    Directories := next(Directories) .
    if not-equal(Directories, []) then
      snd-msg(io-get-filename(Path, Name, Extension)) .
      rec-msg(io-filename(Chosen?)) .
      DealWithMultipleOccurrences(Chosen, Name, Extension, Directories)
    else
      tau
    fi
  )
endlet

process DealWithMultipleOccurrences(Chosen : str, Name : str,
                                    Extension : str, Peers : list) is
let
  Directories : list,
  Directory : str,
  FileName : str
in
  Directories := Peers .
  if not-equal(Directories, []) then
    Directory := first(Directories) .
    Directories := next(Directories) .
    snd-msg(io-get-filename(Directory, Name, Extension)) .
    rec-msg(io-filename(FileName?)) .
    snd-msg(io-compare-files(FileName, Chosen)) .
    (
      rec-msg(io-files-equal) 
    +
      rec-msg(io-files-differ) .
      snd-note(ui-status(messagef(
      "Multiple occurrences of %s. Continuing with %s",
                                [Name, Chosen]))) 
    )
  fi
  *
  if equal(Directories, []) then
    tau
  fi
endlet

process Open-modules is 
let
  Id : int,
  Modules : list,
  Module : str,
  Imports : list,
  Path : str,
  FileName : str,
  Extension : str,
  Changed : term,
  Type : term
in
  Id := process-id.
  (
    rec-msg(open-modules(Modules?, Type?)).
    Changed := true .
    snd-note(ui-status(stat(Id,"Opening Modules"))). 
    if not-equal(Modules, []) then
      Module := first(Modules).
      Modules := next(Modules).
      snd-msg(is-module-in-db(Module)).
      (
        rec-msg(exists-in-module-db(Module))
      +
        rec-msg(not-exists-in-module-db(Module)).
	snd-msg(file-extension-hook(Type)) .
	rec-msg(file-extension-hook-result(Extension?)) .
        LocateFile(Module, Extension, Path?) .
	if not-equal(Path, "") then
          Open-Module(Path, Module, Type, Imports?).
          Modules := join(Imports, Modules)
        else 
          Error("Opening module %s failed: file not found!", [Module])
        fi
      )
    fi *
    if equal(Modules, []) then
      if equal(Changed, true) then
        DrawImportGraph()
      else
        tau
      fi .
      snd-note(ui-status(endstat(Id))) .
      snd-msg(finished-opening-modules)
    fi
  ) *
  delta
endlet

process Open-Module(Path : str, Module : str, Type : term, Imports : list?) 
is
let
  Id : int,
  Error : term,
  RealPath : str,
  RealModule : str
in
  Id := process-id.
  snd-note(ui-status(statf(Id,"Opening %s",[Module]))).
  Imports := [].
  (
    Open-Syntax(Path, Module, Type, Imports?)
  ).
  snd-note(ui-status(endstat(Id)))
endlet

process Error(Message : str, MessageArgs : list) is
  snd-note(ui-status(errorf(Message, MessageArgs)))
  
process HandleOpenModuleErrors(Module: str, Error: term) is
let
  FunSym: str
in
  FunSym := fun(Error) .
  printf("HandleOpenModuleErrors: %t\n", Error) .
  if not-equal(Error, no-errors) then
    if not-equal(FunSym, "summary") then
      if equal(Error, name-inconsistent) then
        Error("Name of module %s inconsistent", [Module])
      else
        Error("Opening module %s failed: %s", [Module, Error])
      fi
    else
      snd-note(show-feedback-summary(Error))
    fi
  else
    tau
  fi
endlet

/*{{{ process BuildPath(Directory: str, Filename: str, Extension: str, Path: str?) */

process BuildPath(Directory: str, Filename: str, Extension: str, Path: str?) is
  snd-msg(io-get-filename(Directory, Filename, Extension))
  . rec-msg(io-filename(Path?))

/*}}}  */
/*{{{  process VerifyModuleId(Tree: term, ModuleId: str, Valid: bool?) */

process VerifyModuleId(Tree: term, ModuleId: str, Valid: bool?) is
let
  TreeId: term
in
  snd-msg(sm-get-module-id(Tree))
  . rec-msg(sm-module-id(TreeId?))
  . Valid := equal(ModuleId, TreeId)
endlet

/*}}}  */
/*{{{ process GetImportedModuleNames(Tree: term, Imports: list?) */

process GetImportedModuleNames(Tree: term, Imports: list?) is
  snd-msg(sm-get-imported-module-names(Tree))
  . rec-msg(sm-imported-module-names(Imports?))

/*}}}  */

process Open-Syntax(Directory: str, ModuleId: str, Type: term, Imports: list?) is
let
  AnnotatedTree: term,
  Error: term,
  Extension: str,
  Message: str,
  ParseResult: term,
  ParseTable: term,
  Path: str,
  Sort: term,
  Summary: term,
  Text: str,
  Valid: bool
in
  snd-msg(sm-is-valid-modulename(ModuleId))
  .
  ( 
    rec-msg(sm-modulename-is-valid)
    . RegisterModule(ModuleId, Directory)
    . snd-msg(file-extension-hook(Type))
    . rec-msg(file-extension-hook-result(Extension?))
    . BuildPath(Directory, ModuleId, Extension, Path?)
    . snd-msg(io-read-file(Path))
    .
    (
      rec-msg(io-file-contents(Text?))
      . SetModuleSyntaxText(ModuleId, Text)
      . snd-msg(get-parse-table(Type))
      .
      (
	rec-msg(parse-table(Type, ParseTable?))
	. snd-msg(syntax-top-sort-hook(Type))
	. rec-msg(syntax-top-sort-hook-result(sort(Sort?)))
	. snd-msg(sglr-parse(Text, ParseTable, Sort))
	.
	(
	  (
	    rec-msg(sglr-parse-tree(ParseResult?))
	  +
	    rec-msg(sglr-parse-ambiguous(ParseResult?, Error?))
	    . ParseErrorToSummary(Error, Path, Summary?)
	    . ShowSummaryInGUI(Summary)
	  )
	  . VerifyModuleId(ParseResult, ModuleId, Valid?)
	  .
	  if equal(Valid, true)
	  then
	    printf("valid\n") .
	    AnnotateTree(ParseResult, Path, AnnotatedTree?)
	    . SetModuleSyntaxTree(ModuleId, AnnotatedTree)
	    . GetImportedModuleNames(ParseResult, Imports?)
	  else
	    printf("invalid\n") .
	    Imports := []
	  fi
	  . printf("Setting imports: %t -> %t\n", ModuleId, Imports)
	+
	  rec-msg(sglr-parse-error(Error?))
	  . ParseErrorToSummary(Error, Path, Summary?)
	  . ShowSummaryInGUI(Summary)
	  . Imports := []
	)
	. SetModuleImports(ModuleId, Imports)
      +
	rec-msg(no-parse-table(Type, Error?))
	. printf("Parse-Syntax: no parse table: %t\n", Error)
      )
    +
      rec-msg(io-error-reading(Message?))
      . printf("io-error-reading: %s\n", Message)
    )
  +
    rec-msg(sm-modulename-is-invalid)
  )
endlet

process Open-Equations(ModuleId: str)  is
let
  Directory: str,
  ErrorMessage: str,
  Extension: str,
  FileName: str,
  Text: str,
  Tree: term
in
  snd-msg(ts-get-str-value("module-paths", ModuleId))
  . rec-msg(ts-value(Directory?))
  . snd-msg(file-extension-hook(asf))
  . rec-msg(file-extension-hook-result(Extension?))
  . snd-msg(io-get-filename(Directory, ModuleId, Extension))
  . rec-msg(io-filename(FileName?))
  . snd-msg(io-read-file(FileName))
  .
  (
    rec-msg(io-file-contents(Text?))
    . snd-msg(add-eqs-to-db(ModuleId, text(Text)))
    . rec-msg(eqs-added)
  +
    rec-msg(io-error-reading(ErrorMessage?)) 
  )
endlet
