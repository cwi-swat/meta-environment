\section{Repositories}
\label{repos}

There are several repositories in the current prototype of the
\metaenv.  
%%The new \metaenv\ provides facilities to store (abstract)
%%syntax trees in \asfix-format in a repository.  
The (abstract) syntax trees in \asfix-format are stored in a
tree-repository.
The import relations are
stored in a separate repository.  Finally, the interpreter has its own
repository to store the equations which are used to rewrite terms.
All repositories were first specified in \asdf\ but for efficiency
reasons implemented in C.
Before discussing the implementation details of the repositories,
we discuss the general format of all stored and exchanged information.

\subsection{Tree Representation}
\label{treerepr}

In the old \metaenv\ the abstract syntax trees are
represented by means of VTP (Virtual Tree Processing formalism)~\cite{Aus90}
offered by \centaur~\cite{BCDIKLP89}. 
There are two problems connected to VTP: it is
hard to learn programming in VTP, furthermore VTP does not offer enough
facilities to prevent illegal access to constructed trees. This latter
drawback causes a number of the maintenance problems in the \metaenv.

These ``VTP-problems'' led to the development of an alternative
formalism to represent syntax trees: \asfix.  This \asfix\ formalism
is an instantiation of a generic {\em annotated term} format:
\aterms~\cite{BKOV97}.  

\aterms\ will be used to represent structured information to be
exchanged between a heterogeneous collection of tools.  The \aterms\
format should be independent of any specific tool, but it should be
capable of representing {\em all} data that is exchanged between
tools.  Consider the following example \aterms:
\begin{tabbing}
annotation\ \ \ \ \= f(123)\{\=xxxx\kill
constant\>abc\\
numeral\>123\\
literal\>"abc" "123"\\
list\>[] [1, "abc", 3] [1, 2, [3,4], 5]\\
functions\>f("abc")\\
annotation\>f(123)\{color("red"),path([0,2,1])\}
\end{tabbing}
The data format used in the \TB\ is also based on \aterms.
So all functions for processing, constructing, and accessing \aterms\
can be used on the \TB\ level as well.

These functions are formally specified in \asdf~\cite{BKOV97} and
this formal specification is used to make a library of C functions
to manipulate terms.
The redundancy in the \aterms\ format is solved by a powerful sharing
mechanism provided by the C implementation of the \aterms\ library.

\subsubsection{\asfix}

These \aterms\ are sufficient to encode parse trees (including
optional annotations) for programs or specifications in any language.
\asfix\ is an instance of \aterms\ used for representing the {\em
parse trees} of \asdf\ specifications.  Parse trees mean that all
keywords, whitespace, comments, etc.\ are preserved in the tree
representation.  A self descriptive representation is used, i.e., each
application of a syntax rule contains a copy of that rule (in the
implementation these are all shared).

%%\subsection{Implementation}
%%
%%One of the strong points of \aterms\ are the powerful access functions
%%to retrieve information from the terms and the construction functions
%%to build terms. 
%%
%%These functions are formally specified in \asdf~\cite{BKOV97} and
%%this formal specification is used to make a library of C functions
%%to manipulate terms.

\subsection{Implementation}
The ``tree-repository'' contains the \asfix\ representation of all
modules of a specification under construction and of all terms being
edited or rewritten.  The tree-repository provides facilities to add 
or remove a module or term, and to clear its
entire repository.  It is possible to check whether a module or term
is already in the repository.  Furthermore, given the name of a module
it is possible to retrieve a specific section of a module, its import
section, its equations, etc.  The tree-repository is implemented as a
table with the module name and term name as key and the \asfix\ 
representation as value.

The ``import-repository'' or ``import-manager'' provides all
information concerning the import relations of an \asdf\ 
specification.  It contains of all modules of a specification in the
tree-repository the import sections.  The import-repository provides
facilities to add the import section of a new module, to remove the
import section of a given module, and to clear its entire repository.
Of course, it is possible to retrieve the imports for a given module
name.  It is also possible to retrieve 
which modules are not yet in ``store'' given a list of module names. 
Finally, a number of
operations are provided to calculate the transitive closure of the
import relation for a given module.  The import-repository stores this
calculated closure in a separate database.
 
The ``equations-repository'' of the interpreter will be discussed in
Section \ref{interpreter}. In fact, there are {\em no} facilities to retrieve
any information from this repository by other tools than the
interpreter itself.

\subsection{Discussion}

The current implementation of the import-repository and
the equations-repository are based on a lazy mechanism.
Only when the import relation or equations of some module are needed
this information is derived and stored to be used later on.
If the contents of the tree repository are changed this leads to clearing
both the import-repository and equations-repository.
There is no smart incremental updating algorithm implemented yet.

The information stored in the tree-repository could be extended with
all kind of extra information such as size of the file,
creation date, etc.
Furthermore, the tree-repository should provided a sophisticated
querying mechanism as described in~\cite{BKV96b}.
Such a mechanism can be used to locate definitions of sorts, lexical
and context-free syntax rules.
