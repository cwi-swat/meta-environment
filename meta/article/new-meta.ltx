\documentclass{article}
\usepackage{latexsym}
\usepackage{ASF+SDF,ASF+SDF-options}
\usepackage{epsfig}
\usepackage{cmbcsc}

\title{Design and Implemention a New {\sc Asf+Sdf} Meta-Environment}

\author{Mark van den Brand$^{^1}$, Tobias Kuipers$^{^2}$, \\
        Leon Moonen$^{^1}$, Pieter Olivier$^{^1}$\\
        {\small\sl $^1$University of Amsterdam,
        Programming Research Group\vspace{-.2cm}}\\
        {\small\sl Kruislaan 403, NL-1098 SJ Amsterdam, The Netherlands}
        \vspace{.1cm}\\
        {\small\sl $^2$CWI,
        Department of Software Engineering\vspace{-.2cm}}\\
        {\small\sl P.O. Box 94079, NL-1090 GB Amsterdam, The Netherlands}
        \vspace{.1cm}\\
        {\small \sl\tt markvdb@wins.uva.nl,Tobias.Kuipers@cwi.nl,\vspace{-.2cm}}\\
        {\small \sl\tt leon@wins.uva.nl,olivierp@wins.uva.nl}
}

\def\aterms{\mbox{ATerms}}
\def\asfix{\mbox{\sc AsFix}}
\def\sdf{{\sc Sdf}}
\def\asf{{\sc Asf}}
\def\asdf{{\sc Asf+Sdf}}
\def\metaenv{{\sc Asf+Sdf}\ Meta-En\-vir\-on\-ment}
\def\TB{{\sc ToolBus}}
\def\centaur{{\sc centaur}}
\def\seal{{\sc seal}}
\def\epic{{\sc Epic}}
\def\lelisp{{\sc LeLisp}}
\def\T{{\bf T}}
\input{psfig}

\begin{document}

\maketitle

\begin{abstract}
To be written.
\end{abstract}

\section{Introduction}

In the beginning of the eigthies the design and implementation
of the current version of the \metaenv\ was started.
On top of \centaur~\cite{BCDIKLP89}
a programming environment (generator) for writing language definitions
in \asdf\ was developed \cite{Kli93.meta}.
An overview of these activities can be found in \cite{HK95}.

The implementation could be considered a test environment for all kinds
of ideas concerning the lazy and incremental generation of
scanners, parsers, and term rewriting machines.
The development of advanced hybrid editing techniques \cite{Koo94.thesis},
origin tracking techniques \cite{Deu94.thesis}, incremental
rewriting \cite{Meu94.thesis}, automatic
generation of unparsers \cite{BV96},
debugging facilities of term rewriting, and
the generation of \LaTeX\ code were performed within or with
this implementation as well.

The current implementation of the \metaenv\ has a number of drawbacks
and shortcomings, the most important ones are listed in Table~\ref{short}.
This table shows that the system has all the signs of a \emph{legacy system},
mainly because most of the coding has been done by
Ph.D. researchers, and consequently the project has had a 
large turnover of staff.

These complaints initiated a redesign and reimplementation of the \metaenv.
Initially we believed in an incremental reimplementation of the
\metaenv\ was feasible, and therefore a number of people
started working on the design and implementation of a new user-interface
and the replacement of the text editing facilities of GSE \cite{Koo94.thesis}
by Emacs and Epoch in 1992 \cite{KB93}.
However, it turned out that the resulting implementation was not deadlock
free.
This initiated the development of the \TB, a software interconnection
architecture \cite{BK96a,BK96b} which takes care of the communication of
software components.

\begin{table}
\begin{center}
\begin{tabular}{|l|} \hline
Complaints or shortcomings \\ \hline\hline
The user-interface is old-fashioned and badly organized: \\
reduced terms not in term-editor and long flat lists of  \\
modules for deleting and editing of modules and terms.   \\ \hline
An often heard complaint was: ``The editor is too        \\
restriced, why is it not emacs- or vi-like?''            \\ \hline
The creation of stand-alone environments is not possible. \\ \hline
It is impossible to port to different architectures.      \\
Limited availability of \lelisp\ on various platforms.      \\
Our version of \lelisp\ is becoming obsolete.               \\ \hline 
The tree formalism VTP is not easy to use, connection     \\
\lelisp/VTP is complicated.                                \\ \hline
The current monolithic system is hard to maintain. New    \\
research ideas are hard to implement.                     \\ \hline 
Bugs are not fixed anymore, because the knowledge about
the intrinsics of the system needed to fix these bugs is
no longer present.					\\ \hline \hline
\end{tabular}
\end{center}
\caption{\label{short} Drawbacks of the current version of the \metaenv.}
\end{table}

Based on the Epoch-GSE-UI coupling it was decided to
design and implement the new \metaenv\ from scratch.
The problems concerning \lelisp\ makes a ``from scratch'' approach even
more important.
In this paper we discuss the first prototype of the new \metaenv\ based
on the \TB. 
This prototype has a very restricted functionality but offers an extendable
infrastructure to experiment with various designs.

\subsection{Tree Representation}

In the current version of the \metaenv\ the abstract syntax trees are 
represented by means of VTP (Virtual Tree Processing formalism)
offer by \centaur.
There are two problems connected to VTP: it is hard to learn programming
in VTP and VTP does not offer enough facilities to prevent illegal
access to constructed trees. This latter drawback causes a number of
the maintenance problems in the \metaenv.

These ``VTP-problems'' led to the development of an alternative
formalism to represent syntax trees: \asfix.
This \asfix\ formalism is an instantiation of a generic {\em annotated
term} format: \aterms~\cite{BKOV97}.
The \sdf\ definition of \aterms\ is presented in Figure~\ref{at}.

\begin{figure}
\centerline{\fbox{
\begin{minipage}[htb]{\textwidth}
{\small \input{ATerms.mtx} }
\end{minipage}
}
}
\caption{\label{at} Context-free syntax definition of \aterms.
}
\end{figure}

\aterms\ will be used to represent structured information to be exchanged
between a heterogenuous collection of tools.
They should be independent of any specific tool, but
they should be able to accomodate the representation of {\em all}
data that is to be exchanged between tools.
Consider the following example \aterms:
\begin{tabbing}
annotation\ \ \ \ \= f(123)\{\=xxxx\kill
constant\>abc\\
numeral\>123\\
literal\>"abc" "123"\\
list\>[] [1, "abc", 3] [1, 2, [3,4], 5]\\
functions\>f("abc")\\
annotation\>f(123)\{color("red"),path([0,2,1])\}
\end{tabbing}

These \aterms\ are sufficient to encode parse trees (including
optional annotations) for programs or specifications in any
language.
\asfix\ is an instance of \aterms\ used for representing
the {\em parse trees} of \asdf\ specifications.
Parse trees means: all keywords, whitespace, comments, etc.\ are
preserved in the tree representation.
A self descriptive representation is used, i.e., each application
of a syntax rule contains a copy of that rule (in the implementation
these are all shared).

Consider the following context-free syntax rules:

\begin{small}
\begin{verbatim}
context-free syntax
  true          -> Bool
  false         -> Bool
  Bool and Bool -> Bool {left}
\end{verbatim}
\end{small}
the parse tree below represents {\tt true and false}:

\begin{small}
\begin{verbatim}
appl(prod(id("Booleans"),w(""),
          [sort("Bool"),w(""),l("and"),w(""),sort("Bool")],w(""),
          l("->"),w(""),sort("Bool"),w(""),
          attrs(l("{"),w(""),[l("left")],w(""),l("}"))),
     [appl(prod(id("Booleans"),w(""),
                [l("true")],w(""),l("->"),w(""),sort("Bool"),w(""),
                no-attrs),
           [l("true")]),
      w(" "),l("and"),w(" "),
      appl(prod(id("Booleans"),w(""),
                [l("false")],w(""),l("->"),w(""),sort("Bool"),w(""),
                no-attrs),
           [l("false")])])
\end{verbatim}
\end{small}
where:
\begin{itemize}
\item {\tt appl}: constructor for function application with arguments.
\item {\tt prod}: constructor for productions.
\item {\tt w}: constructor for whitespace.
\item {\tt l}: constructor for literals.
\item {\tt sort}, {\tt id}: constructor for constants.
\item {\tt no-attrs}: constructor for empty attribute list.
\end{itemize}

\subsection{General Architecture}

The architecture of the new \metaenv\ is depicted in Figure~\ref{picarch}.
In fact this figure does not depict the current state of the prototype
or the future architecture of the system.
There are a number of components enlisted which are not yet integrated
in the prototype, see Table~\ref{components} for a more detailed list
of integrated components.
It is not the future architecture because important components like
unparsers and debuggers are missing.

\input{newarch}
\begin{figure}[tb]
\centerline{\box\graph}
\caption{\label{picarch} General architecture of new \metaenv.}
\end{figure}

Table~\ref{components} gives an overview of all currently available
components in the prototype. For each component it is listed whether
this components is specified and in which language it is implemented.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|} \hline
Activity            & Specification & Implementation  \\
                    & Language      & Language        \\ \hline \hline
\aterms             & \asdf         & C, JAVA         \\ 
\asfix              & \asdf         & C, JAVA         \\ 
\TB                 & \asdf         & C               \\
Structure editor    & \asdf         & JAVA            \\
Text editor         &               & Tcl/Tk          \\
Interpreter         & \asdf         & C               \\
Tree repository     & \asdf         & C               \\
Import manager      & \asdf         & C               \\
user-interface/Dot  &               & Tcl/Tk          \\ \hline
\end{tabular}
\end{center}
\caption{\label{components} Components of the new \metaenv\ which are finished.}
\end{table}

Figure \ref{nm} contains a screendump of the current prototype.
The various components will be discussed in the next sections.

\begin{figure}[htb]
\centerline{\psfig{figure=newmeta.ps,width=\textwidth}}
\caption{\label{nm} Browsing the import graph in the new \metaenv.}
\end{figure}

\input{toolbus.ltx}

\section{User-interface}

\section{Repositories}

There are several repositories in the current prototype of the \metaenv.
The new \metaenv\ provides facilities to store (abstract) syntax trees
in \asfix-format a repository. 
The import relation is stored in a separate repository.
Finally, the interpreter has its own repository to store the
equations which are used to rewrite terms.
All repository were first specified in \asdf\ but for efficiency 
reasons implemented in C.

The ``tree-repository'' contains the \asfix\ representation of
all modules of a specification under construction and of all terms 
being edited or rewritten.
The tree-repository provides facilities to add a new module or
term, to remove a module or term, and to clear its entire repository.
It is possible to check whether a module or term is already
in the repository.
Furthermore, given the name of a module it is possible to retrieve
a specific section of a module, its imports section, its equations, etc.
The tree-repository is implemented as a table with the module name
and term name as key and the \asfix\ representation as value.

The ``imports-repository'' or ``import-manager'' provides all information
concerning the import relations of an \asdf\ specification.
It contains of all modules of a specification in the tree-repository
the import sections.
The imports-repository provides facilities to add the import section
of a new module, to remove the import section of a given module,
and to clear its entire repository.
Of course it is possible to retrieve the imports for a given module name.
It is also possible to calculate given a list of module names which
modules are not yet in ``store''.
Finally, a number of operations are provided to retrieve the transitive
closure of the import relation for a given module.
The imports-repository stores this calculated closure in a separate database.
 
The ``equations-repository'' of the interpreter will be discussed in
Section \ref{interpreter}. In fact, there are facilities to
retrieve any information from this repository for other tools than
the interpreter itself.

\section{Editors}

\section{Interpreter}
\label{interpreter}

The interpreter or evaluator takes care of rewriting terms
given a set of equations.
The interpreter rewrite terms in \asfix\ format using equations in \asfix\
format. The interpreter was first specified in \asdf, and later this
specification was used to make a C implementation.

We will first discuss how the interpreter is activated and which steps
are performed before a term is actually rewritten. Then we will
discuss the implementation of the interpreter in more detail.
Finally, we will discuss some related aspects, such as performance,
improvements, etc.

\subsection{Activating the Interpreter}

The interpreter is activated in the same way as in the old \metaenv, each
term editor is extended with a {\tt Reduce}-button.
When pushing this button it is first checked
whether the interpreter has the appropriate set of rewrite rules
available. If not, the equations are retrieved from the tree repository.
This is done by retrieving the transitive closure of the imports graph
from the import manager and sending this set of modules to
the tree repository which then returns the set of equations.
Finally, the \asfix\ representation of the term is
sent to the interpreter.

When the interpreter recieves a set of equations it performs
some simple transformations to it, for instance,
removal of unnecessary layout and lexicals are transformed into
lists of characters.
The interpreter stores the equations in a hash table to have
fast access to them during rewriting.

The term to be rewritten is also slightly modified.
Unnecessary layout is removed as well as the transformation of the lexicals.
After rewriting the result term is again modified,
layout is inserted and the lists of characters are translated into
lexicals.
This term is sent to the \TB\ to be display in an editor.

The interpreter does not remove the equations they are stored.
These equations are removed only when one of the modules in
the specification is modified.

\subsection{Implementation of the Interpreter}

Before discussing the implementation of the interpreter we recall
some of the characteristics of the \asdf-formalism, and more
specific of \asf\ itself.
The \asf-formalism has the following characteristics:
\begin{itemize}
\item Many-sorted.
\item Non left-linear.
\item List matching.
\item Positive and negative conditions.
\item Default equations.
\item Innermost rewriting.
\end{itemize}
So, the interpreter should support the innermost rewriting of
many-sorted, non left-linear, conditional rewrite rules
with both default rules and list matching.

The main functionality of the interpreter consists of a rewriting
machinery and a local repository to store equations.
This repository is organized as a table, the keys in this table
are module names and the values are sets of equations corresponding
to the transitive closure of the import graph of the corresponding
module.
In the C implementation of the interpreter the set of equations are
stored in a hash-table and the hash key
is calculated using the outermost function symbol of the left hand
side of an equation and the outermost function symbol (if any) of
the first argument of the left hand side of the equation.
This improves the efficiency of the rewriting machine enormously,
but it influence the semantics as well. In fact this implements a form of
syntactic specificity. This implementation trick was also available
in the interpreter of the old \metaenv.
PIETER: How about the default rules?

The rewrite machine itself consists a collection of recursive functions
which have as arguments a set of equations, the term to be rewritten, and
an environment in which the instantiated variables are stored.

\begin{footnotesize}
\begin{verbatim}
context-free syntax
  rewrite(ATermList,ATerm,Env) -> ATerm
\end{verbatim}
\end{footnotesize}
These rewrite functions are based on backtracking, to support list matching
in \asf.
The instantiation of list variables is done by assigning
an ``arbitrary'' sublist to a list variable. 
If this does not lead to a successfull matching of all variables in
the equation or one of the
conditions can not be satisfied, another sublist should be tried. 
This process is repeated until either a successful match is found,
or all sublists are tried.

\asdf\ allows the use of conditional equations.
The conditions maybe positive as well as negative.
This current implementation does not allow the introduction of
new variables in a negative condition. Furthermore,
it is not allowed to introduce new variables on both sides of
a positive condition. If new variables are introduced on one side
of a positive condition only the other side is rewritten which is
then matched against the ``variable introducing side'' of the
condition.

\subsection{Discussion}

There are a few open issues with respect to the interpreter.
First, the performance of the current version is reasonable.
If there is no list matching involved the interpreter performs
6000 rewrite steps per second, the interpreter in the
old \metaenv\ performs 20.000 rewrite steps per second for the
same specification and term. So, there is at least a factor 3 to be
gained.

Second, in the current version no or almost none preprocessing
of the specification is performed.
A number of preprocessing steps could improve the performance 
considerably.
One obvious preprocessing step is the calculation of which side of
a positive condition introduces new variables.
Another very effective preprocessing step is the transformation
of some forms of list matching into non list matching, e.g.,
obtaining the head and tail of a list, etc.
This can be done because we know the internal data structure for
lists in the interpreter.
The list transformations are also important when compiling \asdf\
specifications.

\section{Future Work}

There is a huge bulk of future work to be done.
First of all, the parser and parser generator \cite{Vis97.SGLRP} has to be
integrated in the new \metaenv.
Second, the unparser and unparser generator \cite{BV96} has to be
integrated as well as the To\LaTeX\ facilities \cite{Vis95.tolatex}. This should be done
on top of the {\sc Box} language.
Third, the \metaenv\ should provided facilities to compile specifications
in order to generate stand-alone environments.
Fourth, a debugging facility for debugging specification should provided
as well.
Finally, the new \metaenv\ should provided sophisticated help facilities
and demonstrations modes based on internet facilities.

The tree-repository should provided a sophisticated querying mechanism
as described in \cite{BKV96b}.

\input{future-debugging.ltx}

\bibliographystyle{alpha}
\bibliography{metabib}

\end{document}
