\documentclass{article}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{ASF+SDF,ASF+SDF-options}
\usepackage{epsfig}
\usepackage{cmbcsc,alltt}

\title{Design and Implementation of a New {\textsc Asf+Sdf} Meta-Environment}

\author{Mark van den Brand$^{^1}$, Tobias Kuipers$^{^2}$, \\
        Leon Moonen$^{^1}$, Pieter Olivier$^{^1}$\\
        {\small\sl $^1$University of Amsterdam,
        Programming Research Group\vspace{-.2cm}}\\
        {\small\sl Kruislaan 403, NL-1098 SJ Amsterdam, The Netherlands}
        \vspace{.1cm}\\
        {\small\sl $^2$CWI,
        Department of Software Engineering\vspace{-.2cm}}\\
        {\small\sl P.O. Box 94079, NL-1090 GB Amsterdam, The Netherlands}
        \vspace{.1cm}\\
        {\small \sl\tt markvdb@wins.uva.nl,Tobias.Kuipers@cwi.nl,\vspace{-.2cm}}\\
        {\small \sl\tt leon@wins.uva.nl,olivierp@wins.uva.nl}
}

\def\aterms{\mbox{ATerms}}
\def\asfix{\mbox{\textsc AsFix}}
\def\sdf{\textsc{Sdf}}
\def\asf{\textsc{Asf}}
\def\asdf{\textsc{Asf+Sdf}}
\def\metaenv{\asdf\ Meta-En\-vir\-on\-ment}

\def\TB{\textsc{ToolBus}}
\def\centaur{\textsc{centaur}}
\def\seal{\textsc{seal}}
\def\epic{\textsc{Epic}}
\def\lelisp{\textsc{LeLisp}}
\def\T{\textbf{T}}

\def\tcl{\textsf{Tcl}}
\def\tk{\textsf{Tk}}
\def\dot{\textsf{Dot}}
\def\tcltk{\textsf{Tcl/Tk}}
\def\tcldot{\textsf{TclDot}}
\def\tcldg{\textsf{TclDG}}
\def\ui{user interface}

\makeatletter
\def\up@case#1{\expandafter\uppercase{#1}}
\def\upcase#1{\expandafter\up@case#1}
\makeatother   

%\input{psfig}

\begin{document}

\maketitle

\begin{abstract}
To be written.
\end{abstract}

\section{Introduction}

In the beginning of the eighties the design and implementation of the
current version of the \metaenv\ was started.  On top of
\centaur~\cite{BCDIKLP89} a programming environment (generator) for
writing language definitions in \asdf\ was developed
\cite{Kli93.meta}.  An overview of these activities can be found in
\cite{HK95}.

The implementation could be considered a test environment for all
kinds of ideas concerning the lazy and incremental generation of
scanners, parsers, and term rewriting machines.  The development of
advanced hybrid editing techniques \cite{Koo94.thesis}, origin
tracking techniques \cite{Deu94.thesis}, incremental rewriting
\cite{Meu94.thesis}, automatic generation of unparsers \cite{BV96},
debugging facilities of term rewriting, and the generation of \LaTeX\ 
code were performed within or with this implementation as well.

The current implementation of the \metaenv\ has a number of drawbacks
and shortcomings, the most important ones are listed in
Table~\ref{short}.  This table shows that the system has all the signs
of a \emph{legacy system}, mainly because most of the coding has been
done by Ph.D. researchers, and consequently the project has had a
large turnover of staff.

These complaints initiated a redesign and re-implementation of the
\metaenv.  Initially we believed that an incremental re-implementation
of the \metaenv\ was feasible, and therefore a number of people
started working on the design and implementation of a new \ui{} and
the replacement of the text editing facilities of GSE
\cite{Koo94.thesis} by Emacs and Epoch in 1992 \cite{KB93}.  However,
it turned out that the resulting implementation was not deadlock free.
This initiated the development of the \TB, a software interconnection
architecture \cite{BK96a,TB-AMAST96} which takes care of the communication
of software components.

\begin{table}
\begin{center}
\begin{tabular}{|l|} \hline
Complaints or shortcomings \\ \hline\hline
The \ui{} is old-fashioned and badly organised: \\
reduced terms not in term-editor and long flat lists of  \\
modules for deleting and editing of modules and terms.   \\ \hline
An often heard complaint was: ``The editor is too        \\
restricted, why is it not emacs- or vi-like?''            \\ \hline
The creation of stand-alone environments is not possible. \\ \hline
It is impossible to port to different architectures.      \\
Limited availability of \lelisp\ on various platforms.      \\
Our version of \lelisp\ is becoming obsolete.               \\ \hline 
The tree formalism VTP is not easy to use, connection     \\
\lelisp/VTP is complicated.                                \\ \hline
The current monolithic system is hard to maintain. New    \\
research ideas are hard to implement.                     \\ \hline 
Bugs are not fixed anymore, because the knowledge about \\
the intrinsics of the system needed to fix these bugs \\
is no longer present.                                   \\ \hline \hline
\end{tabular}
\end{center}
\caption{\label{short} Drawbacks of the current version of the \metaenv.}
\end{table}

Based on the experiences gained with the Epoch-GSE-UI coupling it was
decided to design and implement the new \metaenv\ from scratch.  The
problems concerning \lelisp\ makes a ``from scratch'' approach even
more pressing.  In this paper we discuss the first prototype of the
new \metaenv\ based on the \TB.  This prototype has a very restricted
functionality but offers an extendible infrastructure to experiment
with various designs.

\input{toolbus.ltx}

\subsection{Tree Representation}

In the current version of the \metaenv\ the abstract syntax trees are
represented by means of VTP (Virtual Tree Processing formalism)
offered by \centaur.  There are two problems connected to VTP: it is
hard to learn programming in VTP and VTP does not offer enough
facilities to prevent illegal access to constructed trees. This latter
drawback causes a number of the maintenance problems in the \metaenv.

These ``VTP-problems'' led to the development of an alternative
formalism to represent syntax trees: \asfix.  This \asfix\ formalism
is an instantiation of a generic {\em annotated term} format:
\aterms~\cite{BKOV97}.  The \sdf\ definition of \aterms\ is presented
in Figure~\ref{at}.

\begin{figure}
\centerline{\fbox{
\begin{minipage}[htb]{\textwidth}
{\small \input{ATerms.mtx} }
\end{minipage}
}
}
\caption{\label{at} Context-free syntax definition of \aterms.
}
\end{figure}

\aterms\ will be used to represent structured information to be
exchanged between a heterogeneous collection of tools.  The AATerm
format should be independent of any specific tool, but it should be
capable of representing {\em all} data that is exchanged between
tools.  Consider the following example \aterms:
\begin{tabbing}
annotation\ \ \ \ \= f(123)\{\=xxxx\kill
constant\>abc\\
numeral\>123\\
literal\>"abc" "123"\\
list\>[] [1, "abc", 3] [1, 2, [3,4], 5]\\
functions\>f("abc")\\
annotation\>f(123)\{color("red"),path([0,2,1])\}
\end{tabbing}

These \aterms\ are sufficient to encode parse trees (including
optional annotations) for programs or specifications in any language.
\asfix\ is an instance of \aterms\ used for representing the {\em
  parse trees} of \asdf\ specifications.  Parse trees mean that all
keywords, whitespace, comments, etc.\ are preserved in the tree
representation.  A self descriptive representation is used, i.e., each
application of a syntax rule contains a copy of that rule (in the
implementation these are all shared).

Consider the following context-free syntax rules:

\begin{small}
\begin{verbatim}
context-free syntax
  true          -> Bool
  false         -> Bool
  Bool and Bool -> Bool {left}
\end{verbatim}
\end{small}
the parse tree below represents {\tt true and false}:

\begin{small}
\begin{verbatim}
appl(prod(id("Booleans"),w(""),
          [sort("Bool"),w(""),l("and"),w(""),sort("Bool")],w(""),
          l("->"),w(""),sort("Bool"),w(""),
          attrs(l("{"),w(""),[l("left")],w(""),l("}"))),
     [appl(prod(id("Booleans"),w(""),
                [l("true")],w(""),l("->"),w(""),sort("Bool"),w(""),
                no-attrs),
           [l("true")]),
      w(" "),l("and"),w(" "),
      appl(prod(id("Booleans"),w(""),
                [l("false")],w(""),l("->"),w(""),sort("Bool"),w(""),
                no-attrs),
           [l("false")])])
\end{verbatim}
\end{small}
where:
\begin{itemize}
\item {\tt appl}: constructor for function application with arguments.
\item {\tt prod}: constructor for productions.
\item {\tt w}: constructor for whitespace.
\item {\tt l}: constructor for literals.
\item {\tt sort}, {\tt id}: constructor for constants.
\item {\tt no-attrs}: constructor for empty attribute list.
\end{itemize}

\subsection{General Architecture}

The architecture of the new \metaenv\ is depicted in
Figure~\ref{picarch}.  In fact this figure does not depict the current
state of the prototype or the future architecture of the system.
There are a number of components enlisted which are not yet integrated
in the prototype, see Table~\ref{components} for a more detailed list
of integrated components.  It is not the future architecture because
important components like unparsers and debuggers are missing.

\input{newarch}
\begin{figure}[tb]
\centerline{\box\graph}
\caption{\label{picarch} General architecture of new \metaenv.}
\end{figure}

Table~\ref{components} gives an overview of all currently available
components in the prototype. For each component it is listed whether
this components is specified and in which language it is implemented.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|} \hline
Activity            & Specification & Implementation  \\
                    & Language      & Language        \\ \hline \hline
\aterms             & \asdf         & C, JAVA         \\ 
\asfix              & \asdf         & C, JAVA         \\ 
\TB                 & \asdf         & C               \\
Structure editor    & \asdf         & JAVA            \\
Text editor         &               & \tcltk{}        \\
Interpreter         & \asdf         & C               \\
Tree repository     & \asdf         & C               \\
Import manager      & \asdf         & C               \\
\upcase{\ui}        &               & \tcltk{}, \tcldot{}     \\ \hline
\end{tabular}
\end{center}
\caption{\label{components} Components of the new \metaenv\ which are finished.}
\end{table}

The various components will be discussed in the next sections.

\section{\upcase{\ui}}

The \ui{} of the new \metaenv\ is built around the visual
representation of the import graph of the \asdf\ specification which
is loaded. The major advantage of having a visual representation of
the import graph as \ui{} is the increased insight in the structure of
the specification.  Furthermore, effective visualisation of this graph
can reveal interesting characteristics of the specification (e.g.
repeating patterns and unintended transitive import relations) while
avoiding distractions and irrelevancy.

\begin{figure}[htb]
\centerline{\psfig{figure=newmeta.ps,width=\textwidth}}
\caption{\label{nm} Browsing the import graph in the new \metaenv.}
\end{figure}

The user can select one or more modules in this graph and perform
actions on them. Currently the following actions are supported:
\begin{itemize}
\item open the module editor for this module,
\item open a term editor over this module,
\item delete the module from the repositories,
\item request additional information on the module, and
\item revert the module in the repositories to the last version saved
  to disk.
\end{itemize}
These actions can be selected in of a menu which pops up when the user
presses the right mouse button over a module in the graph or using the
module list and buttons on the right side of the screen. In addition
to the actions described above, the user can:
\begin{itemize}
\item add a module to the specification loaded in the repositories,
\item clear all repositories,
\item revert all modules loaded in the repositories to the last
  versions saved to disk, and
\item save the import graph in various graphics formats.
\end{itemize}
Figure \ref{nm} contains a screendump of the user interface of the
current prototype. From left to right one can clearly distinguish the
visual representation of the import graph, the list of modules loaded
and the buttons to perform actions on modules.
 
\subsection{\tcldot}

The user interface is implemented in \tcltk~\cite{Tcl/Tk}, extended
with \tcldot~\cite{Ellson:1996:TR}. \tcldot{} is part of the
\emph{graphvis} package~\cite{North:1994:AGV,Ellson:1996:GPR}: a set
of graph drawing tools for Unix or MS-Windows by AT\&T/Lucent
Technologies.  It is a dynamically loaded extension for
\texttt{tcl7.6} that incorporates the directed graph facilities of
\dot~\cite{Gansner:1993:TDD,Koutsofios:1993:DGT} into \tcl{} and
provides a set of commands to control those facilities.

\tcldot{} initially adds two commands to \tcl{}, namely
\texttt{dotnew} to create an empty \dot{} graph and \texttt{dotread}
to read a \dot{} graph description from file.  These commands return a
handle for the graph that has just been created and that handle can
then be used as a command for further actions on the graph.

All other "commands" are of the form: \mbox{\emph{handle} $<$method$>$
  \emph{parameters}}. \linebreak Many of them return further handles
of graphs, nodes of edges, which are themselves registered as
commands.  To give an impression of the functionality provided by
\tcldot{}, we list the methods that are available:
\begin{description}
\item[Graph methods:] addedge, addnode, addsubgraph, countedges,
  countnodes, layout, listattributes, listedgeattributes,
  listnodeattributes, listnodes, listsubgraphs, render, rendergd,
  queryattributes, queryedgeattributes, querynodeattributes,
  setattributes, setedgeattributes, setnodeattributes, showname,
  write.
\item[Node methods:] addedge, listattributes, listedges, listinedges,
  listoutedges, queryattributes, setattributes, showname.
\item[Edge methods:] delete, listattributes, listnodes,
  queryattributes, setattributes, showname.
\end{description}
  
\subsection{Future Work}

Future work on the user interface includes a search mechanism on
modules (in cooperation with the tree repository and the editor).
Using this mechanism it should be possible for example to
highlight/select all modules that use a given function or sort.

Furthermore, the current version of \tcldot{} only supports static
graphs.  This means that the layout of a graph is computed from
scratch every time an update is performed (i.e.\ adding or removing a
node or edge).  The result of this computation can be completely
different from the original graph. This is not desirable for \ui{}s
since it can be confusing and the user needs to familiarise himself
with a new structure. A new version of \tcldot{}, called \tcldg{},
supports so called \emph{dynamic
  graphs}~\cite{North:1996:ILD,Ellson:1997:TTE}.  The layout of these
graphs changes incrementally when updates are performed resulting in
more gradual changes in the structure of the graph. As soon as the
\tcldg{} package is released (scheduled for summer 1997), it should be
incorporated in the \ui.

Finally, it might be convenient if the user can edit the layout of the
import graph to improve its logical structure. These edit operations
should cooperate in some way with the layout mechanism so that changes
of the user aren't undone by layouting the graph. An example of a more
rigorous editing operation is the ability to define subgraphs in the
import graph which can be collapsed into a single node. Such a feature
could be useful to improve the readability of big import graphs.

\section{Repositories}

There are several repositories in the current prototype of the
\metaenv.  The new \metaenv\ provides facilities to store (abstract)
syntax trees in \asfix-format a repository.  The import relation is
stored in a separate repository.  Finally, the interpreter has its own
repository to store the equations which are used to rewrite terms.
All repository were first specified in \asdf\ but for efficiency
reasons implemented in C.

The ``tree-repository'' contains the \asfix\ representation of all
modules of a specification under construction and of all terms being
edited or rewritten.  The tree-repository provides facilities to add a
new module or term, to remove a module or term, and to clear its
entire repository.  It is possible to check whether a module or term
is already in the repository.  Furthermore, given the name of a module
it is possible to retrieve a specific section of a module, its import
section, its equations, etc.  The tree-repository is implemented as a
table with the module name and term name as key and the \asfix\ 
representation as value.

The ``import-repository'' or ``import-manager'' provides all
information concerning the import relations of an \asdf\ 
specification.  It contains of all modules of a specification in the
tree-repository the import sections.  The import-repository provides
facilities to add the import section of a new module, to remove the
import section of a given module, and to clear its entire repository.
Of course it is possible to retrieve the imports for a given module
name.  It is also possible to calculate given a list of module names
which modules are not yet in ``store''.  Finally, a number of
operations are provided to retrieve the transitive closure of the
import relation for a given module.  The import-repository stores this
calculated closure in a separate database.
 
The ``equations-repository'' of the interpreter will be discussed in
Section \ref{interpreter}. In fact, there are facilities to retrieve
any information from this repository for other tools than the
interpreter itself.

\section{Editors}

\input{editors.ltx}

\section{Interpreter}
\label{interpreter}

The interpreter or evaluator takes care of rewriting terms given a set
of equations.  The interpreter rewrite terms in \asfix\ format using
equations in \asfix\ format. The interpreter was first specified in
\asdf, and later this specification was used to make a C
implementation.

We will first discuss how the interpreter is activated and which steps
are performed before a term is actually rewritten. Then we will
discuss the implementation of the interpreter in more detail.
Finally, we will discuss some related aspects, such as performance,
improvements, etc.

\subsection{Activating the Interpreter}

The interpreter is activated in the same way as in the old \metaenv,
each term editor is extended with a {\tt Reduce}-button.  When pushing
this button it is first checked whether the interpreter has the
appropriate set of rewrite rules available. If not, the equations are
retrieved from the tree repository.  This is done by retrieving the
transitive closure of the import graph from the import manager and
sending this set of modules to the tree repository which then returns
the set of equations.  Finally, the \asfix\ representation of the term
is sent to the interpreter.

When the interpreter receives a set of equations it performs some
simple transformations to it, for instance, removal of unnecessary
layout and lexicals are transformed into lists of characters.  The
interpreter stores the ons in a hash table to have fast access to them
during rewriting.

The term to be rewritten is also slightly modified.  Unnecessary
layout is removed as well as the transformation of the lexicals.
After rewriting the result term is again modified, layout is inserted
and the lists of characters are translated into lexicals.  This term
is sent to the \TB\ to be display in an editor.

The interpreter does not remove the equations after rewriting.  These
equations are removed only when one of the modules in the
specification is modified.

\subsection{Implementation of the Interpreter}

Before discussing the implementation of the interpreter we recall some
of the characteristics of the \asdf-formalism, and more specific of
\asf\ itself.  The \asf-formalism has the following characteristics:
\begin{itemize}
\item Many-sorted.
\item Non left-linear.
\item List matching.
\item Positive and negative conditions.
\item Default equations.
\item Innermost rewriting.
\end{itemize}
So, the interpreter should support the innermost rewriting of
many-sorted, non left-linear, conditional rewrite rules with both
default rules and list matching.

The main functionality of the interpreter consists of a rewriting
machinery and a local repository to store equations.  This repository
is organised as a table, the keys in this table are module names and
the values are sets of equations corresponding to the transitive
closure of the import graph of the corresponding module.  In the C
implementation of the interpreter the set of equations are stored in a
hash-table and the hash key is calculated using the outermost function
symbol of the left hand side of an equation and the outermost function
symbol (if any) of the first argument of the left hand side of the
equation.  This improves the efficiency of the rewriting machine
enormously, but it influences the semantics as well. In fact this
implements a form of syntactic specificity, because when the
interpreter is looking for an equation that matches with a aterm, it
first looks for an equation that has the same outermost function
symbol (ofs), {\em and} has the same ofs at the first argument
position.  If no match can be found, the search is continued for an
equation that has the same ofs as the term, but with a variable at the
first argument position. This strategy means that equations with a
variable at the first argument position are only applied when no other
equation is applicable.  Finally, when this search also fails the
interpreter looks for a default equation that matches with the term.

This implementation trick was also available
in the interpreter of the old \metaenv.
PIETER: How about the default rules?

The rewrite machine itself consists a collection of recursive
functions which have as arguments a set of equations, the term to be
rewritten, and an environment in which the instantiated variables are
stored.

\begin{footnotesize}
\begin{verbatim}
context-free syntax
  rewrite(ATermList,ATerm,Env) -> ATerm
\end{verbatim}
\end{footnotesize}
Recursion is used to implement the backtracking behaviour of list
matching in \asf.  The instantiation of list variables is done by
assigning an ``arbitrary'' sublist to a list variable.  If this does
not lead to a successful matching of all variables in the equation or
one of the conditions can not be satisfied, another sublist should be
tried.  This process is repeated until either a successful match is
found, or all sublists are tried.

\asdf\ allows the use of conditional equations.  The conditions maybe
positive as well as negative.  This current implementation does not
allow the introduction of new variables in a negative condition.
Furthermore, it is not allowed to introduce new variables on both
sides of a positive condition. If new variables are introduced on one
side of a positive condition only the other side is rewritten which is
then matched against the ``variable introducing side'' of the
condition, leading to new variable bindings.

\subsection{Discussion}

There are a few open issues with respect to the interpreter.  First,
the performance of the current version is reasonable.  If there is no
list matching involved the interpreter performs 6000 rewrite steps per
second, the interpreter in the old \metaenv\ performs 20.000 rewrite
steps per second for the same specification and term. So, there is at
least a factor 3 to be gained.

Second, in the current version no or almost no preprocessing of the
specification is performed.  A number of preprocessing steps could
improve the performance considerably.  One obvious preprocessing step
is the calculation of which side of a positive condition introduces
new variables.  Another very effective preprocessing step is the
transformation of some forms of list matching into non list matching,
e.g., obtaining the head and tail of a list, etc.  This can be done
because we know the internal data structure for lists in the
interpreter.  The list transformations are also important when
compiling \asdf\ specifications.

\section{Future Work}

There is a huge bulk of future work to be done.  First of all, the
parser and parser generator \cite{Vis97.SGLRP} has to be integrated in
the new \metaenv.  Second, the unparser and unparser generator
\cite{BV96} has to be integrated as well as the To\LaTeX\ facilities
\cite{Vis95.tolatex}. This should be done on top of the {\sc Box}
language.  Third, the \metaenv\ should provided facilities to compile
specifications in order to generate stand-alone environments.  Fourth,
a debugging facility for debugging specifications should be provided
as well.  Finally, the new \metaenv\ should provide sophisticated help
facilities and demonstration modes based on internet facilities.

The tree-repository should provided a sophisticated querying mechanism
as described in \cite{BKV96b}.

\bibliographystyle{alpha}
\bibliography{metabib}

\end{document}
