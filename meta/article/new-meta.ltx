\documentclass{article}
\usepackage{latexsym}
\usepackage{ASF+SDF,ASF+SDF-options}
\usepackage{epsfig}

\title{Design and Implemention a New {\sc Asf+Sdf} Meta-Environment}

\author{Mark van den Brand$^{^1}$, Tobias Kuipers$^{^2}$, \\
        Leon Moonen$^{^1}$, Pieter Olivier$^{^1}$\\
        {\small\sl $^1$University of Amsterdam,
        Programming Research Group\vspace{-.2cm}}\\
        {\small\sl Kruislaan 403, NL-1098 SJ Amsterdam, The Netherlands}
        \vspace{.1cm}\\
        {\small\sl $^2$CWI,
        Department of Software Engineering\vspace{-.2cm}}\\
        {\small\sl P.O. Box 94079, NL-1090 GB Amsterdam, The Netherlands}
        \vspace{.1cm}\\
        {\small \sl\tt markvdb@wins.uva.nl,Tobias.Kuipers@cwi.nl,\vspace{-.2cm}}\\
        {\small \sl\tt leon@wins.uva.nl,olivierp@wins.uva.nl}
}

\def\aterms{\mbox{ATerms}}
\def\asfix{\mbox{\sc AsFix}}
\def\sdf{{\sc Sdf}}
\def\asf{{\sc Asf}}
\def\asdf{{\sc Asf+Sdf}}
\def\metaenv{{\sc Asf+Sdf}\ Meta-En\-vir\-on\-ment}
\def\TB{{\sc ToolBus}}
\def\centaur{{\sc centaur}}
\def\seal{{\sc seal}}
\def\epic{{\sc Epic}}
\def\lelisp{{\sc LeLisp}}
\def\T{{\bf T}}
\input{psfig}

\begin{document}

\maketitle

\begin{abstract}
To be written.
\end{abstract}

\section{Introduction}

In the beginning of the eigthies the design and implementation
of the current version of the \metaenv\ started.
An overview of these activities can be found in \cite{HK95}.
On top of \centaur~\cite{BCDIKLP89}
a programming environment (generator) for writing language definitions
in \asdf\ was developed \cite{Kli93.meta}.

The implementation could be considered a test environment for all kinds
of ideas concerning the lazy and incremental generation of
scanners, parsers, and term rewriting machines.
The development of advanced hybrid editing techniques \cite{Koo94.thesis},
origin tracking techniques \cite{Deu94.thesis}, incremental
rewriting \cite{Meu94.thesis}, automatic
generation of unparsers, debugging facilities of term rewriting, and
the generation of \LaTeX\ code were performed within or with
this implementation as well.

The current implementation of the \metaenv\ has a number of drawbacks
and shortcomings, the most important ones are listed in Table~\ref{short}.
These complaints initiated a redesign and reimplementation of the \metaenv.
Initially we believed in an incremental reimplemenation of the
\metaenv\ was feasible, and therefore a number of people
started working on the design and implementation of a new user-interface
and the replacement of the text editing facilities of GSE \cite{Koo94.thesis}
by Emacs and Epoch in 1992 \cite{KB93}.
However, it turned out that this implementation was not deadlock free.
This initiated the development of the \TB, a software interconnection
architecture \cite{BK96a,BK96b} which takes care of the communication of
software components.

\begin{table}
\begin{center}
\begin{tabular}{|l|} \hline
Complaints or shortcomings \\ \hline\hline
The user-interface is old-fashioned and badly organized: \\
reduced terms not in term-editor and long flat lists of  \\
modules for deleting and editing of modules and terms.   \\ \hline
An often heard complaint was: ``The editor is too        \\
restriced, why is it not emacs- or vi-like?''            \\ \hline
The creation of stand-alone environments is not possible. \\ \hline
It is impossible to port to different architectures.      \\
Limited availability of \lelisp\ on various platforms.      \\
Our version of \lelisp\ is becoming obsolete.               \\ \hline 
The tree formalism VTP is not easy to use, connection     \\
\lelisp/VTP is complicated.                                \\ \hline
The current monolithic system is hard to maintain. New    \\
research ideas are hard to implement.                     \\ \hline \hline
\end{tabular}
\end{center}
\caption{\label{short} Drawbacks of the current version of the \metaenv.}
\end{table}

Based on the Epoch-GSE-UI coupling it was decided to
design and implement the new \metaenv\ from scratch.
The problems concerning \lelisp\ makes a ``from scratch'' approach even
more important.
In this paper we discuss the first prototype of the new \metaenv\ based
on the \TB. 
This prototype has a very restricted functionality but offers an extendable
infrastructure to experiment with various designs.

\subsection{Tree Representation}

In the current version of the \metaenv\ the abstract syntax trees are 
represented by means of VTP (Virtual Tree Processing formalism)
offer by \centaur.
There are two problems connected to VTP: it is hard to learn programming
in VTP and VTP does not offer enough facilities to prevent illegal
access to constructed trees. This latter drawback causes a number of
the maintenance problems in the \metaenv.

These ``VTP-problems'' led to the development of an alternative
formalism to represent syntax trees: \asfix.
This \asfix\ formalism is an instantiation of a generic {\em annotated
term} format: \aterms~\cite{BKOV97}.
The \sdf\ definition of \aterms\ is presented in Figure~\ref{at}.

\begin{figure}
\centerline{\fbox{
\begin{minipage}[htb]{\textwidth}
{\small \input{ATerms.mtx} }
\end{minipage}
}
}
\caption{\label{at} Context-free syntax definition of \aterms.
}
\end{figure}

\aterms\ will be used to represent structured information to be exchanged
between a heterogenuous collection of tools.
They should be independent of any specific tool, but
they should be able to accomodate the representation of {\em all}
data that is to be exchanged between tools.
Consider the following example \aterms:
\begin{tabbing}
annotation\ \ \ \ \= f(123)\{\=xxxx\kill
constant\>abc\\
numeral\>123\\
literal\>"abc" "123"\\
list\>[] [1, "abc", 3] [1, 2, [3,4], 5]\\
functions\>f("abc")\\
annotation\>f(123)\{color("red"),path([0,2,1])\}
\end{tabbing}

These \aterms\ are sufficient to encode parse trees (including
optional annotations) for programs or specifications in any
language.
\asfix\ is an instance of \aterms\ used for representing
the {\em parse trees} of \asdf\ specifications.
Parse trees means: all keywords, whitespace, comments, etc.\ are
preserved in the tree representation.
A self descriptive representation is used, i.e., each application
of a syntax rule contains a copy of that rule (in the implementation
these are all shared).

Consider the following context-free syntax rules:

\begin{small}
\begin{verbatim}
context-free syntax
  true          -> Bool
  false         -> Bool
  Bool and Bool -> Bool {left}
\end{verbatim}
\end{small}
the parse tree below represents {\tt true and false}:

\begin{small}
\begin{verbatim}
appl(prod(id("Booleans"),w(""),
          [sort("Bool"),w(""),l("and"),w(""),sort("Bool")],w(""),
          l("->"),w(""),sort("Bool"),w(""),
          attrs(l("{"),w(""),[l("left")],w(""),l("}"))),
     [appl(prod(id("Booleans"),w(""),
                [l("true")],w(""),l("->"),w(""),sort("Bool"),w(""),
                no-attrs),
           [l("true")]),
      w(" "),l("and"),w(" "),
      appl(prod(id("Booleans"),w(""),
                [l("false")],w(""),l("->"),w(""),sort("Bool"),w(""),
                no-attrs),
           [l("false")])])
\end{verbatim}
\end{small}
where:
\begin{itemize}
\item {\tt appl}: constructor for function application with arguments.
\item {\tt prod}: constructor for productions.
\item {\tt w}: constructor for whitespace.
\item {\tt l}: constructor for literals.
\item {\tt sort}, {\tt id}: constructor for constants.
\item {\tt no-attrs}: constructor for empty attribute list.
\end{itemize}

\subsection{General Architecture}

The architecture of the new \metaenv\ is depicted in Figure~\ref{picarch}.
In fact this figure does not depict the current state of the prototype
or the future architecture of the system.
There are a number of components enlisted which are not yet integrated
in the prototype, see Table~\ref{components} for a more detailed list
of integrated components.
It is not the future architecture because important components like
unparsers and debuggers are missing.

\input{newarch}
\begin{figure}[tb]
\centerline{\box\graph}
\caption{\label{picarch} General architecture of new \metaenv.}
\end{figure}

Table~\ref{components} gives an overview of all currently available
components in the prototype. For each component it is listed whether
this components is specified and in which language it is implemented.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|} \hline
Activity            & Specification & Implementation  \\
                    & Language      & Language        \\ \hline \hline
\aterms             & \asdf         & C, JAVA         \\ 
\asfix              & \asdf         & C, JAVA         \\ 
\TB                 & \asdf         & C               \\
Structure editor    & \asdf         & JAVA            \\
Text editor         &               & Tcl/Tk          \\
Interpreter         & \asdf         & C               \\
Tree repository     & \asdf         & C               \\
Import manager      & \asdf         & C               \\
user-interface/Dot  &               & Tcl/Tk          \\ \hline
\end{tabular}
\end{center}
\caption{\label{components} Components of the new \metaenv\ which are finished.}
\end{table}

Figure \ref{nm} contains a screendump of the current prototype.
The various components will be discussed in the next sections.

\begin{figure}[htb]
\centerline{\psfig{figure=newmeta.ps,width=\textwidth}}
\caption{\label{nm} The new \metaenv.}
\end{figure}

\input{toolbus.ltx}

\section{User-interface}

\section{Repositories}

\section{Editors}

\section{Interpreter}

\section{Future Work}
\input{future-debugging.ltx}

\bibliographystyle{alpha}
\bibliography{/home/gipe/lib/tex/bib,/home/gipe/lib/tex/LanguageProto,metabib}

\end{document}
