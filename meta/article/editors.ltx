%%% $Id$

%% This file is part of the document 
%% Design and implementation of a new ASF+SDF Meta-Environment

%%\newcommand{\gse}{\textsc{gse}}
%%\newenvironment{codebox}{\vspace{-.3cm}\begin{alltt}\begin{boxedminipage}[t]{6cm}}{\end{boxedminipage}\end{alltt}}
\newenvironment{codebox}{\begin{center}\begin{minipage}[t]{6cm}\begin{alltt}}{\end{alltt}\end{minipage}\end{center}}

\section{Editors}
\label{edit}

The structure editor in the new implementation provides roughly the
same functionality to the user as the Generic Structure Editor
(\gse~\cite{Koo94.thesis}). There are, however a number of
differences, both in the external and the internal behaviour.

\subsection{Internal behaviour}

The structure editing system consists of two parts. One is a
\emph{structure} editor, the other is a \emph{text} editor. The
structure editor operates on parse trees (encoded as AsFix terms). It
only manipulates (sub)trees, i.e.\ it does not manipulate individual
nodes in a parse tree. The text editor operates on a character level,
it \emph{does} manipulate individual nodes in a parse tree.

Both the text editor and the structure editor have a well defined
external behaviour (a ToolBus interface)~\cite{Kui96}. This 
makes it possible to use any (existing) text editor as long as it
adheres to the interface. One of the main weaknesses of \gse\ has
always been its limited text editing capabilities. By separating text
and structure editing functionality we hope to address this problem. 

The text and structure editors are tied together by means of a ToolBus
script. This script provides us with a tight coupling between the
two. This coupling makes sure that at any given time the data
structure in the text editor (the text) can be translated to the data
structure in the structure editor (the parse tree), and vice
versa. If a string $\alpha$ is a syntactically correct string in the
language $L$, and we have a parser $\Pi_L$ over this language and a pretty printer $pp$
then $pp(\Pi_L(\alpha)) = \alpha$. If $t$ is the parse tree that results
from $\Pi_L(\alpha)$ then also $\Pi_L(pp(t)) = t$.

\subsection{External behaviour}\label{externaleditor}

If the edited text is not syntactically correct (which is inevitable
during editing) then the smallest subtree that contains an incorrect
program fragment will be held in a focus. In \gse\ a similar approach
is used. The main difference between \gse\ and the new structure
editor is that \gse\ has 2 specific modes, one for text editing and one
for structure editing. The new editor does not need this
distinction. The difference between these approaches is perhaps best
illustrated with an example.

Consider the following program in the language While (\cite{Vis97.spl}).
\begin{codebox}
 x := 10 ;
 while x > 0 do x := x - 1 \end{codebox}
Now suppose we want to decrease x with 2 during each iteration. We
replace the character \texttt{1} with the character \texttt{2}. After
this replacement the focus will be on the integer 2 (The underlined
character).
\begin{codebox}
 x := 10 ;
 while x > 0 do x := x - \underline{2} \end{codebox}
Now suppose we want to edit the stop condition of the while loop, such
that the loop terminates when x is greater than 2. In \gse\ the focus
would then look like this:
\begin{codebox}
 x := 10 ;
 \underline{while x > 2 do x := x - 2} \end{codebox}
In the new editor, instead of increasing the focus, a new focus will
be created, which looks like this:
\begin{codebox}
 x := 10 ;
 while x > \underline{2} do x := x - \underline{2} \end{codebox}
Obviously, this results in less parsing than in \gse. Of course, this
is a very benign example. If we take the original program again, and
decide to put the body of the while loop between brackets, we get the
following focus positions.
\begin{codebox}
 x := 10 ;
 while x > 0 do \underline{\{x} := x - \underline{1\}} \end{codebox}
where in \gse\ we would have had
\begin{codebox}
 x := 10 ;
 while x > 0 do \underline{\{x := x - 1\}} \end{codebox}
In this case, the last solution is better, because the first solution
leaves us with two syntactically incorrect focuses. However, there are
a number of strategies that could help us here. In this case, the
solution would be to create a new focus that exactly contains all the
old focuses, effectively giving the same functionality as \gse.


\subsection{Implementation}

As stated above, the editing system has been implemented as two
separate tools. The structure editor was specified in \asdf. This
specification can be used as implementation using the interpreter
described in Section \ref{interpreter}. Because of the experimental
nature of the system in this stage, it proves to be difficult to use
the interpreter at two levels at the same time (as a rewrite machine
for specifications written using the \metaenv, and as a implementation
of the editor this specification is written in). Besides, the
interpreter is not (currently) fast enough to support interactive
use. We therefore implemented the structure editor in \java, which
provides us with an implementation that is independent of the other
components of the \metaenv, and sufficiently fast to cater for
interactive use.

The text editor we use is jedit, a public domain text editor written
in \tcltk. It is easily extendible which allows us to experiment with
different lay-outs, and {\ui}s. 

\subsection{Discussion}

In Section \ref{externaleditor} we mentioned the need for
experimenting with different parsing strategies. By moving the
implementation of these strategies out of the structure editor and
into the \TB-script, we hope to create a system that provides us with
the flexibility to try out different strategies. 

The structure editing specification so far has only been tested on
small examples. We need to see how the specification holds up when
used with larger, more complex editing sessions. 

The text editor that is used currently needs to be replaced with a
well known editor. We will try to incorporate emacs into the structure
editing system.


