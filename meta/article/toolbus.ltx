\section{General Architecture}

The architecture of the new \metaenv\ is depicted in
Figure~\ref{picarch}.  In fact this figure does not depict the current
state of the prototype or the future architecture of the system.
There are a number of components enlisted which are not yet integrated
in the prototype, see Table~\ref{components} for a more detailed list
of integrated components.  It is not the future architecture because
important components like unparsers and debuggers are missing.

\input{newarch}
\begin{figure}[tb]
\centerline{\box\graph}
\caption{\label{picarch} General architecture of new \metaenv.}
\end{figure}

Table~\ref{components} gives an overview of all currently available
components in the prototype. For each component it is listed whether
this components is specified and in which language it is implemented.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|} \hline
Activity            & Specification & Implementation  \\
                    & Language      & Language        \\ \hline \hline
\aterms             & \asdf         & C, Java         \\
\asfix              & \asdf         & C               \\
\TB                 & \asdf         & C               \\
Structure editor    & \asdf         & Java            \\
Text editor         &               & \tcltk{}        \\
Interpreter         & \asdf         & C               \\
Tree repository     & \asdf         & C               \\
Import manager      & \asdf         & C               \\
\upcase{\ui}        &               & \tcltk{}, \tcldot{}     \\ \hline
\end{tabular}
\end{center}
\caption{\label{components} Components of the new \metaenv\ which are finished.}
\end{table}

\subsection{Implementation}
\label{toolbus}

%{{{ Intro

Our whole design is based on the
\TB software application architecture\cite{TB-AMAST96,BK96a}
which is a software application architecture that 
utilizes a scripting language based on process 
algebra\cite{BW90} to
describe the communication between software tools. A \TB\ \emph{script}
describes a number of processes that can communicate with each other and
with \emph{tools} existing outside the \TB\ (Figure \ref{TB}).
A tool is roughly equivalent to an operating system process.
A language-dependent adapter that translates between the internal
\TB\ data format and the data format used by the individual tools
makes it possible to write every tool in the language best suitable
for the task(s) it has to perform.

\begin{figure}[htb]
  \centerline{\epsfig{file=toolbus.ps,scale=0.5}}
  \caption{\label{TB}The \TB\ software application architecture}
\end{figure}

The following sections give an overview of the most important \TB\
features. For a more complete description of \TB\ expressions and
primitives see \cite{BK96a}.

\subsubsection{Communication inside the \TB}
There are two mechanisms available for processes in the \TB\ to
communicate with each other, message passing and selective broadcasting.
A process can synchronously send a \emph{message} using the {\tt snd-msg} 
primitive which must be received by another process using the {\tt rec-msg} 
primitive. A process can send a \emph{note} using 
{\tt snd-note} to all processes that have subscribed, using {\tt subscribe},
to that particular note type. The receiving processes read notes 
asynchronously using {\tt rec-note}, at low priority. Transmitting notes 
amounts to \emph{asynchronous selective broadcasting}.

%}}}
%{{{ Communication between the ToolBus and tools

\subsubsection{Communication between \TB\ and tools}
A \TB\ process can initiate communication with a tool by sending a 
message to a tool using {\tt snd-do}, or {\tt snd-eval} when an answer
is expected. A process can receive the answer to a {\tt snd-eval} request 
using the {\tt rec-value} action.

A tool can initiate communication by sending an \emph{event}
to the \TB. A \TB\ process receives this event using
the {\tt rec-event} primitive and must acknowledge the event using 
the {\tt snd-ack-event} primitive.

The execution and termination of the tools attached to the \TB\, as well
as their connection/disconnection can be controlled explicitly by appropriate
primitives.

%}}}
%{{{ Process composition

\subsubsection{Process composition}
More complex processes can be created using process composition operators
for \emph{choice} ({\tt +} operator), \emph{sequential composition} 
({\tt .} operator), 
\emph{parallel composition} ({\tt ||} operator),
\emph{iteration} ({\tt *} operator)
and \emph{guarded (conditional) execution}
(the {\tt if-then-fi} operator). The \emph{process creation}
primitive {\tt create} can be used to create new processes.

%}}}
%{{{ Types and variables

\subsubsection{Types and variables}
All terms within the \TB\ are \emph{typed}. The \TB\ defines a number of
basic types for booleans, integers, reals, strings, and binary strings. Complex
types can be formed using a list constructor or function application. The type
{\tt term} is a supertype of all other types. The {\tt let-in-endlet} construction
makes it possible to declare variables.

%}}}

\subsection{Debugging}

Debugging in the context of the new \metaenv\ has three dimensions:
\begin{enumerate}
\item Debugging the new \metaenv\ itself.
\item Debugging \asdf\ specifications and generated programming environments.
\item Debugging programs developed using the generated 
      programming environments.
\end{enumerate}

Our recent work on generic debugging techniques for distributed,
heterogeneous environments\cite{COORD97.tide}
cover both dimension {\tt 1} and {\tt 2}. 
More research is needed to also use this technology to cover dimension {\tt 3},
which is closely related to techniques like {\em origin tracking}\cite{DHK96}.
\subsection{Discussion}

There is a huge bulk of future work to be done.  First of all, the
parser and parser generator \cite{Vis97.SGLRP} has to be integrated in
the new \metaenv.  Second, the unparser and unparser generator
\cite{BV96} has to be integrated as well as the To\LaTeX\ facilities
\cite{Vis95.tolatex}. This should be done on top of the {\sc Box}
language.  Third, the \metaenv\ should provided facilities to compile
specifications in order to generate stand-alone environments.  Fourth,
a debugging facility for debugging specifications should be provided
as well.  Finally, the new \metaenv\ should provide sophisticated help
facilities and demonstration modes based on internet facilities.

Origin tracking added.


