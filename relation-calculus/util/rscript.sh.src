#! /bin/sh

# rscript -- check and execute an Rscript
# This utility provides the following functionality
# - parse and check an Rscript
# - parse, check and evaluate an Rscript
# - parse, check and evaluate an Rscript with a given Rstore

set -e

# {{{  variables
prefix=__PREFIX__
bindir=__BINDIR__
datadir=__DATADIR__

PRG=`basename $0`
VERBOSE=
CHECK_ONLY=
EVALUATOR=${bindir}/RscriptCalculator
RSCRIPT_PARSE_TABLE=${datadir}/Rscript.trm.tbl
RSTORE_PARSE_TABLE=${datadir}/Rstore.trm.tbl
THE_RSCRIPT=
OUTPUT=./result.rstore
RSTORE=
TYPE_CHECKER="asfe -e ${datadir}/RscriptChecker.eqs"
OUTPUT_TYPE_CHECKER=./.checker.feedback
TYPE_CHECKING_OK="Rscript is type correct!"
TMP_FILES=$OUTPUT_TYPE_CHECKER

# }}}

# {{{  usage

usage() {
cat << ENDCAT >&2
Usage: $PRG [options] [filename]

Options:
  -i (--input)        filename	input from file (default: stdin)
  -o (--output)       filename	output to file (default: result.rstore)
  -s (--store)        filename  initial Rstore (default: empty)
  -c (--check-only)             only check the Rscript, do not evaluate it
  -v (--verbose)                verbose output (default:none)

Advanced options:
  -e (--evaluator)    filename  alternative Rscript evaluator
  -p (--parse-table)  filename  alternative parse table
  -t (--type-checker) filename  alternative type checker

Example:
  $PROG -i query.rscript

ENDCAT
}

# }}}
# {{{  add_tmp_file

add_tmp_file() {
    TMP_FILES="$TMP_FILES $1"
}
# }}}
# {{{  cleanup

cleanup() {
  rm -f $TMP_FILES
}

# {{{  parse_rscript

parse_rscript() {
  sglr $VERBOSE -p $RSCRIPT_PARSE_TABLE -s RSCRIPT -i $THE_RSCRIPT -o $THE_RSCRIPT.pt
  add_tmp_file  $THE_RSCRIPT.pt
}

# }}}
# {{{  parse_rstore

parse_rstore() {
  case $RSTORE in
      *.pt) PARSED_RSTORE=$RSTORE;;

      *) sglr $VERBOSE -p $RSTORE_PARSE_TABLE -s RSTORE -i $RSTORE -o $RSTORE.pt
	 PARSED_RSTORE=$RSTORE.pt
	 add_tmp_file  $RSTORE.pt
	 ;;
  esac
}

# }}}
# {{{  check

check() {
  addPosInfo -p $THE_RSCRIPT -i $THE_RSCRIPT.pt \
  | apply-function -f check-rscript -s Summary \
  | $TYPE_CHECKER \
  | unparsePT >$OUTPUT_TYPE_CHECKER
}

# }}}

# {{{ evaluate

evaluate() {
  if [ -z $RSTORE ]
  then
      $EVALUATOR $VERBOSE -s -f "eval-rscript" \
	  -i $THE_RSCRIPT.pt -r RSTORE \
	  | unparsePT > $OUTPUT
  else
      parse_rstore
      $EVALUATOR $VERBOSE -s -f "eval-rscript-with-rstore" \
	  -i $THE_RSCRIPT.pt -i $PARSED_RSTORE -r RSTORE \
	  | unparsePT > $OUTPUT
  fi
}

# }}}

if [ $# -eq 0 ]; then
  usage
  exit 1
fi

while [ $# -gt 0 ]
do
  case "$1" in
    -e | --evaluator)
      shift; EVALUATOR=$1 ;;
    -o | --output)
      shift; OUTPUT=$1 ;;
    -p | --rscript-parse-table)
      shift; RSCRIPT_PARSE_TABLE=$1 ;;
    -i | --input)
      shift; THE_RSCRIPT=$1 ;;
    -s | --store)
      shift; RSTORE=$1 ;;
    -t | --type-checker)
      shift; TYPE_CHECKER=$1 ;;
    -c | --check-only)
      CHECK_ONLY=yes ;;
    -v | --verbose)
      VERBOSE=-v ;;
    *.rscript)
      THE_RSCRIPT=$1 ;; 
    *)
      usage; exit 1 ;;
  esac
  shift
done

parse_rscript
check


if [ "$CHECK_ONLY" == "yes" ]
then
    if grep  -q "$TYPE_CHECKING_OK" "$OUTPUT_TYPE_CHECKER"
    then 
	echo $THE_RSCRIPT is type correct
    else
	cat $OUTPUT_TYPE_CHECKER
	echo ""
    fi
    exit
fi
   
if grep  -q "$TYPE_CHECKING_OK" "$OUTPUT_TYPE_CHECKER"
then 
    evaluate
else 
    cat $OUTPUT_TYPE_CHECKER
    echo ""
    echo "There are type errors in $THE_RSCRIPT; script is not executed"
fi

cleanup
