#! /bin/sh

# rscript -- check and execute an Rscript
# This utility provides the following functionality
# - parse and check an Rscript
# - parse, check and evaluate an Rscript
# - parse, check and evaluate an Rscript with a given Rstore

set -e

# {{{  variables
prefix=__PREFIX__
bindir=__BINDIR__
datadir=__DATADIR__

PRG=`basename $0`
VERBOSE=
CHECK_ONLY=
EVALUATOR=${bindir}/RscriptCalculator
TESTSUITES=${bindir}/RscriptTestsuites
USE_TESTSUITES=no
RSCRIPT_PARSE_TABLE=${datadir}/Rscript.trm.tbl
RSTORE_PARSE_TABLE=${datadir}/Rstore.trm.tbl
THE_RSCRIPT=
OUTPUT_AS_TREE=
OUTPUT=
RSTORE=
TYPE_CHECKER="asfe -e ${datadir}/RscriptChecker.eqs"
OUTPUT_TYPE_CHECKER=./.checker.feedback
TYPE_CHECKING_OK="Rscript is type correct!"
TMP_FILES=$OUTPUT_TYPE_CHECKER

# }}}

# {{{  usage

usage() {
cat << ENDCAT >&2
Usage: $PRG [options] [filename]

Options:
  -i (--input)              filename  input from file (default: stdin)
  -o (--output-parse-tree)  filename  output as parse-tree to filename
  -s (--store)              filename  initial Rstore (default: empty)
  -c (--check-only)                   only check the Rscript, do not evaluate it
  -t (--testsuite)                    execute as test suite
  -v (--verbose)                      verbose output (default:none)

Examples:
  $PRG query.rscript
  $PRG -i query.rscript -s previous.rstore -o result.rstore.pt

ENDCAT
}

# }}}
# {{{
set_output_style(){
  if test -z "$OUTPUT_AS_TREE"
  then
      OUTPUT="unparsePT"
  else
      OUTPUT="eval cat >"$OUTPUT_AS_TREE
  fi
}
# }}}
# {{{  add_tmp_file

add_tmp_file() {
    TMP_FILES="$TMP_FILES $1"
}
# }}}
# {{{  cleanup

cleanup() {
  rm -f $TMP_FILES
}

# {{{  parse_rscript

parse_rscript() {
  sglr $VERBOSE -p $RSCRIPT_PARSE_TABLE -s RSCRIPT -i $THE_RSCRIPT -o $THE_RSCRIPT.pt
  add_tmp_file  $THE_RSCRIPT.pt
}

# }}}
# {{{  parse_rstore

parse_rstore() {
  case $RSTORE in
      *.pt) PARSED_RSTORE=$RSTORE;;

      *) sglr $VERBOSE -p $RSTORE_PARSE_TABLE -s RSTORE -i $RSTORE -o $RSTORE.pt
	 PARSED_RSTORE=$RSTORE.pt
	 add_tmp_file  $RSTORE.pt
	 ;;
  esac
}

# }}}
# {{{  check

check() {
  addPosInfo -p $THE_RSCRIPT -i $THE_RSCRIPT.pt \
  | apply-function -f check-rscript -s Summary \
  | $TYPE_CHECKER \
  | unparsePT >$OUTPUT_TYPE_CHECKER
}

# }}}

# {{{ evaluate

evaluate() {
  if [ -z $RSTORE ]
  then
      if [ $USE_TESTSUITES = no ]
      then 
          $EVALUATOR $VERBOSE -f "eval-rscript" \
	  -i $THE_RSCRIPT.pt -r RSTORE \
	  | $OUTPUT
      else  
	  $TESTSUITES $VERBOSE -f "eval-rscript-testsuite" \
	  -i $THE_RSCRIPT.pt -r TESTREPORT \
	  | $OUTPUT
      fi
  else
      parse_rstore
      $EVALUATOR $VERBOSE -f "eval-rscript-with-rstore" \
	  -i $THE_RSCRIPT.pt -i $PARSED_RSTORE -r RSTORE \
	  | $OUTPUT
  fi
  echo ""
}

# }}}

if [ $# -eq 0 ]; then
  usage
  exit 1
fi

while [ $# -gt 0 ]
do
  case "$1" in
    -o | --output-parse-tree)
      shift; OUTPUT_AS_TREE=$1 ;;
    -i | --input)
      shift; THE_RSCRIPT=$1 ;;
    -s | --store)
      shift; RSTORE=$1 ;;
    -t | --testsuite)
      USE_TESTSUITES=yes ;;
     -c | --check-only)
      CHECK_ONLY=yes ;;
    -v | --verbose)
      VERBOSE=-v ;;
    *.rscript)
      THE_RSCRIPT=$1 ;; 
    *)
      usage; exit 1 ;;
  esac
  shift
done

set_output_style
parse_rscript
check


if [ "$CHECK_ONLY" == "yes" ]
then
    if grep  -q "$TYPE_CHECKING_OK" "$OUTPUT_TYPE_CHECKER"
    then 
	echo $THE_RSCRIPT is type correct
    else
	cat $OUTPUT_TYPE_CHECKER
	echo ""
    fi
    exit
fi
   
if grep  -q "$TYPE_CHECKING_OK" "$OUTPUT_TYPE_CHECKER"
then 
    evaluate
else 
    cat $OUTPUT_TYPE_CHECKER
    echo ""
    echo "There are type errors in $THE_RSCRIPT; script is not executed"
fi

cleanup
