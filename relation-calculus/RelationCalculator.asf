 equations

%%---- Store

[VL1]   value(Var, [<Var, Val>, VPair*]) = Val
[VL2]   Var != Var' ===> value(Var, [<Var', Val>, VPair*]) = value(Var, [VPair*])

[RV1]   Rel = value(Var, Store)
        =======================================
        rel-value(Var, Store) = Rel

[ASG1]  assign(Var, Val, [VPair*]) = [<Var, Val>, VPair*]

[add1a]  add(Var, E, [<Var, Val>, VPair*]) = [<Var, apply({E} union Val)>, VPair*]

[add1b]  Var != Var',
         [VPair*'] = add(Var, E, [VPair*])
         ===============================================================
         add(Var, E, [<Var', Val>, VPair*]) = [<Var', Val>, VPair*']

[add1c]  add(Var, E, []) = [<Var, {E}>]

[add2a]  add(Var, <E1, E2>, [<Var, Val>, VPair*]) = [<Var, apply({<E1, E2>} union Val)>, VPair*]

[add2b]  Var != Var', 
	 [VPair*'] =add(Var, <E1, E2>, [VPair*])
         ===============================================================
         add(Var, <E1, E2>, [<Var', Val>, VPair*]) = [<Var', Val>, VPair*']

[add2c]  add(Var, <E1, E2>, []) = [< Var, {<E1, E2>} >]


[add3a]  add(Var, Rel, [<Var, Val>, VPair*]) = [<Var, apply(Rel union Val)>, VPair*]

[add3b]  Var != Var', 
	 [VPair*'] =add(Var, Rel, [VPair*])
         ===============================================================
         add(Var, Rel, [<Var', Val>, VPair*]) = [<Var', Val>, VPair*']

[add3c]  add(Var, Rel, []) = [< Var, Rel >]




%%---- if

[if1]  if true then Val1 else Val2 fi  = Val1
[if2]  if false then Val1 else Val2 fi = Val2

%%---- Equality on elements

[e1]   equal(E, E)  = true
[default-e2] 
       equal(E, E') = false

%%---- 

[EVP]  Bool = evalx(Exp, Store)
       ==================================================
       evalp(Exp, Store) = Bool

[EVE]  E = evalx(Exp, Store)
       ==================================================
       evale(Exp, Store) = E

[EVB1] Bag = evalx(Exp, Store)
       ==================================================
       evalb(Exp, Store) = Bag

[EVB2] *empty* = evalx(Exp, Store)
       ==================================================
       evalb(Exp, Store) = {}

[EVR1] Rel = evalx(Exp, Store)
       ==================================================
       evalr(Exp, Store) = Rel

[EVR1] *empty* = evalx(Exp, Store)
       ==================================================
       evalr(Exp, Store) = {}

%% ---- Eval script

[ES1]  eval-rscript(Stat*) = eval-rscript(Stat*, [])

[ES2]  eval-rscript(Stat Stat*, Store) = eval-rscript(Stat*, eval-rscript(Stat, Store))
[ES3]  eval-rscript( , Store) = Store

%% ---- Eval statements

[S1]  eval-rscript(def Var = Exp, Store) = assign(Var, evalx(Exp, Store), Store)

[S3]   eval-rscript(fun Var1(Var2) = Exp, Store) = assign(Var1, <Var2, Exp>, Store)

[S7]   eval-rscript(fun Var1(Var2, Var3) = Exp, Store) = assign(Var1, <Var2, Var3, Exp>, Store)

[S8]   eval-rscript(fun Var1(Var2, Var3, Var4) = Exp, Store) = assign(Var1, <Var2, Var3, Var4, Exp>, Store)

%% ---- Eval elementary predicates

[Pt]   evalx(true, Store) = true

[Pf]   evalx(false, Store) = false

[Pa]   evalx(Exp1 and Exp2, Store) =  evalp(Exp1, Store) & evalp(Exp2, Store)

[Pb]   evalx(Exp1 or Exp2, Store) = evalp(Exp1, Store) | evalp(Exp2, Store)

[Pn]   evalx(not Exp, Store) =  not(evalp(Exp, Store))

%% ---- Eval other predicates

[EQ1]  evalx(Exp1 == Exp2, Store) = apply(evalx(Exp1, Store) == evalx(Exp2, Store))

[EQ2]  apply(Bag1 == Bag2) = Bag1 == Bag2
[EQ3]  apply(Rel1 == Rel2) = Rel1 == Rel2
[EQ4]  apply(E1   == E2)   = equal(E1, E2)

[LE1]  evalx(Exp1 <= Exp2, Store) = apply(evalx(Exp1, Store) <= evalx(Exp2, Store))

[LE2]  apply(Bag1 <= Bag2) = Bag1 <= Bag2
[LE3]  apply(Rel1 <= Rel2) = Rel1 <= Rel2

[LT1]  evalx(Exp1 < Exp2, Store) = apply(evalx(Exp1, Store) < evalx(Exp2, Store))

[LT2]  apply(Bag1 < Bag2) = Bag1 < Bag2
[LT3]  apply(Rel1 < Rel2) = Rel1 < Rel2

[GE1]  evalx(Exp1 >= Exp2, Store) = apply(evalx(Exp1, Store) >= evalx(Exp2, Store))

[GE2]  apply(Bag1 >= Bag2) = Bag1 >= Bag2
[GE3]  apply(Rel1 >= Rel2) = Rel1 >= Rel2

[GT1]  evalx(Exp1 > Exp2, Store) = apply(evalx(Exp1, Store) > evalx(Exp2, Store))

[GT2]  apply(Bag1 > Bag2) = Bag1 > Bag2
[GT3]  apply(Rel1 > Rel2) = Rel1 > Rel2

%% ---- Eval Elements

%%[EE1]  evalx(E, Store) = E

[EE2]  evalx('E, Store) = E

[EE3]  evalx(Var, Store)  = value(Var, Store)

%% ---- Eval tuples

[ET1]  E1 = evale(Exp1, Store),
       E2 = evale(Exp2, Store)
       ==================================================
       evalx(<Exp1, Exp2>, Store) = <E1, E2>

%% ---- Eval bags

[EB1]  evalx('Bag, Store) = Bag

[EB2]  E = evale(Exp, Store), {E+} = evalb({Exp+}, Store)
       ===================================================
       evalx({Exp, Exp+}, Store) = {E, E+}

[EB3]  E = evale(Exp, Store)
       ===================================================
       evalx({Exp}, Store) = {E}

%% ---- Eval relations

[ER1] evalx('Rel, Store)  = Rel

[ER2] E1 = evale(Exp1, Store), E2 = evale(Exp2, Store),
      evalr({Texp+}, Store) = {Tuple+}
      ====================================================
      evalx({<Exp1, Exp2>, Texp+}, Store) = {<E1, E2>, Tuple+}

[ER3] E1 = evale(Exp1, Store), E2 = evale(Exp2, Store)
      ====================================================
      evalx({<Exp1, Exp2>}, Store) = {<E1, E2>}

%% ---- Eval operators

[UN1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 union Exp2, Store) = apply(Val1 union Val2)

[UN2]  apply(Bag1 union Bag2)   = union(Bag1, Bag2)
[UN3]  apply(*empty* union Bag) = Bag 
[UN4]  apply(Bag union *empty*) = Bag
[UN5]  apply(E union *empty*)   = E
[UN6]  apply(*empty* union E)   = E
[UN7]  apply(E1 union E2)       = union({E1}, {E2})
[UN8]  apply(E union Bag)       = union({E}, Bag)
[UN9]  apply(Bag union E)       = union(Bag, {E})

[UN10] apply(Rel1 union Rel2)     = union(Rel1, Rel2)
[UN11] apply(*empty* union Rel)   = Rel
[UN12] apply(Rel union *empty*)   = Rel
[UN13] apply(Tuple union *empty*) = Tuple
[UN14] apply(*empty* union Tuple) = Tuple
[UN15] apply(Tuple1 union Tuple2) = union({Tuple1}, {Tuple2})
[UN16] apply(Tuple union Rel)     = union({Tuple}, Rel)
[UN17] apply(Rel union Tuple)     = union(Rel, {Tuple})

[IN1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 inter Exp2, Store) = apply(Val1 inter Val2)

[IN2]  apply(Bag1 inter Bag2) = inter(Bag1, Bag2)
[IN3]  apply(Rel1 inter Rel2) = inter(Rel1,  Rel2)

[DF1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 \  Exp2, Store) = apply(Val1 \ Val2)

[DF2]  apply(Bag1 \ Bag2) = diff(Bag1, Bag2)
[DF3]  apply(Rel1 \ Rel2) = diff(Rel1, Rel2)

[CM1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 o  Exp2, Store) = apply(Val1 o Val2)

[CM2]  apply(Rel1 o Rel2) = compose(Rel1, Rel2)

[CP1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 x  Exp2, Store) = apply(Val1 x Val2)

[CP2]  apply(Bag1 x Bag2) = product(Bag1, Bag2)

[PJ1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 .  Exp2, Store) = apply(Val1 . Val2)

[PJ2]  apply(Rel . E)   = Rel . E
[PJ3]  apply(Rel . Bag) = Rel . Bag
[PJ4]  apply(E . Rel)   = E . Rel
[PJ5]  apply(Bag . Rel) = Bag . Rel

[TC1] Rel = evalr(Exp, Store)
      ===================================================
      evalx(Exp +, Store) = Rel +

[TC2] Rel = evalr(Exp, Store)
       ===================================================
       evalx(Exp *, Store) = Rel *

%% ---- Eval bag and relation formers

[EB10] evalx({ Var in Exp1 | Exp2 }, Store) = evalx({ Var in Exp1 | Exp2 | {Var}}, Store)

[EB11] evalx({ From+ | Exp1 | Exp2}, Store) =
       valformer(get_from(From+, Store), *empty*, Exp1, Store, Exp2)

[ER11] evalx({ <Var1, Var2> in Exp1 | Exp2 }, Store) =
       evalx({ <Var1, Var2> in Exp1 | Exp2 | {<Var1, Var2>}}, Store)

%% ---- Auxiliary functions for bag and relation formers

[GF1]  Bag = evalb(Exp, Store),
       get_from(From*, Store) = [Gen*]
       ==================================================
       get_from(Var in Exp, From*, Store) = [gen(Var, Bag, Bag, true), Gen*]

[GF2]  Rel = evalr(Exp, Store),
       get_from(From*, Store) = [Gen*]
       ==================================================
       get_from(<Var1, Var2> in Exp, From*, Store) = [gen(Var1, Var2, Rel, Rel, true), Gen*]

[GF3] get_from( , Store) = []

[BF1] has_more(Gens) = false
      ===================================================
      valformer(Gens, Val, Exp1, Store, Exp2) = Val

[BF2] has_more(Gens) = true,
      Store' = get_cur(Gens, Store),
      Gens' = get_next(Gens),
      Bool  =  evalp(Exp1, Store')
      =====================================================
      valformer(Gens, Val, Exp1, Store, Exp2) =
       if Bool
       then
         valformer(Gens', apply(evalx(Exp2, Store') union Val), Exp1, Store, Exp2)
       else
         valformer(Gens', Val, Exp1, Store, Exp2)
       fi

[HM1]  has_more([gen(Var, Bag1, Bag2, Bool), Gen*]) = Bool | has_more([Gen*])

[HM2]  has_more([gen(Var1, Var2, Rel1, Rel2, Bool), Gen*]) =  Bool | has_more([Gen*])

[default-HM] 
      has_more([Gen*]) = false

[GN1] get_next([Gen*]) = [Gen*']
      ====================================================
      get_next([gen(Var, {E}, Bag, Bool), Gen*]) = [gen(Var, Bag, Bag, false), Gen*']

[GN2] get_next([gen(Var, {E, E+}, Bag, Bool), Gen*]) = [gen(Var, {E+}, Bag, true), Gen*]

[GN3] get_next([Gen*]) = [Gen*']
      ====================================================
      get_next([gen(Var1, Var2, {Tuple}, Rel, Bool), Gen*]) =
      [gen(Var1, Var2, Rel, Rel,false), Gen*']

[GN4] get_next([gen(Var1, Var2, {Tuple, Tuple+}, Rel, Bool), Gen*]) =
      [gen(Var1, Var2, {Tuple+}, Rel, true), Gen*]

[GN5] get_next([]) = []

[GC1] get_cur([gen(Var, {}, {E, E*}, Bool), Gen*], Store) = get_cur([Gen*], Store)

[GC2] Store' = assign(Var, E, Store)
      ====================================================
      get_cur([gen(Var, {E, E*}, Bag, Bool), Gen*], Store) = get_cur([Gen*], Store')

[GC3] get_cur([gen(Var1, Var2, {}, Rel, Bool), Gen*], Store) = get_cur([Gen*], Store)

[GC4] Store' = assign(Var1, E1, Store),
      Store'' = assign(Var2, E2, Store')
      ====================================================
      get_cur([gen(Var1, Var2, {<E1, E2>, Tuple*}, Rel, Bool), Gen*], Store) =
      get_cur([Gen*], Store'')

[GC5] get_cur([], Store) = Store

%% ------------------------------

%% ---- FUN ( EXP ) -> EXP

[default-fun1]
        value(Var1, Store) = <Var2, Exp2>,
        Val = evalx(Exp1, Store),
        Store' = assign(Var2, Val, Store)
        ====================================================
	evalx(Var1(Exp1), Store) = evalx(Exp2, Store')

[Fid]   Bag  = evalb(Exp, Store)
        ====================================================
        evalx(id(Exp), Store) = id(Bag)

[Fdom]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(domain(Exp), Store) = domain(Rel)

[Fran]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(range(Exp), Store) = range(Rel)

[Fcar]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(carrier(Exp), Store) = carrier(Rel)
   
[Ftop]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(top(Exp), Store) = top(Rel)

[Fbot]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(bottom(Exp), Store) = bottom(Rel)

[Finv]  Rel = evalr(Exp, Store)
        ===================================================
        evalx(inv(Exp), Store) = inv(Rel)

[Fcmp]  Rel = evalr(Exp, Store)
        ===================================================
        evalx(compl(Exp), Store) = compl(Rel)

%% ---- FUN ( EXP , EXP )  -> EXP

[default-fun2]
        value(Var, Store) = <Var1, Var2, Exp3>,
        Val1 = evalx(Exp1, Store),
        Val2 = evalx(Exp2, Store),

        Store' = assign(Var1, Val1, Store),
	Store'' = assign(Var2, Val2, Store')
        ==================================================
	evalx(Var(Exp1, Exp2), Store) = evalx(Exp3, Store'')

%%      fun domR(REL, Bag) = { <$x, $y> in REL | $x in Bag | {<$x, $y}>}

[RdomR] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ===================================================
        evalx(domR(Exp1, Exp2), Store) = domR(Rel, Bag)

[FranR] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ===================================================
        evalx(ranR(Exp1, Exp2), Store) = ranR(Rel, Bag)

[FcarR] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(carR(Exp1, Exp2), Store) = carR(Rel, Bag)

[FdomX] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(domX(Exp1, Exp2), Store) = domX(Rel, Bag)

[FranX] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(ranX(Exp1, Exp2), Store) = ranX(Rel, Bag)

[FcarX] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(carX(Exp1, Exp2), Store) = carX(Rel, Bag)

[Felm1]  E = evale(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(elem(Exp1, Exp2), Store) = elem(E, Bag)

%% Note elem(Tuple, Rel)

%% ---- FUN ( EXP , EXP , EXP)  -> EXP

[default-fun3]
        value(Var, Store) = <Var1, Var2, Var3, Exp4>,
        Val1 = evalx(Exp1, Store),
        Val2 = evalx(Exp2, Store),
        Val3 = evalx(Exp3, Store),

        Store' = assign(Var1, Val1, Store),
	Store'' = assign(Var2, Val2, Store'),
	Store''' = assign(Var3, Val3, Store')
        ==================================================
	evalx(Var(Exp1, Exp2, Exp3), Store) = evalx(Exp4, Store''')

[Fdms]  Rel1 = evalr(Exp1, Store),
        Rel2 = evalr(Exp2, Store),
        Rel3 = evalr(Exp3, Store)
        ================================================= 
        evalx(dominators(Exp1, Exp2, Exp3), Store) = 
        dominators(Rel1, Rel2, Rel3)





