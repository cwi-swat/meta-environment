equations

%%-----------------------------------------------------------------------------------

%% ---- Simplify constant type

[xxx]	fun [] to $Etype = $Etype

%% ---- Simplify tuple of 1 element to element itself
%% ---- Type of element

[to1]	type-of($Integer) = int 
[to2]	type-of($BoolCon) = bool
[to3]	type-of($String)  = str
[to4]	type-of($Area)    = area

%% ---- Element type

[et1]	element-type(bag[$Etype], $Tenv)  = $Etype
[et2]	element-type(rel[$Etype+], $Tenv) = <$Etype+>
[et3]	element-type(<$Etype+>, $Tenv)    = <$Etype+>
[et4]	element-type($Var, $Tenv)         = element-type(lookup($Tenv, $Var), $Tenv)
[default-et]
	element-type($Etype, $Tenv)       = undefined

%% ---- First of type

[ft1]	first(<$Etype1, $Etype*>, $Tenv) = $Etype1

[ft2]	first(<$Etype1 $Var, $DclVar*>, $Tenv) = $Etype1

[ft3]	first($Var, $Tenv) = first(lookup($Tenv, $Var), $Tenv)

[default-ft]
	first($Etype, $Tenv) = $Etype

%% ---- Second of type

[st1]	second(<$Etype1, $Etype+>, $Tenv) = <$Etype+>
[st2]	second(<$Etype1 $Var, $DclVar+>, $Tenv) = <$DclVar+>
[st3]	second($Var, $Tenv) = second(lookup($Tenv, $Var), $Tenv)
[default-st]
	second($Etype, $Tenv) = undefined

%% ---- Normalize type

[nm1]	norm(bag[$Etype], $Tenv) = bag[norm($Etype, $Tenv)]

[nm2]	norm(rel[$Etype+], $Tenv) = bag[norm(<$Etype+>, $Tenv)]

[nm3]	$Etype1' = norm($Etype1, $Tenv),
	<$Etype+'> = norm(<$Etype2, $Etype+>, $Tenv)
	=========================================================
	norm(<$Etype1, $Etype2, $Etype+>, $Tenv) = <$Etype1', $Etype+'>

[nm4]	$Etype1' = norm($Etype1, $Tenv),
	$Etype2' = norm($Etype2, $Tenv)
	=========================================================
	norm(<$Etype1, $Etype2>, $Tenv) = <$Etype1', $Etype2'>

[nm5]	norm(<$DclVar+>, $Tenv) = norm(get-tuple-type(<$DclVar+>), $Tenv)

[nm6]	norm($Var, $Tenv) = norm(lookup($Tenv, $Var), $Tenv)

[default-nm]
	norm($Etype, $Tenv) = $Etype

%% ---- Equality on types: ==

[eqt]	norm($Etype1, $Tenv) = norm($Etype2, $Tenv)
	=====================================================
	equal-type($Etype1, $Etype2, $Tenv) = true

[default-eqt]
	equal-type($Etype1, $Etype2, $Tenv) = false

%% ---- get-tuple-type

[gtt1]	get-tuple-type(<$Etype1 $Var1, $Etype2 $Var2>) = <$Etype1, $Etype2>

[gtt2]	get-tuple-type(<$Etype2 $Var2, $DclVar+>) = <$Etype2, $Etype+>
	=========================================================
	get-tuple-type(<$Etype1 $Var1, $Etype2 $Var2, $DclVar+>) = <$Etype1, $Etype2, $Etype+>

%% ---- Is tuple

[it1]	is-tuple(<$Elem+>) = true
[default-it]
	is-tuple($Elem) = false

%% ---- well-formed-type

[wft1]	well-formed-type(bag[$Etype], $Tenv) = well-formed-type($Etype, $Tenv)

[wft2]	well-formed-type(rel[$Etype+], $Tenv) = well-formed-type(<$Etype+>,$Tenv)

[wft3]	well-formed-type($Etype, $Tenv) = $Tenv',
	well-formed-type(<$Etype+>, $Tenv') = $Tenv''
	========================================================
	well-formed-type(<$Etype, $Etype+>, $Tenv) = $Tenv''

[wft4]	well-formed-type(<$Etype>, $Tenv) = well-formed-type($Etype, $Tenv)

[wft5]	well-formed-type(<$DclVar+>, $Tenv) = well-formed-type(get-tuple-type(<$DclVar+>), $Tenv)

[wft5]	lookup($Tenv, $Var) = not-in-table
	=======================================================
	well-formed-type($Var, $Tenv) = $Tenv + Undeclared $Var

[wft6]	well-formed-type(<$Etype+>, $Tenv) = $Tenv',
	well-formed-type($Etype, $Tenv') = $Tenv''
	======================================================
	well-formed-type(fun [$Etype+] to $Etype, $Tenv) = $Tenv''

[wft6]	lookup($Tenv, $Var) = $Etype
	=======================================================
	well-formed-type($Var, $Tenv) = well-formed-type($Etype, $Tenv)

[default-wft]
	well-formed-type($Etype, $Tenv) = $Tenv


%% ---- If-then-else on type environments

[ite1]	if true then $Tenv1 else $Tenv2 fi = $Tenv1

[ite2]	if false then $Tenv1 else $Tenv2 fi = $Tenv2

%% ---- If-then-else on <Type, TypeEnv>

[ite3]	if true then <$Etype1, $Tenv1> else <$Etype2, $Tenv2> fi = <$Etype1, $Tenv1>

[ite4]	if false then <$Etype1, $Tenv1> else <$Etype2, $Tenv2> fi = <$Etype2, $Tenv2>

%% ---- Add error message

[te1]	<$Table, errors[$Error*]> + $Error = <$Table, errors[$Error*;
$Error]>

%% ---- Errors to ItemList

[i2s]	rvar2str(rvar(Char*)) = strcon(""" Char* """)

[cve-1] convert-errors(errors[$Error+]) = convert-errors1(errors[$Error+])
[cve-1] convert-errors(errors[]) =  [listitem("Rscript is type correct!", area("",0,0,0,0))]


[cve-1] convert-errors1(errors[$Error*]) = [$ListItem*]
      	================================================
        convert-errors1(errors[$Error; $Error*])= [e2i($Error), $ListItem*]

[cve-2] convert-errors1(errors[]) = []

[e2i-1] e2i($Exp cannot be typed)	= listitem("Expression cannot be typed", get-area($Exp))
[e2i-2] e2i($Stat cannot be typed)	= listitem("Statement cannot be typed", get-area($Stat))
[e2i-3] e2i($Gen cannot be typed) 	= listitem("Generator cannot be typed", get-area($Gen))
[e2i-4] e2i($Bag cannot be typed) 	= listitem("Bag cannot be typed", get-area($Bag))
[e2i-5] e2i($Rel cannot be typed) 	= listitem("Relation cannot be typed", get-area($Rel))
[e2i-6] e2i(Undeclared $Var) 		= listitem("Undeclared: " || rvar2str($Var), get-area($Var))
[e2i-7] e2i($Var redeclared) 		= listitem("Redeclared: " || rvar2str($Var), get-area($Var))

[e2i-8]	e2i($Var not initialized in Rstore)
					= listitem("Not initialized in Rstore: " || rvar2str($Var), get-area($Var))

[e2i-9]	e2i($Var conflicting initialization in Rscript and in Rstore)
					= listitem("Conflicting initialization in Rscript and in Rstore: " || rvar2str($Var), get-area($Var))

[e2i-10] e2i(Incompatible argument types $Etype in $Exp) = 
		listitem("Incompatible arguments of type " || t2s($Etype), get-area($Exp))
[e2i-11] e2i($Exp should have type $Etype)= 
	listitem("Expression should have type " || t2s($Etype), get-area($Exp))
[e2i-12] e2i($Exp should be of type bag) = listitem("Expression should be of type bag", get-area($Exp))
[e2i-13] e2i($Exp should be of type rel) = listitem("Expression should be of type relation", get-area($Exp))
[e2i-14] e2i(No definition for $Var with argument $Etype) = 
        listitem("No definition for " || rvar2str($Var) || " with argument " || t2s($Etype), get-area($Var))

[e2i-15] e2i(No definition for field $Var) =  listitem("No definition for " || rvar2str($Var), get-area($Var))
[e2i-16] e2i($Var exceeds number of targets of generator) =  listitem("Destination contains too many targets", get-area($Var))
[e2i-17] e2i(Field name $Var used at different record positions) =
		   listitem("Field " || rvar2str($Var) || " used at different record positions", get-area($Var))

[t2s-1]	t2s(int) 			= "int"
[t2s-2] t2s(bool) 			= "bool"
[t2s-3] t2s(str) 			= "str"
[t2s-4] t2s(area) 			= "area"
[t2s-5] t2s(undefined) 			= "undefined"
[t2s-6] t2s(< $Etype+ >)		= "<" || tl2sl($Etype+) || ">"
[t2s-7] t2s(bag[$Etype])		= "bag[" || t2s($Etype) || "]"
[t2s-8] t2s(rel[$Etype+])		= "rel[" || tl2sl($Etype+) || "]"

[t2s-8] t2s([$Etype*]) 			= "[" || tl2sl($Etype*) || "]"
[t2s-9] t2s($Var) 			= rvar2str($Var)
[t2s-10] t2s(& $Var) 			= "&" || rvar2str($Var)

[tl2sl-1]
	tl2sl($Etype, $Etype+)		= t2s($Etype) || "," || tl2sl($Etype+)
[tl2sl-1]
	tl2sl($Etype)			= t2s($Etype)
[tl2sl-2]
	tl2sl()				= ""

%% ---- Lookup/store/delete

[te2]	lookup(<$Table, $Errors>, $Var) = lookup($Table, $Var)

[te3]	$Tenv' = well-formed-type($Etype, $Tenv),
	$Tenv' = <$Table, $Errors>
	===================================================================
	store($Tenv, $Var, $Etype) = <store($Table, $Var, $Etype), $Errors>

[te4]	delete(<$Table, $Errors>, $Var)  = <delete($Table, $Var), $Errors>

%% ---- Check that variable is not yet defined

[cnd]	check-not-defined($Var, $Tenv) = 
	if equal-type(lookup($Tenv, $Var), not-in-table, $Tenv) then $Tenv else  $Tenv + $Var redeclared fi

%% ---- get index of a field (if any)

%%[gfi1]				%% asfe bug?
%%	values($Table) = [$Etype*1, <$DclVar*1,$Etype $Var, $DclVar*2>, $Etype*2 ]
%%	=========================================================================
%%	get-field-index($Var, <$Table, $Errors>) = 1 + length($DclVar*1)

[gfi1]	%%<$DclVar+> = <$DclVar*1, $Etype $Var, $DclVar*2>
	$Integer = get-field-index1($Var, $DclVar+, 1),
	$Integer > 0 = true
	=================================================================
	get-field-index($Var, [<$DclVar+>, $Etype*]) = $Integer

[default-gfi2]	
	get-field-index($Var, [$Etype, $Etype*]) = get-field-index($Var,  [$Etype*])

[default-gfi]
	get-field-index($Var, []) = 0

[ldcl1]	get-field-index1($Var, $Etype $Var, $DclVar*, $Integer) = $Integer
[default-ldcl1]	
	get-field-index1($Var, $DclVar, $DclVar*, $Integer) = get-field-index1($Var, $DclVar*, $Integer+1)
[ldcl2]	get-field-index1($Var, , $Integer) = 0

%% ---- check-duplicate-fields

[cdf1]	$Tenv = <$Table, $Errors>,
	$Integer' = get-field-index($Var, values($Table)),
	$Tenv' = if $Integer' == 0 | $Integer' == $Integer then $Tenv 
		 else $Tenv + Field name $Var used at different record positions
		 fi
	===============================================
	check-duplicate-fields($Etype $Var, $DclVar*, $Integer, $Tenv) =
	check-duplicate-fields($DclVar*, $Integer+1, $Tenv')

[cdf2]	check-duplicate-fields(, $Integer, $Tenv) = $Tenv

%% ---- get-field-type

[gft0]	$Etype = lookup($Tenv, $Var1)
	=============================================
	get-field-type($Var1, $Var2, $Tenv) = get-field-type($Etype, $Var2, $Tenv)

[gft1]	get-field-type(<$Etype $Var, $DclVar*>, $Var, $Tenv) = <$Etype, $Tenv>

[gft2]	$Var1 != $Var2
	=============================================
	get-field-type(<$Etype $Var1, $DclVar*>, $Var2, $Tenv) = 
	get-field-type(<$DclVar*>, $Var2, $Tenv)

[gft3]	get-field-type(< > , $Var, $Tenv) = <undefined, $Tenv + No definition for field $Var>

[rt1] 	check($Exp, $Tenv) = <$Etype', $Tenv'>
      	=========================================
      	require-type($Exp, $Etype, $Tenv) = 
      	if equal-type($Etype, $Etype', $Tenv') then $Tenv' else $Tenv' + $Exp
      	should have type $Etype fi

[rt2]	require-type($Exp1, $Etype1, $Tenv) = $Tenv',
	require-type($Exp2, $Etype2, $Tenv') = $Tenv''
	==============================================================	
	require-type2($Exp1, $Etype1, $Exp2, $Etype2, $Tenv) = $Tenv''

%%-----------------------------------------------------------------------------------

[check-const-tuple1] 
      	check-const($Elem1, $Tenv) = <$Etype1, $Tenv'>, 
      	check-const($Elem2, $Tenv') = <$Etype2, $Tenv''>
    	============================================
     	check-const-tuple(<$Elem1, $Elem2>, $Tenv) = <<$Etype1, $Etype2>, $Tenv''>

[check-const-tuple2] 
      	check-const($Elem1, $Tenv) = <$Etype1, $Tenv'>, 
      	check-const-tuple(<$Elem2, $Elem+>, $Tenv') = <<$Etype+>, $Tenv''>
    	============================================
     	check-const-tuple(<$Elem1, $Elem2, $Elem+>, $Tenv) = <<$Etype1, $Etype+>, $Tenv''>

%% ---- Check Elementary values

[check-const-bool] 
	check-const($BoolCon, $Tenv) = <type-of($BoolCon), $Tenv>

[check-const-int] 
	check-const($Integer, $Tenv) = <type-of($Integer), $Tenv>

[check-const-str]
	check-const($String, $Tenv) = <type-of($String), $Tenv>

[check-const-area]
	check-const($Area, $Tenv) = <type-of($Area), $Tenv>

[check-const-tuple1]
	check-const(<$Elem+>, $Tenv) = check-const-tuple(<$Elem+>, $Tenv)

[check-const-bag1]
	check-const($Bag, $Tenv) = check-const-bag-or-rel(mk-iterator($Bag),$Tenv)


[check-const-br1]
	is-tuple($Elem) = false,
	check-const($Elem, $Tenv) = <$Etype, $Tenv'>,
	$Etype' = bag[$Etype],
	check-const-bag-or-rel({ $Elem+ }, $Tenv') = <$Etype', $Tenv''>
	==========================================
	check-const-bag-or-rel({ $Elem, $Elem+ }, $Tenv) = <$Etype', $Tenv''>

%%[check-const-br1]
%%	is-empty-iter($BagIter) = false,
%%	$BagIter' = tail($BagIter),
%%	is-empty-iter($BagIter') = false,
%%	$Elem = head($BagIter),
%%      	is-tuple($Elem) = false,
%%       	check-const($Elem, $Tenv) = <$Etype, $Tenv'>,
%%       	$Etype' = bag[$Etype],
%%       	check-const-bag-or-rel($BagIter', $Tenv') = <$Etype', $Tenv''>
%%       	==========================================
%%       	check-const-bag-or-rel($BagIter, $Tenv) = <$Etype', $Tenv''>

[check-const-br2] 
	is-tuple($Elem) = false,
	check-const($Elem, $Tenv) = <$Etype, $Tenv'>,
	$Etype' =  bag[$Etype]
	==========================================
	check-const-bag-or-rel({ $Elem }, $Tenv) = <$Etype', $Tenv'>

%%[check-const-br2]
%%	is-empty-iter($BagIter) = false,
%%	$BagIter' = tail($BagIter),
%%%%	is-empty-iter($BagIter') = true,
%%	is-tuple($Elem) = false,
%%       	check-const($Elem, $Tenv) = <$Etype, $Tenv'>,
%%       	$Etype' =  bag[$Etype]
%%       	==========================================
%%       	check-const-bag-or-rel($BagIter, $Tenv) = <$Etype', $Tenv'>	

[check-const-br31]
	is-tuple($Elem) = true,   
	check-const-tuple($Elem, $Tenv) = <<$Etype+>, $Tenv'>, 
	$Etype = rel[$Etype+],
	check-const-bag-or-rel({ $Elem+ }, $Tenv') = <$Etype, $Tenv''>
	==========================================
	check-const-bag-or-rel({ $Elem, $Elem+ }, $Tenv) = <$Etype,$Tenv''>

%%[check-const-br31]	
%%	is-empty-iter($BagIter) = false,
%%	$BagIter' = tail($BagIter),
%%	is-empty-iter($BagIter') = false,
%%	$Elem = head($BagIter),
%%	is-tuple($Elem) = true,   
%%	check-const-tuple($Elem, $Tenv) = <<$Etype1, $Etype2>, $Tenv'>, 
%%	$Etype = rel[$Etype1,$Etype2],
%%      	check-const-bag-or-rel($BagIter', $Tenv') = <$Etype, $Tenv''>
%%      	==========================================
%%      	check-const-bag-or-rel($BagIter, $Tenv) = <$Etype, $Tenv''>

[check-const-br4]
	is-tuple($Elem) = true, 
	check-const-tuple($Elem, $Tenv) = <<$Etype+>, $Tenv'>, 
	$Etype = rel[$Etype+]
       ==========================================
       check-const-bag-or-rel({ $Elem }, $Tenv) = <$Etype, $Tenv'>

%%[check-const-br4]
%%	is-empty-iter($BagIter) = false,
%%	$BagIter' = tail($BagIter),
%%	is-empty-iter($BagIter') = true,
%%	$Elem = head($BagIter),
%%	is-tuple($Elem) = true, 
%%	check-const-tuple($Elem, $Tenv) = <<$Etype1, $Etype2>, $Tenv'>, 
%%	$Etype = rel[$Etype1,$Etype2]
%%       ==========================================
%%       check-const-bag-or-rel($BagIter, $Tenv) = <$Etype, $Tenv'>

%%-----------------------------------------------------------------------------------

%% ---- Check arbitrary expressions

[check-const1]
	check($Elem, $Tenv) = check-const($Elem, $Tenv)

[check-var] 
	lookup($Tenv, $Var) = $Etype
	============================================
	check($Var, $Tenv) = 
	if equal-type($Etype, not-in-table, $Tenv) then <undefined, $Tenv + Undeclared $Var> else <$Etype, $Tenv> fi

[check-tuple-const]
 	check($Tuple, $Tenv) = check-const-tuple($Tuple, $Tenv)	

[check-tuple-exp1] 
      	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
      	check(<$Exp2, $Exp+>, $Tenv') = <<$Etype+>, $Tenv''>
      	============================================
      	check(<$Exp1, $Exp2, $Exp+>, $Tenv) = <<$Etype1, $Etype+>, $Tenv''>

[check-tuple-exp2] 
     	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
      	check($Exp2, $Tenv') = <$Etype2, $Tenv''>
      	============================================
      	check(<$Exp1, $Exp2>, $Tenv) = <<$Etype1, $Etype2>, $Tenv''>

[ct1]	container-type(<$Etype+>) = rel[$Etype+]
[default-ct2] 
	container-type($Etype) = bag[$Etype]

%% ---- Check bag/relation  expressions

[check-bag-rel1] 
	check($Exp, $Tenv) = <$Etype, $Tenv'>,
	$Etype' =  container-type($Etype),
	check({ $Exp+ }, $Tenv') = <$Etype', $Tenv''>
	==========================================
	check({ $Exp, $Exp+ }, $Tenv) = <$Etype', $Tenv''>

[check-bag-rel2] 
	check($Exp, $Tenv) = <$Etype, $Tenv'>,
	$Etype' =  container-type($Etype)
	==========================================
	check({ $Exp }, $Tenv) = <$Etype', $Tenv'>

[check-bag-rel3]
	check( {}, $Tenv) =  <undefined, $Tenv + {} cannot be typed>

[default-bag-rel]
	check({ $Exp* }, $Tenv) = <undefined, $Tenv + {$Exp*} cannot be typed>

%% ---- Check Operators

%% ---- Boolean operators

[check-and]
      	require-type2($Exp1, bool, $Exp2, bool, $Tenv) = $Tenv'
      	================================================================
      	check($Exp1 and $Exp2, $Tenv) = <bool, $Tenv'>

[check-or]
      	require-type2($Exp1, bool, $Exp2, bool, $Tenv) = $Tenv'
      	================================================================
      	check($Exp1 or $Exp2, $Tenv) = <bool, $Tenv'>

[check-implies]
      	require-type2($Exp1, bool, $Exp2, bool, $Tenv) = $Tenv'
      	================================================================
      	check($Exp1 implies $Exp2, $Tenv) = <bool, $Tenv'>

[check-not] 
      	require-type($Exp, bool, $Tenv) = $Tenv'
      	===========================================
      	check(not $Exp, $Tenv) = <bool, $Tenv'>

[check-in]
	check($Exp1, $Tenv) = <$Etype1, $Tenv'>,
	require-type($Exp2, bag[$Etype1], $Tenv') = $Tenv''
	===================================================
	check($Exp1 in $Exp2, $Tenv) = <bool, $Tenv''>

[check-notin]
	check($Exp1, $Tenv) = <$Etype1, $Tenv'>,
	require-type($Exp2, bag[$Etype1], $Tenv') = $Tenv''
	===================================================
	check($Exp1 notin $Exp2, $Tenv) = <bool, $Tenv''>

%% ---- Comparison operators

%% ---- equal and notequal

[check-eq] 
      	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
	require-type($Exp2, $Etype1, $Tenv') = $Tenv''
      	===========================================
      	check($Exp1 == $Exp2, $Tenv) = <bool, $Tenv''>
[check-ne] 
      	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
	require-type($Exp2, $Etype1, $Tenv') = $Tenv''
      	===========================================
      	check($Exp1 != $Exp2, $Tenv) = <bool, $Tenv''>

%% ---- compatibility for other comparison operators

[compat-cmp1]
	compat-cmp($Exp, bag[$Etype], bag[$Etype], $Tenv) = $Tenv
[compat-cmp2]
	compat-cmp($Exp, int, int, $Tenv) = $Tenv
[compat-cmp3]
	compat-cmp($Exp, str, str, $Tenv) = $Tenv
[compat-cmp4]
	compat-cmp($Exp, area, area, $Tenv) = $Tenv
[compat-cmp5]
	compat-cmp($Exp, $Etype1, $Etype2, $Tenv) = 
	$Tenv + Incompatible argument types [$Etype1, $Etype2] in $Exp

[check-cmp1]
	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
      	check($Exp2, $Tenv') = <$Etype2, $Tenv''>,
	compat-cmp($Exp, norm($Etype1,$Tenv), norm($Etype2, $Tenv), $Tenv'') = $Tenv'''
	===============================================
	check-cmp($Exp, $Exp1, $Exp2, $Tenv) = <bool, $Tenv'''>

[check-le] 
      $Exp = $Exp1 <= $Exp2
      ===========================================
      check($Exp, $Tenv) = check-cmp($Exp, $Exp1, $Exp2, $Tenv)

[check-lt] 
      $Exp = $Exp1 < $Exp2
      ===========================================
      check($Exp, $Tenv) = check-cmp($Exp, $Exp1, $Exp2, $Tenv)

[check-ge] 
      $Exp = $Exp1 >= $Exp2
      ===========================================
      check($Exp, $Tenv) = check-cmp($Exp, $Exp1, $Exp2, $Tenv)

[check-gt] 
      $Exp = $Exp1 > $Exp2
      ===========================================
      check($Exp, $Tenv) = check-cmp($Exp, $Exp1, $Exp2, $Tenv)

%% ---- Integers operators

[check-int1]
	require-type($Exp1, int, $Tenv) = $Tenv',
	require-type($Exp2, int, $Tenv') = $Tenv''
	=========================================
	check-int($Exp, $Exp1, $Exp2, $Tenv) = <int, $Tenv''>

[check-add1]
 	$Exp = $Exp1 + $Exp2
      	===========================================
      	check($Exp, $Tenv) = check-int($Exp, $Exp1, $Exp2, $Tenv)

[check-sub1]
 	$Exp = $Exp1 - $Exp2
      	===========================================
      	check($Exp, $Tenv) = check-int($Exp, $Exp1, $Exp2, $Tenv)
	
[check-mul1]
 	$Exp = $Exp1 * $Exp2
      	===========================================
      	check($Exp, $Tenv) = check-int($Exp, $Exp1, $Exp2, $Tenv)

[check-div1]
 	$Exp = $Exp1 / $Exp2
      	===========================================
      	check($Exp, $Tenv) = check-int($Exp, $Exp1, $Exp2, $Tenv)

%% --- Union-like operators

[compat-un1] 
	compat-un($Exp, bag[$Etype], bag[$Etype], $Tenv) = <bag[$Etype], $Tenv>
[default-compat-un]
	compat-un($Exp, $Etype1, $Etype2, $Tenv) = 
	<undefined, $Tenv + Incompatible argument types [$Etype1, $Etype2] in $Exp>  

[check-un1]
	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
      	check($Exp2, $Tenv') = <$Etype2, $Tenv''>,
	compat-un($Exp, norm($Etype1,$Tenv), norm($Etype2,$Tenv), $Tenv'') = <$Etype, $Tenv'''>
	===============================================
	check-un($Exp, $Exp1, $Exp2, $Tenv) = <$Etype, $Tenv'''>
	
[check-union]
	$Exp = $Exp1 union $Exp2
	===========================================
	check($Exp, $Tenv) = check-un($Exp, $Exp1, $Exp2, $Tenv)

[check-inter]
	$Exp = $Exp1 inter $Exp2
	===========================================
	check($Exp, $Tenv) = check-un($Exp, $Exp1, $Exp2, $Tenv)

[check-diff]
	$Exp = $Exp1 \ $Exp2
	===========================================
	check($Exp, $Tenv) = check-un($Exp, $Exp1, $Exp2, $Tenv)

%% --- Composition

[compat-comp1] 
	compat-comp($Exp, bag[<$Etype1,$Etype2>], bag[<$Etype2,$Etype3>], $Tenv) = <rel[$Etype1,$Etype3], $Tenv>
[default-compat-comp]
	compat-comp($Exp, $Etype1, $Etype2, $Tenv) = 
	<undefined, $Tenv + Incompatible argument types [$Etype1, $Etype2] in $Exp>  

[c03] $Exp = $Exp1 o $Exp2,
      check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
      check($Exp2, $Tenv') = <$Etype2, $Tenv''>,
      compat-comp($Exp, norm($Etype1,$Tenv), norm($Etype2,$Tenv), $Tenv'') = <$Etype3, $Tenv'''>
      ===================================================================
      check($Exp, $Tenv) = <$Etype3, $Tenv'''>

%% -- Product

[compat-prod1] 
	compat-prod($Exp, bag[$Etype1], bag[$Etype2], $Tenv) = <rel[$Etype1,$Etype2], $Tenv>

[default-compat-prod]
	compat-prod($Exp, $Etype1, $Etype2, $Tenv) = 
	<undefined, $Tenv + Incompatible argument types [$Etype1, $Etype2] in $Exp>  

[check-product] 
	$Exp = $Exp1 x $Exp2,
      	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
      	check($Exp2, $Tenv') = <$Etype2, $Tenv''>,
      	compat-prod($Exp, norm($Etype1,$Tenv), norm($Etype2,$Tenv), $Tenv'') = <$Etype3, $Tenv'''>
      ===========================================
      	check($Exp, $Tenv) = <$Etype3, $Tenv'''>

%% ---- Image

[clm1]	compat-lim($Exp, bag[<$Etype1,$Etype2>], $Etype2, $Tenv) = <bag[$Etype1], $Tenv>
[clm2]  compat-lim($Exp, bag[<$Etype1,$Etype2>], bag[$Etype2], $Tenv) = <bag[$Etype1], $Tenv>
[default-clm]
	compat-lim($Exp, $Etype1, $Etype2, $Tenv) = 
	<undefined, $Tenv + Incompatible argument types [$Etype1, $Etype2] in $Exp>  

[crm1]	compat-rim($Exp, bag[<$Etype1,$Etype2>], $Etype1, $Tenv) = <bag[$Etype2], $Tenv>
[crm2]	compat-rim($Exp, bag[<$Etype1,$Etype2>], bag[$Etype1], $Tenv) = <bag[$Etype2], $Tenv>

[default-compat-rim]
	compat-rim($Exp, $Etype1, $Etype2, $Tenv) = 
	<undefined, $Tenv + Incompatible argument types [$Etype1, $Etype2] in $Exp>  

[check-im1] 	
	$Exp = $Exp1 [ -, $Exp2],
      	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
      	check($Exp2, $Tenv') = <$Etype2, $Tenv''>,
      	compat-lim($Exp, norm($Etype1, $Tenv), norm($Etype2, $Tenv), $Tenv'') = <$Etype3, $Tenv'''>
      	===========================================
      	check($Exp, $Tenv) = <$Etype3, $Tenv'''>

[check-im2]
	$Exp = $Exp1 [ $Exp2, - ],
      	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
      	check($Exp2, $Tenv') = <$Etype2, $Tenv''>,
      	compat-rim($Exp, norm($Etype1,$Tenv), norm($Etype2,$Tenv), $Tenv'') = <$Etype3, $Tenv'''>
      	===========================================
	check($Exp, $Tenv) = <$Etype3, $Tenv'''>

[check-im3]
	$Exp = $Exp1 [ $Exp2 ],
      	check($Exp1, $Tenv) = <$Etype1, $Tenv'>, 
      	check($Exp2, $Tenv') = <$Etype2, $Tenv''>,
      	compat-rim($Exp, norm($Etype1,$Tenv), norm($Etype2,$Tenv), $Tenv'') = <$Etype3, $Tenv'''>
      	===========================================
	check($Exp, $Tenv) = <$Etype3, $Tenv'''>

%% ---- field selection

[check-sel]
	$Exp = $Exp1 . $Var,
	check($Exp1, $Tenv) = <$Etype1, $Tenv'>,
	get-field-type($Etype1, $Var, $Tenv') = <$Etype2, $Tenv''>
	===========================================
	check($Exp, $Tenv) = <$Etype2, $Tenv''>

%% --- Transitive closure

[compat-trans1]
	compat-trans($Exp, bag[<$Etype,$Etype>], $Tenv) = <rel[$Etype, $Etype], $Tenv>
[default-compat-trans]
	compat-trans($Exp, $Etype, $Tenv) = 
	<undefined, $Tenv + Incompatible argument types $Etype in $Exp>  
 
[check-closure] 
	$Exp = $Exp1 +,
      	check($Exp1, $Tenv) = <$Etype, $Tenv'>,
      	compat-trans($Exp, norm($Etype,$Tenv), $Tenv') = <$Etype1, $Tenv''>
      	===========================================
      	check($Exp, $Tenv) = <$Etype1, $Tenv''>

[check-rclosure]
	$Exp = $Exp1 *,
      	check($Exp1, $Tenv) = <$Etype, $Tenv'>,
      	compat-trans($Exp, norm($Etype,$Tenv), $Tenv') = <$Etype1, $Tenv''>
      	===========================================
      	check($Exp, $Tenv) = <$Etype1, $Tenv''>

%% --- size

[compat-size1]
	compat-size($Exp, bag[$Etype], $Tenv) = <int, $Tenv>
[default-compat-size]
	compat-size($Exp, $Etype, $Tenv) = 
	<undefined, $Tenv + Incompatible argument types $Etype in $Exp>  
 
[check-size]
	$Exp = #  $Exp1,
      	check($Exp1, $Tenv) = <$Etype, $Tenv'>,
      	compat-size($Exp, norm($Etype,$Tenv), $Tenv') = <$Etype1, $Tenv''>
      	===========================================
      	check($Exp, $Tenv) = <$Etype1, $Tenv''>

%% --- end of checking operators

%% --- Check comprehensions
	
%% ---- Check generators and add introduced variables to type environment

[ag1] 	require-type($Exp, bag[$Etype], $Tenv) = $Tenv',
      	store($Tenv', $Var, $Etype) = $Tenv'',
      	==========================================
      	add-generators($Etype $Var : $Exp, $Gen*, $Tenv) = add-generators($Gen*, $Tenv'')

[ag2] 	check($Exp, $Tenv) = <$Etype, $Tenv'>, 
      	match-targets($Target+, element-type($Etype, $Tenv), $Tenv') = $Tenv''	
      	==========================================
      	add-generators(<$Target+> : $Exp, $Gen*, $Tenv) = add-generators($Gen*, $Tenv'')

[ag3] 	require-type($Exp, bool, $Tenv) = $Tenv'
      	==========================================
      	add-generators($Exp, $Gen*, $Tenv) = add-generators($Gen*, $Tenv')

[ag4] 	check($Exp, $Tenv) = <$Etype, $Tenv'>, 
	match-targets($Target, element-type($Etype, $Tenv), $Tenv') = $Tenv''
      	==========================================
      	add-generators($Target <- $Exp, $Gen*, $Tenv) = add-generators($Gen*, $Tenv'')

[ag5] 	check($Exp, $Tenv) = <$Etype, $Tenv'>, 
	match-targets($Target+, element-type($Etype, $Tenv), $Tenv') = $Tenv''
      	==========================================
      	add-generators(<$Target+> <- $Exp, $Gen*, $Tenv) = add-generators($Gen*, $Tenv'')

[ag6] 	add-generators( , $Tenv) = $Tenv

[default-af]
      	add-generators($Gen, $Gen*, $Tenv) = $Tenv + $Gen cannot be typed

%% ---- Match a list of targets

[mt1]	equal-type($Etype1, first($Etype2, $Tenv), $Tenv) = true,
	store($Tenv, $Var, $Etype1) = $Tenv'
	=====================================================
	match-targets($Etype1 $Var, $Target*, $Etype2, $Tenv) =
	match-targets($Target*, second($Etype2,$Tenv), $Tenv')

[mt2]	equal-type($Etype1, first($Etype2, $Tenv), $Tenv) = false,
	first($Etype2, $Tenv) != undefined	
	=====================================================
	match-targets($Etype1 $Var, $Target*, $Etype2, $Tenv) =
	match-targets($Target*, second($Etype2, $Tenv), $Tenv + $Var should have type
	first($Etype2, $Tenv))

[mt3]	equal-type($Etype1, first($Etype2, $Tenv), $Tenv) = false,
	first($Etype2, $Tenv) = undefined	
	=====================================================
	match-targets($Etype1 $Var, $Target*, $Etype2, $Tenv) =
	match-targets($Target*, second($Etype2, $Tenv), $Tenv + $Var exceeds number of targets of generator)

[mt4]	require-type($Exp, first($Etype, $Tenv), $Tenv) = $Tenv'
	=====================================================
	match-targets($Exp, $Target*, $Etype, $Tenv) =
	match-targets($Target*, second($Etype, $Tenv), $Tenv')

[mt5]	match-targets( , $Etype, $Tenv) = $Tenv

%% ---  Delete a list of targets from the type environment

[dt1]	delete($Tenv, $Var) = $Tenv'
	=========================================
	delete-targets($Etype $Var, $Target*, $Tenv) = delete-targets($Target*, $Tenv')

[dt2]	delete-targets($Exp, $Target*, $Tenv) = delete-targets($Target*, $Tenv)

[dt3]	delete-targets( , $Tenv) = $Tenv

%% Delete the variables introduced in from clauses from the type environment

[dg1] 	delete-targets($Target, $Tenv) = $Tenv'
      	==========================================
      	del-generators($Target : $Exp, $Gen*, $Tenv) = del-generators($Gen*, $Tenv')

[dg2] 	delete-targets($Target1, $Target+, $Tenv) = $Tenv'
      	==========================================
      	del-generators(<$Target1, $Target+> : $Exp, $Gen*, $Tenv) = del-generators($Gen*, $Tenv')

[dg3]	del-generators($Exp, $Gen*, $Tenv) = del-generators($Gen*, $Tenv)

[df4]	delete-targets($Target, $Tenv) = $Tenv'
	=================================================================
	del-generators($Target <- $Exp, $Gen*, $Tenv) = del-generators($Gen*, $Tenv')

[df5]	delete-targets($Target1, $Target+, $Tenv) = $Tenv'
	=================================================================
	del-generators(<$Target1, $Target+> <- $Exp, $Gen*, $Tenv) = del-generators($Gen*, $Tenv')

[df6] 	del-generators( , $Tenv) = $Tenv

%% ---- Check comprehensions

[check-comprehension] 
      	add-generators($Gen+, $Tenv) = $Tenv',
      	check({$Exp+}, $Tenv') = <$Etype, $Tenv''>,
      	del-generators($Gen+, $Tenv'') = $Tenv'''
      	======================================
      	check({ $Exp+ | $Gen+ }, $Tenv) = <$Etype, $Tenv'''>

%% --- Check Exists

[check-exists1]
	add-generators($SimpleGen, $Tenv) = $Tenv',
	require-type($Test, bool, $Tenv') = $Tenv'',
	del-generators($SimpleGen, $Tenv'') = $Tenv'''
	=====================================
	check(exists($SimpleGen | $Test), $Tenv) = <bool, $Tenv'''>

%% --- Check Forall

[check-forall1]
	add-generators($SimpleGen, $Tenv) = $Tenv',
	require-type($Test, bool, $Tenv') = $Tenv'',
	del-generators($SimpleGen, $Tenv'') = $Tenv'''
	=====================================
	check(forall($SimpleGen | $Test), $Tenv) = <bool, $Tenv'''>

%% ---- Function applications

%% ---- collect-actuals

[ca1]	check($Exp, $Tenv) = <$Etype, $Tenv'>,
	collect-actuals($Exp*, $Tenv') = < [$Etype*], $Tenv''>
	===========================================
	collect-actuals($Exp, $Exp*, $Tenv) = <[$Etype, $Etype*], $Tenv''>

[ca2]	collect-actuals( , $Tenv) = <[], $Tenv>

%% ---- Check function application

[check-appl] 
	collect-actuals($Exp*, $Tenv) = <$Etype, $Tenv'>
	============================================
	check($Var ( $Exp* ), $Tenv) = find-result-type($Var, $Etype, $Tenv')

%% ---- add-formals

[af1]	check-not-defined($Var, $Tenv) = $Tenv',
	store($Tenv', $Var, $Etype) = $Tenv'',
	add-formals([$DclVar*], $Tenv'') = $Tenv'''
	===========================================
	add-formals([$Etype $Var, $DclVar*], $Tenv) = $Tenv'''

[af2] add-formals([], $Tenv) = $Tenv

%% ---- del-formals

[df1]	delete($Tenv, $Var) = $Tenv',
	del-formals([$DclVar*], $Tenv') = $Tenv''
	===========================================
	del-formals([$Etype $Var, $DclVar*], $Tenv) = $Tenv''

[df2]	del-formals([], $Tenv) = $Tenv

%% Extract the types from a list of formal parameters

[et1]	extract-types([$DclVar*]) = [$Etype*]
	===========================================
	extract-types([$Etype $Var, $DclVar*]) = [$Etype, $Etype*]

[et2] extract-types([]) = []

%% ---- Check variable declarations

[check-vardef1]
	check-stat($Etype $Var, $Tenv) = store($Tenv, $Var, $Etype)

[check-vardef2] 
	check-stat($Etype $Var = $Exp, $Tenv) =  check-stat($Etype $Var() = $Exp, $Tenv)

[check-vardef3]
	check-stat(bag[$Etype] $Var = {}, $Tenv) = store($Tenv, $Var, bag[$Etype])

[check-vardef4]
	check-stat(rel[$Etype1,$Etype2] $Var = {}, $Tenv) = store($Tenv, $Var, rel[$Etype1,$Etype2])

%% ---- Check function declarations

[check-fundef] 
	check-not-defined($Var, $Tenv) = $Tenv1,
	add-formals([$DclVar*], $Tenv1) = $Tenv2,
	require-type($Exp, $Etype, $Tenv2) = $Tenv3,      
	del-formals([$DclVar*], $Tenv3) = $Tenv4, 
	store($Tenv4, $Var, fun extract-types([$DclVar*]) to $Etype) = $Tenv5 
	===========================================
	check-stat($Etype $Var ($DclVar*) = $Exp, $Tenv) = $Tenv5

%% ---- Check type declarations

[check-typedef1]
	check-not-defined($Var, $Tenv) = $Tenv',
	check-duplicate-fields($DclVar+, 1, $Tenv') =  $Tenv''
	=============================================
	check-stat(type $Var = < $DclVar+ >, $Tenv) = store($Tenv'', $Var, <$DclVar+ >)

[check-typedef1]
	check-not-defined($Var, $Tenv) = $Tenv'
	=============================================
	check-stat(type $Var = $Etype, $Tenv) = store($Tenv', $Var, $Etype)

%% ---- Check assert statement

[check-assert]
	check-stat(assert $String : $Exp, $Tenv) = require-type($Exp, bool, $Tenv)

%% ---- Check yield statement

[check-yield]
	check($Var, $Tenv) = <$Etype, $Tenv'>
	===============================================
	check-stat(yield $Var, $Tenv) =  $Tenv'

%% ---- Check set of equations

[CEQ1]	check-stat(equations (limit $Integer) initial $InitVar+ satisfy  $Eq+ end equations, $Tenv) = 
	check-eqs($InitVar+, $Eq+, $Tenv)

[CEQ2]	check-stat(equations initial $InitVar+ satisfy  $Eq+ end equations, $Tenv) = 
	check-eqs($InitVar+, $Eq+, $Tenv)

[CEQS1]	check-stat($Etype $Var = $Exp, $Tenv) = $Tenv1
	===============================================	
	check-eqs($Etype $Var init $Exp $InitVar*, $Eq+, $Tenv) =
	check-eqs($InitVar*, $Eq+, $Tenv1)

[CEQS2]	check($Var, $Tenv) = <$Etype, $Tenv1>,
        require-type($Exp, $Etype, $Tenv1) = $Tenv2
        =========================================
	check-eqs( , $Var = $Exp $Eq*, $Tenv) = check-eqs( , $Eq*, $Tenv2)

[CEQS2]	check-eqs( , , $Tenv) = $Tenv

%% ---- Default case for check-stat

[default-check-stat]
	check-stat($Stat, $Tenv) = $Tenv +  $Stat cannot be typed

%% ---- Default case for check

[default-check]
	check($Exp, $Tenv) = <undefined, $Tenv +  $Exp cannot be typed>

%% ---- Find result type of a function, given list of argument types

[frt1]	lookup($Tenv, $Var) = not-in-table
	==================================
	find-result-type($Var, [$Etype*], $Tenv) = <undefined, $Tenv + Undeclared $Var>

[frt2]	lookup($Tenv, $Var) = fun [$Etype*2] to $Etype,
	match-types([$Etype*2],  [$Etype*1], new-table, $Tenv) = <true, $Table>
	===========================================
	find-result-type($Var, [$Etype*1], $Tenv) = substitute($Etype, $Table, $Tenv)

[default-frt]
	find-result-type($Var, [$Etype*1], $Tenv) = <undefined, $Tenv + No definition for $Var with argument [$Etype*1]>

%% ---- is-var 

[iv1]	is-var(& $Var) = true
[default-iv] 
	is-var($Etype) = false

%% ---- match types

[mt1]	equal-type($Etype, $Etype', $Tenv) = true
	================================================
	match-types($Etype, $Etype', $Table, $Tenv) = <true, $Table>

[mt2]	lookup($Table, $Var) = not-in-table
	================================================
	match-types(& $Var, $Etype, $Table, $Tenv) = <true, store($Table, $Var, $Etype)>

[mt3]	equal-type(lookup($Table, $Var), $Etype, $Tenv) = true
	================================================
	match-types(& $Var, $Etype, $Table, $Tenv) = <true, $Table>

[mt4]	match-types($Etype1, $Etype2, $Table, $Tenv) = <true, $Table'>
	===================================================
	match-types(bag[$Etype1], bag[$Etype2], $Table, $Tenv) =  <true, $Table'>

[mt5]	match-types(rel[$Etype+], $Etype, $Table, $Tenv) = match-types(bag[<$Etype+>], $Etype, $Table, $Tenv)

[mt6]	match-types($Etype, rel[$Etype+], $Table, $Tenv) = match-types($Etype, bag[<$Etype+>], $Table, $Tenv)

[mt7]	match-types(<$Etype+>, <$Etype+'>, $Table, $Tenv) = <true, $Table'>
	===================================================
	match-types(bag[<$Etype+>], bag[<$Etype+'>], $Table, $Tenv) =  <true, $Table'>

[mt8]	match-types($Etype1, $Etype1', $Table, $Tenv) = <true, $Table'>,
	match-types(<$Etype2, $Etype+>, <$Etype2', $Etype+'>, $Table', $Tenv) = <true, $Table''>
	=========================================================
	match-types(<$Etype1, $Etype2, $Etype+>, <$Etype1', $Etype2', $Etype+'>, $Table, $Tenv) = <true, $Table''>

[mt9]	match-types($Etype1, $Etype1', $Table, $Tenv) = <true, $Table'>,
	match-types($Etype2, $Etype2', $Table', $Tenv) = <true, $Table''>
	===================================================
	match-types(<$Etype1, $Etype2>, <$Etype1', $Etype2'>, $Table, $Tenv) =  <true, $Table''>

[mt10]	match-types($Etype1, $Etype1', $Table, $Tenv) = <true, $Table'>,
	match-types([$Etype*], [$Etype*'], $Table', $Tenv) = <true, $Table''>
	===================================================
	match-types([$Etype1, $Etype*], [$Etype1', $Etype*'], $Table, $Tenv) = <true, $Table''>

[mt11]  match-types([], [], $Table, $Tenv) = <true, $Table>

[default-mt]
	match-types($Etype1, $Etype2, $Table, $Tenv) = <false, $Table>

%% ---- Substitute type

[sb1]	$Etype = lookup($Table, $Var)
	======================================================
	substitute(& $Var, $Table, $Tenv) = 
	if equal-type($Etype, not-in-table, $Tenv) then <undefined, $Tenv + Undeclared $Var>
						   else <$Etype, $Tenv> fi

[sb2]   substitute($Etype, $Table, $Tenv) = <$Etype', $Tenv'>
	======================================================
	substitute(bag[$Etype], $Table, $Tenv) = <bag[$Etype'], $Tenv>

[sb3]	substitute(<$Etype+>, $Table, $Tenv) = <<$Etype+'>, $Tenv'>
	=======================================================
	substitute(rel[$Etype+], $Table, $Tenv) = <rel[$Etype+'], $Tenv'>

[sb4]	substitute($Etype1, $Table, $Tenv) = <$Etype1', $Tenv'>,
	substitute($Etype2, $Table, $Tenv) = <$Etype2', $Tenv''>
	=======================================================
	substitute(<$Etype1,$Etype2>, $Table, $Tenv) = <<$Etype1', $Etype2'>, $Tenv''>

[sb5]	substitute($Etype1, $Table, $Tenv) = <$Etype1', $Tenv'>,
	substitute(<$Etype2, $Etype+>, $Table, $Tenv') = <<$Etype+'>, $Tenv''>
	=========================================================
	substitute(<$Etype1, $Etype2, $Etype+>, $Table, $Tenv) = <<$Etype1', $Etype+'>, $Tenv''>

[default-sb]
	substitute($Etype, $Table, $Tenv) = <$Etype, $Tenv>

%% ---- The types of the built-in functions

[bi-1]  built-ins = [
		<id,      	fun [ bag[&T] ] 			to rel[&T,&T]>,
      		<domain,  	fun [ rel[&T1,&T2] ] 			to bag[&T1]>,
     		<range,   	fun [ rel[&T1,&T2] ] 			to bag[&T2]>,
       		<carrier, 	fun [ rel[&T,&T] ] 			to bag[&T]>,
		<top,     	fun [ rel[&T,&T] ] 			to bag[&T]>,
		<bottom,  	fun [ rel[&T,&T] ] 			to bag[&T]>,
       		<inv,     	fun [ rel[&T1,&T2] ] 			to rel[&T2,&T1]>,
		<compl,   	fun [ rel[&T1, &T2] ] 			to rel[&T1,&T2]>,

       		<domainR, 	fun [ rel[&T1,&T2], bag[&T1] ]		to rel[&T1,&T2]>,
       		<rangeR,    	fun [ rel[&T1,&T2], bag[&T2] ] 		to rel[&T1,&T2]>,
       		<carrierR,    	fun [ rel[&T,&T], bag[&T] ] 		to rel[&T,&T]>,

       		<domainX,    	fun [ rel[&T1,&T2], bag[&T1] ] 		to rel[&T1,&T2]>,
       		<rangeX,    	fun [ rel[&T1,&T2], bag[&T2] ] 		to rel[&T1,&T2]>,
       		<carrierX,    	fun [	rel[&T,&T], bag[&T] ] 		to rel[&T,&T]>,
                <first,     	fun [ <&T1,&T2>] 			to &T1>,
                <second,     	fun [ <&T1,&T2> ] 			to &T2>,

		<power0,	fun[ bag[&T] ]				to bag[bag[&T]]>,
		<power1,	fun[ bag[&T] ]				to bag[bag[&T]]>,

		<all-paths-from,fun[ rel[&T,&T], bag[&T] ]		to bag[rel[&T,&T]]>,

                <reachX,  	fun [ bag[&T], bag[&T], rel[&T,&T] ] 	to rel[&T,&T] >,
                <reachR,  	fun [ bag[&T], bag[&T], rel[&T,&T] ] 	to rel[&T,&T] >,

		<filename,	fun [ area ]				to str >,
		<beginline,	fun [ area ]				to int >,
		<begincol,	fun [ area ]				to int >,

		<endline,	fun [ area ]				to int >,
		<endcol,	fun [ area ]				to int >,

		<sum,		fun [ bag[int] ]			to int >,
		<average,	fun [ bag[int] ]			to int >,
		<max,		fun [ bag[int] ]			to int >,
		<min,		fun [ bag[int] ]			to int >

        ]

%% ---- Where expressions

[WH1]	$Tenv = <$Table, $Errors>,
	check-rscript($Stat+, $Tenv) = $Tenv',
	check($Exp, $Tenv') = <$Etype, <$Table', $Errors'>>
	===================================================
	check($Exp where $Stat+ endwhere, $Tenv) = <$Etype, <$Table, $Errors'>>


%% ---- Check script

[crs]	$Rscript = $Stat*,
	check-rscript($Stat*,  <built-ins, errors[]>) = <$Table, $Errors>
	===============================================
	check-rscript($Rscript) = convert-errors($Errors)


[crs2]	check-rscript($Stat $Stat*, $Tenv) = check-rscript($Stat*, check-stat($Stat, $Tenv))
[crs3]	check-rscript( , $Tenv) = $Tenv


%% ---- Check script with rstore
 
[cwr1]	$Rscript = $Stat*,
       	check-rscript($Stat*,  <built-ins, errors[]>) = $Tenv,
	check-rstore($Stat*, $Rstore, $Tenv) = <$Table, $Errors>
	=====================================================================
     	check-rscript-with-rstore($Rscript, $Rstore) = convert-errors($Errors)

%% ---- Check Rstore

[check-rstore1]
      	value($Var, $Rstore) = $Elem,
      	require-type($Elem, $Etype, $Tenv) = $Tenv'
	=====================================================================
      	check-rstore($Etype $Var $Stat*, $Rstore, $Tenv) = check-rstore($Stat*, $Rstore, $Tenv')

[check-rstore2]
      	value($Var, $Rstore) = *undefined*
	=====================================================================
      	check-rstore($Etype $Var $Stat*, $Rstore, $Tenv) = 
	check-rstore($Stat*, $Rstore, $Tenv + $Var not initialized in Rstore)

[check-rstore3]
	value($Var, $Rstore) = *undefined*
	===================================================================== 
      	check-rstore($Etype $Var = $Exp, $Rstore, $Tenv) = $Tenv

[check-rstore4]
	value($Var, $Rstore) != *undefined*
	===================================================================== 
      	check-rstore($Etype $Var = $Exp $Stat*, $Rstore, $Tenv) = 
	check-rstore($Stat*, $Rstore,$Tenv + $Var conflicting initialization in Rscript and in Rstore)

[check-rstore7]
	check-rstore( , $Rstore, $Tenv) = $Tenv

[default-check-rstore]
	check-rstore($Stat $Stat*, $Rstore, $Tenv) = check-rstore($Stat*, $Rstore, $Tenv)



