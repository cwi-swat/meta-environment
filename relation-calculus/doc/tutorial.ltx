
\documentclass[10pt]{article}
\usepackage{a4wide}
\usepackage[english]{babel}
\usepackage{url}
\usepackage{times}
\usepackage{xspace}
\usepackage{supertabular}

\newcommand{\rscript}[0]{\textsc{Rscript}\xspace}
\newcommand{\asfsdf}[0]{\textsc{Asf+Sdf}\xspace}

\title{A Tutorial Introduction to \rscript}
\author{Paul Klint}

\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This short note documents the current state of the \rscript language.
Be aware, this work in progress.
\end{abstract}

\section{Introduction}

\rscript is a small scripting language based on the relational
calculus.  It is intended for analyzing and querying the source code
of software systems: from finding uninitialized variables in a single
program to formulating queries about the architecture of a complete
software system. \rscript fits well in the extract-enrich-view paradigm:

\begin{description}
\item[Extract:] Given the source text, extract relevant information
from it in the form of relations. Examples are the CALLS relation that
describes direct calls between procedures, the USE relation that
relates statements with the variables that are used in the statements,
and the PRED relation that relates a statement with its predecessors
in the control flow graph.  The extraction phase is outside the scope
of \rscript but may, for instance, be implemented using \asfsdf.

\item[Enrich:] Derive additional information from the relations
extracted from the source text. For instance, use CALLS to compute
procedures that can also call each other indirectly (using transitive
closure).  Here is where \rscript shines.

\item[View:] The result of the enrichment phase are again bags and
relations.  These can be displayed with various tools like, Dot, Rigi
and others. \rscript is not concerned with viewing.

\end{description}

\section{The \rscript language}

\rscript is based on \emph{binary relations} only and has no direct support
for n-ary relations with labelled columns as usual in a general
database language. However, some syntactic support for n-ary relations
exists that translates them internally to binary relations. We will
explain this further below.

An \rscript consists of a sequence of declarations for variables and/or
functions. Usually, the value of one of these variables is what the writer of the
script is interested in.

The language has scalar types (Boolean, integer, string, area) and
composite types (bag and relation). Expressions are constructed from
comprehensions, function invocations and operators. These are all
described below.

\section{Types and values}

\subsection{Elementary Types and Values}

\paragraph{Booleans}
The Booleans are represented by the type {\tt bool} and have two values:
{\tt true} and {\tt false}.

\paragraph{Integers}
The integer values are represented by the type {\tt int} and are written as
usual, e.g., {\tt 0}, {\tt 1}, or {\tt 123}.

\paragraph{Strings}
The string values are represented by the type {\tt str} and consist
of character sequences surrounded by double quotes. e.g., {\tt "a"} or
{\tt "a\ long\ string"}.

\paragraph{Areas}
Area values are represented by the type {\tt area} and serve as source text
coordinates, they are written as in: {\tt area("/usr/paulk/myfile.c", 2, 3, 7,
55)}.

\subsection{Composite Types and Values}

\paragraph{Tuples}

Tuples are represented by the type {\tt <$T_1$, $T_2$>}, where $T_1$ and
$T_2$ are arbitrary types. An example is {\tt <int, str>}.

\rscript directly supports tuples consisting of two elements (also
know as \emph{pairs}).  For convenience, n-ary tuples are allowed, but
they are translated to a nested pair.  For instance, the type {\tt
<int, int, int, int>} corresponds to {\tt <int, <int, <int, int>>>}
and the value {\tt <1, 2, 3, 4>} corresponds to {\tt <1, <2, <3, 4>>>}.

\paragraph{Bags}
Bags are represented by the type {\tt bag[$T$]}, where $T$ is an
arbitrary type. Examples are {\tt bag[int]}, {{\tt bag[<int,int>]} and
{\tt bag[bag[str]]}.  Bags are denoted by {\tt \{ $E_1$, $E_2$, ..., $E_n$ \}},
where the $E_i$ ($1 <= i <= n$) are expressions that yield the desired element
type. For example, {\tt \{1, 2, 3\}}, {\tt \{<1,10>, <2,20>,
<3,30>\}}, and {\tt \{\{"a", "b"\}, \{"c", "d"\}\}}.

\paragraph{Relations}
Bags are nothing more than bags of tuples, but since they are used so often
we provide some shorthand notation for them.

Relations are represented by the type {\tt rel[$T_1$, T$_2$]}, where {\tt
$T_1$} and {\tt $T_2$} are arbitrary types; it is a shorthand for {\tt
bag[<$T_1$, $T_2$>]}.  Examples are {\tt rel[int,str]} and {\tt
rel[int,bag[str]]}.  Relations are denoted by {\tt \{<$E_{11}$, $E_{12}$>, <$E_{21}$,
$E_{22}$>, ..., <$E_{n1}$, $E_{n2}$>\}}, where the $E_{ij}$ are expressions that
yield the desired element type. For example, {\tt \{<1, "a">, <2, "b">,
<3,"c">\}}.

Not surprisingly, $n$-ary relations are represented by the type {\tt rel[$T_1$, $T_2$, ..., $T_n$]}
which is  a shorthand for  {\tt bag[<$T_1$, $T_2$, ..., $T_n$>]}

\section{Comprehensions}

We will use the familiar notation
\begin{quote}
  {\tt \{ $E$ | $G_1$, ..., $G_n$ \}}
\end{quote}
to denote the construction of a bag consisting of the union of
successive values of the expression $E$.  The values and the
generated bag are determined by $E$ and the \emph{generators}
$G_1 ,..., G_n$.  $E$ is computed for all possible
combinations of values produced by the generators.

Each generator may introduce new variables
that can be used in subsequent generators as well as in the expression
$E$.  A generator can use the variables introduced by preceeding
generators.  Generators may enumerate all the values in a bag or
relation, they may perform a test, or they may assign a value to
variables.

\subsection{Generators}

\paragraph{Enumerator}
Enumerators generate all the values in a given bag or relation.
They come in two flavours: 

\begin{itemize}
\item {\tt $V$~:~$E$}: the elements of the bag or relation that results from the evaluation
of expression $E$ are enumerated and subsequently assigned to the new variable $V$.


\item {\tt <$V_1$,~...,~$V_n$>~:~$E$}: the elements of the bag or relation
that results from the evaluation of expression $E$ are enumerated. The
elements of the resulting $n$-tuple are subsequently assigned to the
new variables $V_1 ,..., V_n$.

\end{itemize}

\paragraph{Test}
A test is a boolean-valued expression. If the evaluation yields {\tt true}
this indicates that the current combination of generated values upto this test
is still as desired and execution continues with subsequent generators.  If
the evaluation yields {\tt false} this indicates that the current combination
of values is undesired, and that another combination should be tried.

\paragraph{Assignment}
Assignments assign a value to one or more variables and also come in two flavours:

\begin{itemize}

\item {\tt $V$ <- $E$}: assigns the value of expression $E$ to the new variable $V$.

\item {\tt <$V_1$, ..., $V_n$> <- $E$}: assigns the elements of the $n$-tuple
resulting from the evaluation of expression $E$ to the new variables $V_1 ,..., V_n$.

\end{itemize}


\subsection{Examples of Comprehensions}

\paragraph{Example}

{\tt \{X | X : \{1, 2, 3, 4, 5\},  X >= 3\}} yields the bag {\tt \{3,4,5\}}.

\paragraph{Example}

{\tt \{<X, Y> | X :\{1, 2, 3\}, Y :\{2, 3, 4\}, X >= Y\}} yields the relation
{\tt \{<2, 2>, <3, 2>, <3, 3>\}}.

\paragraph{Example}
{\tt \{<Y, X> | X, Y> :\{<1,10>, <2,20>\} \}} yields the inverse of
the given relation: {\tt \{<10,1>, <20,2>\}}.

\section{Declarations}

\subsection{Variable declarations}
A variable declaration has the form 
\begin{quote}
{\tt $T$ $V$ = $E$}
\end{quote}
where $T$ is a type,
$V$ is a variable name, and $T$ is an expression that should have type
$T$. The effect is that the value of expression $E$ is assigned to
$V$ and can be used later on as $V$'s value. Double declarations are
not allowed.

As a convenience, also declarations without an initialization expression are
permitted and have the form 
\begin{quote}
{\tt $T$ $V$} 
\end{quote}
and only introduce the variable $V$.

\paragraph{Example} {\tt int max = 100} declares the integer variable
{\tt max} with value {\tt 100}.

\paragraph{Example} {\tt rel[str,int] day = \{<"mon", 1>, <"tue", 2>, <"wed",
    3>, <"thu", 4>, <"fri", 5>, <"sat",6>, <"sun",7>\}}
declares the variable {\tt day}, a relation that maps strings to integers.

\subsection{Local variable declarations}
Local variables can be introduced as follows:
\begin{quote}
{\tt $E$ where $T_1$ $V_1$ = $E_1$, ..., $T_n$ $V_n$ = $E_n$ endwhere}
\end{quote}
First the local variables $V_i$ are bound to their respective values
$E_i$, and then the value of expression $E$ is yielded.


\subsection{Function declarations}
A function declaration has the form
\begin{quote}
{\tt $T$ $F$($T_1 V_1$, ..., $T_n V_n$) = $E$}
\end{quote}
Here $T$ is the result type of the function and this should be equal to the
type of the associated expression $E$.  Each $T_i$ $V_i$ represents a typed
formal parameter of the function. The formal parameters may occur in $E$ and
get their value when $F$ is invoked from another expression.

\paragraph{Example} The function declaration
\begin{quote}
{\tt rel[int, int] invert(rel[int,int] R) = \{<Y, X> | X, Y> : R \}} 
\end{quote}
yields the inverse of the argument relation {\tt R}. For instance,
{\tt invert(\{<1,10>, <2,20>\})} yields {\tt \{<10,1>, <20,2>\}}.

\paragraph{Parameterized types in function declarations}
The types that occur in function declarations may also contain
\emph{type variables}. In this way functions can be defined for arbitrary
types.

\begin{sloppypar}
\paragraph{Example} The declaration
\begin{quote}
{\tt rel[T2, T1] invert2(rel[T1,T2] R) = \{<Y, X> | X, Y> : R \}} 
\end{quote}
yields an inversion function that is applicable to any binary relation.
For instance,
{\tt invert2(\{<1,10>, <2,20>\})} yields {\tt \{<10,1>, <20,2>\}},
and {\tt invert2(\{<"mon", 1>, <"tue", 2>\}}
yields {\tt \{<1, "mon">, <2, "tue">\}}.
\end{sloppypar}

\paragraph{Example} The function
\begin{quote}
{\tt <T2, T1> swap(T1 A, T2 B) = <B, A>}
\end{quote}
can be used to swap the elements of pairs of arbitrary types.  For instance,
{\tt swap(<1, 2>)} yields {\tt <2,1>} and {\tt swap(<"wed", 3>)} yields {\tt
<3, "wed">}.

\subsection{Assertions}
An assert statement may occur everywhere where a declaration is allowed.  It
has the form 
\begin{quote}
{\tt assert $L$: $E$}
\end{quote}
 where $L$ is a string that serves as a
label for this assertion, and $E$ is a boolean-value expression.  During
execution, a list of true and false assertions is maintained.  When the script
is executed as a \emph{testsuite} (see Section~\ref{running}) a summary of this
information is shown to the user. When the script is executed in the standard
fashion, the assert statement has no affect.

\paragraph{Example}
\begin{quote}
{\tt assert "Equality on Bags 1": \{1, 2, 3, 1\} == \{3, 2, 1, 1\}}
\end{quote}

\subsection{Solvers}
It is also possible to define mutually recursive variables by
\begin{quote}
{\tt solve \{
  $V_1$ = $E_1$,
  ...,
  $V_n$ = $E_n$
\}}
\end{quote}
Here, the expressions {\tt E}$_i$ may refer to any of the variables {\tt
  V}$_i$ (and to any variables declared earlier).  This set of equations is
  solved by evaluating the expressions {\tt E}$_i$, assigning their value to
  the corresponding variables {\tt V}$_i$, and repeating this as long as the
  value of one of the variables was changed. This is typically used for
  solving a set of dataflow equations. \footnote{Probably, the syntax of this
  construct should more emphasize that it is a set of equations.}

\section{Built-in Operators and Functions}

In the following two tables the built-in operators and functions are given.
For readability, the argument types are indicated as follows:
\begin{itemize}
\item \emph{bool}: argument is of type {\tt bool}
\item \emph{int}: argument is of type {\tt int}
\item \emph{str}: argument is of type {\tt str}
\item \emph{area}: argument is of type {\tt area}
\item \emph{tuple}: argument is any tuple type.
\item \emph{bag}: argument is of any bag type
\item \emph{rel}: argument is of any relation type
\end{itemize}

\tablecaption{Built-in operators}
\tablehead{\hline}
\tabletail{\hline}
\begin{supertabular}{|p{3.3cm}|p{10.7cm}|} \hline

\emph{bool}$_1$ \texttt{and} \emph{bool}$_2$ & yields {\tt true} if both arguments have the value true and
{\tt false} otherwise\\ \hline

\emph{bool}$_1$ \texttt{or} \emph{bool}$_2$ & yields {\tt true} if either argument has
                         the value {\tt true} and {\tt false} otherwise\\ \hline

\emph{bool}$_1$ \texttt{implies} \emph{bool}$_2$ & yields {\tt false} if
                             \emph{bool}$_1$ has the value {\tt true} and
                               \emph{bool}$_2$ has value {\tt false}, and
                         {\tt true} otherwise\\ \hline

{\tt not} \emph{bool} & yields true if \emph{bool} is {\tt false} and {\tt true} otherwise \\
\hline

\emph{any} {\tt in} \emph{bag} & yields true if \emph{any} occurs as element
in \emph{bag} and false otherwise \\ \hline

\emph{any} {\tt notin} \emph{bag} & yields {\tt false} if \emph{any} occurs as
element in \emph{bag} and {\tt true} otherwise \\ \hline \hline

\emph{\emph{tuple}} {\tt in} \emph{rel} & yields true if the left argument occurs as element in the
right argument and false otherwise \\ \hline

\emph{\emph{tuple}} {\tt notin} \emph{rel} & yields false if the left argument occurs as element in the
right argument and true otherwise \\ \hline \hline

\emph{bag} {\tt ==} \emph{bag} & yields true if both arguments are equal bags and false
otherwise\\ \hline

\emph{bag} {\tt !=} \emph{bag} & yields true if both arguments are unequal bags and false
otherwise\\ \hline

\emph{bag} {\tt <=} \emph{bag} & yields true if the left argument is a subset of the right argument
and false otherwise\\ \hline

\emph{bag} {\tt <} \emph{bag} & yields true if the left argument is a strict subset of the right argument
and false otherwise\\ \hline

\emph{bag} {\tt >=} \emph{bag} & yields true if the left argument is a superset of the right argument
and false otherwise\\ \hline

\emph{bag} {\tt >} \emph{bag} & yields true if the left argument is a strict superset of the right argument
and false otherwise\\ \hline \hline

\emph{rel} {\tt ==} \emph{rel} & yields true if both arguments are equal relations and false
otherwise\\ \hline

\emph{rel} {\tt !=} \emph{rel} & yields true if both arguments are unequal relations and false
otherwise\\ \hline

\emph{rel} {\tt <=} \emph{rel} & yields true if the left argument is a subset of the right argument
and false otherwise\\ \hline

\emph{rel} {\tt <} \emph{rel} & yields true if the left argument is a strict subset of the right argument
and false otherwise\\ \hline

\emph{rel} {\tt >=} \emph{rel} & yields true if the left argument is a superset of the right argument
and false otherwise\\ \hline

\emph{rel} {\tt >} \emph{rel} & yields true if the left argument is a strict superset of the right argument
and false otherwise\\ \hline \hline

\emph{int} {\tt ==} \emph{int} & yields true if both arguments are numerically equal and false
otherwise\\ \hline

\emph{int} {\tt !=} \emph{int} & yields true if both arguments are numerically unequal  and false
otherwise\\ \hline

\emph{int} {\tt <=} \emph{int} & yields true if the left argument is numerically less than
or equal the right argument and false otherwise\\ \hline

\emph{int} {\tt <} \emph{int} & yields true if the left argument is a numerically less than the right argument
and false otherwise\\ \hline

\emph{int} {\tt >=} \emph{int} & yields true if the left argument is numerically greater
than or equal the right argument and false otherwise\\ \hline

\emph{int} {\tt >} \emph{int} & yields true if the left argument is numerically greater than the right argument
and false otherwise\\ \hline \hline

\emph{bag} {\tt union} \emph{bag} & yields the bag resulting from the union of the two arguments
 \\ \hline

\emph{bag} {\tt inter} \emph{bag} & yields the bag resulting from the intersection of the two arguments
 \\ \hline

\emph{bag} \verb+\+ \emph{bag} & yields the bag resulting from the difference of the two arguments
 \\ \hline \hline

\emph{rel} {\tt union} \emph{rel} & yields the relation resulting from the union of the two arguments
 \\ \hline

\emph{rel} {\tt inter} \emph{rel} & yields the relation resulting from the intersection of the two arguments
 \\ \hline

\emph{rel} \verb+\+ \emph{rel} & yields the relation resulting from the difference of the two arguments
 \\ \hline

\emph{rel} {\tt o} \emph{rel} & yields the relation resulting from the composition of the two arguments
 \\ \hline


\emph{bag} {\tt x} \emph{bag} & yields the relation resulting from the carthesian product of the two arguments
 \\ \hline

\emph{rel} {\tt +} & yields the relation resulting from the transitive closure of
 the argument  \\ \hline

\emph{rel} {\tt *}  & yields the relation resulting from the reflexive transitive closure of
 the argument  \\ \hline

\end{supertabular}

\section{Built-in functions}

\tablecaption{Built-in functions}
\tablehead{\hline}
\tabletail{\hline}

\begin{supertabular}{|p{4cm}|p{10cm}|} \hline

{\tt id(} \emph{bag} {\tt )} & yields the relation that results from transforming
each element in the argument into a pair with that element as first and
second element \\ \hline

{\tt domain(} \emph{rel} {\tt )} & yields the bag that results from taking
the first element of each tuple in the argument \\ \hline

{\tt range(} \emph{rel} {\tt )} & yields the bag that results from taking
the second element of each tuple in the argument \\ \hline

{\tt carrier(} \emph{rel} {\tt )} & yields the bag that results from taking
the first and  second element of each tuple in the argument \\ \hline

{\tt top(} \emph{rel} {\tt )} &  yields the bag of all roots when the argument is
viewed as a graph\\ \hline

{\tt bottom(} \emph{rel} {\tt )} &  yields the bag of all leaves when the argument is
viewed as a graph\\ \hline

{\tt inv(} \emph{rel} {\tt )} &  yields the relation that is the inverse of the
argument, i.e. the relation in which the elements of the tuples have been
interchanged.\\ \hline

{\tt compl(} \emph{rel} {\tt )} &  yields the relation that is the complement of the
argument, using the carrier set of that argument oas universe \\ \hline

{\tt domainR(} \emph{rel}, \emph{bag} {\tt )} & yields a relation identical to the first
 argument but only containing tuples whose first element is in the second
 argument \\ \hline

{\tt rangeR(} \emph{rel}, \emph{bag} {\tt )} & yields a relation identical to the first
 argument but only containing tuples whose second element is in the second
 argument \\ \hline

{\tt carrierR(} \emph{rel}, \emph{bag} {\tt )} &  yields a relation identical to the first
 argument but only containing tuples whose first and second element are in the second
 argument \\ \hline

{\tt domainX(} \emph{rel}, \emph{bag} {\tt )} & yields a relation identical to the first
 argument but with all tuples removed whose first element is in the second
 argument \\ \hline

{\tt rangeX(} \emph{rel}, \emph{bag} {\tt )} & yields a relation identical to the first
 argument but with all tuples removed whose second element is in the second
 argument \\ \hline


{\tt carrierX(} \emph{rel}, \emph{bag} {\tt )} &  yields a relation identical to the first
 argument but with all tuples removed whose first or second element is in the second
 argument \\ \hline

{\tt first(} \emph{tuple} {\tt )} &  yields the first element of the argument\\ \hline

{\tt second(} \emph{tuple} {\tt )} &  yields the second element of the argument\\ \hline

{\tt reachR(} \emph{bag}1, \emph{bag}2, \emph{rel} {\tt )} & yields the relation that describes
which nodes can be reached from \emph{bag}1 using the relation rel, such that only nodes in
bag2 are used. \\ \hline

{\tt power(} \emph{bag} {\tt )} & yields the powerset of the value of its argument \\ \hline

{\tt reachX(} \emph{bag}, \emph{bag}, \emph{rel} {\tt )} &  yields the relation that describes
which nodes can be reached from bag1 using the relation rel, such that no nodes in
bag2 are used. \\ \hline

\end{supertabular}

\section{Running a \rscript}
Currently, the definition of \rscript resides in {\tt /ufs/paulk/research/RPA}
but that \emph{will change soon}. You can also checkout your own copy by means of
{\tt cvs -d /ufs/paulk/cvsroot co RPA}.

\paragraph{Running a script}
\begin{itemize}
\item Change to the above directory (better to your own copy!).
\item Start the ASF+SDF Meta-Environment by the command {\tt meta}.
\item Open the module {\tt Rscript.sdf}.
\item Open your own term, using the Rscript module.
\item Observe that a new menu call {\tt Rscript} appears in the menu bar.
\item Click the parse button in the {\tt Actions} menu of the editor:
now we know whether there are syntax errors. If so, correct them.

\item Click the {\tt Check} button in the {\tt Rscript} menu: this will
  perform a type check of your script. If there are type errors, correct them.

\item Click the {\tt Execute} button in the {\tt Rscript} menu to execute your script: a new
editor pops up which shows all the variables at the end of the execution.
\end{itemize}

\paragraph{Running a Test suite} \label{running}
Same as above but use {\tt Testsuite} button instead of the {\tt Execute}
button in the {\tt Rscript} menu.  The effect is that the script is executed
and that a summary is printed of {\tt assert} statement that succeeded or
failed.

\paragraph{Miscellaneous}
The subdirectory {\tt rscripts} contains several sample scripts.  See {\tt
test1.rscript} and {\tt tests2.rscript} for examples of the use of built-in
operators and functions.

The subdirectory {\tt demo} contains larger demos.

\section{Pseudo definitions of some built-in operators and functions}

It is interesting that most (but not all!) built-in operators and all
functions can be defined in \rscript itself. They only serve convenience and
efficiency.  The definitions marked with a dagger ($\dagger$) cannot be written
as such since it is not possible to define operators in \rscript.  It is,
however, allowed to write these polymorphic definitions where {\tt T1}, {\tt
T2}, ... represent arbitrary types.

\paragraph{$^\dagger$Composition: {\tt o}}

\begin{verbatim}
rel[T1,T3] o(rel[T1,T2] R1, rel[T2,T3] R2) =
   {<v, y> | <v, w> : R1, <x, y> :  R2, w == x }
\end{verbatim}

\paragraph{$^\dagger$Carthesian product: {\tt x}}
\begin{verbatim}
rel[T1,T2] x(bag[T1] B1, bag[T2] B2) =
   {<x, y> | x : B1, y : B2 }
\end{verbatim}

\paragraph{$^\dagger$ Left image: {\tt .}}
\begin{verbatim}
bag[T2] .(T1 E, rel[T1,T2] R) = { W | <V, W> : R, V == E }
bag[T2] .(bag[T1] B, rel[T1,T2] R) = { W | <V, W> : R, V in B}
\end{verbatim}

\paragraph{$^\dagger$Right image: {\tt .}}
\begin{verbatim}
bag[T1] .(rel[T1,T2] R, T2 E) = { V | <V, W> : R, W == E }
bag[T1] .(rel[T1,T2] R, bag[T2] B) = { V | <V, W> : R, W in B }
\end{verbatim}

\paragraph{Identity: {\tt id}}
\begin{verbatim}
rel[T,T] id(bag[T] B) = { <X, X> | X in B }
\end{verbatim}
Example:
\begin{verbatim}
id({1,2,3}) = {<1,1>, <2,2>, <3,3>}
\end{verbatim}

\paragraph{Domain: {\tt domain}}
\begin{verbatim}
Def:	bag[T1] domain (rel[T1,T2] R) = { X | <X, Y> : R }
\end{verbatim}
Example:
\begin{verbatim}
domain({<1,10>, <2,20>}) = {1, 2}
\end{verbatim}

\paragraph{Range: {\tt range}}
\begin{verbatim}
bag[T2] range (rel[T1,T2] R) = { Y | <X, Y> : R }
\end{verbatim}
Example:
\begin{verbatim}
range({<1,10>, <2,20>}) = {10, 20}
\end{verbatim}

\paragraph{Carrier: {\tt carrier}}
\begin{verbatim}
bag[T]  carrier (rel[T,T] R) = domain(R) union range(R)
\end{verbatim}
Example:
\begin{verbatim}
carrier({<1,10>, <2,20>}) = {1, 10, 2, 20}
\end{verbatim}

\paragraph{Top: {\tt top}}
\begin{verbatim}
bag[T] top(rel{T, T] R) = domain(R) \ range(R)
\end{verbatim}

\paragraph{Bottom: {\tt bottom}}
\begin{verbatim}
bag[T] bottom(rel[T,T] R) = range(R) \ domain(R)
\end{verbatim}

\paragraph{Inverse: {\tt inv}}
\begin{verbatim}
rel[T2,T1] inv (rel[T1,T2] R) = { <Y, X> | <X, Y> : R }
\end{verbatim}
example:
\begin{verbatim}
inv({<1,10>, <2,20>}) = {<10,1>,<20,2>}
\end{verbatim}

\paragraph{Complement: {\tt compl}}
\begin{verbatim}
rel[T1, T2] compl(rel[T1,T2] R) = (domain(R) x range(R)) \ R
\end{verbatim}

\paragraph{Domain restriction: {\tt domainR}}
\begin{verbatim}
rel[T1,T2] domainR (rel[T1,T2] R, Bag[T1] B) = 
   { <X, Y> | <X, Y> : R, X in B }
\end{verbatim}

\paragraph{Range Restriction: {\tt rangeR}}
\begin{verbatim}
rel[T1,T2] rangeR (rel[T1,T2] R, Bag[T2] B) =  
   { <X, Y> | <X, Y> : R, Y in B }
\end{verbatim}

\paragraph{Carrier Restriction: {\tt carrierR}}
\begin{verbatim}
rel[T,T] carR (rel[T,2] R, Bag[T] B) =  
   { <X, Y> | <X, Y> : R, X in B and Y in B }
\end{verbatim}

\paragraph{Domain Exclusion: {\tt domainX}}
\begin{verbatim}
rel[T1,T2] domainX (rel[T1,T2] R, Bag[T1] B) = 
   { <X, Y> | <X, Y> : R, X notin B }
\end{verbatim}

\paragraph{Range Exclusion: {\tt rangeX}}
\begin{verbatim}
rel[T1,T2] rangeX (rel[T1,T2] R, Bag[T2] B) = 
	   { <X, Y> | <X, Y> : R, Y notin B }
\end{verbatim}

\paragraph{Carrier Exclusion: {\tt carrierX}}
\begin{verbatim}
rel[T,T] carrierX (rel[T,T] R, Bag[T] B) = 
   { <X, Y> | <X, Y> : R, X notin B or Y notin B }
\end{verbatim}

\paragraph{First of Tuple: {\tt first}}
\begin{verbatim}
T1 first(<T1, T2> P) = T1
\end{verbatim}

\paragraph{Second of Tuple: {\tt second}}
\begin{verbatim}
T2 second(<T1, T2> P) = T2
\end{verbatim}

\paragraph{Reach Exclusion: {\tt reachX}}
\begin{verbatim}
rel[T,T] reachX( bag[T] S, bag[T] E, rel[T,T] R) =
	       domainR(R, S) o carrierX(R, E)+
\end{verbatim}

\paragraph{Reach Restriction: {\tt reachR}}
\begin{verbatim}
rel[T,T] reachR( bag[T] S, bag[T] E, rel[T,T] R) =
	       domainR(R, S) o carrierR(R, E)+
\end{verbatim}

\section{Differences with previous versions}
\rscript is in under active development and several (incompatible)  changes
have been made in the last few weeks. Here is an indicative list.

\begin{itemize}

\item The syntax of comprehension has been changed. Old
\begin{verbatim}
  { <X, Y> : <X, Y> in R | X in B and Y  in B }
\end{verbatim}
New:
\begin{verbatim}
  { <X, Y> | <X, Y> : R, X in B and Y in B }
\end{verbatim}

\item The type {\tt node} has been renamed into {\tt area}

\end{itemize}

\end{document}
