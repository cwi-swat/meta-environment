
\documentclass[10pt,twoside]{book}
\usepackage{a4wide}
\usepackage[english]{babel}
\usepackage{url}
\usepackage{times}
\usepackage{xspace}
\usepackage{alltt}
\usepackage{supertabular}
\usepackage{epsfig}
\usepackage{moreverb}
\usepackage{verbatim}
\usepackage{fancyheadings}


\newcommand{\rscript}[0]{\textsc{Rscript}\xspace}
\newcommand{\rstore}[0]{\textsc{Rstore}\xspace}
\newcommand{\asfsdf}[0]{\textsc{Asf+Sdf}\xspace}
\newcommand{\note}[1]{\paragraph{Note:} \emph{#1}}

\newenvironment{exam}
        {\begin{quote}\small}
        {\end{quote}}  

\pagestyle{fancy}
% Switch off shouting makeuppercase from fancyheaders.
\renewcommand{\MakeUppercase}[1]{#1}
\lhead[\leftmark]{\rscript Tutorial}
\rhead[\rscript Tutorial]{\leftmark}

\title{A Tutorial Introduction to \rscript\\ ---a Relational Approach to
  Software Analysis---}
\author{Paul Klint}

\date{\today}

\begin{document}
\maketitle

\tableofcontents

\newpage

\chapter{Introduction}\label{SEC:Introduction}

\begin{figure}[tb]
\begin{center}
\vspace*{-1cm}
\epsfig{figure=figs/paradigm.eps,width=14cm}
\vspace*{-6cm}
\end{center}
\hrulefill
\caption{\label{FIG:paradigm} The extract-enrich-view paradigm}
\end{figure}

\rscript is a small scripting language based on the relational
calculus.  It is intended for analyzing and querying the source code
of software systems: from finding uninitialized variables in a single
program to formulating queries about the architecture of a complete
software system. \rscript fits well in the extract-enrich-view paradigm
shown in Figure~\ref{FIG:paradigm}:

\begin{description}
\item[Extract:] Given the source text, extract relevant information
from it in the form of relations. Examples are the CALLS relation that
describes direct calls between procedures, the USE relation that
relates statements with the variables that are used in the statements,
and the PRED relation that relates a statement with its predecessors
in the control flow graph.  The extraction phase is outside the scope
of \rscript but may, for instance, be implemented using \asfsdf~\cite{BDHJJKKMOSVVV01}.


\item[Enrich:] Derive additional information from the relations
extracted from the source text. For instance, use CALLS to compute
procedures that can also call each other indirectly (using transitive
closure).  Here is where \rscript shines.

\item[View:] The result of the enrichment phase are again bags and
relations.  These can be displayed with various tools like, Dot~\cite{Dot96}, Rigi~\cite{Mueller88}
and others. \rscript is not concerned with viewing.

\end{description}

\section{Background}
Many algorithms for program analysis are usually presented as \emph{graph}
algorithms and this seems to be at odds with our extensive experience of using
\emph{term} rewriting for tasks as type checking, fact extraction, analysis
and transformation.  The major obstacle is that graphs can and terms cannot
contain cycles.  Fortunately, every graph can be represented as a relation and
it is therefore natural to have a look at the combination of relations and
term rewriting.

\paragraph{Relation-oriented Languages}
There is a long tradition in Computer Science to organize languages around one
a more prominent data types such as lists (Lisp), strings (SNOBOL), arrays
(APL) or sets (SETL).  We use bags and relations as primary datatypes and the
sets and set formers in SETL~\cite{SETL} are the best historic reference for
them. Set formers have later on be popularized in various functional languages
since they were introduced in KRC~\cite{Turner82}.  An overview of languages
centered around collection types such as sets and bags is given in
~\cite{Tannen94}.  Database languages in general and SQL in particular are
described in~\cite{Ullman82}.  The connection between comprehensions and
relational algebra is described in~\cite{WadlerLists87,Trinder89}. A further
analysis of this topic is given in~\cite{Buneman94}.

Systems supporting relational programming include RELVIEW~\cite{RELVIEW98}
(intended for the interactive creation and visualisation of relations
and the prototyping of graph algorithms), ...

\paragraph{Relations and Program Analysis}

The idea to represent relational views of programs is already quite old.  For
instance, in~\cite{Linton84} all syntactic as well as semantic aspects of a
program were represented by relations and SQL was used to query them. Due to
the lack of expressiveness of SQL (notably the lack of transitive closures)
and the performance problems encountered, this approach has not seen wider
use.  In Rigi~\cite{Mueller88}, a tuple format (RSF) is introduced to
represent relations and a language (RCL) to manipulate them.
In~\cite{PaulPrakash94} a \emph{source code algebra} is described that can be
used to express relational queries on source text.  In~\cite{BKV96b} a
\emph{query algebra} is formulated to express direct queries on the syntax
tree. It also allows the querying of information that is attached to the
syntax tree via annotations.  Relational algebra is used in GROK~\cite{Holt96}
and Relation Partition Algebra
(RPA)~\cite{FeijsKrikhaarOmmering98,Feijs99,Krikhaar99} to represent basic
facts about software systems and to query them.  In GUPRO~\cite{GUPRO98}
graphs are used to represent programs and to query them. In
F(p)--$\ell$~\cite{CanforRaEtAl99} a Prolog database and a special-purpose
language are used to represent and query program facts.

The requirements for a query language for reverse engineering are discussed
in~\cite{holt-towards}.

\paragraph{Application of Relations to Program Analysis}
\note{To be written}

\paragraph{What's new in \rscript?}
Given the considerable amount of related work, it is necessary to clearly
establish what is and what is not new in our approach:

\begin{itemize}

\item We use bags and multi-relations like in RPA~\cite{FeijsKrikhaarOmmering98}.

\item Unlike Rigi~\cite{Mueller88}, GROK~\cite{Holt96} and
RPA~\cite{FeijsKrikhaarOmmering98} we provide a relational \emph{calculus} as
opposed to a relational algebra. Although the two have the same expressive
power, a calculus increases, in our opinion, the readability of relational
expressions.  We have extended binary relations with modest support for
$n$-ary relations but don't support the complete repertoire of $n$-ary
relations as in SQL.  We also allow nested bags and relations.  In addition,
we offer a strongly typed language with user-defined types.

\item We integrate an equation solver in a relational language. In this way
dataflow problems can be expressed.

\item We introduce an \emph{area} datatype with associated operations to
easily manipulate references to source code.

\item There is some innovation in syntactic notation and specific built-in
functions.

\item We introduce the notion of an \rstore that generalizes the RSF tuple
  format of Rigi. An \rstore consists of name/value pairs, where the values
  may be arbitrary nested bags or relations. An \rstore is a
  language-independent exchange format and can be used to exchange complex
  relational data between programs written in different languages.

\end{itemize}

\section{Plan for this Tutorial}

In Chapter~\ref{SEC:motivating-example} we first provide a motivating example
of our relational approach.
In Chapter~\ref{SEC:rscript-language} follows a complete description
of all the features in \rscript.
In the following Chapters~\ref{SEC:operators} and \ref{SEC:functions}
all built-in operators and functions are described.
The most interesting part of this tutorial is probably
Chapter~\ref{SEC:larger-examples} where we present a menagerie of larger
examples ranging from computing the McCabe complexity of code, analyzing the
component structure of systems, to program slicing.
Chapter~\ref{SEC:running-rscript} describes howto run an \rscript.
Two appendices complete this tutorial:
Appendix~\ref{AP:operators} summarizes all built-in operators
and Appendix~\ref{AP:functions} summarizes all built-in functions.

\chapter{A Motivating Example} \label{SEC:motivating-example}

Suppose a large software system ends up on your desk with several questions
attached to it:

\begin{itemize}

\item How many procedure calls occur in this system?

\item How many procedures contains it?

\item What are the entry points for this system, i.e., procedures that call
  others but are not called themselves?

\item What are the leaves of this application, i.e., procedures that are
called but do not make any calls themselves?

\item Which procedures call each other indirectly?

\item Which procedures are called directly or indirectly from each entry
  point?

\item Which procedures are called from all entry points?

\end{itemize}


\noindent There are now two possibilities. Either you have this superb
programming environment or tool suite that can immediately answer all these
questions for you or you can use \rscript.

\paragraph{Preparations}

\begin{figure}[tb]
\begin{center}
\vspace*{-1cm}
\epsfig{figure=figs/calls.eps,width=14cm}
\vspace*{-13cm}
\end{center}
\hrulefill
\caption{\label{FIG:calls} Graphical representation of the {\tt calls} relation}
\end{figure}


To illustrate this process consider the call graph shown in
Figure~\ref{FIG:calls}. Recall that \rscript does not consider fact extraction
\emph{per se} so we assume that this call graph has been extracted from the
software by some other tool. Also keep in mind that a real call graph of a
real application will contain thousands and thousands of calls. Drawing it in
the way we do in Figure~\ref{FIG:calls} makes no sense since we get a
uniformly black picture due to all the call dependencies.  This section is
intended to give you a first impression what can be done with \rscript. Please
return to this example when you have digested the detailed description of
\rscript in Chapters~\ref{SEC:rscript-language},~\ref{SEC:operators} and
\ref{SEC:functions}.

\rscript supports some basic data types like integers and strings which are
sufficient to formulate and answer the questions at hand.  However, we can
gain readability by introducing separately named types for the items we are
describing.  First, we introduce therefore a new type {\tt proc} (an alias for
strings) to denote procedures:

\begin{exam}
\begin{verbatim}
type proc = str
\end{verbatim}
\end{exam}

Suppose that the following facts have been extracted from the source
code and are represented by the relation {\tt Calls}:

\begin{exam}
\begin{verbatim}
rel[proc , proc] Calls = {<"a", "b">, <"b", "c">, <"b", "d">,
   <"d", "c">, <"d","e">, <"f", "e">, <"f", "g">, <"g", "e">}.
\end{verbatim}
\end{exam}

\noindent This concludes the preparatory steps and now we move on to answer the
questions.

\paragraph{How many procedure calls occur in this system?}
To determine the numbers of calls, we simply determine the number of tuples
in the {\tt Calls} relation, as follows:

\begin{exam}\begin{verbatim}
int nCalls = # Calls
\end{verbatim}
\end{exam}
The operator \verb@#@ determines the number of elements in a bag or relation
and is explained in Section~\ref{BO:misc}.
In this example, {\tt nCalls} will get the value {\tt 8}.

\paragraph{How many procedures contains it?}

We get the number of procedures by determining which names occur
in the tuples in the relation {\tt Calls} and then determining the
number of names:

\begin{exam}\begin{verbatim}
bag[proc] procs = carrier(Calls)
int nprocs = # procs
\end{verbatim}
\end{exam}
The built-in function {\tt carrier} determines all the values that occur
in the tuples of a relation. In this case,
{\tt procs} will get the value  \verb@{"a", "b", "c", "d", "e", "f", "g"}@
and {\tt nprocs} will thus get value {\tt 7}. A more concise way of expressing this
would be to combine both steps:
\begin{exam}\begin{verbatim}
int nprocs = # carrier(Calls)
\end{verbatim}
\end{exam}

\paragraph{What are the entry points for this system?}
The next step in the analysis is to determine which \emph{entry points} this
application has, i.e., procedures which call others but are not called
themselves. Entry points are useful since they define the external interface
of a system and may also be used as guidance to split a system in
parts.

The \emph{top} of a relation contains those left-hand sides of tuples in a
relation that do not occur in any right-hand side.  When a relation is viewed
as a graph, its top corresponds to the root nodes of that graph.
Similarly, the \emph{bottom} of a relation corresponds to the leaf nodes of
the graph. See Section~\ref{BI:bottom} for more details.
Using this knowledge, the entry points can be computed by determining the top of the
{\tt Calls} relation:
\begin{exam}\begin{verbatim}
bag[proc] entryPoints = top(Calls)
\end{verbatim}
\end{exam}

\noindent In this case, {\tt entryPoints} is equal to  \verb@{"a", "f"}@.
In other words, procedures {\tt "a"} and {\tt "f"} are the entry points
of this application.

\paragraph{What are the leaves of this application?}
In a similar spirit, we can determine the \emph{leaves} of this application,
i.e., procedures that are being called but do not make any calls themselves:

\begin{exam}\begin{verbatim}
bag[proc] bottomCalls = bottom(Calls).
\end{verbatim}
\end{exam}
In this case, {\tt bottomCalls} is equal to  \verb@{"c", "e"}@.

\paragraph{Which procedures call each other indirectly?}
We can also determine the \emph{indirect calls} between procedures, by
taking the transitive closure of the {\tt Calls} relation:

\begin{exam}\begin{verbatim}
rel[proc, proc] closureCalls = Calls+
\end{verbatim}
\end{exam}
In this case, {\tt closureCalls} is equal to
\begin{exam}\begin{verbatim}
{<"a", "b">, <"b", "c">, <"b", "d">, <"d", "c">, <"d","e">, <"f", "e">, 
 <"f", "g">, <"g", "e">, <"a", "c">, <"a", "d">, <"b", "e">, <"a", "e">}
\end{verbatim}
\end{exam}

\paragraph{ Which procedures are called directly or indirectly from each entry
  point?}

We know now the entry points for this application ({\tt "a"} and {\tt "f"})
and the indirect call relations. Combining this information, we can determine
which procedures are called from each entry point. This is done by taking the
\emph{right image} of {\tt closureCalls}. The right image operator determines
yields all right-hand sides of tuples that have a given value as left-hand
side:
\begin{exam}\begin{verbatim}
bag[proc] calledFromA = closureCalls["a"]
\end{verbatim}
\end{exam}
yields \verb@{"b", "c", "d", "e"}@ and
\begin{exam}\begin{verbatim}
bag[proc] calledFromF = closureCalls["f"]
\end{verbatim}
\end{exam}
yields \verb@{"e", "g"}@.

\paragraph{Which procedures are called from all entry points?}
Finally, we can determine which procedures are called from both entry points
by taking the intersection of the two bags {\tt calledFromA} and {\tt calledFromF}
\begin{exam}\begin{verbatim}
bag[proc] commonProcs = calledFromA inter calledFromF
\end{verbatim}
\end{exam}
which yields \verb@{"e"}@. In other words, the procedures called from both
entry
points are mostly disjoint except for the common procedure  {\tt "e"}.

\paragraph{Wrap-up}
These findings can be verified by inspecting a graph view of the calls
relation as shown in Figure~\ref{FIG:calls}.  Such a visual inspection does
\emph{not} scale very well to large graphs and this makes the above form of
analysis particularly suited for studying large systems.

\chapter{The \rscript Language} \label{SEC:rscript-language}

\rscript is based on \emph{binary relations} only and has no direct support
for $n$-ary relations with labeled columns as usual in a general database
language. However, some syntactic support for $n$-ary relations exists. We
will explain this further below.

An \rscript consists of a sequence of declarations for variables and/or
functions. Usually, the value of one of these variables is what the writer of the
script is interested in.

The language has scalar types (Boolean, integer, string, area) and
composite types (bag and relation). Expressions are constructed from
comprehensions, function invocations and operators. These are all
described below.

\section{Types and Values}

\subsection{Elementary Types and Values} \label{SEC:ElementaryTypes}

\paragraph{Booleans}
The Booleans are represented by the type {\tt bool} and have two values:
{\tt true} and {\tt false}.

\paragraph{Integers}
The integer values are represented by the type {\tt int} and are written as
usual, e.g., {\tt 0}, {\tt 1}, or {\tt 123}.

\paragraph{Strings}
The string values are represented by the type {\tt str} and consist
of character sequences surrounded by double quotes. e.g., {\tt "a"} or
{\tt "a\ long\ string"}.

\paragraph{Areas}
Area values are represented by the type {\tt area} and serve as source text
coordinates, they are written as in: {\tt area("/usr/paulk/myfile.c", 2, 3, 7,
55)}.

\section{Tuples, Bags and Relations}

\paragraph{Tuples}

Tuples are represented by the type {\tt <$T_1$, $T_2$>}, where $T_1$ and
$T_2$ are arbitrary types. An example of a tuple type is {\tt <int, str>}.
\rscript directly supports tuples consisting of two elements (also
know as \emph{pairs}).  For convenience, $n$-ary tuples are also allowed, but
there are some restrictions on their use, see the paragraph {\bf Relations} below. 

\paragraph{Bags}
Bags are represented by the type {\tt bag[$T$]}, where $T$ is an arbitrary
type. Examples are {\tt bag[int]}, {{\tt bag[<int,int>]} and {\tt
bag[bag[str]]}.  Bags are denoted by a list of elements, separated by comma's
and enclosed in braces as in  \verb@{@{\tt $E_1$, $E_2$, ..., $E_n$}\verb@}@,
where the $E_i$ ($1 \leq i \leq n$) are expressions that yield the desired element
type. For example, 
\begin{itemize}
\item \verb@{1, 2, 3}@ is of type {\tt bag[int]},
\item \verb@{<1,10>, <2,20>, <3,30>\}@ is of type {\tt bag[<int,int>]}, and 
\item \verb@{{"a", "b"}, {"c", "d"}}@ is of type {\tt bag[bag[str]]}.
\end{itemize}

\paragraph{Relations}
Relations are nothing more than bags of tuples, but since they are used so
often we provide some shorthand notation for them.

Relations are represented by the type {\tt rel[$T_1$, $T_2$]}, where {\tt
$T_1$} and {\tt $T_2$} are arbitrary types; it is a shorthand for {\tt
bag[<$T_1$, $T_2$>]}.  Examples are {\tt rel[int,str]} and {\tt
rel[int,bag[str]]}.  Relations are denoted by \verb@{@{\tt <$E_{11}$, $E_{12}$>, <$E_{21}$,
$E_{22}$>, ..., <$E_{n1}$, $E_{n2}$>}\verb@}@, where the $E_{ij}$ are expressions that
yield the desired element type. For example, \verb@{<1, "a">, <2, "b">, <3,"c">}@ is of type {\tt rel[int, str]}.

Not surprisingly, $n$-ary relations are represented by the type {\tt
rel[$T_1$, $T_2$, ..., $T_n$]} which is a shorthand for {\tt bag[<$T_1$,
$T_2$, ..., $T_n$>]}.  Most built-in operators and functions require binary
relations as arguments.  It is, however, perfectly possible to use $n$-ary
relations as values, or as arguments or results of functions.

\subsection{User-defined Types and Values}

\paragraph{Alias types}
Everything can be expressed using the elementary types and values that are
provided by \rscript.  However, for the purpose of documentation and
readability it is sometimes better to use a descriptive name as type
indication, rather than an elementary type. The type declaration
\begin{exam}
{\tt type $T_1$ = $T_2$}
\end{exam}
states that the new type name $T_1$ can be used everywhere instead of the
already defined type name $T_2$. For instance,
\begin{exam}\begin{verbatim}
type ModuleId = str
type Frequency = int
\end{verbatim}
\end{exam}
introduces two new type names {\tt ModuleId} and {\tt Frequency}, both an
alias for the type {\tt str}.
The use of type aliases is a good way to hide representation details.

\paragraph{Composite Types and Values}
In ordinary programming languages record types or classes exist to introduce a
new type name for a collection of related, named, values and to provide access
to the elements of such a collection through their name. In \rscript,
tuples with named elements provide this facility. The type declaration
\begin{exam}
{\tt type $T$ = <$T_1$ $F_1$ ,..., $T_n$ $F_n$>}
\end{exam}
introduces a new composite type $T$, with $n$ elements.  The $i$-th element
$T_i$ $N_i$ has type $T_i$ and field name $F_i$.
The common dot notation for field access is used to address an element of
a composite type. If $V$ is a variable of type $T$, then the $i$-th element
can be accessed by {\tt $V$.$F_i$}. For instance,\footnote{The variable
  declarations that appear on lines 2 and 3 of this example are explained
  fully in Section~\ref{SEC:Declarations}.}
\begin{exam}\begin{verbatim}
type Triple = <int left, str middle, bool right>
Triple TR = <3, "a", true>
str S = TR.middle
\end{verbatim}
\end{exam}
first introduces the composite type {\tt Triple} and defines the {\tt Triple} variable
{\tt TR}. Next, the field selection {\tt TR.middle} is used to define the
string {\tt S}.

\paragraph{Type equivalence}
An \rscript should be \emph{well-typed}, this means above all that identifiers
that are used in expressions have been declared, and that operations and
functions should have operands of the required type.  We use \emph{structural
equivalence} between types as criterion for type equality.
The equivalence of two types $T_1$ and $T_2$ can be determined as follows:

\begin{itemize}
\item Replace in both $T_1$ and $T_2$ all user-defined types by their
  definition until all user-defined types have been eliminated.  This may
  require repeated replacements.  This gives, respectively, $T_1'$ and $T_2'$.

\item If $T_1'$ and $T_2'$ are identical, then $T_1$ and $T_2$ are equal.
\item Otherwise $T_1$ and $T_2$ are not equal.
\end{itemize}

\section{Comprehensions}

We will use the familiar notation
\begin{exam}
  \verb@{@{\tt $E_1$, ..., $E_m$ | $G_1$, ..., $G_n$}\verb@}@
\end{exam}
to denote the construction of a bag consisting of the union of
successive values of the expressions $E_1 ,..., E_m$.  The values and the
generated bag are determined by  $E_1 ,..., E_m$ and the \emph{generators}
$G_1 ,..., G_n$.  $E$ is computed for all possible
combinations of values produced by the generators.

Each generator may introduce new variables
that can be used in subsequent generators as well as in the expressions  $E_1 ,..., E_m$.
A generator can use the variables introduced by preceding
generators.  Generators may enumerate all the values in a bag or
relation, they may perform a test, or they may assign a value to
variables.

\subsection{Generators}

\paragraph{Enumerator}
Enumerators generate all the values in a given bag or relation.
They come in two flavors: 

\begin{itemize}
\item {\tt $T$ $V$ : $E$}: the elements of the bag $B$ (of type {\tt bag[$T$]})
  that results from the evaluation
of expression $E$ are enumerated and subsequently assigned to the new variable $V$ of type $T$.

\item {\tt <$R_1$,~...,~$R_n$>~:~$E$}: the elements of the bag $B$ (of type
{\tt bag[<$T'_1$,...,$T'_n$>]}, where $T'_i$ is determined by the type of each
target $R_i$, see below) that results from the evaluation of expression $E$
are enumerated. The $i$-the element ($i=1,...,n$) of the resulting $n$-tuple
is subsequently combined with each target $R_i$ as follows:
\begin{itemize}
  \item If $R_i$ is a variable declaration of the form $T_i$ $V_i$, then the $i$-th element is assigned to $V_i$.
  \item If $R_i$ is an arbitrary expression $E_i$, then the value of
   the $i$-th element should be equal to the value of $E_i$. If they
   are unequal, computation continues with enumerating the next
   element of the bag or relation $B$.
\end{itemize}
  
\end{itemize}

\paragraph{Test}
A test is a boolean-valued expression. If the evaluation yields {\tt true}
this indicates that the current combination of generated values up to this test
is still as desired and execution continues with subsequent generators.  If
the evaluation yields {\tt false} this indicates that the current combination
of values is undesired, and that another combination should be tried.

\paragraph{Assignment}
Assignments assign a value to one or more variables and also come in two flavors:

\begin{itemize}

\item {\tt $T$ $V$ <- $E$}: assigns the value of expression $E$ to the new variable $V$ of type $T$.

\item {\tt <$R_1$, ..., $R_n$> <- $E$}: combines the elements of the $n$-tuple
resulting from the evaluation of expression $E$ with each $T_i$ as follows:

\begin{itemize}

\item If $R_i$ is a variable declaration of the form $T$ $V_i$, then the $i$-th element is assigned to $V_i$.
\item If $R_i$ is an arbitrary expression $E_i$, then the value of
   the $i$-th element should be equal to the value of $E_i$. If they
   are unequal, the assignment acts as a test that fails (see above).
\end{itemize}

\end{itemize}


\subsection{Examples of Comprehensions}

\paragraph{Example}

\verb@{X | int X : {1, 2, 3, 4, 5},  X >= 3}@ yields the bag \verb@{3,4,5}@.

\paragraph{Example}

\verb@{<X, Y> | int X :{1, 2, 3}, int Y :{2, 3, 4}, X >= Y}@ yields the relation
\verb@{<2, 2>, <3, 2>, <3, 3>}@.

\paragraph{Example}
\verb@{<Y, X> | <int X, int Y> :{<1,10>, <2,20>}}@ yields the inverse of
the given relation: \verb@{<10,1>, <20,2>}@.

\paragraph{Example}
\verb@{X, X * X | X : {1, 2, 3, 4, 5},  X >= 3}@ yields the bag \verb@{3,4,5,9,16,25}@.

\section{Declarations} \label{SEC:Declarations}

\subsection{Variable Declarations}
A variable declaration has the form 
\begin{exam}
{\tt $T$ $V$ = $E$}
\end{exam}
where $T$ is a type,
$V$ is a variable name, and $T$ is an expression that should have type
$T$. The effect is that the value of expression $E$ is assigned to
$V$ and can be used later on as $V$'s value. Double declarations are
not allowed.

As a convenience, also declarations without an initialization expression are
permitted and have the form 
\begin{exam}
{\tt $T$ $V$} 
\end{exam}
and only introduce the variable $V$.

\paragraph{Example} \verb@int max = 100@ declares the integer variable
{\tt max} with value {\tt 100}.

\paragraph{Example} The definition
\begin{exam}
\begin{verbatim}
rel[str,int] day = {<"mon", 1>, <"tue", 2>, <"wed",3>, 
                    <"thu", 4>, <"fri", 5>, <"sat",6>, <"sun",7>}
\end{verbatim}
\end{exam}
declares the variable {\tt day}, a relation that maps strings to integers.

\subsection{Local Variable Declarations}
Local variables can be introduced as follows:
\begin{exam}
{\tt $E$ where $T_1$ $V_1$ = $E_1$, ..., $T_n$ $V_n$ = $E_n$ end where}
\end{exam}
First the local variables $V_i$ are bound to their respective values
$E_i$, and then the value of expression $E$ is yielded.


\subsection{Function Declarations}
A function declaration has the form
\begin{exam}
{\tt $T$ $F$($T_1 ~ V_1$, ..., $T_n ~ V_n$) = $E$}
\end{exam}
Here $T$ is the result type of the function and this should be equal to the
type of the associated expression $E$.  Each $T_i$ $V_i$ represents a typed
formal parameter of the function. The formal parameters may occur in $E$ and
get their value when $F$ is invoked from another expression.

\paragraph{Example} The function declaration
\begin{exam}\begin{verbatim}
rel[int, int] invert(rel[int,int] R) = {<Y, X> | <int X, int Y> : R }
\end{verbatim}
\end{exam}
yields the inverse of the argument relation {\tt R}. For instance,
\verb@invert({<1,10>, <2,20>})@ yields \verb@{<10,1>, <20,2>}@.

\paragraph{Parameterized types in function declarations}
The types that occur in function declarations may also contain
\emph{type variables} that are written as {\tt \&} followed by an identifier.
 In this way functions can be defined for arbitrary
types.

\begin{sloppypar}
\paragraph{Example} The declaration
\begin{exam}\begin{verbatim}
rel[&T2, &T1] invert2(rel[&T1,&T2] R) = {<Y, X> | <&T1 X, &T2 Y> : R }
\end{verbatim}
\end{exam}
yields an inversion function that is applicable to any binary relation.
For instance,
\begin{itemize}
\item \verb@invert2({<1,10>, <2,20>})@ yields \verb@{<10,1>, <20,2>}@,
and 
\item \verb@invert2({<"mon", 1>, <"tue", 2>})@
yields \verb@{<1, "mon">, <2, "tue">}@.
\end{itemize}
\end{sloppypar}

\paragraph{Example} The function
\begin{exam}\begin{verbatim}
<&T2, &T1> swap(&T1 A, &T2 B) = <B, A>
\end{verbatim}
\end{exam}
can be used to swap the elements of pairs of arbitrary types.  For instance,
\begin{itemize}
\item \verb@swap(<1, 2>)@ yields \verb@<2,1>@ and 
\item \verb@swap(<"wed", 3>)@ yields \verb@<3, "wed">@.
\end{itemize}

\section{Assertions}
An assert statement may occur everywhere where a declaration is allowed.  It
has the form 
\begin{exam}
{\tt assert $L$: $E$}
\end{exam}
 where $L$ is a string that serves as a
label for this assertion, and $E$ is a boolean-value expression.  During
execution, a list of true and false assertions is maintained.  When the script
is executed as a \emph{test suite} (see Section~\ref{running}) a summary of this
information is shown to the user. When the script is executed in the standard
fashion, the assert statement has no affect.

\paragraph{Example}
\begin{exam}\begin{verbatim}
assert "Equality on Bags 1": {1, 2, 3, 1} == {3, 2, 1, 1}
\end{verbatim}
\end{exam}

\section{Equations}
It is also possible to define mutually dependent sets of equations:

\begin{exam}
{\tt equations \\
       \hspace*{0.5cm}initial \\
          \hspace*{1cm}$T_1$ $V_1$ init $I_1$\\
          \hspace*{1cm}  ... \\
          \hspace*{1cm}$T_n$ $V_n$ init $I_n$\\
       \hspace*{0.5cm}satisfy\\
          \hspace*{1cm}$V_1$ = $E_1$\\
          \hspace*{1cm}...\\
          \hspace*{1cm}$V_n$ = $E_n$\\
end equations}
\end{exam}

\noindent In the {\tt initial} section, the variables $V_i$ are declared and
initialized.
In the {\tt satisfy} section, the actual set of equations is given.
The expressions $E_i$ may refer to any of the variables 
  $V_i$ (and to any variables declared earlier).  This set of equations is
  solved by evaluating the expressions $E_i$, assigning their value to
  the corresponding variables $V_i$, and repeating this as long as the
  value of one of the variables was changed. This is typically used for
  solving a set of dataflow equations.

\paragraph{Example}
Equations can be used to define the transitive closure of a relation.
Recall that \[R+ = R \cup (R \circ R) \cup (R \circ R \circ R) \cup ... .\]
This can be expressed as follows.

\begin{exam}
\begin{verbatim}
rel[int,int] R =  {<1,2>, <2,3>, <3,4>}

equations
  initial
     rel[int,int] T init R
  satisfy
     T = T union (T o R)
end equations
\end{verbatim}
\end{exam}
The resulting value of {\tt T} is as expected:
\begin{exam}
\begin{verbatim}
 {<1,2>, <2,3>, <3,4>, <1, 3>, <2, 4>, <1, 4>}
\end{verbatim}
\end{exam}


\chapter{Built-in Operators} \label{SEC:operators}
The built-in operators can be subdivided in several broad categories:

\begin{itemize}
\item Operations on Booleans (Section~\ref{BO:bool}): logical operators ({\tt
  and}, {\tt or}, {\tt implies} and {\tt  not}).
\item Operations on integers (Section~\ref{BO:int}):
arithmetic operators ({\tt +}, {\tt -}, {\tt *}, and {\tt /}) and 
comparison operators ({\tt ==}, {\tt !=}, {\tt <}, {\tt <=}, {\tt >}, and {\tt >=}).
\item Operations on strings (Section~\ref{BO:str}):
comparison operators ({\tt ==}, {\tt !=}, {\tt <}, {\tt <=}, {\tt >}, and {\tt >=}).
\item operations on areas (Section~\ref{BO:area}).
comparison operators ({\tt ==}, {\tt !=}, {\tt <}, {\tt <=}, {\tt >}, and {\tt >=}).
\item Operations on bags or relations (Section~\ref{BO:bag-or-rel}):
membership tests ({\tt in}, {\tt notin}),
comparison operators ({\tt ==}, {\tt !=}, {\tt <}, {\tt <=}, {\tt >}, and {\tt
  >=}), and
construction operators ({\tt union}, {\tt inter}, \verb@\@).
\item Operations on relations (Section~\ref{BO:relations}):
composition ({\tt o}), Cartesian product ({\tt x}),
left and right image operators, and
transitive closures ({\tt +}, {\tt *}).
\end{itemize}

\noindent The following sections give detailed descriptions and examples of all built-in operators.

\section{Operations on Booleans} \label{BO:bool}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{bool}$_1$ \texttt{and} \emph{bool}$_2$ & yields {\tt true} if both arguments have the value true and
{\tt false} otherwise\\ \hline

\emph{bool}$_1$ \texttt{or} \emph{bool}$_2$ & yields {\tt true} if either argument has
                         the value {\tt true} and {\tt false} otherwise\\ \hline

\emph{bool}$_1$ \texttt{implies} \emph{bool}$_2$ & yields {\tt false} if
                             \emph{bool}$_1$ has the value {\tt true} and
                               \emph{bool}$_2$ has value {\tt false}, and
                         {\tt true} otherwise\\ \hline

{\tt not} \emph{bool} & yields true if \emph{bool} is {\tt false} and {\tt true} otherwise \\
\hline
\end{tabular}

\section{Operations on Integers} \label{BO:int}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{int}$_1$ {\tt ==} \emph{int}$_2$ & yields {\tt true} if both arguments are numerically equal and {\tt false}
otherwise\\ \hline

\emph{int}$_1$ {\tt !=} \emph{int}$_2$ & yields {\tt true} if both arguments are numerically unequal  and {\tt false}
otherwise\\ \hline

\emph{int}$_1$ {\tt <=} \emph{int}$_2$ & yields {\tt true} if \emph{int}$_1$ is numerically less than
or equal to \emph{int}$_2$ and {\tt false} otherwise\\ \hline

\emph{int}$_1$ {\tt <} \emph{int}$_2$ & yields {\tt true} if \emph{int}$_1$ is a numerically less than \emph{int}$_2$
and {\tt false} otherwise\\ \hline

\emph{int}$_1$ {\tt >=} \emph{int}$_2$ & yields {\tt true} if \emph{int}$_1$ is numerically greater
than or equal to \emph{int}$_2$  and {\tt false} otherwise\\ \hline

\emph{int}$_1$ {\tt >} \emph{int}$_2$ & yields {\tt true} if \emph{int}$_1$  is numerically greater than \emph{int}$_2$
and {\tt false} otherwise\\ \hline

\emph{int}$_1$ {\tt +} \emph{int}$_2$ & yields the arithmetic sum of
\emph{int}$_1$ and \emph{int}$_2$\\ \hline

\emph{int}$_1$ {\tt -} \emph{int}$_2$ & yields the arithmetic difference of
\emph{int}$_1$ and \emph{int}$_2$\\ \hline

\emph{int}$_1$ {\tt *} \emph{int}$_2$ & yields the arithmetic product of
\emph{int}$_1$ and \emph{int}$_2$\\ \hline

\emph{int}$_1$ {\tt /} \emph{int}$_2$ & yields the integer division of
\emph{int}$_1$ and \emph{int}$_2$ \\ \hline

\end{tabular}

\section{Operations on Strings} \label{BO:str}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline

\emph{str}$_1$ {\tt ==} \emph{str}$_2$ & yields {\tt true} if both arguments are equal and {\tt false}
otherwise\\ \hline

\emph{str}$_1$ {\tt !=} \emph{str}$_2$ & yields {\tt true} if both arguments are unequal  and {\tt false}
otherwise\\ \hline

\emph{str}$_1$ {\tt <=} \emph{str}$_2$ & yields {\tt true} if \emph{str}$_1$ is lexicographically less than
or equal to \emph{str}$_2$ and {\tt false} otherwise\\ \hline

\emph{str}$_1$ {\tt <} \emph{str}$_2$ & yields {\tt true} if \emph{str}$_1$ is a lexicographically less than \emph{str}$_2$
and {\tt false} otherwise\\ \hline

\emph{str}$_1$ {\tt >=} \emph{str}$_2$ & yields {\tt true} if \emph{str}$_1$ is lexicographically greater
than or equal to \emph{str}$_2$  and {\tt false} otherwise\\ \hline

\emph{str}$_1$ {\tt >} \emph{str}$_2$ & yields {\tt true} if \emph{str}$_1$  lexicographically greater than \emph{str}$_2$
and {\tt false} otherwise\\ \hline

\end{tabular}
\section{Operations on Areas} \label{BO:area}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{area}$_1$ {\tt ==} \emph{area}$_2$ & yields {\tt true} if both arguments
are identical and {\tt false}
otherwise\\ \hline

\emph{area}$_1$ {\tt !=} \emph{area}$_2$ & yields {\tt true} if both arguments are unequal  and {\tt false}
otherwise\\ \hline

\emph{area}$_1$ {\tt <=} \emph{area}$_2$ & yields {\tt true} if
\emph{area}$_1$ is textually contained in 
or equal to \emph{area}$_2$ and {\tt false} otherwise\\ \hline

\emph{area}$_1$ {\tt <} \emph{area}$_2$ & yields {\tt true} if \emph{area}$_1$
is strictly textually contained  in \emph{area}$_2$
and {\tt false} otherwise\\ \hline

\emph{area}$_1$ {\tt >=} \emph{area}$_2$ & yields {\tt true} if
\emph{area}$_1$ textually encloses or
or is equal to \emph{area}$_2$  and {\tt false} otherwise\\ \hline

\emph{area}$_1$ {\tt >} \emph{area}$_2$ & yields {\tt true} if \emph{area}$_1$
strictly textually encloses \emph{area}$_2$
and {\tt false} otherwise\\ \hline

\end{tabular}

\paragraph{Examples}

\begin{itemize}

 \item {\tt area("f", 11, 1, 11, 9)  < area("f", 10, 2, 12, 8)} yields {\tt
 true}.

 \item {\tt area("f", 10, 3, 11, 7)  < area("f", 10, 2, 11, 8)} yields {\tt
 true}.

 \item {\tt area("f", 10, 3, 11, 7)  < area("g", 10, 3, 11, 7)} yields {\tt
 false}.

\end{itemize}

\section{Operations on Bags or Relations} \label{BO:bag-or-rel}

\subsection{Membership Tests} \label{BO:member}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline

\emph{any} {\tt in} \emph{bag} & yields {\tt true} if \emph{any} occurs as element
in \emph{bag} and {\tt false} otherwise \\ \hline

\emph{any} {\tt notin} \emph{bag} & yields {\tt false} if \emph{any} occurs as
element in \emph{bag} and {\tt true} otherwise \\ \hline

\emph{tuple} {\tt in} \emph{rel} & yields {\tt true} if \emph{tuple} occurs as element in
\emph{rel}  and {\tt false} otherwise \\ \hline

\emph{tuple} {\tt notin} \emph{rel} & yields {\tt false} if \emph{tuple} occurs as
element in \emph{rel} and {\tt true} otherwise \\ \hline
\end{tabular}

\paragraph{Examples}

\begin{itemize}

\item \verb@3 in {1, 2, 3}@ yields {\tt true}.
\item \verb@4 in {1, 2, 3}@ yields {\tt false}.
\item \verb@3 notin {1, 2, 3}@ yields {\tt false}.
\item \verb@4 notin {1, 2, 3}@ yields {\tt true}.
\item \verb@<2,20> in {<1,10>, <2,20>, <3,30>}@ yields {\tt true}.
\item \verb@<4,40> notin {<1,10>, <2,20>, <3,30>}@ yields {\tt true}.

\end{itemize}

\paragraph{Note} If the first argument of these operators has type $T$, then
the second argument should have type {\tt bag[$T$]}.

\subsection{Comparisons} \label{BO:bag-comp}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{bag}$_1$ {\tt ==} \emph{bag}$_2$ & yields {\tt true} if both arguments are equal bags and {\tt false}
otherwise\\ \hline

\emph{bag}$_1$ {\tt !=} \emph{bag}$_2$ & yields {\tt true} if both arguments are unequal bags and {\tt false}
otherwise\\ \hline

\emph{bag}$_1$ {\tt <=} \emph{bag}$_2$ & yields {\tt true} if \emph{bag}$_1$ is a subset of \emph{bag}$_2$
and {\tt false} otherwise\\ \hline

\emph{bag}$_1$ {\tt <} \emph{bag}$_2$ & yields {\tt true} if \emph{bag}$_1$ is a
strict subset of \emph{bag}$_2$
and {\tt false} otherwise\\ \hline

\emph{bag}$_1$ {\tt >=} \emph{bag}$_2$ & yields {\tt true} if \emph{bag}$_1$  is a
superset of \emph{bag}$_2$
and {\tt false} otherwise\\ \hline

\emph{bag}$_1$ {\tt >} \emph{bag}$_2$ & yields {\tt true} if  \emph{bag}$_1$  is a strict superset of \emph{bag}$_2$
and {\tt false} otherwise\\ \hline 
\end{tabular}

\subsection{Construction} \label{BO:bag-cons}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{bag}$_1$ {\tt union} \emph{bag}$_2$ & yields the bag resulting from the union of the two arguments.
The number of occurrences of each element in the result is the {\bf maximum} of the number of occurrences of that element
in \emph{bag}$_1$  and \emph{bag}$_2$.
 \\ \hline

\emph{bag}$_1$ {\tt inter} \emph{bag}$_2$ & yields the bag resulting from the intersection of the two arguments.
The number of occurrences of each element in the result is the {\bf minimum} of the number of occurrences of that element
in \emph{bag}$_1$  and \emph{bag}$_2$.
 \\ \hline

\emph{bag}$_1$ \verb+\+ \emph{bag}$_2$ & yields the bag resulting from the difference of the two arguments.
The number of occurrences of each element in the result is the {\bf difference} of the number of occurrences of that element
in \emph{bag}$_1$  and \emph{bag}$_2$.
 \\ \hline

\end{tabular}

\paragraph{Examples}

\begin{itemize}
\item \verb@{1, 2, 3} union {4, 5, 6}@ yields \verb@{1, 2, 3, 4, 5, 6}@.
\item \verb@{1, 2, 3} union {1, 2, 3}@ yields  \verb@{1, 2, 3}@.
\item \verb@{1, 1, 2, 3} union {4, 4, 5, 6}@ yields \verb@{1, 1, 2, 3, 4, 4, 5, 6}@.

\item \verb@{1, 2, 3} inter {4, 5, 6}@ yields \verb@{ }@.
\item \verb@{1, 1, 2, 3} inter {1, 2, 3}@ yields  \verb@{1, 2, 3}@.

\item \verb@{1, 1, 2, 3}  \ {1, 2, 3}@ yields  \verb@{1}@.
\item \verb@{1, 1, 2, 3}  \ {4, 4, 5, 6}@ yields \verb@{1, 1, 2, 3}@.

\end{itemize}

\subsection{Miscellaneous} \label{BO:misc}
\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline

\verb@#@ \emph{bag} & yields the number of elements in \emph{bag}. \\ \hline
\verb@#@ \emph{rel} & yields the number of tuples in \emph{rel}. \\ \hline
\end{tabular}

\paragraph{Examples}

\begin{itemize}
\item \verb@#{1, 2, 3}@ yields {\tt 3}.
\item \verb@{<1,10>, <2,20>, <3,30>}@ yield {\tt 3}.
\end{itemize}

\section{Operations on Relations} \label{BO:relations}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline

\emph{rel}$_1$ {\tt o} \emph{rel}$_2$ & yields the relation resulting from the composition of the two arguments
 \\ \hline

\emph{bag}$_1$ {\tt x}~ \emph{bag}$_2$ & yields the relation resulting from the Cartesian product of the two arguments
 \\ \hline


\emph{rel} {\tt [-,} \emph{bag} {\tt ]} & yields the left image of the \emph{rel}
 \\ \hline

\emph{rel} {\tt [-,} \emph{elem} {\tt ]} & yields the left image of the \emph{rel}
 \\ \hline

\emph{rel} {\tt [} \emph{elem} {\tt ,-]} & yields the right image of \emph{rel}
 \\ \hline

\emph{rel} {\tt [} \emph{bag} {\tt ,-]} & yields the right image of \emph{rel}
 \\ \hline

\emph{bag} {\tt [} \emph{elem} {\tt ]} & yields the right image of \emph{rel}
 \\ \hline

\emph{rel} {\tt [} \emph{bag} {\tt ]} & yields the right image of \emph{rel}
 \\ \hline


\emph{rel} {\tt +} & yields the relation resulting from the transitive closure of
 \emph{rel}  \\ \hline

\emph{rel} {\tt *}  & yields the relation resulting from the reflexive transitive closure of
 \emph{rel}  \\ \hline

\end{tabular}

\paragraph{Composition: {\tt o}}

The composition operator combines two relations and can be defined as follows:

\begin{exam}
\begin{verbatim}
rel[&T1,&T3] compose(rel[&T1,&T2] R1, rel[&T2,&T3] R2) =
   {<V, Y> | <&T1 V, &T2 W> : R1, <&T2 X, &T3 Y> : R2, W == X }
\end{verbatim}
\end{exam}

\paragraph{Example}

\begin{itemize}
\item \verb@{<1,10>, <2,20>, <3,15>} o {<10,100>, <20,200>}@ yields  \verb@{<1,100>, <2,200>}@.
\end{itemize}


\paragraph{Cartesian product: {\tt x}}
The product operator combines two bags into a relation and can be defined as
follows:

\begin{exam}
\begin{verbatim}
rel[&T1,&T2] product(bag[&T1] B1, bag[&T2] B2) = 
   {<V, W> | &T1 V : B1, &T2 W : B2 }
\end{verbatim}
\end{exam}

\paragraph{Example}
\begin{itemize}
\item \verb@{1, 2, 3} x {9}@ yields \verb@{<1, 9>, <2, 9>, <3, 9>}@.
\end{itemize}

\paragraph{Left image: {\tt [-,~]}}

Taking the left image of a relation amounts to selecting
some elements from the domain of a relation.

The \emph{left} image operator takes a relation and an element {\tt E} and
produces a bag consisting of all elements {\tt E}$_i$ in the domain of the relation
that occur in tuples of the form {\tt <E$_i$, E>}. It can be defined as
follows:

\begin{exam}
\begin{verbatim}
bag[&T1] left-image(rel[&T1,&T2] R, &T2 E) = 
   { V | <&T1 V, &T2 W> : R, W == E }
\end{verbatim}
\end{exam}

The left image operator can be extended to take a bag of elements as second
element instead of a single element:

\begin{exam}
\begin{verbatim}
bag[&T1] left-image(rel[&T1,&T2] R, bag[&T2] B) = 
   { V | <&T1 V, &T2 W> : R, W in B }
\end{verbatim}
\end{exam}

\paragraph{Examples}
Assume that {\tt Rel} has value
\verb@{<1,10>, <2,20>, <1,11>, <3,30>, <2,21>}@ in the following examples.
\begin{itemize}
\item \verb@Rel[-,10]@ yields  \verb@{1}@.
\item \verb@Rel[-,{10}]@ yields  \verb@{1}@.
\item \verb@Rel[-,{10, 20}]@ yields \verb@{1, 2}@.
\end{itemize}

\paragraph{Right image: {\tt [ ]} and {\tt [~,-]}}
Taking the right image of a relation amounts to selecting
some elements from the range of a relation.

The \emph{right} image operator takes a relation and an element {\tt E} and
produces a bag consisting of all elements {\tt E}$_i$ in the range of the relation
that occur in tuples of the form {\tt <E, E$_i$>}. It can be defined as
follows:

\begin{exam}
\begin{verbatim}
bag[&T2] right-image(rel[&T1,&T2] R, &T1 E) = 
   { W | <&T1 V, &T2 W> : R, V == E }
\end{verbatim}
\end{exam}

The right image operator can be extended to take a bag of elements as second
element instead of a single element:

\begin{exam}
\begin{verbatim}
bag[&T2] right-image(rel[&T1,&T2] R, bag[&T1] B) = 
   { W | <&T1 V, &T2 W> : R, V in B}
\end{verbatim}
\end{exam}

\paragraph{Examples}
Assume that {\tt Rel} has value \verb@{<1,10>, <2,20>, <1,11>, <3,30>, <2,21>}@  in the following examples.
\begin{itemize}
\item \verb@Rel[1]@ yields \verb@{10, 11}@.
\item \verb@Rel[{1}]@ yields \verb@{10, 11}@.
\item \verb@Rel[{1, 2}]@ yields \verb@{10, 11, 20, 21}@.
\end{itemize}

\noindent These expressions are abbreviations for, respectively 
\verb@Rel[1,-]@,
\verb@Rel[{1},-]@. 
and 
\verb@Rel[{1, 2},-]@.

\chapter{Built-in Functions} \label{SEC:functions}

The built-in functions can be subdivided in several broad categories:

\begin{itemize}
\item Elementary functions on bags and relations
  (Section~\ref{elementary-functions}): identity ({\tt id}), inverse ({\tt
  inv}), complement ({\tt compl}), and powerset ({\tt power0}, {\tt power1}).

\item Extraction from relations (Section~\ref{extraction}):
domain ({\tt domain}), range ({\tt range}), and carrier ({\tt carrier}).

\item Restrictions and exclusions on relations (Section~\ref{restrictions}):
domain restriction ({\tt domainR}), range restriction ({\tt rangeR}),
carrier restriction ({\tt carrierR}),
domain exclusion ({\tt domainX}), range exclusion ({\tt rangeX}), and carrier
exclusion ({\tt carrierX}).

\item Functions on tuples (Section~\ref{tuples}):
first element ({\tt first}),
and second element ({\tt second}).

\item Relations viewed as graphs (Section~\ref{relations-as-graphs}):
the root elements ({\tt top}),
the leaf elements ({\tt bottom}),
reachability with restriction ({\tt reachR}), and
reachability with exclusion ({\tt reachX}).

\item Functions on areas (Section~\ref{areas}):
file name ({\tt filename}),
beginning line ({\tt beginline}),
first column ({\tt begincol}),
ending line ({\tt endline}), and
ending column ({\tt endcol}).

\item Functions on bags of integers (Section~\ref{bags-of-integers}):
sum ({\tt sum}), average ({\tt average}), maximum ({\tt max}), and minimum
({\tt min}).

\end{itemize}

\noindent The following sections give detailed descriptions and examples of all built-in functions.

\newcommand{\function}[5]{\subsection{#1: {\tt #2}}\label{BI:#2}
Definition:
\begin{quote}
#3
\end{quote}
#4
Example(s):
\begin{itemize}
#5
\end{itemize}
}

\newcommand{\functiona}[2]{\subsection{#1: {\tt #2}}\label{BI:#2}
Definition:}

\section{Elementary Functions on Bags and Relations}
\label{elementary-functions}


\functiona{Identity Relation}{id}
\begin{exam}
\begin{verbatim}
rel[&T, &T] id(bag[&T] B) = { <X, X> | &T X : B}
\end{verbatim}
\end{exam}
{Yields the relation that results from transforming
each element in {\tt B} into a pair with that element as first and
second element.
}
{Examples: 
\begin{itemize}
\item \verb@id({1,2,3})@ yields \verb@{<1,1>, <2,2>, <3,3>}@.
\item \begin{sloppypar} 
  \verb@id({"mon", "tue", "wed"})@ yields \verb@{<"mon","mon">, <"tue","tue">, <"wed","wed">}@.\end{sloppypar}
\end{itemize}
}

\functiona{Inverse of a Relation}{inv}
\begin{exam}
\begin{verbatim}
 rel[&T2, &T1] inv (rel[&T1, &T2] R) = { <Y, X> | <&T1 X, &T2 Y> : R }
\end{verbatim}
\end{exam}
{ Yields the relation that is the inverse of the
argument relation {\tt R}, i.e. the relation in which the elements of all
tuples in {\tt R} have been
interchanged.
}
{Example: \begin{itemize}
\item \verb@inv({<1,10>, <2,20>})@ yields \verb@{<10,1>,<20,2>}@.
\end{itemize}
}
\functiona{Complement of a Relation}{compl}
\begin{exam}
\begin{verbatim}
rel[&T1, &T2] compl(rel[&T1, &T2] R) = (domain(R) x range(R)) \ R}
\end{verbatim}
\end{exam}
{ Yields the relation that is the complement of the
argument relation {\tt R}, using the carrier set of {\tt R} as universe.
}
{Example:
\begin{itemize}
\item \verb@compl({<1,10>}@  yields \verb@{<1, 1>, <10, 1>, <10, 10>}@.
\end{itemize}
}
%%----
\functiona{Powerset of a Bag}{power0}
\begin{exam}
\begin{verbatim}
bag[bag[&T]] power0(bag[&T] B) = primitive
\end{verbatim}
\end{exam}
{ Yields the powerset of bag {\tt B} (including the empty bag).}
{Example:
\begin{itemize}
\item \verb@power0({1, 2, 3, 4})@ yields 
\begin{exam}
\begin{verbatim}
  { {}, {1}, {2}, {3}, {4},{1,2}, {1,3}, {1,4}, {2,3}, {2,4}, {3,4},
    {1,2,3}, {1,2,4}, {1,3,4}, {2,3,4}, {1,2,3,4}}
\end{verbatim}
\end{exam}
\end{itemize}
}
%%----
\functiona{Powerset of a Bag}{power1}
\begin{exam}
\begin{verbatim}
bag[bag[&T]] power1(bag[&T] B) = primitive
\end{verbatim}
\end{exam}
{ Yields the powerset of bag {\tt B} (excluding the empty bag).}
{Example:
\begin{itemize}
\item \verb@power1({1, 2, 3, 4})@ yields 
\begin{exam}
\begin{verbatim}
{ {1}, {2}, {3}, {4},{1,2}, {1,3}, {1,4}, {2,3}, {2,4}, {3,4},
  {1,2,3}, {1,2,4}, {1,3,4}, {2,3,4}, {1,2,3,4}}
\end{verbatim}
\end{exam}
\end{itemize}
}
%%----
\section{Extraction from Relations} \label{extraction}
%%----
\functiona{Domain of a Relation}{domain}
\begin{exam}
\begin{verbatim}
bag[&T1] domain (rel[&T1,&T2] R) = { X | <&T1 X, &T2 Y> : R }
\end{verbatim}
\end{exam}
{Yields the bag that results from taking
the first element of each tuple in relation {\tt R}.
}
{Examples:
\begin{itemize}
\item \verb@domain({<1,10>, <2,20>})@ yields \verb@{1, 2}@.
\item \verb@domain({<"mon", 1>, <"tue", 2>})@ yields \verb@{"mon", "tue"}@.
\end{itemize}
}
%%----
\functiona {Range of a Relation}{range}
\begin{exam}
\begin{verbatim}
bag[&T2] range (rel[&T1,&T2] R) = { Y | <&T1 X, &T2 Y> : R }
\end{verbatim}
\end{exam}
{Yields the bag that results from taking
the second element of each tuple in relation {\tt R}.
}
{Examples:
\begin{itemize}
\item \verb@range({<1,10>, <2,20>})@ yields \verb@{10, 20}@.
\item \verb@range({<"mon", 1>, <"tue", 2>})@ yields \verb@{1, 2}@.
\end{itemize}
}
%%----
\functiona {Carrier of a Relation}{carrier}
\begin{exam}
\begin{verbatim}
bag[&T]  carrier (rel[&T,&T] R) = domain(R) union range(R)
\end{verbatim}
\end{exam}
{Yields the bag that results from taking
the first and  second element of each tuple in the relation {\tt R}.
Note that the domain and range type of {\tt R} should be the same.
}
{Example:
\begin{itemize}
\item \verb@carrier({<1,10>, <2,20>})@ yields \verb@{1, 10, 2, 20}@.
\end{itemize}
}
%%----
\section{Restrictions and Exclusions on Relations} \label{restrictions}
%%---
\functiona{Domain Restriction of a Relation}{domainR}
\begin{exam}
\begin{verbatim}
rel[&T1,&T2] domainR (rel[&T1,&T2] R, Bag[&T1] B) =
   { <X, Y> | <&T1 X, &T2 Y> : R, X in B }
\end{verbatim}
\end{exam}
{ Yields a relation identical to the relation {\tt R}
  but only containing tuples whose first element occurs in bag {\tt B}.
}
{Example:
\begin{itemize}
\item \verb@domainR({<1,10>, <2,20>, <3,30>}, {3, 1}@ yields \verb@{<1,10>, <3,30>}@.
\end{itemize}
}
%%---
\functiona{Range Restriction of a Relation}{rangeR}
\begin{exam}
\begin{verbatim}
rel[&T1,&T2] rangeR (rel[&T1,&T2] R, Bag[&T2] B) =
   { <X, Y> | <&T1 X, &T2 Y> : R, Y in B }
\end{verbatim}
\end{exam}
{ Yields a relation identical to relation {\tt R} but only containing tuples
  whose second element occurs in bag {\tt B}.
}
{Example:
\begin{itemize}
 \item \verb@rangeR({<1,10>, <2,20>, <3,30>}, {30, 10}@ yields \verb@{<1,10>, <3,30>}@.
\end{itemize}
}
%%---
\functiona{Carrier Restriction of a Relation}{carrierR}
\begin{exam}
\begin{verbatim}
rel[&T,&T] carrierR (rel[&T,&T] R, Bag[&T] B) = 
   { <X, Y> | <&T X, &T Y> : R, X in B, Y in B }
\end{verbatim}
\end{exam}
{ Yields a relation identical to relation {\tt R}
  but only containing tuples whose first and second element occur in bag {\tt
    B}.
}
{Example:
\begin{itemize}
 \item \verb@carrierR({<1,10>, <2,20>, <3,30>}, {10, 1, 20})@ yields \verb@{<1,10>}@.
\end{itemize}
}
%%---
\functiona{Domain Exclusion of a Relation}{domainX}
\begin{exam}
\begin{verbatim}
rel[&T1,&T2] domainX (rel[&T1,&T2] R, Bag[&T1] B) =
   { <X, Y> | <&T1 X, &T2 Y> : R, X notin B }
\end{verbatim}
\end{exam}
{ Yields a relation identical to relation {\tt R}
  but with all tuples removed whose first element occurs in bag {\tt B}.}
{Example:
\begin{itemize}
\item \verb@domainX({<1,10>, <2,20>, <3,30>}, {3, 1})@ yields \verb@{<2, 20>}@.
\end{itemize}
}
%%---
\functiona{Range Exclusion of a Relation}{rangeX}
\begin{exam}
\begin{verbatim}
rel[&T1,&T2] rangeX (rel[&T1,&T2] R, Bag[&T2] B) =
   { <X, Y> | <&T1 X, &T2 Y> : R, Y notin B }
\end{verbatim}
\end{exam}
{ Yields a relation identical to relation {\tt R} but with all tuples removed
  whose  second element occurs in bag {\tt B}.}
{Example:
\begin{itemize}
 \item \verb@rangeX({<1,10>, <2,20>, <3,30>}, {30, 10})@ yields \verb@{<2, 20>}@.
\end{itemize}
}
%%---
\functiona{Carrier Exclusion of a Relation}{carrierX}
\begin{exam}
\begin{verbatim}
rel[&T,&T] carrierX (rel[&T,&T] R, Bag[&T] B) =
   { <X, Y> | <&T1 X, &T2 Y> : R, X notin B, Y notin B }
\end{verbatim}
\end{exam}
{ Yields a relation identical to relation {\tt R}
  but with all tuples removed whose first or second element occurs in bag {\tt
    B}.}
{Example:
\begin{itemize}
 \item \verb@carrierX({<1,10>, <2,20>, <3,30>}, {10, 1, 20})@ yields \verb@{<3,30>}@.
\end{itemize}
}
%%---
\section{Tuples} \label{tuples}
%%---
\functiona{First Element of a Tuple}{first}
\begin{exam}
\begin{verbatim}
&T1 first(<&T1, &T2> P) = primitive
\end{verbatim}
\end{exam}
{ Yields the first element of the tuple {\tt P}.}
{Examples:
\begin{itemize}
\item \verb@first(<1, 10>)@ yields {\tt 1}.
\item \verb@first(<"mon", 1>)@ yields {\tt "mon"}.
\end{itemize}
}
%%---
\functiona{Second Element of a Tuple}{second}
\begin{exam}
\begin{verbatim}
&T2 second(<&T1, &T2> P) = primitive
\end{verbatim}
\end{exam}
{ Yields the second element of the tuple {\tt P}.}
{Examples:
\begin{itemize}
\item \verb@second(<1, 10>)@ yields {\tt 10}.
\item \verb@second(<"mon", 1>)@ yields {\tt 1}.
\end{itemize}
}
%%---
\section{Relations viewed as graphs} \label{relations-as-graphs}
%%---
\functiona {Top of a Relation}{top}
\begin{exam}
\begin{verbatim}
bag[&T] top(rel[&T, &T] R) = domain(R) \ range(R)
\end{verbatim}
\end{exam}
{Yields the bag of all roots when the relation {\tt R} is
viewed as a graph. Note that the domain and range type of {\tt R} should be the same.
}
{Example:
\begin{itemize}
\item \verb@top({<1,2>, <1,3>, <2,4>, <3,4>})@ yields \verb@{1}@.
\end{itemize}
}
%%---
\functiona{Bottom of a Relation}{bottom}
\begin{exam}
\begin{verbatim}
bag[&T] bottom(rel[&T,&T] R) = range(R) \ domain(R)
\end{verbatim}
\end{exam}
{Yields the bag of all leaves when the relation {\tt R} is
viewed as a graph. Note that the domain and range type of {\tt R} should be
the same.
}
{Example:
\begin{itemize}
\item \verb@bottom({<1,2>, <1,3>, <2,4>, <3,4>})@ yields \verb@{4}@.
\end{itemize}
}
%%---
\functiona{Reachability with Restriction}{reachR}
\begin{exam}
\begin{verbatim}
rel[&T,&T] reachR( bag[&T] Start, bag[&T] Restr, rel[T,T] Rel) =
   domainR(Rel, Start) o carrierR(Rel, Restr)+
\end{verbatim}
\end{exam}
{ Yields the relation that describes
which elements can be reached from  bag {\tt Start} using the relation {\tt Rel}, such that only elements in
bag {\tt Restr} are used.
}
{Example:
\begin{itemize}
\item  \verb@reachR({1}, {1, 2, 3}, {<1,2>, <1,3>, <2,4>, <3,4>})@ yields \verb@{<1,2>, <1, 3>}@.
\end{itemize}
}
%%---
\functiona{Reachability with Exclusion}{reachX}
\begin{exam}
\begin{verbatim}
rel[&T,&T] reachX( bag[&T] Start, bag[&T] Excl, rel[T,T] Rel) =
   domainR(Rel, Start) o carrierX(Rel, Excl)+
\end{verbatim}
\end{exam}
{ Yields the relation that describes
which elements can be reached from  bag {\tt Start} using the relation {\tt Rel}, such that no elements in
bag {\tt Excl} are used.
}
{Example:
\begin{itemize}
\item  \verb@reachX({1}, {2}, {<1,2>, <1,3>, <2,4>, <3,4>})@ yields  \verb@{<1,3>, <1, 4>}@.
\end{itemize}
}
%%---
\section{Functions on Areas} \label{areas}
%%---
\functiona{File Name of an Area}{filename}
\begin{exam}
\begin{verbatim}
str filename(area A) = primitive
\end{verbatim}
\end{exam}
{Yields the file name of area {\tt A}.}
{ Example:
\begin{itemize}
\item \verb@filename(area("pico1.trm",5,2,6,8))@ yields {\tt "pico1.trm"}.
\end{itemize}
}
%%----
\functiona{Beginning Line of an Area}{beginline}
\begin{exam}
\begin{verbatim}
int beginline(area A) = primitive
\end{verbatim}
\end{exam}
{Yields the first line of area {\tt A}.}
{ Example:
\begin{itemize}
\item \verb@beginline(area("pico1.trm",5,2,6,8))@ yields {\tt 5}.
\end{itemize}
}
%%----
\functiona{First Column of an Area}{begincol}
\begin{exam}
\begin{verbatim}
int begincol(area A) = primitive
\end{verbatim}
\end{exam}
{Yields the first column of area {\tt A}.}
{ Example:
\begin{itemize}
\item \verb@begincol(area("pico1.trm",5,2,6,8))@ yields {\tt 2}.
\end{itemize}
}
%%----
\functiona{Ending Line of an Area}{endline}
\begin{exam}
\begin{verbatim}
int endline(area A) = primitive
\end{verbatim}
\end{exam}
{Yields the last line of area {\tt A}.}
{ Example:
\begin{itemize}
\item \verb@endline(area("pico1.trm",5,2,6,8))@ yields {\tt 6}.
\end{itemize}
}
%%----
\functiona{Ending Column of an Area}{endcol}
\begin{exam}
\begin{verbatim}
int endcol(area A) = primitive
\end{verbatim}
\end{exam}
{Yields the last column of area {\tt A}.}
{ Example:
\begin{itemize}
\item \verb@endcol(area("pico1.trm",5,2,6,8))@ yields {\tt 8}.
\end{itemize}
}
%%----
\section{Functions on Bags of Integers} \label{bags-of-integers}
%%----
\functiona{Sum of a Bag of Integers}{sum}
\begin{exam}
\begin{verbatim}
int sum(bag[int] B) = primitive
\end{verbatim}
\end{exam}
{Yields the sum of the integers in bag {\tt B}.}
{Example:
\begin{itemize}
\item \verb@sum({1, 2, 3})@ yields {\tt 6}.
\end{itemize}
}
%%----
\functiona{Average of a Bag of Integers}{average}
\begin{exam}
\begin{verbatim}
int average(bag[int] B) = sum(B)/(#B)
\end{verbatim}
\end{exam}
{Yields the average of the integers in bag {\tt B}.}
{Example:
\begin{itemize}
\item \verb@average({1, 2, 3})@ yields {\tt 3}.
\end{itemize}
}
%%----
\functiona{Maximum of a Bag of Integers}{max}
\begin{exam}
\begin{verbatim}
int max(bag[int] B) = primitive
\end{verbatim}
\end{exam}
{Yields the largest integer in bag {\tt B}.}
{Example:
\begin{itemize}
\item \verb@max({1, 2, 3})@ yields {\tt 3}.
\end{itemize}
}
%%----
\functiona{Minimum of a Bag of Integers}{min}
\begin{exam}
\begin{verbatim}
int min(bag[int] B) = priimtive
\end{verbatim}
\end{exam}
{Yields the smallest integer in bag {\tt B}.}
{Example:
\begin{itemize}
\item \verb@min({1, 2, 3})@ yields {\tt 1}.
\end{itemize}
}
%%----
\newpage
\chapter{Larger Examples} \label{SEC:larger-examples}


\section{Analyzing the Call Structure of an Application}
You may now want to reread the example of call graph analysis given earlier in
Chapter~\ref{SEC:motivating-example}.

\section{Analyzing the Component Structure of an Application}
A frequently occurring problem is that we know the call
relation of a system but that we want to understand it at the component level
rather than at the procedure level. If it is known to which component each
procedure belongs, it is possible to \emph{lift} the call relation to the
component level as proposed in \cite{Krikhaar99}.

First, introduce new types to denote procedure calls as well as components of a system:

\begin{exam}\begin{verbatim}
type proc = str
type comp = str
\end{verbatim}
\end{exam}

\noindent Given a calls relation {\tt Calls2}, the next step is to define the
components of the system and to define a {\tt PartOf} relation between procedures and
components.

\begin{exam}\begin{verbatim}
rel[proc,proc] Calls2 = {<"main", "a">, <"main", "b">, <"a", "b">, 
                         <"a", "c">, <"a", "d">, <"b", "d">}

bag[comp] Components = {"Appl", "DB", "Lib"}

rel[proc, comp] PartOf = {<"main", "Appl">, <"a", "Appl">, <"b", "DB">,
                          <"c", "Lib">, <"d", "Lib">}
\end{verbatim}
\end{exam}

\noindent Actual lifting, amounts to translating each call between procedures by a call between components.
This is achieved by the following function {\tt lift}:

\begin{exam}
\begin{verbatim}
rel[comp,comp] lift(rel[proc,proc] aCalls,  rel[proc,comp] aPartOf) =
   { <C1, C2> | <proc P1, proc P2> : aCalls, 
                <comp C1, comp C2> : aPartOf[P1] x aPartOf[P2]
   }
\end{verbatim}
\end{exam}

\noindent In our example, the lifted call relation between components is obtained by

\begin{exam}\begin{verbatim}
rel[comp,comp] ComponentCalls = lift(Calls2, PartOf, Components)
\end{verbatim}
\end{exam}
and has as value:
\begin{exam}\begin{verbatim}
{<"DB", "Lib">, <"Appl", "Lib">, <"Appl", "DB">, <"Appl", "Appl">}
\end{verbatim}
\end{exam}

\noindent The relevant relations for this example are shown in Figure ~\ref{FIG:parts}.


\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/parts.eps,width=13cm}
\vspace*{-12.5cm}
\end{center}
\hrulefill
\caption{\label{FIG:parts} (a) {\tt Calls2}; (b) {\tt PartOf}; (c) {\tt ComponentCalls}}
\end{figure}

\section{Analyzing the Structure of Java Systems}

\begin{figure}[tb]
{\small
\begin{verbatim}
package CH.ifa.draw.standard;

import java.awt.Point;
import CH.ifa.draw.framework.*;
/**
 * A LocatorHandle implements a Handle by delegating the location requests to
 * a Locator object.
 */
public class LocatorHandle extends AbstractHandle {
    private Locator       fLocator;
    /**
     * Initializes the LocatorHandle with the given Locator.
     */
    public LocatorHandle(Figure owner, Locator l) {
        super(owner);
        fLocator = l;
    }
    /**
     * Locates the handle on the figure by forwarding the request
     * to its figure.
     */
    public Point locate() {
        return fLocator.locate(owner());
    }
}
\end{verbatim} 
\hrulefill}
\caption{\label{FIG:LocatorHandle}The class {\tt LocatorHandle} from JHotDraw 5.2}
\end{figure}

Now we consider the analysis of Java systems (inspired by \cite{BNL03}).
Suppose that the type {\tt class} is defined as follows
\begin{exam}\begin{verbatim}
type class = str
\end{verbatim}
\end{exam}
and that the following relations are available about a Java application:

\begin{itemize}

\item {\tt rel[class,class] CALL}: If {\tt <C$_1$, C$_2$>} is an element of {\tt CALL}, then
some method of {\tt C$_2$} is called from {\tt C$_1$}.

\item {\tt rel[class,class] INHERITANCE}: If {\tt <C$_1$, C$_2$>} is an element of {\tt INHERITANCE},
then class {\tt C$_1$} either extends class {\tt C$_2$} or {\tt C$_1$}
implements interface {\tt C$_2$}.

\item {\tt rel[class,class] CONTAINMENT}: If {\tt <C$_1$, C$_2$>} is an element of {\tt CONTAINMENT},
then one of the attributes of class  {\tt C$_1$} is of type {\tt C$_2$}.

\end{itemize}

To make this more explicit, consider the class {\tt LocatorHandle} from the
JHotDraw application (version 5.2) as shown in Figure~\ref{FIG:LocatorHandle}.
It leads to the addition to the above relations of the following tuples:

\begin{itemize}
\item {\tt CALL}: {\tt <"LocatorHandle", "AbstractHandle">} and {\tt <"LocatorHandle", "Locator">}.
\item {\tt INHERITANCE}:     {\tt <"LocatorHandle",  "AbstractHandle">}.
\item {\tt CONTAINMENT}:     {\tt <"LocatorHandle",  "Locator">}.
\end{itemize}

\paragraph{Classes in Cycles}
Cyclic structures in object-oriented systems makes understanding hard.
Therefore it is interesting to spot classes that occur as part of a cyclic
dependency.  Here we determine cyclic uses of classes that include calls,
inheritance and containment. This is achieved as follows:

\begin{exam}\begin{verbatim}
rel[class,class] USE = CALL union CONTAINMENT union INHERITANCE
bag[str] ClassesInCycle =
   {C1 | <class C1, class C2> : USE+, C1 == C2}
\end{verbatim}
\end{exam}
First, we define the {\tt USE} relation as the union of the three avaliable
relations {\tt CALL}, {\tt CONTAINMENT} and {\tt INHERITANCE}. Next, we consider all
pairs {\tt <C1, C2>} in the transitive closure of the {\tt USE} relation such
{\tt C1} and {\tt C2} are equal.  Those are precisely the cases of a class with a cyclic
dependency on itself.

Probably, we do not only want to know which classes occur in a cyclic
dependency, but we also want to know which classes are involved in such a
cycle. In other words, we want to associate with each class a bag of classes
that are responsible for the cyclic dependency. This can be done as follows.

\begin{exam}\begin{verbatim}
rel[class,class] USE = CALL union CONTAINMENT union INHERITANCE
bag[class] CLASSES = carrier(USE)
rel[class,class] USETRANS = USE+
rel[class,bag[class]] ClassCycles = 
   {<C, USETRANS[C]> | class C : CLASSES, <C, C> in USETRANS }
\end{verbatim}
\end{exam}
First, we introduce two new shorthands: {\tt CLASSES} and {\tt USETRANS}.  Next,
we consider all classes {\tt C} with a cyclic dependency and add the pair {\tt
<C, USETRANS[C]>} to the relation {\tt ClassCycles}.  Note that {\tt
USETRANS[C]} is the right image of the relation {\tt USETRANS} for element
{\tt C}, i.e., all classes that can be called transitively from class {\tt C}.

\section{Finding Uninitialized and Unused Variables in a Program}

Consider the following program in the toy language Pico:
\footnote{This is an extended version of the example presented earlier
  in~\cite{KlintIWPC03}.}

\begin{verbatim}
[ 1] begin declare x : natural, y : natural,
[ 2]              z : natural, p : natural;
[ 3]  x := 3;
[ 4]  p := 4;
[ 5]  if q then
[ 6]        z := y + x
[ 7]  else
[ 8]        x := 4
[ 9]  fi;
[10]  y := z
[11] end
\end{verbatim}

Inspection of this program learns that some of the variables are being used
before they have been initialized.  The variables in question are {\tt q}
(line 5), {\tt y} (line 6), and {\tt z} (line 10). It is also clear that
variable {\tt p} is initialized (line 4), but is never used.  How can we
automate these kinds of analysis?

Recall from Section~\ref{SEC:Introduction} that we follow extract-enrich-view
paradigm to approach such a problem.

The first step is to determine which elementary facts we need about the
program.  For this and many other kinds of program analysis, we need at least
the following:

\begin{itemize}
\item The \emph{control flow graph} of the program. We represent it by a relation
{\tt PRED} (for predecessor) which relates each statement with each
predecessors.

\item The \emph{definitions} of each variable, i.e., the program statements where a
  value is assigned to the variable. It is represented by the relation {\tt
  DEFS}.

\item The \emph{uses} of each variable, i.e., the program statements where the
  value of the variable is used.  It is represented by the relation {\tt
  USES}.
\end{itemize}

In this example, we will use line numbers to identify the statements in the
program.\footnote{In Section~\ref{SEC:UsingAreas}, we will use areas to represent statements.}

Assuming that there is a tool to extract the above information from a program text,
we get the following for the above example:

\begin{exam}
\begin{verbatim}
type stat = int
type var = str
stat ROOT = 1
rel[stat,stat] PRED = {<1,3>, <3,4>, <4,5>, <5,6>, <5,8>, <6,10>, <8,10>}
rel[stat,var] DEFS = {<3,"x">, <4,"p">, <6,"z">, <8,"x">, <10,"y">}
rel[stat,var] USES = {<5,"q">, <6,"y">, <6,"x">, <10,"z">}
\end{verbatim}
\end{exam}

This concludes the extraction phase. Next, we have to enrich these basic
facts to obtain the unitialized variables in the program. 

So, when is a variable \emph{V} in some statement \emph{S} unitialized?  If we
execute the program (starting in {\tt ROOT}), there may be several possible
execution path that can reach statement \emph{S}.  All is well if \emph{all}
these execution path contain a definition of \emph{V}.  However, if one or
more of these path do \emph{not} contain a definition of \emph{V}, then
\emph{V} may be uninitialized in statement \emph{S}. This can be formalized as
follows:
\begin{exam}
\begin{verbatim}
rel[stat,var] UNINIT = 
   { <S, V> | <stat S, var V>: USES, 
              <ROOT, S> in reachX({ROOT}, DEFS[-,V], PRED)
   }
\end{verbatim}
\end{exam}

\noindent We analyze this definition in detail:
\begin{itemize}
\item {\tt <stat S, var V> : USES} enumerates all tuples in the {\tt USES} relation.
In other words, we consider the use of each variable in turn.

\item {\tt <ROOT, S> in reachX({ROOT}, DEFS[-,V], PRED)} is a test that
  determines whether statement {\tt S} is reachable from the {\tt ROOT}
  without encountering a definition of variable {\tt V}.
  \begin{itemize}
    \item {\tt \{ROOT\}} represents the initial set of nodes from which all
    path should start.
    \item {\tt DEFS[-,V]} yields the set of all statements in which a definition
    of variable {\tt V} occurs. These nodes form the exclusion set for
    {\tt reachX}: no path will be extended beyond an element in this set.
    \item {\tt PRED} is the relation for which the reachability has to be
    determined.
    \item The result of  {\tt reachX({ROOT}, DEFS[-,V], PRED)} is a relation
    that contains all pairs of nodes that are reachable from the
    {\tt ROOT} (as well as all intermediate steps on each path).
    \item Finally, {\tt <ROOT, S> in reachX({ROOT}, DEFS[-,V], PRED)} tests
    whether statement {\tt S} can be reached from the {\tt ROOT}.
  \end{itemize}
\item The net effect is that {\tt UNINIT} will only contain pairs
that satisfy the test just described.
\end{itemize}

When we execute the resulting \rscript (i.e., the declarations of {\tt ROOT},
{\tt PRED}, {\tt DEFS}, {\tt USES} and {\tt UNINIT}), we get as value
for {\tt UNINIT}:

\begin{exam}
\begin{verbatim}
 {<5, "q">, <6, "y">, <10, "z">}
\end{verbatim}
\end{exam}
and this is in concordance with the informal analysis given at the beginning of this
example.

As a bonus, we can also determine the \emph{unused} variables in a
program, i.e., variables that are defined but are used nowhere.
This is done as follows:
\begin{exam}
\begin{verbatim}
bag[var] UNUSED = range(DEFS) \ range(USES)
\end{verbatim}
\end{exam}
Taking the range of the relations {\tt DEFS} and {\tt USES} yields the
variables that are defined, respectively, used in the program. The difference
of these two bags yields the unused variables, in this case \verb@{"p"}@.

\section{Using Areas to Represent Program Fragments}\label{SEC:UsingAreas}

One aspect of the example we have just seen is artificial: where do these
line numbers come from that we used to indicate statements in the program?
One solution is to let the extraction phase generate \emph{area}s
to precisely indicate relevant places in the program text.

Recall from Section~\ref{SEC:ElementaryTypes}, that an area is 5-tuple
consisting of a file name, a begin line, a begin position, an end line, and an
end position. Also recall that areas can be compared: an area $A_1$ is smaller
than another area $A_2$, if $A_1$ is textually contained in $A_2$.
By including areas in the final answer of a relational
expression, external tools will be able to highlight places of interest in the
source text. The first step, is to define the types {\tt stat} and {\tt var}
as aliases for {\tt area} (instead of {\tt int} and {\tt str}):

\begin{exam}\begin{verbatim} 
type stat = int
type var = str
\end{verbatim}
\end{exam}

Of course, the actual relations are now represented differently.
For instance,  the {\tt USES} relation may now look like:
\begin{exam}
\begin{verbatim}
{ < area ("/home/paulk/pico1.trm", 11, 2, 11, 8), "z">, 
  < area ("/home/paulk/pico1.trm", 6, 2, 10, 4), "q">, 
  < area ("/home/paulk/pico1.trm", 7, 8, 7, 18), "x">, 
  < area ("/home/paulk/pico1.trm", 7, 8, 7, 18), "y"> }
\end{verbatim}
\end{exam}

The definition of {\tt UNINIT} can be reused as is. The only thing that remains to be done is to
map the (statement, variable-name) tuple to (variable-name, variable-occurrence) tuples.

We define a new type {\tt var-occ} to represent variable occurrences and a
relation {\tt OCCURS} that relates variable names to their occurrences.  The
new relation {\tt OCCURS} will have to generated by the program extraction phase.

\begin{exam}\begin{verbatim}
type var-occ = area
rel[var,var-occ] OCCURS
\end{verbatim}
\end{exam}
Remains the transformation of {\tt UNINIT}. This is done as follows:

\begin{exam}
\begin{verbatim}
rel[var, var-occ] UNINIT-OCC =
   { <V, VO> | <stat S, var V> : UNINIT, 
               var-occ VO : OCCURS[V], 
               VO <= S
   }
\end{verbatim}
\end{exam}
Here we consider all tuples {\tt <S, V>} in {\tt UNINIT} and all occurrences of variable {\tt V}.
Those variable occurrences that are contained in {\tt S} (using a comparison of areas)
are included in the result.

\section{McCabe Cyclomatic Complexity}
The \emph{cyclomatic complexity} of a program is defined as $e - n + 2$, where
$e$ and $n$ are the number of edges and nodes in the control flow graph,
respectively.  It was proposed by McCabe~\cite{McCabe76} as a measure of
program complexity.

Experiments have shown that programs with a higher cyclomatic complexity are
more difficult to understand and test and have more errors.  It is generally
accepted that a program, module or procedure with a cyclomatic complexity
larger than 15 is \emph{too complex}.  Essentially, cyclomatic complexity
measures the number of decision points in a program and can be computed by
counting all if statement, case branches in switch statements and the number
of conditional loops.

Given a control flow in the form of a predecessor relation {\tt rel[stat,stat]
PRED} between statements,
the cyclomatic complexity can be computed in an \rscript as follows:
\begin{exam}
\begin{verbatim}
int cyclomatic-complexity(rel[stat,stat] PRED) = 
    #PRED - #carrier(PRED) + 2
\end{verbatim}
\end{exam}

The number of edges $e$ is equal to the number of tuples in {\tt PRED}.
The number of nodes $n$ is equal to the number of elements in the carrier of
{\tt PRED}, i.e., all elements that occur in a tuple in {\tt PRED}.

\section{Dataflow Analysis}

\emph{Dataflow analysis} is a program analysis technique that forms the basis
for many compiler optimizations. It is described in any text book on compiler
construction, e.g. \cite{ASU86}. The goal of dataflow analysis is to determine
the effect of statements on their surroundings. Typical examples are:

\begin{itemize}

\item Dominators (Section~\ref{SEC:dominators}): which nodes in the
flow dominate the execution of other nodes?

\item Reaching definitions (Section~\ref{SEC:reaching}): which
definitions of variables are still valid at each statement?

\item Live variables (Section~\ref{SEC:live}): of which variables will
  the values be used by successors of a statement?

\item Available expressions: an expression is available if it is computed
  along each path from the start of the program to the current statement.

\item and more.
\end{itemize}

\subsection{Dominators} \label{SEC:dominators}

\begin{figure}[tb]
{\small
\begin{verbatim}
rel[stat,stat] dominators(rel[stat,stat] PRED) = 
   DOMINATES
where
    bag[stat] STATEMENT = carrier(PRED)

    bag[stat] ROOT = top(PRED)

    rel[stat,stat] DOMINATES =
    { <S, S1> | stat S : STATEMENT , 
                stat S1 : STATEMENT \ (ROOT union {S}) \ 
                                      range(reachX(ROOT, {S}, PRED)) 
    }
endwhere
\end{verbatim} 
\hrulefill}
\caption{\label{FIG:dominators-function}The function {\tt dominators}}
\end{figure}

\begin{figure}[tb]

\hspace*{-2cm} \epsfig{figure=figs/dominators.eps,width=10cm} 
\hspace*{-4cm} \epsfig{figure=figs/dominator-tree.eps,width=10cm}
\vspace*{-4.5cm}

\hrulefill
\caption{\label{FIG:dominators} (a) Flow graph and (b) dominator tree}
\end{figure}

A node $d$ of a flow graph \emph{dominates} a node $n$, if every path from the
initial node of the flow graph to $n$ goes through $d$~\cite[Section
10.4]{ASU86}. Dominators play a role in the analysis of conditional statements
and loops. In Figure~\ref{FIG:dominators-function}, we show the function {\tt
dominators} that computes the dominators for a given flow graph {\tt PRED}.
First, the auxiliary bags {\tt STATEMENT} (all the statements) and {\tt ROOT}
(the initial nodes) of the flow graph are computed. The relation {\tt
  DOMINATES} consists of all pairs {\tt <S, S1>} such that
\begin{itemize}
\item {\tt S1} is not an initial node or equal to {\tt S}.
\item {\tt S1} can be reached from the initial node without going through {\tt S}.
\end{itemize}

\noindent Consider the flow graph

\begin{exam}
\begin{verbatim}
rel[int,int] PRED = {
<1,2>, <1,3>,
<2,3>,
<3,4>,
<4,3>,<4,5>, <4,6>,
<5,7>,
<6,7>,
<7,4>,<7,8>,
<8,9>,<8,10>,<8,3>,
<9,1>,
<10,7>
}
\end{verbatim}
\end{exam}
and the result of applying {\tt dominators} to it:

\begin{exam}
\begin{verbatim}
{<1, {2, 3, 4, 5, 6, 7, 8, 9, 10}>, 
<2, {}>, 
<3, {4, 5, 6, 7, 8, 9, 10}>, 
<4, {5, 6, 7, 8, 9, 10}>, 
<5, {}>, <6, {}>, 
<7, {8, 9, 10}>, 
<8, {9, 10}>, 
<9, {}>, <10, {}>}
\end{verbatim}
\end{exam}

The original flow graph and the resulting \emph{dominator tree} are
shown in Figure~\ref{FIG:dominators}.  The dominator tree has the
initial node as root and each node $d$ in the tree only dominates its
descendants in the tree.



\subsection{Reaching Definitions} \label{SEC:reaching}
\begin{figure}[tb]
\begin{center}
\hspace*{3cm} \epsfig{figure=figs/df-graph.eps,width=10cm}
\vspace*{-6cm}
\end{center}
\hrulefill
\caption{\label{FIG:df-graph} Flow graph for various dataflow problems}
\end{figure}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/reach.eps,width=10cm}
\vspace*{-6cm}
\end{center}
\hrulefill
\caption{\label{FIG:reach} Reaching definitions for flow graph in Figure~\ref{FIG:df-graph}}
\end{figure}

We illustrate the calculation of reaching definitions using the example in
Figure~\ref{FIG:df-graph} which was inspired by \cite[Example 10.15]{ASU86}.

As before, we assume the following basic relations {\tt PRED}, {\tt DEFS} and
{\tt USES} about the program:
\begin{exam}
\begin{verbatim}
type stat = int
type var = str
rel[stat,stat] PRED = { <1,2>, <2,3>, <3,4>, <4,5>, <5,6>, <5,7>, <6,7>, 
                      <7,4>}
rel[stat, var] DEFS = { <1, "i">, <2, "j">, <3, "a">, <4, "i">, 
                       <5, "j">, <6, "a">, <7, "i">}
rel[stat, var] USES = { <1, "m">, <2, "n">, <3, "u1">, <4, "i">, 
                       <5, "j">, <6, "u2">, <7, "u3">}
\end{verbatim}
\end{exam}

For convenience, we introduce a notion {\tt def} that describes
that a certain statement defines some variable and we
revamp the basic relations into a more convenient
format using this new type:
\begin{exam}
\begin{verbatim}
type def  = <stat theStat, var theVar>

rel[stat, def] DEF = {<S, <S, V>> | <S, V> : DEFS}
rel[stat, def] USE = {<S, <S, V>> | <S, V> : USES}
\end{verbatim}
\end{exam}
The new {\tt DEF} relation gets as value:
\begin{exam}
\begin{verbatim}
 {<1, <1, "i">>, <2, <2, "j">>, <3, <3, "a">>, <4, <4, "i">>, 
  <5, <5, "j">>, <6, <6, "a">>, <7, <7, "i">>
\end{verbatim}
\end{exam}
and {\tt USE} gets as value:
\begin{exam}
\begin{verbatim}
{<1, <1, "m">>, <2, <2, "n">>, <3, <3, "u1">>, <4, <4, "i">>, 
 <5, <5, "j">>, <6, <6, "u2">>, <7, <7, "u3">>}
\end{verbatim}
\end{exam}

Now we are ready to define an important new relation {\tt KILL}.
{\tt KILL} defines which variable definitions are undone (killed) at each
 statement and is defined as follows:
\begin{exam}
\begin{verbatim}
rel[stat, def] KILL = 
   {<S1, <S2, V>> | <stat S1, var V> : DEFS, <stat S2, V> : DEFS, S1 != S2}
\end{verbatim}
\end{exam}
In this definition, all variable definitions are compared with each other,
and for each variable definition all \emph{other} definitions of the same variable
are placed in its kill set. In the example, {\tt KILL} gets the value
\begin{exam}
\begin{verbatim}
{<1, <4, "i">>, <1, <7, "i">>, <2, <5, "j">>, <3, <6, "a">>, 
 <4, <1, "i">>, <4, <7, "i">>, <5, <2, "j">>, <6, <3, "a">>, 
 <7, <1, "i">>, <7, <4, "i">>}
\end{verbatim}
\end{exam}
and, for instance, the definition of variable {\tt i} in statement {\tt 1}
kills the definitions of {\tt i} in statements {\tt 4} and {\tt 7}.  Next, we
introduce the collection of statements
\begin{exam}
\begin{verbatim}
bag[stat] STATEMENTS = carrier(PRED)
\end{verbatim}
\end{exam}
which gets as value \verb@{1, 2, 3, 4, 5, 6, 7}@ and
two convenience functions to obtain
the predecessor, respectively, the successor of a statement:
\begin{exam}
\begin{verbatim}
bag[stat] predecessor(stat S) = PRED[-,S]
bag[stat] successor(stat S) = PRED[S,-]
\end{verbatim}
\end{exam}

After these preparations, we are ready to formulate the reaching definitions
problem in terms of two relations {\tt IN} and {\tt OUT}.  {\tt IN} captures
all the variable definitions that are valid at the entry of each statement and
{\tt OUT} captures the definitions that are still valid after execution of
each statement. Intuitively, for each statement {\tt S}, {\tt IN[S]} is equal to
the union of the {\tt OUT} of all the predecessors of {\tt S}.
{\tt OUT[S]}, on the other hand, is equal to the definitions generated by
{\tt S} to which we add {\tt IN[S]} minus the definitions that are killed
in {\tt S}. Mathematically, the following set of equations captures this idea
for each statement:

\[
IN[S] = \bigcup_{P \in predecessor of S} OUT[P] \]
\[ OUT[S] = DEF[S] \cup (IN[S] - KILL[S]) \]

\noindent This idea can be expressed in \rscript quite literally:
\begin{exam}
\begin{verbatim}
equations
  initial
        rel[stat,def] IN init {}
        rel[stat,def] OUT init DEF
  satisfy
        IN  = {<S, D> | stat S : STATEMENTS, 
                        stat P : predecessor(S), 
                        def D : OUT[P]}
        OUT = {<S, D> | stat S : STATEMENTS, 
                        def D : DEF[S] union (IN[S] \ KILL[S])}
end equations
\end{verbatim}
\end{exam}
First, the relations {\tt IN} and {\tt OUT} are declared and initialized. Next, 
two equations are given that very much resemble the ones given above.
For our running example (Figure~\ref{FIG:reach}) the results are as follows.
Relation {\tt IN} has as value:
\begin{exam}
\begin{verbatim}
{<2, <1, "i">>, <3, <2, "j">>, <3, <1, "i">>, <4, <3, "a">>, 
 <4, <2, "j">>, <4, <1, "i">>, <4, <7, "i">>, <4, <5, "j">>, 
 <4, <6, "a">>, <5, <4, "i">>, <5, <3, "a">>, <5, <2, "j">>, 
 <5, <5, "j">>, <5, <6, "a">>, <6, <5, "j">>, <6, <4, "i">>, 
 <6, <3, "a">>, <6, <6, "a">>, <7, <5, "j">>, <7, <4, "i">>, 
 <7, <3, "a">>, <7, <6, "a">>}
\end{verbatim}
\end{exam}
If we consider statement {\tt 3}, then the definitions of {\tt i} and {\tt j}
from the preceding two statements are still valid. A more interesting case
are the definitions that can reach statement {\tt 4}:
\begin{itemize}
\item  The definitions of variables {\tt a}, {\tt j} and {\tt i} from,
  respectively, statements {\tt 3}, {\tt 2} and {\tt 1}.

\item The definition of variable {\tt i} from statement {\tt 7} (via the
  backward control flow path from {\tt 7} to {\tt 4}).

\item The definition of variable {\tt j} from statement{\tt 5} (via the path
  {\tt 5}, {\tt 7}, {\tt 4}).
\item The definition of variable {\tt a} from statement {\tt 6} (via the path
 {\tt 6}, {\tt 7}, {\tt 4}).
\end{itemize}

Relation {\tt OUT} has as value:
\begin{exam}
\begin{verbatim}
{<1, <1, "i">>, <2, <2, "j">>, <2, <1, "i">>, <3, <3, "a">>, 
 <3, <2, "j">>, <3, <1, "i">>, <4, <4, "i">>, <4, <3, "a">>, 
 <4, <2, "j">>, <4, <5, "j">>, <4, <6, "a">>, <5, <5, "j">>, 
 <5, <4, "i">>, <5, <3, "a">>, <5, <6, "a">>, <6, <6, "a">>, 
 <6, <5, "j">>, <6, <4, "i">>, <7, <7, "i">>, <7, <5, "j">>, 
 <7, <3, "a">>, <7, <6, "a">>}
\end{verbatim}
\end{exam}
Observe, again for statement {\tt 4}, that
all definitions of variable  {\tt i} are missing in {\tt OUT[4]} since
they are killed by the definition of {\tt i} in statement {\tt 4} itself. Definitions for
{\tt a} and {\tt j} are, however, contained in {\tt OUT[4]}.
The result of reaching definitions computation is illustrated in
Figure~\ref{FIG:reach}.

In Figure~\ref{FIG:reaching-definitions} the above definitions are used to
formulate the function {\tt reaching-definitions}. It assumes appropriate
definitions for the types {\tt stat} and {\tt var}. It also assumes more
general versions of {\tt predecessor} and {\tt successor}.  We will use it
later on in Section~\ref{SEC:slicing} when defining program slicing.

\begin{figure}[tb]
{\small
\begin{verbatim}
type def  = <stat theStat, var theVar>
type use  = <stat theStat, var theVar>

bag[stat] predecessor(rel[stat,stat] P, stat S) = P[-,S]

bag[stat] successor(rel[stat,stat] P, stat S) = P[S,-]

rel[stat, def] reaching-definitions(rel[stat,var] DEFS, rel[stat,stat] PRED) = 
   IN
where
    bag[stat] STATEMENT = carrier(PRED)

    rel[stat,def] DEF  = {<S,<S,V>> | <stat S, var V> : DEFS}

    rel[stat,def] KILL = 
        {<S1, <S2, V>> | <stat S1, var V> : DEFS, <stat S2, V> : DEFS, S1 != S2}

    equations 
       initial
           rel[stat,def] IN init {}
           rel[stat,def] OUT init DEF
       satisfy
           IN  =  {<S, D> | int S : STATEMENT, 
                            stat P : predecessor(PRED,S), 
                            def D : OUT[P]}
           OUT = {<S, D> |  int S : STATEMENT, 
                            def D : DEF[S] union (IN[S] \ KILL[S])}
    end equations
end where
\end{verbatim}
\hrulefill}
\caption{\label{FIG:reaching-definitions}Reaching definitions}
\end{figure}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/live.eps,width=10cm}
\vspace*{-6cm}
\end{center}
\hrulefill
\caption{\label{FIG:live} Live variables for flow graph in Figure~\ref{FIG:df-graph}}
\end{figure}

\subsection{Live Variables} \label{SEC:live}

The live variables of a statement are those variables whose value will be used
by the current statement or some successor of it. The mathematical formulation
of this problem is as follows:

\[
IN[S] =USE[S] \cup (OUT[S] - DEF[S]) \]
\[ OUT[S] = \bigcup_{S' \in successor of S} IN[S'] \]
The first equation says that a variable is live coming into a statement if
either it is used before redefinition in that statement or it is live coming
out of the statement and is not redefined in it.  The second equation says
that a variable is live coming out of a statement if and only if it is live
coming into one of its successors.
This can be expressed in \rscript as follows:
\begin{exam}
\begin{verbatim}
equations
  initial
        rel[stat,def] LIN init {}
        rel[stat,def] LOUT init DEF
  satisfy
        LIN  =  { < S, D> | stat S : STATEMENTS,  
                            def D : USE[S] union (LOUT[S] \ (DEF[S]))}
        LOUT =  { < S, D> | stat S : STATEMENTS,  
                            stat Succ : successor(S), 
                            def D : LIN[Succ] }
end equations
\end{verbatim}
\end{exam}

\noindent The results of live variable analysis for our running example are
illustrated in Figure~\ref{FIG:live}.

\section{Program Slicing} \label{SEC:slicing}

\begin{figure}[tb]
\begin{center}
{\small
\begin{verbatim}
      [ 1] read(n)           [ 1] read(n)            [ 1] read(n)
      [ 2] i := 1            [ 2] i := 1             [ 2] i := 1
      [ 3] sum := 0          [ 3] sum := 0          
      [ 4] product := 1                              [ 4] product := 1
      [ 5] while i<= n do    [ 5] while i<= n do     [ 5] while i<= n do
           begin                  begin                   begin
      [ 6]   sum := sum + i  [ 6]   sum := sum + i
      [ 7]   product :=                              [ 7]   product := 
               product * i                                    product * i
      [ 8]   i := i + 1      [ 8]  i := i + 1        [ 8]   i := i + 1
           end                    end                     end
      [ 9] write(sum)        [ 9] write(sum)
      [10] write(product)                            [10] write(product)
\end{verbatim}
}
\end{center}

\noindent\hspace{1cm}(a)\hspace{4cm}(b)\hspace{4cm}(c)

\hrulefill

\caption{\label{FIG:slicing}(a) Sample program, 
(b) slice for statement {\tt [9]}, (c) slice for statement {\tt [10]}}
\end{figure}


Program slicing is a technique proposed by Weiser~\cite{Weiser84} for
automatically decomposing programs in parts by analyzing their data
flow and control flow. Typically, a given statement in a program is
selected as the \emph{slicing criterion} and the original program is
reduced to an independent subprogram, called a \emph{slice}, that is
guaranteed to represent faithfully the behaviour of the original
program at the slicing criterion.  An example is given in
Figure~\ref{FIG:slicing}.  The initial program is given in
Figure~\ref{FIG:slicing}(a).  The slice with statement {\tt [9]} as
slicing criterion is shown in Figure~\ref{FIG:slicing}(b): statements
{\tt [4]} and {\tt [7]} are irrelevant for computing statement {\tt
[9]} and do not occur in the slice. Similarly, Figure~\ref{FIG:slicing}(c)
shows the slice with statement {\tt [10]} as slicing criterion.
This particular form of slicing is called \emph{backward slicing}.
Slicing can be used for debugging and program understanding,
optimization and more. An overview of slicing techniques and
applications can be found in ~\cite{Tip95}.

Here we will explore a relational formulation of slicing adapted from a proposal
in ~\cite{Jackson&Rollins94}. The basic ingredients of the approach are as
follows:

\begin{itemize}

\item We assume the relations {\tt PRED}, {\tt DEFS} and {\tt USES} as before.

\item We assume an additional bag {\tt CONTROL-STATEMENT} that defines which
  statements are control statements.

\item To tie together dataflow and control flow, three auxiliary variables are
  introduced:
  \begin{itemize}

    \item The variable {\tt TEST} represents the outcome of
    a specific test of a conditional statement. The conditional statement
    defines {\tt TEST} and all statements that are control dependent on this
    conditional statement will use {\tt TEST}.

    \item The variable {\tt EXEC} represents the potential execution
    dependence of a statement on some conditional statement.  The dependent
    statement defines {\tt EXEC} and an explicit (control) dependence is made
    between {\tt EXEC} and the corresponding {\tt TEST}.

    \item The variable {\tt CONST} represents an arbitrary constant.	

  \end{itemize}

\end{itemize}

\begin{figure}[tb]
{\small
\begin{verbatim}
bag[use] BackwardSlice(
    bag[stat] CONTROL-STATEMENT, 
    rel[stat,stat] PRED,
    rel[stat,var] USES,
    rel[stat,var] DEFS,    
    use Criterion) 
= USE-USE[Criterion]

where
    rel[stat, def] REACH = reaching-definitions(DEFS, PRED)

    rel[use,def] use-def = 
       {<<S1,V>, <S2,V>> | <stat S1, var V> : USES, <stat S2, V> : REACH[S1]}

    rel[def,use] def-use-per-stat  = 
       {<<S,V1>, <S,V2>> | <stat S, var V1> : DEFS, <S, var V2> : USES}
             union
       {<<S,V>, <S,"EXEC">> | <stat S, var V> : DEFS}
             union
       {<<S,"TEST">,<S,V>> | stat S : CONTROL-STATEMENT, 
                             <S, var V> : domainR(USES, {S})}

    rel[stat, stat] CONTROL-DOMINATOR = 
       domainR(dominators(PRED), CONTROL-STATEMENT)

    rel[def,use] control-dependence  =
       { <<S2, "EXEC">,<S1,"TEST">> | <stat S1, stat S2> : CONTROL-DOMINATOR}

    rel[use,def] use-control-def = use-def union control-dependence

    rel[use,use] USE-USE = (use-control-def o def-use-per-stat)*

endwhere
\end{verbatim}
\hrulefill}
\caption{\label{FIG:backward-slice}Backward slicing}
\end{figure}


\noindent The calculation of a (backward) slice now proceeds in six steps:

\begin{enumerate}

\item 	Compute the relation {\tt rel[use,def] use-def} that relates all uses
  to their corresponding definitions. The function {\tt reaching-definitions}
  as shown earlier in Figure~\ref{FIG:reaching-definitions} does most of the work.

\item 	Compute the relation {\tt rel[def,use] def-use-per-stat} that relates the ``internal''
  definitions and uses of a statement.

\item 	Compute the relation {\tt rel[def,use] control-dependence} that links
  all {\tt EXEC}s to the corresponding {\tt TEST}s.
 
\item	Compute the relation {\tt rel[use,def] use-control-def} combines
  use/def dependencies with control dependencies.

\item 	After these preparations, compute the relation {\tt rel[use,use]
  USE-USE} that contains dependencies of uses on uses.

\item The backward slice for a given slicing criterion (a use) is now simply
  the projection of USE-USE for the slicing criterion.
\end{enumerate}

This informal description of backward slicing is described precisely in
Figure~\ref{FIG:backward-slice}. Let's apply this to the example
in Figure~\ref{FIG:slicing} and assume the following:

\begin{exam}
\begin{verbatim}
rel[stat,stat] PRED = {<1,2>, <2,3>, <3,4>, <4,5>, <5,6>, <5,9>, <6,7>,
                       <7,8>,<8,5>, <8,9>, <9,10>}

rel[stat,var] DEFS  = {<1, "n">, <2, "i">, <3, "sum">, <4,"product">,
                       <6, "sum">, <7, "product">, <8, "i">}

rel[stat,var] USES  = {<5, "i">, <5, "n">, <6, "sum">, <6,"i">,
                       <7, "product">, <7, "i">, <8, "i">, <9, "sum">, 
                       <10, "product">}

bag[int] CONTROL-STATEMENT = { 5 }
\end{verbatim}
\end{exam}
The result of the slice
\begin{exam}
\begin{verbatim}
BackwardSlice(CONTROL-STATEMENT, PRED, USES, DEFS, <9, "sum">)
\end{verbatim}
\end{exam}
will then be
\begin{exam}
\begin{verbatim}
 { <1, "EXEC">, <2, "EXEC">,  <3, "EXEC">, <5, "i">, <5, "n">,  
   <6, "sum">, <6, "i">, <6, "EXEC">, <8, "i">, <8, "EXEC">, 
   <9, "sum"> }.
\end{verbatim}
\end{exam}
Take the domain of this result and we get exactly the statements
in Figure~\ref{FIG:slicing}(b).


\subsection{Others}
\note{Some ideas:
\begin{itemize}
\item Type system
\item Constraint-like puzzle
\end{itemize}
}

\chapter{Running a \rscript} \label{SEC:running-rscript}

Currently, the definition of \rscript resides in the CWI cvs repository {\tt /ufs/glt/CVS}.
You can checkout your own copy by means of
{\tt cvs -d ssh.cwi.nl:/ufs/glt/CVS co relation-calculus} (provided that you have an account at CWI).
Otherwise you have to obtain a {\tt tar.gz} file of the relation calculus.

\paragraph{Running a script}
\begin{itemize}
\item Change to your checked out copy of the directory {\tt relation-calculus}.
\item Start the ASF+SDF Meta-Environment with the command {\tt meta}.
\item Open the module {\tt Rscript.sdf}.
\item Open your own term, using the Rscript module.
\item Observe that a new menu with the name {\tt Rscript} appears in the menu bar.
\item Click the parse button in the {\tt Actions} menu of the editor:
now we know whether there are syntax errors. If so, correct them.

\item Click the {\tt Check} button in the {\tt Rscript} menu: this will
  perform a type check of your script. If there are type errors, correct them.

\item Click the {\tt Run} button in the {\tt Rscript} menu to execute your script: a new
editor pops up which shows all the variables at the end of the execution.
{\tt Run} also performs a type of your script so you may skip the previous step.

\item Click the {\tt Run with Rstore} button if you want to execute your
  \rscript with an existing ``Rstore'': a collection of relations that are the
  result of previous extraction phase. Currently, a fixed name is used for
  this Rstore: {\tt RSTORE.rstore}.

\end{itemize}

\paragraph{Running a Test suite} \label{running}
Same as above but use {\tt Testsuite} button instead of the {\tt Execute}
button in the {\tt Rscript} menu.  The effect is that the script is executed
and that a summary is printed of {\tt assert} statement that succeeded or
failed.

\paragraph{Miscellaneous}
The subdirectory {\tt rscripts} contains several sample scripts.  See {\tt
tests1.rscript} and {\tt tests2.rscript} for examples of the use of built-in
operators and functions.

The subdirectory {\tt demo} contains larger demos.

\chapter{Differences with Previous Versions}
\rscript is in under active development and several (incompatible)  changes
have been made in the last few weeks. Here is an indicative list.

\begin{itemize}

\item The syntax of comprehension has been changed. Old
\begin{verbatim}
  { <X, Y> : <X, Y> in R | X in B and Y  in B }
\end{verbatim}
New:
\begin{verbatim}
  { <X, Y> | <X, Y> : R, X in B and Y in B }
\end{verbatim}

\item The type {\tt node} has been renamed into {\tt area}

\end{itemize}

\section*{Acknowledgments}
Taeke Kooiker, Tijs van der Storm.

\appendix

\chapter{Tables of Built-in Operators} \label{AP:operators}


\begin{center}
\begin{supertabular}{|l|l|c|} \hline
\tablecaption{Built-in operators}
\tablehead{\hline}
\tabletail{\hline} 
{\bf Operator} & {\bf Description} & {\bf Section} \\ \hline \hline
{\tt and} & Boolean and & \ref{BO:bool}\\
{\tt implies} & Boolean implication & \ref{BO:bool}\\
{\tt in}    & Membership test on bags/relations& \ref{BO:bag-or-rel}\\
{\tt inter} & Intersection of bags/relations& \ref{BO:bag-or-rel}\\
{\tt not} & Boolean negation & \ref{BO:bool}\\
{\tt notin} & Non-membership test on bags/relations& \ref{BO:bag-or-rel}\\
{\tt or} & Boolean or & \ref{BO:bool}\\
{\tt union} & Union of bags/relations& \ref{BO:bag-or-rel}\\
{\tt ==}  & Equality of integers & \ref{BO:int}\\
{\tt ==}  & Equality of areas & \ref{BO:area}\\
{\tt ==}  & Equality of bags/relations & \ref{BO:bag-or-rel}\\

{\tt !=}  & Inequality of integers & \ref{BO:int}\\
{\tt !=}  & Inequality of strings & \ref{BO:str}\\
{\tt !=}  & Inequality of areas & \ref{BO:area}\\
{\tt !=}  & Inequality of bags/relations & \ref{BO:bag-or-rel}\\

{\tt <=}  & Less than or equal of integers & \ref{BO:int}\\
{\tt <=}  & Less than or equal of strings & \ref{BO:str}\\
{\tt <=}  & Textual inclusion of areas & \ref{BO:area}\\
{\tt <=}  & Subset of bags/relations & \ref{BO:bag-or-rel}\\

{\tt <}  & Less than of integers & \ref{BO:int}\\
{\tt <}  & Less than of strings & \ref{BO:str}\\
{\tt <}  & Strict textual inclusion of areas & \ref{BO:area}\\
{\tt <}  & Strict subset of bags/relations & \ref{BO:bag-or-rel}\\

{\tt >=}  & Greater than or equal of integers & \ref{BO:int}\\
{\tt >=}  & Greater than or equal of strings & \ref{BO:str}\\
{\tt >=}  & Textual containment of areas & \ref{BO:area}\\
{\tt >=}  & Superset of bags/relations & \ref{BO:bag-or-rel}\\

{\tt >}  & Greater than of integers & \ref{BO:int}\\
{\tt >}  & Greater than of strings & \ref{BO:str}\\
{\tt >}  & Strict textual containment of areas & \ref{BO:area}\\
{\tt >}  & Strict superset of bags/relations & \ref{BO:bag-or-rel}\\

{\tt +}  & Addition of integers & \ref{BO:int}\\
{\tt -}  & Subtraction of integers & \ref{BO:int}\\
{\tt *}  & Multiplication of integers & \ref{BO:int}\\
{\tt /}  & Division of integers & \ref{BO:int}\\

\verb+\+   & Difference of bags/relations & \ref{BO:bag-or-rel}\\

{\tt o}    & Composition of relations  & \ref{BO:relations}\\
{\tt x}    & Carthesian product of bags & \ref{BO:relations}\\

\verb@#@   & Number of elements of bag & \ref{BO:misc}\\
\verb@#@   & Number of tuples of relation & \ref{BO:misc}\\

{\tt [-, ]}    & Left image of relation & \ref{BO:relations}\\
{\tt [  ,-]}   & Right image of relation & \ref{BO:relations}\\
{\tt [ ]}      & Right image of relation & \ref{BO:relations}\\

{\tt +}    & Transitive closure of a relation  & \ref{BO:relations}\\
{\tt *}    & Reflexive transitive closure of a relation  & \ref{BO:relations}\\ \hline

\end{supertabular}
\end{center}

\chapter{Tables of Built-in Functions} \label{AP:functions}

%%\tablecaption{Built-in functions}
\tablehead{\hline}
\tabletail{\hline}

\begin{center}
\begin{supertabular}{|l|l|c|}

{\bf Function}    & {\bf Description}   & {\bf Section} \\ \hline \hline

{\tt average}     & Average of a bag of integers & \ref{BI:average} \\
{\tt begincol}    & First column of an area & \ref{BI:begincol}\\
{\tt beginline}   & Beginning line of an area & \ref{BI:beginline}\\
{\tt bottom}      & Bottom of a relation & \ref{BI:bottom} \\
{\tt carrier}     & Carrier of a relation & \ref{BI:carrier} \\
{\tt carrierR}    & Carrier restriction of a relation & \ref{BI:carrierR} \\
{\tt carrierX}    & Carrier exclusion of a relation & \ref{BI:carrierX} \\

{\tt compl}       & Complement of a relation & \ref{BI:compl} \\
{\tt endcol}      & Last column of an area & \ref{BI:endcol}\\
{\tt endline}     & Ending line of an area & \ref{BI:endline}\\
{\tt filename}    & File name of an area & \ref{BI:filename}\\
{\tt first}       & First element of a tuple & \ref{BI:first} \\
{\tt id}          & Identity relation & \ref{BI:id} \\
{\tt inv}         & Inverse of a relation & \ref{BI:inv} \\

{\tt domain}      & Domain of a relation & \ref{BI:domain} \\
{\tt domainR}     & Domain restriction of a relation & \ref{BI:domainR} \\
{\tt domainX}     & Domain exclusion of a relation & \ref{BI:domainX} \\
{\tt min}         & Minimum of a bag of integers & \ref{BI:max} \\
{\tt max}         & Maximum of a bag of integers & \ref{BI:max} \\
{\tt power0}      & Powerset of a bag & \ref{BI:power0} \\
{\tt power1}      & Powerset of a bag & \ref{BI:power1} \\

{\tt range}       & Range of a relation  & \ref{BI:range} \\
{\tt rangeR}      & Range restriction of a relation & \ref{BI:rangeR} \\
{\tt rangeX}      & Range exclusion of a relation & \ref{BI:rangeX} \\
{\tt reachR}      & Reachability with restriction & \ref{BI:reachR} \\
{\tt reachX}      & Reachability with exclusion& \ref{BI:reachX} \\

{\tt second}      & Second element of a tuple & \ref{BI:second} \\
{\tt sum}         & Sum of a bag of integers & \ref{BI:sum} \\
{\tt top}         & Top of a relation & \ref{BI:top} \\

\end{supertabular}
\end{center}

\chapter{TO DO}
\begin{itemize}
\item {\tt all-path-to} is not described.
\item $n$-ary relations
\item Termination criteria for solving equations
\item Access functions for $n$-ary tuples.
\item Describe Rstores
\item Give Rscript grammar
\end{itemize}

\bibliographystyle{plain}
\bibliography{iwpc,tutorial}
\end{document}
