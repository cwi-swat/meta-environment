
\documentclass[10pt]{article}
\usepackage{a4wide}
\usepackage[english]{babel}
\usepackage{url}
\usepackage{times}
\usepackage{xspace}
\usepackage{alltt}
\usepackage{supertabular}
\usepackage{epsfig}


\newcommand{\rscript}[0]{\textsc{Rscript}\xspace}
\newcommand{\asfsdf}[0]{\textsc{Asf+Sdf}\xspace}
\newcommand{\note}[1]{\paragraph{Note:} \emph{#1}}

\title{A Tutorial Introduction to \rscript}
\author{Paul Klint}

\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This short note documents the current state of the \rscript language.
Be aware, this work in progress.
\end{abstract}

\section{Introduction}

\rscript is a small scripting language based on the relational
calculus.  It is intended for analyzing and querying the source code
of software systems: from finding uninitialized variables in a single
program to formulating queries about the architecture of a complete
software system. \rscript fits well in the extract-enrich-view paradigm:

\begin{description}
\item[Extract:] Given the source text, extract relevant information
from it in the form of relations. Examples are the CALLS relation that
describes direct calls between procedures, the USE relation that
relates statements with the variables that are used in the statements,
and the PRED relation that relates a statement with its predecessors
in the control flow graph.  The extraction phase is outside the scope
of \rscript but may, for instance, be implemented using \asfsdf.

\item[Enrich:] Derive additional information from the relations
extracted from the source text. For instance, use CALLS to compute
procedures that can also call each other indirectly (using transitive
closure).  Here is where \rscript shines.

\item[View:] The result of the enrichment phase are again bags and
relations.  These can be displayed with various tools like, Dot, Rigi
and others. \rscript is not concerned with viewing.

\end{description}

\section{The \rscript language}

\rscript is based on \emph{binary relations} only and has no direct support
for n-ary relations with labelled columns as usual in a general
database language. However, some syntactic support for n-ary relations
exists that translates them internally to binary relations. We will
explain this further below.

An \rscript consists of a sequence of declarations for variables and/or
functions. Usually, the value of one of these variables is what the writer of the
script is interested in.

The language has scalar types (Boolean, integer, string, area) and
composite types (bag and relation). Expressions are constructed from
comprehensions, function invocations and operators. These are all
described below.

\section{Types and values}

\subsection{Elementary Types and Values}

\paragraph{Booleans}
The Booleans are represented by the type {\tt bool} and have two values:
{\tt true} and {\tt false}.

\paragraph{Integers}
The integer values are represented by the type {\tt int} and are written as
usual, e.g., {\tt 0}, {\tt 1}, or {\tt 123}.

\paragraph{Strings}
The string values are represented by the type {\tt str} and consist
of character sequences surrounded by double quotes. e.g., {\tt "a"} or
{\tt "a\ long\ string"}.

\paragraph{Areas}
Area values are represented by the type {\tt area} and serve as source text
coordinates, they are written as in: {\tt area("/usr/paulk/myfile.c", 2, 3, 7,
55)}.

\subsection{Composite Types and Values}

\paragraph{Tuples}

Tuples are represented by the type {\tt <$T_1$, $T_2$>}, where $T_1$ and
$T_2$ are arbitrary types. An example is {\tt <int, str>}.

\rscript directly supports tuples consisting of two elements (also
know as \emph{pairs}).  For convenience, n-ary tuples are allowed, but
they are translated to a nested pair.  For instance, the type {\tt
<int, int, int, int>} corresponds to {\tt <int, <int, <int, int>>>}
and the value {\tt <1, 2, 3, 4>} corresponds to {\tt <1, <2, <3, 4>>>}.

\paragraph{Bags}
Bags are represented by the type {\tt bag[$T$]}, where $T$ is an arbitrary
type. Examples are {\tt bag[int]}, {{\tt bag[<int,int>]} and {\tt
bag[bag[str]]}.  Bags are denoted by a list of elements, separated by comma's
and enclosed in braces as in  {\tt \{ $E_1$, $E_2$, ..., $E_n$ \}},
where the $E_i$ ($1 \leq i \leq n$) are expressions that yield the desired element
type. For example, 
\begin{itemize}
\item {\tt \{1, 2, 3\}} is of type {\tt bag[int]},
\item  {\tt \{<1,10>, <2,20>, <3,30>\}} is of type {\tt bag[<int,int>]}, and 
\item {\tt \{\{"a", "b"\}, \{"c", "d"\}\}} is of type {\tt bag[bag[str]]}.
\end{itemize}

\paragraph{Relations}
Bags are nothing more than bags of tuples, but since they are used so often
we provide some shorthand notation for them.

Relations are represented by the type {\tt rel[$T_1$, T$_2$]}, where {\tt
$T_1$} and {\tt $T_2$} are arbitrary types; it is a shorthand for {\tt
bag[<$T_1$, $T_2$>]}.  Examples are {\tt rel[int,str]} and {\tt
rel[int,bag[str]]}.  Relations are denoted by {\tt \{<$E_{11}$, $E_{12}$>, <$E_{21}$,
$E_{22}$>, ..., <$E_{n1}$, $E_{n2}$>\}}, where the $E_{ij}$ are expressions that
yield the desired element type. For example, {\tt \{<1, "a">, <2, "b">,
<3,"c">\}} is of type {\tt rel[int, str]}.

Not surprisingly, $n$-ary relations are represented by the type {\tt rel[$T_1$, $T_2$, ..., $T_n$]}
which is  a shorthand for  {\tt bag[<$T_1$, $T_2$, ..., $T_n$>]}

\section{Comprehensions}

We will use the familiar notation
\begin{quote}
  {\tt \{ $E$ | $G_1$, ..., $G_n$ \}}
\end{quote}
to denote the construction of a bag consisting of the union of
successive values of the expression $E$.  The values and the
generated bag are determined by $E$ and the \emph{generators}
$G_1 ,..., G_n$.  $E$ is computed for all possible
combinations of values produced by the generators.

Each generator may introduce new variables
that can be used in subsequent generators as well as in the expression
$E$.  A generator can use the variables introduced by preceeding
generators.  Generators may enumerate all the values in a bag or
relation, they may perform a test, or they may assign a value to
variables.

\subsection{Generators}

\paragraph{Enumerator}
Enumerators generate all the values in a given bag or relation.
They come in two flavours: 

\begin{itemize}
\item {\tt $V$~:~$E$}: the elements of the bag or relation that results from the evaluation
of expression $E$ are enumerated and subsequently assigned to the new variable $V$.


\item {\tt <$V_1$,~...,~$V_n$>~:~$E$}: the elements of the bag or relation
that results from the evaluation of expression $E$ are enumerated. The
elements of the resulting $n$-tuple are subsequently assigned to the
new variables $V_1 ,..., V_n$.

\end{itemize}

\paragraph{Test}
A test is a boolean-valued expression. If the evaluation yields {\tt true}
this indicates that the current combination of generated values upto this test
is still as desired and execution continues with subsequent generators.  If
the evaluation yields {\tt false} this indicates that the current combination
of values is undesired, and that another combination should be tried.

\paragraph{Assignment}
Assignments assign a value to one or more variables and also come in two flavours:

\begin{itemize}

\item {\tt $V$ <- $E$}: assigns the value of expression $E$ to the new variable $V$.

\item {\tt <$V_1$, ..., $V_n$> <- $E$}: assigns the elements of the $n$-tuple
resulting from the evaluation of expression $E$ to the new variables $V_1 ,..., V_n$.

\end{itemize}


\subsection{Examples of Comprehensions}

\paragraph{Example}

{\tt \{X | X : \{1, 2, 3, 4, 5\},  X >= 3\}} yields the bag {\tt \{3,4,5\}}.

\paragraph{Example}

{\tt \{<X, Y> | X :\{1, 2, 3\}, Y :\{2, 3, 4\}, X >= Y\}} yields the relation
{\tt \{<2, 2>, <3, 2>, <3, 3>\}}.

\paragraph{Example}
{\tt \{<Y, X> | X, Y> :\{<1,10>, <2,20>\} \}} yields the inverse of
the given relation: {\tt \{<10,1>, <20,2>\}}.

\section{Declarations}

\subsection{Variable declarations}
A variable declaration has the form 
\begin{quote}
{\tt $T$ $V$ = $E$}
\end{quote}
where $T$ is a type,
$V$ is a variable name, and $T$ is an expression that should have type
$T$. The effect is that the value of expression $E$ is assigned to
$V$ and can be used later on as $V$'s value. Double declarations are
not allowed.

As a convenience, also declarations without an initialization expression are
permitted and have the form 
\begin{quote}
{\tt $T$ $V$} 
\end{quote}
and only introduce the variable $V$.

\paragraph{Example} {\tt int max = 100} declares the integer variable
{\tt max} with value {\tt 100}.

\paragraph{Example} {\tt rel[str,int] day = \{<"mon", 1>, <"tue", 2>, <"wed",
    3>, <"thu", 4>, <"fri", 5>, <"sat",6>, <"sun",7>\}}
declares the variable {\tt day}, a relation that maps strings to integers.

\subsection{Local variable declarations}
Local variables can be introduced as follows:
\begin{quote}
{\tt $E$ where $T_1$ $V_1$ = $E_1$, ..., $T_n$ $V_n$ = $E_n$ endwhere}
\end{quote}
First the local variables $V_i$ are bound to their respective values
$E_i$, and then the value of expression $E$ is yielded.


\subsection{Function declarations}
A function declaration has the form
\begin{quote}
{\tt $T$ $F$($T_1 ~ V_1$, ..., $T_n ~ V_n$) = $E$}
\end{quote}
Here $T$ is the result type of the function and this should be equal to the
type of the associated expression $E$.  Each $T_i$ $V_i$ represents a typed
formal parameter of the function. The formal parameters may occur in $E$ and
get their value when $F$ is invoked from another expression.

\paragraph{Example} The function declaration
\begin{quote}
{\tt rel[int, int] invert(rel[int,int] R) = \{<Y, X> | <X, Y> : R \}} 
\end{quote}
yields the inverse of the argument relation {\tt R}. For instance,
\begin{itemize}
\item {\tt invert(\{<1,10>, <2,20>\})} yields {\tt \{<10,1>, <20,2>\}}.
\end{itemize}

\paragraph{Parameterized types in function declarations}
The types that occur in function declarations may also contain
\emph{type variables}. In this way functions can be defined for arbitrary
types.

\begin{sloppypar}
\paragraph{Example} The declaration
\begin{quote}
{\tt rel[T2, T1] invert2(rel[T1,T2] R) = \{<Y, X> | <X, Y> : R \}} 
\end{quote}
yields an inversion function that is applicable to any binary relation.
For instance,
\begin{itemize}
\item {\tt invert2(\{<1,10>, <2,20>\})} yields {\tt \{<10,1>, <20,2>\}},
and 
\item {\tt invert2(\{<"mon", 1>, <"tue", 2>\}}
yields {\tt \{<1, "mon">, <2, "tue">\}}.
\end{itemize}
\end{sloppypar}

\paragraph{Example} The function
\begin{quote}
{\tt <T2, T1> swap(T1 A, T2 B) = <B, A>}
\end{quote}
can be used to swap the elements of pairs of arbitrary types.  For instance,
\begin{itemize}
\item {\tt swap(<1, 2>)} yields {\tt <2,1>} and 
\item {\tt swap(<"wed", 3>)} yields {\tt
<3, "wed">}.
\end{itemize}

\subsection{Assertions}
An assert statement may occur everywhere where a declaration is allowed.  It
has the form 
\begin{quote}
{\tt assert $L$: $E$}
\end{quote}
 where $L$ is a string that serves as a
label for this assertion, and $E$ is a boolean-value expression.  During
execution, a list of true and false assertions is maintained.  When the script
is executed as a \emph{testsuite} (see Section~\ref{running}) a summary of this
information is shown to the user. When the script is executed in the standard
fashion, the assert statement has no affect.

\paragraph{Example}
\begin{quote}
{\tt assert "Equality on Bags 1": \{1, 2, 3, 1\} == \{3, 2, 1, 1\}}
\end{quote}

\subsection{Solvers}
It is also possible to define mutually recursive variables by
\begin{quote}
{\tt solve \{
  $V_1$ = $E_1$,
  ...,
  $V_n$ = $E_n$
\}}
\end{quote}
Here, the expressions {\tt E}$_i$ may refer to any of the variables {\tt
  V}$_i$ (and to any variables declared earlier).  This set of equations is
  solved by evaluating the expressions {\tt E}$_i$, assigning their value to
  the corresponding variables {\tt V}$_i$, and repeating this as long as the
  value of one of the variables was changed. This is typically used for
  solving a set of dataflow equations. \footnote{Probably, the syntax of this
  construct should more emphasize that it is a set of equations.}

\section{Built-in Operators}

\note{The format of this section will be changed to the style of the built-in
  functions.}

In the following two tables the built-in operators and functions are given.
For readability, the argument types are indicated as follows:
\begin{itemize}
\item \emph{bool}: argument is of type {\tt bool}
\item \emph{int}: argument is of type {\tt int}
\item \emph{str}: argument is of type {\tt str}
\item \emph{area}: argument is of type {\tt area}
\item \emph{tuple}: argument is any tuple type.
\item \emph{bag}: argument is of any bag type
\item \emph{rel}: argument is of any relation type
\end{itemize}

\tablecaption{Built-in operators}
\tablehead{\hline}
\tabletail{\hline}
\begin{supertabular}{|p{3.3cm}|p{10.7cm}|} \hline

\emph{bool}$_1$ \texttt{and} \emph{bool}$_2$ & yields {\tt true} if both arguments have the value true and
{\tt false} otherwise\\ \hline

\emph{bool}$_1$ \texttt{or} \emph{bool}$_2$ & yields {\tt true} if either argument has
                         the value {\tt true} and {\tt false} otherwise\\ \hline

\emph{bool}$_1$ \texttt{implies} \emph{bool}$_2$ & yields {\tt false} if
                             \emph{bool}$_1$ has the value {\tt true} and
                               \emph{bool}$_2$ has value {\tt false}, and
                         {\tt true} otherwise\\ \hline

{\tt not} \emph{bool} & yields true if \emph{bool} is {\tt false} and {\tt true} otherwise \\
\hline

\emph{any} {\tt in} \emph{bag} & yields true if \emph{any} occurs as element
in \emph{bag} and false otherwise \\ \hline

\emph{any} {\tt notin} \emph{bag} & yields {\tt false} if \emph{any} occurs as
element in \emph{bag} and {\tt true} otherwise \\ \hline \hline

\emph{\emph{tuple}} {\tt in} \emph{rel} & yields true if the left argument occurs as element in the
right argument and false otherwise \\ \hline

\emph{\emph{tuple}} {\tt notin} \emph{rel} & yields false if the left argument occurs as element in the
right argument and true otherwise \\ \hline \hline

\emph{bag} {\tt ==} \emph{bag} & yields true if both arguments are equal bags and false
otherwise\\ \hline

\emph{bag} {\tt !=} \emph{bag} & yields true if both arguments are unequal bags and false
otherwise\\ \hline

\emph{bag} {\tt <=} \emph{bag} & yields true if the left argument is a subset of the right argument
and false otherwise\\ \hline

\emph{bag} {\tt <} \emph{bag} & yields true if the left argument is a strict subset of the right argument
and false otherwise\\ \hline

\emph{bag} {\tt >=} \emph{bag} & yields true if the left argument is a superset of the right argument
and false otherwise\\ \hline

\emph{bag} {\tt >} \emph{bag} & yields true if the left argument is a strict superset of the right argument
and false otherwise\\ \hline \hline

\emph{rel} {\tt ==} \emph{rel} & yields true if both arguments are equal relations and false
otherwise\\ \hline

\emph{rel} {\tt !=} \emph{rel} & yields true if both arguments are unequal relations and false
otherwise\\ \hline

\emph{rel} {\tt <=} \emph{rel} & yields true if the left argument is a subset of the right argument
and false otherwise\\ \hline

\emph{rel} {\tt <} \emph{rel} & yields true if the left argument is a strict subset of the right argument
and false otherwise\\ \hline

\emph{rel} {\tt >=} \emph{rel} & yields true if the left argument is a superset of the right argument
and false otherwise\\ \hline

\emph{rel} {\tt >} \emph{rel} & yields true if the left argument is a strict superset of the right argument
and false otherwise\\ \hline \hline

\emph{int} {\tt ==} \emph{int} & yields true if both arguments are numerically equal and false
otherwise\\ \hline

\emph{int} {\tt !=} \emph{int} & yields true if both arguments are numerically unequal  and false
otherwise\\ \hline

\emph{int} {\tt <=} \emph{int} & yields true if the left argument is numerically less than
or equal the right argument and false otherwise\\ \hline

\emph{int} {\tt <} \emph{int} & yields true if the left argument is a numerically less than the right argument
and false otherwise\\ \hline

\emph{int} {\tt >=} \emph{int} & yields true if the left argument is numerically greater
than or equal the right argument and false otherwise\\ \hline

\emph{int} {\tt >} \emph{int} & yields true if the left argument is numerically greater than the right argument
and false otherwise\\ \hline \hline

\emph{bag} {\tt union} \emph{bag} & yields the bag resulting from the union of the two arguments
 \\ \hline

\emph{bag} {\tt inter} \emph{bag} & yields the bag resulting from the intersection of the two arguments
 \\ \hline

\emph{bag} \verb+\+ \emph{bag} & yields the bag resulting from the difference of the two arguments
 \\ \hline \hline

\emph{rel} {\tt union} \emph{rel} & yields the relation resulting from the union of the two arguments
 \\ \hline

\emph{rel} {\tt inter} \emph{rel} & yields the relation resulting from the intersection of the two arguments
 \\ \hline

\emph{rel} \verb+\+ \emph{rel} & yields the relation resulting from the difference of the two arguments
 \\ \hline

\emph{rel} {\tt o} \emph{rel} & yields the relation resulting from the composition of the two arguments
 \\ \hline


\emph{bag} {\tt x} \emph{bag} & yields the relation resulting from the carthesian product of the two arguments
 \\ \hline

\emph{rel} {\tt +} & yields the relation resulting from the transitive closure of
 the argument  \\ \hline

\emph{rel} {\tt *}  & yields the relation resulting from the reflexive transitive closure of
 the argument  \\ \hline

\end{supertabular}

\section{Built-in functions}

\tablecaption{Built-in functions}
\tablehead{\hline}
\tabletail{\hline}


\newcommand{\function}[4]{\subsection{#1}
Definition:
\begin{quote}
#2
\end{quote}
#3
Example(s):
\begin{itemize}
#4
\end{itemize}
}

\function{The identity relation: {\tt id}}
{\tt rel[$T$,$T$] id(bag[$T$] B) = \{ <X, X> | X : B \}}
{Yields the relation that results from transforming
each element in {\tt B} into a pair with that element as first and
second element.
}
{
\item {\tt id(\{1,2,3\})} yields {\tt \{<1,1>, <2,2>, <3,3>\}}.
\item \begin{sloppypar} {\tt id(\{"mon", "tue", "wed"\}} yields {\tt \{<"mon","mon">,
  <"tue","tue">, <"wed","wed">\}}. \end{sloppypar}
}

\function{The domain of a relation: {\tt domain}}
{\tt bag[$T_1$] domain (rel[$T_1$,$T_2$] R) = \{ X | <X, Y> : R \}}
{Yields the bag that results from taking
the first element of each tuple in relation {\tt R}.
}
{
\item {\tt domain(\{<1,10>, <2,20>\})} yields {\tt \{1, 2\}}.
\item {\tt domain(\{<"mon", 1>, <"tue", 2>\})} yields {\tt \{"mon", "tue"\}}.

}

\function {The range of a relation: {\tt range}}
{\tt bag[$T_2$] range (rel[$T_1$,$T_2$] R) = \{ Y | <X, Y> : R \}}
{Yields the bag that results from taking
the second element of each tuple in relation {\tt R}.
}
{
\item {\tt range(\{<1,10>, <2,20>\})} yields {\tt \{10, 20\}}.
\item {\tt range(\{<"mon", 1>, <"tue", 2>\})} yields {\tt \{1, 2\}}.
}

\function {The carrier of a relation: {\tt carrier}}
{\tt bag[$T$]  carrier (rel[$T$,$T$] R) = domain(R) union range(R)}
{Yields the bag that results from taking
the first and  second element of each tuple in the relation {\tt R}.
Note that the domain and range type of {\tt R} should be the same.
}
{
\item {\tt carrier(\{<1,10>, <2,20>\})} yields {\tt \{1, 10, 2, 20\}}.
}

\function {The top of a relation: {\tt top}}
{\tt bag[$T$] top(rel[$T$, $T$] R) = domain(R) BACKSLASH range(R)}
{Yields the bag of all roots when the relation {\tt R} is
viewed as a graph. Note that the domain and range type of {\tt R} should be the same.
}
{
\item {\tt top(\{<1,2>, <1,3>, <2,4>, <3,4>\}} yields {\tt \{1\}}.
}

\function{The bottom of a relation: {\tt bottom}}
{\tt bag[$T$] bottom(rel[$T$,$T$] R) = range(R) BACKSLASH domain(R)}
{Yields the bag of all leaves when the relation {\tt R} is
viewed as a graph. Note that the domain and range type of {\tt R} should be
the same.
}
{
\item {\tt bottom(\{<1,2>, <1,3>, <2,4>, <3,4>\}} yields {\tt \{4\}}.
}

\function{The inverse of a relation: {\tt inv}}
{\tt rel[$T_2$,$T_1$] inv (rel[$T_1$,$T_2$] R) = \{ <Y, X> | <X, Y> : R \}}
{ Yields the relation that is the inverse of the
argument relation {\tt R}, i.e. the relation in which the elements of all
tuples in {\tt R} have been
interchanged.
}
{
\item {\tt inv(\{<1,10>, <2,20>\})} yields {\tt \{<10,1>,<20,2>]}.
}
\function{The complement of a relation: {\tt compl}}
{\tt rel[$T_1$, $T_2$] compl(rel[$T_1$,$T_2$] R) = (domain(R) x range(R)) BACKSLASH R}
{ Yields the relation that is the complement of the
argument relation {\tt R}, using the carrier set of {\tt R} as universe.
}
{
\item {\tt compl(\{<1,10>\}}  yields {\tt \{<1, 1>, <10, 1>, <10, 10>\}}.
}

\function{Domain restriction of a relation: {\tt domainR}}
{\tt rel[$T_1$,$T_2$] domainR (rel[$T_1$,$T_2$] R, Bag[$T_1$] B) = \\
   \{ <X, Y> | <X, Y> : R, X in B \}}
{ Yields a relation identical to the relation {\tt R}
  but only containing tuples whose first element occurs in bag {\tt B}.
}
{
\item {\tt domainR(\{<1,10>, <2,20>, <3,30>\}, \{3, 1\}} yields {\tt \{<1,10>, <3,30>\}}.
}

\function{Range restriction of a relation: {\tt rangeR}}
{\tt rel[$T_1$,$T_2$] rangeR (rel[$T_1$,$T_2$] R, Bag[$T_2$] B) =  \\
   \{ <X, Y> | <X, Y> : R, Y in B \}}
{ Yields a relation identical to relation {\tt R} but only containing tuples
  whose second element occurs in bag {\tt B}.
}
{
 \item {\tt rangeR(\{<1,10>, <2,20>, <3,30>\}, \{30, 10\}} yields {\tt \{<1,10>, <3,30>\}}.
}

\function{Carrier restriction of a relation: {\tt carrierR}}
{\tt rel[$T$,$T$] carrierR (rel[$T$,$T$] R, Bag[$T$] B) = \\ 
   \{ <X, Y> | <X, Y> : R, X in B, Y in B \}}
{ Yields a relation identical to relation {\tt R}
  but only containing tuples whose first and second element occur in bag {\tt
    B}.
}
{
 \item {\tt carrierR(\{<1,10>, <2,20>, <3,30>\}, \{10, 1, 20\}} yields {\tt \{<1,10>\}}.
}

\function{Domain exclusion of a relation: {\tt domainX}}
{\tt rel[$T_1$,$T_2$] domainX (rel[$T_1$,$T_2$] R, Bag[$T_1$] B) = \\
   \{ <X, Y> | <X, Y> : R, X notin B \}}
{ Yields a relation identical to relation {\tt R}
  but with all tuples removed whose first element occurs in bag {\tt B}.}
{
\item {\tt domainX(\{<1,10>, <2,20>, <3,30>\}, \{3, 1\}} yields {\tt \{<2, 20>\}}.
}

\function{Range exclusion of a relation: {\tt rangeX}}
{\tt rel[$T_1$,$T_2$] rangeX (rel[$T_1$,$T_2$] R, Bag[$T_2$] B) = \\
	   \{ <X, Y> | <X, Y> : R, Y notin B \}}
{ Yields a relation identical to relation {\tt R} but with all tuples removed
  whose  second element occurs in bag {\tt B}.}
{
 \item {\tt rangeX(\{<1,10>, <2,20>, <3,30>\}, \{30, 10\}} yields {\tt \{<2, 20>\}}.
}

\function{Carrier exclusion of a relation: {\tt carrierX}}
{\tt rel[$T$,$T$] carrierX (rel[$T$,$T$] R, Bag[$T$] B) = \\
   \{ <X, Y> | <X, Y> : R, X notin B, Y notin B \}}
{ Yields a relation identical to relation {\tt R}
  but with all tuples removed whose first or second element occurs in bag {\tt
    B}.}
{
 \item {\tt carrierX(\{<1,10>, <2,20>, <3,30>\}, \{10, 1, 20\}} yields {\tt \{<3,30>\}}.
}

\function{First element of a tuple: {\tt first}}
{\tt $T_1$ first(<$T_1$, $T_2$> P) = primitive}
{ Yields the first element of the tuple {\tt P}.}
{
\item {\tt first(<1, 10>)} yields {\tt 1}.
\item {\tt first(<"mon", 1>)} yields {\tt "mon"}.
}

\function{Second element of a tuple: {\tt second}}
{\tt $T_2$ second(<$T_1$, $T_2$> P) = primitive}
{ Yields the second element of the tuple {\tt P}.}
{
\item {\tt second(<1, 10>)} yields {\tt 10}.
\item {\tt second(<"mon", 1>)} yields {\tt 1}.
}

\function{Reachability with restriction: {\tt reachR}}
{\tt rel[$T$,$T$] reachR( bag[$T$] Start, bag[$T$] Restr, rel[T,T] Rel) =\\
	       domainR(Rel, Start) o carrierR(Rel, Restr)+ }
{ Yields the relation that describes
which elements can be reached from  bag {\tt Start} using the relation {\tt Rel}, such that only elements in
bag {\tt Restr} are used.
}
{
\item  {\tt reachR(\{1\}, \{1, 2, 3\}, \{<1,2>, <1,3>, <2,4>, <3,4>\})} yields  {\tt
  \{<1,2>, <1, 3>\}}.
}

\function{Reachability with exclusion: {\tt reachX}}
{\tt rel[$T$,$T$] reachX( bag[$T$] Start, bag[$T$] Excl, rel[T,T] Rel) =\\
	       domainR(Rel, Start) o carrierX(Rel, Excl)+ }
{ Yields the relation that describes
which elements can be reached from  bag {\tt Start} using the relation {\tt Rel}, such that no elements in
bag {\tt Excl} are used.
}
{
\item  {\tt reachX(\{1\}, \{2\}, \{<1,2>, <1,3>, <2,4>, <3,4>\})} yields  {\tt
  \{<1,3>, <1, 4>\}}.
}

\function{Powerser of a bag: {\tt power}}
{\tt bag[bag[$T$]] power(bag[$T$] B) = primitive}
{ Yields the powerset of bag {\tt B}.}
{
\item \begin{sloppypar} {\tt power(\{1, 2, 3, 4})\} yields {\tt \{ \{\}, \{1\},
    \{2\}, \{3\}, \{4\},\{1,2\}, \{1,3\}, \{1,4\}, \{2,3\}, \{2,4\}, \{3,4\},
    \{1,2,3\}, \{1,2,4\}, \{1,3,4\}, \{2,3,4\}, \{1,2,3,4\}\}} \end{sloppypar}
}

\function{File name of an area: {\tt filename}}
{\tt str filename(area A) = primitive}
{Yields the file name of area {\tt A}.}
{  
\item {\tt filename(area("pico1.trm",5,2,6,8))} yields {\tt "pico1.trm"}.
}

\function{Beginning line of an area: {\tt beginline}}
{\tt int beginline(area A) = primitive}
{Yields the first line of area {\tt A}.}
{  
\item {\tt beginline(area("pico1.trm",5,2,6,8))} yields {\tt 5}.
}

\function{First column of an area: {\tt begincol}}
{\tt int begincol(area A) = primitive}
{Yields the first column of area {\tt A}.}
{  
\item {\tt begincol(area("pico1.trm",5,2,6,8))} yields {\tt 2}.
}

\function{Ending line of an area: {\tt endline}}
{\tt int endline(area A) = primitive}
{Yields the last line of area {\tt A}.}
{  
\item {\tt endline(area("pico1.trm",5,2,6,8))} yields {\tt 6}.
}

\function{Ending column of an area: {\tt endcol}}
{\tt int endcol(area A) = primitive}
{Yields the last column of area {\tt A}.}
{  
\item {\tt endcol(area("pico1.trm",5,2,6,8))} yields {\tt 8}.
}

\function{Summation of a bag of integers: {\tt sum}}
{\tt int sum(bag[int] B) = primitive}
{Yields the sum of the integers in bag {\tt B}.}
{
\item {\tt sum(\{1, 2, 3\})} yields {\tt 6}.
}

\function{Maximum of a bag of integers: {\tt max}}
{\tt int max(bag[int] B) = primitive}
{Yields the largest integer in bag {\tt B}.}
{
\item {\tt max(\{1, 2, 3\})} yields {\tt 3}.
}

\function{Minimum of a bag of integers: {\tt max}}
{\tt int min(bag[int] B) = primitive}
{Yields the smalles integer in bag {\tt B}.}
{
\item {\tt min(\{1, 2, 3\})} yields {\tt 1}.
}

\section{Larger Examples}

\subsection{Analyzing the call structure of an application}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/calls.eps,width=15cm}
\vspace*{-14cm}
\end{center}
\caption{\label{FIG:calls} Graphical representation of the {\tt calls} relation}
\end{figure}

Now we will explore the call structure of an application.
Suppose that the following facts have been extracted from the source
code and are represented by the relation {\tt calls}:

\begin{quote}
{\tt rel[str, str] calls = \{<"a", "b">, <"b", "c">, <"b", "d">, 
   <"d", "c">, <"d","e">, <"f", "e">, <"f", "g">, <"g", "e">\}}.
\end{quote}
A first step in the analysis is to determine which \emph{entry points}
this application has, i.e., procedures which call others but are not called
themselves. This can be done by determining the top of the
{\tt calls} relation:

\begin{quote}
{\tt bag[str] topCalls = top(calls)}
\end{quote}

\noindent In this case, {\tt topCalls} is equal to  {\tt \{"a", "f"\}}.
In other words, procedures {\tt "a"} and {\tt "f"} are the entry points
of this application.

In a similar spirit, we can determine the \emph{leaves} of this application,
i.e., procedures that are being called but do not make any calls themselves:

\begin{quote}
{\tt bag[str] bottomCalls = bottom(calls)}.
\end{quote}
In this case, {\tt bottomCalls} is equal to  {\tt \{"c", "e"\}}.

We can also determine the \emph{indirect calls} between procedures, by
taking the transitive closure of the {\tt calls} relation:

\begin{quote}
{\tt rel[str,str] closureCalls = calls+}
\end{quote}
In this case, {\tt closureCalls} is equal to
\begin{quote}
	{\tt \{<"a", "b">, <"b", "c">, <"b", "d">, <"d", "c">, 
	<"d","e">, <"f", "e">, <"f", "g">, <"g", "e">, 
	<"a", "c">, <"a", "d">, <"b", "e">, <"a", "e">\}}
\end{quote}

We know now the entry points for this application and the indirect call
relations. Combining this information, we can determine which procedures are
called from each entry point:
\begin{quote}
{\tt bag[str] calledFromA = closureCalls["a"]}
\end{quote}
yields {\tt \{"b", "c", "d", "e"\}} and
\begin{quote}
{\tt bag[str] calledFromF = closureCalls["f"]}
\end{quote}
yields {\tt  \{"e", "g"\}}.
Finally, we can determine which procedures are called from both entry points:
\begin{quote}
{\tt bag[str] shared = calledFromA inter calledFromF}
\end{quote}
which yields {\tt \{"e"\}}.

These findings can be verified by inspecting a graph view
of the calls relation as shown in Figure~\ref{FIG:calls}.
Observe that such a visual inspection does not scale to large graphs.


\section{Running a \rscript}
Currently, the definition of \rscript resides in {\tt /ufs/glt/CVS}.
 You can also checkout your own copy by means of
{\tt cvs -d ssh.cwi.nl:/ufs/glt/CVS co relation-calculus}.

\paragraph{Running a script}
\begin{itemize}
\item Change to your copy of the directory {\tt relation-calculus}.
\item Start the ASF+SDF Meta-Environment by the command {\tt meta}.
\item Open the module {\tt Rscript.sdf}.
\item Open your own term, using the Rscript module.
\item Observe that a new menu call {\tt Rscript} appears in the menu bar.
\item Click the parse button in the {\tt Actions} menu of the editor:
now we know whether there are syntax errors. If so, correct them.

\item Click the {\tt Check} button in the {\tt Rscript} menu: this will
  perform a type check of your script. If there are type errors, correct them.

\item Click the {\tt Execute} button in the {\tt Rscript} menu to execute your script: a new
editor pops up which shows all the variables at the end of the execution.
\end{itemize}

\paragraph{Running a Test suite} \label{running}
Same as above but use {\tt Testsuite} button instead of the {\tt Execute}
button in the {\tt Rscript} menu.  The effect is that the script is executed
and that a summary is printed of {\tt assert} statement that succeeded or
failed.

\paragraph{Miscellaneous}
The subdirectory {\tt rscripts} contains several sample scripts.  See {\tt
test1.rscript} and {\tt tests2.rscript} for examples of the use of built-in
operators and functions.

The subdirectory {\tt demo} contains larger demos.

\section{Pseudo definitions of some built-in operators and functions}

It is interesting that most (but not all!) built-in operators and all
functions can be defined in \rscript itself. They only serve convenience and
efficiency.  The definitions marked with a dagger ($\dagger$) cannot be written
as such since it is not possible to define operators in \rscript.  It is,
however, allowed to write these polymorphic definitions where {\tt T1}, {\tt
T2}, ... represent arbitrary types.

\paragraph{$^\dagger$Composition: {\tt o}}

\begin{verbatim}
rel[T1,T3] o(rel[T1,T2] R1, rel[T2,T3] R2) =
   {<v, y> | <v, w> : R1, <x, y> :  R2, w == x }
\end{verbatim}

\paragraph{$^\dagger$Carthesian product: {\tt x}}
\begin{verbatim}
rel[T1,T2] x(bag[T1] B1, bag[T2] B2) =
   {<x, y> | x : B1, y : B2 }
\end{verbatim}

\paragraph{$^\dagger$ Left image: {\tt .}}
\begin{verbatim}
bag[T2] .(T1 E, rel[T1,T2] R) = { W | <V, W> : R, V == E }
bag[T2] .(bag[T1] B, rel[T1,T2] R) = { W | <V, W> : R, V in B}
\end{verbatim}

\paragraph{$^\dagger$Right image: {\tt .}}
\begin{verbatim}
bag[T1] .(rel[T1,T2] R, T2 E) = { V | <V, W> : R, W == E }
bag[T1] .(rel[T1,T2] R, bag[T2] B) = { V | <V, W> : R, W in B }
\end{verbatim}




\section{Differences with previous versions}
\rscript is in under active development and several (incompatible)  changes
have been made in the last few weeks. Here is an indicative list.

\begin{itemize}

\item The syntax of comprehension has been changed. Old
\begin{verbatim}
  { <X, Y> : <X, Y> in R | X in B and Y  in B }
\end{verbatim}
New:
\begin{verbatim}
  { <X, Y> | <X, Y> : R, X in B and Y in B }
\end{verbatim}

\item The type {\tt node} has been renamed into {\tt area}

\end{itemize}

\end{document}
