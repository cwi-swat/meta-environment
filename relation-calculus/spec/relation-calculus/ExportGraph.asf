equations

[mkNodeId1]
	mkNodeId(natcon($Char*)) = strcon(""" "N" $Char* """)

[mkNodeId2]
	mkNodeId($StrCon) = $StrCon

[mkGraph1]
	mkGraph(null) = graph([],[],[])

[mkGraph1]
	mkGraph($Node) = graph([$Node],[],[])

[mkGraph1]
	mkGraph($Edge) = graph([],[$Edge],[])

[mkGraph1]
	mkGraph($Instr1) = graph([$Node*1],[$Edge*1],[$Attribute*1]),
	mkGraph($Instr2) = graph([$Node*2],[$Edge*2],[$Attribute*2])
	========================================================	
	mkGraph($Instr1 ++ $Instr2) = 
	graph([$Node*1, $Node*2],[$Edge*1, $Edge*2],[$Attribute*1,
	$Attribute*2])

[export-graph-bool1]
	export-graph-bool($BoolCon) = export-graph($BoolCon)

[export-graph-int1]
	export-graph-int($NatCon) = export-graph($NatCon)

[export-graph-str1]
	export-graph-str($StrCon) = export-graph($StrCon)

[export-graph-set1]
	export-graph-set($Set) = export-graph($Set)

[export-graph1]
	gen($Elem, 0) = <$N, $N', $Instr>
	=====================================================
	export-graph($Elem) = mkGraph($Instr)

[mkBoolNode1]	
	$StrCon := "true"
	=====================================================
	mkBoolNode(true, $N) = <$N, $N+1, node(mkNodeId($N), [label($StrCon),shape(triangle)])>

[mkBoolNode2]
		$StrCon := "false"
	=====================================================	
	mkBoolNode(false, $N) = <$N, $N+1, node(mkNodeId($N), [label($StrCon),shape(triangle)])>

[mkStringNode1]	
	$StrCon = strcon(""" "\" """ $Char* "\" """ """)
	=====================================================
	mkStringNode(strcon(""" $Char* """), $N) = <$N, $N+1, node(mkNodeId($N), [label($StrCon),shape(box)])>

[mkIntegerNode1]
	$StrCon = strcon(""" $Char* """)
	=====================================================
	mkIntegerNode(natcon($Char*), $N) = <$N, $N+1, node(mkNodeId($N), [label($StrCon),shape(circle)])>

[mkLocNode1] 
	mkLocNode($Loc, $N) =
	 	<$N, $N+1, node(mkNodeId($N), [label("area"),shape(parallelogram)])>

[gen-bool]
	gen($BoolCon, $N)	= mkBoolNode($BoolCon, $N)

[gen-int]	
	gen($NatCon, $N)	= mkIntegerNode($NatCon, $N)

[gen-string]
	gen($StrCon, $N) 	= mkStringNode($StrCon, $N)

[gen-area]
	gen($Loc, $N) 		= mkLocNode($Loc, $N)

[gen-relation1]
	gen({$Tuple, $Elem*}, $N) = gen-rel({$Tuple, $Elem*}, $N)

[gen-set-1]	
	gen({$Elem, $Elem*}, $N) = gen-set({$Elem, $Elem*}, $N)

[gen-empty] 	
	gen({}, $N) = <$N, $N, null>

[gen-set-1]
	gen-set1($Set, $N, $N+1) = <$N1, $N1', $Instr>
	==============================================
	gen-set($Set, $N) = <$N, $N1', $Instr ++  node(mkNodeId($N), [label("Set"),shape(octagon)])>

[gen-set1-1]
	gen($Elem, $N') = <$N1, $N1', $Instr1>,
	gen-set1({$Elem*}, $N, $N1') = <$N2, $N2', $Instr2>
	============================================
	gen-set1({$Elem, $Elem*}, $N, $N') = 
	<$N, $N2', $Instr1 ++ $Instr2 ++ edge(mkNodeId($N), mkNodeId($N1),[direction(none)])>
[gen-set1-2]
	gen-set1({}, $N, $N') = <$N, $N', null>


[gen-rel-1]
	gen-rel1($Set, $N, {}) = <$N1, $N1', $Instr, $Table>
	==============================================
	gen-rel($Set, $N) = <$N, $N1', $Instr>

[gen-rel1-1]
	gen-tuple($Tuple, $N, $Table) = <$N1, $N1', $Instr1, $Table'>,
	gen-rel1({$Elem*}, $N1', $Table') = <$N2, $N2', $Instr2, $Table''>
	==============================================
	gen-rel1({$Tuple, $Elem*}, $N, $Table) = 
	<0, $N2', $Instr1 ++ $Instr2, $Table''>

[gen-rel1-3]
	gen-rel1({}, $N, $Table) = <$N, $N, null, $Table>

[gen-tuple-1]
	gen-elem($Elem1, $N, $Table) = <$N1, $N1', $Instr1, $Table'>,
	gen-elem($Elem2, $N1', $Table') = <$N2, $N2',$Instr2, $Table''>
	==============================================
	gen-tuple(<$Elem1, $Elem2>, $N, $Table) =
	<0, $N2', $Instr1 ++ $Instr2 ++ edge(mkNodeId($N1), mkNodeId($N2),[direction(back)]), $Table''>


[gen-elem-1]
	rimage($Table, $Elem) == {},
	{$Elem*1} := $Table,
	$Table' := {<$Elem, $N>, $Elem*1},
	 <$N1, $N1', $Instr> := gen($Elem, $N)
	=============================================
	gen-elem($Elem, $N, $Table) = <$N1, $N1', $Instr, $Table'>

[gen-elem-1]
	{$N1} := rimage($Table, $Elem)
	=============================================
	gen-elem($Elem, $N, $Table) = <$N1, $N, null, $Table>
