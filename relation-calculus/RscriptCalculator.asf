 equations

%%---- Store

%% Get value of a variable

[VL1]	value($Var, [<$Var, $Val>, $VPair*]) = $Val
[VL2]	$Var != $Var' ===> value($Var, [<$Var', $Val>, $VPair*]) = value($Var, [$VPair*])

%% Assign value to variable

[ASG1]  assign($Var, $Val, [$VPair*1, <$Var, $Val'>, $VPair*2]) = [$VPair*1, <$Var, $Val>, $VPair*2]
	

[default-ASG1]	
	assign($Var, $Val, [$VPair*]) = [<$Var, $Val>, $VPair*]

%% Add tuple to a relation

[AT1]	add-tuple($Var, <$Elem1, $Elem2>, [<$Var, $Val>, $VPair*]) = 
	[<$Var, apply({<$Elem1, $Elem2>} union $Val)>, $VPair*]

[AT2]	$Var != $Var', 
	[$VPair*'] = add-tuple($Var, <$Elem1, $Elem2>, [$VPair*])
	===============================================================
	add-tuple($Var, <$Elem1, $Elem2>, [<$Var', $Val>, $VPair*]) = [<$Var', $Val>, $VPair*']

[AT3]	add-tuple($Var, <$Elem1, $Elem2>, []) = [< $Var, {<$Elem1, $Elem2>} >]

%% Extend a relation

[ER1]	extend-rel($Var, $Rel, [<$Var, $Val>, $VPair*]) = [<$Var, apply($Rel union $Val)>, $VPair*]

[ER2]	$Var != $Var', 
	[$VPair*'] = extend-rel($Var, $Rel, [$VPair*])
	===============================================================
	extend-rel($Var, $Rel, [<$Var', $Val>, $VPair*]) = [<$Var', $Val>, $VPair*']

[ER3]	extend-rel($Var, $Rel, []) = [< $Var, $Rel >]

%%---- if on VALUEs

[if1]	if true then $Val1 else $Val2 fi  = $Val1
[if2]	if false then $Val1 else $Val2 fi = $Val2

%%---- Equality on elements

[e1]	equal($Elem, $Elem)  = true
[default-e2] 
	equal($Elem, $Elem') = false

%% --- Equality on RVALUEs

[ev1]	equal($Val, $Val) = true
[default-ev2]
	equal($Val, $Val') = false

[v2b]	rval2bag($Bag) = $Bag
[v2r]	rval2rel($Rel) = $Rel

%%---- Specialized versions of evalx that return value of required type

[EVP]	$Bool = evalx($Exp, $Store)               ===> evalp($Exp, $Store) = $Bool

[EVE1]	$Elem = evalx($Exp, $Store)                 ===> evale($Exp, $Store) = $Elem

[EVB1]	$Bag = evalx($Exp, $Store)     ===> evalb($Exp, $Store) = $Bag

%%[EVB2]	*empty* = evalx($Exp, $Store)  ===> evalb($Exp, $Store) = {}

[EVR1]	$Rel = evalx($Exp, $Store)     ===> evalr($Exp, $Store) = $Rel

%%[EVR1]	*empty* = evalx($Exp, $Store)  ===> evalr($Exp, $Store) = {}

%% ---- Eval complete script

[ES0]	eval-rscript($Stat*, $Var, $Store) = value($Var, eval-rscript($Stat*, $Store))

[ES1]	eval-rscript($Stat*) = eval-rscript($Stat*, [])

[ES2]	eval-rscript($Stat $Stat*, $Store) = eval-rscript($Stat*, eval-rscript($Stat, $Store))
[ES3]	eval-rscript( , $Store) = $Store

%% ---- Eval statements

[S1]	eval-rscript(bool $Var, $Store) 	= assign($Var, true, $Store)
[S2]	eval-rscript(int $Var, $Store)  	= assign($Var, 0, $Store)
[S3]	eval-rscript(str $Var, $Store)  	= assign($Var, "", $Store)
[S4]	$Bag = EmptyBag ===>  eval-rscript(bag[$Etype] $Var, $Store)  = assign($Var, $Bag, $Store)	
[S5]	$Rel = EmptyBag ====> eval-rscript(rel[$Etype1, $Etype2] $Var, $Store) 
						 = assign($Var, $Rel, $Store)

[S6]	eval-rscript($Etype $Var = $Exp, $Store) = assign($Var, evalx($Exp, $Store), $Store)
[S7]	eval-rscript($Etype1 $Var1($Etype2 $Var2) = $Exp, $Store) 
						= assign($Var1, <$Var2, $Exp>, $Store)

[S8]	eval-rscript($Etype1 $Var1($Etype2 $Var2, $Etype3 $Var3) = $Exp, $Store) 
						= assign($Var1, <$Var2, $Var3, $Exp>, $Store)

[S9]	eval-rscript($Etype1 $Var1($Etype2 $Var2, $Etype3 $Var3, $Etype4 $Var4) = $Exp, $Store) 
						= assign($Var1, <$Var2, $Var3, $Var4, $Exp>, $Store)

%% --- Solve Sets of equations


[SL1]	eval-rscript(solve {$Var1 = $Exp1}, $Store) = 
	solve1(1000, $Var1, $Exp1, $Store)

[SL1]	eval-rscript(solve($Integer) {$Var1 = $Exp1}, $Store) = 
	solve1($Integer, $Var1, $Exp1, $Store)

[SL2]	eval-rscript(solve {$Var1 = $Exp1, $Var2 = $Exp2}, $Store) = 
	solve2(1000, $Var1, $Exp1, $Var2, $Exp2, $Store)

[SL2]	eval-rscript(solve($Integer){$Var1 = $Exp1, $Var2 = $Exp2}, $Store) = 
	solve2($Integer, $Var1, $Exp1, $Var2, $Exp2, $Store)

[SL1-1]	$Integer > 0 = true,
	$Val1 = value($Var1, $Store),
	$Val1' = evalx($Exp1, $Store),
	$Store' = assign($Var1, $Val1', $Store),
	equal($Val1, $Val1') = false
	===========================================
	solve1($Integer, $Var1, $Exp1, $Store) =
	solve1($Integer - 1, $Var1, $Exp1, $Store')

[default-SL1-2]	
	solve1($Integer, $Var1, $Exp1, $Store) = $Store


[SL2-1]	$Integer > 0 = true,
	$Val1 = value($Var1, $Store),
	$Val1' = evalx($Exp1, $Store),
	$Val2 = value($Var2, $Store),
	$Val2' = evalx($Exp2, $Store),
	$Store' = assign($Var1, $Val1', $Store),
	$Store'' = assign($Var2, $Val2', $Store'),
	equal($Val1, $Val1') & equal($Val2, $Val2') = false
	===========================================
	solve2($Integer, $Var1, $Exp1, $Var2, $Exp2, $Store) =
	solve2($Integer - 1, $Var1, $Exp1, $Var2, $Exp2, $Store'')

[default-SL2-2]	
	solve2($Integer, $Var1, $Exp1, $Var2, $Exp2, $Store) = $Store

%% ---- Eval one REXP

[ER1]	eval-rexp($Exp, $Store) = evalx($Exp, $Store)


%% ---- The main evaluation function evalx

%% ---- Eval true, false, elements and variables

[TR]	evalx(true, $Store) = true

[FL]	evalx(false, $Store) = false

[ELM]	evalx($Elem, $Store) = $Elem

[VAR1]	evalx($Var, $Store)  = value($Var, $Store)

%% ---- Eval tuples

[ET1]	$Elem1 = evale($Exp1, $Store),
	$Elem2 = evale($Exp2, $Store)
	==================================================
	evalx(<$Exp1, $Exp2>, $Store) = <$Elem1, $Elem2>

%% ---- Eval bags

[EB2]	$Elem = evale($Exp, $Store), {$Elem+} = evalb({$Exp+}, $Store)
	===================================================
	evalx({$Exp, $Exp+}, $Store) = {$Elem, $Elem+}

[EB3]	$Elem = evale($Exp, $Store)
	===================================================
	evalx({$Exp}, $Store) = {$Elem}

%% ---- Eval relations

[ER2]	$Elem1 = evale($Exp1, $Store), $Elem2 = evale($Exp2, $Store),
	evalr({$Exp+}, $Store) = {$Tuple+}
	====================================================
	evalx({<$Exp1, $Exp2>, $Exp+}, $Store) = {<$Elem1, $Elem2>, $Tuple+}

[ER3]	$Elem1 = evale($Exp1, $Store), $Elem2 = evale($Exp2, $Store)
	====================================================
	evalx({<$Exp1, $Exp2>}, $Store) = {<$Elem1, $Elem2>}

%% ---- Eval binary infix operators

%%[EMP1]	apply(*empty* $Op2 *empty*)	= *empty*
%%MP1]	apply($Bag $Iop *empty*)	= apply($Bag $Iop EmptyBag)
%%MP2]	apply(*empty* $Iop $Bag)	= apply(EmptyBag $Iop $Bag)

%%[EMP3]	apply($Rel $Iop *empty*)	= apply($Rel $Iop EmptyRel)
%%[EMP4]	apply(*empty* $Iop $Rel)	= apply(EmptyRel $Iop $Rel)

[AND1]	evalx($Exp1 and $Exp2, $Store) 	= apply(evalx($Exp1, $Store) and evalx($Exp2, $Store))
[AND2]	apply($Bool1 and $Bool2) 	= $Bool1 & $Bool2

[OR1]	evalx($Exp1 or $Exp2, $Store) 	= apply(evalx($Exp1, $Store) or evalx($Exp2, $Store))
[OR2]	apply($Bool1 or $Bool2) 	= $Bool1 | $Bool2	

[IN1]	evalx($Exp1 in $Exp2, $Store) 	= apply(evalx($Exp1, $Store) in evalx($Exp2, $Store))
%%[IN2]	apply($Elem in *empty*) 	= false
[IN3]	apply($Elem in $Bag) 		= in($Elem, $Bag)
%%[IN4]	apply(<$Elem1, $Elem2> in *empty*) 
%%					= false
[IN5]	apply(<$Elem1, $Elem2> in $Rel) = in(<$Elem1, $Elem2>, $Rel)

[NI1]	$Bool = apply(evalx($Exp1, $Store) in evalx($Exp2, $Store))
	===========================================================
	evalx($Exp1 notin $Exp2, $Store)= not($Bool)

[EQ1]	evalx($Exp1 == $Exp2, $Store) 	= apply(evalx($Exp1, $Store) == evalx($Exp2, $Store))
[EQ2]	apply($Val == $Val)		= true
[default-EQ3]
	apply($Val1 == $Val2)		= false

[NE1]	$Bool = apply(evalx($Exp1, $Store) == evalx($Exp2, $Store))
	===========================================================
	evalx($Exp1 != $Exp2, $Store) 	= not($Bool)

[LE1]	evalx($Exp1 <= $Exp2, $Store) 	= apply(evalx($Exp1, $Store) <= evalx($Exp2, $Store))
%%[LE2]	apply(*empty* <= $Bag2) 	= true
%%[LE3]	apply($Bag <= *empty*) 		= subset($Bag, EmptyBag)
[LE4]	apply($Bag1 <= $Bag2) 		= subset($Bag1, $Bag2)
%%[LE5]	apply(*empty* <= $Rel2) 	= true
%%[LE6]	apply($Rel <= *empty*) 		= subset($Rel, EmptyRel)
[LE7]	apply($Rel1 <= $Rel2) 		= subset($Rel1,  $Rel2)
[LE8]	apply($Integer1 <= $Integer2) 	= $Integer1 <= $Integer2

[LT1]	evalx($Exp1 < $Exp2, $Store) 	= apply(evalx($Exp1, $Store) < evalx($Exp2, $Store))
%%[LT2]	apply(*empty* < $Bag2) 		= strict-subset(EmptyBag, $Bag2)
%%[LT3]	apply($Bag1 < *empty*) 		= false
[LT4]	apply($Bag1 < $Bag2) 		= strict-subset($Bag1, $Bag2)
%%[LT5]	apply(*empty* < $Rel2) 		= strict-subset(EmptyRel,  $Rel2)
%%[LT6]	apply($Rel1 < *empty*) 		= false
[LT7]	apply($Rel1 < $Rel2) 		= strict-subset($Rel1,  $Rel2)
[LT8]	apply($Integer1 < $Integer2) 	= $Integer1 < $Integer2

[GE1]	$Bool = apply(evalx($Exp1, $Store) < evalx($Exp2, $Store))
	==========================================================
	evalx($Exp1 >= $Exp2, $Store) 	= not($Bool)

[GT1]	$Bool = apply(evalx($Exp1, $Store) <= evalx($Exp2, $Store))
	===========================================================
	evalx($Exp1 > $Exp2, $Store) 	= not($Bool)

[UN1]	evalx($Exp1 union $Exp2, $Store)= apply(evalx($Exp1, $Store) union evalx($Exp2, $Store))

%%[UN2]	apply(*empty* union *empty*)	= *empty*
%%[UN3]	apply(*empty* union $Bag) 	= $Bag 
%%[UN4]	apply($Bag union *empty*) 	= $Bag
[UN5]	apply($Bag1 union $Bag2)   	= union($Bag1, $Bag2)

%%[UN6]	apply($Elem union *empty*)   	= $Elem
%%[UN7]	apply(*empty* union $Elem)   	= $Elem
[UN8]	apply($Elem1 union $Elem2)     	= union({$Elem1}, {$Elem2})
[UN9]	apply($Elem union $Bag)       	= union({$Elem}, $Bag)
[UN10]	apply($Bag union $Elem)       	= union($Bag, {$Elem})

%%[UN11]	apply(*empty* union $Rel)   	= $Rel
%%[UN12]	apply($Rel union *empty*)   	= $Rel
[UN13]	apply($Rel1 union $Rel2)     	= union($Rel1, $Rel2)

%%[UN14]	apply(*empty* union $Tuple) 	= $Tuple
%%[UN15]	apply($Tuple union *empty*) 	= $Tuple
[UN16]	apply($Tuple1 union $Tuple2) 	= union({$Tuple1}, {$Tuple2})
[UN17]	apply($Tuple union $Rel)     	= union({$Tuple}, $Rel)
[UN18]	apply($Rel union $Tuple)     	= union($Rel, {$Tuple})

[IN1]	evalx($Exp1 inter $Exp2, $Store)= apply(evalx($Exp1, $Store) inter evalx($Exp2, $Store))

[IN2]	apply($Bag1 inter $Bag2) 	= inter($Bag1, $Bag2)
[IN3]	apply($Rel1 inter $Rel2) 	= inter($Rel1,  $Rel2)

[DF1]	evalx($Exp1 \ $Exp2, $Store)	= apply(evalx($Exp1, $Store) \ evalx($Exp2, $Store))
[DF2]	apply($Bag1 \ $Bag2) 		= diff($Bag1, $Bag2)
[DF3]	apply($Rel1 \ $Rel2) 		= diff($Rel1, $Rel2)

[CM1]	evalx($Exp1 o $Exp2, $Store)	= apply(evalx($Exp1, $Store) o evalx($Exp2, $Store))
[CM2]	apply($Rel1 o $Rel2) 		= compose($Rel1, $Rel2)

[CP1]	evalx($Exp1 x $Exp2, $Store)	= apply(evalx($Exp1, $Store) x evalx($Exp2, $Store))
[CP2]	apply($Bag1 x $Bag2) 		= product($Bag1, $Bag2)
[CP3]	apply($Elem x $Bag)     	= product({$Elem}, $Bag)
[CP4]	apply($Bag x $Elem)     	= product($Bag, {$Elem})
[CP5]	apply($Elem1 x $Elem2)  	= product({$Elem1}, {$Elem2})

[PJ1]	evalx($Exp1 . $Exp2, $Store)	= apply(evalx($Exp1, $Store) . evalx($Exp2, $Store))
[PJ2]	apply($Rel . $Elem)   		= $Rel . $Elem
[PJ3]	apply($Rel . $Bag) 		= $Rel . $Bag
[PJ4]	apply($Elem . $Rel)   		= $Elem . $Rel
%%[PJ4]	apply(<$Elem1, $Elem2> . $Rel)	= <$Elem1, $Elem2> . $Rel
[PJ5]	apply($Bag . $Rel) 		= $Bag . $Rel

[IM1]	evalx($Exp1 [ $Exp2 ], $Store)	= evalx($Exp2 . $Exp1, $Store)

%% --- Eval unary prefix operators

[NOT1]	evalx(not $Exp, $Store) 	= apply(not evalx($Exp, $Store))
[NOT1]	apply(not $Bool)		= not($Bool)

[SZ1]	evalx(# $Exp, $Store) 		= apply(# evalx($Exp, $Store))
[SZ1]	apply(# $Rel) 			= size($Rel)
[SZ2]	apply(# $Bag) 			= size($Bag)

%% --- Eval unary postfix operators

[TC1]	evalx($Exp +, $Store)		= apply(evalx($Exp, $Store) +)
%%[TC2]	apply(*empty* +)		= *empty*
[TC3]	apply($Rel +)			= $Rel +


[RTC1]	evalx($Exp *, $Store)		= apply(evalx($Exp, $Store) *)
%%[RTC2]	apply(*empty* *)		= *empty*
[TRC3]	apply($Rel *)			= $Rel *


%% ---- Eval bag and relation formers

%% --- Simplify multiple Froms

[RF1]	{$Exp : $From+}  =  {$From+ :: $Exp}

[RF1]	{$From, $From+ :: $Exp } = {$From :: {$From+ :: $Exp}}

[RF2]	{$Exp : $From+ | $Test} =  {$From+ :: $Test, $Exp}

[RF1]	{$From, $From+ :: $Test, $Exp } = {$From :: {$From+ :: $Test, $Exp}}

%% --- eval-iter: iterate over a bag

[ei-1]	$Bag = evalb($Exp1, $Store)
	=======================================
	evalx({$Var in $Exp1 :: $Exp2}, $Store) = eval-iter($Var, $Bag, EmptyBag, $Exp2, $Store)

[ei-2]	$Store' = assign($Var, $Elem, $Store),
	$Val' = evalx($Exp, $Store'),
	eval-iter($Var, {$Elem*}, append($Bag, $Val'), $Exp, $Store') = $Val''
	======================================================
	eval-iter($Var, {$Elem, $Elem*}, $Bag, $Exp, $Store) =  $Val''

[ei-3]	eval-iter($Var, {}, $Bag, $Exp2, $Store) = $Bag

%% --- eval-citer: iterate over bag, with condition

[eci-1]	$Bag = evalb($Exp1, $Store)
	=======================================
	evalx({$Var in $Exp1 :: $Test, $Exp2}, $Store) = 
	eval-citer($Var, $Bag, EmptyBag, $Test, $Exp2, $Store)

[eci-2]	$Store' = assign($Var, $Elem, $Store),
	$Bool =  evalp($Test, $Store'),
	$Bag' = if $Bool then append($Bag, evalx($Exp, $Store')) else $Bag fi,
	eval-citer($Var, {$Elem*}, $Bag', $Test, $Exp, $Store') = $Val''
	======================================================
	eval-citer($Var, {$Elem, $Elem*}, $Bag, $Test, $Exp, $Store) = $Val''

[eci3]	eval-citer($Var, {}, $Bag, $Test, $Exp, $Store) = $Bag

%% --- eval-iter2: iterate over relation

[ei2-1]	$Rel = evalr($Exp1, $Store)
	=======================================
	evalx({ <$Var1, $Var2> in $Exp1 :: $Exp2 }, $Store) = 
	eval-iter2($Var1, $Var2, $Rel, EmptyBag, $Exp2, $Store)

[ei2-2]	$Store' = assign($Var1, $Elem1, $Store),
	$Store'' = assign($Var2, $Elem2, $Store'),
	$Val' = evalx($Exp, $Store''),
	eval-iter2($Var1, $Var2, {$Tuple*}, append($Bag, $Val'), $Exp, $Store'') = $Val''
	======================================================
	eval-iter2($Var1, $Var2, {<$Elem1, $Elem2>, $Tuple*}, $Bag, $Exp, $Store) = $Val''

[ei2-3]	eval-iter2($Var1, $Var2, {}, $Bag, $Exp2, $Store) = $Bag

%% --- eval-citer2: iterate over relation, with condition

[eci2-1]	
	$Rel = evalr($Exp1, $Store)
	=======================================
	evalx({ <$Var1, $Var2> in $Exp1 :: $Test, $Exp2 }, $Store) = 
	eval-citer2($Var1, $Var2, $Rel, EmptyBag, $Test, $Exp2, $Store)

[eci2-2]
	$Store' = assign($Var1, $Elem1, $Store),
	$Store'' = assign($Var2, $Elem2, $Store'),
	$Bool = evalp($Test, $Store''),
	$Bag' = if $Bool then append($Bag,evalx($Exp, $Store'')) else $Bag fi, 
	eval-citer2($Var1, $Var2, {$Tuple*}, $Bag', $Test, $Exp, $Store'') = $Val''
	======================================================
	eval-citer2($Var1, $Var2, {<$Elem1, $Elem2>, $Tuple*}, $Bag, $Test, $Exp, $Store) = $Val''

[eci2-3]
	eval-citer2($Var1, $Var2, {}, $Bag, $Test, $Exp, $Store) = $Bag

%% ---- Auxiliary functions for bag and relation formers

[AP1]	$Rel = {}, $Elem != $Rel, $Elem != {$Tuple+}, 
        $Bag = {}, $Elem != $Bag, $Elem != {$Elem+}
	=========================================
	append({$Elem*}, $Elem) 	= {$Elem*, $Elem}

[AP2]	append({$Elem*1}, {$Elem*2}) 	= {$Elem*1, $Elem*2}
[AP3]	r2b({$Tuple*2}) = {$Elem*2}
	=========================================
	append({$Elem*1},{$Tuple*2})	= {$Elem*1, $Elem*2}
[default-AP]
	append({$Elem*}, $Val)		= {$Elem*}


%% ---

[r2b-1] r2b({}) = {}
[r2b-2]	r2b({$Tuple*}) = {$Elem*}
	================================================
	r2b({<$Elem1, $Elem2>, $Tuple*}) = {<$Elem1, $Elem2>, $Elem*}

%% --- Exists in bag

[EXB1]	$Bag = evalb($Exp, $Store)
	=========================================
	evalx(exists($Var in $Exp | $Test), $Store) = existsb($Var, $Bag, $Test, $Store)

[EXB2]	$Store' = assign($Var, $Elem, $Store)
	=========================================
	existsb($Var, {$Elem, $Elem*}, $Test, $Store) =
	if evalp($Test, $Store') then true else existsb($Var, {$Elem*}, $Test, $Store) fi

[EXB3]	existsb($Var, {}, $Test, $Store) = false

%% --- Exists in relation

[EXR1]	$Rel = evalr($Exp, $Store)
	=========================================
	evalx(exists(<$Var1, $Var2> in $Exp | $Test), $Store) = existsr($Var1, $Var2, $Rel, $Test, $Store)

[EXR1]	$Store' = assign($Var1, $Elem1, $Store),
	$Store'' = assign($Var2, $Elem2, $Store')
	=========================================
	existsr($Var1, $Var2, {<$Elem1, $Elem2>, $Tuple*}, $Test, $Store) =
	if evalp($Test, $Store'') then true else existsr($Var1, $Var2, {$Tuple*}, $Test, $Store) fi

[EXR2]	existsr($Var1, $Var2, {}, $Test, $Store) = false

%% --- Forall in bag

[ALB1]	$Bool = evalp(exists($Var in $Exp | not $Test), $Store)
	==========================================
	evalx(forall($Var in $Exp | $Test), $Store) = not($Bool)

%% --- Forall in relation

[ALB1]	$Bool = evalp(exists(<$Var1, $Var2> in $Exp | not $Test), $Store)
	==========================================
	evalx(forall(<$Var1, $Var2> in $Exp | $Test), $Store) = not($Bool)


%% ------------------------------

%% ---- FUN ( EXP ) -> EXP

[default-fun1]
	value($Var1, $Store) = <$Var2, $Exp2>,
	$Val = evalx($Exp1, $Store),
	$Store' = assign($Var2, $Val, $Store)
	====================================================
	evalx($Var1($Exp1), $Store) = evalx($Exp2, $Store')

[Fid]	$Bag  = evalb($Exp, $Store)
	====================================================
	evalx(id($Exp), $Store) = id($Bag)

[Fdom]	$Rel = evalr($Exp, $Store)
	====================================================
	evalx(domain($Exp), $Store) = domain($Rel)

[Fran]	$Rel = evalr($Exp, $Store)
	====================================================
	evalx(range($Exp), $Store) = range($Rel)

[Fcar]	$Rel = evalr($Exp, $Store)
	====================================================
	evalx(carrier($Exp), $Store) = carrier($Rel)
	
[Ftop]	$Rel = evalr($Exp, $Store)
	====================================================
	evalx(top($Exp), $Store) = top($Rel)

[Fbot]	$Rel = evalr($Exp, $Store)
	====================================================
	evalx(bottom($Exp), $Store) = bottom($Rel)

[Finv]	$Rel = evalr($Exp, $Store)
	===================================================
	evalx(inv($Exp), $Store) = inv($Rel)

[Fcmp]	$Rel = evalr($Exp, $Store)
	===================================================
	evalx(compl($Exp), $Store) = compl($Rel)

[Ffst]	evalx($Exp, $Store) = <$Elem1, $Elem2>
	===================================================
	evalx(fst($Exp), $Store) = $Elem1

[Fsec]	evalx($Exp, $Store) = <$Elem1, $Elem2>
	===================================================
	evalx(sec($Exp), $Store) = $Elem2

%% ---- FUN ( EXP , EXP )  -> EXP

[default-fun2]
	value($Var, $Store) = <$Var1, $Var2, $Exp3>,
	$Val1 = evalx($Exp1, $Store),
	$Val2 = evalx($Exp2, $Store),

	$Store' = assign($Var1, $Val1, $Store),
	$Store'' = assign($Var2, $Val2, $Store')
	==================================================
	evalx($Var($Exp1, $Exp2), $Store) = evalx($Exp3, $Store'')

%%      fun domR(REL, $Bag) = { <$x, $y> in REL | $x in $Bag | {<$x, $y}>}

[RdomR]	$Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
	===================================================
	evalx(domR($Exp1, $Exp2), $Store) = domR($Rel, $Bag)

[FranR]	$Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
	===================================================
	evalx(ranR($Exp1, $Exp2), $Store) = ranR($Rel, $Bag)

[FcarR]	$Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
	====================================================
	evalx(carR($Exp1, $Exp2), $Store) = carR($Rel, $Bag)

[FdomX]	$Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
	====================================================
	evalx(domX($Exp1, $Exp2), $Store) = domX($Rel, $Bag)

[FranX]	$Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
	====================================================
	evalx(ranX($Exp1, $Exp2), $Store) = ranX($Rel, $Bag)

[FcarX]	$Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
	====================================================
	evalx(carX($Exp1, $Exp2), $Store) = carX($Rel, $Bag)

%% ---- FUN ( EXP , EXP , EXP)  -> EXP

[default-fun3]
	value($Var, $Store) = <$Var1, $Var2, $Var3, $Exp4>,
	$Val1 = evalx($Exp1, $Store),
	$Val2 = evalx($Exp2, $Store),
	$Val3 = evalx($Exp3, $Store),

	$Store' = assign($Var1, $Val1, $Store),
	$Store'' = assign($Var2, $Val2, $Store'),
	$Store''' = assign($Var3, $Val3, $Store')
	==================================================
	evalx($Var($Exp1, $Exp2, $Exp3), $Store) = evalx($Exp4, $Store''')

[FrX]	$Bag1 = evalb($Exp1, $Store),
	$Bag2 = evalb($Exp2, $Store),
	$Rel  = evalr($Exp3, $Store)
	================================================= 
	evalx(reachX($Exp1, $Exp2, $Exp3), $Store) =
	reachX($Bag1, $Bag2, $Rel)	

[FrR]	$Bag1 = evalb($Exp1, $Store),
        $Bag2 = evalb($Exp2, $Store),
        $Rel  = evalr($Exp3, $Store)
        ================================================= 
        evalx(reachR($Exp1, $Exp2, $Exp3), $Store) =
        reachR($Bag1, $Bag2, $Rel)	





