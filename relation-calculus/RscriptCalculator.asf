 equations

%%---- Store

%% Get value of a variable

[VL1]   value($Var, [<$Var, $Val>, $VPair*]) = $Val
[VL2]   $Var != $Var' ===> value($Var, [<$Var', $Val>, $VPair*]) = value($Var, [$VPair*])

%% Assign value to variable

[ASG1]  assign($Var, $Val, [$VPair*]) = [<$Var, $Val>, $VPair*]

%% Add tuple to a relation

[AT1]  add-tuple($Var, <$Elem1, $Elem2>, [<$Var, $Val>, $VPair*]) = 
       [<$Var, apply({<$Elem1, $Elem2>} union $Val)>, $VPair*]

[AT2]  $Var != $Var', 
       [$VPair*'] = add-tuple($Var, <$Elem1, $Elem2>, [$VPair*])
       ===============================================================
       add-tuple($Var, <$Elem1, $Elem2>, [<$Var', $Val>, $VPair*]) = [<$Var', $Val>, $VPair*']

[AT3]  add-tuple($Var, <$Elem1, $Elem2>, []) = [< $Var, {<$Elem1, $Elem2>} >]

%% Extend a relation

[ER1]  extend-rel($Var, $Rel, [<$Var, $Val>, $VPair*]) = [<$Var, apply($Rel union $Val)>, $VPair*]

[ER2]  $Var != $Var', 
       [$VPair*'] = extend-rel($Var, $Rel, [$VPair*])
       ===============================================================
       extend-rel($Var, $Rel, [<$Var', $Val>, $VPair*]) = [<$Var', $Val>, $VPair*']

[ER3]  extend-rel($Var, $Rel, []) = [< $Var, $Rel >]

%%---- if on VALUEs

[if1]  if true then $Val1 else $Val2 fi  = $Val1
[if2]  if false then $Val1 else $Val2 fi = $Val2

%%---- Equality on elements

[e1]   equal($Elem, $Elem)  = true
[default-e2] 
       equal($Elem, $Elem') = false

[v2b]  rval2bag($Bag) = $Bag
[v2r]  rval2rel($Rel) = $Rel

%%---- Specialized versions of evalx that return value of required type

[EVP] $Bool = evalx($Exp, $Store)               ===> evalp($Exp, $Store) = $Bool

[EVE1] $Elem = evalx($Exp, $Store)                 ===> evale($Exp, $Store) = $Elem

%%[EVE2] $Bag = evalx($Exp, $Store)                 ===> evale($Exp, $Store) = $Bag

%%[EVE3] $Rel = evalx($Exp, $Store)                 ===> evale($Exp, $Store) = $Rel

%%[EVE4] <$Elem1, $Elem2> = evalx($Exp, $Store)     ===> evale($Exp, $Store) = <$Elem1, $Elem2>


[EVB1] $Bag = evalx($Exp, $Store)     ===> evalb($Exp, $Store) = $Bag

[EVB2] *empty* = evalx($Exp, $Store)  ===> evalb($Exp, $Store) = {}

[EVR1] $Rel = evalx($Exp, $Store)     ===> evalr($Exp, $Store) = $Rel

[EVR1] *empty* = evalx($Exp, $Store)  ===> evalr($Exp, $Store) = {}

%% ---- Eval complete script

[ES0] eval-rscript($Stat*, $Var, $Store) = value($Var, eval-rscript($Stat*, $Store))

[ES1]  eval-rscript($Stat*) = eval-rscript($Stat*, [])

[ES2]  eval-rscript($Stat $Stat*, $Store) = eval-rscript($Stat*, eval-rscript($Stat, $Store))
[ES3]  eval-rscript( , $Store) = $Store

%% ---- Eval statements

[S1]  eval-rscript($Etype $Var, $Store) = $Store

[S2]  eval-rscript($Etype $Var = $Exp, $Store) = assign($Var, evalx($Exp, $Store), $Store)

[S3]  eval-rscript($Etype1 $Var1($Etype2 $Var2) = $Exp, $Store) = assign($Var1, <$Var2, $Exp>, $Store)

[S4]  eval-rscript($Etype1 $Var1($Etype2 $Var2, $Etype3 $Var3) = $Exp, $Store) = assign($Var1, <$Var2, $Var3, $Exp>, $Store)

[S5]  eval-rscript($Etype1 $Var1($Etype2 $Var2, $Etype3 $Var3, $Etype4 $Var4) = $Exp, $Store) = assign($Var1, <$Var2, $Var3, $Var4, $Exp>, $Store)

%% ---- Eval one REXP

[ER1] eval-rexp($Exp, $Store) = evalx($Exp, $Store)


%% ---- The main evaluation function evalx

%% ---- Eval elementary predicates

[Pt]   evalx(true, $Store) = true

[Pf]   evalx(false, $Store) = false

[Pa]   evalx($Exp1 and $Exp2, $Store) =  evalp($Exp1, $Store) & evalp($Exp2, $Store)

[Pb]   evalx($Exp1 or $Exp2, $Store) = evalp($Exp1, $Store) | evalp($Exp2, $Store)

[Pn]   evalx(not $Exp, $Store) =  not(evalp($Exp, $Store))

%% ---- Eval other predicates

[EL1] evalx($Exp1 elem $Exp2, $Store) = apply(evalx($Exp1, $Store) elem evalx($Exp2, $Store))

[EL2]  apply($Elem elem $Bag) = elem($Elem, $Bag)
[EL3]  apply(<$Elem1, $Elem2> elem $Rel) = elem(<$Elem1, $Elem2>, $Rel)

[EQ1]  evalx($Exp1 == $Exp2, $Store) = apply(evalx($Exp1, $Store) == evalx($Exp2, $Store))

[EQ2]  apply($Bag1 == $Bag2) = equal($Bag1, $Bag2)
[EQ3]  apply($Rel1 == $Rel2) = equal($Rel1, $Rel2)
[EQ4]  apply($Elem1 == $Elem2)   = equal($Elem1, $Elem2)
[EQ5]  apply($Integer1 == $Integer2) = equal($Integer1, $Integer2)

[LE1]  evalx($Exp1 <= $Exp2, $Store) = apply(evalx($Exp1, $Store) <= evalx($Exp2, $Store))

[LE2]  apply($Bag1 <= $Bag2) = subset($Bag1, $Bag2)
[LE3]  apply($Rel1 <= $Rel2) = subset($Rel1,  $Rel2)
[LE4]  apply($Integer1 <= $Integer2) = $Integer1 <= $Integer2

[LT1]  evalx($Exp1 < $Exp2, $Store) = apply(evalx($Exp1, $Store) < evalx($Exp2, $Store))

[LT2]  apply($Bag1 < $Bag2) = strict-subset($Bag1, $Bag2)
[LT3]  apply($Rel1 < $Rel2) = strict-subset($Rel1,  $Rel2)
[LT4]  apply($Integer1 < $Integer2) = $Integer1 < $Integer2

[GE1]  evalx($Exp1 >= $Exp2, $Store) = apply(evalx($Exp1, $Store) >= evalx($Exp2, $Store))

[GE2]  apply($Bag1 >= $Bag2) = superset($Bag1,  $Bag2)
[GE3]  apply($Rel1 >= $Rel2) = superset($Rel1, $Rel2)
[GE4]  apply($Integer1 >= $Integer2) = $Integer1 >= $Integer2

[GT1]  evalx($Exp1 > $Exp2, $Store) = apply(evalx($Exp1, $Store) > evalx($Exp2, $Store))

[GT2]  apply($Bag1 > $Bag2) = strict-superset($Bag1, $Bag2)
[GT3]  apply($Rel1 > $Rel2) = strict-superset($Rel1, $Rel2)
[GT4]  apply($Integer1 > $Integer2) = $Integer1 > $Integer2

%% ---- Eval Elements

%%[EE1] evalx($Bool, $Store) = $Bool

%%[EE1]  evalx($Integer, $Store) = $Integer

[EE1]  evalx($Elem, $Store) = $Elem

[EE2]  evalx($Var, $Store)  = value($Var, $Store)

%% ---- Eval tuples

[ET1]  $Elem1 = evale($Exp1, $Store),
       $Elem2 = evale($Exp2, $Store)
       ==================================================
       evalx(<$Exp1, $Exp2>, $Store) = <$Elem1, $Elem2>

%% ---- Eval bags

[EB2]  $Elem = evale($Exp, $Store), {$Elem+} = evalb({$Exp+}, $Store)
       ===================================================
       evalx({$Exp, $Exp+}, $Store) = {$Elem, $Elem+}

[EB3]  $Elem = evale($Exp, $Store)
       ===================================================
       evalx({$Exp}, $Store) = {$Elem}

%% ---- Eval relations

[ER2] $Elem1 = evale($Exp1, $Store), $Elem2 = evale($Exp2, $Store),
      evalr({$Exp+}, $Store) = {$Tuple+}
      ====================================================
      evalx({<$Exp1, $Exp2>, $Exp+}, $Store) = {<$Elem1, $Elem2>, $Tuple+}

[ER3] $Elem1 = evale($Exp1, $Store), $Elem2 = evale($Exp2, $Store)
      ====================================================
      evalx({<$Exp1, $Exp2>}, $Store) = {<$Elem1, $Elem2>}

%% ---- Eval operators

[UN1]  $Val1 = evalx($Exp1, $Store), $Val2 = evalx($Exp2, $Store)
       ====================================================
       evalx($Exp1 union $Exp2, $Store) = apply($Val1 union $Val2)

[UN2]  apply($Bag1 union $Bag2)   = union($Bag1, $Bag2)
[UN3]  apply(*empty* union $Bag) = $Bag 
[UN4]  apply($Bag union *empty*) = $Bag
[UN5]  apply($Elem union *empty*)   = $Elem
[UN6]  apply(*empty* union $Elem)   = $Elem
[UN7]  apply($Elem1 union $Elem2)       = union({$Elem1}, {$Elem2})
[UN8]  apply($Elem union $Bag)       = union({$Elem}, $Bag)
[UN9]  apply($Bag union $Elem)       = union($Bag, {$Elem})

[UN10] apply($Rel1 union $Rel2)     = union($Rel1, $Rel2)
[UN11] apply(*empty* union $Rel)   = $Rel
[UN12] apply($Rel union *empty*)   = $Rel
[UN13] apply($Tuple union *empty*) = $Tuple
[UN14] apply(*empty* union $Tuple) = $Tuple
[UN15] apply($Tuple1 union $Tuple2) = union({$Tuple1}, {$Tuple2})
[UN16] apply($Tuple union $Rel)     = union({$Tuple}, $Rel)
[UN17] apply($Rel union $Tuple)     = union($Rel, {$Tuple})

[IN1]  $Val1 = evalx($Exp1, $Store), $Val2 = evalx($Exp2, $Store)
       ====================================================
       evalx($Exp1 inter $Exp2, $Store) = apply($Val1 inter $Val2)

[IN2]  apply($Bag1 inter $Bag2) = inter($Bag1, $Bag2)
[IN3]  apply($Rel1 inter $Rel2) = inter($Rel1,  $Rel2)

[DF1]  $Val1 = evalx($Exp1, $Store), $Val2 = evalx($Exp2, $Store)
       ====================================================
       evalx($Exp1 \  $Exp2, $Store) = apply($Val1 \ $Val2)

[DF2]  apply($Bag1 \ $Bag2) = diff($Bag1, $Bag2)
[DF3]  apply($Rel1 \ $Rel2) = diff($Rel1, $Rel2)

[CM1]  $Val1 = evalx($Exp1, $Store), $Val2 = evalx($Exp2, $Store)
       ====================================================
       evalx($Exp1 o  $Exp2, $Store) = apply($Val1 o $Val2)

[CM2]  apply($Rel1 o $Rel2) = compose($Rel1, $Rel2)

[CP1]  $Val1 = evalx($Exp1, $Store), $Val2 = evalx($Exp2, $Store)
       ====================================================
       evalx($Exp1 x  $Exp2, $Store) = apply($Val1 x $Val2)

[CP2]  apply($Bag1 x $Bag2) = product($Bag1, $Bag2)
[CP3]  apply($Elem x $Bag)     = product({$Elem}, $Bag)
[CP4]  apply($Bag x $Elem)     = product($Bag, {$Elem})
[CP5]  apply($Elem1 x $Elem2)     = product({$Elem1}, {$Elem2})

[PJ1]  $Val1 = evalx($Exp1, $Store), $Val2 = evalx($Exp2, $Store)
       ====================================================
       evalx($Exp1 .  $Exp2, $Store) = apply($Val1 . $Val2)

[PJ2]  apply($Rel . $Elem)   = $Rel . $Elem
[PJ3]  apply($Rel . $Bag) = $Rel . $Bag
[PJ4]  apply($Elem . $Rel)   = $Elem . $Rel
%%[PJ4]  apply(<$Elem1, $Elem2> . $Rel)   = <$Elem1, $Elem2> . $Rel
[PJ5]  apply($Bag . $Rel) = $Bag . $Rel

[TC1] $Rel = evalr($Exp, $Store)
      ===================================================
      evalx($Exp +, $Store) = $Rel +

[TC2] $Rel = evalr($Exp, $Store)
       ===================================================
       evalx($Exp *, $Store) = $Rel *

[SZ1]   $Val = evalx($Exp, $Store)
      =====================================================
       evalx(# $Exp, $Store) = apply( # $Val)


[SZ1] apply( # $Rel) = size($Rel)
[SZ2] apply( # $Bag) = size($Bag)

%% ---- Eval bag and relation formers

%% --- Simplify multiple Froms

[RF1]	{$Exp | $From, $From+} =  {{$Exp | $From} | $From+}
[RF2]	{$Exp1 | $From, $From+, $Exp2} =  {{$Exp1 | $From} | $From+, $Exp2}

%% --- eval-iter: iterate over a bag

[ei-1] 	$Bag = evalb($Exp1, $Store)
     	=======================================
     	evalx({$Exp2 | $Var in $Exp1}, $Store) = eval-iter($Var, $Bag, *empty*, $Exp2, $Store)

[ei-2]	$Store' = assign($Var, $Elem, $Store),
      	$Val' = evalx($Exp, $Store'),
      	eval-iter($Var, {$Elem*}, append($Val, $Val'), $Exp, $Store') = $Val''
      	======================================================
      	eval-iter($Var, {$Elem, $Elem*}, $Val, $Exp, $Store) =  $Val''

[ei-3]	eval-iter($Var, {}, $Val, $Exp2, $Store) = $Val

%% --- eval-citer: iterate over bag, with condition

[eci-1]	$Bag = evalb($Exp1, $Store)
     	=======================================
     	evalx({$Exp3  | $Var in $Exp1, $Exp2}, $Store) = 
     	eval-citer($Var, $Bag, *empty*, $Exp2, $Exp3, $Store)

[eci-2]	$Store' = assign($Var, $Elem, $Store),
      	$Val' = if evalp($Exp2, $Store') then append($Val, evalx($Exp3, $Store')) else $Val fi,
      	eval-citer($Var, {$Elem*}, $Val', $Exp2, $Exp3, $Store') = $Val''
      	======================================================
      	eval-citer($Var, {$Elem, $Elem*}, $Val, $Exp2, $Exp3, $Store) = $Val''

[eci3]	eval-citer($Var, {}, $Val, $Exp2, $Exp3, $Store) = $Val

%% --- eval-iter2: iterate over relation

[ei2-1]	$Rel = evalr($Exp1, $Store)
     	=======================================
     	evalx({ $Exp2 | <$Var1, $Var2> in $Exp1 }, $Store) = 
     	eval-iter2($Var1, $Var2, $Rel, *empty*, $Exp2, $Store)

[ei2-2]	$Store' = assign($Var1, $Elem1, $Store),
      	$Store'' = assign($Var2, $Elem2, $Store'),
      	$Val' = evalx($Exp, $Store''),
      	eval-iter2($Var1, $Var2, {$Tuple*}, append($Val, $Val'), $Exp, $Store'') = $Val''
      	======================================================
      	eval-iter2($Var1, $Var2, {<$Elem1, $Elem2>, $Tuple*}, $Val, $Exp, $Store) = $Val''

[ei2-3]	eval-iter2($Var1, $Var2, {}, $Val, $Exp2, $Store) = $Val

%% --- eval-citer2: iterate over relation, with condition

[eci2-1]	
	$Rel = evalr($Exp1, $Store)
     	=======================================
     	evalx({ $Exp3 | <$Var1, $Var2> in $Exp1, $Exp2}, $Store) = 
     	eval-citer2($Var1, $Var2, $Rel, *empty*, $Exp2, $Exp3, $Store)

[eci2-2]
      	$Store' = assign($Var1, $Elem1, $Store),
      	$Store'' = assign($Var2, $Elem2, $Store'),
      	$Val' = if evalp($Exp2, $Store'') then append($Val,evalx($Exp3, $Store'')) else $Val fi, 
      	eval-citer2($Var1, $Var2, {$Tuple*}, $Val', $Exp2, $Exp3, $Store'') = $Val''
      	======================================================
      	eval-citer2($Var1, $Var2, {<$Elem1, $Elem2>, $Tuple*}, $Val, $Exp2, $Exp3, $Store) = $Val''

[eci2-3]
	eval-citer2($Var1, $Var2, {}, $Val, $Exp2, $Exp3, $Store) = $Val

%% ---- Auxiliary functions for bag and relation formers

[AP1]  	append($Elem1, $Elem2) 		= {$Elem1, $Elem2}
[AP2]  	append(*empty*, $Elem) 		= $Elem
[AP3]  	append($Elem, *empty*) 		= $Elem

[AP4]  	append({$Elem*}, $Elem) 	= {$Elem*, $Elem}
[AP5]  	append($Elem, {$Elem*}) 	= {$Elem*, $Elem}
[AP6]  	append({$Elem*1}, {$Elem*2}) 	= {$Elem*1, $Elem*2}

[AP7]  	append($Tuple1, $Tuple2) 	= {$Tuple1, $Tuple2}
[AP8]  	append(*empty*, $Tuple) 	= {$Tuple}
[AP9]  	append($Tuple, *empty*) 	= {$Tuple}
[AP10] 	append({$Tuple*}, $Tuple) 	= {$Tuple*, $Tuple}
[AP11]  append($Tuple, {$Tuple*}) 	= {$Tuple*, $Tuple}
[AP12]  append({$Tuple*1}, {$Tuple*2}) 	= {$Tuple*1, $Tuple*2}

%% ------------------------------

%% ---- FUN ( EXP ) -> EXP

[default-fun1]
        value($Var1, $Store) = <$Var2, $Exp2>,
        $Val = evalx($Exp1, $Store),
        $Store' = assign($Var2, $Val, $Store)
        ====================================================
	evalx($Var1($Exp1), $Store) = evalx($Exp2, $Store')

[Fid]   $Bag  = evalb($Exp, $Store)
        ====================================================
        evalx(id($Exp), $Store) = id($Bag)

[Fdom]  $Rel = evalr($Exp, $Store)
        ====================================================
        evalx(domain($Exp), $Store) = domain($Rel)

[Fran]  $Rel = evalr($Exp, $Store)
        ====================================================
        evalx(range($Exp), $Store) = range($Rel)

[Fcar]  $Rel = evalr($Exp, $Store)
        ====================================================
        evalx(carrier($Exp), $Store) = carrier($Rel)
   
[Ftop]  $Rel = evalr($Exp, $Store)
        ====================================================
        evalx(top($Exp), $Store) = top($Rel)

[Fbot]  $Rel = evalr($Exp, $Store)
        ====================================================
        evalx(bottom($Exp), $Store) = bottom($Rel)

[Finv]  $Rel = evalr($Exp, $Store)
        ===================================================
        evalx(inv($Exp), $Store) = inv($Rel)

[Fcmp]  $Rel = evalr($Exp, $Store)
        ===================================================
        evalx(compl($Exp), $Store) = compl($Rel)

[Ffst]  evalx($Exp, $Store) = <$Elem1, $Elem2>
        ===================================================
        evalx(fst($Exp), $Store) = $Elem1

[Fsec]  evalx($Exp, $Store) = <$Elem1, $Elem2>
        ===================================================
        evalx(sec($Exp), $Store) = $Elem2

%% ---- FUN ( EXP , EXP )  -> EXP

[default-fun2]
        value($Var, $Store) = <$Var1, $Var2, $Exp3>,
        $Val1 = evalx($Exp1, $Store),
        $Val2 = evalx($Exp2, $Store),

        $Store' = assign($Var1, $Val1, $Store),
	$Store'' = assign($Var2, $Val2, $Store')
        ==================================================
	evalx($Var($Exp1, $Exp2), $Store) = evalx($Exp3, $Store'')

%%      fun domR(REL, $Bag) = { <$x, $y> in REL | $x in $Bag | {<$x, $y}>}

[RdomR] $Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
        ===================================================
        evalx(domR($Exp1, $Exp2), $Store) = domR($Rel, $Bag)

[FranR] $Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
        ===================================================
        evalx(ranR($Exp1, $Exp2), $Store) = ranR($Rel, $Bag)

[FcarR] $Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
        ====================================================
        evalx(carR($Exp1, $Exp2), $Store) = carR($Rel, $Bag)

[FdomX] $Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
        ====================================================
        evalx(domX($Exp1, $Exp2), $Store) = domX($Rel, $Bag)

[FranX] $Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
        ====================================================
        evalx(ranX($Exp1, $Exp2), $Store) = ranX($Rel, $Bag)

[FcarX] $Rel = evalr($Exp1, $Store), $Bag = evalb($Exp2, $Store)
        ====================================================
        evalx(carX($Exp1, $Exp2), $Store) = carX($Rel, $Bag)

%%[Fcls1] $Bag = evalb($Exp1, $Store),  $Rel = evalr($Exp2, $Store)
%%       ==================================================== 
%%        evalx(closure($Exp1, $Exp2), $Store) =  closure($Bag, $Rel)

%% ---- FUN ( EXP , EXP , EXP)  -> EXP

[default-fun3]
        value($Var, $Store) = <$Var1, $Var2, $Var3, $Exp4>,
        $Val1 = evalx($Exp1, $Store),
        $Val2 = evalx($Exp2, $Store),
        $Val3 = evalx($Exp3, $Store),

        $Store' = assign($Var1, $Val1, $Store),
	$Store'' = assign($Var2, $Val2, $Store'),
	$Store''' = assign($Var3, $Val3, $Store')
        ==================================================
	evalx($Var($Exp1, $Exp2, $Exp3), $Store) = evalx($Exp4, $Store''')

%%[Fdms]  $Rel1 = evalr($Exp1, $Store),
%%        $Rel2 = evalr($Exp2, $Store),
%%        $Rel3 = evalr($Exp3, $Store)
%%        ================================================= 
%%        evalx(dominators($Exp1, $Exp2, $Exp3), $Store) =
%%        dominators($Rel1, $Rel2, $Rel3)


[FrX]   $Bag1 = evalb($Exp1, $Store),
        $Bag2 = evalb($Exp2, $Store),
        $Rel  = evalr($Exp3, $Store)
        ================================================= 
        evalx(reachX($Exp1, $Exp2, $Exp3), $Store) =
        reachX($Bag1, $Bag2, $Rel)	

[FrR]   $Bag1 = evalb($Exp1, $Store),
        $Bag2 = evalb($Exp2, $Store),
        $Rel  = evalr($Exp3, $Store)
        ================================================= 
        evalx(reachR($Exp1, $Exp2, $Exp3), $Store) =
        reachR($Bag1, $Bag2, $Rel)	





