 equations

%% --- Simplify n-ary tuples

[st1]	$Exps = $Exp'
	=============================================================
	<$Exp1, $Exp2, $Exps> = <$Exp1, <$Exp2, $Exp'>>

[st2]	$Exps1 = $Exp', $Exps2
	=============================================================
	<$Exp1, $Exp2, $Exps1> = <$Exp1, <$Exp2, $Exp', $Exps2>>

%% ---- Equality on RVALUEs

[er1]	equal-rval($Bag1, $Bag2) = equal($Bag1, $Bag2)
[er2]	equal-rval($Rel1, $Rel2) = equal($Rel1, $Rel2)
[er3]	equal-rval($Val, $Val)  = true
[default-er] 
	equal-rval($Val1, $Val2) = false

%% ---- Extract a list of variables from a declaration list

[erv1]	extract-rvars($DclRvar+) = $Var+
	===================================================
	extract-rvars($Etype $Var, $DclRvar+) = $Var, $Var+

[erv2]	extract-rvars($Etype $Var) = $Var

%% ---- Eval a complete Rscript

[ERS1]	$Rstore = eval-rstats($Stat*, rstore(<YIELD, empty-bag>)),	%%XXX
	$Bag = value(YIELD, $Rstore)
	===============================================================
	eval-rscript($Stat*) = filter($Rstore, $Bag)

%% ---- Eval a complete Rscript with given Rstore

[ERS2]	$Rstore' = assign(YIELD, empty-bag, $Rstore),			%%XXX
	$Rstore'' = eval-rstats($Stat*, $Rstore'),
	$Bag = value(YIELD, $Rstore'')
	===============================================================
	eval-rscript-with-rstore($Stat*, $Rstore) = filter($Rstore'', $Bag)

%% ---- Eval complete script and yield value of a variable

[ERS3]	$Elem =  value($Var, eval-rstats($Stat*, $Rstore))
	===================================================
	eval-rscript($Stat*, $Var, $Rstore) = $Elem

%% ---- Eval statements

[ES2]	eval-rstats($Stat $Stat*, $Rstore) = eval-rstats($Stat*, eval-rstat($Stat, $Rstore))
[ES3]	eval-rstats( , $Rstore) = $Rstore

%% ---- Eval one statement

[S1]	eval-rstat(bool $Var, $Rstore) 		= assign-when-undef($Var, true, $Rstore)
[S2]	eval-rstat(int $Var, $Rstore)  		= assign-when-undef($Var, 0, $Rstore)
[S3]	eval-rstat(str $Var, $Rstore)  		= assign-when-undef($Var, "", $Rstore)
[S4]	eval-rstat(area $Var, $Rstore)		= assign-when-undef($Var, area("",0,0,0,0), $Rstore)
[S5]	eval-rstat(bag[$Etype] $Var, $Rstore)  	= assign-when-undef($Var, empty-bag, $Rstore)	%%XXX
	
[S6]	eval-rstat(rel[$Etype1, $Etype2] $Var, $Rstore) 
						= assign-when-undef($Var, empty-bag, $Rstore)	%%XXX
[S7]	eval-rstat($Etype $Var, $Rstore)	= $Rstore

[S8]	eval-rstat($Etype $Var = $Exp, $Rstore)    = assign($Var, evalx($Exp, $Rstore), $Rstore)
[S8]	eval-rstat($Etype $Var init $Exp, $Rstore) = assign($Var, evalx($Exp, $Rstore), $Rstore)

[S9]	eval-rstat($Etype1 $Var1($DclRvar+) = $Exp, $Rstore) 
						= assign($Var1, <extract-rvars($DclRvar+), $Exp>, $Rstore)
[default-assert]	
	eval-rstat(assert $String : $Exp, $Rstore) = $Rstore

[S10]	$Elem =  value($Var, $Rstore)
	=======================================================
	eval-rstat(yield $Var, $Rstore) = add-elem(YIELD, rvar2str($Var), $Rstore)

%% ---- Variable initialization in solve statement

[eiv]	$Rstore' =  assign($Var, evalx($Exp, $Rstore), $Rstore)
	========================================================
	eval-initvar($Etype $Var init $Exp $InitVar*, $Rstore) =
	eval-initvar($InitVar*, $Rstore')

[eiv2]	eval-initvar( , $Rstore) = $Rstore
	
%% --- Solve Sets of equations

[SL1]	eval-initvar( $InitVar+, $Rstore) = $Rstore'
	=======================================================
	eval-rstat(equations initial $InitVar+ satisfy $Var1 = $Exp1 end equations, $Rstore) = 
	solve1(1000, $Var1, $Exp1, $Rstore')

[SL2]	eval-initvar( $InitVar+, $Rstore) = $Rstore'
	=======================================================	
	eval-rstat(equations (limit $Integer) initial $InitVar+ satisfy $Var1 = $Exp1 end equations, $Rstore) = 
	solve1($Integer, $Var1, $Exp1, $Rstore')

[SL3]	eval-initvar( $InitVar+, $Rstore) = $Rstore'
	=======================================================	
	eval-rstat(equations initial  $InitVar+ satisfy $Var1 = $Exp1 $Var2 = $Exp2 end equations, $Rstore) = 
	solve2(1000, $Var1, $Exp1, $Var2, $Exp2, $Rstore')

[SL4]	eval-initvar( $InitVar+, $Rstore) = $Rstore'
	=======================================================	
	eval-rstat(equations (limit $Integer) initial $InitVar+ satisfy $Var1 = $Exp1 $Var2 = $Exp2 end equations, $Rstore) = 
	solve2($Integer, $Var1, $Exp1, $Var2, $Exp2, $Rstore')

[SL1-1]	$Integer > 0 = true,
	$Val1 = value($Var1, $Rstore),
	$Val1' = evalx($Exp1, $Rstore),
	$Rstore' = assign($Var1, $Val1', $Rstore),
	equal-rval($Val1, $Val1') = false
	===========================================
	solve1($Integer, $Var1, $Exp1, $Rstore) =
	solve1($Integer - 1, $Var1, $Exp1, $Rstore')

[default-SL1-2]	
	solve1($Integer, $Var1, $Exp1, $Rstore) = $Rstore

[SL2-1]	$Integer > 0 = true,
	$Val1 = value($Var1, $Rstore),
	$Val1' = evalx($Exp1, $Rstore),
	$Val2 = value($Var2, $Rstore),
	$Val2' = evalx($Exp2, $Rstore),
	$Rstore' = assign($Var1, $Val1', $Rstore),
	$Rstore'' = assign($Var2, $Val2', $Rstore'),
	equal-rval($Val1, $Val1') & equal-rval($Val2, $Val2') = false
	===========================================
	solve2($Integer, $Var1, $Exp1, $Var2, $Exp2, $Rstore) =
	solve2($Integer - 1, $Var1, $Exp1, $Var2, $Exp2, $Rstore'')

[default-SL2-2]	
	solve2($Integer, $Var1, $Exp1, $Var2, $Exp2, $Rstore) = $Rstore

%% ---- Eval one REXP

%% ---- Specialized versions of evalx that return value of required type

[EVP]	$BoolCon = evalx($Exp, $Rstore) ===> evalp($Exp, $Rstore) = $BoolCon
[EVI]	$Integer = evalx($Exp, $Rstore)	===> evali($Exp, $Rstore) = $Integer
[EVE1]	$Elem = evalx($Exp, $Rstore)   	===> evale($Exp, $Rstore) = $Elem
[EVE2]	$Tuple = evalx($Exp, $Rstore)	===> evalt($Exp, $Rstore) = $Tuple
[EVB1]	$Bag = evalx($Exp, $Rstore)     ===> evalb($Exp, $Rstore) = $Bag
[EVR1]	$Rel = evalx($Exp, $Rstore)     ===> evalr($Exp, $Rstore) = $Rel
[EVA1]	$Area = evalx($Exp, $Rstore)    ===> evala($Exp, $Rstore) = $Area

%% ---- The main evaluation function evalx

%% ---- Eval elements, tuples and variables

[ELM]	evalx($Elem, $Rstore) = $Elem

[VAR1]	$Elem = value($Var, $Rstore)
	=================================================
	 evalx($Var, $Rstore)  = $Elem

%% ---- Eval tuples

[ET1]	$Elem1 = evale($Exp1, $Rstore),
	$Elem2 = evale($Exp2, $Rstore)
	==================================================
	evalx(<$Exp1, $Exp2>, $Rstore) = <$Elem1, $Elem2>

%% ---- Eval bags

[EB2]   $Elem = evale($Exp, $Rstore),
	$Bag = evalb({$Exp+}, $Rstore)				%%XXX
	===================================================
	evalx({$Exp, $Exp+}, $Rstore) = union1($Elem, $Bag)

[EB2]   $Elem = evale($Exp, $Rstore)					%%XXX
	===================================================
	evalx({$Exp}, $Rstore) = insert($Elem, empty-bag)

[EB3]	evalx({}, $Rstore) = empty-bag

%% ---- Eval binary operators

[AND1]	$BoolCon = evalp($Exp1, $Rstore) & evalp($Exp2, $Rstore)
	====================================================
	evalx($Exp1 and $Exp2, $Rstore) = $BoolCon

[OR1]	$BoolCon = evalp($Exp1, $Rstore) | evalp($Exp2, $Rstore)
	====================================================
	evalx($Exp1 or $Exp2, $Rstore) 	= $BoolCon

[IMP1]	$BoolCon = not(evalp($Exp1, $Rstore) & not(evalp($Exp2, $Rstore)))
	====================================================
	evalx($Exp1 implies $Exp2, $Rstore) = $BoolCon

[NOT1]	$BoolCon = not(evalp($Exp, $Rstore))
	====================================================
	evalx(not $Exp, $Rstore) = $BoolCon

[IN1]	$BoolCon = in(evalx($Exp1, $Rstore), evalb($Exp2, $Rstore))
	====================================================
	evalx($Exp1 in $Exp2, $Rstore) = $BoolCon

[NI1]	$BoolCon = not(in(evalx($Exp1, $Rstore), evalb($Exp2, $Rstore)))
	====================================================
	evalx($Exp1 notin $Exp2, $Rstore) = $BoolCon

[EQ1]	$BoolCon = elem-equal(evalx($Exp1, $Rstore), evalx($Exp2, $Rstore))
	====================================================
	evalx($Exp1 == $Exp2, $Rstore) 	= $BoolCon

[NE1]	$BoolCon = not(elem-equal(evalx($Exp1, $Rstore), evalx($Exp2, $Rstore)))
	====================================================
	evalx($Exp1 != $Exp2, $Rstore) 	=  $BoolCon

%% ---- aux functions for evaluating comparison operators

[EQI1]	$Integer == $Integer = true
[default-EQI]
	$Integer1 == $Integer2 = false

[LE1]	eval-le($Bag1, $Bag2)			= subset($Bag1, $Bag2)
[LE2]	eval-le($Integer1, $Integer2) 		= $Integer1 <= $Integer2

[LE3]	$Integer1 = get-beginline($Area1),
	$Integer1' = get-beginline($Area2),
	$Integer2 = get-begincol($Area1),
	$Integer2' = get-begincol($Area2),
	$Integer3 = get-endline($Area1),
	$Integer3' = get-endline($Area2),
	$Integer4 = get-endcol($Area1),
	$Integer4' = get-endcol($Area2),
	$BoolCon = elem-equal(get-filename($Area1), get-filename($Area2)) &
		    (($Integer1 > $Integer1') | (($Integer1 == $Integer1') & ($Integer2 >= $Integer2'))) &
		    (($Integer3 < $Integer3') | (($Integer3 == $Integer3') & ($Integer4 <= $Integer4')))
	====================================================
	eval-le($Area1, $Area2) = $BoolCon


[LT1]	eval-lt($Bag1, $Bag2) 			= strict-subset($Bag1,  $Bag2)
[LT2]	eval-lt($Integer1, $Integer2) 		= $Integer1 < $Integer2

[LT3]	$Integer1 = get-beginline($Area1),
	$Integer1' = get-beginline($Area2),
	$Integer2 = get-begincol($Area1),
	$Integer2' = get-begincol($Area2),
	$Integer3 = get-endline($Area1),
	$Integer3' = get-endline($Area2),
	$Integer4 = get-endcol($Area1),
	$Integer4' = get-endcol($Area2),
	$BoolCon = elem-equal(get-filename($Area1), get-filename($Area2)) &
		    (($Integer1 > $Integer1') | (($Integer1 == $Integer1') & ($Integer2 > $Integer2'))) &
		    (($Integer3 < $Integer3') | (($Integer3 == $Integer3') & ($Integer4 < $Integer4')))
	====================================================
	eval-lt($Area1, $Area2) = $BoolCon


[LE1]	$BoolCon = eval-le(evalx($Exp1, $Rstore), evalx($Exp2, $Rstore))
	====================================================
	evalx($Exp1 <= $Exp2, $Rstore) 	= $BoolCon

[LT1]	$BoolCon = eval-lt(evalx($Exp1, $Rstore), evalx($Exp2, $Rstore))
	====================================================
	evalx($Exp1 < $Exp2, $Rstore) = $BoolCon

[GE1]	$BoolCon = not(eval-lt(evalx($Exp1, $Rstore), evalx($Exp2, $Rstore)))
	====================================================
	evalx($Exp1 >= $Exp2, $Rstore) 	= $BoolCon

[GT1]	$BoolCon = not(eval-le(evalx($Exp1, $Rstore), evalx($Exp2, $Rstore)))
	====================================================
	evalx($Exp1 > $Exp2, $Rstore) = $BoolCon

[ADD1]	evalx($Exp1 + $Exp2, $Rstore) 		= evali($Exp1, $Rstore) + evali($Exp2, $Rstore)

[SUB1]	evalx($Exp1 - $Exp2, $Rstore) 		= evali($Exp1, $Rstore) - evali($Exp2, $Rstore)

[MUL1]	evalx($Exp1 * $Exp2, $Rstore) 		= evali($Exp1, $Rstore) * evali($Exp2, $Rstore)

[DIV1]	evalx($Exp1 / $Exp2, $Rstore) 		= evali($Exp1, $Rstore) / evali($Exp2, $Rstore)

[UN1]	evalx($Exp1 union $Exp2, $Rstore)	= union(evalb($Exp1, $Rstore), evalb($Exp2, $Rstore))

[IN1]	evalx($Exp1 inter $Exp2, $Rstore)	= inter(evalb($Exp1, $Rstore), evalb($Exp2, $Rstore))

[DF1]	evalx($Exp1 \ $Exp2, $Rstore)		= diff(evalb($Exp1, $Rstore), evalb($Exp2, $Rstore))

[CM1]	evalx($Exp1 o $Exp2, $Rstore)		= compose(evalb($Exp1, $Rstore), evalb($Exp2, $Rstore))

[CP1]	evalx($Exp1 x $Exp2, $Rstore)		= product(evalb($Exp1, $Rstore), evalb($Exp2, $Rstore))

%% ---- aux functions for evaluating image operator .

[eim1]	eval-im($Rel, $Elem)			= limage($Rel, $Elem) when is-rel($Rel) = true
[eim2]	eval-im($Elem, $Rel)			= rimage($Elem, $Rel) when is-rel($Rel) = true

[eim3]	eval-im($Bag, $Rel)			= rimage($Bag,  $Rel) when is-rel($Rel) = true
[eim4]	eval-im($Rel, $Bag)			= limage($Rel,  $Bag) when is-rel($Rel) = true

[default-eim]
	eval-im($Val1, $Val2)			= empty-bag		%%XXX

[IM1]	evalx($Exp1 . $Exp2, $Rstore)		= eval-im(evalx($Exp1, $Rstore), evalx($Exp2, $Rstore))

%% ---- [ ]
[IM2]	evalx($Exp1 [ $Exp2 ], $Rstore)		= evalx($Exp2 . $Exp1, $Rstore)

[TC1]	evalx($Exp +, $Rstore)			= trans-closure(evalb($Exp, $Rstore))

[RTC1]	evalx($Exp *, $Rstore)			= rtrans-closure(evalb($Exp, $Rstore))

[SZ1]	evalx(# $Exp, $Rstore) 	= size(evalb($Exp, $Rstore))

%% ---- Eval comprehensions

%% ---- Simplify multiple generators

[RF2]	{$Exp | $Gen+}  =  {$Gen+ :: $Exp}

[XX] 	{$Gen, $Gen+ :: $Exp } = { $Gen :: {$Gen+ :: $Exp}}

%% ---- Generator: test

[et-1a]	$Bool =  evalp($Test, $Rstore)
	======================================================================
	evalx({$Test :: $Exp} , $Rstore) = if $Bool then evalx($Exp, $Rstore) else *undefined* fi

%% ---- Generator: assignment,  one variable V <- E

[ea-1a]	$Val = evalx($Exp1, $Rstore),
	$Rstore' =  assign($Var, $Val, $Rstore)
	======================================================================
	evalx({ $Var <- $Exp1 :: $Exp2 }, $Rstore) = evalx($Exp2, $Rstore')

%% ---- Generator: assignment, two variables: <V1, V2> <- E

[eat-1a]	
	$Val = evalx($Exp1, $Rstore),
	$Rstore' =  store-rvars($Var1, $Var2, $Val, $Rstore)
	======================================================================
	evalx({ <$Var1,$Var2> <- $Exp1 :: $Exp2 }, $Rstore) = evalx($Exp2, $Rstore')

%% ---- Generator: assignment, N variables: <V1, V2, ..., Vn> <- E

[eat-1a]	
	$Val = evalx($Exp1, $Rstore),
	$Rstore' =  store-rvars($Var1, $Var2, $Var+, $Val, $Rstore)
	======================================================================
	evalx({ <$Var1,$Var2, $Var+> <- $Exp1 :: $Exp2 }, $Rstore) = evalx($Exp2, $Rstore')

%% ---- Simple generator, extract one value V : E

[ei-1]	$Bag = evalx($Exp1, $Rstore)
	=======================================
	evalx({ $Var : $Exp1 :: $Exp2 }, $Rstore) = eval-itern($Var, mk-iterator($Bag), empty-bag, $Exp2, $Rstore)	%%XXX

%% ---- Simple generator, extract two values <V1, V2> : E

[ei2-1]	$Bag = evalx($Exp1, $Rstore)
	=======================================
	evalx({ <$Var1, $Var2> : $Exp1 :: $Exp2 }, $Rstore) = 
	eval-itern($Var1, $Var2, mk-iterator($Bag), empty-bag, $Exp2, $Rstore)	%%XXX

%% ---- Simple generator, extract N values <V1, V2, ...> : E

[ei2-1]	$Bag = evalx($Exp1, $Rstore)
	=======================================
	evalx({ <$Var1, $Var2, $Var+> : $Exp1 :: $Exp2 }, $Rstore) = 
	eval-itern($Var1, $Var2, $Var+, mk-iterator($Bag), empty-bag, $Exp2, $Rstore)    %%XXX

%% ---- eval-itern: the workhorse for comprehensions

[ei2-2]	is-empty-iter($BagIter) = false,
	$Elem = head($BagIter),
	$Rstore' = store-rvars($Var+, $Elem, $Rstore),
	$Val' = evalx($Exp, $Rstore'),
	eval-itern($Var+, tail($BagIter), append-rval($Val, $Val'), $Exp, $Rstore') = $Elem'	%%XXX
	======================================================
	eval-itern($Var+, $BagIter, $Val, $Exp, $Rstore) = $Elem'

[ei2-3]	is-empty-iter($BagIter) = true
	======================================================
	eval-itern($Var+, $BagIter, $Elem, $Exp2, $Rstore) = $Elem	  %%XXX

%% ---- Auxiliary functions for evaluating comprehensions

%% ---- Assign to list of variables

[sv1]	$Rstore' = assign($Var, $Elem1, $Rstore)
	=====================================================
	store-rvars($Var, $Var+, <$Elem1, $Elem2>, $Rstore) =
	store-rvars($Var+, $Elem2, $Rstore')

[sv2]	$Rstore' = assign($Var, $Elem, $Rstore)
	=====================================================
	store-rvars($Var, $Elem, $Rstore) = $Rstore'

%% --- Append-rval

[AP0]	append-rval($Elem, *undefined*) = $Elem

[AP1]	is-bag($Elem2) = false
	====================================================
	append-rval($Bag1, $Elem2) = union2($Bag1, $Elem2)
[default-AP2]	
	append-rval($Bag1, $Bag2) = union($Bag1, $Bag2)

%% ---- Exists

[EXB1]	$Bag = evalb($Exp, $Rstore),
	$BoolCon = exists($Var, $Bag, $Test, $Rstore)
	=========================================
	evalx(exists($Var : $Exp | $Test), $Rstore) = $BoolCon

[EXB1]	$Bag = evalb($Exp, $Rstore),
	$BoolCon = exists($Var1, $Var2, $Bag, $Test, $Rstore)
	=========================================
	evalx(exists(<$Var1, $Var2> : $Exp | $Test), $Rstore) = $BoolCon

[EXB1]	$Bag = evalb($Exp, $Rstore),
	$BoolCon = exists($Var1, $Var2, $Var+, $Bag, $Test, $Rstore)
	=========================================
	evalx(exists(<$Var1, $Var2, $Var+> : $Exp | $Test), $Rstore) = $BoolCon

%%>>[ex1]	$Rstore' = store-rvars($Var+, $Elem, $Rstore),
%%	$BoolCon = if evalp($Test, $Rstore') then true else exists($Var+, {$Elem*}, $Test, $Rstore) fi
%%	======================================================
%%	exists($Var+, {$Elem, $Elem*}, $Test, $Rstore) = $BoolCon

[ex2]	exists($Var+, empty-bag, $Test, $Rstore) = false	 %%XXX

%% ---- Forall

[AL1]	$Bool = evalp(exists($Var : $Exp | not $Test), $Rstore),
	$BoolCon =  not($Bool)
	==========================================
	evalx(forall($Var : $Exp | $Test), $Rstore) = $BoolCon

[AL2]	$Bool = evalp(exists(<$Var1, $Var2> : $Exp | not $Test), $Rstore),
	$BoolCon = not($Bool)
	==========================================
	evalx(forall(<$Var1, $Var2> : $Exp | $Test), $Rstore) = $BoolCon

[AL3]	$Bool = evalp(exists(<$Var1, $Var2, $Var+> : $Exp | not $Test), $Rstore),
	$BoolCon =  not($Bool)
	==========================================
	evalx(forall(<$Var1, $Var2, $Var+> : $Exp | $Test), $Rstore) = $BoolCon

%% ---- Where expressions

[WH1]	eval-rstats($Stat+, $Rstore) = $Rstore'
	=================================================
	evalx($Exp where $Stat+ endwhere, $Rstore) =  evalx($Exp, $Rstore')	

%% ---- Function calls

%% ---- Bind formals

[bf1]	$Val = evalx($Exp, $Rstore),
	$Rstore' = assign($Var, $Val, $Rstore)
	====================================================
	bind-formals($Var, $Var+, $Exp, $Exp+, $Rstore) =
	bind-formals($Var+, $Exp+, $Rstore')

[bf1]	$Val = evalx($Exp, $Rstore),
	$Rstore' = assign($Var, $Val, $Rstore)
	====================================================
	bind-formals($Var, $Exp, $Rstore) = $Rstore'

%% ---- General case for function application

[default-fun]
	value($Var1, $Rstore) = <$Var+, $Exp2>,
	bind-formals($Var+, $Exp+, $Rstore) = $Rstore'
	====================================================
	evalx($Var1($Exp+), $Rstore) = evalx($Exp2, $Rstore')

%% ---- Special cases for all built-in functions

[Fid]	$Bag  = evalb($Exp, $Rstore)
	====================================================
	evalx(id($Exp), $Rstore) = id($Bag)

[Fdom]	$Rel = evalr($Exp, $Rstore)
	====================================================
	evalx(domain($Exp), $Rstore) = domain($Rel)

[Fran]	$Rel = evalr($Exp, $Rstore)
	====================================================
	evalx(range($Exp), $Rstore) = range($Rel)

[Fcar]	$Rel = evalr($Exp, $Rstore)
	====================================================
	evalx(carrier($Exp), $Rstore) = carrier($Rel)
	
[Ftop]	$Rel = evalr($Exp, $Rstore)
	====================================================
	evalx(top($Exp), $Rstore) = top($Rel)

[Fbot]	$Rel = evalr($Exp, $Rstore)
	====================================================
	evalx(bottom($Exp), $Rstore) = bottom($Rel)

[Finv]	$Rel = evalr($Exp, $Rstore)
	===================================================
	evalx(inv($Exp), $Rstore) = inv($Rel)

[Fcmp]	$Rel = evalr($Exp, $Rstore)
	===================================================
	evalx(compl($Exp), $Rstore) = compl($Rel)

[Ffst]	evalx($Exp, $Rstore) = <$Elem1, $Elem2>
	===================================================
	evalx(first($Exp), $Rstore) = $Elem1

[Fsec]	evalx($Exp, $Rstore) = <$Elem1, $Elem2>
	===================================================
	evalx(second($Exp), $Rstore) = $Elem2

[Fpower0]	
	$Bag  = evalb($Exp, $Rstore)
	====================================================
	evalx(power0($Exp), $Rstore) = power0(mk-iterator($Bag))

[Fpower1]	
	$Bag  = evalb($Exp, $Rstore)
	====================================================
	evalx(power1($Exp), $Rstore) = power1(mk-iterator($Bag))
	
[RdomR]	$Rel = evalr($Exp1, $Rstore), $Bag = evalb($Exp2, $Rstore)
	===================================================
	evalx(domainR($Exp1, $Exp2), $Rstore) = domR($Rel, $Bag)

[FranR]	$Rel = evalr($Exp1, $Rstore), $Bag = evalb($Exp2, $Rstore)
	===================================================
	evalx(rangeR($Exp1, $Exp2), $Rstore) = ranR($Rel, $Bag)

[FcarR]	$Rel = evalr($Exp1, $Rstore), $Bag = evalb($Exp2, $Rstore)
	====================================================
	evalx(carrierR($Exp1, $Exp2), $Rstore) = carR($Rel, $Bag)

[FdomX]	$Rel = evalr($Exp1, $Rstore), $Bag = evalb($Exp2, $Rstore)
	====================================================
	evalx(domainX($Exp1, $Exp2), $Rstore) = domX($Rel, $Bag)

[FranX]	$Rel = evalr($Exp1, $Rstore), $Bag = evalb($Exp2, $Rstore)
	====================================================
	evalx(rangeX($Exp1, $Exp2), $Rstore) = ranX($Rel, $Bag)

[FcarX]	$Rel = evalr($Exp1, $Rstore), $Bag = evalb($Exp2, $Rstore)
	====================================================
	evalx(carrierX($Exp1, $Exp2), $Rstore) = carX($Rel, $Bag)

[FrX]	$Bag1 = evalb($Exp1, $Rstore),
	$Bag2 = evalb($Exp2, $Rstore),
	$Rel  = evalr($Exp3, $Rstore)
	================================================= 
	evalx(reachX($Exp1, $Exp2, $Exp3), $Rstore) =
	reachX($Bag1, $Bag2, $Rel)	

[FrR]	$Bag1 = evalb($Exp1, $Rstore),
        $Bag2 = evalb($Exp2, $Rstore),
        $Rel  = evalr($Exp3, $Rstore)
        ================================================= 
        evalx(reachR($Exp1, $Exp2, $Exp3), $Rstore) =
        reachR($Bag1, $Bag2, $Rel)

%% ---- Auxiliary functions for powerset

[ae1]	is-empty-iter($BagIter) = false,
	$Bag = head($BagIter),
	$Bag' = insert($Elem, $Bag)
	==================================================
	add-element($Elem, $BagIter) = union1($Bag', add-element($Elem, tail($BagIter)))

[ae2]	is-empty-iter($BagIter) = true
	===================================================
	add-element($Elem, $BagIter) = empty-bag

[pw01]	is-empty-iter($BagIter) = false,
	$Elem = head($BagIter),
	$Bag1 = power0(tail($BagIter)),
	$Bag2 = add-element($Elem, mk-iterator($Bag1))
	====================================================
	power0($BagIter) = union($Bag1, $Bag2)

[pw02]	is-empty-iter($BagIter) = true
	====================================================
	power0($BagIter) = insert(empty-bag, empty-bag)						%%XXX

[pw11]	power1($BagIter) = diff(power0($BagIter), insert(empty-bag, empty-bag))				%%XXX

[fn]	evalx(filename($Exp), $Rstore)	=  get-filename(evala($Exp, $Rstore))

[bl]	evalx(beginline($Exp), $Rstore) = get-beginline(evala($Exp, $Rstore))

[bc]	evalx(begincol($Exp), $Rstore) 	= get-begincol(evala($Exp, $Rstore))

[el]	evalx(endline($Exp), $Rstore) 	= get-endline(evala($Exp, $Rstore))

[ec]	evalx(endcol($Exp), $Rstore) 	= get-endcol(evala($Exp, $Rstore))

%% ---- sum

[sumx1] is-empty-iter($BagIter) = false,
	$Integer1 = head($BagIter)
	=======================================	
	sumx($BagIter, $Integer2) = sumx(tail($BagIter), $Integer1 + $Integer2)

[sumx2]	is-empty-iter($BagIter) = true
	======================================
	sumx($BagIter, $Integer) = $Integer

%%[default-sumx]
%%	sumx({$Elem, $Elem*}, $Integer2) = sumx({$Elem*}, $Integer2)

[sum1]	$Bag = evalx($Exp, $Rstore)
	========================================
	evalx(sum($Exp), $Rstore) = sumx(mk-iterator($Bag), 0)

%%% --- average

[avg1]	$Bag = evalx($Exp, $Rstore),
	$Integer1 = sumx(mk-iterator($Bag), 0),
	$Integer2 = size($Bag),
	$Integer2 > 0 = true
	========================================
	evalx(average($Exp), $Rstore) = $Integer1 / $Integer2

[avg2]	evalx(average($Exp), $Rstore) = 0


%% ---- max

[max11] is-empty-iter($BagIter) = false,
	$Integer = head($BagIter)
	========================================
	max1($BagIter) = max2(tail($BagIter), $Integer)	%%XXX

[max12]	is-empty-iter($BagIter) = true
	======================================
	max1($BagIter) = 0

[default-max1]
	max1($BagIter) = max1(tail($BagIter))


[max21]	is-empty-iter($BagIter) = false,
	$Integer1 = head($BagIter),
	$Integer1 > $Integer2 = true
	===========================================================================
	max2($BagIter, $Integer2) = max2(tail($BagIter), $Integer1)	%%XXX

[max22]	is-empty-iter($BagIter) = true
	======================================
	max2($BagIter, $Integer) = $Integer   %%XXX

[default-max2]
	max2($BagIter, $Integer2) = max2(tail($BagIter), $Integer2)	%%XXX

[max-1]	$Bag = evalx($Exp, $Rstore)
	========================================
	evalx(max($Exp), $Rstore) = max1(mk-iterator($Bag))

%% ---- min

[min11]	is-empty-iter($BagIter) = false,
	$Integer = head($BagIter)
	========================================
	min1($BagIter) = min2(tail($BagIter), $Integer)

[min12]	is-empty-iter($BagIter) = true
	========================================
	min1($BagIter) = 0			%%XXX

[default-min1]
	min1($BagIter) = min1(tail($BagIter))	%%XXX


[min21]	is-empty-iter($BagIter) = false,
	$Integer1 = head($BagIter),
	$Integer1 < $Integer2 = true
	===========================================================================
	min2($BagIter, $Integer2) = min2(tail($BagIter), $Integer1)	%%XXX

[min22]	is-empty-iter($BagIter) = true
	========================================
	min2($BagIter, $Integer) = $Integer   %%XXX

[default-min2]
	min2($BagIter, $Integer2) = min2(tail($BagIter), $Integer2)	%%XXX

[min-1]	$Bag = evalx($Exp, $Rstore)
	========================================
	evalx(min($Exp), $Rstore) = min1(mk-iterator($Bag))







