%% Example from Frank Tip's slicing survey

%%       1: read(n)
%%	 2: i := 1
%%	 3: sum := 0
%%	 4: product := 1
%%	 5: while i<= n do
%%	    begin
%%	 6:	sum := sum + i
%%	 7:	product := product * i;
%%	 8:	i := i + 1
%%	    end
%%       9: write(sum)
%%	 10: write(product)

int ROOT = 1

rel[int,int] PRED	= {<1,2>, <2,3>, <3,4>, <4,5>, <5,6>, <5,9>, <6,7>,
			    <7,8>,<8,5>, <8,9>, <9,10>}

rel[str,int] DEF	= {<"n", 1>, <"i", 2>, <"sum", 3>, <"product", 4>,
			  <"sum", 6>, <"product", 7>, <"i", 8>}

rel[str,int] USE	= {<"i", 5>, <"n", 5>, <"sum", 6>, <"i", 6>,
			   <"product", 7>, <"i", 7>, <"i", 8>, <"sum", 9>, 
			   <"product", 10>}


bag[int] CONTROL-STATEMENT = { 5 }

%% Here ends the program specific information.
%%
%% Given values for ROOT, PRED, DEF and USE, we can compute the following
%% general information.
%% This works towards the definitions given in 
%%	Jackson & Rollins: A new model of program dependences for 
%%	reverse engineering.

%% The inverse of PRED and the carrier of PRED for later use:

rel[int,int] PRED-OF 	= inv(PRED)
bag[int] STATEMENT 	= carrier(PRED)



%% Compute the reaching definitions for each statement.
%% First introduce the GEN and KILL relations.

rel[int,<str,int>] GEN  = {<S,<V,S>> : <V,S> in DEF}
rel[int,<str,int>] KILL = 
  {<S1, <V2,S2>> : <V1,S1> in DEF, <V2,S2> in DEF | V1 == V2 and S1 != S2}

assert "GEN":  GEN == {<1, <"n", 1>>, <2, <"i", 2>>, <3, <"sum", 3>>,
 <4, <"product", 4>>, <6, <"sum", 6>>, <7, <"product", 7>>, <8, <"i", 8>>}

assert "KILL": KILL == {<2, <"i", 8>>, <3, <"sum", 6>>, <4, <"product", 7>>,
 <6, <"sum", 3>>,  <7, <"product", 4>>, <8, <"i", 2>>}


%% The goals is to compute RDIN and RDOUT: the sets of variable definitions
%% going in and out of each statement.

rel[int,<str,int>] RDIN = {}
rel[int,<str,int>] RDOUT = GEN

%% Here is the set of mutually recursive equations that has to be solved:

solve {
        RDIN =  {S x RDOUT[P] : S in STATEMENT, P in PRED-OF[S]},
        RDOUT = {S x (GEN[S] union (RDIN[S] \ KILL[S])) : S in STATEMENT }
}

assert "RDIN": RDIN ==  {<2, <"n", 1>>, <3, <"i", 2>>, <3, <"n", 1>>,
 <4, <"sum", 3>>, <4, <"i", 2>>, <4, <"n", 1>>, <5, <"product", 4>>, 
 <5, <"sum", 3>>, <5, <"i", 2>>, <5, <"n", 1>>, <5, <"i", 8>>, 
 <5, <"product", 7>>, <5, <"sum", 6>>, <6, <"product", 4>>, <6, <"sum", 3>>, 
 <6, <"i", 2>>, <6, <"n", 1>>, <6, <"i", 8>>, <6, <"product", 7>>, 
 <6, <"sum", 6>>, <9, <"product", 4>>, <9, <"sum", 3>>, <9, <"i", 2>>,
 <9, <"n", 1>>, <9, <"i", 8>>, <9, <"product", 7>>, <9, <"sum", 6>>,
 <7, <"sum", 6>>, <7, <"product", 4>>, <7, <"i", 2>>, <7, <"n", 1>>,
 <7, <"i", 8>>, <7, <"product", 7>>, <8, <"product", 7>>, <8, <"sum", 6>>,
 <8, <"i", 2>>, <8, <"n", 1>>, <8, <"i", 8>>, <10, <"product", 4>>,
 <10, <"sum", 3>>, <10, <"i", 2>>, <10, <"n", 1>>, <10, <"i", 8>>,
 <10, <"product", 7>>, <10, <"sum", 6>>}

assert "RDOUT": RDOUT == {<1, <"n", 1>>, <2, <"i", 2>>, <2, <"n", 1>>, 
 <3, <"sum", 3>>, <3, <"i", 2>>, <3, <"n", 1>>, <4, <"product", 4>>, 
 <4, <"sum", 3>>, <4, <"i", 2>>, <4, <"n", 1>>, <5, <"product", 4>>, 
 <5, <"sum", 3>>, <5, <"i", 2>>, <5, <"n", 1>>, <5, <"i", 8>>, 
 <5, <"product", 7>>, <5, <"sum", 6>>, <6, <"sum", 6>>, <6, <"product", 4>>,
 <6, <"i", 2>>, <6, <"n", 1>>, <6, <"i", 8>>, <6, <"product", 7>>, 
 <9, <"product", 4>>, <9, <"sum", 3>>, <9, <"i", 2>>, <9, <"n", 1>>, 
 <9, <"i", 8>>, <9, <"product", 7>>, <9, <"sum", 6>>, <7, <"product", 7>>, 
 <7, <"sum", 6>>, <7, <"i", 2>>, <7, <"n", 1>>, <7, <"i", 8>>, <8, <"i", 8>>,
 <8, <"product", 7>>, <8, <"sum", 6>>, <8, <"n", 1>>, <10, <"product", 4>>, 
 <10, <"sum", 3>>, <10, <"i", 2>>, <10, <"n", 1>>, <10, <"i", 8>>, 
 <10, <"product", 7>>, <10, <"sum", 6>>}

%% Compute the relation between each use and corresponding definitions: ud

rel[<str,int>,<str,int>] ud = 
  {<<V,S>,Pair> : <V,S> in USE, Pair in RDIN[S] | V == fst(Pair)}

%% Note, it would be more readable (but currently not possible) to write the 
%% above expressions as:
%%	rel[<str,int>,<str,int>] ud = 
%%	  {<<V1,S1>,<V2,S2>  : <V1,S1> in USE, <V2,S2> in RDIN[S] | V1 == V2}

assert "ud": ud == {<<"i", 5>, <"i", 2>>, <<"i", 5>, <"i", 8>>, <<"n", 5>, <"n", 1>>,
 <<"sum", 6>, <"sum", 3>>, <<"sum", 6>, <"sum", 6>>, <<"i", 6>, <"i", 2>>,
 <<"i", 6>, <"i", 8>>, <<"product", 7>, <"product", 4>>, 
 <<"product", 7>, <"product", 7>>, <<"i", 7>, <"i", 2>>, <<"i", 7>, <"i", 8>>,
 <<"i", 8>, <"i", 2>>, <<"i", 8>, <"i", 8>>, <<"sum", 9>, <"sum", 3>>,
 <<"sum", 9>, <"sum", 6>>, <<"product", 10>, <"product", 4>>, 
 <<"product", 10>, <"product", 7>>}


%% Internal use in definition: du

rel[<str,int>,<str,int>] du  = 
     {<<V1,S1>, <V2,S2>> : <V1, S1> in DEF, <V2, S2> in USE | S1 == S2 }
     union
     {<<V,S>, <"eps",S>> : <V, S> in DEF}
     union
     {<<"tau",S1>,<V,S1>> : S1 in CONTROL-STATEMENT, 
			    <V, S2> in ranR(USE, {S1}) | S1 == S2}

assert "du": du == {<<"sum", 6>, <"sum", 6>>, <<"sum", 6>, <"i", 6>>,
 <<"product", 7>, <"product", 7>>, <<"product", 7>, <"i", 7>>,
 <<"i", 8>, <"i", 8>>, <<"n", 1>, <"eps", 1>>, <<"i", 2>, <"eps", 2>>,
 <<"sum", 3>, <"eps", 3>>, <<"product", 4>, <"eps", 4>>,
 <<"sum", 6>, <"eps", 6>>, <<"product", 7>, <"eps", 7>>,
 <<"i", 8>, <"eps", 8>>, <<"tau", 5>, <"i", 5>>, <<"tau", 5>, <"n", 5>>}


%% Find all the statements that are dominated by each statement

rel[int,int] DOMINATES =
  { S x (STATEMENT \ {ROOT, S} \ range(reachX({ROOT}, {S}, PRED))) : 
    S in STATEMENT }

assert "DOMINATES": DOMINATES == {<1, 2>, <1, 3>, <1, 4>, <1, 5>, <1, 6>, 
 <1, 9>, <1, 7>, <1, 8>, <1, 10>, <2, 3>, <2, 4>, <2, 5>, <2, 6>, <2, 9>,
 <2, 7>, <2, 8>, <2, 10>, <3, 4>, <3, 5>, <3, 6>, <3, 9>, <3, 7>,
 <3, 8>, <3, 10>, <4, 5>, <4, 6>, <4, 9>, <4, 7>, <4, 8>, <4, 10>, <5, 6>,
 <5, 9>, <5, 7>, <5, 8>, <5, 10>, <6, 7>, <6, 8>, <9, 10>, <7, 8>}

%% Find the statements that are directly dominated by each statement

rel[int, int] POST-DOMINATOR = domR(DOMINATES, CONTROL-STATEMENT)

assert "POST-DOMINATOR": POST-DOMINATOR == {<5, 6>, <5, 9>, <5, 7>, <5, 8>,
 <5, 10>}

%% Control dependence: cd

rel[<str,int>,<str,int>] cd  =
   { <<"eps",S2>,<"tau",S1>> : <S1, S2> in POST-DOMINATOR}

assert "cd": cd == {<<"eps", 6>, <"tau", 5>>, <<"eps", 9>, <"tau", 5>>, 
 <<"eps", 7>, <"tau", 5>>, <<"eps", 8>, <"tau", 5>>, 
 <<"eps", 10>, <"tau", 5>>}

%% Control and data dependence: ucd

rel[<str,int>,<str,int>] ucd = ud union cd

assert "ucd": ucd ==  {<<"i", 5>, <"i", 2>>, <<"i", 5>, <"i", 8>>,
 <<"n", 5>, <"n", 1>>, <<"sum", 6>, <"sum", 3>>, <<"sum", 6>, <"sum", 6>>, 
 <<"i", 6>, <"i", 2>>, <<"i", 6>, <"i", 8>>, <<"product", 7>, <"product", 4>>,
 <<"product", 7>, <"product", 7>>, <<"i", 7>, <"i", 2>>, <<"i", 7>, <"i", 8>>,
 <<"i", 8>, <"i", 2>>, <<"i", 8>, <"i", 8>>, <<"sum", 9>, <"sum", 3>>,
 <<"sum", 9>, <"sum", 6>>, <<"product", 10>, <"product", 4>>,
 <<"product", 10>, <"product", 7>>, <<"eps", 6>, <"tau", 5>>,
 <<"eps", 9>, <"tau", 5>>, <<"eps", 7>, <"tau", 5>>, <<"eps", 8>, <"tau", 5>>,
 <<"eps", 10>, <"tau", 5>>}

rel[<str,int>,<str,int>] UU = (ucd o du)*
rel[<str,int>,<str,int>] DD = (du o ucd)*
rel[<str,int>,<str,int>] UD = ucd o (du o ucd)*
rel[<str,int>,<str,int>] DU = du o (ucd o du)*


assert "UU": UU  == {<<"i", 5>, <"eps", 2>>, <<"i", 5>, <"i", 8>>, 
 <<"i", 5>, <"eps", 8>>, <<"n", 5>, <"eps", 1>>, <<"sum", 6>, <"eps", 3>>,
 <<"sum", 6>, <"sum", 6>>, <<"sum", 6>, <"i", 6>>, <<"sum", 6>, <"eps", 6>>,
 <<"i", 6>, <"eps", 2>>, <<"i", 6>, <"i", 8>>, <<"i", 6>, <"eps", 8>>, 
 <<"product", 7>, <"eps", 4>>, <<"product", 7>, <"product", 7>>, 
 <<"product", 7>, <"i", 7>>, <<"product", 7>, <"eps", 7>>, 
 <<"i", 7>, <"eps", 2>>, <<"i", 7>, <"i", 8>>, <<"i", 7>, <"eps", 8>>,
  <<"i", 8>, <"eps", 2>>, <<"i", 8>, <"i", 8>>, <<"i", 8>, <"eps", 8>>,
  <<"sum", 9>, <"eps", 3>>, <<"sum", 9>, <"sum", 6>>, <<"sum", 9>, <"i", 6>>,
  <<"sum", 9>, <"eps", 6>>, <<"product", 10>, <"eps", 4>>, 
 <<"product", 10>, <"product", 7>>, <<"product", 10>, <"i", 7>>, 
 <<"product", 10>, <"eps", 7>>, <<"eps", 6>, <"i", 5>>, <<"eps", 6>, <"n", 5>>,
  <<"eps", 9>, <"i", 5>>, <<"eps", 9>, <"n", 5>>, <<"eps", 7>, <"i", 5>>,
  <<"eps", 7>, <"n", 5>>, <<"eps", 8>, <"i", 5>>, <<"eps", 8>, <"n", 5>>,
  <<"eps", 10>, <"i", 5>>, <<"eps", 10>, <"n", 5>>, <<"i", 5>, <"i", 5>>,
  <<"i", 5>, <"n", 5>>, <<"sum", 6>, <"eps", 2>>, <<"sum", 6>, <"i", 8>>,
  <<"sum", 6>, <"eps", 8>>, <<"sum", 6>, <"i", 5>>, <<"sum", 6>, <"n", 5>>,
  <<"i", 6>, <"i", 5>>, <<"i", 6>, <"n", 5>>, <<"product", 7>, <"eps", 2>>,
  <<"product", 7>, <"i", 8>>, <<"product", 7>, <"eps", 8>>, 
  <<"product", 7>, <"i", 5>>, <<"product", 7>, <"n", 5>>, <<"i", 7>, <"i", 5>>,
   <<"i", 7>, <"n", 5>>, <<"i", 8>, <"i", 5>>, <<"i", 8>, <"n", 5>>, 
  <<"sum", 9>, <"eps", 2>>, <<"sum", 9>, <"i", 8>>, <<"sum", 9>, <"eps", 8>>,
  <<"sum", 9>, <"i", 5>>, <<"sum", 9>, <"n", 5>>, <<"product", 10>, <"eps", 2>>,
  <<"product", 10>, <"i", 8>>, <<"product", 10>, <"eps", 8>>, 
  <<"product", 10>, <"i", 5>>, <<"product", 10>, <"n", 5>>, 
  <<"eps", 6>, <"eps", 2>>, <<"eps", 6>, <"i", 8>>, <<"eps", 6>, <"eps", 8>>,
  <<"eps", 6>, <"eps", 1>>, <<"eps", 9>, <"eps", 2>>, <<"eps", 9>, <"i", 8>>,
  <<"eps", 9>, <"eps", 8>>, <<"eps", 9>, <"eps", 1>>, <<"eps", 7>, <"eps", 2>>,
   <<"eps", 7>, <"i", 8>>, <<"eps", 7>, <"eps", 8>>, <<"eps", 7>, <"eps", 1>>,
  <<"eps", 8>, <"eps", 2>>, <<"eps", 8>, <"i", 8>>, <<"eps", 8>, <"eps", 8>>,
  <<"eps", 8>, <"eps", 1>>, <<"eps", 10>, <"eps", 2>>, <<"eps", 10>, <"i", 8>>,
  <<"eps", 10>, <"eps", 8>>, <<"eps", 10>, <"eps", 1>>, <<"i", 5>, <"eps", 1>>,
  <<"sum", 6>, <"eps", 1>>, <<"i", 6>, <"eps", 1>>, <<"product", 7>, <"eps", 1>>,
  <<"i", 7>, <"eps", 1>>, <<"i", 8>, <"eps", 1>>, <<"sum", 9>, <"eps", 1>>,
  <<"product", 10>, <"eps", 1>>, <<"eps", 2>, <"eps", 2>>, <<"n", 5>, <"n", 5>>,
  <<"eps", 1>, <"eps", 1>>, <<"eps", 3>, <"eps", 3>>, <<"i", 6>, <"i", 6>>,
  <<"eps", 6>, <"eps", 6>>, <<"eps", 4>, <"eps", 4>>, <<"i", 7>, <"i", 7>>,
  <<"eps", 7>, <"eps", 7>>, <<"sum", 9>, <"sum", 9>>, 
  <<"product", 10>, <"product", 10>>, <<"eps", 9>, <"eps", 9>>,
  <<"eps", 10>, <"eps", 10>>}


assert "DD": DD == {<<"sum", 6>, <"sum", 3>>, <<"sum", 6>, <"sum", 6>>,
 <<"sum", 6>, <"i", 2>>, <<"sum", 6>, <"i", 8>>,
 <<"product", 7>, <"product", 4>>, <<"product", 7>, <"product", 7>>,
 <<"product", 7>, <"i", 2>>, <<"product", 7>, <"i", 8>>, <<"i", 8>, <"i", 2>>,
 <<"i", 8>, <"i", 8>>, <<"sum", 6>, <"tau", 5>>,
 <<"product", 7>, <"tau", 5>>, <<"i", 8>, <"tau", 5>>,
 <<"tau", 5>, <"i", 2>>, <<"tau", 5>, <"i", 8>>, <<"tau", 5>, <"n", 1>>,
 <<"sum", 6>, <"n", 1>>, <<"product", 7>, <"n", 1>>, <<"i", 8>, <"n", 1>>,
 <<"tau", 5>, <"tau", 5>>, <<"sum", 3>, <"sum", 3>>, <<"i", 2>, <"i", 2>>,
 <<"product", 4>, <"product", 4>>, <<"n", 1>, <"n", 1>>}


assert "UD": UD ==  {<<"i", 5>, <"i", 2>>, <<"i", 5>, <"i", 8>>, 
 <<"i", 5>, <"tau", 5>>, <<"i", 5>, <"n", 1>>, <<"n", 5>, <"n", 1>>, 
 <<"sum", 6>, <"sum", 3>>, <<"sum", 6>, <"sum", 6>>, <<"sum", 6>, <"i", 2>>,
  <<"sum", 6>, <"i", 8>>, <<"sum", 6>, <"tau", 5>>, <<"sum", 6>, <"n", 1>>, 
 <<"i", 6>, <"i", 2>>, <<"i", 6>, <"i", 8>>, <<"i", 6>, <"tau", 5>>, 
 <<"i", 6>, <"n", 1>>, <<"product", 7>, <"product", 4>>, 
 <<"product", 7>, <"product", 7>>, <<"product", 7>, <"i", 2>>, 
 <<"product", 7>, <"i", 8>>, <<"product", 7>, <"tau", 5>>, 
 <<"product", 7>, <"n", 1>>, <<"i", 7>, <"i", 2>>, <<"i", 7>, <"i", 8>>, 
 <<"i", 7>, <"tau", 5>>, <<"i", 7>, <"n", 1>>, <<"i", 8>, <"i", 2>>, 
 <<"i", 8>, <"i", 8>>, <<"i", 8>, <"tau", 5>>, <<"i", 8>, <"n", 1>>, 
 <<"sum", 9>, <"sum", 3>>, <<"sum", 9>, <"sum", 6>>, <<"sum", 9>, <"i", 2>>, 
 <<"sum", 9>, <"i", 8>>, <<"sum", 9>, <"tau", 5>>, <<"sum", 9>, <"n", 1>>, 
 <<"product", 10>, <"product", 4>>, <<"product", 10>, <"product", 7>>, 
 <<"product", 10>, <"i", 2>>, <<"product", 10>, <"i", 8>>, 
 <<"product", 10>, <"tau", 5>>, <<"product", 10>, <"n", 1>>, 
 <<"eps", 6>, <"i", 2>>, <<"eps", 6>, <"i", 8>>, <<"eps", 6>, <"n", 1>>,
  <<"eps", 6>, <"tau", 5>>, <<"eps", 9>, <"i", 2>>, <<"eps", 9>, <"i", 8>>, 
 <<"eps", 9>, <"n", 1>>, <<"eps", 9>, <"tau", 5>>, <<"eps", 7>, <"i", 2>>,
  <<"eps", 7>, <"i", 8>>, <<"eps", 7>, <"n", 1>>, <<"eps", 7>, <"tau", 5>>,
  <<"eps", 8>, <"i", 2>>, <<"eps", 8>, <"i", 8>>, <<"eps", 8>, <"n", 1>>,
  <<"eps", 8>, <"tau", 5>>, <<"eps", 10>, <"i", 2>>, <<"eps", 10>, <"i", 8>>,
  <<"eps", 10>, <"n", 1>>, <<"eps", 10>, <"tau", 5>>}


assert "DU": DU == {<<"sum", 6>, <"eps", 3>>, <<"sum", 6>, <"sum", 6>>,
 <<"sum", 6>, <"i", 6>>, <<"sum", 6>, <"eps", 6>>, <<"sum", 6>, <"eps", 2>>,
 <<"sum", 6>, <"i", 8>>, <<"sum", 6>, <"eps", 8>>, <<"sum", 6>, <"i", 5>>,
 <<"sum", 6>, <"n", 5>>, <<"sum", 6>, <"eps", 1>>,
 <<"product", 7>, <"eps", 4>>, <<"product", 7>, <"product", 7>>,
 <<"product", 7>, <"i", 7>>, <<"product", 7>, <"eps", 7>>,
 <<"product", 7>, <"eps", 2>>, <<"product", 7>, <"i", 8>>, 
 <<"product", 7>, <"eps", 8>>, <<"product", 7>, <"i", 5>>,
 <<"product", 7>, <"n", 5>>, <<"product", 7>, <"eps", 1>>,
 <<"i", 8>, <"eps", 2>>, <<"i", 8>, <"i", 8>>, <<"i", 8>, <"eps", 8>>,
 <<"i", 8>, <"i", 5>>, <<"i", 8>, <"n", 5>>, <<"i", 8>, <"eps", 1>>,
 <<"n", 1>, <"eps", 1>>, <<"i", 2>, <"eps", 2>>, <<"sum", 3>, <"eps", 3>>,
 <<"product", 4>, <"eps", 4>>, <<"tau", 5>, <"eps", 2>>,
 <<"tau", 5>, <"i", 8>>, <<"tau", 5>, <"eps", 8>>, <<"tau", 5>, <"i", 5>>,
 <<"tau", 5>, <"n", 5>>, <<"tau", 5>, <"eps", 1>>}

bag[<str,int>] BackwardSlice(<str,int> Criterion) =
	       UU[Criterion]

bag[<str,int>] Example1 = BackwardSlice(<"sum",9>)

bag[<str,int>] Example2 = BackwardSlice(<"product",10>)

assert "Example1": Example1 ==  {<"eps", 3>, <"sum", 6>, <"i", 6>, 
  <"eps", 6>, <"eps", 2>, <"i", 8>, <"eps", 8>, <"i", 5>, <"n", 5>, 
  <"eps", 1>, <"sum", 9>}

assert "Example2": Example2 == {<"eps", 4>, <"product", 7>, <"i", 7>, 
   <"eps", 7>, <"eps", 2>, <"i", 8>, <"eps", 8>, <"product", 10>}


