%%%% $Id$

equations

%% \noindent
%% We define several predicates to distinguish the constructors of terms.

  [is-list1]         is-list(Tl)          = true
  [is-list1]         is-list(Tl Ann)      = true
  [default-is-list2] is-list(T)           = false
  [is-con-1]         is-con(ACon)         = true
  [is-con-2]         is-con(ACon Ann)     = true
  [default-is-con-2] is-con(T)            = false
  [is-fun-1]         is-fun(AFun)         = true
  [is-fun-2]         is-fun(AFun Ann)     = true
  [default-is-fun-2] is-fun(T)            = false
  [is-app1]          is-app(AFun(Ts))     = true
  [is-app1]          is-app(AFun(Ts) Ann) = true
  [default-is-app2]  is-app(T)            = false

%% And predicates for several special cases of these constructors.

  [is-lit1]          is-lit(L)            = true
  [is-lit1]          is-lit(L Ann)        = true
  [default-is-lit2]  is-lit(T)            = false
  [is-int1]          is-int(z)            = true
  [is-int1]          is-int(z Ann)        = true
  [default-is-int2]  is-int(T)            = false
  [is-real1]         is-real(RealCon)     = true
  [is-real1]         is-real(RealCon Ann) = true
  [default-is-real2] is-real(T)           = false

%% We define conversion functions, or \emph{retracts},
%% that convert an ATerm to the real sort of the term.
%% Note that these functions are only defined for arguments
%% of the right type. For instance, the function \fun{list} is only
%% defined on terms that are lists, i.e., terms of the sort \sort{ATermList}
%% that are injected into the sort \sort{ATerm}.

  [aterms-1] aterms([Ts])  = Ts  [aterms-2] aterms([Ts] Ann) = Ts
  [list-1]   atermlist(Tl) = Tl  [list-2]   atermlist(Tl Ann) = Tl
  [lit-1]    literal(L)    = L   [lit-2]    literal(L Ann) = L

%% \COND
%%
%% \EQUATIONSBEGIN
%%
%% \noindent
%% The predicate \fun{==} defines the equality of terms.

  [eq-1]          T  == T  = true
  [default-eq-2]  T1 == T2 = false

%% Conditionals on terms and termlists.

  [if-1]  if true  then T1  else T2  fi = T1
  [if-2]  if false then T1  else T2  fi = T2
  [if-1]  if true  then Tl1 else Tl2 fi = Tl1
  [if-2]  if false then Tl1 else Tl2 fi = Tl2

%% The concatenation of argument lists.

  [conc-aterms1] T ++a Ts         = T, Ts
  [conc-aterms2] (T, Ts1) ++a Ts2 = T, (Ts1 ++a Ts2)

%% \HOF
%%
%% \EQUATIONSBEGIN
%%
%% \noindent
%% The predicate \fun{eq} is the name of the equality predicate $==$ on terms.
%% The predicate \fun{holds} applied to the predicate name \fun{eq} and two
%% argument terms $T_1$ and $T_2$ is satisfied if the two terms are equal according
%% to $==$.

  [pred-eq] holds(eq, T1, T2) = T1 == T2

%% The identity function.

  [id-1] identity(T)        = T
  [id-2] apply(identity, T) = T

%% The always succesful predicate.

  [yes-1] yes(T)        = true
  [yes-2] holds(yes, T) = true

%% The composition of a list of functions such that
%% $\mfun{apply}(\mfun{comp}(Fun_1,\ldots,Fun_n), T)$ evaluates to
%% $\mfun{apply}(Fun_1, \ldots \mfun{apply}(Fun_n, T))$.

  [comp-1] apply(comp(Fun), Args)     = apply(Fun, Args)
  [comp-2] apply(comp(Fun, Ts), Args) = apply(Fun, apply(comp(Ts), Args))

%%
%% Partial application\footnote{also know as `Currying'}
%% of a function to a list of arguments, i.e., an
%% application of a function to too few arguments leads to a term that
%% represents the partial application.

  [default-apply-1] apply(AFun, Args) = AFun(Args)

%% The application of such a partial application to more arguments leads to
%% the renewed application of the function to the concatenation of the
%% lists of old and new arguments.

  [default-apply-2] apply(AFun(Args1), Args2) = apply(AFun, Args1 ++a Args2)

%% Similarly we define the satisfaction of a partially filled in predicate
%% applied to more arguments as:

  [default-holds-1] holds(AFun(Args1), Args2) = holds(AFun, Args1 ++a Args2)

%% The function \fun{apply} itself can also be used as a higher-order function
%% through the function name \fun{applyf}.

  [apply-1] apply(applyf, Fun, Args) = apply(Fun, Args)

%% \ANN
%%
%% \EQUATIONSBEGIN
%%
%% \noindent
%% Requirement

  [term-ann] term(T) @ ann(T) = T

%% The function \fun{term} gives the term part of a possibly annotated term.
%% The function \fun{ann} gives the annotation of an annotated term and
%% \fun{no-ann} if the term is not annotated.

  [term-1] term(ACon)         = ACon         [ann-1] ann(ACon)          = []
  [term-2] term(Tl)           = Tl           [ann-2] ann(Tl)            = []
  [term-3] term(AFun)         = AFun         [ann-3] ann(AFun)          = []
  [term-4] term(AFun(Ts))     = AFun(Ts)     [ann-4] ann(AFun(Ts))      = []
  [term-5] term(ACon     Ann) = ACon         [ann-5] ann(ACon     {Ts}) = [Ts]
  [term-6] term(Tl       Ann) = Tl           [ann-6] ann(Tl       {Ts}) = [Ts]
  [term-7] term(AFun     Ann) = AFun         [ann-7] ann(AFun     {Ts}) = [Ts]
  [term-8] term(AFun(Ts) Ann) = AFun(Ts)     [ann-8] ann(AFun(Ts) {Ts'}) = [Ts']
  [term-9] apply(termf, T)    = term(T)

%% A term has annotations if its annotation list is non-empty.

  [has-ann-1] has-ann(T) = true  when ann(T) = [Ts]
  [has-ann-2] has-ann(T) = false when ann(T) = []

%% Add annotations to a term. If the term has already annotations the annotation
%% lists are concatenated.

  [add-ann-1] T              @ []     = T
  [add-ann-1] ACon           @ [Ts]   = ACon     {Ts}
  [add-ann-3] Tl             @ [Ts]   = Tl       {Ts}
  [add-ann-4] AFun           @ [Ts]   = AFun     {Ts}
  [add-ann-5] AFun(Ts)       @ [Ts']  = AFun(Ts) {Ts'}
  [add-ann-6] ACon     {Ts}  @ [Ts']  = ACon     {Ts  ++a Ts'}
  [add-ann-7] Tl       {Ts}  @ [Ts']  = Tl       {Ts  ++a Ts'}
  [add-ann-8] AFun     {Ts}  @ [Ts']  = AFun     {Ts  ++a Ts'}
  [add-ann-9] AFun(Ts) {Ts'} @ [Ts''] = AFun(Ts) {Ts' ++a Ts''}

%% Overwrite the annotations of a term with new annotations.

  [set-ann-1] set-ann(T, Tl) = term(T) @ Tl
