%%%% $Id$

equations

%% \noindent
%% The normalization of an \SDFII{} definition is defined by the following
%% equation. The function \fun{normalize} is parameterized with a module name
%% denoting the top module to be normalized and a sort denoting the topsort
%% of the definition. The definition is normalized by first expanding module
%% $M$ by means of function \fun{m}. Then the normalization functions \fun{b}
%% (Basic), \fun{a} (Alias), \fun{r} (Regular),  \fun{p} (Priorities),
%% \fun{l} (Literals) and
%% \fun{k} (Kernel) are applied to the resulting grammar. The function
%% \fun{topsorts}, defined below, is used to add special productions for
%% the top sorts of the definition and to remove productions not reachable
%% from those top sorts.

  [0]   m[[d]](M) = _G1,
        b[[ _G1 ]] = _G2,
        a[[ _G2 ]] = _G3,
        topsorts[[ _G3 ]](_A) = _G4,
        r[[ _G4 ]] = _G5,
        p[[ _G5 ]] = _G6,
        l[[ _G6 ]] = _G7,
        k[[ _G7 ]] = _G8
        ================
        normalize[[definition d]](M, _A) = reachable({<Start>}, _G8)

%% The function \fun{topsorts} adds a special production for the symbol $\Start{}$,
%% which declares that a text over the grammar is a string of sort $\SymA$ followed
%% by the character representing the end of file. For each declared sort in the
%% definition a production is added that defines that a text can be a string of
%% that sort which starts and ends with layout.

  [0]
        _G' = syntax _A [\EOF] -> <Start> ++ topsorts(_A, S(_G))
        ========================================================
        topsorts[[ _G ]](_A) = _G' _G

  [0] topsorts(_A, 'a+ 'b+) = topsorts(_A, 'a+) ++ topsorts(_A, 'b+)
  [0] topsorts(_A, )        =
  [0] topsorts(_A, _B)      = <LAYOUT?-CF> <_B-CF> <LAYOUT?-CF> -> _A

%% \subsection{Interaction}
%%
%% Several of the normalization functions are underdefined, i.e., the full
%% \SDFII{} formalism contains more constructors than the extension for
%% which they have been defined. Therefore, we must extend these functions
%% accordingly.
%%
%% \smallskip
%%
%% \InterferenceSYN
%% \EQUATIONSBEGIN

%% \noindent
%% The normalization function for regular expressions must be extended
%% to the symbol constructors added in other extensions. The first
%% equations express that sorts, character classes, literals and
%% the symbols {\tt LAYOUT}, $\START$ and $\Start$ do not generate any
%% productions.

  [0] r[[ _S ]] = (/)            [0] r[[ LAYOUT  ]] = (/)
  [0] r[[ cc ]] = (/)            [0] r[[ <START> ]] = (/)
  [0] r[[ L  ]] = (/)            [0] r[[ <Start> ]] = (/)

%% The following equations define that the productions generated for
%% some symbol \SymA{} should be transformed into productions for
%% lexical (context-free) productions if a lexical (context-free)
%% version of the symbol occurs. This entails that first the
%% productions for \SymA{} are generated by the recursive call and
%% that these are transformed by the $\lexsort{\_}$ ($\cfsort{\_}$) function.

  [0] r[[ <_A-LEX> ]] = <r[[_A]] -LEX>
  [0] r[[ <_A-CF>  ]] = <r[[_A]] -CF>
  [0] r[[ <_A-VAR> ]] = r[[ _A ]]

%% This is an example of the context-sensitivity of the generation of productions
%% from symbols. The meaning of $\cfsort{\mfun{Id}*}$ is different from that of
%% $\lexsort{\mfun{Id}*}$.

%% \paragraph{Basic}
%%
%% Literals and character classes do not need the $\lexsort{\_}$ or $\cfsort{\_}$
%% constructor, because they are lexical by definition

  [0] <cc -LEX> = cc  [0] <cc -CF> = cc  [0]  <cc -VAR> = cc
  [0] <L  -LEX> = L   [0] <L  -CF> = L   [0]  <L  -VAR> = L

%% \paragraph{Basic + Priorities}
%%
%% Equations for the normalization of lexical and context-free priorities
%% that were added at the level of \SDFII{}.

  [0]
        _G1 = context-free priorities pr*, _G2 = context-free syntax p*
        ==================================================================
        _G1 <> _G2 = <context-free syntax p*, context-free priorities pr*>
  [0]
        _G1 = context-free priorities pr*, _G2 = lexical syntax p*
        =============================================================
        _G1 <> _G2 = <lexical syntax p*, context-free priorities pr*>
  [0]
        _G1 = context-free priorities pr*1, _G2 = context-free priorities pr*2
        ======================================================================
        _G1 <> _G2 =  <context-free priorities pr*1, pr*2, (/)>

%% Context-free priorities are priority declarations for context-free
%% productions and are abbreviations of normal
%% priorities in the same way that context-free syntax is an abbreviation
%% for a certain style of normal syntax.
%% The productions in the priorities sections are thus treated with the
%% same $\cfsort{\_}$ functions as context-free productions.

   [] b-aux[[context-free priorities pr*]] = <priorities pr* -CF>
   [] <priorities pr*-CF>      = priorities <norm[[pr*]]-CFp>
   [] <pr*-CFp>                = when pr* =
   [] <pr+1, pr+2-CFp>         = <pr+1-CFp> ++ <pr+2-CFp>
   [] <p1 > p2-CFp>            = <p1-CF> > <p2-CF>
   [] <p1 as p2-CFp>           = <p1-CF> as <p2-CF>

%% Similarly for lexical priorities.

   [] b-aux[[lexical priorities pr*]] = <priorities pr* -LEX>
   [] <priorities pr*-LEX>     = priorities <norm[[pr*]]-LEXp>
   [] <pr*-LEXp>               = when pr* =
   [] <pr+1, pr+2-LEXp>        = <pr+1-LEXp> ++ <pr+2-LEXp>
   [] <p1 > p2-LEXp>           = <p1-LEX> > <p2-LEX>
   [] <p1 as p2-LEXp>          = <p1-LEX> as <p2-LEX>

%% \paragraph{Basic + Restrictions}

   [0] b-aux[[lexical restrictions restr*]] = restrictions <restr* -LEX>

   [0] <restr* -LEX>          = when restr* =
   [0] <restr+1 restr+2 -LEX> = <restr+1 -LEX> ++ <restr+2 -LEX>
   [0] <'a -/- las -LEX>       = <'a -LEXs> -/- las

   [0] b-aux[[context-free restrictions restr*]] = restrictions <restr* -CF>

   [0] <restr* -CF>          = when restr* =
   [0] <restr+1 restr+2 -CF> = <restr+1 -CF> ++ <restr+2 -CF>
   [0] <'a -/- las -CF>        = <'a -CFr> -/- las

   [0] <'a      -CFr>  =         when 'a =
   [0] <_A      -CFr>  = <_A-CF>
   [0] <'a+ 'b+ -CFr>  = <'a+ -CFr> ++ <'b+ -CFr>

%% \paragraph{Labels}

  [0] r[[ L : _A ]] = r[[ _A ]]
  [0] <L : _A -LEX> = L : <_A -LEX>
  [0] <L : _A -CF>  = L : <_A -CF>
  [0] <L : _A -VAR> = L : <_A -VAR>

%% \paragraph{Hiding Productions}

%%%  [0] hide(M, context-free syntax p*)    = context-free syntax hide(M, p*)
%%%  [0] hide(M, lexical syntax p*)         = lexical syntax hide(M, p*)
%%%  [0] hide(M, variables p*)              = variables hide(M, p*)
%%%  [0] hide(M, lexical variables p*)      = lexical variables hide(M, p*)

  [annA] annotate(M, context-free syntax p*)  = context-free syntax annotateprods(M, p*)
  [annB] annotate(M, lexical syntax p*)       = lexical syntax annotateprods(M, p*)
  [annC] annotate(M, variables p*)            = variables annotateprods(M, p*)
  [annD] annotate(M, lexical variables p*)    = lexical variables annotateprods(M, p*)

%% \paragraph{Aliases}

  [0]
        _G1 = aliases al*, _G2 = sorts 'a
        ====================================
        _G1 <> _G2 = <sorts 'a, aliases al*>
