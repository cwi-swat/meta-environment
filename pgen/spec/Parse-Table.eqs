equations

%% \paragraph{Parse Tables}
%%
%% A parse table is a record containing a grammar, a follow table, a label table (mapping
%% labels to identifiers), the identifier of the initial state and a state table.

  [pt-0] new-table = parse-table( (/), new-symbol-table, new-label-table, 0, new-states)

  [pt-1] parse-table(_G, st, lt, z, sts)[states]  = sts
  [pt-1] parse-table(_G, st, lt, z, sts)[grammar] = _G
  [pt-1] parse-table(_G, st, lt, z, sts)[follow]  = st
  [pt-1] parse-table(_G, st, lt, z, sts)[labels]  = lt
  [pt-1] parse-table(_G, st, lt, z, sts)[init]    = z

  [pt-1] parse-table(_G, st, lt, z, sts)[states  := sts'] = parse-table(_G, st, lt, z, sts')
  [pt-1] parse-table(_G, st, lt, z, sts)[grammar := _G']  = parse-table(_G', st, lt, z, sts)
  [pt-1] parse-table(_G, st, lt, z, sts)[follow  := st']  = parse-table(_G, st', lt, z, sts)
  [pt-1] parse-table(_G, st, lt, z, sts)[labels  := lt']  = parse-table(_G, st, lt', z, sts)
  [pt-1] parse-table(_G, st, lt, z, sts)[init    := z']   = parse-table(_G, st, lt, z', sts)

%% The operation $pt[v]$ looks up the identifier of the state with kernel $v$.
%% If no such state exists it is added. The operation returns the accordingly
%% modified parse table.

  [pt-2]
        pt[states][v] = <sts, z>
        ==============================
        pt[v] = <pt[states := sts], z>

%% \paragraph{States}

%% A state table stores states, which have at least an identifier
%% and a kernel vertex.
%%
%% The \fun{last} denotes the next available state identifier.

  [sts-0] new-states = states(0, [])

  [sts-1] states(z, stl)[last] = z
  [sts-2] states(z, stl)[last := z'] = states(z', stl)

%% Retrieving the state with identifier $z'$.

  [sts-2]
        state[id] = z'
        ================================================
        states(z, [state*1, state, state*2])[z'] = state
  [default-sts-3]
        states(z, [state*])[z'] = new-state

%% Overwriting the state with identifier $z'$.

  [sts-4]
        sts = states(z, [state*1, state, state*2]), state[id] = z'
        ==========================================================
        sts[z' := state'] = states(z, [state*1, state', state*2])
  [default-sts5]
        states(z, [state*])[z' := state] = states(z, [state*, state])

%% Looking up a kernel in the state table yields the identifier of the
%% state with that kernel (which should be unique). If no such state
%% exists a new one is created with the given kernel and a new identifier.
%% The identifiers are integers. The first argument of the states table
%% is an integer that denotes the next free identifier.

  [sts-2]
        sts = states(z, [state*1, state, state*2]), state[kernel] = v
        =============================================================
        sts[v] = <sts, state[id]>
  [default-sts-2]
        z = sts[last], state = new-state[kernel := v][id := z]
        ======================================================
        sts[v] = <sts[last := z + 1][z := state], z>

%% \paragraph{State}
%%
%% A state is a record containing an identifier (integer), a
%% kernel vertex, a closure vertex, a goto table and an action table.
%%

  [state-1] new-state = state-rec(0, new-vertex, new-vertex, new-goto-table, new-action-table)

  [state-2] state-rec(z, v1, v2, gt, at)[kernel]  = v1
  [state-2] state-rec(z, v1, v2, gt, at)[closure] = v2
  [state-2] state-rec(z, v1, v2, gt, at)[id]      = z
  [state-2] state-rec(z, v1, v2, gt, at)[actions] = at
  [state-2] state-rec(z, v1, v2, gt, at)[gotos]   = gt

  [state-2] state-rec(z, v1, v2, gt, at)[kernel  := v3]  = state-rec(z, v3, v2, gt, at)
  [state-2] state-rec(z, v1, v2, gt, at)[closure := v3]  = state-rec(z, v1, v3, gt, at)
  [state-2] state-rec(z, v1, v2, gt, at)[id      := z']  = state-rec(z', v1, v2, gt, at)
  [state-2] state-rec(z, v1, v2, gt, at)[actions := at'] = state-rec(z, v1, v2, gt, at')
  [state-2] state-rec(z, v1, v2, gt, at)[gotos   := gt'] = state-rec(z, v1, v2, gt', at)

%% \paragraph{Goto Table}
%%
%% A goto table maps character classes to state identifiers.

  [gt-1] new-goto-table = gotos([])

  [] gotos([])[cc :=  z]                  = gotos([goto(cc, z)])
  [] gotos([goto(cc1, z), ge*])[cc2 := z] = gotos([goto(cc1 \/ cc2, z), ge*])
  [default-] gotos([ge, ge*])[cc := z]    = gotos([ge, ge*2]) when gotos([ge*2]) = gotos([ge*])[cc := z]

%% \paragraph{Action Table}
%%
%% An action table maps labels to sets of actions.


  [at-1] new-action-table = actions([])

  [at-2] actions([ae*1, action(ls, {a*}), ae*2])[l] = {a*} when l (- ls = true
  [default-at-2] actions([ae*])[l] = {}


%% \paragraph{Label Table}

  [lt-1] new-label-table = labels([])

  []         labels([le*1, label(p, cc), le*2])[p] = cc
  []         lt[cc]                                = cc
  [default-] lt[l]                                 = []

  [lt-2] labels([le*1, label(l, cc), le*2])[l := z'] = labels([le*1, label(l, [character(z')]), le*2])
  [default-lt-2] labels([le*])[l := z] = labels([le*, label(l, [character(z)])])
