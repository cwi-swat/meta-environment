%%%% $Id$

equations

  [0]   init-labels[[_G]] = init-labels[[P(_G)]](int(\LABEL_START))

  [0]
        init-labels[[]](z) = new-label-table
  [0]
        init-labels[[p*]](z+1) = lt
        ===================================
        init-labels[[p p*]](z) = lt[p := z]

%% Derive shift actions from gotos.
  [0] shifts(gt) = nm-shifts(gt)
  [nm-0]
        nm-shifts(gotos([])) = new-action-table
%%%  [nm-0]
%%%        nm-shifts(gotos([goto([\EOF], z), ge*])) = nm-shifts(gotos([ge*]))[{[\EOF]} := {accept}]
%%%   [nm-0]
%%%        [\BOT-\TOP] /\ cc1 = cc2, cc2 != []
%%%        ==============================================================================
%%%        nm-shifts(gotos([goto(cc1, z), ge*])) = nm-shifts(gotos([ge*]))[{cc2} := {shift(z)}]
%%%  [default-nm-0]
%%%        nm-shifts(gotos([goto(cc, z), ge*])) = nm-shifts(gotos([ge*]))
  [nm-1] nm-shifts(gotos([ge*])) = at1,
         at1[{[\EOF]} := {accept}] = at2
         ===============================
         nm-shifts(gotos([goto([\EOF], z), ge*])) = at2
   [nm-0]
        [\BOT-\TOP] /\ cc1 = cc2, cc2 != [],
        nm-shifts(gotos([ge*])) = at1,
        at1[{cc2} := {shift(z)}] = at2
        ==============================
        nm-shifts(gotos([goto(cc1, z), ge*])) = at2
  [default-nm-0]
        nm-shifts(gotos([goto(cc, z), ge*])) = nm-shifts(gotos([ge*]))

%% Derive reduce actions from items in the item set.

  []
        reductions(lt, st, restr*, {}, at) = at
  []
        union(st('a -> _A!)) = cc, lt['a -> _A!] = [_c],
        proj__A(restr*) = las, restrict(cc, las, |'a|, int(_c), 'a -> _A!, at) = at'
        ==========================================================================================
        reductions(lt, st, restr*, {['a . -> _A!] I*}, at) = reductions(lt, st, restr*, {I*}, at')
  [default-]
        reductions(lt, st, restr*, {I I*}, at) = reductions(lt, st, restr*, {I*}, at)


  [] restrict(cc, [[]], i, j, p, at) =
     at[{cc}  := {reduce(i, j, p, [[]])}]

  [] restrict(cc, [[cc', la*]], i, j, p, at) =
     restrict(cc / cc', [[la*]], i, j, p, at)

  [] restrict(cc, [[cc' . las, la*]], i, j, p, at) =
     restrict(cc / cc', [[la*]], i, j, p, at[{cc /\ cc'} := {reduce(i, j, p, las)}])

  [nm-0] union(ls) = nm-union(ls)

  [0] nm-union({})     = []
  [0] nm-union({l l*}) = char-class(l) \/ nm-union({l*})

  [0]         char-class(cc) = cc
  [default-0] char-class(l)  = []


%% adding actions to an action table. Care has to be taken to keep the labelsets disjunct.

  [0]
        actions([])[{cc} := {a*}] = add-action(action({cc}, {a*}), new-action-table)
  [0]
        cc2 /\ cc1 = cc3, cc3 != [],
        actions([ae*1])[{cc2/cc3} := {a*2}] = at,
        at' = add-action(action({cc1/cc3}, {a*1}),
              add-action(action({cc3}, {a*1} || {a*2}), at))
        ==============================================================================
        actions([action({cc1}, {a*1}), ae*1])[{cc2} := {a*2}] = at'
  [0]
        cc2 /\ cc1 = cc3, cc3 = [],
        actions([ae*1])[{cc2} := {a*2}] = at,
        at' = add-action(action({cc1}, {a*1}), at)
        ==========================================================
        actions([action({cc1}, {a*1}), ae*1])[{cc2} := {a*2}] = at'

%% The function \fun{add-action} filters action entries with empty labelsets.

  [0] add-action(action({[]}, {a*}), actions([ae*])) = actions([ae*])
  [default-0] add-action(ae, actions([ae*])) = actions([ae, ae*])
