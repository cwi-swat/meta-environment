%%%% $Id$

equations

%% \noindent
%% The function $\mfun{r}\sem{\_}$ adds defining
%% productions for each regular expresssion occurring
%% in one of the productions of the grammar.
%% Existing productions are not affected.

   [0] r[[ _G ]] = _G r[[ 'a ]] when {'a} = symbols(_G)

%% Recall that the function \fun{symbols}, defined in \Section{Mod:Kernel-Sdf-Projection},
%% gives the set of all symbols in a grammar. The function $\mfun{r}\sem{\_}$
%% generates a grammar for each of the regular expressions in the list of symbols.

   [0] r[[]]        = (/)
   [0] r[['a+ 'b+]] = r[['a+]] r[['b+]]

%% \paragraph{Concatenation}
%%
%% The regular expression $(\alpha)$ is a \emph{symbol}
%% that abbreviates the \emph{concatenation} of the symbols
%% $\alpha$.

   [0]
        r[[ () ]] = syntax  -> ()
   [0]
        p = _A 'a+ -> (_A 'a+)
        ======================================
        r[[ (_A 'a+) ]] = syntax p r[[_A 'a+]]

%% Note that $\mfun{r}\sem{\Sym{A}\;\alpha^+}$
%% recursively produces the productions for regular expressions in
%% the list of symbols $\Sym{A}\;\alpha^+$.
%%
%% \paragraph{Alternative}
%%
%% The \emph{alternative} $\Sym{A}|\Sym{B}$ denotes
%% either $\Sym{A}$ or $\Sym{B}$. We could thus define
%% $\mfun{r}\sem{\Sym{A}|\Sym{B}}$ to yield the productions
%% $\Sym{A}\to\Sym{A}|\Sym{B}$ and
%% $\Sym{B}\to\Sym{A}|\Sym{B}$.
%% However, if one of the alternatives
%% is again an alternative, an unnecessary chain
%% $
%%    \Sym{A} \to \Sym{A} | \Sym{B}
%% $
%% and
%% $
%%    \Sym{A} | \Sym{B} \to \Sym{A} | \Sym{B} | \Sym{C}
%% $
%% is created.
%% We would rather have
%% $
%%    \Sym{A} \to \Sym{A} | \Sym{B} | \Sym{C}
%% $.
%% Therefore, we define

   [0] r[[_A | _B]] = alt(_A | _B, _A | _B)

%% where the function \fun{alt} unpacks the alternative until
%% a symbol is reached that is not an alternative.

   [0]         alt(_B1 | _B2, _A) = alt(_B1, _A) alt(_B2, _A)
   [default-0] alt(_B, _A)        = syntax _B -> _A r[[_B]]

%% \paragraph{Optional}
%%
%% The \emph{optional construct} $\Sym{A}?$ is either empty or $\Sym{A}$.

   [0]
        p1 =    -> _A?,
        p2 = _A -> _A?
        ==================================
        r[[ _A ? ]] = syntax p1 p2 r[[_A]]

%% \paragraph{Iteration}
%% \input{iteration.ltx}

   [0]
        p0 = _A      -> _A+,
        p1 = _A+ _A+ -> _A+ {left},
        p2 = _A+ _A* -> _A+,
        p3 = _A* _A+ -> _A+,
        p4 = _A* _A* -> _A* {left},
        p5 =         -> _A*,
        p6 = _A+     -> _A*
        =============================================================
        r[[_A*]] = syntax p0 p1 p2 p3 p4 p5 p6
                   priorities {left: p1 p2 p3 p4} > {p5 p6} r[[ _A ]]
   [0]
        r[[ _A+ ]] = r[[ _A* ]]

%% \paragraph{Iteration with Separator}
%%
%% The \emph{iteration with separator} operators $\{\Sym{A}\;\Sym{B}\}+$ and
%% $\{\Sym{A}\;\Sym{B}\}*$ denote iteration of $\Sym{A}$'s separated by
%% $\Sym{B}$'s. Their meaning is defined analogously to $\Sym{A}+$ and
%% $\Sym{A}*$.

   [0]
        p0 = _A                   -> {_A _B}+,
        p1 = {_A _B}+ _B {_A _B}+ -> {_A _B}+ {left},
        p2 = {_A _B}+ _B {_A _B}* -> {_A _B}+,
        p3 = {_A _B}* _B {_A _B}+ -> {_A _B}+,
        p4 = {_A _B}* _B {_A _B}* -> {_A _B}* {left},
        p5 =                      -> {_A _B}*,
        p6 = {_A _B}+             -> {_A _B}*
        ================================================================
        r[[{_A _B}*]] = syntax p0 p1 p2 p3 p4 p5 p6
                        priorities {left: p1 p2 p3 p4} > {p5 p6} r[[ _A _B ]]
   [0]
        r[[ {_A _B}+ ]] = r[[ {_A _B}* ]]

%% \paragraph{Constrained Iteration}
%%
%% The iteration operator $\{\Sym{A}\}n+$ denotes the iteration of \emph{at}
%% \emph{least} $n$ $\Sym{A}$s. First of all we define  that zero
%% or more $\Sym{A}$s corresponds to $*$ iteration and that one or
%% more $\Sym{A}$s corresponds to $+$ iteration. For integers $n\geq2$ we define
%% $\{\Sym{A}\}n+$ in terms of $\{\Sym{A}\}(n-1)+$, and eventually
%% $\Sym{A}+$, by productions of the form
%% $\Sym{A}\;\{\Sym{A}\}(n-1)+\to\{\Sym{A}\}n+$.

   [0] {_A}0+ = _A*
   [0] {_A}1+ = _A+

   [0]
        n >= 2 = true, n - 1 = n', p = _A {_A} n'+ -> {_A} n+
        =====================================================
        r[[ {_A} n+]] = syntax p r[[ {_A} n'+ ]]

%% Constrained iteration is defined similarly for lists with separators.

   [0] {_A _B} 0+ = {_A _B}*
   [0] {_A _B} 1+ = {_A _B}+

   [0]
        n >= 2 = true, n-1 = n', p = _A _B {_A _B}n'+ -> {_A _B}n+
        ==========================================================
        r[[ {_A _B}n+]] = syntax p r[[ {_A _B}n'+ ]]

%% \paragraph{Tuples}
%%
%% For the definition of functions that return a tuple of values,
%% new sorts have to be invented. To give sensible types to tuples
%% the notation $\Sym{A}\#\Sym{B}$ is introduced.
%% A symbol $\Sym{A}_1\#\ldots\#\Sym{A}_n$ denotes a tuple of
%% $\Sym{A}_1\ldots\Sym{A}_n$ expressions.
%% A tuple is written as $\langle{}T_1,\ldots,T_n\rangle$,
%% where the $T_i$ are expresions of type $\Sym{A}_i$.

  [0]
        "<" ++ tup(_A # _B) ++ ">" = 'a, p = 'a -> _A # _B
        ==================================================
        r[[ _A # _B ]] =  syntax p r[[ 'a ]]

%% The auxiliary function $\mfun{tup}\sem{\_}$ derives the syntax
%% of the body of the tuple by separating the symbols by commas.

  [0]         tup(_A # _B) = tup(_A) ++ "," ++ tup(_B)
  [default-0] tup(_A) = _A

%% \paragraph{Sets}
%%
%% The conventional notation for sets is a list of items
%% between $\{$ and $\}$. The operator $\mfun{Set}[\Sym{A}]$ generates
%% this notation such that if $T_1\ldots{}T_n$ are expressions of
%% type $\Sym{A}$, then $\{T_1,\ldots,T_n\}$ is an expression of
%% type  $\mfun{Set}[\Sym{A}]$.

   [0]
        'a = "{" {_A ","}* "}", p = 'a -> Set[_A]
        =========================================
        r[[ Set[_A] ]] = r[['a]] syntax p

%% \paragraph{Functions}
%%
%% Sometimes it is convenient to pass functions around as data.
%% The operator $(\alpha\Rightarrow\Sym{B})$ can be used to give a type to functions.
%% It denotes the sort of functions from $\alpha$ to $\Sym{B}$.
%% The operator generates syntax for the prefix application of a
%% function to an argument.

   [0]
        p = ('a => _B) "(" 'a ")" -> _B
        =======================================
        r[[ ('a => _B) ]] = syntax p r[['a _B]]

%% \paragraph{Permutation}
%%
%% The permutation symbol $\ll\alpha\gg$ denotes any concatenation of the symbols
%% in $\alpha$, i.e., $\beta\to\ll\alpha\gg$ if $\beta$ is a permutation of $\alpha$.

  [0] r[[ <<'a>> ]] = syntax perm('a) r[['a]]

%% The function \fun{perm} generates the productions for all permutations of
%% a set of symbols. In case the permutation consists of two elements it
%% generates the two productions directly.
%% In case of more elements the
%% function \fun{perm3} is used to generate permutations.

  [0] perm( )     = -> << >>
  [0] perm(_A)    = _A -> <<_A>>
  [0] perm(_A _B) = _A _B -> <<_A _B>> _B _A -> <<_A _B>>
  [0] perm('a)    = perm3( , 'a) when |'a| > 2 = true

%% For each symbol in the list a production is generated with that symbol
%% first and a permutation of the other symbols following it.

  [0]
        perm3('a, ) =
  [0]
        p = _A <<'a 'b>> -> <<'a _A 'b>>
        =======================================================
        perm3('a, _A 'b) = p ++ perm3('a _A, 'b) ++ perm('a 'b)

%% It should be observed that this is not a very efficient way to implement permutation
%% constructs. It should be adequate for permutations of 2 or 3 elements, though. What is
%% needed in addition to the generation of these productions, is the normalization
%% of the parse trees over these productions to a form that lists the elements in
%% a fixed order such that semantic functions do not also have to deal with all
%% permutations.  \cite{Cam93} describes an extension of  LL(1) parsing for
%% permutation operators. An alternative approach suggested by \cite{Cam93} is
%% the introduction of an intermediate symbol representing the union of the symbols
%% in the permutation and a check after parsing that each symbol in the permutation
%% is represented exactly once.

%%%%% This alternative just produces all permutations in a flat manner.
%%%%%
%%%%%  [] r[[ {'a} ]] = syntax perm( , 'a, {'a}) r[['a]]
%%%%%  [] perm(, , _B)           = -> _B
%%%%%  [] perm('a+, , _B)        =
%%%%%  [] perm('a, _A 'b, _B)    = perm1(_A, perm( , 'a 'b, _B)) ++ perm('a _A, 'b, _B)
%%%%%  [] perm1(_A, )            =
%%%%%  [] perm1(_A, 'b -> _B p*) = _A 'b -> _B ++ perm1(_A, p*)

%%%
