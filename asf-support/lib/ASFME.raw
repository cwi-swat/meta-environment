[ [ Implies
, lex-to-cf
, appl ( prod ( [ lex ( sort ( "Implies" ) ) ]
, cf ( sort ( "Implies" ) )
, no-attrs )
, [ < lex ( Lexical ) > ] ) ]
, [ TagId
, lex-to-cf
, appl ( prod ( [ lex ( sort ( "TagId" ) ) ]
, cf ( sort ( "TagId" ) )
, attrs ( [ atr ( "avoid" ) ] ) )
, [ < lex ( Lexical ) > ] ) ]
, [ Conditions
, Default
, appl ( prod ( [ cf ( iter-sep ( sort ( "Condition" )
, lit ( "," ) ) ) ]
, cf ( sort ( "Conditions" ) )
, attrs ( [ id ( "Equations" ) ] ) )
, [ list ( cf ( iter-sep ( sort ( "Condition" )
, lit ( "," ) ) )
, < list ( Condition-list ) > ) ] ) ]
, [ Condition-list
, single
, [ < head ( Condition ) > ] ]
, [ Condition-list
, many
, [ < head ( Condition ) >
, < ws-after-first ( Layout ) >
, lit ( < sep ( str ) > )
, < ws-after-sep ( Layout ) >
, < [ tail ( Condition-list ) ] > ] ]
, [ Equations
, absent
, appl ( prod ( [  ]
, cf ( sort ( "Equations" ) )
, attrs ( [ id ( "Equations" ) ] ) )
, [  ] ) ]
, [ Equations
, present
, appl ( prod ( [ lit ( "equations" )
, cf ( opt ( layout ) )
, cf ( iter-star ( sort ( "CondEquation" ) ) ) ]
, cf ( sort ( "Equations" ) )
, attrs ( [ id ( "Equations" ) ] ) )
, [ lit ( "equations" )
, < "ws-after-equations" ( Layout ) >
, list ( cf ( iter-star ( sort ( "CondEquation" ) ) )
, < list ( CondEquation-list ) > ) ] ) ]
, [ CondEquation-list
, empty
, [  ] ]
, [ CondEquation-list
, single
, [ < head ( CondEquation ) > ] ]
, [ CondEquation-list
, many
, [ < head ( CondEquation ) >
, < ws-after-first ( Layout ) >
, < [ tail ( CondEquation-list ) ] > ] ]
, [ CondEquation
, simple
, appl ( prod ( [ cf ( sort ( "Tag" ) )
, cf ( opt ( layout ) )
, cf ( sort ( "Equation" ) ) ]
, cf ( sort ( "CondEquation" ) )
, attrs ( [ id ( "Equations" ) ] ) )
, [ < Tag ( Tag ) >
, < ws-after-Tag ( Layout ) >
, < Equation ( Equation ) > ] ) ]
, [ CondEquation
, implies
, appl ( prod ( [ cf ( sort ( "Tag" ) )
, cf ( opt ( layout ) )
, cf ( sort ( "Conditions" ) )
, cf ( opt ( layout ) )
, cf ( sort ( "Implies" ) )
, cf ( opt ( layout ) )
, cf ( sort ( "Equation" ) ) ]
, cf ( sort ( "CondEquation" ) )
, attrs ( [ id ( "Equations" ) ] ) )
, [ < Tag ( Tag ) >
, < ws-after-Tag ( Layout ) >
, < Conditions ( Conditions ) >
, < ws-after-Conditions ( Layout ) >
, < Implies ( Implies ) >
, < ws-after-Implies ( Layout ) >
, < Equation ( Equation ) > ] ) ]
, [ CondEquation
, when
, appl ( prod ( [ cf ( sort ( "Tag" ) )
, cf ( opt ( layout ) )
, cf ( sort ( "Equation" ) )
, cf ( opt ( layout ) )
, lit ( "when" )
, cf ( opt ( layout ) )
, cf ( sort ( "Conditions" ) ) ]
, cf ( sort ( "CondEquation" ) )
, attrs ( [ id ( "Equations" ) ] ) )
, [ < Tag ( Tag ) >
, < ws-after-Tag ( Layout ) >
, < Equation ( Equation ) >
, < ws-after-Equation ( Layout ) >
, lit ( "when" )
, < "ws-after-when" ( Layout ) >
, < Conditions ( Conditions ) > ] ) ]
, [ Tag
, empty
, appl ( prod ( [ lit ( "[" )
, cf ( opt ( layout ) )
, lit ( "]" ) ]
, cf ( sort ( "Tag" ) )
, attrs ( [ id ( "Equations" ) ] ) )
, [ lit ( "[" )
, < "ws-after-[" ( Layout ) >
, lit ( "]" ) ] ) ]
, [ Tag
, not-empty
, appl ( prod ( [ lit ( "[" )
, cf ( opt ( layout ) )
, cf ( sort ( "TagId" ) )
, cf ( opt ( layout ) )
, lit ( "]" ) ]
, cf ( sort ( "Tag" ) )
, attrs ( [ id ( "Equations" ) ] ) )
, [ lit ( "[" )
, < "ws-after-[" ( Layout ) >
, < TagId ( TagId ) >
, < ws-after-TagId ( Layout ) >
, lit ( "]" ) ] ) ]
, [ Tree
, lexical-constructor
, appl ( prod ( [ cf ( sort ( "Tree" ) )
, cf ( opt ( layout ) )
, lit ( "(" )
, cf ( opt ( layout ) )
, cf ( iter-star ( sort ( "CHAR" ) ) )
, cf ( opt ( layout ) )
, lit ( ")" ) ]
, cf ( sort ( "Tree" ) )
, attrs ( [ id ( "GEN-LexConsFuncs" ) ] ) )
, [ < name ( Tree ) >
, < ws-after-name ( Layout ) >
, lit ( "(" )
, < "ws-after-(" ( Layout ) >
, list ( cf ( iter-star ( sort ( "CHAR" ) ) )
, < list ( CHAR-list ) > )
, < ws-after-list ( Layout ) >
, lit ( ")" ) ] ) ]
, [ CHAR-list
, empty
, [  ] ]
, [ CHAR-list
, single
, [ < head ( CHAR ) > ] ]
, [ CHAR-list
, many
, [ < head ( CHAR ) >
, < ws-after-first ( Layout ) >
, < [ tail ( CHAR-list ) ] > ] ]
, [ Equation
, Default
, appl ( prod ( [ cf ( sort ( "Tree" ) )
, cf ( opt ( layout ) )
, lit ( "=" )
, cf ( opt ( layout ) )
, cf ( sort ( "Tree" ) ) ]
, cf ( sort ( "Equation" ) )
, attrs ( [ id ( "GEN-Equations" ) ] ) )
, [ < lhs ( Tree ) >
, < ws-after-lhs ( Layout ) >
, lit ( "=" )
, < "ws-after-=" ( Layout ) >
, < rhs ( Tree ) > ] ) ]
, [ Condition
, positive
, appl ( prod ( [ cf ( sort ( "Tree" ) )
, cf ( opt ( layout ) )
, lit ( "=" )
, cf ( opt ( layout ) )
, cf ( sort ( "Tree" ) ) ]
, cf ( sort ( "Condition" ) )
, attrs ( [ id ( "GEN-Equations" ) ] ) )
, [ < lhs ( Tree ) >
, < ws-after-lhs ( Layout ) >
, lit ( "=" )
, < "ws-after-=" ( Layout ) >
, < rhs ( Tree ) > ] ) ]
, [ Condition
, negative
, appl ( prod ( [ cf ( sort ( "Tree" ) )
, cf ( opt ( layout ) )
, lit ( "!=" )
, cf ( opt ( layout ) )
, cf ( sort ( "Tree" ) ) ]
, cf ( sort ( "Condition" ) )
, attrs ( [ id ( "GEN-Equations" ) ] ) )
, [ < lhs ( Tree ) >
, < ws-after-lhs ( Layout ) >
, lit ( "!=" )
, < ws-after-unequal ( Layout ) >
, < rhs ( Tree ) > ] ) ]
, [ CHAR
, lex-to-cf
, appl ( prod ( [ lex ( sort ( "CHAR" ) ) ]
, cf ( sort ( "CHAR" ) )
, no-attrs )
, [ < lex ( Lexical ) > ] ) ] ]