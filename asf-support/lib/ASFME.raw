[ [ Implies , lex-to-cf , appl ( prod ( [ lex ( sort ( "Implies" ) ) ] , cf ( sort ( "Implies" ) ) , no-attrs ) , [ < lex ( Lexical ) > ] ) ] , [ TagId , lex-to-cf , appl ( prod ( [ lex ( sort ( "TagId" ) ) ] , cf ( sort ( "TagId" ) ) , no-attrs ) , [ < lex ( Lexical ) > ] ) ] , [ Conditions , Default , appl ( prod ( [ cf ( iter-sep ( sort ( "Condition" ) , lit ( "," ) ) ) ] , cf ( sort ( "Conditions" ) ) , no-attrs ) , [ appl ( list ( cf ( iter-sep ( sort ( "Condition" ) , lit ( "," ) ) ) ) , < list ( Condition-list ) > ) ] ) ] , [ Condition-list , single , [ < head ( Condition ) > ] ] , [ Condition-list , many , [ < head ( Condition ) > , < ws-after-first ( Layout ) > , lit ( < sep ( str ) > ) , < ws-after-sep ( Layout ) > , < [ tail ( Condition-list ) ] > ] ] , [ Equations , absent , appl ( prod ( [  ] , cf ( sort ( "Equations" ) ) , no-attrs ) , [  ] ) ] , [ Equations , present , appl ( prod ( [ lit ( "equations" ) , cf ( opt ( layout ) ) , cf ( iter-star ( sort ( "CondEquation" ) ) ) ] , cf ( sort ( "Equations" ) ) , no-attrs ) , [ lit ( "equations" ) , < "ws-after-equations" ( Layout ) > , appl ( list ( cf ( iter-star ( sort ( "CondEquation" ) ) ) ) , < list ( CondEquation-list ) > ) ] ) ] , [ CondEquation-list , empty , [  ] ] , [ CondEquation-list , single , [ < head ( CondEquation ) > ] ] , [ CondEquation-list , many , [ < head ( CondEquation ) > , < ws-after-first ( Layout ) > , < [ tail ( CondEquation-list ) ] > ] ] , [ CondEquation , simple , appl ( prod ( [ cf ( sort ( "Tag" ) ) , cf ( opt ( layout ) ) , cf ( sort ( "Equation" ) ) ] , cf ( sort ( "CondEquation" ) ) , no-attrs ) , [ < Tag ( Tag ) > , < ws-after-Tag ( Layout ) > , < Equation ( Equation ) > ] ) ] , [ CondEquation , implies , appl ( prod ( [ cf ( sort ( "Tag" ) ) , cf ( opt ( layout ) ) , cf ( sort ( "Conditions" ) ) , cf ( opt ( layout ) ) , cf ( sort ( "Implies" ) ) , cf ( opt ( layout ) ) , cf ( sort ( "Equation" ) ) ] , cf ( sort ( "CondEquation" ) ) , no-attrs ) , [ < Tag ( Tag ) > , < ws-after-Tag ( Layout ) > , < Conditions ( Conditions ) > , < ws-after-Conditions ( Layout ) > , < Implies ( Implies ) > , < ws-after-Implies ( Layout ) > , < Equation ( Equation ) > ] ) ] , [ CondEquation , when , appl ( prod ( [ cf ( sort ( "Tag" ) ) , cf ( opt ( layout ) ) , cf ( sort ( "Equation" ) ) , cf ( opt ( layout ) ) , lit ( "when" ) , cf ( opt ( layout ) ) , cf ( sort ( "Conditions" ) ) ] , cf ( sort ( "CondEquation" ) ) , no-attrs ) , [ < Tag ( Tag ) > , < ws-after-Tag ( Layout ) > , < Equation ( Equation ) > , < ws-after-Equation ( Layout ) > , lit ( "when" ) , < "ws-after-when" ( Layout ) > , < Conditions ( Conditions ) > ] ) ] , [ Tag , empty , appl ( prod ( [ lit ( "[" ) , cf ( opt ( layout ) ) , lit ( "]" ) ] , cf ( sort ( "Tag" ) ) , no-attrs ) , [ lit ( "[" ) , < "ws-after-[" ( Layout ) > , lit ( "]" ) ] ) ] , [ Tag , not-empty , appl ( prod ( [ lit ( "[" ) , cf ( opt ( layout ) ) , cf ( sort ( "TagId" ) ) , cf ( opt ( layout ) ) , lit ( "]" ) ] , cf ( sort ( "Tag" ) ) , no-attrs ) , [ lit ( "[" ) , < "ws-after-[" ( Layout ) > , < TagId ( TagId ) > , < ws-after-TagId ( Layout ) > , lit ( "]" ) ] ) ] , [ Tree , lexical-constructor , appl ( prod ( [ cf ( sort ( "Tree" ) ) , cf ( opt ( layout ) ) , lit ( "(" ) , cf ( opt ( layout ) ) , cf ( iter-star ( sort ( "CHAR" ) ) ) , cf ( opt ( layout ) ) , lit ( ")" ) ] , cf ( sort ( "Tree" ) ) , no-attrs ) , [ < name ( Tree ) > , < ws-after-name ( Layout ) > , lit ( "(" ) , < "ws-after-(" ( Layout ) > , appl ( list ( cf ( iter-star ( sort ( "CHAR" ) ) ) ) , < list ( CHAR-list ) > ) , < ws-after-list ( Layout ) > , lit ( ")" ) ] ) ] , [ CHAR-list , empty , [  ] ] , [ CHAR-list , single , [ < head ( CHAR ) > ] ] , [ CHAR-list , many , [ < head ( CHAR ) > , < ws-after-first ( Layout ) > , < [ tail ( CHAR-list ) ] > ] ] , [ Equation , Default , appl ( prod ( [ cf ( sort ( "Tree" ) ) , cf ( opt ( layout ) ) , lit ( "=" ) , cf ( opt ( layout ) ) , cf ( sort ( "Tree" ) ) ] , cf ( sort ( "Equation" ) ) , no-attrs ) , [ < lhs ( Tree ) > , < ws-after-lhs ( Layout ) > , lit ( "=" ) , < "ws-after-=" ( Layout ) > , < rhs ( Tree ) > ] ) ] , [ Condition , positive , appl ( prod ( [ cf ( sort ( "Tree" ) ) , cf ( opt ( layout ) ) , lit ( "=" ) , cf ( opt ( layout ) ) , cf ( sort ( "Tree" ) ) ] , cf ( sort ( "Condition" ) ) , no-attrs ) , [ < lhs ( Tree ) > , < ws-after-lhs ( Layout ) > , lit ( "=" ) , < "ws-after-=" ( Layout ) > , < rhs ( Tree ) > ] ) ] , [ Condition , negative , appl ( prod ( [ cf ( sort ( "Tree" ) ) , cf ( opt ( layout ) ) , lit ( "!=" ) , cf ( opt ( layout ) ) , cf ( sort ( "Tree" ) ) ] , cf ( sort ( "Condition" ) ) , no-attrs ) , [ < lhs ( Tree ) > , < ws-after-lhs ( Layout ) > , lit ( "!=" ) , < ws-after-unequal ( Layout ) > , < rhs ( Tree ) > ] ) ] , [ Tree , ambiguity-constructor , appl ( prod ( [ lit ( "amb" ) , cf ( opt ( layout ) ) , lit ( "(" ) , cf ( opt ( layout ) ) , cf ( iter-star-sep ( sort ( "Tree" ) , lit ( "," ) ) ) , cf ( opt ( layout ) ) , lit ( ")" ) ] , cf ( sort ( "Tree" ) ) , no-attrs ) , [ lit ( "amb" ) , < "ws-after-amb" ( Layout ) > , lit ( "(" ) , < "ws-after-(" ( Layout ) > , appl ( list ( cf ( iter-star-sep ( sort ( "Tree" ) , lit ( "," ) ) ) ) , < ambs ( Tree-ambs ) > ) , < ws-after-ambs ( Layout ) > , lit ( ")" ) ] ) ] , [ Tree-ambs , empty , [  ] ] , [ Tree-ambs , single , [ < head ( Tree ) > ] ] , [ Tree-ambs , many , [ < head ( Tree ) > , < ws-after-first ( Layout ) > , lit ( < sep ( str ) > ) , < ws-after-sep ( Layout ) > , < [ tail ( Tree-ambs ) ] > ] ] , [ CHAR , lex-to-cf , appl ( prod ( [ lex ( sort ( "CHAR" ) ) ] , cf ( sort ( "CHAR" ) ) , no-attrs ) , [ < lex ( Lexical ) > ] ) ] , [ Start , Equations , parsetree ( appl ( prod ( [ cf ( opt ( layout ) ) , cf ( sort ( Equations ) ) , cf ( opt ( layout ) ) ] , sort ( "<START>" ) , no-attrs ) , [ < ws-before ( Layout ) > , < top-Equations ( Equations ) > , < ws-after ( Layout ) > ] ) , < amb-cnt ( int ) > ) ] ]