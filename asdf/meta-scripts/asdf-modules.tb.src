/* ActionSdf extension of the ASF+SDF Meta-Environment */
#include "Asdfsupport.idef"
#include "Typecheck.idef"

/* copy of Open-initial-module in open-modules.tb */
process ASDF is
let
  Path : str,
  Module : str,
  Modules : list,
  ModuleNames : list,
  Extension : str,
  RealModule : str,
  Imports : list,
  Status : term,
  ErrorMsg: str,
  Pid : int,
  Type : str, 
  EditorId : term,
  Id : int,
  ANModules : list,
  Whitespace : list,
  InitialModules : list
in
  Id := process-id .
  snd-msg(ts-add-table("asdf-text","str")) .
  snd-msg(ts-add-table("asdf-tree","term")) .
  snd-msg(ts-add-table("asdf-pt-text","str")) .
  snd-msg(ts-add-table("asdf-pt-tree","term")) .
  snd-msg(ts-add-table("asdf-parse-table","term")) .
  create(Open-ActionSdf-Language, Pid?) .
  create(ASDF-ModuleDB, Pid?) .
  create(ASDF-Support, Pid?) .
  create(ActionSdf-hooks, Pid?) .
  create(Obtain-ParseTable-hooks, Pid?) .
  create(ASDFButtons, Pid?) .
  rec-msg(post-initialization-hook) .
  Open-Initial-Module("__ASF_LIBRARY__","basic/Whitespace") .
  snd-msg(ts-get-all-values("sdf-tree")) .
  rec-msg(ts-all-values(Whitespace?)) .
  Open-Initial-Module("__ASDF_PT__","asdf/an") .
  snd-msg(ts-get-all-values("sdf-tree")) .
  rec-msg(ts-all-values(ANModules?)) .
  Open-Initial-Module("__ASDF_PT__","asdf/asdf") .
  Open-Initial-Module("__ASF_LIBRARY__","languages/asf/syntax/Equations") .
  snd-msg(ts-get-all-values("sdf-tree")) .
  rec-msg(ts-all-values(InitialModules?)) .
  snd-msg(ts-clear-table("import-relations")) .
  DrawImportGraph() .
  snd-msg(post-initialization-hook-finished) .
  (
    rec-msg(edit-asdf(Module?)) .
    ASDFEditorCreator(Module)
  + 
    rec-msg(gen-asfsdf(Module?)) .
    GenerateASFSDF(Module, Status?) .
    if equal(Status, success) then
      tau
    else
      ErrorMsg := first(args(Status)) .
      snd-note(ui-status(error(ErrorMsg)))
    fi
  +
    rec-msg(gen-asdf-pt(Module?)) .
    GenerateASDF-PT(Module, Status?) .
    if equal(Status, success) then
      tau
    else
      ErrorMsg := first(args(Status)) .
      snd-note(ui-status(error(ErrorMsg)))
    fi
  +
    rec-msg(revert-asdf-module(Module?)) .
    snd-note(ui-status(statf(Id, "Reverting %s",[Module]))).
    DoRevertActionSdfModule(Module) .
    snd-note(ui-status(endstat(Id))) .
    snd-msg(asdf-module-reverted(Module))
  +
    rec-msg(generate-asfsdf-for-modules(Modules?)) .
    Status := success .
    (
      if not-equal(Modules, []) then
         Module := first(Modules) .
         Modules := next(Modules) .
         GenerateASFSDF(Module, Status?)
      fi
    )*
    if or(equal(Modules, []), not-equal(Status, success))  then
      tau
    fi .
    if equal(Status, success) then
      snd-msg(asfsdf-generated)
    else
      ErrorMsg := first(args(Status)) .
      snd-msg(asfsdf-not-generated(ErrorMsg)) 
    fi
  +
    rec-msg(generate-asdf-pt-for-modules(Modules?)) .
    Status := success .
    (
      if not-equal(Modules, []) then
         Module := first(Modules) .
         Modules := next(Modules) .
         GenerateASDF-PT(Module, Status?)
      fi
    )*
    if or(equal(Modules, []), not-equal(Status, success))  then
      tau
    fi .
    if equal(Status, success) then
      snd-msg(asdf-pt-generated)
    else
      ErrorMsg := first(args(Status)) .
      snd-msg(asdf-pt-not-generated(ErrorMsg)) 
    fi
  +
    rec-msg(notify-about-changed-modules(Modules?, asdf)) .
    if not-equal(Modules,[]) then
      Module := first(Modules) .
printf("Module = %s\n", Module).
      Modules := next(Modules) .
      snd-msg(ts-remove-value("asf-tree", Module)) 
    fi *
    if equal(Modules,[]) then
      snd-msg(notify-about-changed-modules-done)
    fi
  +
    rec-msg(save-asfsdf-text(Module?)) .
    SaveASFSDF(Module) .
    snd-msg(asfsdf-text-saved)
  +
    rec-msg(add-initial-syntax-modules-hook(Modules?, asdf)) .
DebugTS("SDF Trees", "sdf-tree") .
    Modules := join(Modules, InitialModules) .
    snd-msg(initial-modules-added(Modules)) 
  +
    rec-msg(add-initial-syntax-modules-hook(Modules?, eqs)) .
DebugTS("SDF Trees", "sdf-tree") .
    Modules := join(Modules, ANModules) .
    snd-msg(initial-modules-added(Modules)) 
  +
    rec-msg(add-initial-syntax-modules-hook(Modules?, trm)) .
DebugTS("SDF Trees", "sdf-tree") .
    Modules := join(Modules, Whitespace) .
    snd-msg(initial-modules-added(Modules)) 
  + 
    rec-msg(add-initial-eqs-module-names-hook(ModuleNames?)) .
    ModuleNames := join(ModuleNames, ["asdf/an","basic/Whitespace"]).
    snd-msg(initial-eqs-module-names-added(ModuleNames)) 
  ) * 
  delta
endlet



/* copy of Open-Sdf2-Language in open-modules.tb */
process Open-ActionSdf-Language is
let
  Table : term,
  Message : str
in
  (
    rec-msg(open-language(asdf)) .
    snd-msg(io-read-term-file("__ASDF_PT__asdf/all.trm.tbl")) .
    (
      rec-msg(io-file-contents(Table?)) .
      snd-msg(parse-table(trm("ASDF"), Table))
    +
      rec-msg(io-error-reading(Message?)) .
      snd-msg(no-parse-table)
    )
  ) *
    delta
endlet

process ASDF-ModuleDB is
let
  Path      : str,
  Table     : term,
  ModuleId  : str,
  Syntax    : term,
  OldSyntaxTree : term,
  SyntaxTree: term,
  SyntaxText: str,
  LocalText : str,
  EqsTree   : term,
  EqsText   : str,
  Name      : str,
  OldName   : str,
  NewName   : str,
  Modules   : list,
  DependingModules : list,
  ModuleNames : list,
  FileName : str,
  Pairs    : list
in
(
    rec-msg(add-module-to-db(Name?, Path?, asdf, SyntaxText?, SyntaxTree?)).
    if and(not-equal(SyntaxTree, error-tree),
	   not-equal(SyntaxTree, no-tree)) then
      snd-msg(asdf-get-module-id(SyntaxTree)) .
      rec-msg(asdf-module-id(ModuleId?)) .
      snd-msg(sm-get-module-path(Path, ModuleId)) .
      rec-msg(sm-module-path(Path?)) .
      snd-msg(ts-put-str-value("module-paths", ModuleId, Path)) .
      snd-msg(ts-put-term-value("asdf-tree", ModuleId, SyntaxTree)) .
      snd-msg(asdf-get-imported-module-names(SyntaxTree)) .
      rec-msg(asdf-imported-module-names(Modules?)) .
/* MDB-ActionSdf-AddModulePosInfo(ModuleId, SyntaxTree, SyntaxTree?) .*/
      SyntaxTree := no-tree 
    else 
      ModuleId := Name .
      snd-msg(ts-put-str-value("module-paths", ModuleId, Path)) .
      Modules := []
    fi .
    snd-msg(ts-put-term-value("import-relations", ModuleId, Modules)) .
    snd-msg(ts-put-str-value("active-modules", ModuleId, Path)) .
    snd-msg(ts-put-str-value("asdf-text", ModuleId, SyntaxText)) .
    SyntaxText := "" .
    snd-msg(ts-filter-keys("active-modules", Modules)) .
    rec-msg(ts-keys(Modules?)) .
    snd-msg(adding-succeeded(Name, ModuleId, Path, Modules))
  +
    rec-msg(update-module-in-db(Name?, SyntaxTree?, asdf)).
    snd-msg(asdf-get-module-id(SyntaxTree)) .
    rec-msg(asdf-module-id(ModuleId?)) .
    if equal(Name, ModuleId) then
      /* MDB-AddModulePosInfo(ModuleId, SyntaxTree, SyntaxTree?) .*/
      snd-msg(ts-put-term-value("asdf-tree", Name, SyntaxTree)) .
      RemoveGeneratedValues(Name) .
      snd-msg(asdf-get-imported-module-names(SyntaxTree)) .
      SyntaxTree := no-tree .
      rec-msg(asdf-imported-module-names(Modules?)) .
      snd-msg(ts-put-term-value("import-relations", ModuleId, Modules)) .
      snd-msg(ts-filter-keys("active-modules", Modules)) .
      rec-msg(ts-keys(Modules?)) .
      snd-msg(updating-succeeded(Modules))
    else
      snd-msg(error-opening(Name, name-inconsistent))
    fi
  +
    rec-msg(update-module-text-in-db(Name?, SyntaxText?, SyntaxTree?, asdf)).
    if equal(SyntaxTree, no-tree) then
      ModuleId := Name
    else
      snd-msg(asdf-get-module-id(SyntaxTree)) .
      rec-msg(asdf-module-id(ModuleId?))
    fi .    
    if equal(Name, ModuleId) then
      snd-msg(ts-get-str-value("asdf-text", Name)) .
      rec-msg(ts-value(LocalText?)) .
      if equal(SyntaxText, LocalText) then
        SyntaxText := "" .
        snd-msg(no-updating-needed)
      else
        snd-msg(ts-put-str-value("asdf-text", Name, SyntaxText)) .
        snd-msg(ts-remove-value("asdf-tree", Name)) .
        snd-msg(ts-put-term-value("import-relations", Name, [])) .
        SyntaxText := "" .
        MDB-GetAllDependingModules(Name, DependingModules?) .
        MDB-InvalidateModule(Name, asdf) .
        MDB-InvalidateModules(DependingModules, asdf) .
        snd-msg(updating-succeeded(DependingModules))
      fi
    else
      snd-msg(error-opening(Name, name-inconsistent))
    fi
  +
    rec-msg(invalidate-asdf-in-db(Name)).
    snd-msg(ts-remove-value("asdf-tree", Name)) .
    snd-msg(ts-remove-value("asdf-parse-table", Name)) .
    snd-msg(ts-remove-value("asdf-pt-text", Name)) .
    snd-msg(ts-remove-value("asdf-pt-tree", Name)) 
  + 
    rec-msg(get-table-from-db(Name?, asdf)) .
    snd-msg(ts-get-term-value("asdf-parse-table", Name)).
    (
      rec-msg(ts-value(Table?)) .
      snd-msg(table(Table)) 
    +
      rec-msg(ts-no-value) .
      snd-msg(no-table)
    )
  +
    rec-msg(add-parse-table-to-db(Name?, asdf, Table?)) .
    /* Do nothing because this is second parse of ActionSdf module */
    snd-msg(parse-table-added)
  +
    rec-msg(clear-module-db-hook) .
    snd-msg(ts-clear-table("asdf-text")) .
    snd-msg(ts-clear-table("asdf-tree")) .
    snd-msg(ts-clear-table("asdf-pt-text")) .
    snd-msg(ts-clear-table("asdf-pt-tree")) .
    snd-msg(ts-clear-table("asdf-parse-table")) .
    snd-msg(module-db-hook-done) 
) * delta
endlet

process ASDF-Support is
let
 Module : term,
 ModuleName : str,
 ModuleNames : term,
 Imports : list,
 Tree : term,
 Str : str
in
  (
    rec-msg(asdf-get-module-id(Module?)) .
    snd-msg(apply-rewrite("Asdfsupport", "getModuleName", "ModuleName", [Module])).
    rec-msg(normalform("Asdfsupport", Tree?)).
    snd-msg(unparse(Tree)) .
    rec-msg(unparsed-text(ModuleName?)) .
    snd-msg(asdf-module-id(ModuleName)) 
  +
    rec-msg(asdf-get-imported-module-names(Module?)) .
    snd-msg(apply-rewrite("Asdfsupport", "getImportedModules", "ATermList", [Module])).
    rec-msg(normalform("Asdfsupport", Tree?)).
    snd-msg(unparse(Tree)) .
    rec-msg(unparsed-text(ModuleName?)) .
    snd-msg(io-write-text-file("foo", [ModuleName])) .
    rec-msg(io-file-written) .
    snd-msg(io-read-packed-term-file("foo")) .
    rec-msg(io-file-contents(ModuleNames?)) .
    Imports := ModuleNames .
    snd-msg(asdf-imported-module-names(Imports))
  ) * delta
endlet

process MDB-ActionSdf-AddModulePosInfo(Module : str, In : term , Out : term?) is
let
  Path : str,
  FileName : str
in
  snd-msg(ts-get-str-value("module-paths", Module)) .
  rec-msg(ts-value(Path?)) .
  snd-msg(io-get-filename(Path, Module, ".asdf")) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(add-posinfo-packed(FileName, In)) .
  rec-msg(tree-with-pos-info(Out?)) 
endlet


process ASDFEditorCreator (ModuleName : str) is
let
  Tree : term,
  Text : str,
  FileName : str,
  Message : str,
  Path : str
in
  Tree := none.
  Text := "".
  snd-msg(get-path-from-db(ModuleName)) .
  rec-msg(path(Path?)) .
  snd-msg(io-get-filename(Path, ModuleName, ".asdf")) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(ts-get-term-value("asdf-tree", ModuleName)) .
  (
    rec-msg(ts-value(Tree?))
  +
    rec-msg(ts-no-value) .
    snd-msg(io-read-file(FileName)) .
    (
      rec-msg(io-file-contents(Text?))
    +
      rec-msg(io-error-reading(Message?))
    )
  ) .
  CreateEditor(syntax-editor,ModuleName,FileName,Text,Tree)
endlet

process RecursiveGenASFSDF(Module : str) is
let
  Modules : list,
  ErrorMsg : str
in
    MDB-GetAllImportedModuleNames(Module, Modules?) .
    snd-msg(generate-asfsdf-for-modules(Modules)) 
endlet

process GenerateASFSDF(Module : str, Result : term?) is
let
   ModuleText : str,
   GenModuleText : str,
   GenModuleTree : term,
   ModuleTree : term
in
  snd-msg(ts-get-str-value("sdf-text", Module)) .
  (  /* ASF+SDF already generated, don't regenerate */
     rec-msg(ts-value(ModuleText?)) .
     Result := success 
   +
     rec-msg(ts-no-value) .
     snd-msg(ts-get-term-value("asdf-tree", Module)) .
     (
        rec-msg(ts-value(ModuleTree?)) .
        snd-msg(apply-rewrite("Asdfsupport", "asdf2sdf", "Module", [ModuleTree])).
        rec-msg(normalform("Asdfsupport", GenModuleTree?)).
        snd-msg(ts-put-term-value("sdf-tree", Module, GenModuleTree)) .
        snd-msg(unparse(GenModuleTree)) .
        rec-msg(unparsed-text(GenModuleText?)) .
     	snd-msg(ts-put-str-value("sdf-text", Module, GenModuleText)) .
        snd-msg(apply-rewrite("Asdfsupport", "asdf2asf", "ASFEquations", [ModuleTree])).
        rec-msg(normalform("Asdfsupport", GenModuleTree?)).
        snd-msg(unparse(GenModuleTree)) .
        rec-msg(unparsed-text(GenModuleText?)) .
printf("ModuleName = %s gives ASF = %s\n", Module, GenModuleText) .
        snd-msg(ts-put-str-value("asf-text", Module, GenModuleText)) .
        Result := success
     +
        rec-msg(ts-no-value) .
        Result := quote(failed("No ASDF tree"))
     )
  )
endlet

process GenerateASDF-PT(Module : str, Result : term?) is
let
   ModuleText : str,
   GenModuleText : str,
   GenModuleTree : term,
   ModuleTree : term
in
  snd-msg(ts-get-str-value("asdf-pt-text", Module)) .
  (  /* ASDF parsetable already generated, don't regenerate */
     rec-msg(ts-value(ModuleText?)) .
     Result := success 
   +
     rec-msg(ts-no-value) .
     snd-msg(ts-get-term-value("asdf-tree", Module)) .
     (
       rec-msg(ts-value(ModuleTree?)) .
       snd-msg(apply-rewrite("Asdfsupport", "$asdf2asdf-pt", "Module", [ModuleTree])).
       rec-msg(normalform("Asdfsupport", GenModuleTree?)).
       snd-msg(ts-put-term-value("asdf-pt-tree", Module, GenModuleTree)) .
       snd-msg(unparse(GenModuleTree)) .
       rec-msg(unparsed-text(GenModuleText?)) .
       snd-msg(ts-put-str-value("asdf-pt-text", Module, GenModuleText)) .
       Result := success
     +
       rec-msg(ts-no-value) .
       Result := quote(failed("No ActionSDF tree"))
     )
  )
endlet

/* Copy of KillModuleEditor from editors.tb */
process KillActionSdfEditor(EditorId : term, ModuleName : str) is
let
  ModifiedStatus : term
in
  snd-msg(get-modified-status(EditorId)) .
  rec-msg(modified-status(EditorId, ModifiedStatus?)) .
  if equal(ModifiedStatus, modified) then
    snd-msg(gen-asfsdf(ModuleName)) .       
    DoRevertActionSdfModule(ModuleName) .
    snd-note(ui-status(errorf("ASF+SDF is regenerated for dirty module %s",
                       [ModuleName]))).
    MDB-DisplayGraph
  else
    tau
  fi
endlet

/* Copy of DoRevertModule from module-utils.tb */
process DoRevertActionSdfModule(ModuleName : str) is
  HardCloseModuleInDB(ModuleName).
  snd-msg(open-modules([ModuleName], asdf)) .
  rec-msg(finished-opening-modules)

process ActionSdf-hooks is
let
  Type : str, 
  EditorId : term,
  Module : str,
  Pid : int,
  Syntax : term,
  Checking : term
in
  create(ActionSdf-hooks2, Pid?) .
  (
    rec-msg(file-extension-hook(asdf)).
    snd-msg(file-extension-hook-result(".asdf"))
  +
    rec-msg(extension-to-type-hook(".asdf")).
    snd-msg(extension-to-type-hook-result(asdf))
  +
    rec-msg(syntax-top-sort-hook(asdf)) .
    snd-msg(syntax-top-sort-hook-result(sort("AS-Module")))
  + 
    rec-msg(other-top-sort-hook(asdf)) .
    snd-msg(other-top-sort-hook-result(sort("ASDFModule")))
  + 
    rec-msg(other-top-sort-hook(asdf1)) .
    snd-msg(other-top-sort-hook-result(sort("AS-Module")))
  +
    rec-msg(get-module-id-hook(asdf)) .
    snd-msg(get-module-id-hook-result("asdf/asdf")) 
  +
    rec-msg(invalidate-other-tables-hook(Module?, asdf)) .
    RemoveGeneratedValues(Module) .
    snd-msg(other-tables-invalidated-hook)
  + 
    rec-msg(preprocess-syntax-hook(Module?, asdf, Checking?, Syntax?)).
    snd-msg(preprocess-syntax-hook-result(Module, Syntax)) 
   )* delta
endlet

/* Because KillActionSdfEditor uses other hooks */
process ActionSdf-hooks2 is
let
  Type : str, 
  EditorId : term,
  Module : str,
  ModuleNames : list,
  ErrorMsg : str,
  Table : term,
  TermType : term,
  Checking : term
in
  (
    rec-msg(kill-editor-unknown-type-hook(EditorId?, Type?, Module?)).
    KillActionSdfEditor(EditorId, Module) .
    snd-msg(kill-editor-unknown-type-hook-result)
  +
    rec-msg(pre-get-all-syntax-hook(ModuleNames?, asdf)) .
    snd-msg(generate-asdf-pt-for-modules(ModuleNames)) .
    (
       rec-msg(asdf-pt-generated) .
       snd-msg(pre-get-all-syntax-hook-result(tablename("asdf-pt-tree")))
    +
       rec-msg(asdf-pt-not-generated(ErrorMsg?)) .
       snd-msg(pre-get-all-syntax-hook-result(failure(ErrorMsg)))       
    )
   )* delta
endlet

process Obtain-ParseTable-hooks is
let
  Module : str,
  Table : term,
  TermType : term,
  Checking : term
in
  (
    rec-msg(obtain-parse-table-hook(asdf1, Module?, Checking?)) .
    snd-msg(open-language(asdf)) .
    (
      rec-msg(parse-table(TermType?, Table?))
    +
      rec-msg(no-parse-table) .
      Table := no-table
    ).
    snd-msg(obtain-parse-table-hook-result(Table))
  + 
    rec-msg(obtain-parse-table-hook(asdf, Module?, Checking?)) .
    snd-msg(get-parsetable(Module, asdf, Checking)) .
    (
      rec-msg(parse-table(Table?))
    +
      rec-msg(no-parse-table(Module?)) .
      Table := no-table
    ).
    snd-msg(obtain-parse-table-hook-result(Table)) 
   )* delta
endlet

process RemoveGeneratedValues(Module : str)  is
  snd-msg(ts-remove-value("sdf-tree", Module)) .
  snd-msg(ts-remove-value("sdf-text", Module)) .
  snd-msg(ts-remove-value("asf-text", Module)) .
  snd-msg(ts-remove-value("asf-tree", Module)) .
  snd-msg(ts-remove-value("asdf-pt-text", Module)) .
  snd-msg(ts-remove-value("asdf-pt-tree", Module)) .
  snd-msg(ts-remove-value("asdf-parse-table", Module)) 


process SaveASFSDF(Module : str) is
let
   ModuleNames	: list,
   ModuleName	: str,
   Status	: term,
   ErrorMsg	: str,
   Text		: str,
   FileName	: str,
   Path		: str,
   Extension	: str
in 
   snd-msg(get-all-imported-module-names(Module)).
   rec-msg(all-imported-module-names(ModuleNames?)).
   ( if not-equal(ModuleNames, []) then
       ModuleName := first(ModuleNames) .
       ModuleNames := next(ModuleNames) .
       GenerateASFSDF(ModuleName, Status?) .
       if equal(Status, success) then
         snd-msg(get-path-from-db(ModuleName)) .
         rec-msg(path(Path?)) .
	 SaveFromDB(ModuleName, Path, "sdf-text", sdf) .
	 SaveFromDB(ModuleName, Path, "asf-text", asf) 
       else
         ErrorMsg := first(args(Status)) .
         snd-note(ui-status(error(ErrorMsg)))
       fi
     fi
   ) *
   if equal(ModuleNames, []) then
     tau
   fi
endlet

process SaveFromDB(Module : str, Path : str, Table : str, Type : term) is
let
   Extension : str,
   Text	     : str,
   FileName  : str,
   ErrorMessage	: str
in   
   snd-msg(ts-get-str-value(Table, Module)) .
   rec-msg(ts-value(Text?)) .
   snd-msg(file-extension-hook(Type)) .
   rec-msg(file-extension-hook-result(Extension?)) .
   snd-msg(io-get-filename(Path, Module, Extension)) .
   rec-msg(io-filename(FileName?)) .
   snd-msg(io-write-text-file(FileName,[Text])) .
   (
     rec-msg(io-file-written) 
   +
     rec-msg(io-file-not-written(ErrorMessage?)) .
     snd-note(ui-status(errorf("%s: %s",[FileName, ErrorMessage])))
   )
endlet

process DebugTS(Mesg : str, Table : str) is
let
   Keys : list
in
   snd-msg(ts-get-all-keys(Table)) .
   rec-msg(ts-all-keys(Keys?)) 
endlet

process Open-Initial-Module(Path : str, InitModule : str) is 
let
  Imports : list,
  Modules : list,
  Module : str,
  Id : int,
  LibPath : str,
  Directories : list
in 
  Id := process-id.
  snd-note(ui-status(stat(Id,"Initializing"))). 
  Modules := [InitModule].
  snd-msg(library-location-hook).
  rec-msg(library-location-hook-result(LibPath?)) .
  if not-equal(Modules, []) then
    Module := first(Modules).
    Modules := next(Modules).
    snd-msg(is-module-in-db(Module)).
    (
      rec-msg(exists-in-module-db(Module))
    +
      rec-msg(not-exists-in-module-db(Module)).
      /* Necessary if module uses library module */
      snd-msg(io-find-file([Path], Module, ".sdf")) .
      (
        rec-msg(io-file-not-found) .
printf("Opening Module (%s,%s)\n", LibPath, Module).
        Open-Module(LibPath, Module, sdf, Imports?).
        Modules := join(Imports, Modules)
      +
        rec-msg(io-file-found(Directories?)) .
printf("Opening Module (%s,%s)\n", Path, Module).
        Open-Module(Path, Module, sdf, Imports?).
        Modules := join(Imports, Modules)
      )
    )
  fi *
  if equal(Modules, []) then
    snd-note(ui-status(endstat(Id))) 
  fi
endlet

process ASDFButtons is
let
  ModuleName : str,
  Stack : list,
  EditorId : term,
  EditorId2 : term,
  InStr : str,
  Path : str,
  Ext : str
in
(
  rec-msg(asdf-parse-action, Stack?, EditorId?) .
  StackPopString(Stack,Stack?,ModuleName?) .
  RecursiveGenASFSDF(ModuleName) .
  (
    rec-msg(asfsdf-generated) .
    ParseTerm(EditorId, ModuleName) 
  +
    rec-msg(asfsdf-not-generated(InStr?)) .
    snd-note(ui-status(error(InStr)))
  ) .
  ReturnSuccess(EditorId,Stack)
+
  rec-msg(edit-asdf, Stack?, EditorId?) .
  StackPopString(Stack,Stack?,ModuleName?) .
  snd-msg(edit-asdf(ModuleName)) .
  rec-msg(editor-opened(ModuleName,EditorId2?)) .
  ReturnSuccess(EditorId, Stack)
+
  rec-msg(open-asdf-module, Stack?, EditorId?) .
  StackPopString(Stack, Stack?, Ext?) .
  StackPopString(Stack, Stack?, Path?) .
  StackPopString(Stack, Stack?, ModuleName?) .
  snd-msg(open-initial-module(Path, ModuleName, Ext)) .
  ReturnSuccess(EditorId, Stack)	
+
  rec-msg(revert-asdf-module, Stack?, EditorId?) .
  StackPopString(Stack, Stack?, ModuleName?) .
  snd-msg(revert-asdf-module(ModuleName)) .
  rec-msg(asdf-module-reverted(ModuleName)) .
  ReturnSuccess(EditorId, Stack)	
+
  rec-msg(new-asdf-module, Stack?, EditorId?) .
  StackPopString(Stack, Stack?, Ext?) .
  StackPopString(Stack, Stack?, Path?) .
  StackPopString(Stack, Stack?, ModuleName?) .
  snd-msg(create-new-module(Path, ModuleName, asdf)) . 
  rec-msg(new-module-created(Path?, ModuleName?)) .
  ReturnSuccess(EditorId, Stack)	
+
  rec-msg(generate-asfsdf, Stack?, EditorId?) .
  StackPopString(Stack, Stack?, ModuleName?) .    
  snd-msg(gen-asfsdf(ModuleName)).
  ReturnSuccess(EditorId, Stack)
+
  rec-msg(generate-asdf-pt, Stack?, EditorId?) .
  StackPopString(Stack, Stack?, ModuleName?) .    
  snd-msg(gen-asdf-pt(ModuleName)).
  ReturnSuccess(EditorId, Stack)
+
  rec-msg(parse-asdf-action, Stack?, EditorId?).
  StackPopString(Stack,Stack?,ModuleName?) .
  ParseActionSdf(EditorId, ModuleName, asdf) .
  ReturnSuccess(EditorId,Stack)
+
  rec-msg(create-asdf-module, Stack?, EditorId?) .
  StackPopString(Stack, Stack?, ModuleName?) .
  snd-msg(io-relative-to-absolute(["."])) .
  rec-msg(io-absolute-directories([Path?])) .
  snd-msg(create-new-module(Path, ModuleName, asdf)) .           
  ReturnSuccess(EditorId, Stack)	
+
  rec-msg(save-asfsdf-text, Stack?, EditorId?) .
  StackPopString(Stack,Stack?,ModuleName?) .
  snd-msg(save-asfsdf-text(ModuleName)) .
  rec-msg(asfsdf-text-saved) .
  snd-note(ui-status(errorf("Saving ASF+SDF done"))) .        
  ReturnSuccess(EditorId, Stack)			
+
  rec-msg(type-check-asdf, Stack?, EditorId?) .
  StackPopString(Stack, Stack?, ModuleName?) .
  TypeCheckModule(ModuleName).
  ReturnSuccess(EditorId, Stack)
) * delta
endlet

process ParseActionSdf(EditorId : term, ModuleName : str, Type : term) is
let
  Tree             : term,
  Text             : str,
  Focus            : term,
  NewModules       : list,
  DependingModules : list,
  ModuleId	   : str,
  Modules          : list
in
  InvalidateEditor(EditorId).
  snd-msg(get-module-id-hook(Type)) .
  rec-msg(get-module-id-hook-result(ModuleId?)) .
  snd-msg(notify-about-changed-modules([ModuleName], Type)) .
  rec-msg(notify-about-changed-modules-done) .
  snd-msg(parse-focusses(EditorId, ModuleId, asdf1)) .
  (
    rec-msg(parse-ok(ModuleId)) .
    snd-msg(se-get-tree(EditorId)) .
    (
      rec-msg(se-tree(Tree?)) .
      snd-msg(unparse(Tree)) .
      rec-msg(unparsed-text(Text?)) .
      snd-msg(update-module-text-in-db(ModuleName, Text, Tree, Type)) .
      (
	rec-msg(no-updating-needed).
	SecondParse(EditorId, ModuleName)
      +
        rec-msg(updating-succeeded(DependingModules?)).
        snd-msg(update-module-in-db(ModuleName, Tree, Type)) .
	(
          rec-msg(updating-succeeded(NewModules?)).
	  snd-msg(notify-about-changed-modules(DependingModules, Type)) .
	  rec-msg(notify-about-changed-modules-done) .
          snd-msg(open-modules(NewModules, Type)).
          rec-msg(finished-opening-modules) .
          snd-note(te-clear-focus(EditorId)). 
  	  SecondParse(EditorId, ModuleName)
        +
          rec-msg(error-opening(ModuleName, name-inconsistent)).
          snd-msg(invalidate-sdf-in-db(ModuleName)).
          InvalidateEditor(EditorId).
          snd-note(ui-status(
            errorf("Changing the name of %s is not permitted.",[ModuleName])))
        )
      +
        rec-msg(error-opening(ModuleName, name-inconsistent)).
        snd-msg(invalidate-sdf-in-db(ModuleName)).
        InvalidateEditor(EditorId).
        snd-note(ui-status(
            errorf("Changing the name of %s is not permitted.",[ModuleName])))
      )
    +
      rec-msg(se-no-tree) /* editor dissappeared */
    )
  +
    rec-msg(parse-failed(ModuleId, Focus?)) .
    snd-msg(invalidate-sdf-in-db(ModuleName))
  ) 
endlet

process SecondParse(EditorId : term, ModuleName : str) is
let
   Focus : term,
   Tree : term
in
    InvalidateEditor(EditorId) .
    snd-msg(parse-focusses(EditorId, ModuleName, asdf)) .
    (
      rec-msg(parse-ok(ModuleName)) .
      snd-msg(se-get-tree(EditorId)) .
      (
	rec-msg(se-tree(Tree?)) .
	snd-note(te-clear-focus(EditorId))
      +
	rec-msg(se-no-tree)
      )
    +
      rec-msg(parse-failed(ModuleName, Focus?)).
      snd-msg(invalidate-sdf-in-db(ModuleName)).
      snd-msg(invalidate-asdf-in-db(ModuleName))
    )
endlet

process TypeCheckModule(ModuleName : str) is
let
   ModuleNames : list,
   ImModuleTrees : list,
   ImModuleTree : term,
   ModuleTree : term,
   ModuleText : str,
   Signatures : term,
   AllSignatures : term, 
   SignatureText : str,
   ErrorTree : term,
   ErrorText : str
in
   /* get definition of signatures etc. in imported modules */
   snd-msg(get-all-imported-module-names(ModuleName)) .
   rec-msg(all-imported-module-names(ModuleNames?)) .
   snd-msg(ts-get-values("asdf-tree", ModuleNames)) .
   (
     rec-msg(ts-values(ImModuleTrees?)) 
   + 
     rec-msg(ts-no-values) .
     ImModuleTrees := []    
   ) .
   ImModuleTree := first(ImModuleTrees) .
   ImModuleTrees := next(ImModuleTrees) .
   snd-msg(apply-rewrite("Asdfsupport", "get-signatures", 
                         "Signatures", [ImModuleTree])) .
   rec-msg(normalform("Asdfsupport", AllSignatures?)) .
   (
     if not-equal(ImModuleTrees, []) then
       ImModuleTree := first(ImModuleTrees) .
       ImModuleTrees := next(ImModuleTrees) .
       snd-msg(apply-rewrite("Asdfsupport", "get-signatures", 
	 		    "Signatures", [ImModuleTree])) .
       rec-msg(normalform("Asdfsupport", Signatures?)) .
       snd-msg(apply-rewrite("Asdfsupport", "join-signatures", 
	 		    "Signatures", [AllSignatures, Signatures])) .
       rec-msg(normalform("Asdfsupport", AllSignatures?)) 
     fi
   )*
   if equal(ImModuleTrees, []) then
     tau
   fi .
   /* typecheck with signatures */
   snd-msg(io-unpack-term(AllSignatures)) .
   rec-msg(io-term(AllSignatures?)).
   snd-msg(ts-get-term-value("asdf-tree",ModuleName)) .
   rec-msg(ts-value(ModuleTree?)) .
   snd-msg(io-unpack-term(ModuleTree)) .
   rec-msg(io-term(ModuleTree?)).
   snd-msg(io-write-packed-term-file("module", ModuleTree)) .
   rec-msg(io-file-written) .
   snd-msg(io-write-packed-term-file("signatures", AllSignatures)) .
   rec-msg(io-file-written) .
/*   snd-msg(apply-rewrite("Typecheck", "typecheck", 
	 		"Summary", [ModuleTree, AllSignatures])).
   rec-msg(normalform("Typecheck", ErrorTree?)).*/
   snd-msg(gen-adapter-term-evaluate(asdf-typecheck-id,"__ASDF_BIN__/typecheck", hest)).
   rec-msg(gen-adapter-term-result(asdf-typecheck-id, ErrorTree?)).
/*   snd-msg(unparse(ErrorTree)) .
   rec-msg(unparsed-text(ErrorText?)) .
   snd-msg(io-write-text-file("foo", [ErrorText])) .
   rec-msg(io-file-written) .
   snd-msg(io-read-packed-term-file("foo")) .
   rec-msg(io-file-contents(ErrorTree?)) .*/
printf("ErrorTree = %t\n", ErrorTree).
   snd-note(show-feedback-summary(ErrorTree))
endlet

