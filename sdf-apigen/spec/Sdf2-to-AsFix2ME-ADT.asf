equations

[equ-sdf-to-adt-cons-expand]
  sdf-to-asfix2me-adt-cons-expand($SDF) = 
    sdf-to-asfix2me-adt($SDF, cons-expand)

[equ-sdf-to-adt-cons-remove]
  sdf-to-asfix2me-adt-cons-remove($SDF) = 
    sdf-to-asfix2me-adt($SDF, cons-remove)

[equ-sdf-to-adt-definition-empty]
  sdf-to-asfix2me-adt(definition ,$ConsOption) = [ ]

[equ-sdf-to-adt-defintion-divide]
  $ADT1 := sdf-module-to-asfix2me-adt($Module, $ConsOption),
  $ADT2 := merge-adts([], $ADT1),
  $ADT3 := sdf-to-asfix2me-adt(definition $Module*, $ConsOption),
  $ADT4 := merge-adts($ADT2, $ADT3),
  $ADT5 := start-sorts-to-asfix2me-adt($Module),
  $ADT6 := merge-adts($ADT4, $ADT5),
  $ADT7 := merge-adts($ADT6, [ constructor(OptLayout, Absent, appl(prod([],cf(opt(layout)),no-attrs),[])),
     constructor(OptLayout, Present, appl(prod([cf(layout)],cf(opt(layout)),no-attrs),
                          <chars(CHARLIST)>))
   ])
  ===>
  sdf-to-asfix2me-adt(definition $Module $Module*, $ConsOption) = $ADT7




[equ-sdf-to-adt-module]
  sdf-to-asfix2me-adt($Module, $ConsOption) = 
    sdf-module-to-asfix2me-adt($Module, $ConsOption)

[equ-sdf-module-to-adt-empty]
  sdf-module-to-asfix2me-adt(module $ModName $ImpSection*, $ConsOption) = [ ]

[equ-sdf-module-to-adt-divide]
  $Entries1 := section-to-adt($ModName, $Section, $ConsOption),
  [ $Entries2 ] := sdf-module-to-asfix2me-adt(module $ModName $ImpSection* $Section*, 
                             $ConsOption)
  ===>
  sdf-module-to-asfix2me-adt(module $ModName $ImpSection* $Section $Section*, 
                             $ConsOption) = 
	[ $Entries1, $Entries2 ]

[equ-section-to-adt-exports]
  section-to-adt($ModName, exports $Grammar, $ConsOption) =
    grammar-to-adt(no-module-name, $Grammar, $ConsOption)

[equ-section-to-adt-hiddens]
  section-to-adt($ModName, hiddens $Grammar, $ConsOption) = 
    grammar-to-adt($ModName, $Grammar, $ConsOption)

[default-grammar-to-adt]
  grammar-to-adt($ModName, $Grammar, $ConsOption) =

[equ-grammar-to-adt-divide]
  $Entries1 := grammar-to-adt($ModName, $Grammar1, $ConsOption),
  $Entries2 := grammar-to-adt($ModName, $Grammar2, $ConsOption)
  ===>
  grammar-to-adt($ModName, $Grammar1 $Grammar2, $ConsOption) =
    $Entries1, $Entries2

[equ-grammar-to-adt-context-free-syntax]
  grammar-to-adt($ModName, context-free syntax $Production*, $ConsOption) = 
    productions-to-adt($ModName, $Production*, $ConsOption)

[equ-grammar-to-adt-lexical-syntax]
  grammar-to-adt($ModName, lexical syntax $Production*, $ConsOption) =
    lexicals-to-adt($ModName, $Production*, $ConsOption)

[equ-productions-to-adt-empty]
  productions-to-adt($ModName,  , $ConsOption) =

[equ-productions-to-adt-divide]
  $Entries1 := production-to-adt($ModName, $Production, $ConsOption),
  $Entries2 := productions-to-adt($ModName, $Production*, $ConsOption)
  ===>
  productions-to-adt($ModName, $Production $Production*, $ConsOption) =
    $Entries1, $Entries2

[equ-production-to-adt-cons]
  { $Attr*1, cons(at-literal(""" $Char* """)), $Attr*2 } := $Attributes,
  $AltId   := afun($Char*),
  $TypeId  := sort-to-afun($Sort),
  $AFProd  := 
    build-asfix-prod(cf, $ModName, $Symbol*, $Sort, $Attributes, $ConsOption),
  $AFArgs  := build-asfix-appl-args($Symbol*),
  $Entry   := constructor( $TypeId, $AltId, appl($AFProd,[$AFArgs]) ),
  $Entries := build-list-entries($Symbol*)
  ===>
  production-to-adt($ModName, $Symbol* -> $Sort $Attributes, $ConsOption) = 
    $Entry, $Entries

[equ-production-to-adt-bracket]
  $Attributes == { bracket },
  $AltId   := afun("B" "r" "a" "c" "k" "e" "t"),
  $TypeId  := sort-to-afun($Sort),
  $AFProd  := 
    build-asfix-prod(cf, $ModName, $Symbol*, $Sort, $Attributes, $ConsOption),
  $AFArgs  := build-asfix-appl-args($Symbol*),
  $Entry   := constructor( $TypeId, $AltId, appl($AFProd,[$AFArgs]) ),
  $Entries := build-list-entries($Symbol*)
  ===>
  production-to-adt($ModName, $Symbol* -> $Sort $Attributes, $ConsOption) =
    $Entry, $Entries
 
[equ-production-to-adt-reject]
  production-to-adt($ModName, $Symbol* -> $Sort { $Attr*1, reject, $Attr*2 }, 
    $ConsOption) =

[default-production-to-adt]
  $AltId   := afun("D" "e" "f" "a" "u" "l" "t"),
  $TypeId  := sort-to-afun($Sort),
  $AFProd  := 
    build-asfix-prod(cf, $ModName, $Symbol*, $Sort, $Attributes, $ConsOption),
  $AFArgs  := build-asfix-appl-args($Symbol*),
  $Entry   := constructor( $TypeId, $AltId, appl($AFProd,[$AFArgs]) ),
  $Entries := build-list-entries($Symbol*)
  ===>
  production-to-adt($ModName, $Symbol* -> $Sort $Attributes, $ConsOption) =
    $Entry, $Entries

[equ-lexicals-to-adt-empty]
  lexicals-to-adt($ModName, , $ConsOption) =

[equ-lexicals-to-adt-divide]
  $Entries1 := lexical-to-adt($ModName, $Production, $ConsOption),
  $Entries2 := lexicals-to-adt($ModName, $Production*, $ConsOption)
  ===>
  lexicals-to-adt($ModName, $Production $Production*, $ConsOption) =
    $Entries1, $Entries2

[equ-lexical-to-adt-LAYOUT]
  lexical-to-adt($ModName, $Symbol* -> LAYOUT $Attributes, $ConsOption) =

[equ-lexical-to-adt-reject]
  lexical-to-adt($ModName, $Symbol* -> $Sort { $Attr*1, reject, $Attr*2 }, 
    $ConsOption) =

[default-lexical-to-adt]
  { $Attr*1, cons(at-literal(""" $Char* """)), $Attr*2 } := $Attributes,
  $AltId := afun($Char*),
  $TypeId  := sort-to-afun($Sort),
  $AFSort    := sort-to-lit($Sort),
  $FieldType := sort-to-afun($Sort),
  $AFAttrs   := build-asfix-attrs($Attributes, $ConsOption)
  ===>
  lexical-to-adt($ModName, $Symbol* -> $Sort $Attributes, $ConsOption) = 
    constructor( $TypeId, $AltId, 
      appl(prod([lex(sort($AFSort))],cf(sort($AFSort)),no-attrs),
       [appl(list(iter-star(char-class([range(0,255)]))),<chars(CHARLIST)>)]) )

[equ-build-list-entries-empty]
  build-list-entries() =

[equ-build-list-entries-divide]
  $Entries1 := build-list-entries($Symbol),
  $Entries2 := build-list-entries($Symbol+)
  ===>
  build-list-entries($Symbol $Symbol+) = $Entries1, $Entries2

[equ-build-list-entries-iter-star]
  $FieldId := sdflit-to-afun($Label),
  $ElemType := sort-to-afun($Sort),
  $ListType := afun-concat($ElemType $FieldId)
  ===>
  build-list-entries($Label : $Sort *) = [separated-list($ListType, $ElemType,[<ws-after-first(OptLayout)>])]

[equ-build-list-entries-iter-plus]
  $FieldId := sdflit-to-afun($Label),
  $ElemType := sort-to-afun($Sort),
  $ListType := afun-concat($ElemType $FieldId)
  ===>
  build-list-entries($Label : $Sort +) = [separated-list($ListType, $ElemType,[<ws-after-first(OptLayout)>])]
    

[equ-build-list-entries-iter-sep-star]
  $FieldId := sdflit-to-afun($Label),
  $ElemType := sort-to-afun($Sort),
  $ListType := afun-concat($ElemType $FieldId)
  ===>
  build-list-entries($Label : { $Sort $Sep } *) = 
    [separated-list($ListType, $ElemType,[<ws-after-first(OptLayout)>,lit(<sep(str)>), <ws-after-sep(OptLayout)>])]

  
[equ-build-list-entries-iter-sep-plus]
  $FieldId := sdflit-to-afun($Label),
  $ElemType := sort-to-afun($Sort),
  $ListType := afun-concat($ElemType $FieldId)
  ===>
  build-list-entries($Label : { $Sort $Sep } +) = 
    [separated-list($ListType, $ElemType,[<ws-after-first(OptLayout)>,lit(<sep(str)>), <ws-after-sep(OptLayout)>])]

[default-equ-build-list-entries]
  build-list-entries($Symbol) =

[css-1] collect-start-sorts($Module) = collect-start-sorts($Module, )
[css-2] collect-start-sorts(sorts $Symbol*1,$Symbol*2) = $Symbol*1 $Symbol*2
[css-3] collect-start-sorts(hiddens $Grammar, $Symbol*) = $Symbol*

[0] $Symbol* := collect-start-sorts($Module),
   $ADT := start-sorts-to-adt($Symbol*)
   ===>
   start-sorts-to-asfix2me-adt($Module) = $ADT

[0] start-sorts-to-adt($Symbol*) = start-sorts-to-adt($Symbol*, [])

[0] start-sorts-to-adt(,$ADT) = $ADT
[0] $ADT2 := start-sort-to-adt($Symbol, $ADT),
   $ADT3 := start-sorts-to-adt($Symbol*, $ADT2)
   ===>
   start-sorts-to-adt($Symbol $Symbol*, $ADT) = $ADT3

[0] $FieldType := sort-to-afun($Sort),
   $AFSort := sort-to-lit($Sort),   
   sort($Char* ) := $Sort,
   $AltId := afun($Char*),
   $FieldId := afun("t" "o" "p" "-" $Char*)
   ===>
   start-sort-to-adt($Sort, [ $Entries ]) = 
    [ constructor(Start, $AltId,
      parsetree(appl(prod(
                     [cf(opt(layout)),cf(sort($AFSort)),cf(opt(layout))],
                       sort("<START>"), no-attrs),
             [<ws-before(OptLayout)>,<$FieldId($FieldType)>,<ws-after(OptLayout)>]),
                              <amb-cnt(int)>)), $Entries]



