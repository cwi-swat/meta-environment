definition
module basic/Whitespace

exports
  lexical syntax
    [\ \t\n\r]	-> LAYOUT {cons("whitespace")}

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
module basic/Booleans

imports basic/BoolCon
exports
  sorts Boolean

  context-free syntax
    BoolCon                     -> Boolean {cons("constant")}
    lhs:Boolean "|" rhs:Boolean -> Boolean {left, cons("or")}
    lhs:Boolean "&" rhs:Boolean -> Boolean {left, cons("and")}
    "not" "(" Boolean ")" 	-> Boolean {cons("not")}
    "(" Boolean ")"       	-> Boolean {bracket, cons("bracket")}

  context-free priorities
    Boolean "&" Boolean -> Boolean >
    Boolean "|" Boolean -> Boolean

hiddens
  context-free start-symbols Boolean

  imports
    basic/Comments
  variables
    "Bool"[0-9]* 	-> Boolean
    "Bool-con"[0-9]* 	-> BoolCon

module basic/StrCon

exports

sorts StrCon StrChar

lexical syntax
    "\\n"                      -> StrChar {cons("newline")}
    "\\t"                      -> StrChar {cons("tab")}
    "\\\""                     -> StrChar {cons("quote")}
    "\\\\"                     -> StrChar {cons("backslash")}
    "\\" a:[0-7]b:[0-7]c:[0-7] -> StrChar {cons("octal")}
    ~[\0-\31\"\\\n]            -> StrChar {cons("normal")}

    [\"] line:StrChar* [\"]    -> StrCon {cons("default")}

hiddens
 context-free start-symbols
	StrCon

module basic/BoolCon

exports

sorts BoolCon
context-free syntax

    "true"  -> BoolCon {cons("true")}
    "false" -> BoolCon {cons("false")}

hiddens
context-free start-symbols
  BoolCon
module basic/NatCon

exports

sorts NatCon

lexical syntax
  
 [0-9]+ -> NatCon {cons("default")}

lexical restrictions

 NatCon -/- [0-9]

module basic/BytesCon

%% This module defines a lexical sort Bytes without defining any
%% particular syntax for it. The Bytes sort is used to store any
%% characters using lexical constructor functions.

exports 
  sorts Bytes Byte


%% exports

  %% The following production mimick what lexical constructor
  %% functions would have been generated when the syntax of Bytes
  %% was not hidden...
%%  context-free syntax
%%   bytes(CHARS[[Byte]]*) -> CHARS[[Bytes]] {char-classes([]),cons("bytes"), lexical-constructor}
%%   CHARS[[Bytes]]        -> Bytes
%%
%%
%%   byte(CHAR) -> CHARS[[Byte]] 
%%     {char-classes([char-class([range(0,255)])]),
%%      cons("byte"),lexical-constructor}
%%   CHARS[[Byte]] -> Byte

hiddens
  lexical syntax
    ~[]   -> Byte  {cons("byte")}
    Byte* -> Bytes {cons("bytes")}

module basic/Errors

imports basic/Locations
imports basic/StrCon

hiddens
  context-free start-symbols
    Summary Error

exports

sorts Subject
context-free syntax
  "subject" "(" description:StrCon ")" -> Subject {cons("subject")}

  "localized" "(" description:StrCon "," Location ")"
    -> Subject {cons("localized")}


sorts Error
context-free syntax
  "info" "(" description:StrCon "," "[" {Subject ","}* "]" ")"
    -> Error {cons("info")}

  "warning" "(" description:StrCon "," "[" {Subject ","}* "]" ")"
    -> Error {cons("warning")}

  "error" "(" description:StrCon "," "[" {Subject ","}* "]" ")"
    -> Error {cons("error")}

  "fatal" "(" description:StrCon "," "[" {Subject ","}* "]" ")"
    -> Error {cons("fatal")}


sorts Summary
context-free syntax
  "summary" "(" producer:StrCon "," id:StrCon "," 
   "[" {Error ","}* "]" ")"  -> Summary {cons("summary")}

module basic/Locations

imports basic/Areas
imports basic/StrCon

exports

sorts Location
context-free syntax

  "file" "(" filename:StrCon ")" -> Location {cons("file")}

  a:"area" "(" Area ")" -> Location {cons("area")}

  "area-in-file" "(" filename:StrCon "," Area ")"
    -> Location {cons("area-in-file")}
module basic/Areas

imports basic/NatCon

exports

sorts Area
context-free syntax

  "area" "("
    begin-line:NatCon "," 
    begin-column:NatCon ","
    end-line:NatCon ","
    end-column:NatCon ","
    offset:NatCon ","
    length:NatCon ")"
  -> Area {cons("area")}


module basic/ReadWriteCon

imports basic/BytesCon
imports basic/Errors

exports 

sorts Read Write

context-free syntax

  "read" "(" value:Bytes ")"    -> Read  {cons("success")}
  "read-error" "(" Summary ")"  -> Read  {cons("failure")}

  "written"                     -> Write {cons("success")}
  "write-error" "(" Summary ")" -> Write {cons("failure")}
module basic/ParsetreeCon[X]

imports basic/BytesCon
imports basic/NatCon
imports basic/Errors

exports 

context-free syntax

  "parse-tree" "(" left-layout:Bytes  "," 
                   tree:X             "," 
                   right-layout:Bytes ","
                   amb-cnt:NatCon
               ")"                   -> Parsetree[[X]] {cons("success")}

  "parse-error" "(" Summary ")"      -> Parsetree[[X]] {cons("failure")}
 
