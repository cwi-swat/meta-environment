
\documentclass[10pt]{article}
\usepackage[english]{babel}
\usepackage{url}
\usepackage{times}
\usepackage{xspace}
\usepackage{supertabular}

\newcommand{\rscript}[0]{\textsc{Rscript}\xspace}
\newcommand{\asfsdf}[0]{\textsc{Asf+Sdf}\xspace}

\title{A Tutorial Introduction to \rscript}
\author{Paul Klint}

\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This short note documents the current state of the \rscript language.
Be aware, this work in progress.
\end{abstract}

\section{Introduction}

\rscript is a small scripting language based on the relational
calculus.  It is intended for analyzing and querying the source code
of software systems: from finding uninitialized variables in a single
program to formulating queries about the architecture of a complete
software system. \rscript fits well in the extract-enrich-view paradigm:

\begin{description}
\item[Extract:] Given the source text, extract relevant information
from it in the form of relations. Examples are the CALLS relation that
describes direct calls between procedures, the USE relation that
relates statements with the variables that are used in the statements,
and the PRED relation that relates a statement with its predecessors
in the control flow graph.  The extraction phase is outside the scope
of \rscript, may be implemented using \asfsdf.

\item[Enrich:] Derive additional information from the relations
extracted from the source text. For instance, use CALLS to compute
procedures that can also call each other indirectly (using transitive
closure).  Here is where \rscript shines.

\item[View:] The result of the enrichment phase are again bags and
relations.  These can be displayed with various tools like, Dot, Rigi
and others. \rscript is not concerned with viewing.

\end{description}

\section{The \rscript language}

\rscript is based on \emph{binary relations} only and has no direct support
for n-ary relations with labelled columns as usual in a general
database language. However, some syntactic support for n-ary relations
exists that translates them internally to binary relations. We will
explain this further below.

An \rscript consists of a sequence of declarations for variables and/or
functions. Usually, the value of one of these variables is what the writer of the
script is interested in.

The language has scalar types (Boolean, integer, string, area) and
composite types (bag and relation). Expressions are constructed from
comprehensions, function invocations and operators. These are all
described below.

\section{Types and values}

\subsection{Elementary Types and Values}

\paragraph{Booleans}
The Booleans are represented by the type {\tt bool} and have two values:
{\tt true} and {\tt false}.

\paragraph{Integers}
The integer values are represented by the type {\tt int} and are written as
usual, e.g., {\tt 0}, {\tt 1}, or {\tt 123}.

\paragraph{Strings}
The string values are represented by the type {\tt str} and consist
of character sequences surrounded by double quotes. e.g., {\tt "a"} or
{\tt "a\ long\ string"}.

\paragraph{Areas}
Area values are represented by the type {\tt area} and serve as source text
coordinates, they are written as in: {\tt area("/usr/paulk/myfile.c", 2, 3, 7,
55)}.

\subsection{Composite Types and Values}

\paragraph{Tuples}

Tuples are represented by the type {\tt <T1, T2>}, where {\tt T1} and
{\tt T2} are arbitrary types. An example is {\tt <int, str>}.

\rscript directly supports tuples consisting of two elements (also
know as \emph{pairs}).  For convenience, n-ary tuples are allowed, but
they are translated to a nested pair.  For instance, the type {\tt
<int, int, int, int>} corresponds to {\tt <int, <int, <int, int>>>}
and the value {\tt <1, 2, 3, 4>} corresponds to {\tt <1, <2, <3, 4>>>}.

\paragraph{Bags}
Bags are represented by the type {\tt bag[T]}, where {\tt T} is an
arbitrary type. Examples are {\tt bag[int]}, {{\tt bag[<int,int>]} and
{\tt bag[bag[str]]}.  Bags are denoted by {\tt \{ E1, E2, ..., En \}},
where the {\tt E}s are expressions that yield the desired element
type. For example, {\tt \{1, 2, 3\}}, {\tt \{<1,10>, <2,20>,
<3,30>\}}, and {\tt \{\{"a", "b"\}, \{"c", "d"\}\}}.

\paragraph{Relations}
Bags are nothing more than bags of tuples, but since they are used so often
we provide some shorthand notation for them.

Relations are represented by the type {\tt rel[T1, T2]}, where {\tt
T1} and {\tt T2} are arbitrary types; it is a shorthand for {\tt
bag[<T1, T2>]}.  Examples are {\tt rel[int,str]} and {\tt
rel[int,bag[str]]}.  Relations are denoted by {\tt \{<E11, E12>, <E21,
E22>, ..., <En1, En2>\}}, where the {\tt E}$_ij$ are expressions that
yield the desired element type. For example, {\tt \{<1, "a">, <2, "b",
<3,"c">\}}.

N-ary relations are represented by the type  {\tt rel[T1, T2, ..., Tn]}
which is, not surprisingly, a shorthand for  {\tt bag[<T1, T2, ..., Tn>]}

\section{Comprehensions}

We will use the familiar notation
\begin{verbatim}
  { Exp | Gen1, ..., Genn }
\end{verbatim}
to denote the construction of a bag consisting of the union of
successive values of the expression {\tt Exp}.  The values and the
generated bag are determined by {\tt Exp} and the \emph{generators}
{\tt Gen1, ..., Genn}.  {\tt Exp} is computed for all possible
combinations of values produced by the generators.

Each generator may introduce new variables
that can be used in subsequent generators as well as in the expression
{\tt Exp}.  A generator can use the variables introduced by preceeding
generators.  Generators may enumerate all the values in a bag or
relation, they may perform a test, or they may assign a value to
variables.

\subsection{Generators}

\paragraph{Enumerator}
Enumerators generate all the values in a given bag or relation.
They come in two flavours: 

\begin{itemize}
\item {\tt V : Exp}: the elements of the bag or relation that results from the evaluation
of {\tt Exp} are enumerated and subsequently assigned to the new variable {\tt V}.


\item {\tt <V1, ..., Vn> : Exp}: the elements of the bag or relation
that results from the evaluation of {\tt Exp} are enumerated. The
elements of the resulting n-tuple are subsequently assigned to the
new variables {\tt V1, ..., Vn}.

\end{itemize}

\paragraph{Test}
A test is a boolean-valued expression. If the evaluation yields {\tt
true} this indicates that the current combination of generated values is
still as desired and execution continues with subsequent generators.
otherwise.
If the evaluation yields {\tt false} this indicates that the current
combination of values is undesired, and that another combination
should be tried.

\paragraph{Assignment}
Assignment assigns a value to one or more variables and comes in two forms:

\begin{itemize}

\item \item {\tt V : Exp}: assigns the value of {\tt Exp} to the new variable {\tt V}.

\item {\tt <V1, ..., Vn> : Exp}: assigns the elements of the n-tuple
resulting from the evaluation of {\tt Exp} to the new variables {\tt
V1, ..., Vn}.

\end{itemize}


\subsection{Examples of Comprehensions}

\paragraph{Example 1}

{\tt \{X | X : \{1, 2, 3, 4, 5\},  X >= 3\}} yields the bag {\tt \{3,4,5\}}.

\paragraph{Example 2}

{\tt \{X | X :\{1, 2, 3\}, Y :\{2, 3, 4\} | X >= Y\}} yields the relation
{\tt \{<2, 2>, <3, 2>, <3, 3>\}}.

\paragraph{Example 3}
{\tt \{<Y, X> | X, Y> :\{<1,10>, <2,20>\} \}} yields the inverse of
the given relation: {\tt \{<10,1>, <20,2>\}}.

\section{Declarations}

\paragraph{Variable declarations}
A variable declaration has the form {\tt T V = E}, where {\tt T} is a type,
{\tt V} is a variable name, and {\tt E} is an expression that should have type
{\tt T}. The effect is that the value of expression {\tt E} is assigned to
{\tt V} and can be used later on as {\tt V}'s values. Double declarations are
not allowed.

As a convenience, also declarations without an initialization expression are
permitted and have the form {\tt T V}. They only introduce the variable {\tt
V}.

\paragraph{Function declarations}
A function declaration has the form
\begin{verbatim}
T F(T1 V1, ..., Tn Vn) = E
\end{verbatim}
Here {\tt T} is the result type of the function and this should be equal to
the type of the associated expression {\tt E}.  Each {\tt T}$_i$\ {\tt V}$_i$
represents a formal parameter of the function. The formal parameters may occur
in {\tt E} and get their value when {\tt F} is invoked from another
expression.

\paragraph{Where}
Local variables can be introduced as follows:
\begin{verbatim}
E where T1 V1 = E1, ..., Tn Vn = En endwhere
\end{verbatim}
First the local variables {\tt V}$_i$ are bound to their respective values
{\tt E}$_i$, and then the value of expression {\tt E} is yielded.

\paragraph{Assert}
An assert statement may occur everywhere where a declaration is allowed.  It
has the form {\tt assert M: E}, where {\tt M} is a string that serves as a
label for this assertion, and {\tt E} is a boolean-value expression.  During
execution, a list of true and false assertions is maintained.  When the script
is executed as \emph{testsuite} (see Section~\ref{running}) a summary of this
information is shown to the user.

\paragraph{Solvers}
It is also possible to define mutually recursive variables by
\begin{verbatim}
solve {
  V1 = E1,
  ...
  Vn = En
}
\end{verbatim}
Here, the expressions {\tt E}$_i$ may refer to any of the variables {\tt
  V}$_i$ (and to any variables declared earlier).  This set of equations is
  solved by evaluating the expressions {\tt E}$_i$, assigning their value to
  the corresponding variables {\tt V}$_i$, and repeated this as long as the
  value of one of the variables was changed. This is typically used for
  solving a set of dataflow equations. \footnote{Probably, the syntax of this
  construct should more emphasize that it is a set of equations.}


\section{Built-in operators}

\tablehead{\hline}
\tabletail{\hline}
\begin{supertabular}{|p{3cm}|p{8.5cm}|} \hline

bool \texttt{and} bool & yields true if both arguments have the value true and
false otherwise\\ \hline

bool \texttt{or} bool & yields true if either argument has the value true and
                         false otherwise\\ \hline

bool \texttt{implies} bool & yields false if the first argument has the value true and
                             the second argument has value false, and
                         true otherwise\\ \hline

{\tt not} bool & yields true if its argument is false and true otherwise \\
\hline

any {\tt in} bag & yields true if the left argument occurs as element in the
right argument and false otherwise \\ \hline

any {\tt notin} bag & yields false if the left argument occurs as element in the
right argument and true otherwise \\ \hline \hline


tuple {\tt in} rel & yields true if the left argument occurs as element in the
right argument and false otherwise \\ \hline

tuple {\tt notin} rel & yields false if the left argument occurs as element in the
right argument and true otherwise \\ \hline \hline

bag {\tt ==} bag & yields true if both arguments are equal bags and false
otherwise\\ \hline

bag {\tt !=} bag & yields true if both arguments are unequal bags and false
otherwise\\ \hline

bag {\tt <=} bag & yields true if the left argument is a subset of the right argument
and false otherwise\\ \hline

bag {\tt <} bag & yields true if the left argument is a strict subset of the right argument
and false otherwise\\ \hline

bag {\tt >=} bag & yields true if the left argument is a superset of the right argument
and false otherwise\\ \hline

bag {\tt >} bag & yields true if the left argument is a strict superset of the right argument
and false otherwise\\ \hline \hline

rel {\tt ==} rel & yields true if both arguments are equal relations and false
otherwise\\ \hline

rel {\tt !=} rel & yields true if both arguments are unequal relations and false
otherwise\\ \hline

rel {\tt <=} rel & yields true if the left argument is a subset of the right argument
and false otherwise\\ \hline

rel {\tt <} rel & yields true if the left argument is a strict subset of the right argument
and false otherwise\\ \hline

rel {\tt >=} rel & yields true if the left argument is a superset of the right argument
and false otherwise\\ \hline

rel {\tt >} rel & yields true if the left argument is a strict superset of the right argument
and false otherwise\\ \hline \hline

int {\tt ==} int & yields true if both arguments are numerically equal and false
otherwise\\ \hline

int {\tt !=} int & yields true if both arguments are numerically unequal  and false
otherwise\\ \hline

int {\tt <=} int & yields true if the left argument is numerically less than
or equal the right argument and false otherwise\\ \hline

int {\tt <} int & yields true if the left argument is a numerically less than the right argument
and false otherwise\\ \hline

int {\tt >=} int & yields true if the left argument is numerically greater
than or equal the right argument and false otherwise\\ \hline

int {\tt >} int & yields true if the left argument is numerically greater than the right argument
and false otherwise\\ \hline \hline

bag {\tt union} bag & yields the bag resulting from the union of the two arguments
 \\ \hline

bag {\tt inter} bag & yields the bag resulting from the intersection of the two arguments
 \\ \hline

bag \verb+\+ bag & yields the bag resulting from the difference of the two arguments
 \\ \hline \hline

rel {\tt union} rel & yields the relation resulting from the union of the two arguments
 \\ \hline

rel {\tt inter} rel & yields the relation resulting from the intersection of the two arguments
 \\ \hline

rel \verb+\+ rel & yields the relation resulting from the difference of the two arguments
 \\ \hline

rel {\tt o} rel & yields the relation resulting from the composition of the two arguments
 \\ \hline


bag {\tt x} bag & yields the relation resulting from the carthesian product of the two arguments
 \\ \hline

rel {\tt +} & yields the relation resulting from the transitive closure of
 the argument  \\ \hline

rel {\tt *}  & yields the relation resulting from the reflexive transitive closure of
 the argument  \\ \hline

\end{supertabular}

\section{Built-in functions}

\tablehead{\hline}
\tabletail{\hline}

\begin{supertabular}{|p{4cm}|p{7.5cm}|} \hline

{\tt id(} bag {\tt )} & yields the relation that results from transforming
each element in the argument into a pair with that element as first and
second element \\ \hline

{\tt domain(} rel {\tt )} & yields the bag that results from taking
the first element of each tuple in the argument \\ \hline

{\tt range(} rel {\tt )} & yields the bag that results from taking
the second element of each tuple in the argument \\ \hline

{\tt carrier(} rel {\tt )} & yields the bag that results from taking
the first and  second element of each tuple in the argument \\ \hline

{\tt top(} rel {\tt )} &  yields the bag of all roots when the argument is
viewed as a graph\\ \hline

{\tt bottom(} rel {\tt )} &  yields the bag of all leaves when the argument is
viewed as a graph\\ \hline

{\tt inv(} rel {\tt )} &  yields the relation that is the inverse of the
argument, i.e. the relation in which the elements of the tuples have been
interchanged.\\ \hline

{\tt compl(} rel {\tt )} &  yields the relation that is the complement of the
argument, using the carrier set of that argument oas universe \\ \hline

{\tt domainR(} rel, bag {\tt )} & yields a relation identical to the first
 argument but only containing tuples whose first element is in the second
 argument \\ \hline

{\tt rangeR(} rel, bag {\tt )} & yields a relation identical to the first
 argument but only containing tuples whose second element is in the second
 argument \\ \hline

{\tt carrierR(} rel, bag {\tt )} &  yields a relation identical to the first
 argument but only containing tuples whose first and second element are in the second
 argument \\ \hline

{\tt domainX(} rel, bag {\tt )} & yields a relation identical to the first
 argument but with all tuples removed whose first element is in the second
 argument \\ \hline

{\tt rangeX(} rel, bag {\tt )} & yields a relation identical to the first
 argument but with all tuples removed whose second element is in the second
 argument \\ \hline


{\tt carrierX(} rel, bag {\tt )} &  yields a relation identical to the first
 argument but with all tuples removed whose first or second element is in the second
 argument \\ \hline

{\tt first(} tuple {\tt )} &  yields the first element of the argument\\ \hline

{\tt second(} tuple {\tt )} &  yields the second element of the argument\\ \hline

{\tt reachR(} bag1, bag2, rel {\tt )} & yields the relation that describes
which nodes can be reached from bag1 using the relation rel, such that only nodes in
bag2 are used. \\ \hline

{\tt power(} bag {\tt )} & yields the powerset of the value of its argument \\ \hline

{\tt reachX(} bag, bag, rel {\tt )} &  yields the relation that describes
which nodes can be reached from bag1 using the relation rel, such that no nodes in
bag2 are used. \\ \hline

\end{supertabular}

\section{Running a \rscript}
Currently, the definition of \rscript resides in {\tt /ufs/paulk/research/RPA}
but that will change soon. You can also checkout your own copy by means of
{\tt cvs -d /ufs/paulk/cvsroot co RPA}.

\paragraph{Running a script}
\begin{itemize}
\item Change to the above directory (better to your own copy!).
\item Start the ASF+SDF Meta-Environment by the command {\tt meta}.
\item Open the module {\tt Rscript.sdf}.
\item Open your own term, using the Rscript module.
\item Click the parse button in the {\tt Actions} menu of the editor:
now we know whether there are syntax errors. If so, correct them.

\item Click the {\tt Check Rscript} button in the {\tt Actions} menu: this will
  perform a type check of your script. If there are type errors, correct them.

\item Click the {\tt Exec Rscript} button to execute your script: a new
editor pops up which shows all the variables at the end of the execution.
\end{itemize}

\paragraph{Running a Test suite} \label{running}
Same as above but use {\tt Exec Rscript Testsuite} button instead of the {\tt
Exec Rscript} button.  The effect is that the script is executed and that a
summary is printed of {\tt assert} statement that succeeded or failed.

\paragraph{Miscellaneous}
The subdirectory {\tt rscripts} contains several sample scripts.  See {\tt
test1.rscript} and {\tt tests2.rscript} for examples of the use of built-in
operators and functions.

\section{Pseudo definitions of some built-in operators and functions}

It is interesting that most (but not all!) built-in operators and all
functions can be defined in \rscript itself. They only serve convenience and
efficiency.  The definitions marked with a dagger ($\dagger$) cannot be written
as such since it is not possible to define operators in \rscript.  It is,
however, allowed to write these polymorphic definitions where {\tt T1}, {\tt
T2}, ... represent arbitrary types.

\paragraph{$^\dagger$Composition: {\tt o}}

\begin{verbatim}
rel[T1,T3] o(rel[T1,T2] R1, rel[T2,T3] R2) =
   {<v, y> : <v, w> in R1, <x, y> in R2 | w == x }
\end{verbatim}

\paragraph{$^\dagger$Carthesian product: {\tt x}}
\begin{verbatim}
rel[T1,T2] x(bag[T1] B1, bag[T2] B2) =
   {<x, y> : x in B1, y in B2 }
\end{verbatim}

\paragraph{$^\dagger$ Left image: {\tt .}}
\begin{verbatim}
bag[T2] .(T1 E, rel[T1,T2] R) = { W : <V, W> in R | V == E }
bag[T2] .(bag[T1] B, rel[T1,T2] R) = { W : <V, W> in R | V in B}
\end{verbatim}

\paragraph{$^\dagger$Right image: {\tt .}}
\begin{verbatim}
bag[T1] .(rel[T1,T2] R, T2 E) = { V : <V, W> in R | W == E }
bag[T1] .(rel[T1,T2] R, bag[T2] B) = { V : <V, W> in R |  W in B }
\end{verbatim}

\paragraph{Identity: {\tt id}}
\begin{verbatim}
rel[T,T] id(bag[T] B) = { <X, X> : X in B }
\end{verbatim}
Example:
\begin{verbatim}
id({1,2,3}) = {<1,1>, <2,2>, <3,3>}
\end{verbatim}

\paragraph{Domain: {\tt domain}}
\begin{verbatim}
Def:	bag[T1] domain (rel[T1,T2] R) = { X : <X, Y> in R }
\end{verbatim}
Example:
\begin{verbatim}
domain({<1,10>, <2,20>}) = {1, 2}
\end{verbatim}

\paragraph{Range: {\tt range}}
\begin{verbatim}
bag[T2] range (rel[T1,T2] R) = { Y : <X, Y> in R }
\end{verbatim}
Example:
\begin{verbatim}
range({<1,10>, <2,20>}) = {10, 20}
\end{verbatim}

\paragraph{Carrier: {\tt carrier}}
\begin{verbatim}
bag[T]  carrier (rel[T,T] R) = domain(R) union range(R)
\end{verbatim}
Example:
\begin{verbatim}
carrier({<1,10>, <2,20>}) = {1, 10, 2, 20}
\end{verbatim}

\paragraph{Top: {\tt top}}
\begin{verbatim}
bag[T] top(rel{T, T] R) = domain(R) \ range(R)
\end{verbatim}

\paragraph{Bottom: {\tt bottom}}
\begin{verbatim}
bag[T] bottom(rel[T,T] R) = range(R) \ domain(R)
\end{verbatim}

\paragraph{Inverse: {\tt inv}}
\begin{verbatim}
rel[T2,T1] inv (rel[T1,T2] R) = { <Y, X> : <X, Y> in R }
\end{verbatim}
example:
\begin{verbatim}
inv({<1,10>, <2,20>}) = {<10,1>,<20,2>}
\end{verbatim}

\paragraph{Complement: {\tt compl}}
\begin{verbatim}
rel[T1, T2] compl(rel[T1,T2] R) = (domain(R) x range(R)) \ R
\end{verbatim}

\paragraph{Domain restriction: {\tt domainR}}
\begin{verbatim}
rel[T1,T2] domainR (rel[T1,T2] R, Bag[T1] B) = 
   { <X, Y> : <X, Y> in R, X in B
}
\end{verbatim}

\paragraph{Range Restriction: {\tt rangeR}}
\begin{verbatim}
rel[T1,T2] rangeR (rel[T1,T2] R, Bag[T2] B) =  
   { <X, Y> : <X, Y> in R | Y in B
}
\end{verbatim}

\paragraph{Carrier Restriction: {\tt carrierR}}
\begin{verbatim}
rel[T,T] carR (rel[T,2] R, Bag[T] B) =  
   { <X, Y> : <X, Y> in R | X in B and Y  in B }
\end{verbatim}

\paragraph{Domain Exclusion: {\tt domainX}}
\begin{verbatim}
rel[T1,T2] domainX (rel[T1,T2] R, Bag[T1] B) = 
   { <X, Y> : <X, Y> in R | X notin B }
\end{verbatim}

\paragraph{Range Exclusion: {\tt rangeX}}
\begin{verbatim}
rel[T1,T2] rangeX (rel[T1,T2] R, Bag[T2] B) = 
	   { <X, Y> : <X, Y> in R | Y notin B }
\end{verbatim}

\paragraph{Carrier Exclusion: {\tt carrierX}}
\begin{verbatim}
rel[T,T] carX (rel[T,T] R, Bag[T] B) = 
   { <X, Y> : <X, Y> in R | X notin B or Y notin B }
\end{verbatim}

\paragraph{First of Tuple: {\tt first}}
\begin{verbatim}
T1 first(<T1, T2> P) = T1
\end{verbatim}

\paragraph{Second of Tuple: {\tt second}}
\begin{verbatim}
T2 second(<T1, T2> P) = T2
\end{verbatim}

\paragraph{Reach Exclusion: {\tt reachX}}
\begin{verbatim}
rel[T,T] reachX( bag[T] S, bag[T] E, rel[T,T] R) =
	       domainR(R, S) o carrierX(R, E)+
\end{verbatim}

\paragraph{Reach Restriction: {\tt reachR}}
\begin{verbatim}
rel[T,T] reachR( bag[T] S, bag[T] E, rel[T,T] R) =
	       domainR(R, S) o carrierR(R, E)+
\end{verbatim}

\end{document}
