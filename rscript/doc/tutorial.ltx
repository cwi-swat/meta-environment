
\documentclass[10pt]{article}
\usepackage{a4wide}
\usepackage[english]{babel}
\usepackage{url}
\usepackage{times}
\usepackage{xspace}
\usepackage{alltt}
\usepackage{supertabular}
\usepackage{epsfig}


\newcommand{\rscript}[0]{\textsc{Rscript}\xspace}
\newcommand{\asfsdf}[0]{\textsc{Asf+Sdf}\xspace}
\newcommand{\note}[1]{\paragraph{Note:} \emph{#1}}

\title{A Tutorial Introduction to \rscript}
\author{Paul Klint}

\date{\today}

\begin{document}
\maketitle

\tableofcontents

\newpage

\section{Introduction}\label{SEC:Introduction}

\rscript is a small scripting language based on the relational
calculus.  It is intended for analyzing and querying the source code
of software systems: from finding uninitialized variables in a single
program to formulating queries about the architecture of a complete
software system. \rscript fits well in the extract-enrich-view paradigm:

\begin{description}
\item[Extract:] Given the source text, extract relevant information
from it in the form of relations. Examples are the CALLS relation that
describes direct calls between procedures, the USE relation that
relates statements with the variables that are used in the statements,
and the PRED relation that relates a statement with its predecessors
in the control flow graph.  The extraction phase is outside the scope
of \rscript but may, for instance, be implemented using \asfsdf.

\item[Enrich:] Derive additional information from the relations
extracted from the source text. For instance, use CALLS to compute
procedures that can also call each other indirectly (using transitive
closure).  Here is where \rscript shines.

\item[View:] The result of the enrichment phase are again bags and
relations.  These can be displayed with various tools like, Dot, Rigi
and others. \rscript is not concerned with viewing.

\end{description}

\section{The \rscript Language}

\rscript is based on \emph{binary relations} only and has no direct support
for n-ary relations with labeled columns as usual in a general
database language. However, some syntactic support for n-ary relations
exists that translates them internally to binary relations. We will
explain this further below.

An \rscript consists of a sequence of declarations for variables and/or
functions. Usually, the value of one of these variables is what the writer of the
script is interested in.

The language has scalar types (Boolean, integer, string, area) and
composite types (bag and relation). Expressions are constructed from
comprehensions, function invocations and operators. These are all
described below.

\subsection{Types and Values}

\subsubsection{Elementary Types and Values} \label{SEC:ElementaryTypes}

\paragraph{Booleans}
The Booleans are represented by the type {\tt bool} and have two values:
{\tt true} and {\tt false}.

\paragraph{Integers}
The integer values are represented by the type {\tt int} and are written as
usual, e.g., {\tt 0}, {\tt 1}, or {\tt 123}.

\paragraph{Strings}
The string values are represented by the type {\tt str} and consist
of character sequences surrounded by double quotes. e.g., {\tt "a"} or
{\tt "a\ long\ string"}.

\paragraph{Areas}
Area values are represented by the type {\tt area} and serve as source text
coordinates, they are written as in: {\tt area("/usr/paulk/myfile.c", 2, 3, 7,
55)}.

\subsubsection{Composite Types and Values}

\paragraph{Tuples}

Tuples are represented by the type {\tt <$T_1$, $T_2$>}, where $T_1$ and
$T_2$ are arbitrary types. An example is {\tt <int, str>}.

\rscript directly supports tuples consisting of two elements (also
know as \emph{pairs}).  For convenience, n-ary tuples are allowed, but
they are translated to a nested pair.  For instance, the type {\tt
<int, int, int, int>} corresponds to {\tt <int, <int, <int, int>>>}
and the value {\tt <1, 2, 3, 4>} corresponds to {\tt <1, <2, <3, 4>>>}.

\paragraph{Bags}
Bags are represented by the type {\tt bag[$T$]}, where $T$ is an arbitrary
type. Examples are {\tt bag[int]}, {{\tt bag[<int,int>]} and {\tt
bag[bag[str]]}.  Bags are denoted by a list of elements, separated by comma's
and enclosed in braces as in  {\tt \{ $E_1$, $E_2$, ..., $E_n$ \}},
where the $E_i$ ($1 \leq i \leq n$) are expressions that yield the desired element
type. For example, 
\begin{itemize}
\item {\tt \{1, 2, 3\}} is of type {\tt bag[int]},
\item  {\tt \{<1,10>, <2,20>, <3,30>\}} is of type {\tt bag[<int,int>]}, and 
\item {\tt \{\{"a", "b"\}, \{"c", "d"\}\}} is of type {\tt bag[bag[str]]}.
\end{itemize}

\paragraph{Relations}
Bags are nothing more than bags of tuples, but since they are used so often
we provide some shorthand notation for them.

Relations are represented by the type {\tt rel[$T_1$, T$_2$]}, where {\tt
$T_1$} and {\tt $T_2$} are arbitrary types; it is a shorthand for {\tt
bag[<$T_1$, $T_2$>]}.  Examples are {\tt rel[int,str]} and {\tt
rel[int,bag[str]]}.  Relations are denoted by {\tt \{<$E_{11}$, $E_{12}$>, <$E_{21}$,
$E_{22}$>, ..., <$E_{n1}$, $E_{n2}$>\}}, where the $E_{ij}$ are expressions that
yield the desired element type. For example, {\tt \{<1, "a">, <2, "b">,
<3,"c">\}} is of type {\tt rel[int, str]}.

Not surprisingly, $n$-ary relations are represented by the type {\tt rel[$T_1$, $T_2$, ..., $T_n$]}
which is  a shorthand for  {\tt bag[<$T_1$, $T_2$, ..., $T_n$>]}.

\subsection{Comprehensions}

We will use the familiar notation
\begin{quote}
  {\tt \{ $E$ | $G_1$, ..., $G_n$ \}}
\end{quote}
to denote the construction of a bag consisting of the union of
successive values of the expression $E$.  The values and the
generated bag are determined by $E$ and the \emph{generators}
$G_1 ,..., G_n$.  $E$ is computed for all possible
combinations of values produced by the generators.

Each generator may introduce new variables
that can be used in subsequent generators as well as in the expression
$E$.  A generator can use the variables introduced by preceding
generators.  Generators may enumerate all the values in a bag or
relation, they may perform a test, or they may assign a value to
variables.

\subsubsection{Generators}

\paragraph{Enumerator}
Enumerators generate all the values in a given bag or relation.
They come in two flavors: 

\begin{itemize}
\item {\tt $V$~:~$E$}: the elements of the bag or relation that results from the evaluation
of expression $E$ are enumerated and subsequently assigned to the new variable $V$.


\item {\tt <$V_1$,~...,~$V_n$>~:~$E$}: the elements of the bag or relation
that results from the evaluation of expression $E$ are enumerated. The
elements of the resulting $n$-tuple are subsequently assigned to the
new variables $V_1 ,..., V_n$.

\end{itemize}

\paragraph{Test}
A test is a boolean-valued expression. If the evaluation yields {\tt true}
this indicates that the current combination of generated values up to this test
is still as desired and execution continues with subsequent generators.  If
the evaluation yields {\tt false} this indicates that the current combination
of values is undesired, and that another combination should be tried.

\paragraph{Assignment}
Assignments assign a value to one or more variables and also come in two flavors:

\begin{itemize}

\item {\tt $V$ <- $E$}: assigns the value of expression $E$ to the new variable $V$.

\item {\tt <$V_1$, ..., $V_n$> <- $E$}: assigns the elements of the $n$-tuple
resulting from the evaluation of expression $E$ to the new variables $V_1 ,..., V_n$.

\end{itemize}


\subsubsection{Examples of Comprehensions}

\paragraph{Example}

{\tt \{X | X : \{1, 2, 3, 4, 5\},  X >= 3\}} yields the bag {\tt \{3,4,5\}}.

\paragraph{Example}

{\tt \{<X, Y> | X :\{1, 2, 3\}, Y :\{2, 3, 4\}, X >= Y\}} yields the relation
{\tt \{<2, 2>, <3, 2>, <3, 3>\}}.

\paragraph{Example}
{\tt \{<Y, X> | <X, Y> :\{<1,10>, <2,20>\} \}} yields the inverse of
the given relation: {\tt \{<10,1>, <20,2>\}}.

\subsection{Declarations}

\subsubsection{Variable Declarations}
A variable declaration has the form 
\begin{quote}
{\tt $T$ $V$ = $E$}
\end{quote}
where $T$ is a type,
$V$ is a variable name, and $T$ is an expression that should have type
$T$. The effect is that the value of expression $E$ is assigned to
$V$ and can be used later on as $V$'s value. Double declarations are
not allowed.

As a convenience, also declarations without an initialization expression are
permitted and have the form 
\begin{quote}
{\tt $T$ $V$} 
\end{quote}
and only introduce the variable $V$.

\paragraph{Example} {\tt int max = 100} declares the integer variable
{\tt max} with value {\tt 100}.

\paragraph{Example} {\tt rel[str,int] day = \{<"mon", 1>, <"tue", 2>, <"wed",
    3>, <"thu", 4>, <"fri", 5>, <"sat",6>, <"sun",7>\}}
declares the variable {\tt day}, a relation that maps strings to integers.

\subsubsection{Local Variable Declarations}
Local variables can be introduced as follows:
\begin{quote}
{\tt $E$ where $T_1$ $V_1$ = $E_1$, ..., $T_n$ $V_n$ = $E_n$ end where}
\end{quote}
First the local variables $V_i$ are bound to their respective values
$E_i$, and then the value of expression $E$ is yielded.


\subsubsection{Function Declarations}
A function declaration has the form
\begin{quote}
{\tt $T$ $F$($T_1 ~ V_1$, ..., $T_n ~ V_n$) = $E$}
\end{quote}
Here $T$ is the result type of the function and this should be equal to the
type of the associated expression $E$.  Each $T_i$ $V_i$ represents a typed
formal parameter of the function. The formal parameters may occur in $E$ and
get their value when $F$ is invoked from another expression.

\paragraph{Example} The function declaration
\begin{quote}
{\tt rel[int, int] invert(rel[int,int] R) = \{<Y, X> | <X, Y> : R \}} 
\end{quote}
yields the inverse of the argument relation {\tt R}. For instance,
\begin{itemize}
\item {\tt invert(\{<1,10>, <2,20>\})} yields {\tt \{<10,1>, <20,2>\}}.
\end{itemize}

\paragraph{Parameterized types in function declarations}
The types that occur in function declarations may also contain
\emph{type variables}. In this way functions can be defined for arbitrary
types.

\begin{sloppypar}
\paragraph{Example} The declaration
\begin{quote}
{\tt rel[T2, T1] invert2(rel[T1,T2] R) = \{<Y, X> | <X, Y> : R \}} 
\end{quote}
yields an inversion function that is applicable to any binary relation.
For instance,
\begin{itemize}
\item {\tt invert2(\{<1,10>, <2,20>\})} yields {\tt \{<10,1>, <20,2>\}},
and 
\item {\tt invert2(\{<"mon", 1>, <"tue", 2>\}}
yields {\tt \{<1, "mon">, <2, "tue">\}}.
\end{itemize}
\end{sloppypar}

\paragraph{Example} The function
\begin{quote}
{\tt <T2, T1> swap(T1 A, T2 B) = <B, A>}
\end{quote}
can be used to swap the elements of pairs of arbitrary types.  For instance,
\begin{itemize}
\item {\tt swap(<1, 2>)} yields {\tt <2,1>} and 
\item {\tt swap(<"wed", 3>)} yields {\tt
<3, "wed">}.
\end{itemize}

\subsection{Assertions}
An assert statement may occur everywhere where a declaration is allowed.  It
has the form 
\begin{quote}
{\tt assert $L$: $E$}
\end{quote}
 where $L$ is a string that serves as a
label for this assertion, and $E$ is a boolean-value expression.  During
execution, a list of true and false assertions is maintained.  When the script
is executed as a \emph{test suite} (see Section~\ref{running}) a summary of this
information is shown to the user. When the script is executed in the standard
fashion, the assert statement has no affect.

\paragraph{Example}
\begin{quote}
{\tt assert "Equality on Bags 1": \{1, 2, 3, 1\} == \{3, 2, 1, 1\}}
\end{quote}

\subsection{Equations}
It is also possible to define mutually dependent sets of equations:

\begin{quote}
{\tt equations \\
       \hspace*{0.5cm}initial \\
          \hspace*{1cm}$T_1$ $V_1$ init $I_1$\\
          \hspace*{1cm}  ... \\
          \hspace*{1cm}$T_n$ $V_n$ init $I_n$\\
       \hspace*{0.5cm}satisfy\\
          \hspace*{1cm}$V_1$ = $E_1$\\
          \hspace*{1cm}...\\
          \hspace*{1cm}$V_n$ = $E_n$\\
end equations}
\end{quote}

\noindent In the {\tt initial} section, the variables $V_i$ are declared and
initialized.
In the {\tt satisfy} section, the actual set of equations is given.
The expressions $E_i$ may refer to any of the variables 
  $V_i$ (and to any variables declared earlier).  This set of equations is
  solved by evaluating the expressions $E_i$, assigning their value to
  the corresponding variables $V_i$, and repeating this as long as the
  value of one of the variables was changed. This is typically used for
  solving a set of dataflow equations.

\paragraph{Example}
Equations can be used to define the transitive closure of a relation.
Recall that \[R+ = R \cup (R \circ R) \cup (R \circ R \circ R) \cup ... .\]
This can be expressed as follows.

\begin{verbatim}
rel[int,int] R =  {<1,2>, <2,3>, <3,4>}

equations
  initial
     rel[int,int] T init R
  satisfy
     T = T union (T o R)
end equations
\end{verbatim}
The resulting value of {\tt T} is as expected:
\begin{verbatim}
 {<1,2>, <2,3>, <3,4>, <1, 3>, <2, 4>, <1, 4>}
\end{verbatim}


\section{Built-in Operators}
Now we give brief descriptions in tabular form of the various groups of operators.
Where appropriate, examples are given.

\subsection{Operations on Booleans} \label{BO:bool}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{bool}$_1$ \texttt{and} \emph{bool}$_2$ & yields {\tt true} if both arguments have the value true and
{\tt false} otherwise\\ \hline

\emph{bool}$_1$ \texttt{or} \emph{bool}$_2$ & yields {\tt true} if either argument has
                         the value {\tt true} and {\tt false} otherwise\\ \hline

\emph{bool}$_1$ \texttt{implies} \emph{bool}$_2$ & yields {\tt false} if
                             \emph{bool}$_1$ has the value {\tt true} and
                               \emph{bool}$_2$ has value {\tt false}, and
                         {\tt true} otherwise\\ \hline

{\tt not} \emph{bool} & yields true if \emph{bool} is {\tt false} and {\tt true} otherwise \\
\hline
\end{tabular}

\subsection{Operations on Integers} \label{BO:int}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{int}$_1$ {\tt ==} \emph{int}$_2$ & yields {\tt true} if both arguments are numerically equal and {\tt false}
otherwise\\ \hline

\emph{int}$_1$ {\tt !=} \emph{int}$_2$ & yields {\tt true} if both arguments are numerically unequal  and {\tt false}
otherwise\\ \hline

\emph{int}$_1$ {\tt <=} \emph{int}$_2$ & yields {\tt true} if \emph{int}$_1$ is numerically less than
or equal to \emph{int}$_2$ and {\tt false} otherwise\\ \hline

\emph{int}$_1$ {\tt <} \emph{int}$_2$ & yields {\tt true} if \emph{int}$_1$ is a numerically less than \emph{int}$_2$
and {\tt false} otherwise\\ \hline

\emph{int}$_1$ {\tt >=} \emph{int}$_2$ & yields {\tt true} if \emph{int}$_1$ is numerically greater
than or equal to \emph{int}$_2$  and {\tt false} otherwise\\ \hline

\emph{int}$_1$ {\tt >} \emph{int}$_2$ & yields {\tt true} if \emph{int}$_1$  is numerically greater than \emph{int}$_2$
and {\tt false} otherwise\\ \hline

\emph{int}$_1$ {\tt +} \emph{int}$_2$ & yields the arithmetic sum of
\emph{int}$_1$ and \emph{int}$_2$\\ \hline

\emph{int}$_1$ {\tt -} \emph{int}$_2$ & yields the arithmetic difference of
\emph{int}$_1$ and \emph{int}$_2$\\ \hline

\emph{int}$_1$ {\tt *} \emph{int}$_2$ & yields the arithmetic product of
\emph{int}$_1$ and \emph{int}$_2$\\ \hline

\emph{int}$_1$ {\tt /} \emph{int}$_2$ & yields the integer division of
\emph{int}$_1$ and \emph{int}$_2$ \\ \hline

\end{tabular}

\subsection{Operations on Strings} \label{BO:str}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline

\emph{str}$_1$ {\tt ==} \emph{str}$_2$ & yields {\tt true} if both arguments are equal and {\tt false}
otherwise\\ \hline

\emph{str}$_1$ {\tt !=} \emph{str}$_2$ & yields {\tt true} if both arguments are unequal  and {\tt false}
otherwise\\ \hline
\end{tabular}
\subsection{Operations on Areas} \label{BO:area}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{area}$_1$ {\tt ==} \emph{area}$_2$ & yields {\tt true} if both arguments
are identical and {\tt false}
otherwise\\ \hline

\emph{area}$_1$ {\tt !=} \emph{area}$_2$ & yields {\tt true} if both arguments are unequal  and {\tt false}
otherwise\\ \hline

\emph{area}$_1$ {\tt <=} \emph{area}$_2$ & yields {\tt true} if
\emph{area}$_1$ is textually contained in 
or equal to \emph{area}$_2$ and {\tt false} otherwise\\ \hline

\emph{area}$_1$ {\tt <} \emph{area}$_2$ & yields {\tt true} if \emph{area}$_1$
is strictly textually contained  in \emph{area}$_2$
and {\tt false} otherwise\\ \hline

\emph{area}$_1$ {\tt >=} \emph{area}$_2$ & yields {\tt true} if
\emph{area}$_1$ textually encloses or
or is equal to \emph{area}$_2$  and {\tt false} otherwise\\ \hline

\emph{area}$_1$ {\tt >} \emph{area}$_2$ & yields {\tt true} if \emph{area}$_1$
strictly textually encloses \emph{area}$_2$
and {\tt false} otherwise\\ \hline

\end{tabular}

\paragraph{Examples}

\begin{itemize}

 \item {\tt area("f", 11, 1, 11, 9)  < area("f", 10, 2, 12, 8)} yields {\tt
 true}.

 \item {\tt area("f", 10, 3, 11, 7)  < area("f", 10, 2, 11, 8)} yields {\tt
 true}.

 \item {\tt area("f", 10, 3, 11, 7)  < area("g", 10, 3, 11, 7)} yields {\tt
 false}.

\end{itemize}

\subsection{Operations on Bags or Relations} \label{BO:bag-or-rel}

\subsubsection{Membership Tests} \label{BO:member}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline

\emph{any} {\tt in} \emph{bag} & yields {\tt true} if \emph{any} occurs as element
in \emph{bag} and {\tt false} otherwise \\ \hline

\emph{any} {\tt notin} \emph{bag} & yields {\tt false} if \emph{any} occurs as
element in \emph{bag} and {\tt true} otherwise \\ \hline

\emph{tuple} {\tt in} \emph{rel} & yields {\tt true} if \emph{tuple} occurs as element in
\emph{rel}  and {\tt false} otherwise \\ \hline

\emph{tuple} {\tt notin} \emph{rel} & yields {\tt false} if \emph{tuple} occurs as
element in \emph{rel} and {\tt true} otherwise \\ \hline
\end{tabular}

\paragraph{Examples}

\begin{itemize}

\item {\tt 3 in \{1, 2, 3\}} yields {\tt true}.
\item {\tt 4 in \{1, 2, 3\}} yields {\tt false}.
\item {\tt 3 notin \{1, 2, 3\}} yields {\tt false}.
\item {\tt 4 notin \{1, 2, 3\}} yields {\tt true}.
\item {\tt <2,20> in \{<1,10>, <2,20>, <3,30>\}} yields {\tt true}.
\item {\tt <4,40> notin \{<1,10>, <2,20>, <3,30>\}} yields {\tt true}.

\end{itemize}

\paragraph{Note} If the first argument of these operators has type $T$, then
the second argument should have type {\tt bag[$T$]}.

\subsubsection{Comparisons} \label{BO:bag-comp}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{bag}$_1$ {\tt ==} \emph{bag}$_2$ & yields {\tt true} if both arguments are equal bags and {\tt false}
otherwise\\ \hline

\emph{bag}$_1$ {\tt !=} \emph{bag}$_2$ & yields {\tt true} if both arguments are unequal bags and {\tt false}
otherwise\\ \hline

\emph{bag}$_1$ {\tt <=} \emph{bag}$_2$ & yields {\tt true} if \emph{bag}$_1$ is a subset of \emph{bag}$_2$
and {\tt false} otherwise\\ \hline

\emph{bag}$_1$ {\tt <} \emph{bag}$_2$ & yields {\tt true} if \emph{bag}$_1$ is a
strict subset of \emph{bag}$_2$
and {\tt false} otherwise\\ \hline

\emph{bag}$_1$ {\tt >=} \emph{bag}$_2$ & yields {\tt true} if \emph{bag}$_1$  is a
superset of \emph{bag}$_2$
and {\tt false} otherwise\\ \hline

\emph{bag}$_1$ {\tt >} \emph{bag}$_2$ & yields {\tt true} if  \emph{bag}$_1$  is a strict superset of \emph{bag}$_2$
and {\tt false} otherwise\\ \hline 
\end{tabular}

\subsubsection{Construction} \label{BO:bag-cons}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline
\emph{bag}$_1$ {\tt union} \emph{bag}$_2$ & yields the bag resulting from the union of the two arguments.
The number of occurrences of each element in the result is the {\bf maximum} of the number of occurrences of that element
in \emph{bag}$_1$  and \emph{bag}$_2$.
 \\ \hline

\emph{bag}$_1$ {\tt inter} \emph{bag}$_2$ & yields the bag resulting from the intersection of the two arguments.
The number of occurrences of each element in the result is the {\bf minimum} of the number of occurrences of that element
in \emph{bag}$_1$  and \emph{bag}$_2$.
 \\ \hline

\emph{bag}$_1$ \verb+\+ \emph{bag}$_2$ & yields the bag resulting from the difference of the two arguments.
The number of occurrences of each element in the result is the {\bf difference} of the number of occurrences of that element
in \emph{bag}$_1$  and \emph{bag}$_2$.
 \\ \hline \hline

\end{tabular}

\paragraph{Examples}

\begin{itemize}
\item {\tt \{1, 2, 3\} union \{4, 5, 6\}} yields {\tt \{1, 2, 3, 4, 5, 6\}}.
\item  {\tt \{1, 2, 3\} union \{1, 2, 3\}} yields  {\tt \{1, 2, 3\}}.
\item {\tt \{1, 1, 2, 3\} union \{4, 4, 5, 6\}} yields {\tt \{1, 1, 2, 3, 4, 4, 5, 6\}}.

\item \item {\tt \{1, 2, 3\} inter \{4, 5, 6\}} yields {\tt \{ \}}.
\item  {\tt \{1, 1, 2, 3\} inter \{1, 2, 3\}} yields  {\tt \{1, 2, 3\}}.

\item  {\tt \{1, 1, 2, 3\}  \verb+\+ \{1, 2, 3\}} yields  {\tt \{1\}}.
\item {\tt \{1, 1, 2, 3\}  \verb+\+ \{4, 4, 5, 6\}} yields {\tt \{1, 1, 2, 3\}}.

\end{itemize}

\subsection{Operations on Relations} \label{BO:relations}

\begin{tabular}{|p{3.3cm}|p{10.7cm}|} \hline

\emph{rel}$_1$ {\tt o} \emph{rel}$_2$ & yields the relation resulting from the composition of the two arguments
 \\ \hline

\emph{bag}$_1$ {\tt x} \emph{bag}$_2$ & yields the relation resulting from the Cartesian product of the two arguments
 \\ \hline


\emph{bag}$_1$ {\tt .} \emph{bag}$_2$ & yields the left or right image of the
 two arguments (depending on their type)
 \\ \hline

\emph{bag}$_1$ {\tt [} \emph{bag}$_2$ {\tt ]} & yields the right image of {bag}$_1$
 \\ \hline


\emph{rel} {\tt +} & yields the relation resulting from the transitive closure of
 \emph{rel}  \\ \hline

\emph{rel} {\tt *}  & yields the relation resulting from the reflexive transitive closure of
 \emph{rel}  \\ \hline

\end{tabular}

\paragraph{Composition: {\tt o}}

The composition operator combines two relations and can be defined as follows:

\begin{verbatim}
rel[T1,T3] o(rel[T1,T2] R1, rel[T2,T3] R2) =
   {<V, Y> | <V, W> : R1, <X, Y> :  R2, W == X }
\end{verbatim}

\paragraph{Example}

\begin{itemize}
\item {\tt \{<1,10>, <2,20>, <3,15>\} o \{<10,100>, <20,200>\}} yields  {\tt \{<1,100>, <2,200>\}}.
\end{itemize}


\paragraph{Cartesian product: {\tt x}}
The product operator combines two bags into a relation and can be defined as
follows:

\begin{verbatim}
rel[T1,T2] x(bag[T1] B1, bag[T2] B2) = {<V, W> | V : B1, W : B2 }
\end{verbatim}

\paragraph{Example}
\begin{itemize}
\item {\tt \{1, 2, 3\} x \{9\}} yields {\tt \{<1, 9>, <2, 9>, <3, 9>\}}.
\end{itemize}

\paragraph{Left image: {\tt .}}

Taking the left image of a relation amounts to selecting
some elements from the domain of a relation.

The \emph{left} image operator takes a relation and an element {\tt E} and
produces a bag consisting of all elements {\tt E}$_i$ in the domain of the relation
that occur in tuples of the form {\tt <E, E$_i$>}. It can be defined as
follows:
\footnote{Strictly speaking, this is \emph{not} a legal \rscript since we do not
  allow {\tt .} as function name. The same applies to some of the following definitions.}

\begin{verbatim}
bag[T1] .(rel[T1,T2] R, T2 E) = { V | <V, W> : R, W == E }
\end{verbatim}

The left image operator can be extended to take a bag of elements as second
element instead of a single element:

\begin{verbatim}
bag[T1] .(rel[T1,T2] R, bag[T2] B) = { V | <V, W> : R, W in B }
\end{verbatim}

\paragraph{Examples}
Assume in the following examples that {\tt Rel} has value {\tt \{<1,10>, <2,20>, <1,11>, <3,30>, <2,21>\}}.
\begin{itemize}
\item {\tt Rel .~10} yields  {\tt \{1\}},
\item {\tt Rel .~\{10\}} yields  {\tt \{1\}}.
\item {\tt Rel .~\{10, 20\}} yields {\tt \{1, 2\}}.
\end{itemize}

\paragraph{Right image: {\tt .}}
Taking the right image of a relation amounts to selecting
some elements from the range of a relation.

The \emph{right} image operator takes an element {\tt E} and a relation and
produces a bag consisting of all elements {\tt E}$_i$ in the range of the relation
that occur in tuples of the form {\tt <E$_i$, E>}. It can be defined as
follows:

\begin{verbatim}
bag[T2] .(T1 E, rel[T1,T2] R) = { W | <V, W> : R, V == E }
\end{verbatim}

The right image operator can be extended to take a bag of elements as first
element instead of a single element:

\begin{verbatim}
bag[T2] .(bag[T1] B, rel[T1,T2] R) = { W | <V, W> : R, V in B}
\end{verbatim}

Since both versions of the right image operator occur so frequently, we also provide
a more intuitive alternative for it: 
\begin{itemize}
\item {\tt R [ E ]} is a shorthand for {\tt E .~R}, and
\item {\tt R [ B ]} is a shorthand for {\tt B .~R}.
\end{itemize}


\paragraph{Examples}
Assume in the following examples that {\tt Rel} has value {\tt \{<1,10>, <2,20>, <1,11>, <3,30>, <2,21>\}}.
\begin{itemize}
\item {\tt 1 .~Rel} yields {\tt \{10, 11\}}.
\item {\tt \{1\} .~Rel} yields {\tt \{10, 11\}}.
\item {\tt \{1, 2\} .~Rel} yields {\tt \{10, 11, 20, 21\}}.


\item {\tt Rel[1]} yields {\tt \{10, 11\}}.
\item {\tt Rel[\{1\}]} yields {\tt \{10, 11\}}.
\item {\tt Rel[\{1, 2\}]} yields {\tt \{10, 11, 20, 21\}}.

\end{itemize}



\section{Built-in Functions}

\tablecaption{Built-in functions}
\tablehead{\hline}
\tabletail{\hline}


\newcommand{\function}[5]{\subsection{#1: {\tt #2}}\label{BI:#2}
Definition:
\begin{quote}
#3
\end{quote}
#4
Example(s):
\begin{itemize}
#5
\end{itemize}
}

\function{Identity relation}{id}
{\tt rel[$T$,$T$] id(bag[$T$] B) = \{ <X, X> | X : B \}}
{Yields the relation that results from transforming
each element in {\tt B} into a pair with that element as first and
second element.
}
{
\item {\tt id(\{1,2,3\})} yields {\tt \{<1,1>, <2,2>, <3,3>\}}.
\item \begin{sloppypar} {\tt id(\{"mon", "tue", "wed"\}} yields {\tt \{<"mon","mon">,
  <"tue","tue">, <"wed","wed">\}}. \end{sloppypar}
}

\function{Domain of a relation}{domain}
{\tt bag[$T_1$] domain (rel[$T_1$,$T_2$] R) = \{ X | <X, Y> : R \}}
{Yields the bag that results from taking
the first element of each tuple in relation {\tt R}.
}
{
\item {\tt domain(\{<1,10>, <2,20>\})} yields {\tt \{1, 2\}}.
\item {\tt domain(\{<"mon", 1>, <"tue", 2>\})} yields {\tt \{"mon", "tue"\}}.

}

\function {Range of a relation}{range}
{\tt bag[$T_2$] range (rel[$T_1$,$T_2$] R) = \{ Y | <X, Y> : R \}}
{Yields the bag that results from taking
the second element of each tuple in relation {\tt R}.
}
{
\item {\tt range(\{<1,10>, <2,20>\})} yields {\tt \{10, 20\}}.
\item {\tt range(\{<"mon", 1>, <"tue", 2>\})} yields {\tt \{1, 2\}}.
}

\function {Carrier of a relation}{carrier}
{\tt bag[$T$]  carrier (rel[$T$,$T$] R) = domain(R) union range(R)}
{Yields the bag that results from taking
the first and  second element of each tuple in the relation {\tt R}.
Note that the domain and range type of {\tt R} should be the same.
}
{
\item {\tt carrier(\{<1,10>, <2,20>\})} yields {\tt \{1, 10, 2, 20\}}.
}

\function {Top of a relation}{top}
{\tt bag[$T$] top(rel[$T$, $T$] R) = domain(R) BACKSLASH range(R)}
{Yields the bag of all roots when the relation {\tt R} is
viewed as a graph. Note that the domain and range type of {\tt R} should be the same.
}
{
\item {\tt top(\{<1,2>, <1,3>, <2,4>, <3,4>\}} yields {\tt \{1\}}.
}

\function{Bottom of a relation}{bottom}
{\tt bag[$T$] bottom(rel[$T$,$T$] R) = range(R) BACKSLASH domain(R)}
{Yields the bag of all leaves when the relation {\tt R} is
viewed as a graph. Note that the domain and range type of {\tt R} should be
the same.
}
{
\item {\tt bottom(\{<1,2>, <1,3>, <2,4>, <3,4>\}} yields {\tt \{4\}}.
}

\function{Inverse of a relation}{inv}
{\tt rel[$T_2$,$T_1$] inv (rel[$T_1$,$T_2$] R) = \{ <Y, X> | <X, Y> : R \}}
{ Yields the relation that is the inverse of the
argument relation {\tt R}, i.e. the relation in which the elements of all
tuples in {\tt R} have been
interchanged.
}
{
\item {\tt inv(\{<1,10>, <2,20>\})} yields {\tt \{<10,1>,<20,2>\}}.
}
\function{Complement of a relation}{compl}
{\tt rel[$T_1$, $T_2$] compl(rel[$T_1$,$T_2$] R) = (domain(R) x range(R)) BACKSLASH R}
{ Yields the relation that is the complement of the
argument relation {\tt R}, using the carrier set of {\tt R} as universe.
}
{
\item {\tt compl(\{<1,10>\}}  yields {\tt \{<1, 1>, <10, 1>, <10, 10>\}}.
}

\function{Domain restriction of a relation}{domainR}
{\tt rel[$T_1$,$T_2$] domainR (rel[$T_1$,$T_2$] R, Bag[$T_1$] B) = \\
   \{ <X, Y> | <X, Y> : R, X in B \}}
{ Yields a relation identical to the relation {\tt R}
  but only containing tuples whose first element occurs in bag {\tt B}.
}
{
\item {\tt domainR(\{<1,10>, <2,20>, <3,30>\}, \{3, 1\}} yields {\tt \{<1,10>, <3,30>\}}.
}

\function{Range restriction of a relation}{rangeR}
{\tt rel[$T_1$,$T_2$] rangeR (rel[$T_1$,$T_2$] R, Bag[$T_2$] B) =  \\
   \{ <X, Y> | <X, Y> : R, Y in B \}}
{ Yields a relation identical to relation {\tt R} but only containing tuples
  whose second element occurs in bag {\tt B}.
}
{
 \item {\tt rangeR(\{<1,10>, <2,20>, <3,30>\}, \{30, 10\}} yields {\tt \{<1,10>, <3,30>\}}.
}

\function{Carrier restriction of a relation}{carrierR}
{\tt rel[$T$,$T$] carrierR (rel[$T$,$T$] R, Bag[$T$] B) = \\ 
   \{ <X, Y> | <X, Y> : R, X in B, Y in B \}}
{ Yields a relation identical to relation {\tt R}
  but only containing tuples whose first and second element occur in bag {\tt
    B}.
}
{
 \item {\tt carrierR(\{<1,10>, <2,20>, <3,30>\}, \{10, 1, 20\}} yields {\tt \{<1,10>\}}.
}

\function{Domain exclusion of a relation}{domainX}
{\tt rel[$T_1$,$T_2$] domainX (rel[$T_1$,$T_2$] R, Bag[$T_1$] B) = \\
   \{ <X, Y> | <X, Y> : R, X notin B \}}
{ Yields a relation identical to relation {\tt R}
  but with all tuples removed whose first element occurs in bag {\tt B}.}
{
\item {\tt domainX(\{<1,10>, <2,20>, <3,30>\}, \{3, 1\}} yields {\tt \{<2, 20>\}}.
}

\function{Range exclusion of a relation}{rangeX}
{\tt rel[$T_1$,$T_2$] rangeX (rel[$T_1$,$T_2$] R, Bag[$T_2$] B) = \\
	   \{ <X, Y> | <X, Y> : R, Y notin B \}}
{ Yields a relation identical to relation {\tt R} but with all tuples removed
  whose  second element occurs in bag {\tt B}.}
{
 \item {\tt rangeX(\{<1,10>, <2,20>, <3,30>\}, \{30, 10\}} yields {\tt \{<2, 20>\}}.
}

\function{Carrier exclusion of a relation}{carrierX}
{\tt rel[$T$,$T$] carrierX (rel[$T$,$T$] R, Bag[$T$] B) = \\
   \{ <X, Y> | <X, Y> : R, X notin B, Y notin B \}}
{ Yields a relation identical to relation {\tt R}
  but with all tuples removed whose first or second element occurs in bag {\tt
    B}.}
{
 \item {\tt carrierX(\{<1,10>, <2,20>, <3,30>\}, \{10, 1, 20\}} yields {\tt \{<3,30>\}}.
}

\function{First element of a tuple}{first}
{\tt $T_1$ first(<$T_1$, $T_2$> P) = primitive}
{ Yields the first element of the tuple {\tt P}.}
{
\item {\tt first(<1, 10>)} yields {\tt 1}.
\item {\tt first(<"mon", 1>)} yields {\tt "mon"}.
}

\function{Second element of a tuple}{second}
{\tt $T_2$ second(<$T_1$, $T_2$> P) = primitive}
{ Yields the second element of the tuple {\tt P}.}
{
\item {\tt second(<1, 10>)} yields {\tt 10}.
\item {\tt second(<"mon", 1>)} yields {\tt 1}.
}

\function{Reachability with restriction}{reachR}
{\tt rel[$T$,$T$] reachR( bag[$T$] Start, bag[$T$] Restr, rel[T,T] Rel) =\\
	       domainR(Rel, Start) o carrierR(Rel, Restr)+ }
{ Yields the relation that describes
which elements can be reached from  bag {\tt Start} using the relation {\tt Rel}, such that only elements in
bag {\tt Restr} are used.
}
{
\item  {\tt reachR(\{1\}, \{1, 2, 3\}, \{<1,2>, <1,3>, <2,4>, <3,4>\})} yields  {\tt
  \{<1,2>, <1, 3>\}}.
}

\function{Reachability with exclusion}{reachX}
{\tt rel[$T$,$T$] reachX( bag[$T$] Start, bag[$T$] Excl, rel[T,T] Rel) =\\
	       domainR(Rel, Start) o carrierX(Rel, Excl)+ }
{ Yields the relation that describes
which elements can be reached from  bag {\tt Start} using the relation {\tt Rel}, such that no elements in
bag {\tt Excl} are used.
}
{
\item  {\tt reachX(\{1\}, \{2\}, \{<1,2>, <1,3>, <2,4>, <3,4>\})} yields  {\tt
  \{<1,3>, <1, 4>\}}.
}

\function{Powerset of a bag}{power0}
{\tt bag[bag[$T$]] power0(bag[$T$] B) = primitive}
{ Yields the powerset of bag {\tt B} (including the empty bag).}
{
\item \begin{sloppypar} {\tt power0(\{1, 2, 3, 4})\} yields {\tt \{ \{\}, \{1\},
    \{2\}, \{3\}, \{4\},\{1,2\}, \{1,3\}, \{1,4\}, \{2,3\}, \{2,4\}, \{3,4\},
    \{1,2,3\}, \{1,2,4\}, \{1,3,4\}, \{2,3,4\}, \{1,2,3,4\}\}} \end{sloppypar}
}

\function{Powerset of a bag}{power1}
{\tt bag[bag[$T$]] power1(bag[$T$] B) = primitive}
{ Yields the powerset of bag {\tt B} (excluding the empty bag).}
{
\item \begin{sloppypar} {\tt power1(\{1, 2, 3, 4})\} yields {\tt \{ \{1\},
    \{2\}, \{3\}, \{4\},\{1,2\}, \{1,3\}, \{1,4\}, \{2,3\}, \{2,4\}, \{3,4\},
    \{1,2,3\}, \{1,2,4\}, \{1,3,4\}, \{2,3,4\}, \{1,2,3,4\}\}} \end{sloppypar}
}

\function{File name of an area}{filename}
{\tt str filename(area A) = primitive}
{Yields the file name of area {\tt A}.}
{  
\item {\tt filename(area("pico1.trm",5,2,6,8))} yields {\tt "pico1.trm"}.
}

\function{Beginning line of an area}{beginline}
{\tt int beginline(area A) = primitive}
{Yields the first line of area {\tt A}.}
{  
\item {\tt beginline(area("pico1.trm",5,2,6,8))} yields {\tt 5}.
}

\function{First column of an area}{begincol}
{\tt int begincol(area A) = primitive}
{Yields the first column of area {\tt A}.}
{  
\item {\tt begincol(area("pico1.trm",5,2,6,8))} yields {\tt 2}.
}

\function{Ending line of an area}{endline}
{\tt int endline(area A) = primitive}
{Yields the last line of area {\tt A}.}
{  
\item {\tt endline(area("pico1.trm",5,2,6,8))} yields {\tt 6}.
}

\function{Ending column of an area}{endcol}
{\tt int endcol(area A) = primitive}
{Yields the last column of area {\tt A}.}
{  
\item {\tt endcol(area("pico1.trm",5,2,6,8))} yields {\tt 8}.
}

\function{Sum of a bag of integers}{sum}
{\tt int sum(bag[int] B) = primitive}
{Yields the sum of the integers in bag {\tt B}.}
{
\item {\tt sum(\{1, 2, 3\})} yields {\tt 6}.
}

\function{Average of a bag of integers}{average}
{\tt int average(bag[int] B) = sum(B)/(\#B)}
{Yields the average of the integers in bag {\tt B}.}
{
\item {\tt average(\{1, 2, 3\})} yields {\tt 3}.
}

\function{Maximum of a bag of integers}{max}
{\tt int max(bag[int] B) = primitive}
{Yields the largest integer in bag {\tt B}.}
{
\item {\tt max(\{1, 2, 3\})} yields {\tt 3}.
}

\function{Minimum of a bag of integers}{min}
{\tt int min(bag[int] B) = primitive}
{Yields the smallest integer in bag {\tt B}.}
{
\item {\tt min(\{1, 2, 3\})} yields {\tt 1}.
}

\newpage

\section{Larger Examples}

\subsection{Analyzing the Call Structure of an Application}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/calls.eps,width=15cm}
\vspace*{-14cm}
\end{center}
\caption{\label{FIG:calls} Graphical representation of the {\tt calls} relation}
\end{figure}

Now we will explore the call structure of an application.
Suppose that the following facts have been extracted from the source
code and are represented by the relation {\tt calls}:

\begin{quote}
{\tt rel[str, str] calls = \{<"a", "b">, <"b", "c">, <"b", "d">, 
   <"d", "c">, <"d","e">, <"f", "e">, <"f", "g">, <"g", "e">\}}.
\end{quote}

A first step in the analysis is to determine some basic statistics
of the problem: how many calls and how many procedures are there?
To determine the numbers of calls, we simply determine the number of tuples
in the {\tt calls} relation, as follows:

\begin{quote}
{\tt int ncalls = \# calls}
\end{quote}
In this example, {\tt ncalls} will get the value {\tt 8}. 

We get the number of procedures by determining which names occur
in the tuples in the relation {\tt calls} and then determining the
number of names:

\begin{quote}
{\tt bag[str] procs = carrier(calls)\\
int nprocs = \# procs}
\end{quote}
{\tt procs} will get the value  {\tt \{"a" , "b", "c", "d", "e" , "f", "g"\}}
and {\tt nprocs} will thus get value {\tt 7}. A more concise way of expressing this
would be to combine both steps:
\begin{quote}
{\tt int nprocs = \# carrier(calls)}
\end{quote}

The next step in the analysis is to determine which \emph{entry points} this
application has, i.e., procedures which call others but are not called
themselves. Entry points are useful since they define the external interface
of a components and may also be used as guidance to split a component in
parts.

This can be done by determining the top of the
{\tt calls} relation:

\begin{quote}
{\tt bag[str] entryPoints = top(calls)}
\end{quote}

\noindent In this case, {\tt entryPoints} is equal to  {\tt \{"a", "f"\}}.
In other words, procedures {\tt "a"} and {\tt "f"}} are the entry points
of this application.

In a similar spirit, we can determine the \emph{leaves} of this application,
i.e., procedures that are being called but do not make any calls themselves:

\begin{quote}
{\tt bag[str] bottomCalls = bottom(calls)}.
\end{quote}
In this case, {\tt bottomCalls} is equal to  {\tt \{"c", "e"\}}.

We can also determine the \emph{indirect calls} between procedures, by
taking the transitive closure of the {\tt calls} relation:

\begin{quote}
{\tt rel[str,str] closureCalls = calls+}
\end{quote}
In this case, {\tt closureCalls} is equal to
\begin{quote}
	{\tt \{<"a", "b">, <"b", "c">, <"b", "d">, <"d", "c">, 
	<"d","e">, <"f", "e">, <"f", "g">, <"g", "e">, 
	<"a", "c">, <"a", "d">, <"b", "e">, <"a", "e">\}}
\end{quote}

We know now the entry points for this application ({\tt "a"} and {\tt "f"}) and the indirect call
relations. Combining this information, we can determine which procedures are
called from each entry point:
\begin{quote}
{\tt bag[str] calledFromA = closureCalls["a"]}
\end{quote}
yields {\tt \{"b", "c", "d", "e"\}} and
\begin{quote}
{\tt bag[str] calledFromF = closureCalls["f"]}
\end{quote}
yields {\tt  \{"e", "g"\}}.
Finally, we can determine which procedures are called from both entry points:
\begin{quote}
{\tt bag[str] commonProcs = calledFromA inter calledFromF}
\end{quote}
which yields {\tt \{"e"\}}. In other words, the procedures called from both
entry
points are mostly disjoint except for the common procedure  {\tt \{"e"\}}.

These findings can be verified by inspecting a graph view of the calls
relation as shown in Figure~\ref{FIG:calls}.  Such a visual inspection does
\emph{not} scale very well to large graphs and this makes the above form of
analysis particularly suited for studying large systems.

\subsection{Analyzing the Structure of Java Systems}

\begin{figure}[tb]
{\small
\begin{verbatim}
package CH.ifa.draw.standard;

import java.awt.Point;
import CH.ifa.draw.framework.*;
/**
 * A LocatorHandle implements a Handle by delegating the location requests to
 * a Locator object.
 */
public class LocatorHandle extends AbstractHandle {
    private Locator       fLocator;
    /**
     * Initializes the LocatorHandle with the given Locator.
     */
    public LocatorHandle(Figure owner, Locator l) {
        super(owner);
        fLocator = l;
    }
    /**
     * Locates the handle on the figure by forwarding the request
     * to its figure.
     */
    public Point locate() {
        return fLocator.locate(owner());
    }
}
\end{verbatim} }
\caption{\label{FIG:LocatorHandle}The class {\tt LocatorHandle} fron JHotDraw 5.2}
\end{figure}

Now we consider the analysis of Java systems (inspired by \cite{BNL03}).
Suppose the following relations are available about a Java application:

\begin{itemize}

\item {\tt rel[str,str] CALL}: If {\tt <C$_1$, C$_2$>} is an element of {\tt CALL}, then
some method of {\tt C$_2$} is called from {\tt C$_1$}.

\item {\tt rel[str,str] INHERITANCE}: If {\tt <C$_1$, C$_2$>} is an element of {\tt INHERITANCE},
then class {\tt C$_1$} either extends class {\tt C$_2$} or {\tt C$_1$}
implements interface {\tt C$_2$}.

\item {\tt rel[str,str] CONTAINMENT}: If {\tt <C$_1$, C$_2$>} is an element of {\tt CONTAINMENT},
then one of the attributes of class  {\tt C$_1$} is of type {\tt C$_2$}.

\end{itemize}

To make this more explicit, consider the class {\tt LocatorHandle} from the
JHotDraw application (version 5.2) as shown in Figure~\ref{FIG:LocatorHandle}.
It leads to the addition to the above relations of the following tuples:

\begin{itemize}
\item {\tt CALL}: {\tt <"LocatorHandle", "AbstractHandle">} and {\tt <"LocatorHandle", "Locator">}.
\item {\tt INHERITANCE}:     {\tt <"LocatorHandle",  "AbstractHandle">}.
\item {\tt CONTAINMENT}:     {\tt <"LocatorHandle",  "Locator">}.
\end{itemize}

\paragraph{Classes in Cycles}
Cyclic structures in object-oriented systems makes understanding hard.
Therefore it is interesting to spot classes that occur as part of a cyclic
dependency.  Here we determine cyclic uses of classes that include calls,
inheritance and containment. This is achieved as follows:

\begin{quote}
{\tt rel[str,str] USE = CALL union CONTAINMENT union INHERITANCE\\
bag[str] ClassesInCycle = \{C1 | <C1, C2> : USE+, C1 == C2\}}
\end{quote}
First, we define the {\tt USE} relation as the union of the three avalaible
relations {\tt CALL}, {\tt CONTAINMENT} and {\tt INHERITANCE}. Next, we consider all
pairs {\tt <C1, C2>} in the transitive closure of the {\tt USE} relation such
{\tt C1} and {\tt C2} are equal.  Those are precisely the cases of a class with a cyclic
dependency on itself.

Probably, we do not only want to know which classes occur in a cyclic
dependency, but we also want to know which classes are involved in such a
cycle. In other words, we want to associate with each class a bag of classes
that are responsible for the cyclic dependency. This can be done as follows.

\begin{quote}
{\tt  rel[str,str] USE = CALL union CONTAINMENT union INHERITANCE\\
bag[str] CLASSES = carrier(USE)\\
rel[str,str] USETRANS = USE+\\
rel[str,bag[str]] ClassCycles = \\
\hspace*{1cm}\{<C, USETRANS[C]> | C : CLASSES, <C, C> in USETRANS \}}
\end{quote}
First, we introduce two new shorthands: {\tt CLASSES} and {\tt USETRANS}.  Next,
we consider all classes {\tt C} with a cyclic dependency and add the pair {\tt
<C, USETRANS[C]>} to the relation {\tt ClassCycles}.  Note that {\tt
USETRANS[C]} is the right image of the relation {\tt USETRANS} for element
{\tt C}, i.e., all classes that can be called transitively from class {\tt C}.





\subsection{Finding Uninitialized Variables in a Program}

Consider the following program in the toy language Pico:
\footnote{This is an extended version of the example presented earlier
  in~\cite{KlintIWPC03}.}

\begin{verbatim}
[ 1] begin declare x : natural, y : natural,
[ 2]              z : natural, p : natural;
[ 3]  x := 3;
[ 4]  p := 4;
[ 5]  if q then
[ 6]        z := y + x
[ 7]  else
[ 8]        x := 4
[ 9]  fi;
[10]  y := z
[11] end
\end{verbatim}

Inspection of this program learns that some of the variables are being used
before they have been initialized.  The variables in question are {\tt q}
(line 5), {\tt y} (line 6), and {\tt z} (line 10). How can we automate this
analysis?

Recall from Section~\ref{SEC:Introduction} that we follow extract-enrich-view
paradigm to approach such a problem.

The first step is to determine which elementary facts we need about the
program.  For this and many other kinds of program analysis, we need at least
the following:

\begin{itemize}
\item The \emph{control flow graph} of the program. We represent it by a relation
{\tt PRED} (for predecessor) which relates each statement with each
predecessors.

\item The \emph{definitions} of each variable, i.e., the program statements where a
  value is assigned to the variable. It is represented by the relation {\tt
  DEFS}.

\item The \emph{uses} of each variable, i.e., the program statements where the
  value of the variable is used.  It is represented by the relation {\tt
  USES}.
\end{itemize}

In this example, we will use line numbers to identify the statements in the
program.\footnote{In Section~\ref{SEC:UsingAreas}, we will use areas to represent statements.}

Assuming that there is a tool to extract the above information from a program text,
we get the following for the above example:

\begin{verbatim}
int ROOT = 1
rel[int,int] PRED = {<1,3>, <3,4>, <4,5>, <5,6>, <5,8>, <6,10>, <8,10>}
rel[int,str] DEFS = {<3,"x">, <4,"p">, <6,"z">, <8,"x">, <10,"y">}
rel[int,str] USES = {<5,"q">, <6,"y">, <6,"x">, <10,"z">}
\end{verbatim}

This concludes the extraction phase. Next, we have to enrich these basic
facts to obtain the unitialized variables in the program. 

So, when is a variable \emph{V} in some statement \emph{S} unitialized?  If we
execute the program (starting in {\tt ROOT}), there may be several possible
execution path that can reach statement \emph{S}.  All is well if \emph{all}
these execution path contain a definition of \emph{V}.  However, if one or
more of these path do \emph{not} contain a definition of \emph{V}, then
\emph{V} may be uninitialized in statement \emph{S}. This can be formalized as
follows:
\begin{verbatim}
rel[str,int] UNINIT = 
   { <V,S> | <V, S>: USES, <ROOT, S> in reachX({ROOT}, DEFS[V], PRED)
   }
rel[int,str] UNINIT = 
   { <S, V> | <S, V>: USES, <ROOT, S> in reachX({ROOT}, DEFS . V, PRED)
    }
\end{verbatim}

\noindent We analyze this definition in detail:
\begin{itemize}
\item {\tt <S, V> : USES} enumerates all tuples in the {\tt USES} relation.
In other words, we consider the use of each variable in turn.

\item {\tt <ROOT, S> in reachX({ROOT}, DEFS . V, PRED)} is a test that
  determines whether statement {\tt S} is reachable from the {\tt ROOT}
  without encountering a definition of variable {\tt V}.
  \begin{itemize}
    \item {\tt \{ROOT\}} represents the initial set of nodes from which all
    path should start.
    \item {\tt DEFS . V} yields the set of all statements in which a definition
    of variable {\tt V} occurs. These nodes form the eXclusion set for
    {\tt reachX}: no path will be extended beyond an element in this set.
    \item {\tt PRED} is the relation for which the reachability has to be
    determined.
    \item The result of  {\tt reachX({ROOT}, DEFS . V, PRED)} is a relation
    that contains all pairs of nodes that are reachable from the
    {\tt ROOT} (as well as all intermediate steps on each path).
    \item Finally, {\tt <ROOT, S> in reachX({ROOT}, DEFS . V, PRED)} tests
    whether statement {\tt S} can be reached from the {\tt ROOT}.
  \end{itemize}
\item The net effect is that {\tt UNINIT} will only contain pairs
that satisfy the test just described.
\end{itemize}

When we execute the resulting \rscript (i.e., the declarations of {\tt ROOT},
{\tt PRED}, {\tt DEFS}, {\tt USES} and {\tt UNINIT}), we get as value
for {\tt UNINIT}:

\begin{verbatim}
 {<5, "q">, <6, "y">, <10, "z">}
\end{verbatim}
and this is in concordance with the informal analysis given at the beginning of this
example.

As a bonus, we can also determine the \emph{unused} variables in a
program, i.e., variables that are defined but are used nowhere.
This is done as follows:
\begin{verbatim}
bag[str] UNUSED = range(DEFS) \ range(USES)
\end{verbatim}
Taking the range of the relations {\tt DEFS} and {\tt USES} yields the
variables that are defined, respectively, used in the program. The difference
of these two bags yields the unused variables, in this case {\tt \{"p"\}}.

\subsection{Using Areas to Represent Program Fragments}\label{SEC:UsingAreas}

One aspect of the example we have just seen is artificial: where do these
line numbers come from that we used to indicate statements in the program?
One solution is to let the extraction phase generate \emph{area}s
to precisely indicate relevant places in the program text.

Recall from Section~\ref{SEC:ElementaryTypes}, that an area is 5-tuple
consisting of a file name, a begin line, a begin position, an end line, and an
end position. By including areas in the final answer of a relational
expression, external tools will be able to highlight places of interest in the
source text. In a first appoximation, the relations

\begin{quote}
{\tt 
int ROOT
rel[int,int] PRED\\
rel[int,str] DEFS\\
rel[int,str] USES}
\end{quote}
can be replaced by relations

\begin{quote}
{\tt area ROOT
rel[area,area] PRED
rel[area,str] USES
rel[area,str] DEFS}
\end{quote}

%%rel[<area,str>,area] USE_OCCURS
%%rel[<area,str>,area] DEF_OCCURS


%%rel[str,area] occurrences(<area,str> S) = {second(S)} x USE_OCCURS[S]

%%rel[str,area] UNINIT =
%%  { occurrences(<N,V>) | <N, V> : USES, <ROOT, N> in reachX({ROOT}, DEFS . V, PRED)
%%  }




\subsection{Dataflow Analysis}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/reach.eps,width=10cm}
\vspace*{-6cm}
\end{center}
\caption{\label{FIG:reach} Flow graph for reaching definitions}
\end{figure}

\emph{Dataflow analysis} is a program analysis technique that forms the basis
for many compiler optimizations. It is described in any text book on compiler
construction, e.g. \cite{ASU86}. The goal of dataflow analysis is to determine
the effect of statements on their surroundings. Typical examples are:
\begin{itemize}
\item Reaching definitions: which definitions of variables are still valid at each statement?
\item Available expressions: an expression is available if it is computed
  along each path from the start of the program to the current statement.
\item Live variables: of which variables will the values be used by successors
  of a statement?
\item and more.
\end{itemize}

\subsubsection{Reaching Definitions}

We illustrate the calculation of reaching definitions using the example in
Figure~\ref{FIG:reach} which was inspired by \cite[Example 10.15]{ASU86}.

As before, we assume the following basic relations {\tt PRED}, {\tt DEFS} and
{\tt USES} about the program:
\begin{verbatim}
rel[int,int] PRED = { <1,2>, <2,3>, <3,4>, <4,5>, <5,6>, <5,7>, <6,7>, 
                      <7,4>}
rel[int, str] DEFS = { <1, "i">, <2, "j">, <3, "a">, <4, "i">, 
                       <5, "j">, <6, "a">, <7, "i">}
rel[int, str] USES = { <1, "m">, <2, "n">, <3, "u1">, <4, "i">, 
                       <5, "j">, <6, "u2">, <7, "u3">}
\end{verbatim}

For convenience, we first revamp these basic relations into a more convenient
format:
\begin{verbatim}
rel[int, <int, str>] DEF = {<S, <S, V>> | <S, V> : DEFS}
rel[int, <int, str>] USE = {<S, <S, V>> | <S, V> : USES}
\end{verbatim}
The new {\tt DEF} relation gets as value:
\begin{verbatim}
 {<1, <1, "i">>, <2, <2, "j">>, <3, <3, "a">>, <4, <4, "i">>, 
  <5, <5, "j">>, <6, <6, "a">>, <7, <7, "i">>
\end{verbatim}
and {\tt USE} gets as value:
\begin{verbatim}
{<1, <1, "m">>, <2, <2, "n">>, <3, <3, "u1">>, <4, <4, "i">>, 
 <5, <5, "j">>, <6, <6, "u2">>, <7, <7, "u3">>}
\end{verbatim}

Now we are ready to define an important new relation {\tt KILL}.
{\tt KILL} defines which variable definitions are undone (killed) at each
 statement and is defined as follows:
\begin{verbatim}
rel[int, <int, str>] KILL = 
   {<S1, <S2, V2>> | <S1, V1> : DEFS, <S2, V2> : DEFS, 
                     V1 == V2, S1 != S2}
\end{verbatim}
In this definition, all variable definitions are compared with each other,
and for each variable definition all \emph{other} definitions of the same variable
are placed in its kill set. In the example, {\tt KILL} get the value
and yields as value
\begin{verbatim}
{<1, <4, "i">>, <1, <7, "i">>, <2, <5, "j">>, <3, <6, "a">>, 
 <4, <1, "i">>, <4, <7, "i">>, <5, <2, "j">>, <6, <3, "a">>, 
 <7, <1, "i">>, <7, <4, "i">>}
\end{verbatim}
and, for instance, the definition of variable {\tt i} in statement
{\tt 1} kills the definitions of {\tt i} in statements {\tt 4} and {\tt 7}.
Next, we introduce two convenience variables:
\begin{verbatim}
bag[int] STATEMENTS = carrier(PRED)
\end{verbatim}
which gets as value {\tt \{1, 2, 3, 4, 5, 6, 7\}} and
\begin{verbatim}
rel[int,int] PRED-OF = inv(PRED)
\end{verbatim}
which gets as value
\begin{verbatim}
{<2,1>, <3,2>, <4,3>, <5,4>, <6,5>, <7,5>, <7,6>, <4,7>}
\end{verbatim}

After these preparations, we are ready to formulate the reaching definitions
problem in terms of two relations {\tt IN} and {\tt OUT}.  {\tt IN} captures
all the variable definitions that are valid at the entry of each statement and
{\tt OUT} captures the definitions that are still valid after execution of
each statement. Intuitively, for each statement {\tt S}, {\tt IN[S]} is equal to
the union of the {\tt OUT} of all the predecessors of {\tt S}.
{\tt OUT[S]}, on the other hand, is equal to the definitions generated by
{\tt S} to which we add {\tt IN[S]} minus the definitions that are killed
in {\tt S}. Mathematically, the following set of equations captures this idea
for each statement:

\[
IN[S] = \bigcup_{P \in predecessor of S} OUT[P] \]
\[ OUT[S] = DEF[S] \cup (IN[S] - KILL[S]) \]

\noindent This idea can be expressed in \rscript quite literally:

\begin{verbatim}
equations
  initial
    rel[int,<int,str>] IN init {}
    rel[int,<int,str>] OUT init DEF
  satisfy
    IN  =  {{S} x OUT[P] | S : STATEMENTS, P : PRED-OF[S]}
    OUT =  {{S} x (DEF[S] union (IN[S] \ KILL[S])) | S : STATEMENTS }
end equations
\end{verbatim}
First, the relations {\tt IN} and {\tt OUT} are declared and initialized. Next, 
two equations are given that very much resemble the ones given above.
The Cartesian product operator {\tt x} is used, to combine each statement
with the relevant {\tt IN} or {\tt OUT} information.
For our running example (Figure~\ref{FIG:reach}) the results are as follows.
Relation {\tt IN} has as value:
\begin{verbatim}
{<2, <1, "i">>, <3, <2, "j">>, <3, <1, "i">>, <4, <3, "a">>, 
 <4, <2, "j">>, <4, <1, "i">>, <4, <7, "i">>, <4, <5, "j">>, 
 <4, <6, "a">>, <5, <4, "i">>, <5, <3, "a">>, <5, <2, "j">>, 
 <5, <5, "j">>, <5, <6, "a">>, <6, <5, "j">>, <6, <4, "i">>, 
 <6, <3, "a">>, <6, <6, "a">>, <7, <5, "j">>, <7, <4, "i">>, 
 <7, <3, "a">>, <7, <6, "a">>}
\end{verbatim}
If we consider statement {\tt 3}, then the definitions of {\tt i} and {\tt j}
from the preceding two statements are still valid. A more interesting case
are the definitions that can reach statement {\tt 4}:
\begin{itemize}
\item  The definitions of variables {\tt a}, {\tt j} and {\tt i} from,
  respectively, statements {\tt 3}, {\tt 2} and {\tt 1}.

\item The definition of variable {\tt i} from statement {\tt 7} (via the
  backward control flow path from {\tt 7} to {\tt 4}).

\item The definition of variable {\tt j} from statement{\tt 5} (via the path
  {\tt 5}, {\tt 7}, {\tt 4}).
\item The definition of variable {\tt a} from statement {\tt 6} (via the path
 {\tt 6}, {\tt 7}, {\tt 4}).
\end{itemize}

Relation {\tt OUT} has as value:
\begin{verbatim}
{<1, <1, "i">>, <2, <2, "j">>, <2, <1, "i">>, <3, <3, "a">>, 
 <3, <2, "j">>, <3, <1, "i">>, <4, <4, "i">>, <4, <3, "a">>, 
 <4, <2, "j">>, <4, <5, "j">>, <4, <6, "a">>, <5, <5, "j">>, 
 <5, <4, "i">>, <5, <3, "a">>, <5, <6, "a">>, <6, <6, "a">>, 
 <6, <5, "j">>, <6, <4, "i">>, <7, <7, "i">>, <7, <5, "j">>, 
 <7, <3, "a">>, <7, <6, "a">>}
\end{verbatim}
Observe, again for statement {\tt 4}, that
all definitions of variable  {\tt i} are missing in {\tt OUT[4]} since
they are killed by the definition of {\tt i} in statement {\tt 4} itself. Definitions for
{\tt a} and {\tt j} are, however, contained in {\tt OUT[4]}.

\subsubsection{Live Variables}

\note{To be done}

\subsubsection{Others}
\note{Some ideas:
\begin{itemize}
\item Dominator tree
\item McCabe complexity
\end{itemize}
}

\section{Running a \rscript}
Currently, the definition of \rscript resides in the CWI cvs repository {\tt /ufs/glt/CVS}.
You can checkout your own copy by means of
{\tt cvs -d ssh.cwi.nl:/ufs/glt/CVS co relation-calculus} (provided that you have an account at CWI).
Otherwise you have to obtain a {\tt tar.gz} file of the relation calculus.

\paragraph{Running a script}
\begin{itemize}
\item Change to your checked out copy of the directory {\tt relation-calculus}.
\item Start the ASF+SDF Meta-Environment with the command {\tt meta}.
\item Open the module {\tt Rscript.sdf}.
\item Open your own term, using the Rscript module.
\item Observe that a new menu with the name {\tt Rscript} appears in the menu bar.
\item Click the parse button in the {\tt Actions} menu of the editor:
now we know whether there are syntax errors. If so, correct them.

\item Click the {\tt Check} button in the {\tt Rscript} menu: this will
  perform a type check of your script. If there are type errors, correct them.

\item Click the {\tt Run} button in the {\tt Rscript} menu to execute your script: a new
editor pops up which shows all the variables at the end of the execution.
{\tt Run} also performs a type of your script so you may skip the previous step.

\item Click the {\tt Run with Rstore} button if you want to execute your
  \rscript with an existing ``Rstore'': a collection of relations that are the
  result of previous extraction phase. Currently, a fixed name is used for
  this Rstore: {\tt RSTORE.rstore}.

\end{itemize}

\paragraph{Running a Test suite} \label{running}
Same as above but use {\tt Testsuite} button instead of the {\tt Execute}
button in the {\tt Rscript} menu.  The effect is that the script is executed
and that a summary is printed of {\tt assert} statement that succeeded or
failed.

\paragraph{Miscellaneous}
The subdirectory {\tt rscripts} contains several sample scripts.  See {\tt
tests1.rscript} and {\tt tests2.rscript} for examples of the use of built-in
operators and functions.

The subdirectory {\tt demo} contains larger demos.

\section{Differences with Previous Versions}
\rscript is in under active development and several (incompatible)  changes
have been made in the last few weeks. Here is an indicative list.

\begin{itemize}

\item The syntax of comprehension has been changed. Old
\begin{verbatim}
  { <X, Y> : <X, Y> in R | X in B and Y  in B }
\end{verbatim}
New:
\begin{verbatim}
  { <X, Y> | <X, Y> : R, X in B and Y in B }
\end{verbatim}

\item The type {\tt node} has been renamed into {\tt area}

\end{itemize}

\section*{Acknowledgements}
Taeke Kooiker

\appendix

\section{Tables of Built-in Operators}


\begin{center}
\begin{supertabular}{|l|l|l|}
\tablecaption{Built-in operators}
\tablehead{\hline}
\tabletail{\hline}
{\bf Operator} & {\bf Description} & {\bf Section} \\ \hline \hline
{\tt and} & Boolean and & \ref{BO:bool}\\
{\tt implies} & Boolean implication & \ref{BO:bool}\\
{\tt in}    & Membership test on bags/relations& \ref{BO:bag-or-rel}\\
{\tt inter} & Intersection of bags/relations& \ref{BO:bag-or-rel}\\
{\tt not} & Boolean negation & \ref{BO:bool}\\
{\tt notin} & Non-membership test on bags/relations& \ref{BO:bag-or-rel}\\
{\tt or} & Boolean or & \ref{BO:bool}\\
{\tt union} & Union of bags/relations& \ref{BO:bag-or-rel}\\
{\tt ==}  & Equality of integers & \ref{BO:int}\\
{\tt ==}  & Equality of areas & \ref{BO:area}\\
{\tt ==}  & Equality of bags/relations & \ref{BO:bag-or-rel}\\

{\tt !=}  & Inequality of integers & \ref{BO:int}\\
{\tt !=}  & Inequality of strings & \ref{BO:str}\\
{\tt !=}  & Inequality of areas & \ref{BO:area}\\
{\tt !=}  & Inequality of bags/relations & \ref{BO:bag-or-rel}\\

{\tt <=}  & Less than or equal of integers & \ref{BO:int}\\
{\tt <=}  & Textual inclusion of areas & \ref{BO:area}\\
{\tt <=}  & Subset of bags/relations & \ref{BO:bag-or-rel}\\

{\tt <}  & Less than of integers & \ref{BO:int}\\
{\tt <}  & Strict textual inclusion of areas & \ref{BO:area}\\
{\tt <}  & Strict subset of bags/relations & \ref{BO:bag-or-rel}\\

{\tt >=}  & Greater than or equal of integers & \ref{BO:int}\\
{\tt >=}  & Textual containment of areas & \ref{BO:area}\\
{\tt >=}  & Superset of bags/relations & \ref{BO:bag-or-rel}\\

{\tt >}  & Greater than of integers & \ref{BO:int}\\
{\tt >}  & Strict textual containment of areas & \ref{BO:area}\\
{\tt >}  & Strict superset of bags/relations & \ref{BO:bag-or-rel}\\

{\tt +}  & Addition of integers & \ref{BO:int}\\
{\tt -}  & Subtraction of integers & \ref{BO:int}\\
{\tt *}  & Multiplication of integers & \ref{BO:int}\\
{\tt /}  & Division of integers & \ref{BO:int}\\

\verb+\+   & Difference of bags/relations & \ref{BO:bag-or-rel}\\

{\tt o}    & Composition of relations  & \ref{BO:relations}\\
{\tt x}    & Carthesian product of bags & \ref{BO:relations}\\

{\tt .}    & Left/right image of bags/relations & \ref{BO:relations}\\
{\tt [ ]}  & Right image of bags/relations & \ref{BO:relations}\\

{\tt +}    & Transitive closure of a relation  & \ref{BO:relations}\\
{\tt *}    & Reflexive transitive closure of a relation  & \ref{BO:relations}\\ \hline

\end{supertabular}
\end{center}

\section{Tables of Built-in Functions}

\tablecaption{Built-in functions}
\tablehead{\hline}
\tabletail{\hline}

\begin{center}
\begin{supertabular}{|l|l|l|}

{\bf Function}    & {\bf Description}   & {\bf Section} \\ \hline \hline

{\tt average}     & Average of a bag of integers & \ref{BI:average} \\
{\tt begincol}    & First column of an area & \ref{BI:begincol}\\
{\tt beginline}   & Beginning line of an area & \ref{BI:beginline}\\
{\tt bottom}      & Bottom of a relation & \ref{BI:bottom} \\
{\tt carrier}     & Carrier of a relation & \ref{BI:carrier} \\
{\tt carrierR}    & Carrier restriction of a relation & \ref{BI:carrierR} \\
{\tt carrierX}    & Carrier exclusion of a relation & \ref{BI:carrierX} \\

{\tt compl}       & Complement of a relation & \ref{BI:compl} \\
{\tt endcol}      & Last column of an area & \ref{BI:endcol}\\
{\tt endline}     & Ending line of an area & \ref{BI:endline}\\
{\tt filename}    & File name of an area & \ref{BI:filename}\\
{\tt first}       & First element of a tuple & \ref{BI:first} \\
{\tt id}          & Identity relation & \ref{BI:id} \\
{\tt inv}         & Inverse of a relation & \ref{BI:inv} \\

{\tt domain}      & Domain of a relation & \ref{BI:domain} \\
{\tt domainR}     & Domain restriction of a relation & \ref{BI:domainR} \\
{\tt domainX}     & Domain exclusion of a relation & \ref{BI:domainX} \\
{\tt min}         & Minimum of a bag of integers & \ref{BI:max} \\
{\tt max}         & Maximum of a bag of integers & \ref{BI:max} \\
{\tt power0}      & Powerset of a bag & \ref{BI:power0} \\
{\tt power1}      & Powerset of a bag & \ref{BI:power1} \\

{\tt range}       & Range of a relation  & \ref{BI:range} \\
{\tt rangeR}      & Range restriction of a relation & \ref{BI:rangeR} \\
{\tt rangeX}      & Range exclusion of a relation & \ref{BI:rangeX} \\
{\tt reachR}      & Reachability with restriction & \ref{BI:reachR} \\
{\tt reachX}      & Reachability with exclusion& \ref{BI:reachX} \\

{\tt second}      & Second element of a tuple & \ref{BI:second} \\
{\tt sum}         & Sum of a bag of integers & \ref{BI:sum} \\
{\tt top}         & Top of a relation & \ref{BI:top} \\

\end{supertabular}
\end{center}

\bibliographystyle{plain}
\bibliography{tutorial}
\end{document}
