 equations

%%---- Store

[VL1]   value(Var, [<Var, Val>, VPair*]) = Val
[VL2]   Var != Var' ===> value(Var, [<Var', Val>, VPair*]) = value(Var, [VPair*])

[ASG1]  assign(Var, Val, [VPair*]) = [<Var, Val>, VPair*]

[add1]  add(Var, Val1, [<Var, Val2>, VPair*]) = [<Var, apply(Val1 union Val2)>, VPair*]
[add2]  Var != Var' ===> add(Var, Val1, [<Var', Val2>, VPair*]) = add(Var, Val1, [VPair*])
[add3]  add(Var, Val, []) = [<Var, Val>]

%%---- if

[if1]  if true then Val1 else Val2 fi  = Val1
[if2]  if false then Val1 else Val2 fi = Val2

%%---- Equality on elements

[e1]   equal(E, E)  = true
[default-e2] 
       equal(E, E') = false

%%---- 

[EVP]  Bool = evalx(Exp, Store)
       ==================================================
       evalp(Exp, Store) = Bool

[EVE]  E = evalx(Exp, Store)
       ==================================================
       evale(Exp, Store) = E

[EVB1] Bag = evalx(Exp, Store)
       ==================================================
       evalb(Exp, Store) = Bag

[EVB2] *empty* = evalx(Exp, Store)
       ==================================================
       evalb(Exp, Store) = {}

[EVR1] Rel = evalx(Exp, Store)
       ==================================================
       evalr(Exp, Store) = Rel

[EVR1] *empty* = evalx(Exp, Store)
       ==================================================
       evalr(Exp, Store) = {}

%% ---- Eval script

[ES1]  eval(Stat*) = eval1(Stat*, [])

[ES2]  eval1(Stat Stat*, Store) = eval1(Stat*, eval(Stat, Store))
[ES3]  eval1( , Store) = Store

%% ---- Eval statements

[S1]  eval(def Var = Exp, Store) = assign(Var, evalx(Exp, Store), Store)

[S3]   eval(fun Var1(Var2) = Exp, Store) = assign(Var1, <Var2, Exp>, Store)

[S7]   eval(fun Var1(Var2, Var3) = Exp, Store) = assign(Var1, <Var2, Var3, Exp>, Store)

%% ---- Eval elementary predicates

[Pt]   evalx(true, Store) = true

[Pf]   evalx(false, Store) = false

[Pa]   evalx(Exp1 and Exp2, Store) =  evalp(Exp1, Store) & evalp(Exp2, Store)

[Pb]   evalx(Exp1 or Exp2, Store) = evalp(Exp1, Store) | evalp(Exp2, Store)

[Pn]   evalx(not Exp, Store) =  not(evalp(Exp, Store))

%% ---- Eval other predicates

[EQ1]  evalx(Exp1 == Exp2, Store) = apply(evalx(Exp1, Store) == evalx(Exp2, Store))

[EQ2]  apply(Bag1 == Bag2) = Bag1 == Bag2
[EQ3]  apply(Rel1 == Rel2) = Rel1 == Rel2
[EQ4]  apply(E1   == E2)   = equal(E1, E2)

[LE1]  evalx(Exp1 <= Exp2, Store) = apply(evalx(Exp1, Store) <= evalx(Exp2, Store))

[LE2]  apply(Bag1 <= Bag2) = Bag1 <= Bag2
[LE3]  apply(Rel1 <= Rel2) = Rel1 <= Rel2

[LT1]  evalx(Exp1 < Exp2, Store) = apply(evalx(Exp1, Store) < evalx(Exp2, Store))

[LT2]  apply(Bag1 < Bag2) = Bag1 < Bag2
[LT3]  apply(Rel1 < Rel2) = Rel1 < Rel2

[GE1]  evalx(Exp1 >= Exp2, Store) = apply(evalx(Exp1, Store) >= evalx(Exp2, Store))

[GE2]  apply(Bag1 >= Bag2) = Bag1 >= Bag2
[GE3]  apply(Rel1 >= Rel2) = Rel1 >= Rel2

[GT1]  evalx(Exp1 > Exp2, Store) = apply(evalx(Exp1, Store) > evalx(Exp2, Store))

[GT2]  apply(Bag1 > Bag2) = Bag1 > Bag2
[GT3]  apply(Rel1 > Rel2) = Rel1 > Rel2

%% ---- Eval Elements

[EE1]  evalx(E, Store) = E

[EE2]  evalx('E, Store) = E

[EE3]  evalx(Var, Store)  = value(Var, Store)

%% ---- Eval bags

[EB1]  evalx('Bag, Store) = Bag

[EB2]  E = evale(Exp, Store), {E+} = evalb({Exp+}, Store)
       ===================================================
       evalx({Exp, Exp+}, Store) = {E, E+}

[EB3]  E = evale(Exp, Store)
       ===================================================
       evalx({Exp}, Store) = {E}

%% ---- Eval relations

[ER1] evalx('Rel, Store)  = Rel

[ER2] E1 = evale(Exp1, Store), E2 = evale(Exp2, Store),
      evalr({Texp+}, Store) = {Tuple+}
      ====================================================
      evalx({<Exp1, Exp2>, Texp+}, Store) = {<E1, E2>, Tuple+}

[ER3] E1 = evale(Exp1, Store), E2 = evale(Exp2, Store)
      ====================================================
      evalx({<Exp1, Exp2>}, Store) = {<E1, E2>}

%% ---- Eval operators

[UN1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 union Exp2, Store) = apply(Val1 union Val2)

[UN2]  apply(Bag1 union Bag2) = Bag1 union Bag2
[UN3]  apply(*empty* union Bag) = Bag 
[UN4]  apply(Bag union *empty*) = Bag

[UN5]  apply(Rel1 union Rel2) = Rel1 union Rel2
[UN6]  apply(*empty* union Rel) = Rel
[UN7]  apply(Rel union *empty*) = Rel

[IN1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 inter Exp2, Store) = apply(Val1 inter Val2)

[IN2]  apply(Bag1 inter Bag2) = Bag1 inter Bag2
[IN3]  apply(Rel1 inter Rel2) = Rel1 inter Rel2

[DF1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 \  Exp2, Store) = apply(Val1 \ Val2)

[DF2]  apply(Bag1 \ Bag2) = Bag1 \ Bag2
[DF3]  apply(Rel1 \ Rel2) = Rel1 \ Rel2

[CM1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 o  Exp2, Store) = apply(Val1 o Val2)

[CM2]  apply(Rel1 o Rel2) = Rel1 o Rel2

[CP1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 x  Exp2, Store) = apply(Val1 x Val2)

[CP2]  apply(Bag1 x Bag2) = Bag1 x Bag2

[PJ1]  Val1 = evalx(Exp1, Store), Val2 = evalx(Exp2, Store)
       ====================================================
       evalx(Exp1 .  Exp2, Store) = apply(Val1 . Val2)

[PJ2]  apply(Rel . E)   = Rel . E
[PJ3]  apply(Rel . Bag) = Rel . Bag
[PJ4]  apply(E . Rel)   = E . Rel
[PJ5]  apply(Bag . Rel) = Bag . Rel

[UN1]  Bag1 = evalb(Exp1, Store),  
       Bag2 = evalb(Exp2, Store), 
       Rel = evalr(Exp3, Store)
       ===================================================
       evalx(Exp1 until(Exp2, Exp3), Store) = Bag1 until(Bag2, Rel)

[TC1] Rel = evalr(Exp, Store)
      ===================================================
      evalx(Exp +, Store) = Rel +

[TC2] Rel = evalr(Exp, Store)
       ===================================================
       evalx(Exp *, Store) = Rel *

%% ---- Eval bag and relation formers

[EB10] evalx({ Var in Exp1 | Exp2 }, Store) = evalx({ Var in Exp1 | Exp2 | {Var}}, Store)

[EB11] evalx({ From+ | Exp1 | Exp2}, Store) =
       valformer(get_from(From+, Store), *empty*, Exp1, Store, Exp2)

[ER11] evalx({ <Var1, Var2> in Exp1 | Exp2 }, Store) =
       evalx({ <Var1, Var2> in Exp1 | Exp2 | {<Var1, Var2>}}, Store)

%% ---- Auxiliary functions for bag and relation formers

[GF1]  Bag = evalb(Exp, Store),
       get_from(From*, Store) = [Gen*]
       ==================================================
       get_from(Var in Exp, From*, Store) = [gen(Var, Bag, Bag, true), Gen*]

[GF2]  Rel = evalr(Exp, Store),
       get_from(From*, Store) = [Gen*]
       ==================================================
       get_from(<Var1, Var2> in Exp, From*, Store) = [gen(Var1, Var2, Rel, Rel, true), Gen*]

[GF3] get_from( , Store) = []

[BF1] has_more(Gens) = false
      ===================================================
      valformer(Gens, Val, Exp1, Store, Exp2) = Val

[BF2] has_more(Gens) = true,
      Store' = get_cur(Gens, Store),
      Gens' = get_next(Gens),
      Bool  =  evalp(Exp1, Store')
      =====================================================
      valformer(Gens, Val, Exp1, Store, Exp2) =
       if Bool
       then
         valformer(Gens', apply(evalx(Exp2, Store') union Val), Exp1, Store, Exp2)
       else
         valformer(Gens', Val, Exp1, Store, Exp2)
       fi

[HM1]  has_more([gen(Var, Bag1, Bag2, Bool), Gen*]) = Bool | has_more([Gen*])

[HM2]  has_more([gen(Var1, Var2, Rel1, Rel2, Bool), Gen*]) =  Bool | has_more([Gen*])

[default-HM] 
      has_more([Gen*]) = false

[GN1] get_next([Gen*]) = [Gen*']
      ====================================================
      get_next([gen(Var, {E}, Bag, Bool), Gen*]) = [gen(Var, Bag, Bag, false), Gen*']

[GN2] get_next([gen(Var, {E, E+}, Bag, Bool), Gen*]) = [gen(Var, {E+}, Bag, true), Gen*]

[GN3] get_next([Gen*]) = [Gen*']
      ====================================================
      get_next([gen(Var1, Var2, {Tuple}, Rel, Bool), Gen*]) =
      [gen(Var1, Var2, Rel, Rel,false), Gen*']

[GN4] get_next([gen(Var1, Var2, {Tuple, Tuple+}, Rel, Bool), Gen*]) =
      [gen(Var1, Var2, {Tuple+}, Rel, true), Gen*]

[GN5] get_next([]) = []

[GC1] get_cur([gen(Var, {}, {E, E*}, Bool), Gen*], Store) = get_cur([Gen*], Store)

[GC2] Store' = assign(Var, E, Store)
      ====================================================
      get_cur([gen(Var, {E, E*}, Bag, Bool), Gen*], Store) = get_cur([Gen*], Store')

[GC3] get_cur([gen(Var1, Var2, {}, Rel, Bool), Gen*], Store) = get_cur([Gen*], Store)

[GC4] Store' = assign(Var1, E1, Store),
      Store'' = assign(Var2, E2, Store')
      ====================================================
      get_cur([gen(Var1, Var2, {<E1, E2>, Tuple*}, Rel, Bool), Gen*], Store) =
      get_cur([Gen*], Store'')

[GC5] get_cur([], Store) = Store

%% ------------------------------

%% ---- FUN ( EXP ) -> EXP

[default-fun1]
        value(Var1, Store) = <Var2, Exp2>,
        Val = evalx(Exp1, Store),
        Store' = assign(Var2, Val, Store)
        ====================================================
	evalx(Var1(Exp1), Store) = evalx(Exp2, Store')

[Fid]   Bag  = evalb(Exp, Store)
        ====================================================
        evalx(id(Exp), Store) = id Bag

[Fdom]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(dom(Exp), Store) = dom Rel

[Fran]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(ran(Exp), Store) = ran Rel

[Fcar]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(car(Exp), Store) = car Rel
   
[Ftop]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(top(Exp), Store) = top Rel

[Fbot]  Rel = evalr(Exp, Store)
        ====================================================
        evalx(bot(Exp), Store) = bot Rel

[Finv]  Rel = evalr(Exp, Store)
        ===================================================
        evalx(inv(Exp), Store) = inv Rel

[Fcmp]  Rel = evalr(Exp, Store)
        ===================================================
        evalx(compl(Exp), Store) = compl Rel

%% ---- FUN ( EXP , EXP )  -> EXP

[default-fun2]
        value(Var, Store) = <Var1, Var2, Exp3>,
        Val1 = evalx(Exp1, Store),
        Val2 = evalx(Exp2, Store),

        Store' = assign(Var1, Val1, Store),
	Store'' = assign(Var2, Val2, Store')
        ==================================================
	evalx(Var(Exp1, Exp2), Store) = evalx(Exp3, Store'')

%%      fun domR(REL, Bag) = { <$x, $y> in REL | $x in Bag | {<$x, $y}>}

[RdomR] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ===================================================
        evalx(domR(Exp1, Exp2), Store) = Rel domR Bag

[FranR] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ===================================================
        evalx(ranR(Exp1, Exp2), Store) = Rel ranR Bag

[FcarR] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(carR(Exp1, Exp2), Store) = Rel carR Bag

[FdomX] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(domX(Exp1, Exp2), Store) = Rel domX Bag

[FranX] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(ranX(Exp1, Exp2), Store) = Rel ranX Bag

[FcarX] Rel = evalr(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(carX(Exp1, Exp2), Store) = Rel carX Bag

[Felm]  E = evale(Exp1, Store), Bag = evalb(Exp2, Store)
        ====================================================
        evalx(elem(Exp1, Exp2), Store) = E in Bag
