#! /bin/sh

# rscript -- check and execute an Rscript
# This utility provides the following functionality
# - parse and check an Rscript
# - parse, check and evaluate an Rscript
# - parse, check and evaluate an Rscript with a given Rstore
# - parse and check an Rscript and run it as test suite

set -e

#   variables
prefix=__PREFIX__
bindir=__BINDIR__
datadir=__DATADIR__

PRG=`basename $0`
VERBOSE=
CHECK_ONLY=

RSCRIPT_PARSE_TABLE=${datadir}/Rscript.trm.tbl
RSTORE_PARSE_TABLE=${datadir}/Rstore.trm.tbl

EVALUATOR=${bindir}/RscriptCalculator
RSTORE_SORT=RSTORE
SUMMARY_SORT=Summary
EVALUATOR_RESULT=$RSTORE_SORT

ADDPOSINFO=__PT_SUPPORT__/bin/addPosInfo
APPLYFUNCTION=__PT_SUPPORT__/bin/apply-function
SGLR=__SGLR__/bin/sglr
UNPARSEPT=__PT_SUPPORT__/bin/unparsePT

THE_EVALUATOR=$EVALUATOR
EVALUATOR_FUN=eval-rscript
EVALUATOR_WITH_STORE_FUN=eval-rscript-with-rstore
CHECKER_FUN=check-rscript


TESTSUITES=${bindir}/RscriptTestsuites
USE_TESTSUITES=no
YIELD=

THE_RSCRIPT=
OUTPUT_AS_TREE=
OUTPUT=
RSTORE=
TYPE_CHECKER=$EVALUATOR
OUTPUT_TYPE_CHECKER=./.checker.feedback
TYPE_CHECKING_OK="Rscript is type correct!"
TMP_FILES=$OUTPUT_TYPE_CHECKER

# 

#   usage

usage() {
cat << ENDCAT >&2
Usage: $PRG [options] [filename]

Options:
  -i (--input)              filename  input from file (default: stdin)
  -o (--output-parse-tree)  filename  output as parse-tree to filename (default: text to stdout)
  -s (--store)              filename  initial Rstore (default: none)
  -c (--check-only)                   only check the Rscript, do not evaluate it
  -t (--testsuite)                    execute as test suite (excludes -y option)
  -v (--verbose)                      verbose output (default:not verbose)
  -y (--yield)              name      yield the value of variable "name" (default: the complete Rstore)

Examples:
  $PRG query.rscript
  $PRG -i query.rscript -s previous.rstore -o result.rstore.pt
  $PRG -y nCalls calls.rscript
  $PRG -t tests1.rscript

ENDCAT
}

# 
# 
die(){
  echo $PRG: $1
  exit 1
}
# 
# 
check_rscript_file_type(){
  case "$1" in
  *.rscript) ;;
  *) die "$1 is not an rscript"
  esac
  if [ ! -r $1 ]
  then
     die "$1 is not readable"
  fi
}

# 
check_rstore_file_type(){
  case "$1" in
  *.rstore) ;;
  *.rstore.pt) ;;
  *) die "$1 is not an rstore"
  esac
  if [ ! -r $1 ]
  then
     die "$1 is not readable"
  fi
}

# 
set_output_style(){
  if test -z "$OUTPUT_AS_TREE"
  then
      OUTPUT=$UNPARSEPT
  else
      OUTPUT="eval cat >"$OUTPUT_AS_TREE
  fi
}
# 
#   add_tmp_file

add_tmp_file() {
    TMP_FILES="$TMP_FILES $1"
}
# 
#   cleanup

cleanup() {
  rm -f $TMP_FILES
}

#   parse_rscript

parse_rscript() {
  $SGLR $VERBOSE -p $RSCRIPT_PARSE_TABLE -s RSCRIPT -i $THE_RSCRIPT -o $THE_RSCRIPT.pt
  add_tmp_file  $THE_RSCRIPT.pt
}

# 
#   parse_rstore

parse_rstore() {
  case $RSTORE in
      *.pt) PARSED_RSTORE=$RSTORE;;

      *) $SGLR $VERBOSE -p $RSTORE_PARSE_TABLE -s $RSTORE_SORT -i $RSTORE -o $RSTORE.pt
	 PARSED_RSTORE=$RSTORE.pt
	 add_tmp_file  $RSTORE.pt
	 ;;
  esac
}

# 
#   check


check() {
  $ADDPOSINFO -p $THE_RSCRIPT -i $THE_RSCRIPT.pt  | $APPLYFUNCTION -f $CHECKER_FUN -s $SUMMARY_SORT -o $THE_RSCRIPT.pt.pos
  add_tmp_file $THE_RSCRIPT.pt.pos
  $TYPE_CHECKER -i $THE_RSCRIPT.pt.pos | $UNPARSEPT > $OUTPUT_TYPE_CHECKER
}

# 

#  evaluate

evaluate() {
  if test -n "$RSTORE" 
  then
    parse_rstore 
    $APPLYFUNCTION -f $EVALUATOR_FUN -s $EVALUATOR_RESULT -i $THE_RSCRIPT.pt -i $PARSED_RSTORE | $THE_EVALUATOR | $OUTPUT
  else
    $APPLYFUNCTION -f $EVALUATOR_FUN -s $EVALUATOR_RESULT -i $THE_RSCRIPT.pt | $THE_EVALUATOR | $OUTPUT
  fi
  echo ""
}
   
# 

if test $# -eq 0
then
  usage
  exit 1
fi

while test $# -gt 0
do
  case "$1" in
    -o | --output-parse-tree)
      shift; OUTPUT_AS_TREE=$1 ;;
    -i | --input)
      shift; THE_RSCRIPT=$1 ; check_rscript_file_type ${THE_RSCRIPT};;
    -s | --store)
      shift; RSTORE=$1;  check_rstore_file_type ${RSTORE}; WITH_RSTORE=-with-rstore;;
    -t | --testsuite)
      USE_TESTSUITES=yes; THE_EVALUATOR=$TESTSUITES; EVALUATOR_FUN=eval-rscript-testsuite; EVALUATOR_RESULT=TESTREPORT;;
     -c | --check-only)
      CHECK_ONLY=yes ;;
     -y | --yield)
      shift; YIELD="-s $1"; EVALUATOR_RESULT="Elem" ; AND_YIELD=-and-yield;;
    -v | --verbose)
      VERBOSE=-v ;;
    *.rscript)
      THE_RSCRIPT=$1 
      check_rscript_file_type ${THE_RSCRIPT};; 
    *)
      usage; exit 1 ;;
  esac
  shift
done

if test -n "$YIELD" -a  "(" $USE_TESTSUITES = "yes" ")"
then
    echo "$PRG: -y (--yield) and -t (--testsuite) cannot be combined"
    usage
    exit 1
else
    EVALUATOR_FUN=${EVALUATOR_FUN}${WITH_RSTORE}${AND_YIELD}
fi

set_output_style
parse_rscript
check


if test "$CHECK_ONLY" = "yes"
then
    if grep  -q "$TYPE_CHECKING_OK" "$OUTPUT_TYPE_CHECKER"
    then 
	echo $THE_RSCRIPT is type correct
    else
	error-support -i $OUTPUT_TYPE_CHECKER
	echo ""
    fi
    exit
fi
   
if grep  -q "$TYPE_CHECKING_OK" "$OUTPUT_TYPE_CHECKER"
then 
    evaluate
else 
    error-support -i $OUTPUT_TYPE_CHECKER
    echo ""
    echo "There are type errors in $THE_RSCRIPT; script is not executed"
fi

cleanup
