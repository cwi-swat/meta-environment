module Rscript

imports basic/Booleans basic/Integers basic/Strings
imports MyArea

exports
%%sorts Elem would be reasonable :-) but gives double declaration error

  sorts ElemType RSCRIPT RSTAT RVAR DCLRVAR SIMPLE-GENERATOR GENERATOR 
	REXP REXPTYPE EQU DESTINATION {REXP ","}+

  imports Relations[Elem]

  lexical syntax
     [A-Za-z][A-Za-z0-9\_\-]*             	-> RVAR {avoid}
      "comment" ~[]* "endcomment"		-> LAYOUT

  context-free restrictions
     RVAR -/- [A-Za-z0-9\_\-]

  context-free syntax

%% Elementary values
     Boolean                                	-> Elem  
     Integer                                	-> Elem  
     String				    	-> Elem  
     Area				    	-> Elem  

%% Extend Elem to allow nested bags and relations

     Bag[[Elem]]                   	    	-> Elem  
     Tuple					-> Elem

     Elem                                    	-> REXP
     RVAR                                    	-> REXP
     REXP # REXP			     	-> REXP {avoid}
     "<" REXP "," REXP "," {REXP ","}+ ">"	-> REXP {avoid}
     "{" {REXP ","}* "}"                     	-> REXP {avoid}

%% Binary Operators
     REXP "and" REXP                         	-> REXP {left}
     REXP "or" REXP                          	-> REXP {left}
     REXP "implies" REXP			-> REXP {left}

     REXP "in" REXP			     	-> REXP {non-assoc}
     REXP "notin" REXP			     	-> REXP {non-assoc}

     REXP "==" REXP                          	-> REXP {non-assoc}
     REXP "!=" REXP                          	-> REXP {non-assoc}
     REXP "<=" REXP                          	-> REXP {non-assoc}
     REXP "<" REXP                           	-> REXP {non-assoc}
     REXP ">=" REXP                          	-> REXP {non-assoc}
     REXP ">" REXP                           	-> REXP {non-assoc}

     REXP "union" REXP                       	-> REXP {left}
     REXP "inter" REXP                       	-> REXP {left}
     REXP "\\" REXP                          	-> REXP {left}
     REXP "o" REXP                           	-> REXP {left}
     REXP "x" REXP                           	-> REXP {left}
     REXP "." REXP                           	-> REXP {left}

%% Unary Operators

     REXP "+"                                	-> REXP
     REXP "*"                                	-> REXP
     "not" REXP                              	-> REXP
     "#" REXP			    	     	-> REXP

%% Image operator
     REXP "[" REXP "]"				-> REXP

%% Types

     "bool" | "int" | "str" | "area"	     	-> ElemType
     ElemType                                	-> REXPTYPE
     "<" REXPTYPE "," REXPTYPE ">"           	-> REXPTYPE
     "<" REXPTYPE "," REXPTYPE "," {REXPTYPE ","}+">" 
				          	-> REXPTYPE
     "bag" "[" REXPTYPE "]"       	     	-> REXPTYPE
     "rel" "[" REXPTYPE "," {REXPTYPE ","}+ "]" -> REXPTYPE
     RVAR				     	-> REXPTYPE

%% Bag and relation formers

     "{" REXP "|" {GENERATOR ","}+ "}"		-> REXP

     RVAR 					-> DESTINATION
     "<" RVAR "," RVAR ">"			-> DESTINATION
     "<" RVAR "," RVAR "," {RVAR ","}+ ">"	-> DESTINATION

     DESTINATION ":" REXP                      	-> SIMPLE-GENERATOR
     SIMPLE-GENERATOR				-> GENERATOR
     REXP					-> GENERATOR
     DESTINATION "<-" REXP			-> GENERATOR {prefer}

%% Quantifiers

     "exists" "(" SIMPLE-GENERATOR "|" REXP ")" -> REXP
     "forall" "(" SIMPLE-GENERATOR "|" REXP ")"	-> REXP

%% Functions

     RVAR "(" {REXP ","}* ")"                 	-> REXP {avoid}
     "(" REXP ")"                             	-> REXP {bracket}

%% Let expressions

     REXP "where" RSTAT+ "endwhere"		-> REXP

%% Highly experimental sets of equations
     RVAR "=" REXP				-> EQU

     "solve" ("(" Integer ")")? "{" { EQU  "," }+ "}" -> RSTAT

%% Statements and script

     REXPTYPE RVAR			      	-> DCLRVAR

     DCLRVAR				      	-> RSTAT

     DCLRVAR "=" REXP                         	-> RSTAT

     DCLRVAR  "(" { DCLRVAR ","}* ")" "=" REXP	-> RSTAT

     "assert" String ":"  REXP			-> RSTAT
 
     RSTAT*                                     -> RSCRIPT

  context-free priorities

    {	REXP "+" -> REXP
       	REXP "*" -> REXP
    }					>
    REXP "[" REXP "]"	-> REXP 	>

    REXP "o" REXP -> REXP		>
    REXP "x" REXP -> REXP		>
    REXP "." REXP -> REXP		>
    REXP "inter" REXP -> REXP		>
    REXP "union" REXP -> REXP		>
    REXP "\\" REXP -> REXP		>
    "#" REXP -> REXP 			>    


    {	REXP "in" REXP -> REXP
	REXP "notin" REXP -> REXP  
	REXP "<=" REXP -> REXP 
       	REXP "<" REXP -> REXP
       	REXP ">=" REXP -> REXP
       	REXP ">" REXP -> REXP
       	REXP "!=" REXP -> REXP  
      	REXP "==" REXP -> REXP  
    }   				>
    REXP "and" REXP -> REXP 		>
    REXP "or" REXP -> REXP 		>
    "not" REXP -> REXP			>
    REXP "implies" REXP -> REXP
 

     


     
