module relation-calculus/RscriptChecker

imports relation-calculus/Rscript
imports containers/Table[RVAR REXPTYPE]

imports basic/Errors

imports utilities/PosInfo[RSTAT]
imports utilities/PosInfo[REXP]
imports utilities/PosInfo[RVAR]
imports utilities/PosInfo[REXPTYPE]
imports utilities/PosInfo[GENERATOR]
imports utilities/PosInfo[Set[[Elem]]]

imports relation-calculus/Rstore

%% External interface

exports
    context-free start-symbols Summary 
    context-free syntax
	check-rscript(RSCRIPT)					-> Summary
	check-rscript-with-rstore(RSCRIPT, RSTORE)		-> Summary
	is-type-correct(Summary)				-> Boolean

%% Error handling

hiddens
    sorts ERROR ERRORS

    context-free syntax
	RSTAT "cannot be typed" 				-> ERROR
	REXP "cannot be typed" 					-> ERROR

	GENERATOR "cannot be typed"				-> ERROR
	Set[[Elem]] "cannot be typed" 				-> ERROR
 	"Undeclared" RVAR					-> ERROR
  	RVAR "redeclared"					-> ERROR
	RVAR "not initialized in Rstore"			-> ERROR
	RVAR "conflicting initialization in Rscript and in Rstore"		
								-> ERROR
        "Incompatible argument types" REXPTYPE "in" REXP        -> ERROR
        REXP "should have type" REXPTYPE          		-> ERROR
        REXP "should be of type set"         			-> ERROR
        REXP "should be of type rel"         			-> ERROR
        "No definition for" RVAR "with argument" REXPTYPE       -> ERROR
	"No definition for field" RVAR				-> ERROR
	RVAR "exceeds number of targets of generator"		-> ERROR
	"Field name" RVAR "used at different record positions"	-> ERROR
	REXPTYPE "should be set or rel type"			-> ERROR

       "errors" "[" {ERROR ";"} * "]"                		-> ERRORS {prefer}

	e2i(ERROR)						-> Error
	convert-errors(ERRORS)                    		-> Summary
	convert-errors1(ERRORS)                    		-> {Error ","}*
        rvar2str(RVAR)		 	        		-> StrCon

%% Type environments

hiddens
    sorts TENV

    context-free start-symbols TENV <REXPTYPE, TENV> <Boolean, Table[[RVAR,REXPTYPE]]>

    context-free syntax

	<Table[[RVAR,REXPTYPE]], ERRORS> 			-> TENV {prefer}

	TENV "+" ERROR						-> TENV

        "if" Boolean "then" TENV "else" TENV "fi"		-> TENV
        "if" Boolean "then" <REXPTYPE, TENV> "else" <REXPTYPE, TENV> "fi"	->
        <REXPTYPE, TENV>

	lookup(TENV, RVAR) 					-> REXPTYPE
	store(TENV, RVAR, REXPTYPE)				-> TENV
	delete(TENV, RVAR)					-> TENV

	"built-ins"						-> Table[[RVAR,REXPTYPE]]

%% Type extensions and type utilities

hiddens
    context-free syntax
        "undefined-type"                       			-> REXPTYPE
	 "<" {DCLRVAR ","}* ">"					-> REXPTYPE
        "fun" {REXPTYPE ","}* "to" REXPTYPE			-> REXPTYPE
        "[" {REXPTYPE ","}* "]"                 		-> REXPTYPE
	"empty-set-type"					-> REXPTYPE

	type-of(Elem)                  				-> ElemType
	element-type(REXPTYPE, TENV)				-> REXPTYPE
	field(Integer)						-> REXPTYPE
	cover-empty(REXPTYPE)					-> REXPTYPE
	first(REXPTYPE, TENV)					-> REXPTYPE
	second(REXPTYPE, TENV)					-> REXPTYPE

	is-tuple(Elem)						-> Boolean
	is-rel-type(REXPTYPE)					-> Boolean
	is-set-type(REXPTYPE)					-> Boolean

	norm(REXPTYPE, TENV)					-> REXPTYPE
	well-formed-type(REXPTYPE, TENV)			-> TENV
	equal-type(REXPTYPE, REXPTYPE, TENV)			-> Boolean
	get-tuple-type(REXPTYPE)				-> REXPTYPE

        match-types(REXPTYPE, REXPTYPE, Table[[RVAR,REXPTYPE]], TENV)	-> <Boolean, Table[[RVAR,REXPTYPE]]>
        substitute(REXPTYPE,  Table[[RVAR,REXPTYPE]], TENV) 	-> <REXPTYPE, TENV>

	t2s(REXPTYPE)						-> StrCon
	tl2sl({REXPTYPE ","}*)					-> StrCon

hiddens
    sorts  DCLRVARS  

    context-free syntax
	match-targets({TARGET ","}*, REXPTYPE, TENV)		-> TENV
	delete-targets({TARGET ","}*, TENV)			-> TENV

        check-rscript(RSTAT*, TENV)				-> TENV
	check-rstore(RSTAT*, RSTORE, TENV)			-> TENV
	check(REXP, TENV) 					-> <REXPTYPE, TENV>

	check-const(Elem, TENV) 				-> <REXPTYPE, TENV>
	check-const-tuple(Elem, TENV)				-> <REXPTYPE, TENV>
	check-const-set-or-rel(SetIterator[[Elem]], TENV) 	-> <REXPTYPE, TENV>
	check-stat(RSTAT, TENV) 				-> TENV

        check-not-defined(RVAR, TENV)            		-> TENV

        require-type(REXP, REXPTYPE, TENV) 			-> TENV
        require-type2(REXP, REXPTYPE, REXP, REXPTYPE, TENV) 	-> TENV

	check-eqs(INITVAR*, EQU*, TENV)				-> TENV

	check-duplicate-fields({DCLRVAR ","}*, Integer, TENV)	-> TENV
	get-field-type(REXPTYPE, RVAR, TENV)			-> <REXPTYPE, TENV>
	get-field-index(RVAR, List[[REXPTYPE]])			-> Integer
	get-field-index1(RVAR, {DCLRVAR ","}*, Integer)		-> Integer
	
	compat-cmp(REXP, REXPTYPE, REXPTYPE, TENV)		-> TENV
	check-cmp(REXP, REXP, REXP, TENV)			-> <REXPTYPE, TENV>

	check-int(REXP, REXP, REXP, TENV)			-> <REXPTYPE, TENV>

	compat-un(REXP, REXPTYPE, REXPTYPE, TENV)		-> <REXPTYPE, TENV>
	check-un(REXP, REXP, REXP, TENV)			-> <REXPTYPE, TENV>

	compat-comp(REXP, REXPTYPE, REXPTYPE, TENV)		-> <REXPTYPE, TENV>
	compat-prod(REXP, REXPTYPE, REXPTYPE, TENV)		-> <REXPTYPE, TENV>
	compat-lim(REXP, REXPTYPE, REXPTYPE, TENV)		-> <REXPTYPE, TENV>
	compat-rim(REXP, REXPTYPE, REXPTYPE, TENV)		-> <REXPTYPE, TENV>
	compat-trans(REXP, REXPTYPE, TENV)			-> <REXPTYPE, TENV>
	compat-size(REXP, REXPTYPE, TENV)			-> <REXPTYPE, TENV>

        container-type(REXPTYPE)				-> REXPTYPE
        
        "[" { DCLRVAR ","}* "]"					-> DCLRVARS

	add-generators({GENERATOR ","}*, TENV)            	-> TENV
	del-generators({GENERATOR ","}*, TENV)         		-> TENV

        add-formals(DCLRVARS, TENV)             		-> TENV
        del-formals(DCLRVARS, TENV)				-> TENV

 	extract-types(DCLRVARS )                     		-> REXPTYPE
        collect-actuals({REXP ","}*, TENV)        		-> <REXPTYPE, TENV>

        find-result-type(RVAR, REXPTYPE, TENV)   		-> <REXPTYPE, TENV>

hiddens
    imports basic/Comments
    variables
     "$Table" [0-9\']* 		-> Table[[RVAR,REXPTYPE]]
     "$Tenv"[0-9\']* 		-> TENV
     "$Error" [0-9\']* 		-> ERROR
     "$Error*" [0-9\']* 	-> {ERROR ";"}*
     "$Error+" [0-9\']* 	-> {ERROR ";"}+
     "$Errors" [0-9\']*		-> ERRORS

     "$Summary"  [0-9\']*	-> Summary
     
     "$Exp0" [0-9\']*    	-> REXP0
     "$Exp" [1-9\']*    	-> REXP
     "$Test" [0-9\']*    	-> REXP
     "$Exp*" [0-9\']*    	-> {REXP ","}*
     "$Exp+" [0-9\']*    	-> {REXP ","}+
     "$Exps" [0-9\']*    	-> {REXP ","}+

     "$Etype" [0-9\']*    	-> REXPTYPE
     "$Etype*" [0-9\']*    	-> {REXPTYPE ","}*
     "$Etype+" [0-9\']*    	-> {REXPTYPE ","}+


     "$Elem" [0-9\']*     	-> Elem
     "$Elem+" [0-9\']*     	-> {Elem ","}+
     "$Elem*" [0-9\']*     	-> {Elem ","}*

     "$Tuple" [0-9\']*     	-> Tuple
     "$Tuple*" [0-9\']*     	-> {Tuple ","}*
     "$Tuple+" [0-9\']*     	-> {Tuple ","}+


     "$Set" [0-9\']*        	-> Set[[Elem]]
     "$Rel" [0-9\']*        	-> Set[[Elem]]

     "$BoolCon" [0-9\']*    	-> BoolCon
     "$Boolean" [0-9\']*    	-> Boolean
     "$NatCon" [0-9\']*    	-> NatCon
     "$Integer" [0-9\']*    	-> Integer
     "$Loc" [0-9\']*    	-> Location
     "$String" [0-9\']*    	-> String
     "$StrCon" [0-9\']*    	-> StrCon

     "$Var" [0-9\']*       	-> RVAR
     "$Var*" [0-9\']*       	-> {RVAR ","}*
     "$Var+" [0-9\']*       	-> {RVAR ","}+

     "$DclVar" [0-9\']*		-> DCLRVAR
     "$DclVar*" [0-9\']*	-> {DCLRVAR ","}*
     "$DclVar+" [0-9\']*	-> {DCLRVAR ","}+


     "$Target" [0-9\']*		-> TARGET
     "$Target*" [0-9\']*	-> {TARGET ","}*
     "$Target+" [0-9\']*	-> {TARGET ","}+

     "$Rscript" [0-9\']*        -> RSCRIPT

     "$Stat" [0-9\']*            -> RSTAT
     "$Stat*" [0-9\']*           -> RSTAT*
     "$Stat+" [0-9\']*           -> RSTAT+

     "$SimpleGen" [0-9\']*   	-> SIMPLE-GENERATOR

     "$Gen" [0-9\']*   		-> GENERATOR
     "$Gen*" [0-9\']*   	-> {GENERATOR ","}*
     "$Gen+" [0-9\']*   	-> {GENERATOR ","}+

      "$Feedback*" [0-9\']*	-> {Error ","}*

      "$InitVar" [0-9\']*	-> INITVAR
      "$InitVar*" [0-9\']*	-> INITVAR*
      "$InitVar+" [0-9\']*	-> INITVAR+

      "$Eq" [0-9\']*		-> EQU
      "$Eq*" [0-9\']*		-> EQU*
      "$Eq+" [0-9\']*		-> EQU+

      "$Rstore" [0-9\']*        -> RSTORE

      "$ListOfTypes" [0-9\']*	-> List[[REXPTYPE]]
	
      "Char*" [0-9\']*          -> CHAR*
      "$Yield"                  -> YIELD
