equations

%% We first make an artificial single root to the tree. 
%% The result is that the carrier of the relation is
%% equal to the domain, minus the single top. The main loop (sort)
%% can then use range exlusion to sweep to the next
%% line of nodes without the chance of removing any nodes that do not
%% occur in the domain of the relation.

%% topological sort only works on a-cyclic relations

[topological-sort-many]
	is-rel($relation) == true,
	contains-cycle($relation) == false,
	$rootset := top($relation),
	$root := head(mk-iterator($rootset)),
	$rootset' := diff($rootset, {$root}),
	$relation' := union($relation, product($root, $rootset'))
	===
	topological-sort($relation) = concat(sort($relation'), [$root])

[topological-sort-empty]
	topological-sort({}) = []

equations

[sort-empty]
	sort({}) = []

[sort-many]
	$bottom := bottom($relation),
	$bottomList := bag-to-list($bottom),
	$relation' := ranX($relation, $bottom)
	===
   	sort($relation) = concat($bottomList, sort($relation'))

equations

[cyclic]
	{$elem*1, <$elem, $elem>, $elem*2} := trans-closure($relation)
	===
	contains-cycle($relation) = true

[default-cyclic]
	contains-cycle($relation) = false

equations

[bag-to-list-top]
	{$elem*} := $bag,
	$set := {$elem*},
	{$elem*'} := $set,
	$list := [$elem*']
	===
        bag-to-list($bag) = $list

tests

[bag-to-list-empty]
	bag-to-list({}) == []

[bag-to-list-many-unique]
	bag-to-list({1, 3, 2}) == [1, 3, 2]

[bag-to-list-many-dup]
	bag-to-list({1, 3, 2, 3}) == [1, 3, 2]

tests 

[top-sort-empty] 
	topological-sort({}) == []

[top-sort-single]
	topological-sort({<1,2>}) == [2,1]

[top-sort-independent-subgraphs]
	topological-sort({<1,2>,<3,4>}) == [2,4,3,1]

[top-sort-shortcut]
	topological-sort({<1,0>,<3,2>,<2,0>,<3,0>}) == [0,2,3,1]

[top-sort-linear]
	topological-sort({<1,2>,<2,3>,<3,4>,<4,5>,<5,6>}) ==
		[6,5,4,3,2,1]

[top-sort-cyclic-1]
	%% idiom for testing if a function does not reduce
	topological-sort({<1,1>}) := topological-sort({<1,1>})

[top-sort-on-non-relation]
	topological-sort({1,2,3}) := topological-sort({1,2,3})

[top-sort-X]
	topological-sort({<1,2>,<2,3>,<0,2>,<2,4>}) == [3, 4 , 2 , 0 , 1]

[top-sort-diamond]
	topological-sort({<1,2>,<1,3>,<3,4>,<2,4>}) == [4,2,3,1]
 
tests

[cyclic-0]
	contains-cycle({<1,2>, <2,3>, <3,1>}) == true

[cyclic-1] 
	contains-cycle({<1,1>}) == true

[cyclic-2]
	contains-cycle({<1,2>,<2,3>,<3,4>,<4,5>,<5,6>}) == false

[cyclic-empty]
	contains-cycle({}) == false