%%
%%    MEPT -- The Meta-Environment Parse Tree library 
%%
%%    Copyright (C) 2001  Stichting Mathematisch Centrum, Amsterdam,
%%    The Netherlands.
%%
%%    This program is free software; you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation; either version 2 of the License, or
%%    (at your option) any later version.
%%
%%    This program is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with this program; if not, write to the Free Software
%%    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
%%

\documentclass[a4paper,twoside]{article}

\usepackage{verbatim}
\usepackage{makeidx}
\usepackage{epsfig}
\usepackage{alltt}

\makeindex

\newcommand{\asmetaenv}{{\sc Asf}+{\sc Sdf} Meta-En\-vir\-on\-ment}
\newcommand{\sdf}{{\sc Sdf}}
\newcommand{\kernelsdf}{{\sc Kernel-Sdf}}
\newcommand{\asf}{{\sc Asf}}
\newcommand{\asfix}{{\sc AsFix2}}
\newcommand{\asfixme}{{\sc AsFix2ME}}
\newcommand{\asfsdf}{{\sc Asf}+{\sc Sdf}}
\newcommand{\aterm}{ATerm}
\newcommand{\aterms}{ATerms}
\newcommand{\toolbus}{\mbox{\tt ToolBus}}

\title{The Meta-Environment Parse Tree Library \\
       User Manual \\ 
       $Revision$}
\author{M.G.J. van den Brand \and H.A. de Jong \and J.J. Vinju \\
        {\small\sl Centrum voor Wiskunde en Informatica (CWI),}\\
{\small\sl Kruislaan 413, 1098 SJ Amsterdam, The Netherlands}}

\date{}
\begin{document}
\maketitle

\section{Introduction}

The Parse Tree (PT) library of the \asmetaenv\ \cite{BKMO97} defines 
the format and provides the basic functionality to access parse trees 
exchanged between and manipulated by the individual components of 
the environment. 
The parse tree format is based on \aterms\ \cite{BJKO00} and closely
related to the \asfix\ parse tree format proposed in \cite{Vis97}.
The exact characteristics of the Meta-Environment specific parse
tree format is described in Section \ref{asfix2me}.
The Meta-Environment Parse Tree library consists of three sub libraries.

The first sub library provides functionality to the parse trees in general. 
It has no knowledge of what is represented in the parse trees and 
typical functionality is retrieving the production rule and the
arguments of the application nodes.

The second sub library provides functionality to \sdf\ parse trees,
thus parse trees representing parsed \sdf\ specifications.
Typical functionality is to retrieve the imported modules of
an \sdf\ module, or to get all context-free functions defined in
a module.

The third sub library provides functionality to \asf\ parse trees,
thus parse trees representing parse \asf\ specifications (thus equations).

The core of the second and third sub library are generated via
the API-GEN tooling \cite{JO01} given the annotated \sdf\
definitions of \sdf\ and \asf. They provided type-safe manipulation
of parse trees. On top of this core functionality more sophisticated
functionality has been implemented, e.g.\ retrieval of imported modules,
etc.
The parse tree library is discussed in more detail in Section \ref{ptlib}.

\section{\asfixme}
\label{asfix2me}

We will describe the \asmetaenv\ variant of \asfix\ in more detail.
In Appendix \ref{app:motivation} we motivate why we ``diverse''
and in Appendix \ref{app:differences} we discuss at which points 
the \asmetaenv\ variant differs from plain \asfix.

Based on the \aterm\ format the {\sc AsFix} family has been developed.
So, every \asfixme\ term is also an \aterm.
This library tries to shield the \aterm\ functionality from the user.
Discussing the details of the \asfixme\ format will reveal some
of the \aterm\ details. 
There is a strong relation between \asfix/\asfixme\ and \sdf2.
So, in order to understand design decisions we have to present
\sdf2 details as well.

In \cite{Vis97} the \sdf2 definition is presented. There are versions
of this \sdf2 definition which are decorated with so-called constructor
attributes. Some of these attributes are used in the parse tree to
classify the type of nodes. Consider the \sdf2 definition of the
production rule:

\begin{verbatim}
Symbols "->" Symbol Attributes {cons{"prod"}}
\end{verbatim}
This {\tt prod} is used int the parse tree to mark nodes which represent
the production rules.

Finally, \asfix\ as well as \asfixme\ represent full parse trees including
all literals and {\em all} layout originally available in the parsed text.

\subsection{Basic tree nodes}

There are only 4 different type of nodes in the parse tree.
\begin{itemize}

\item The first type of nodes contain the characters, they represented 
by their decimal representation, e.g.\ {\tt '101'}. For sake of readability
we will use the string representation of the characters instead
of the decimal representation, so {\tt "e"} instead of {\tt '101'}.
There are no access/con\-struc\-tor functions related to this type of node.

\item The second category of nodes represent the literals,
e.g.\ {\tt lit("begin")}.
The literal itself is represented by a plain string.
The following access/con\-struc\-tor functions are available:
\begin{description}
\item[{\tt PT\_isLiteral}] to check whether a node is a literal node.
\item[{\tt PT\_getLiteralString}] to obtain the string of the literal.
\item[{\tt PT\_makeLiteral}] to create a literal node given a string.
\end{description}

\item The third category is the most important category of nodes,
it represents all non-leaf nodes in the tree. They are the so-called
application nodes {\tt appl(<term>,<term>)}, where the first argument
represents a production rule and the second argument is the list of
argument nodes which have a one-to-one correspondence with the
number of arguments in the left-hand side of the production rule
in the first argurment.
The following access/con\-struc\-tor functions are available:
\begin{description}
\item[{\tt PT\_isApplNode}] to check whether a node is an application node.
\item[{\tt PT\_getApplProd}] to obtain the production rule of an application.
\item[{\tt PT\_getApplArgs}] to obtain the arguments of an application.
\item[{\tt PT\_makeApplNode}] to create an application node given
a production rule and a list of arguments.
\end{description}

\item The fourth category of nodes are the so-called flat-layout nodes, they
represent the layout in the parsed text. 
These nodes are a bit strange because the arguments of these nodes
can be any of the previously described catogories,
e.g.\
{\tt layout([" ","}$\backslash${\tt n",lit("\%\%")," ","}$\backslash${\tt n"])}
is a legal flat-layout node.

\end{itemize}

These four categories of nodes allows us to represent any parse tree
we want.

\subsection{Production rule nodes}

We will now describe the \asfix/\asfixme\ representation of production
rules, but before we dive into the details we have to explain some
\sdf2 and \kernelsdf\ details in order to understand the various
categories of nodes that are used ot represent the production rules.
\section{Library interface}
\label{ptlib}

\bibliographystyle{alpha}
\bibliography{PTdoc}

\appendix
\section{Motivation}
\label{app:motivation}

Why has the \asmetaenv\ its own variant of \asfix?
Over the last 4 years we have been experimenting with various versions
of parse tree representations, ``AsFix''.
The first version was very \asfsdf\ specific, the module structure
was hard-coded in the parse tree, it was an ackward combination
of an abstract syntax tree with parse tree characteristics,
all layout was maintained.
With the development of \sdf2 and SGLR \cite{Vis97} a new version
of ``AsFix'' was developed, \asfix, it was more regular, it consisted
only of the application of production rules to arguments.
However, everything was expressed in these terms, lists, lexicals,
literals, and layout. This made the resulting terms huge, there
is a lot of redundancy in these terms.
The underlying \aterms\ library provides maximal sharing and
binary encoded terms, so the issue of size and redundancy are
solved by the underlying library.

The syntax definition formalism \sdf2 supports lists to describe
the repetition of language constructs, e.g.\ {\tt A+} (non-empty lists without
separators) or {\tt \{A ","\}*} (lists with separators).
In the mapping from \sdf2 to \kernelsdf\ this list constructs
are transformed into ordinary production rules of
the form, e.g., {\tt A+ A+ -> A+ \{left\}} and {\tt A -> A+}.
The \asfix\ term respect the underlying structure as defined by
the \kernelsdf\ rules.
So, {\em all} tools that manipulate \asfix\ terms which contain 
lists have to traverse recusively over these lists.
It would be more convenient to flatten these lists in advance.
The same holds for the definition of lexical syntax and layout,
both are also represented as unflattened tree structures.

The main reason for diversion is not the size or redundancy but
the ease for developing tools.
The nested unflattened tree structures are transformed into
flat lists. In the next section we will describe the differences
in more detail.

\section{Differences in representation}
\label{app:differences}

\paragraph{Implosion of literals}
The literals in \asfix\ are represented as a tree consisting of
a production rule and a list of characters representing the lexical,
e.g., 
\begin{verbatim}
appl(prod([char-class([102]),char-class([105]),char-class([120])],
          lit("fix"),no-attrs),
     [102,105,120])
\end{verbatim}
In \asfixme\ these literal trees are ``imploded'' to {\tt lit("fix")},
this tree contains the same amount of information but in a more concise
way.

\paragraph{Flattening of lists}
The issue of lists has been already briefly discussed above.
We will now reveal some more details and discuss a few design(?)
details.
We will use the \sdf\ of a set as running example and show the
intermediate \kernelsdf\ and the corresponding tree structures.

\begin{verbatim}
  context-free syntax
    "{" {Elem ","}* "}" -> Set
\end{verbatim}
The rules generated for {\tt \{Elem ","\}*} are\footnote{We will
not present the context-free priority rules in order to disambiguate
lists of elements.}:

\begin{verbatim}
                              -> {Elem ","}*
  {Elem ","}+                 -> {Elem ","}*
  {Elem ","}* "," {Elem ","}* -> {Elem ","}* {left}
  Elem                        -> {Elem ","}+
  {Elem ","}+ "," {Elem ","}+ -> {Elem ","}+ {left}
  {Elem ","}* "," {Elem ","}+ -> {Elem ","}+
  {Elem ","}+ "," {Elem ","}+ -> {Elem ","}*
\end{verbatim}
We have presented these rules as ordinary \sdf\ rules in order to abstract
from the \kernelsdf\ syntax.

The \asfix\ tree constructed for the term {\tt <Elem>,<Elem>,Elem>}
looks as follows (we have abstracted from the actual contents of
the elements, {\tt <Elem>} and layout {\tt <layout>}):

\begin{verbatim}
appl(
 prod([cf(iter-sep(sort("Elem"),lit(",")))],
      cf(iter-star-sep(sort("Elem"),lit(","))),no-attrs),
 [appl(
   prod([cf(iter-sep(sort("Elem"),lit(","))),
         cf(opt(layout)),lit(","),cf(opt(layout)),
         cf(iter-sep(sort("Elem"),lit(",")))],
        cf(iter-sep(sort("Elem"),lit(","))),attrs([atr("left")])),
   [appl(
     prod([cf(iter-sep(sort("Elem"),lit(","))),
           cf(opt(layout)),lit(","),cf(opt(layout)),
           cf(iter-sep(sort("Elem"),lit(",")))],
          cf(iter-sep(sort("Elem"),lit(","))),attrs([atr("left")])),
     [appl(prod([cf(sort("Elem"))],
                 cf(iter-sep(sort("Elem"),lit(","))),no-attrs),
           [<Elem>]),
      <layout>, lit(",") <layout>,
      appl(prod([cf(sort("Elem"))],
                 cf(iter-sep(sort("Elem"),lit(","))),no-attrs),
           [<Elem>])]),
    <layout>, lit(",") <layout>,
    appl(prod([cf(sort("Elem"))],
              cf(iter-sep(sort("Elem"),lit(","))),no-attrs),
         [<Elem>])])])
\end{verbatim}
The \asfixme\ tree for the same term looks like:

\begin{verbatim}
appl(
 prod([cf(iter-sep(sort("Elem"),lit(",")))],
      cf(iter-star-sep(sort("Elem"),lit(","))),no-attrs),
 [[<Elem>,
   <layout>, lit(",") <layout>,
   <Elem>,
   <layout>, lit(",") <layout>,
   <Elem>]])
\end{verbatim}

\paragraph{Flattening of lexicals}
At the lowest level lexicals are constructed by lists of characters
from the defining character classes of the lexical. If the character
class was an iterated one the list of character classes is treated
in the same way as ordinary lists, e.g.
\begin{verbatim}
appl(
 prod([char-class([range(97,122)]),
       lex(iter-star(char-class([range(48,57),range(97,122)])))],
      lex(sort("Elem")),attrs([id("TestSet")])),
 ["a",
  appl(
   prod([lex(iter(char-class([range(48,57),range(97,122)])))],
        lex(iter-star(char-class([range(48,57),range(97,122)]))),
        no-attrs),
   [appl(
     prod([lex(iter(char-class([range(48,57),range(97,122)]))),
           lex(iter(char-class([range(48,57),range(97,122)])))],
          lex(iter(char-class([range(48,57),range(97,122)]))),
          attrs([atr("left")])),
    [appl(
      prod([char-class([range(48,57),range(97,122)])],
           lex(iter(char-class([range(48,57),range(97,122)]))),
           no-attrs),
      ["b"]),
     appl(
      prod([char-class([range(48,57),range(97,122)])],
           lex(iter(char-class([range(48,57),range(97,122)]))),
           no-attrs),
      ["c"])])])])
\end{verbatim}

In \asfixme\ this subtree will have the following form:
\begin{verbatim}
appl(
 prod([char-class([range(97,122)]),
       lex(iter-star(char-class([range(48,57),range(97,122)])))],
      lex(sort("Elem")),attrs([id("TestSet")])),    
 ["a",["b","c"]])
\end{verbatim} 

\paragraph{Flattening of layout}

\subsection{Conversion Tooling}

\begin{description}
\item[{\tt flattenPT}] takes an \asfix\ term and produces an \asfixme\ term.
\item[{\tt inflatePT}] takes an \asfixme\ term and produces an \asfix\ term.
\item[{\tt implodePT}] takes an \asfixme\ term and produces an \aterm\ 
representing an abstract syntax tree in various forms depending on
the options, e.g., with/without layout, with/without literals, with/without
constructors, with/without flattened lexicals, etc.
\item[{\tt a2metoa1}] takes an \asfixme\ term and produces an {\sc AsFix}1
term, this function is only available for migration purposes and
will certainly disappear in the (near) future.
\end{description}
\end{document}
