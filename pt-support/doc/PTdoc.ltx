\documentclass[a4paper,twoside]{article}

\usepackage{verbatim}
\usepackage{makeidx}
\usepackage{epsfig}
\usepackage{alltt}

\makeindex

\newcommand{\asmetaenv}{{\sc Asf}+{\sc Sdf} Meta-En\-vir\-on\-ment}
\newcommand{\sdf}{{\sc Sdf}}
\newcommand{\kernelsdf}{{\sc Kernel-Sdf}}
\newcommand{\asf}{{\sc Asf}}
\newcommand{\asfix}{{\sc AsFix2}}
\newcommand{\asfixme}{{\sc AsFix2ME}}
\newcommand{\asfsdf}{{\sc Asf}+{\sc Sdf}}
\newcommand{\aterm}{ATerm}
\newcommand{\aterms}{ATerms}
\newcommand{\toolbus}{\mbox{\tt ToolBus}}

\title{The Meta-Environment Parse Tree Library \\
       User Manual \\ 
       $Revision$}
\author{M.G.J. van den Brand \and H.A. de Jong \and J.J. Vinju \\
        {\small\sl Centrum voor Wiskunde en Informatica (CWI),}\\
{\small\sl Kruislaan 413, 1098 SJ Amsterdam, The Netherlands}}

\date{}
\begin{document}
\maketitle

\section{Introduction}

The Parse Tree (PT) library of the \asmetaenv\ \cite{BKMO97} defines 
the format and provides the basic functionality to access parse trees 
exchanged between and manipulated by the individual components of 
the environment. 
The parse tree format is based on \aterms\ \cite{BJKO00} and closely
related to the \asfix\ parse tree format proposed in \cite{Vis97}.
The exact characteristics of the Meta-Environment specific parse
tree format is described in Section \ref{asfix2me}.
The Meta-Environment Parse Tree library consists of three sub libraries.

The first sub library provides functionality to the parse trees in general. 
It has no knowledge of what is represented in the parse trees and 
typical functionality is retrieving the production rule and the
arguments of the application nodes.

The second sub library provides functionality to \sdf\ parse trees,
thus parse trees representing parsed \sdf\ specifications.
Typical functionality is to retrieve the imported modules of
an \sdf\ module, or to get all context-free functions defined in
a module.

The third sub library provides functionality to \asf\ parse trees,
thus parse trees representing parse \asf\ specifications (thus equations).

The core of the second and third sub library are generated via
the API-GEN tooling \cite{JO01} given the annotated \sdf\
definitions of \sdf\ and \asf. They provided type-safe manipulation
of parse trees. On top of this core functionality more sophisticated
functionality has been implemented, e.g.\ retrieval of imported modules,
etc.
The parse tree library is discussed in more detail in Section \ref{ptlib}.

\section{\asfixme}
\label{asfix2me}

We will describe the \asmetaenv\ variant of \asfix\ in more detail.
In Appendix \ref{app:motivation} we motivate why we ``diverse''
and in Appendix \ref{app:differences} we discuss at which points 
the \asmetaenv\ variant differs from plain \asfix.

Based on the \aterm\ format the {\sc AsFix} family has been developed.
So, every \asfixme\ term is also an \aterm.
This library tries to shield the \aterm\ functionality from the user.
Discussing the details of the \asfixme\ format will reveal some
of the \aterm\ details. 
There is a strong relation between \asfix/\asfixme\ and \sdf2.
So, in order to understand design decisions we have to present
\sdf2 details as well.

In \cite{Vis97} the \sdf2 definition is presented. There are versions
of this \sdf2 definition which are decorated with so-called constructor
attributes. Some of these attributes are used in the parse tree to
classify the type of nodes. Consider the \sdf2 definition of the
production rule:

\begin{verbatim}
Symbols "->" Symbol Attributes {cons{"prod"}}
\end{verbatim}
This {\tt prod} is used int the parse tree to mark nodes which represent
the production rules.

Finally, \asfix\ as well as \asfixme\ represent full parse trees including
all literals and {\em all} layout originally available in the parsed text.

\subsection{Basic tree nodes}

There are only 4 different type of nodes in the parse tree.
\begin{itemize}

\item The first type of nodes contain the characters, they represented 
by their decimal representation, e.g.\ {\tt '101'}. For sake of readability
we will use the string representation of the characters instead
of the decimal representation, so {\tt "e"} instead of {\tt '101'}.
There are no access/con\-struc\-tor functions related to this type of node.

\item The second category of nodes represent the literals,
e.g.\ {\tt lit("begin")}.
The literal itself is represented by a plain string.
The following access/con\-struc\-tor functions are available:
\begin{description}
\item[{\tt PT\_isLiteral}] to check whether a node is a literal node.
\item[{\tt PT\_getLiteralString}] to obtain the string of the literal.
\item[{\tt PT\_makeLiteral}] to create a literal node given a string.
\end{description}

\item The third category is the most important category of nodes,
it represents all non-leaf nodes in the tree. They are the so-called
application nodes {\tt appl(<term>,<term>)}, where the first argument
represents a production rule and the second argument is the list of
argument nodes which have a one-to-one correspondence with the
number of arguments in the left-hand side of the production rule
in the first argurment.
The following access/con\-struc\-tor functions are available:
\begin{description}
\item[{\tt PT\_isApplNode}] to check whether a node is an application node.
\item[{\tt PT\_getApplProd}] to obtain the production rule of an application.
\item[{\tt PT\_getApplArgs}] to obtain the arguments of an application.
\item[{\tt PT\_makeApplNode}] to create an application node given
a production rule and a list of arguments.
\end{description}

\item The fourth category of nodes are the so-called flat-layout nodes, they
represent the layout in the parsed text. 
These nodes are a bit strange because the arguments of these nodes
can be any of the previously described catogories,
e.g.\
{\tt layout([" ","}$\backslash${\tt n",lit("\%\%")," ","}$\backslash${\tt n"])}
is a legal flat-layout node.

\end{itemize}

These four categories of nodes allows us to represent any parse tree
we want.

\subsection{Production rule nodes}

The most important type of nodes in the parse trees is the application.
The application node has two arguments, the first argument is either 
a production rule and the second argument is an (empty) list of arguments,
or a list symbol and the second argument is an (empty) list of elements.
In this section we will discuss the production rules in more detail,
in Section \ref{listnodes} we will discuss the list symbols in more detail.

Production rules consist of three parts:
\begin{itemize}
\item left-hand side,
\item right-hand side, and
\item attributes.
\end{itemize}
The node representation for production rules is {\tt prod(<term>,<term>,<term>)}.
The left-hand side consists of a list of symbols, whereas the right-hand
side is a single symbol.

We will now describe the \asfix/\asfixme\ representation of these symbols,
but before we dive into the details we have to explain some
\sdf2 and \kernelsdf\ details in order to understand the various
categories of nodes that are used to represent symbols.

\subsubsection{Lexical and context-free syntax in \sdf2}
\sdf2 or \sdf\ stands for Syntax Definition Formalism, it allows the
definition of the concrete syntax of some (programming) language,
details on \sdf\ can be found in~\cite{HKR89} and on \sdf2\ in~cite{Vis97}.
We will restrict ourselves to the way lexical and context-free syntax
is defined using \sdf2.

The elementary building block of \sdf\ syntax rules is the ``symbol''.  It is
comparable to terminals and non-terminals in other grammar definition
formalisms. The elementary symbols are:

\begin{itemize}
\item \emph{sort}: corresponds to a non-terminal, e.g., {\tt Bool}.  Sort
  names always start with a capital letter and may be followed by letters
  and/or digits.  Hyphens (``{\tt -}'') may be embedded in a sort name.

\item \emph{literal}: corresponds to a terminal, e.g.,  {\tt true} or  {\tt
    "\&"}.

\item \emph{character class}: corresponds to a set of characters,
e.g., {\tt [a-z]}.
\end{itemize}

Starting with the elementary symbols, more complex symbols can be constructed
by way of operators that we will discuss now.

\begin{description}
\item{Option}

The postfix option operator {\tt ?} describes an optional part in a syntax
rule. For instance, {\tt ElsePart?}  defines zero or exactly one occurrence of
{\tt ElsePart}.

\item{Sequence} 

The sequence operator {\tt (...)} describes the grouping of two or more
symbols, e.g., {\tt (Bool "\&")}.  Sequences are mostly used to group symbols
together to form a more complex symbol using one of the available operators,
e.g., {\tt (Bool "\&")*}.  The empty sequence is represented as {\tt ()}.

\item{Repetition}

Repetition operators express that a symbol should occur several times.  In
this way it is possible to construct flat lists and therefore we usually refer
to repetitions as \emph{lists}.

Repetition operators come in two flavors, with and without separators.
Furthermore, it is possible to express the minimal number of repetitions of
the symbol: at least zero times ({\tt *}), at least one time ({\tt +}), or at
least $n$ times ({\tt n+}). Examples are:

\begin{itemize}

\item {\tt Bool*} (a list of zero or more {\tt Bool}s).

\item {\tt \{Bool ","\}+} (a list of one or more {\tt Bool}s separated by comma's).

\item {\tt Bool3+} (a list of at least 3 {\tt Bool}s).

\end{itemize}

\item{Alternative}

The alternative operator {\tt |} expresses the choice between two symbols,
e.g., {\tt true | false} represents that either a {\tt true} symbol or a {\tt
  false} symbol may occur here.  

\item{Tuple}

The tuple operator {\tt \#} describes the grouping of a sequence of symbols of
a fixed length into a tuple. The notation for tuples is {\tt < , , >}, i.e., a
comma-separated list of elements enclosed in angle brackets.

\item{Permutation}

The permutation operator {\tt <<...>>} describes an arbitrary permutation of
a given sequence of symbols.  For example, {\tt <<Bool Int Id>>} represents a
permutation of the symbols {\tt Bool}, {\tt Int}, and {\tt Id}. 

\item{Set}

The set operator {\tt Set[...]} is an abbreviation for defining a set of
elements of a given symbol.  For example, {\tt Set[Int]} abbreviates the
definition {\tt "\{" \{Int ","\}* "\}"}. 

\item{Function}

The function operator {\tt (...=>...)} allows the definition of function
types. Left of {\tt =>} zero or more symbols may occur, right of {\tt =>}
exactly one symbol may occur.  For example, {\tt (Bool Int) => Int} represents
a function with two argument (of types {\tt Bool} and {\tt Int}, respectively)
and a result type {\tt Int}.
\end{description}

For each of these symbol types a corresponding node type exists:
{\tt empty} (empty sequence), {\tt seq} (non-empty sequence),
{\tt alt} (alternative), {\tt opt} (optional), {\tt pair} (tuple),
{\tt iter-plus}, {\tt iter-star}, {\tt iter-plus-sep}, {\tt iter-star-sep},
{\tt iter-n}, {\tt iter-sep-n} (various list symbols),
{\tt perm} (permutation), {\tt set}, and {\tt func} (function).

For the basic symbol types (sort, literal, and character classes), we
have, respectively, {\tt sort}, {\tt lit}, and {\tt char-class}.



\subsubsection{\kernelsdf}

\subsection{List nodes}\label{listnodes}

\section{Library interface}
\label{ptlib}

\bibliographystyle{alpha}
\bibliography{PTdoc}

\appendix
\section{Motivation}
\label{app:motivation}

Why has the \asmetaenv\ its own variant of \asfix?
Over the last 4 years we have been experimenting with various versions
of parse tree representations, ``AsFix''.
The first version was very \asfsdf\ specific, the module structure
was hard-coded in the parse tree, it was an ackward combination
of an abstract syntax tree with parse tree characteristics,
all layout was maintained.
With the development of \sdf2 and SGLR \cite{Vis97} a new version
of ``AsFix'' was developed, \asfix, it was more regular, it consisted
only of the application of production rules to arguments.
However, everything was expressed in these terms, lists, lexicals,
literals, and layout. This made the resulting terms huge, there
is a lot of redundancy in these terms.
The underlying \aterms\ library provides maximal sharing and
binary encoded terms, so the issue of size and redundancy are
solved by the underlying library.

The syntax definition formalism \sdf2 supports lists to describe
the repetition of language constructs, e.g.\ {\tt A+} (non-empty lists without
separators) or {\tt \{A ","\}*} (lists with separators).
In the mapping from \sdf2 to \kernelsdf\ this list constructs
are transformed into ordinary production rules of
the form, e.g., {\tt A+ A+ -> A+ \{left\}} and {\tt A -> A+}.
The \asfix\ term respect the underlying structure as defined by
the \kernelsdf\ rules.
So, {\em all} tools that manipulate \asfix\ terms which contain 
lists have to traverse recusively over these lists.
It would be more convenient to flatten these lists in advance.
The same holds for the definition of lexical syntax and layout,
both are also represented as unflattened tree structures.

The main reason for diversion is not the size or redundancy but
the ease for developing tools.
The nested unflattened tree structures are transformed into
flat lists. In the next section we will describe the differences
in more detail.

\section{Differences in representation}
\label{app:differences}

\paragraph{Implosion of literals}
The literals in \asfix\ are represented as a tree consisting of
a production rule and a list of characters representing the lexical,
e.g., 
\begin{verbatim}
appl(prod([char-class([102]),char-class([105]),char-class([120])],
          lit("fix"),no-attrs),
     [102,105,120])
\end{verbatim}
In \asfixme\ these literal trees are ``imploded'' to {\tt lit("fix")},
this tree contains the same amount of information but in a more concise
way.

\paragraph{Flattening of lists}
The issue of lists has been already briefly discussed above.
We will now reveal some more details and discuss a few design(?)
details.
We will use the \sdf\ of a set as running example and show the
intermediate \kernelsdf\ and the corresponding tree structures.

\begin{verbatim}
  context-free syntax
    "{" {Elem ","}* "}" -> Set
\end{verbatim}
The rules generated for {\tt \{Elem ","\}*} are\footnote{We will
not present the context-free priority rules in order to disambiguate
lists of elements.}:

\begin{verbatim}
                              -> {Elem ","}*
  {Elem ","}+                 -> {Elem ","}*
  {Elem ","}* "," {Elem ","}* -> {Elem ","}* {left}
  Elem                        -> {Elem ","}+
  {Elem ","}+ "," {Elem ","}+ -> {Elem ","}+ {left}
  {Elem ","}* "," {Elem ","}+ -> {Elem ","}+
  {Elem ","}+ "," {Elem ","}+ -> {Elem ","}*
\end{verbatim}
We have presented these rules as ordinary \sdf\ rules in order to abstract
from the \kernelsdf\ syntax.

The \asfix\ tree constructed for the term {\tt <Elem>,<Elem>,Elem>}
looks as follows (we have abstracted from the actual contents of
the elements, {\tt <Elem>} and layout {\tt <layout>}):

\begin{verbatim}
appl(
 prod([cf(iter-sep(sort("Elem"),lit(",")))],
      cf(iter-star-sep(sort("Elem"),lit(","))),no-attrs),
 [appl(
   prod([cf(iter-sep(sort("Elem"),lit(","))),
         cf(opt(layout)),lit(","),cf(opt(layout)),
         cf(iter-sep(sort("Elem"),lit(",")))],
        cf(iter-sep(sort("Elem"),lit(","))),attrs([atr("left")])),
   [appl(
     prod([cf(iter-sep(sort("Elem"),lit(","))),
           cf(opt(layout)),lit(","),cf(opt(layout)),
           cf(iter-sep(sort("Elem"),lit(",")))],
          cf(iter-sep(sort("Elem"),lit(","))),attrs([atr("left")])),
     [appl(prod([cf(sort("Elem"))],
                 cf(iter-sep(sort("Elem"),lit(","))),no-attrs),
           [<Elem>]),
      <layout>, lit(",") <layout>,
      appl(prod([cf(sort("Elem"))],
                 cf(iter-sep(sort("Elem"),lit(","))),no-attrs),
           [<Elem>])]),
    <layout>, lit(",") <layout>,
    appl(prod([cf(sort("Elem"))],
              cf(iter-sep(sort("Elem"),lit(","))),no-attrs),
         [<Elem>])])])
\end{verbatim}
The \asfixme\ tree for the same term looks like:

\begin{verbatim}
appl(
 prod([cf(iter-sep(sort("Elem"),lit(",")))],
      cf(iter-star-sep(sort("Elem"),lit(","))),no-attrs),
 [[<Elem>,
   <layout>, lit(",") <layout>,
   <Elem>,
   <layout>, lit(",") <layout>,
   <Elem>]])
\end{verbatim}

\paragraph{Flattening of lexicals}
At the lowest level lexicals are constructed by lists of characters
from the defining character classes of the lexical. If the character
class was an iterated one the list of character classes is treated
in the same way as ordinary lists, e.g.
\begin{verbatim}
appl(
 prod([char-class([range(97,122)]),
       lex(iter-star(char-class([range(48,57),range(97,122)])))],
      lex(sort("Elem")),attrs([id("TestSet")])),
 ["a",
  appl(
   prod([lex(iter(char-class([range(48,57),range(97,122)])))],
        lex(iter-star(char-class([range(48,57),range(97,122)]))),
        no-attrs),
   [appl(
     prod([lex(iter(char-class([range(48,57),range(97,122)]))),
           lex(iter(char-class([range(48,57),range(97,122)])))],
          lex(iter(char-class([range(48,57),range(97,122)]))),
          attrs([atr("left")])),
    [appl(
      prod([char-class([range(48,57),range(97,122)])],
           lex(iter(char-class([range(48,57),range(97,122)]))),
           no-attrs),
      ["b"]),
     appl(
      prod([char-class([range(48,57),range(97,122)])],
           lex(iter(char-class([range(48,57),range(97,122)]))),
           no-attrs),
      ["c"])])])])
\end{verbatim}

In \asfixme\ this subtree will have the following form:
\begin{verbatim}
appl(
 prod([char-class([range(97,122)]),
       lex(iter-star(char-class([range(48,57),range(97,122)])))],
      lex(sort("Elem")),attrs([id("TestSet")])),    
 ["a",["b","c"]])
\end{verbatim} 

\paragraph{Flattening of layout}

\subsection{Conversion Tooling}

\begin{description}
\item[{\tt flattenPT}] takes an \asfix\ term and produces an \asfixme\ term.
\item[{\tt inflatePT}] takes an \asfixme\ term and produces an \asfix\ term.
\item[{\tt implodePT}] takes an \asfixme\ term and produces an \aterm\ 
representing an abstract syntax tree in various forms depending on
the options, e.g., with/without layout, with/without literals, with/without
constructors, with/without flattened lexicals, etc.
\item[{\tt a2metoa1}] takes an \asfixme\ term and produces an {\sc AsFix}1
term, this function is only available for migration purposes and
will certainly disappear in the (near) future.
\end{description}
\end{document}
