%{{{ LaTeX configuration

% vim:ts=4:sw=4:tw=75
\documentclass[a4paper,twoside]{article}

%\usepackage{fullpage}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{makeidx}
\usepackage{epsfig}

\makeindex

\newcommand{\ASmetaenv}{{\sc Asf}+{\sc Sdf} Meta-En\-vir\-on\-ment}
\newcommand{\sdf}{{\sc Sdf}}
\newcommand{\asf}{{\sc Asf}}
\newcommand{\asfsdf}{{\sc Asf}+{\sc Sdf}}
\newcommand{\ATerm}{ATerm}
\newcommand{\ATerms}{ATerms}

%% notion of Symbol was changed to AFun, which matches specification.
\newcommand{\Symbol}{AFun}

\newcommand{\ATtrue}{\mbox{\tt ATtrue}}
\newcommand{\ATfalse}{\mbox{\tt ATfalse}}
\newcommand{\main}{\mbox{\tt main}}
\newcommand{\ATinit}{\mbox{\tt ATinit}}
\newcommand{\ATprotect}{\mbox{\tt ATprotect}}
\newcommand{\ATprotectArray}{\mbox{\tt ATprotectArray}}

\newcommand{\toolbus}{\mbox{\tt ToolBus}}

% \example{init.c} will input file "examples/init.c" in verbatim mode.
\newcommand{\example}[1]{
    \noindent
    \hrulefill
    \begin{small}
    \verbatiminput{examples/#1}
    \end{small}
    \hrulefill
}

% NULL
\newcommand{\NULL}{{\tt NULL}}               

% Function definition
\newcommand{\Function}[4]{
    \vspace{0.3cm}
    \noindent
    \framebox[12.6cm][l]{{\bf function:} {\tt #1}} \vspace{0.1cm}\newline
    \label{#1}
    \noindent
    {\bf Summary:\hspace{0.2cm}} #4\newline
    {\bf Declaration:}
        {\tt #2} {\tt #1}({\tt #3});
    \index{#1@{\tt #1}}
}
                                        

% Macro definition
\newcommand{\Macro}[4]{
    \vspace{0.3cm}
    \noindent
    \framebox[12.6cm][l]{{\bf macro:} {\tt #1}} \vspace{0.1cm}\newline
    \label{#1}
    \noindent
    {\bf Summary:\hspace{0.2cm}} #4\newline
    {\bf Declaration:}
        {\tt #2} {\tt #1}({\tt #3})
    \index{#1@{\tt #1}}
}
                        

% Method definition
\newcommand{\Method}[4]{
    \vspace{0.3cm}
    \noindent
    \framebox[12.6cm][l]{{\bf method:} {\tt #1}} \vspace{0.1cm}\newline
    \label{#1}
    \noindent
    {\bf Summary:\hspace{0.2cm}} #4\newline
    {\bf Declaration:}
        {\tt #2} {\tt #1}({\tt #3});
    \index{#1@{\tt #1}}
}

% Throws exception (optional)
\newcommand{\Throws}[2]{

\noindent{\bf Throws:} {\tt #1} #2
}                  

% Function/Macro/Method description (optional)
\newcommand{\Describe}[1]{

    \noindent{\bf Description:} #1
}

\def\aterms{\mbox{ATerms}}
\def\aterm{\mbox{ATerm}}
\def\asfix{\mbox{\sc AsFix}}

%}}}
%{{{ Title page and table of contents

%----[ TITLE PAGE ]----           
\title{\ASmetaenv\ User Manual}
\author{All\\
        {\small\sl Centrum voor Wiskunde en Informatica (CWI),}\\
{\small\sl Kruislaan 413, 1098 SJ Amsterdam, The Netherlands}}

\date{}
\begin{document}
\maketitle    

\begin{abstract}
This is a preliminary user manual for the \ASmetaenv\ Release 1.
This is work under construction.
\end{abstract}

\tableofcontents
\newpage

%}}}

%{{{ Overview

%---- [ OVERVIEW ]---- 

\section{Overview}\label{overview} 

\subsection{When to use the ASF+SDF Meta-Environment?}

The ASF+SDF Meta-Environment is an interactive development environment
for the automatic generation of interactive systems for manipulating
programs, specifications, or other texts written in a formal
language. The generation process is controlled by a definition of the
target language, which typically includes such features as syntax,
pretty printing, type checking and execution of programs in the target
language. The ASF+SDF Meta-environment can help you if:

\begin{itemize}

  \item You have to write a formal specification for some problem
  and you need interactive support to do this.

  \item You have developed your own (application) language and want to
  create an interactive environment for it.

  \item You have programs in some existing programming language and you
   want to analyze or transform them.
\end{itemize}

The ASF+SDF formalism allows the definition of syntactic as well as
semantic issues. It can be used for the definition of languages (for
programming, for writing specifications, for querying databases, for
text processing, or for dedicated applications). In addition it can be
used for the formal specification of a wide variety of
problems. ASF+SDF provides you with:

\begin{itemize}

  \item A general-purpose algebraic specification formalism based on equational logic. 

  \item Modular structuring of specifications.

  \item Integrated definition of lexical, context-free and abstract syntax. 

  \item User-defined syntax, allowing you to write specifications using your own notation. 

  \item Complete integration of the definition of syntax and
  semantics.

\end{itemize}

The ASF+SDF Meta-environment offers: 

\begin{itemize}

  \item Syntax-directed editing of ASF+SDF specifications.

  \item Incremental compilation and testing of specifications.

  \item Compilation of ASF+SDF specifications into dedicated
interactive environments containing various tools such as a lexical
analyzer, a parser, a pretty printer, a syntax-directed editor, a
debugger, and an interpreter or compiler.

\end{itemize}

The advantages of creating interactive environments in this way are twofold:

\begin{itemize}

  \item \emph{Increased uniformity}. Similar tools for different
  languages often suffer from a lack of uniformity.  Generating tools
  from language definitions will result in a large increase in
  uniformity, with corresponding benefits for the user.

  \item \emph{Reduced implementation effort.} Preparing a language
  definition requires significantly less effort than developing an
  environment from scratch.

\end{itemize}

\subsection{Global Structure of the Meta-Environment}

You can create new specifications or modify and test existing ones
using the Meta-Environment. Specifications consist of a series of
modules, and individual modules can be edited by invoking a module
editor. All editing in the Meta-environment is done by creating
instances of a \emph{generic syntax-directed editor}.

After each editing operation on a module its \emph{implementation} is updated
immediately. It consists of a lexical scanner, a parser, a pretty
printer, and a term rewriting system which are all derived from the
module automatically.

A module can be tested by invoking a \emph{term editor} to create and
evaluate terms defined by the module. Term editors use the syntax of
the module for parsing the textual representation of terms and for
converting them to internal format (abstract syntax trees). The
equations of the module are then used to reduce the terms into normal
form. This result is, in its turn, converted back to textual form by
pretty printing it.

%%The reduction of a term can be monitored by using EDB (Equation
%%Debugger), a debugging system that allows you to reduce a term
%%step-by-step or to place breakpoints for interrupting the reduction
%%process at specific moments.

Finally, term editors can be customized by adding \emph{buttons} whose
activation starts the evaluation of a function which is defined in the
specification. In this way you can customize the user-interface of the
application by adding, for instance, a typechecking or evaluation
button to a term editor. (** check; not in Release 1.**)

\subsection{About this Manual}

This manual is intended for those courageous users that want to try
out the new brand new implementation of the \ASmetaenv. This manual is
still under development and we welcome all feed back and comments.

%%In the sequel we will use \ASmetaenv\ to address the new
%%system and old \ASmetaenv\ when addressing the old system.

The focus in this manual will be on using the system to write a
specification like a type checker or evaluator for the toy language
PICO. It follows the user-interface to explain the capabilities of the
system.  Topics that will be addressed include:
\begin{itemize}
\item How to start the system, and how to leave it.
\item How to create, open and save a specification.
\item How to edit the syntax and/or equations part of a module.
\item How to edit a term.
\item How to evaluate a term.
\item How to compile a specification.
\item How to parse a term outside the \ASmetaenv.
\item How to rewrite a term using a compiled specification outside the
\ASmetaenv.
\item How to unparse parse and/or normalized terms.
\end{itemize}

\noindent We do \emph{not} explain:

\begin{itemize}
\item The formalism \asfsdf.
\item The architectural and implementational aspects of the system.
\item The stand alone usage of various parts fot he system.
\end{itemize}

\subsection{Further Reading}

\section{Starting the System}

The \ASmetaenv\ can be invoked via the command {\tt meta}.  As a
result, the \ASmetaenv\ main window pops up. This is shown in
Figure~\ref{FIG:meta-start}.


The {\tt meta} command has the following options, which may come in
handy later on.

\begin{itemize}

\item {\tt -c \emph{dir}} instructs the \asfsdf\ compiler to generate
C files in the directory \emph{dir}. Note that this directory is also
controlled by the environment {\tt COMPILER\_OUTPUT}

\item {\tt -d} starts the \ASmetaenv\ in debug mode. As a result,
an interactive viewer (``ToolBus viewer'') will be started that allows the study of
the internal behaviour of the system.

\item {\tt -h } shows help information for the {\tt meta} command.

\item {\tt -T \emph{port}} controls the communication ports that will
be used for communication between the components of the \ASmetaenv.
Note that these ports are also controlled by the environment variable
{\tt TB\_PORT}.  The default value is {\tt 8999}, but this port may be
in use by someone else (or by a aborted previous run of the
\ASmetaenv). In that case, it is advisable to use other value in the
range 9000 and up.

\item {\tt -v} runs the \ASmetaenv\ in verbose mode.

\item {\tt -V} shows the version number of the \ASmetaenv\ you are running.

\end{itemize}

Search paths can initialized via creating a file ``meta.conf''. This file
may contain a list of absolute and/or relative paths. See the meta.conf
file in the demo directory for an example. (**)

\begin{figure}[tb]

  \centerline{\epsfig{file=meta-start.ps,width=10cm}}
  \caption{\label{FIG:meta1} Main window of \ASmetaenv}

\end{figure}

\section{The Main Window}

The main window of the  \ASmetaenv\ consists of the following parts:

\begin{itemize}
\item At the top of the window is a menu bar that contains the following menus:
  \begin{itemize}

   \item {\tt File}: for creating, opening, saving and printing
    specifications as well as for leaving the \ASmetaenv.

   \item {\tt Edit}: for cut, copy, paste style editing and for setting user
      preferences.

   \item {\tt Graph}: for setting options for the display of 
        the graph in the import pane (see below).

   \item {\tt Debug}: for turning on/off the display of diagnostic messages.

   \item {\tt Help} for various forms of information and online help.

  \end{itemize}

\item The \emph{import pane}: A graphical canvas (empty in
Figure~\ref{FIG:meta-start}) at the left
hand side of the window that shows the import graph of the
specification you are editing.

\item The \emph{module list}: a vertical list (empty in
Figure~\ref{FIG:meta-start}) at
the right/middle part of the window that shows the names of
all modules in the current specification.

\item A vertical row of buttons at the right hand side of the window:
they are used for common operations on the current specification like
editing, saving or deleting a module, or compiling the complete
specification.

\item A status bar at the bottom of the window that shows the current
activity of the system. 

\end{itemize}

\begin{figure}[tb]
  \centerline{\epsfig{file=meta-pico.ps,width=10cm,angle=-90}}
  \caption{\label{FIG:meta-pico} Main window after loading the Pico specification}
\end{figure}

\section{The Menus of the Main Window}
 
\subsection{The File menu} \label{FileMenu}

\begin{figure}[tb]
  \centerline{\epsfig{file=file-menu.ps,width=3cm}}
  \caption{\label{FIG:file-menu} File pull-down menu of \ASmetaenv}
\end{figure}

The {\tt File} menu is used for creating, opening, saving and printing
specifications as well as for leaving the \ASmetaenv.  It is shown in Figure
\ref{FIG:file-menu} and contains the following entries:

\begin{itemize}

\item {\tt New}
\item {\tt Open}
\item {\tt Save}

\item {\tt Clear }
\item {\tt Revert}

\item {\tt Export}

\item {\tt Print Setup}
\item {\tt Print}
\item {\tt Quit}

\end{itemize} 

\begin{figure}[tb]
  \centerline{\epsfig{file=open-file.ps,width=3cm}}
  \caption{\label{FIG:open-file} Open module dialog}
\end{figure}

\subsection{The Edit menu}

\begin{itemize}
\item {\tt Undo}
\item {\tt Copy}
\item {\tt Paste}
\item {\tt Preferences}
\end{itemize}

\subsection{The Graph Menu}

\begin{figure}[tb]
  \centerline{\epsfig{file=graph-menu.ps,width=5cm}}
  \caption{\label{FIG:graph-menu} Graph pull-down menu of \ASmetaenv}
\end{figure}


The {\tt Graph} menu is used for setting options for the display of the graph
in the import pane.  It is shown in Figure \ref{FIG:graph-menu} and contains
the entries:

\begin{itemize}
\item {\tt View All}
\item {\tt Autoresize after loading}
\item {\tt Animate while loading}
\end{itemize}

\subsection{The Debug Menu}

\begin{figure}[tb]
  \centerline{\epsfig{file=debug-menu.ps,width=6cm}}
  \caption{\label{FIG:debug-menu}The Debug  Menu}
\end{figure}

The {\tt Debug} menu is shown in Figure~\ref{FIG:debug-menu} and contains the
single check box {\tt Diagnostic messages}.  When turned on, diagnostic
messages will be displayed.  Otherwise the systems runs silently.

\subsection{The Help Menu}

\begin{figure}[tb]
  \centerline{\epsfig{file=help-menu.ps,width=6cm}}
  \caption{\label{FIG:help-menu}The Help  Menu}
\end{figure}

The {\tt Help} menu is shown in Figure~\ref{FIG:help-menu}
and contains the following entries:

\begin{itemize}
\item {\tt About NewMeta}
\item {\tt Meta-Environment}
\item {\tt Mouse operations}
\item {\tt Online help}
\end{itemize}

\section{The Panes of the Main Window}

The two left-most panes of the main window give two, alternative,
views on the same information: the \asfsdf\ specification that has
been loaded into the Meta-Environment.  Using one of these views, the
same set of operations is available either via a pop menu or via the
buttons in the pane at the right-hand side of the main window.

\subsection{The Import Pane}

The \emph{import pane} gives a graphical view of the specification by
displaying the \emph{import} relation between modules in the form of a
graph. A module $M_1$ imports another module $M_2$ if $M_1$ contains
an import statement of the form {\tt imports $M_2$}.

Each module is represented by a circle and an arrow between two
circles represents an import relation between the two corresponding
modules.

The import pane has the following interaction facilities:

\begin{itemize}

\item Clicking \emph{on} a module yields a pop up menu
with the same entries as the button pane of the main window
(see Section \ref{ButtonPane})
\item Clicking \emph{outside} any module yields a pop up menu
with the entries {\tt New} and {\tt Open} for creating a new,
respectively, opening an existing module. These two operations
are also part of the file menu (see Section~\ref{FileMenu}).

\end{itemize}

\begin{figure}[tb]
  \centerline{\epsfig{file=module-menu.ps,width=6cm}}
  \caption{\label{FIG:module-menu}Pop up menu for module operations}
\end{figure}

\begin{figure}[tb]
  \centerline{\epsfig{file=new-open.ps,width=6cm}}
  \caption{\label{FIG:new-open}Pop up menu for adding a module}
\end{figure}


\subsection{The Module Pane}

The import pane is particularly usefull when you want to understand the
overall structure of a specification but it may become unwieldy for
very large specifications. For large specifications the module pane
may give you quicker access to the modules in the specification.

It presents a vertical, scrollable, list of the names of all the modules in
the specification.

\subsection{The Button Pane of the Main Window} \label{ButtonPane}

  \begin{itemize}
  \item {\tt Edit Sdf2}
  \item {\tt Edit Eqs}
  \item {\tt Term}
  \item {\tt Save}
  \item {\tt Revert}
  \item {\tt Delete}
  \item {\tt Info}
  \item {\tt Compile}
  \end{itemize}

\section{Editing Specifications}

\subsection{Editing the syntax part of a module}

\subsection{Editing the equations of a module}

\subsection{Editing terms}

\section{Executing Specifications}

\subsection{Evaluating terms}

\subsection{Compiling a specification}

\section{Guided Tour}

(*** Under construction ***)

\begin{figure}[tb]
  \centerline{\epsfig{file=meta-booleans.ps,width=6cm}}
  \caption{\label{FIG:meta-booleans}Main window after opening {\tt Pico-Booleans}}
\end{figure}

To help you to get acquainted with the ASF+SDF Meta-environment the system
comprises two example specifications, namely the one-module specification:
{\tt Bool-example}, and the specification of the syntax, typechecker and dynamic
semantics of the small programming language Pico.

This Guided Tour is meant to guide you through these specifications, and show
you the main features of the ASF+SDF Meta-environment. Only global information
is given about these features but references are made to parts of the
user-manual with detailed information.

\subsection{Before you start the Guided Tour}

The Meta-Environment is usually installed in a directory named {\tt
  meta-$version$}. For Release 1, this may, for instance, be {\tt meta-1.0.0}.
You will then find the files needed for this Guided Tour in the directory {\tt
  meta-1.0.0/demo/pico}. It is advisable to make your personal copy of this
directory.  In this Guided Tour we will use `{\tt pico}' to refer to your own
copy of the directory.

For each module in a specification two files exist: `{\tt $module$.sdf2}'
\footnote{In the current version the extension is `{\tt sdf2}' ; should this
  not be changed to `{\tt .syn}'?}  contains the syntax of $module$ and `{\tt
  $module$.eqs}' contains the semantics (equations) of $module$. The directory
pico contains:

\begin{itemize}

\item two files for the module {\tt Bool-example}.

\item files for the Pico-specification.

\item three examples of Pico-programs: `{\tt big.pico}', `{\tt fac.pico}',
  `{\tt small.pico}'.

\item terms for typechecking and evaluating these Pico-programs.

\end{itemize}

\subsection{Beginning the Guided Tour}

\begin{itemize}

\item Go to directory pico. 
\item Type the command {\tt meta}. The main window of the Meta-environment
  will appear.
  
\item Add the module {\tt Bool-example} by selecting the File menu, and
  choosing the Open button. In a dialog window, the system asks you to give
  the name of the module to be opened. It presents a list of all files with
  extension `{\tt sdf2}'. Click once on `{\tt Bool-example.sdf2}' and then
  push the {\tt Open} button. This will load the module {\tt Module-example}
  (both its syntax and equations!) into the system
\footnote{*** Strictly speaking this is strange; it would be better to only
display module names without any extension.}
  
\item Verify that module {\tt Bool-example} appears as a rectangle in the import pane
  as well as in the module pane of the main window.

\end{itemize}

\subsection{The Module Bool-example}

One of the simplest specifications possible, and therefore frequently used as
an example, is the datatype of the Boolean values. It defines the constants
{\tt true} and {\tt false} and the functions \emph{and} and \emph{or}
 (written in infix notation using
the left-associative operators `{\tt \&}' and `{\tt |}', respectively) and
\emph{not} (written
in prefix notation using the function symbol `{\tt not}'). Here is the
specification:

\begin{verbatim}
module Bool-example
  exports
    sorts BOOL 
    lexical syntax
      [\ \t\n]           -> LAYOUT

    context-free syntax
      "true"             -> BOOL
      "false"            -> BOOL 
      BOOL "|" BOOL      -> BOOL {left}
      BOOL "&" BOOL      -> BOOL {left}
      "not" "(" BOOL ")" -> BOOL
      "(" BOOL ")"       -> BOOL {bracket}

    variables
      "Bool"[0-9\']* -> BOOL

    context-free priorities
      BOOL "&" BOOL -> BOOL >
      BOOL "|" BOOL -> BOOL

    equations

    [B1] true | Bool = true 
    [B2] false | Bool = Bool

    [B3] true & Bool = Bool 
    [B4] false & Bool = false

    [B5] not(false) = true 
    [B6] not(true) = false

\end{verbatim}

\subsubsection{The module editor for {\tt Bool-example}}

\begin{itemize}
  
\item Select module {\tt Bool-example} from the module pane (the vertical list
  of module names that now only contains {\tt Bool-example}) by clicking on it
  once.
  
\item Push the button {\tt Edit Sdf2} in the button pane at the right-hand
  side of the main window.  An editor will appear containing the syntax part
  of the {\tt Bool-example} specification: the SDF section.  This editor is a
  version of the standard text editor Emacs extended with the menu {\tt
    Meta-Environment}.
  
\item Push the button {\tt Edit Eqs}.  This will reuse the already created
  instance of Emacs by adding a new buffer to it containing the semantic part
  of the {\tt Bool-example} specification: a list of conditional equations.
  Note that the syntax of the equations is determined by the syntax defined in
  the SDF section. Use the {\tt Buffers} menu of Emacs to see which buffers
  are open and to switch between buffers.

\end{itemize}

\subsubsection{A Term Editor for {\tt Bool-example}}

\begin{itemize}
\item Open a term-editor over module {\tt Bool-example} by first selecting
  module {\tt Bool-example} in the module pane, and then pushing the {\tt
    Term} button.  A dialog window pops up\footnote{Why is this note a
    standard file dialog?}
    Enter any new filename, for instance, `{\tt my-term}'.

\item 
  Type the term `{\tt true \& false}' in this editor. Observe how the text
  that you type gets a light blue background.
  This is called a \emph{focus}.

\item Click in the focus, this will move the cursor (a single character-sized
  red rectangle) 
  
\item From menu {\tt Meta-Envrionment} click the {\tt Parse} button.  The text
  in the focus is now parsed and the blue background has disappeared.

\end{itemize}

All the text\emph{ outside} the focus is (by definition) always syntactically
correct. The text \emph{inside} the focus is fresh text which may contain syntax
errors.

\begin{itemize}

\item Click on one of the characters of the word `{\tt false}'.
You have selected `{\tt false}' as new focus and 
the blue background reappears.

\item Click on the \emph{and} operator `{\tt \&}'.  The whole expression is
  now selected as focus.

\end{itemize}

The movements of the focus are \emph{syntax-directed}: when you click on any
character in the text, the smallest syntactic unit enclosing that character
will be selected and becomes the focus.

\begin{itemize}
  
\item Reduce the term in the term-editor by clicking the {\tt Reduce} button
  in the {\tt Meta-Environment} menu of the editor.  The result will appear in
  the terminal window from which the Meta-Environment was started.

\end{itemize}

\paragraph{Error-messages}

\begin{itemize}
  
\item Edit the term `{\tt true \& false}' such that the new term will be
  syntactically incorrect. For instance, type `{\tt true \& wrong}'. Force a
  parse of the term by selecting the {\tt Parse } button of the {\tt
    Meta-Envrionment} menu.
  
  In the status line at the bottom of the edit window a message will appear
  message `{\tt Parse error near cursor}' and the cursor will be positioned in
  the word `{\tt wrong}'

\end{itemize}

\paragraph{Associativity, Priorities and Brackets}

\begin{itemize}
  
\item Erase the term in your term-editor and type a new term `{\tt true \&
    false \& true}'. 

\item Parse the term using the {\tt Parse} button.

\item  Try to find out how this term has been parsed by clicking
  on different parts of the term and studying the resulting focus.

\end{itemize}

The {\tt left} attribute in the SDF definition indicates that the `{\tt \&}'
operator is left associative. The term will thus be parsed as `{\tt (true \&
  false) \& true}'. Clicking on the left or right {\tt \&} yields a focus that
corresponds with this parse.

\begin{itemize}
  
\item Erase the term in your term-window and type a new term `{\tt true |
    false \& true}'. 
\item Parse the term using the {\tt Parse} button.
  
\item Try to find out how this term has been parsed by clicking on various
  parts of the term and studying the resulting focus.

\end{itemize}

The {\tt context-free priorities} definitions in the SDF definition state that the `{\tt
  \&}' operator binds stronger than the `{\tt |}' operator.

\begin{itemize}
  
\item Erase the term in the term-editor and type a new term `{\tt true \&
    false}'.  Click on `false', so that the focus is around `false' only. Then
  add `{\tt | true}' after `{\tt false}', so that the resulting term is `{\tt
    true \& false | true}'.  

\item Parse the term.

\item Click on the `{\tt \&}' symbol. Is this what you wanted? Probably not.
\end{itemize}
  
To resolve a priority conflict `{\tt (}' and `{\tt )}' which are defined as
brackets in the SDF definition are put around the term `{\tt false | true}'.
Thus `{\tt true \& (false | true})' is more likely to express what you
intended.

\subsubsection{Modifying {\tt Bool-example}}

The ASF+SDF Meta-Environment is an \emph{incremental environment generator}. After
each edit operation on a module, its \emph{implementation} (i.e., scanner, parser and
term rewriting system) is updated immediately.

The editing of both the syntax section and the equations secion of a module is
syntax-directed like the editing of terms in a term editor.

\paragraph{Modifying the Equations}

The equation section of a module begins with the keyword {\tt equations}
and is saved in files ending on `{\tt .eqs}'.

\begin{itemize}

\item  Click in the equation section to investigate the focus behavior.
  
\item Change the equations, for instance replace in equation {\tt [B1]} the
  last part `{\tt = true}' by `{\tt = false}'. 
  
\item Study the effect on the reduction of terms in the term-editor.

\end{itemize}

\paragraph{Modifying the Syntax}

The syntax part of a module starts with the keyword {\tt module}
and  is saved in files ending on `{\tt .sdf2}'.
Modifying the syntax causes the generated scanner and parser to be adapted.
After each edit operation in the SDF section that is followed by a parse of
the SDF section, the focus in both the equations section and the term editor
is extended to completely contain the text in these editors.

Modifying the context-free syntax:

\begin{itemize}
  
\item Change the syntax of the defined functions. E.g, replace `{\tt not}' by
  `{\tt negation}'.

\item Try to re-parse the equations. 
  
%%\item Investigate the expand menu in the term-editor. (type `{\tt <BOOL>}' and
%%  select {\tt expand}.)

\end{itemize}

Modifying the priorities: 

\begin{itemize}

\item Remove the priority declaration. 
  
\item Type the term `{\tt true \& false | true}' in the term-editor (or
  anything similar according to your current syntax). Try to parse this term.
\footnote{PROBLEM: there is no feed back here that there is an ambiguity!}

\item Add the priority declarations again.

\end{itemize}

Modifying layout in the lexical section: 

\begin{itemize}

\item Remove the lexical syntax with the {\tt LAYOUT} definitions. 

\item Try parsing equations of {\tt Bool-example}.

\end{itemize}

\paragraph{Note:} Not defining {\tt LAYOUT} is one of the errors most commonly
made when writing a new specification; always make sure your syntax
definitions define at least spaces and newlines to be {\tt LAYOUT}.

\begin{itemize}
  
\item End the editing of your term and the module {\tt Bool-example} by
  selecting the {\tt Exit XEmacs} from the {\tt File} menu of the editor.  You
  may or may not save the changes to module Bool-example.

\end{itemize}

If you save the changes the files `{\tt Bool-example.sdf2}' and `{\tt
  Bool-example.eqs}' will be modified.


\begin{itemize}
  
\item Delete the module {\tt Bool-example} from the specification.  Click on
  {\tt Bool-example} in the module pane and push the {\tt Delete} button. The
  module remains known to the system and its graphical representation is
  changed form a rectangle to an ellipse. It can be re-opened later on.
  
\item Leave the system by pushing the {\tt Quit} entry in the {\tt File} menu
  of the main window of the \ASmetaenv.

\end{itemize}

\subsection{The Pico Specification}

More features of the  \ASmetaenv\  can be studied by looking at the
Pico specification.

\begin{itemize}
  
\item Start the Meta-Environment: go to directory {\tt
    pico}, and type `{\tt meta}'.
  
\item Add the module {\tt Pico-syntax} by selecting the {\tt File} menu, and
  choosing the {\tt Open...} button.  In the dialog window that appears, click
  on {\tt Pico-syntax.sdf2} and push the {\tt Open} button.
  
\item As you can see in both the import pane and the module pane, not only
  {\tt Pico-syntax} has been added, but also all modules that are directly or
  transitively imported by {\tt Pico-syntax}.

\end{itemize}

\subsubsection{The Module Editor for Pico-syntax}

\begin{itemize}
  
\item Open an editor for the syntax of {\tt Pico-syntax} (using the {\tt Edit
    Sdf2} button.

\end{itemize}
  
  A Pico program consist of the word `{\tt begin}', a declaration section, a
  series of zero or more statements, and the word `{\tt end}'. The declaration
  section consists of the word `{\tt declare}', a list of zero or more tuples
  `{\tt $identifier$ : $type$}' and a semi-colon `{\tt ;}'. Types are `{\tt
    string}' and `{\tt natural}'.  There are three kinds of statements:
  assignments, if-then-else statements and while-loops. And there are
  expressions.

\paragraph{Notes:}

\begin{itemize}
  
\item A module{\tt Layout} is imported, in which the sort {\tt LAYOUT} has been
  specified.
  
\item The use of list constructs in the context-free section: `{\tt {-ID-TYPE
      ","}*}' and `{\tt {STATEMENT ","}*}'. In fact, the sort {\tt SERIES}
  could have been left out entirely and be replaced by `{\tt {STATEMENT
      ","}*}' all through the specification. {\tt SERIES} is only used for
  abbreviation in the syntax rules. Also, variables over list constructs are
  being declared.
  
\item When a literal in a context-free function consists only of lower case
  letters and digits, and it is not a SDF-keyword, it need not be quoted.

\item  The Pico-syntax module naturally contains no equations.

\end{itemize}

\subsubsection{A Term Editor for Pico-syntax}

\begin{itemize}
  
\item Open a term-editor for the Pico-program `{\tt small.pico}': select {\tt
    Pico-syntax} in the module pane and push the {\tt term} button in the
  button pane. A dialog window pops up and type `{\tt small.pico}' as name of
  the term.

\item Press the {\tt Parse} button in the {\tt Meta-Environment} menu of the
  editor. As a result, {\tt small.pico} is parsed.

\item Press the {\tt Reduce} button in the {\tt Meta-Environment} menu of the
  editor.

\end{itemize}

This has the following effects:

\begin{itemize}

\item  The term in the editor is parsed. 
  
\item All the equations that are valid for this editor are parsed and compiled
  into a rewrite system.  In this case that means the equations of the
  imported modules {\tt Pico-Booleans}, {\tt Pico-Integers}, {\tt Pico-Strings} and {\tt
    Pico-Types}. This takes some time.
  
\item The term in the editor is reduced. As no equation can be applied to
  reduce this term, the term itself is returned in the shell window from which
  the Meta-Environment has been started.
\end{itemize}

  
Reducing a term for the second time is notably faster: the equations have been
compiled already. If you are curious what is going, have a look at the
status field at the bottom of the main window. It reveals the steps that
are necessary to arrive at an executable specification.

\begin{itemize}
\item Verify this by pushing the {\tt Reduce} button once more.
\end{itemize}

\begin{itemize}

\item Load the module {\tt Pico-typecheck} in the Meta-Environment.

\item Open a term editor for the term {\tt smalltc.pico}.

\item Reduce this term.

\end{itemize}

This has the following effects:

\begin{itemize}

\item  The module {\tt Pico-typecheck} is added to the specification. 
  
\item The term in {\tt smalltc.pico} is identical to the one in {\tt
    small.pico}, except that the program has been surrounded by `{\tt tcp(}
  and `{\tt )}'.  The function {\tt tcp} (for type check program), applies the
  typing rules for the Pico language to its single argument: a complete Pico
  program. The result is {\tt true} or {\tt false}.
  
\item All equations of {\tt Pico-typecheck} and its imported
  modules are being compiled.
  
\item The term {\tt smalltc.pico} is reduced using the equations of {\tt
    Pico-typecheck}.

\end{itemize}
  
Typechecking a term for the second time is notably faster, the
modules have been added already and the equations have been compiled.

\begin{itemize}

\item Verify this, by pushing {\tt Reduce} once more.
  
\item Make some modifications to `{\tt smalltc.pico}' in the term-editor.
  Typecheck the modified program.
  
\item Open term-editors with other pico programs (`{\tt fac.pico}', `{\tt
    big.pico}') or create your own program. The corresponding applications of
  the type check function are in `{\tt factc.pico}', respectively, `{\tt
    bigtc.pico}'.  Typecheck these programs.

\end{itemize}

The evaluation (execution) of programs is achieved in a similar fashion as
typechecking. The evaluation rules are defined in the module `{\tt
  Pico-eval}'. Applications of the evaluation function `{\tt evp}' can be
found in `{\tt smallev.pico}', `{\tt facev.pico}', and `{\tt bigev.pico}.

\begin{itemize}
  
\item Repeat the steps described above for typechecking, now for the
  evaluation of Pico programs.

\end{itemize}

\subsubsection{More Exercises to Study the Pico Specification}

\begin{itemize}

\item Study other modules in the specification. The modules {\tt
    Pico-typecheck} and {\tt  Pico-eval} are explained in the next sections.
  
\item Add a repeat statement `{\tt repeat SERIES until EXP}' to {\tt
    Pico-syntax}, add typecheck equations to {\tt Pico-typecheck}, and
  eval-equations to {\tt Pico-eval}, for this new statement.

\item Add your own module to the specification. 

\item Make your own specification. Create a new directory for each
  specification.

\end{itemize}

\subsubsection{Module Pico-typecheck}

\begin{itemize}

\item Open an editor for the syntax and equations of {\tt Pico-typecheck}.

\end{itemize}

The function `{\tt tcp}' is defined for typechecking Pico-programs.
Variants of this function exist for typechecking various parts of a Pico program. 
The
typechecking of the declarations yields a type-environment: a table of
identifiers and their types. This type-environment, and the `{\tt lookup}'
function is specified in the module {\tt Type-environments}. The typechecking
of statements uses a type-environment and yields a Boolean value.

In the equations is defined how a Pico-program is typechecked. Equation {\tt
  [Tc1]} says that the typechecking of a program is `{\tt true}' if the
typechecking of the Series in the type-environments, `{\tt tcd(Decls)}', is
`{\tt true}'.

Equations {\tt [Tc2]} and {\tt [Tc3]} specify how a type-environment is
constructed, when the declarations are typechecked.

Equations {\tt [Tc3a]} and {\tt [Tc3b]} specify the typechecking of a,
possibly empty, list of statements. Equations {\tt [Tc4a]} through {\tt
  [default-Tc6} specify how the three kinds of Statements are typechecked
using the information from the type-environment.

The rest of the equations deal with the typechecking of expressions.

\subsubsection{Module Pico-eval}

\begin{itemize}

\item Open an editor for the syntax and equations of {\tt Pico-eval}.

\end{itemize}

The functions `{\tt evp}' and variants are defined for describing the dynamic semantics of
Pico. The result of evaluation is a value-environment: a table of identifiers
and values with the final values of the declared identifiers. (Note that Pico
does not have an output-statement.)

In the equations is defined how a program is evaluated. Equation {\tt [Ev1]}
says that the evaluation of a program is the evaluation of the Series in the
value-environments, `{\tt evs(Decls)}'.

Equations {\tt [Ev2]} thorugh {\tt [Ev3c]}  specify how a
value-environment is constructed, when the declarations are evaluated.
Identifiers of type `{\tt natural}' get value `{\tt 0}', Identifiers of type
`{\tt string}' get value `{\tt ""}' (the empty-string).

Equations {\tt [Ev4a]} and {\tt [Ev4b]} specify the evaluation of a, possibly
empty, list of statements. Equations {\tt [Ev5a]} through {\tt [Ev5e]}
specify how the three kinds of statements are
evaluated using the information from the type-environment. Evaluating
statements means updating the value-environment.

The rest of the equations deal with the evaluation of expressions. Evaluating
expressions results in a value.

\section{The ASF+SDF specification formalism}

\section{Miscellaneous}

\subsection{Parsing a term outside the \ASmetaenv}

\subsection{Rewriting a term using a compiled specification}

\subsection{Unparsing a (parsed/normalized) term}

\end{document}
