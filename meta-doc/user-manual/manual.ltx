%{{{ LaTeX configuration

% vim:ts=4:sw=4:tw=75
\documentclass[a4paper,twoside]{article}

%\usepackage{fullpage}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{makeidx}
\usepackage{epsfig}

\makeindex

\newcommand{\ASmetaenv}{{\sc Asf}+{\sc Sdf} Meta-En\-vir\-on\-ment}
\newcommand{\sdf}{{\sc Sdf}}
\newcommand{\asf}{{\sc Asf}}
\newcommand{\asfsdf}{{\sc Asf}+{\sc Sdf}}
\newcommand{\ATerm}{ATerm}
\newcommand{\ATerms}{ATerms}

%% notion of Symbol was changed to AFun, which matches specification.
\newcommand{\Symbol}{AFun}

\newcommand{\ATtrue}{\mbox{\tt ATtrue}}
\newcommand{\ATfalse}{\mbox{\tt ATfalse}}
\newcommand{\main}{\mbox{\tt main}}
\newcommand{\ATinit}{\mbox{\tt ATinit}}
\newcommand{\ATprotect}{\mbox{\tt ATprotect}}
\newcommand{\ATprotectArray}{\mbox{\tt ATprotectArray}}

\newcommand{\toolbus}{\mbox{\tt ToolBus}}

% \example{init.c} will input file "examples/init.c" in verbatim mode.
\newcommand{\example}[1]{
    \noindent
    \hrulefill
    \begin{small}
    \verbatiminput{examples/#1}
    \end{small}
    \hrulefill
}

% NULL
\newcommand{\NULL}{{\tt NULL}}               

% Function definition
\newcommand{\Function}[4]{
    \vspace{0.3cm}
    \noindent
    \framebox[12.6cm][l]{{\bf function:} {\tt #1}} \vspace{0.1cm}\newline
    \label{#1}
    \noindent
    {\bf Summary:\hspace{0.2cm}} #4\newline
    {\bf Declaration:}
        {\tt #2} {\tt #1}({\tt #3});
    \index{#1@{\tt #1}}
}
                                        

% Macro definition
\newcommand{\Macro}[4]{
    \vspace{0.3cm}
    \noindent
    \framebox[12.6cm][l]{{\bf macro:} {\tt #1}} \vspace{0.1cm}\newline
    \label{#1}
    \noindent
    {\bf Summary:\hspace{0.2cm}} #4\newline
    {\bf Declaration:}
        {\tt #2} {\tt #1}({\tt #3})
    \index{#1@{\tt #1}}
}
                        

% Method definition
\newcommand{\Method}[4]{
    \vspace{0.3cm}
    \noindent
    \framebox[12.6cm][l]{{\bf method:} {\tt #1}} \vspace{0.1cm}\newline
    \label{#1}
    \noindent
    {\bf Summary:\hspace{0.2cm}} #4\newline
    {\bf Declaration:}
        {\tt #2} {\tt #1}({\tt #3});
    \index{#1@{\tt #1}}
}

% Throws exception (optional)
\newcommand{\Throws}[2]{

\noindent{\bf Throws:} {\tt #1} #2
}                  

% Function/Macro/Method description (optional)
\newcommand{\Describe}[1]{

    \noindent{\bf Description:} #1
}

\def\aterms{\mbox{ATerms}}
\def\aterm{\mbox{ATerm}}
\def\asfix{\mbox{\sc AsFix}}

%}}}
%{{{ Title page and table of contents

%----[ TITLE PAGE ]----           
\title{\ASmetaenv\ User Manual}
\author{All\\
        {\small\sl Centrum voor Wiskunde en Informatica (CWI),}\\
{\small\sl Kruislaan 413, 1098 SJ Amsterdam, The Netherlands}}

\date{}
\begin{document}
\maketitle    

\begin{abstract}
This is a very preliminary user manual for the \ASmetaenv\ Release 1.
\end{abstract}

\tableofcontents
\newpage

%}}}

%{{{ Overview

%---- [ OVERVIEW ]---- 

\section{Overview}\label{overview} 

\subsection{When to use the ASF+SDF Meta-Environment?}

The ASF+SDF Meta-Environment is an interactive development environment
for the automatic generation of interactive systems for manipulating
programs, specifications, or other texts written in a formal
language. The generation process is controlled by a definition of the
target language, which typically includes such features as syntax,
pretty printing, type checking and execution of programs in the target
language. The ASF+SDF Meta-environment can help you if:

\begin{itemize}

  \item You have to write a formal specification for some problem
  and you need interactive support to do this.

  \item You have developed your own (application) language and want to
  create an interactive environment for it.

  \item You have programs in some existing programming language and you
   want to analyze or transform them.
\end{itemize}

The ASF+SDF formalism allows the definition of syntactic as well as
semantic issues. It can be used for the definition of languages (for
programming, for writing specifications, for querying databases, for
text processing, or for dedicated applications). In addition it can be
used for the formal specification of a wide variety of
problems. ASF+SDF provides you with:

\begin{itemize}

  \item A general-purpose algebraic specification formalism based on equational logic. 

  \item Modular structuring of specifications.

  \item Integrated definition of lexical, context-free and abstract syntax. 

  \item User-defined syntax, allowing you to write specifications using your own notation. 

  \item Complete integration of the definition of syntax and
  semantics.

\end{itemize}

The ASF+SDF Meta-environment offers: 

\begin{itemize}

  \item Syntax-directed editing of ASF+SDF specifications.

  \item Incremental compilation and testing of specifications.

  \item Compilation of ASF+SDF specifications into dedicated
interactive environments containing various tools such as a lexical
analyzer, a parser, a pretty printer, a syntax-directed editor, a
debugger, and an interpreter or compiler.

\end{itemize}

The advantages of creating interactive environments in this way are twofold:

\begin{itemize}

  \item \emph{Increased uniformity}. Similar tools for different
  languages often suffer from a lack of uniformity.  Generating tools
  from language definitions will result in a large increase in
  uniformity, with corresponding benefits for the user.

  \item \emph{Reduced implementation effort.} Preparing a language
  definition requires significantly less effort than developing an
  environment from scratch.

\end{itemize}

\subsection{Global Structure of the Meta-Environment}

You can create new specifications or modify and test existing ones
using the Meta-Environment. Specifications consist of a series of
modules, and individual modules can be edited by invoking a module
editor. All editing in the Meta-environment is done by creating
instances of a \emph{generic syntax-directed editor}.

After each editing operation on a module its \emph{implementation} is updated
immediately. It consists of a lexical scanner, a parser, a pretty
printer, and a term rewriting system which are all derived from the
module automatically.

A module can be tested by invoking a \emph{term editor} to create and
evaluate terms defined by the module. Term editors use the syntax of
the module for parsing the textual representation of terms and for
converting them to internal format (abstract syntax trees). The
equations of the module are then used to reduce the terms into normal
form. This result is, in its turn, converted back to textual form by
pretty printing it.

%%The reduction of a term can be monitored by using EDB (Equation
%%Debugger), a debugging system that allows you to reduce a term
%%step-by-step or to place breakpoints for interrupting the reduction
%%process at specific moments.

Finally, term editors can be customized by adding \emph{buttons} whose
activation starts the evaluation of a function which is defined in the
specification. In this way you can customize the user-interface of the
application by adding, for instance, a typechecking or evaluation
button to a term editor. (** check; not in Release 1.**)

\subsection{About this Manual}

This manual is intended for those courageous users that want to try
out the new brand new implementation of the \ASmetaenv. This manual is
still under development and we welcome all feed back and comments.

%%In the sequel we will use \ASmetaenv\ to address the new
%%system and old \ASmetaenv\ when addressing the old system.

The focus in this manual will be on using the system to write a
specification like a type checker or evaluator for the toy language
PICO. It follows the user-interface to explain the capabilities of the
system.  Topics that will be addressed include:
\begin{itemize}
\item How to start the system, and how to leave it.
\item How to create, open and save a specification.
\item How to edit the syntax and/or equations part of a module.
\item How to edit a term.
\item How to evaluate a term.
\item How to compile a specification.
\item How to parse a term outside the \ASmetaenv.
\item How to rewrite a term using a compiled specification outside the
\ASmetaenv.
\item How to unparse parse and/or normalized terms.
\end{itemize}

\noindent We do \emph{not} explain:

\begin{itemize}
\item The formalism \asfsdf.
\item The architectural and implementational aspects of the system.
\item The stand alone usage of various parts fot he system.
\end{itemize}

\subsection{Further Reading}

\section{Starting the System}

The \ASmetaenv\ can be invoked via the command {\tt meta}.  As a
result, the \ASmetaenv\ main window pops up. This is shown in
Figure~\ref{FIG:meta-start}.


The {\tt meta} command has the following options, which may come in
handy later on.

\begin{itemize}

\item {\tt -c \emph{dir}} instructs the \asfsdf\ compiler to generate
C files in the directory \emph{dir}. Note that this directory is also
controlled by the environment {\tt COMPILER\_OUTPUT}

\item {\tt -d} starts the \ASmetaenv\ in debug mode. As a result,
an interactive viewer (``ToolBus viewer'') will be started that allows the study of
the internal behaviour of the system.

\item {\tt -h } shows help information for the {\tt meta} command.

\item {\tt -T \emph{port}} controls the communication ports that will
be used for communication between the components of the \ASmetaenv.
Note that these ports are also controlled by the environment variable
{\tt TB\_PORT}.  The default value is {\tt 8999}, but this port may be
in use by someone else (or by a aborted previous run of the
\ASmetaenv). In that case, it is advisable to use other value in the
range 9000 and up.

\item {\tt -v} runs the \ASmetaenv\ in verbose mode.

\item {\tt -V} shows the version number of the \ASmetaenv\ you are running.

\end{itemize}

Search paths can initialized via creating a file ``meta.conf''. This file
may contain a list of absolute and/or relative paths. See the meta.conf
file in the demo directory for an example. (**)

\begin{figure}[tb]

  \centerline{\epsfig{file=meta-start.ps,width=10cm}}
  \caption{\label{FIG:meta1} Main window of \ASmetaenv}

\end{figure}

\section{The Main Window}

The main window of the  \ASmetaenv\ consists of the following parts:

\begin{itemize}
\item At the top of the window is a menu bar that contains the following menus:
  \begin{itemize}

   \item {\tt File}: for creating, opening, saving and printing
    specifications as well as for leaving the \ASmetaenv.

   \item {\tt Edit}: for cut, copy, paste style editing and for setting user
      preferences.

   \item {\tt Graph}: for setting options for the display of 
        the graph in the import pane (see below).

   \item {\tt Debug}: for turning on/off the display of diagnostic messages.

   \item {\tt Help} for various forms of information and online help.

  \end{itemize}

\item The \emph{import pane}: A graphical canvas (empty in
Figure~\ref{FIG:meta-start}) at the left
hand side of the window that shows the import graph of the
specification you are editing.

\item The \emph{module list}: a vertical list (empty in
Figure~\ref{FIG:meta-start}) at
the right/middle part of the window that shows the names of
all modules in the current specification.

\item A vertical row of buttons at the right hand side of the window:
they are used for common operations on the current specification like
editing, saving or deleting a module, or compiling the complete
specification.

\item A status bar at the bottom of the window that shows the current
activity of the system. 

\end{itemize}

\begin{figure}[tb]
  \centerline{\epsfig{file=meta-pico.ps,width=10cm,angle=-90}}
  \caption{\label{FIG:meta-pico} Main window after loading the Pico specification}
\end{figure}

\section{The Menus of the Main Window}
 
\subsection{The File menu} \label{FileMenu}

\begin{figure}[tb]
  \centerline{\epsfig{file=file-menu.ps,width=3cm}}
  \caption{\label{FIG:file-menu} File pull-down menu of \ASmetaenv}
\end{figure}

The {\tt File} menu is used for creating, opening, saving and printing
specifications as well as for leaving the \ASmetaenv.  It is shown in Figure
\ref{FIG:file-menu} and contains the following entries:

\begin{itemize}

\item {\tt New}
\item {\tt Open}
\item {\tt Save}

\item {\tt Clear }
\item {\tt Revert}

\item {\tt Export}

\item {\tt Print Setup}
\item {\tt Print}
\item {\tt Quit}

\end{itemize} 

\begin{figure}[tb]
  \centerline{\epsfig{file=open-file.ps,width=3cm}}
  \caption{\label{FIG:open-file} Open module dialog}
\end{figure}

\subsection{The Edit menu}

\begin{itemize}
\item {\tt Undo}
\item {\tt Copy}
\item {\tt Paste}
\item {\tt Preferences}
\end{itemize}

\subsection{The Graph Menu}

\begin{figure}[tb]
  \centerline{\epsfig{file=graph-menu.ps,width=5cm}}
  \caption{\label{FIG:graph-menu} Graph pull-down menu of \ASmetaenv}
\end{figure}


The {\tt Graph} menu is used for setting options for the display of the graph
in the import pane.  It is shown in Figure \ref{FIG:graph-menu} and contains
the entries:

\begin{itemize}
\item {\tt View All}
\item {\tt Autoresize after loading}
\item {\tt Animate while loading}
\end{itemize}

\subsection{The Debug Menu}

\begin{figure}[tb]
  \centerline{\epsfig{file=debug-menu.ps,width=6cm}}
  \caption{\label{FIG:debug-menu}The Debug  Menu}
\end{figure}

The {\tt Debug} menu is shown in Figure~\ref{FIG:debug-menu} and contains the
single check box {\tt Diagnostic messages}.  When turned on, diagnostic
messages will be displayed.  Otherwise the systems runs silently.

\subsection{The Help Menu}

\begin{figure}[tb]
  \centerline{\epsfig{file=help-menu.ps,width=6cm}}
  \caption{\label{FIG:help-menu}The Help  Menu}
\end{figure}

The {\tt Help} menu is shown in Figure~\ref{FIG:help-menu}
and contains the following entries:

\begin{itemize}
\item {\tt About NewMeta}
\item {\tt Meta-Environment}
\item {\tt Mouse operations}
\item {\tt Online help}
\end{itemize}

\section{The Panes of the Main Window}

The two left-most panes of the main window give two, alternative,
views on the same information: the \asfsdf\ specification that has
been loaded into the Meta-Environment.  Using one of these views, the
same set of operations is available either via a pop menu or via the
buttons in the pane at the right-hand side of the main window.

\subsection{The Import Pane}

The \emph{import pane} gives a graphical view of the specification by
displaying the \emph{import} relation between modules in the form of a
graph. A module $M_1$ imports another module $M_2$ if $M_1$ contains
an import statement of the form {\tt imports $M_2$}.

Each module is represented by a circle and an arrow between two
circles represents an import relation between the two corresponding
modules.

The import pane has the following interaction facilities:

\begin{itemize}

\item Clicking \emph{on} a module yields a pop up menu
with the same entries as the button pane of the main window
(see Section \ref{ButtonPane})
\item Clicking \emph{outside} any module yields a pop up menu
with the entries {\tt New} and {\tt Open} for creating a new,
respectively, opening an existing module. These two operations
are also part of the file menu (see Section~\ref{FileMenu}).

\end{itemize}

\begin{figure}[tb]
  \centerline{\epsfig{file=module-menu.ps,width=6cm}}
  \caption{\label{FIG:module-menu}Pop up menu for module operations}
\end{figure}

\begin{figure}[tb]
  \centerline{\epsfig{file=new-open.ps,width=6cm}}
  \caption{\label{FIG:new-open}Pop up menu for adding a module}
\end{figure}


\subsection{The Module Pane}

The import pane is particularly usefull when you want to understand the
overall structure of a specification but it may become unwieldy for
very large specifications. For large specifications the module pane
may give you quicker access to the modules in the specification.

It presents a vertical, scrollable, list of the names of all the modules in
the specification.

\subsection{The Button Pane of the Main Window} \label{ButtonPane}

  \begin{itemize}
  \item {\tt Edit Sdf2}
  \item {\tt Edit Eqs}
  \item {\tt Term}
  \item {\tt Save}
  \item {\tt Revert}
  \item {\tt Delete}
  \item {\tt Info}
  \item {\tt Compile}
  \end{itemize}

\section{Editing Specifications}

\subsection{Editing the syntax part of a module}

\subsection{Editing the equations of a module}

\subsection{Editing terms}

\section{Executing Specifications}

\subsection{Evaluating terms}

\subsection{Compiling a specification}

\section{Guided Tour}

(*** Under construction ***)

\begin{figure}[tb]
  \centerline{\epsfig{file=meta-booleans.ps,width=6cm}}
  \caption{\label{FIG:meta-booleans}Main window after opening {\tt Pico-Booleans}}
\end{figure}

To help you to get acquainted with the ASF+SDF Meta-environment the system
comprises two example specifications, namely the one-module specification:
{\tt Bool-example}, and the specification of the syntax, typechecker and dynamic
semantics of the small programming language Pico.

This Guided Tour is meant to guide you through these specifications, and show
you the main features of the ASF+SDF Meta-environment. Only global information
is given about these features but references are made to parts of the
user-manual with detailed information.

\subsection{Before you start the Guided Tour}

The Meta-Environment is usually installed in a directory named {\tt
  meta-$version$}. For Release 1, this may, for instance, be {\tt meta-1.0.0}.
You will then find the files needed for this Guided Tour in the directory {\tt
  meta-1.0.0/demo/pico}. It is advisable to make your personal copy of this
directory.  In this Guided Tour we will use `{\tt pico}' to refer to your own
copy of the directory.

For each module in a specification two files exist: `{\tt $module$.syn}'
contains the syntax of $module$ and  `{\tt $module$.eqs}' contains the semantics
(equations) of $module$. The directory pico contains:

\begin{itemize}

\item two files for the module {\tt Bool-example}.

\item 24 files for the Pico-specification.

\item three examples of Pico-programs: `{\tt bin.pico}', `{\tt fac.pico}',
  `{\tt small.pico}'.

\end{itemize}

\subsection{Beginning the Guided Tour}

\begin{itemize}

\item Go to directory pico. 
\item Type the command {\tt meta}. The main window of the Meta-environment
  will appear.
  
\item Add the module {\tt Bool-example} by selecting the File menu, and
  choosing the Open button. In a dialog window, the systems asks you to give
  the name of the module to be opened.  The directory has already been filled
  in (but you could modify it), and enter `{\tt Bool-example}' as module name.
  
\item Verify that {\tt Bool-example} appears in the import pane as well as in
  the module pane of the main window.

\end{itemize}

\subsection{The Module Bool-example}

One of the simplest specifications possible, and therefore frequently used as
an example, is the datatype of the Boolean values. It defines the constants
{\tt true} and {\tt false} and the functions \emph{and} and \emph{or}
 (written in infix notation using
the left-associative operators `{\tt \&}' and `{\tt |}', respectively) and
\emph{not} (written
in prefix notation using the function symbol `{\tt not}'). Here is the
specification:

\begin{verbatim}
module Bool-example
  exports
    sorts BOOL 
    lexical syntax


      "%%" ~[\n]* [\n] -> LAYOUT 
      [ \t\n]          -> LAYOUT 
    context-free syntax

      true             -> BOOL
      false            -> BOOL 
      BOOL "|" BOOL    -> BOOL {left}
      BOOL "&" BOOL    -> BOOL {left}
      not "(" BOOL ")" -> BOOL
      "(" BOOL ")"     -> BOOL {bracket}

    variables
      Bool [0-9']* -> BOOL

    priorities
      "|" ! "&" 

    equations
    %% disjunction
    [B1] true | Bool = true 
    [B2] false | Bool = Bool

    %% conjunction
    [B3] true & Bool = Bool 
    [B4] false & Bool = false

    %% negation
    [B5] not(false) = true 
    [B6] not(true) = false

\end{verbatim}

\subsubsection{The module editor for {\tt Bool-example}}

\begin{itemize}

\item Select {\tt Bool-example} from the module pane.
  
\item Push the button {\tt Edit Sdf2}. An editor will appear containing the
  syntax part of the {\tt Bool-example} specification: the SDF section.

\item Push the button {\tt Edit Eqs}. An editor will appear containing the
  semantic part of the {\tt Bool-example} specification: a list of conditional
  equations. Note that the syntax of the equations is determined by the syntax
  defined in the SDF section.

\end{itemize}


\subsubsection{A Term Editor for {\tt Bool-example}}

\begin{itemize}
\item Open a term-editor over module {\tt Bool-example}
 by first selecting module  {\tt Bool-example} in the module pane,
and then pushing the {\tt term} button.
A dialog window pops up. Choose `.' (dot) for directory, choose any new filename. See, for instance, Figure ***.

\item Notice there is a little blob in the top left corner of the window.
  Type the term `{\tt true \& false}' in this editor and notice how the blob
  becomes a block around the term when double click in the text (see below).
  This block is called a focus.

\item Click in the focus, this will move the cursor. 
  
\item When you double click in the focus, the text in the focus is parsed.

\end{itemize}

All the text\emph{ outside} the focus is (by definition) always syntactically
correct. The text \emph{inside} the focus is fresh text which may contain syntax
errors.

\begin{itemize}

\item Reduce the term in the term-editor by clicking the reduce button. The
  result will appear in ***

\end{itemize}

\paragraph{Error-messages}

\begin{itemize}
  
\item Edit the term `{\tt true \& false}' such that the new term will be
  syntactically incorrect. For instance, type `{\tt true \& wrong}'. Force a
  parse of the term by clicking in the term. An error window pops up with
  message `{\tt Lexical syntax error near 'w'}'

\item Select the help button in the term-editor and choose cursor to error.

\end{itemize}

\paragraph{The expand menu}

Instead of \emph{typing} a term you can construct a term using the {\tt expand} menu.

\begin{itemize}
  
\item Type the string `{\tt <BOOL>}' in the term-editor. This is a
  \emph{meta-variable}. Click \emph{inside} this string.
You can then use the {\tt expand} menu to construct a Boolean term.

\end{itemize}

Note that you can only make syntactically correct terms when using the {\tt
  expand} menu.

\paragraph{Associativity, Priorities and Brackets}

\begin{itemize}
  
\item Erase the term in your term-editor and type a new term `{\tt true \&
    false \& true}'. Try to find out how this term has been parsed by clicking
  on different parts of the term and studying the resulting focus.

\end{itemize}

The {\tt left} attribute in the SDF definition indicates that the `{\tt \&}'
operator is left associative. 

\begin{itemize}
  
\item Erase the term in your term-window and type a new term `{\tt true |
    false \& true}'. Try to find out how this term has been parsed by clicking
  and studying the resulting focus.

\end{itemize}

The {\tt priorities} definitions in the SDF definition state that the `{\tt
  \&}' operator binds stronger than the `{\tt |}' operator.


\begin{itemize}
  
\item Erase the term in the term-editor and type a new term `{\tt true \&
    false}'.  Click on `false', so that the focus is around `false' only. Then
  add `{\tt | true}' after `{\tt false}', so that the resulting term is `{\tt
    true \& false | true}'.  Click on the `{\tt \&}' symbol.
\end{itemize}
  
  To resolve a priority conflict `{\tt (}' and `{\tt )}' which are defined as
  brackets in the SDF definition are put around the term `{\tt false | true}'.

\subsubsection{Modifying {\tt Bool-example}}

The ASF+SDF Meta-Environment is an incremental environment generator. After
each edit operation on a module, its implementation (i.e., scanner, parser and
term rewriting system) is updated immediately.

The editing of both the equations and the syntax part of a module is
syntax-directed like the editing of terms in a term editor.

\paragraph{Modifying the Equations}

The equation section of a module appears in the bottom part of the module and
begins with the keyword equations.

\begin{itemize}

\item  Click in the equation section to investigate the focus behavior.
  
\item Change the equations, for instance replace in equation {\tt [B1]} the
  last part `{\tt = true}' by `{\tt = false}'. Study the effect on the
  reduction of terms in the term-editor.

\end{itemize}

\paragraph{Modifying the Syntax}

Modifying the syntax causes the generated scanner and parser to be adapted.
After each edit operation in the SDF section that is followed by a parse of
the SDF section, the focus in both the equations section and the term editor
is extended to completely contain the text in these editors.


Modifying the context-free syntax:

\begin{itemize}
  
\item Change the syntax of the defined functions. E.g, replace `{\tt not}' by
  `{\tt negation}'.

\item Try to re-parse the equations. 
  
\item Investigate the expand menu in the term-editor. (type `{\tt <BOOL>}' and
  select {\tt expand}.)

\end{itemize}

Modifying the priorities: 

\begin{itemize}

\item Remove the priority declaration. 
  
\item Type the term `{\tt true \& false | true}' in the term-editor (or
  anything similar according to your current syntax). Try to parse this term.

\item Add the priority declarations again.

\end{itemize}

Modifying layout in the lexical section: 

\begin{itemize}

\item Remove the lexical syntax with the {\tt LAYOUT} definitions. 

\item Try parsing equations of {\tt Bool-example}.

\end{itemize}

\paragraph{Note:} Not defining {\tt LAYOUT} is one of the errors most commonly
made when writing a new specification; always make sure your syntax
definitions define at least spaces and newlines to be {\tt LAYOUT}.


\begin{itemize}
  
\item Close the term-editor and module-editor. By clicking the little button
  in the left corner of the menu bar. You may or may not save the changes to
  module Bool-example.

\end{itemize}

If you save the changes the files `{\tt Bool-example.syn}' and `{\tt
  Bool-example.eqs}' will be modified.


\begin{itemize}

 \item Delete the module Bool-example from the specification. Select the
   delete button.

\end{itemize}

\subsection{The Pico Specification}

More features of the ASF+SDF Meta-environment can be studied by looking at the
Pico specification.

\begin{itemize}
  
\item If necessary, start the ASF+SDF Meta-environment. (Go to directory {\tt
    pico}, and type `{\tt meta}').
  
\item Add the module {\tt Pico-syntax} by selecting the Specification menu,
  and choosing the add button. The system will ask you for a directory(path)
  and a module name. Answer with `.' for directory. Answer with Pico-syntax
  for module name.

\item Check the Edit-Module menu. Not only {\tt Pico-syntax} has been added, also all modules that
are directly or transitively imported by {\tt Pico-syntax}.

\end{itemize}

Possible Error: `sort ``BOOL'' double declared'. Both the modules Booleans and Boolexample declare the sort BOOL. Delete module Bool-example.

\subsubsection{The Module Editor for Pico-syntax}

\begin{itemize}

\item Open the module-editor for {\tt Pico-syntax}.
  
  A Pico program consist of the word `{\tt begin}', a declaration section, a
  series of zero or more statements, and the word `{\tt end}'. The declaration
  section consists of the word `{\tt declare}', a list of zero or more tuples
  `{\tt $identifier$ : $type$}' and a semi-colon `{\tt ;}'. Types are `{\tt
    string}' and `{\tt natural}'.  There are three kinds of statements:
  assignments, if-then-else statements and while-loops. And there are
  expressions.

\end{itemize}

\paragraph{Notes:}

\begin{itemize}
  
\item A module{\tt Layout} is imported, in which {\tt LAYOUT} has been
  specified.
  
\item The use of list constructs in the context-free section: `{\tt {-ID-TYPE
      ","}*}' and `{\tt {STATEMENT ","}*}'. In fact, the sort {\tt SERIES}
  could have been left out entirely and be replaced by `{\tt {STATEMENT
      ","}*}' all through the specification. {\tt SERIES} is only used for
  abbreviation in the syntax rules. Also, variables over list constructs are
  being declared.
  
\item When a literal in a context-free function consists only of lower case
  letters and digits, and it is not a SDF-keyword, it need not be quoted.

\item  The Pico-syntax module naturally contains no equations.

\end{itemize}

\subsubsection{A Term Editor for Pico-syntax}

\begin{itemize}
  
\item Open a term-editor for Pico-syntax, containing the program `{\tt
    small.pico}' This term-editor not only has a reduce button but also the
  buttons {\tt typecheck} and {\tt evaluate}. These latter buttons have been
  defined in the configuration file `ctasdf.conf').

\item Press the reduce button.

\end{itemize}

This has the following effects:

\begin{itemize}

\item  The term in the editor is parsed. 
  
\item All the equations that are valid for this editor are parsed and compiled
  into a rewrite system.  In this case that means the equations of the
  imported modules {\tt Booleans}, {\tt Integers}, {\tt Strings} and {\tt
    Types}. This takes some time.
  
\item The term in the editor is reduced. As no equation can be applied to
  reduce this term, the term itself is returned in the shell window from which
  the Meta-Environment has been started.
\end{itemize}

  
Reducing a term for the second time is notably faster: the equations have been
compiled already.

\begin{itemize}

\item Press the typecheck (evaluate) button.

\end{itemize}

This has the following effects:

\begin{itemize}

\item  The module {\tt Pico-typecheck} ({\tt Pico-eval}) is added to the specification. 

\item  The term `{\tt tc[Program-in-editor]}' (`{\tt
    eval[Program-in-editor]}') is constructed. 
  
\item All equations of {\tt Pico-typecheck} ({\tt Pico-eval}) and its imported
  modules are being compiled.
  
\item The term `{\tt tc[Program-in-editor]}' (`{\tt eval[Program-in-editor]}')
  is reduced using the equations of {\tt Pico-typecheck} ({\tt Pico-eval}).

\end{itemize}
  
Typechecking (evaluating) a term for the second time is notably faster, the
modules have been added already and the equations have been compiled.

\begin{itemize}
  
\item Make some modifications to `{\tt small.pico}' in the term-editor.
  Typecheck and evaluate the modified program.
  
\item Open term-editors with other pico programs (`{\tt fac.pico}', `{\tt
    bin.pico}') or create your own program. Typecheck and evaluate these
  programs.

\end{itemize}

\subsubsection{More Exercises to Study the Pico Specification}

\begin{itemize}

\item Study other modules in the specification. The modules {\tt
    Pico-typecheck} and{\tt  Pico-eval} are explained in ***
  
\item Add a repeat statement `{\tt repeat SERIES until EXP}' to {\tt
    Pico-syntax}, add typecheck equations to {\tt Pico-typecheck}, and
  eval-equations to {\tt Pico-eval}, for this new statement.

\item Add your own module to the specification. 

\item Make your own specification. Create a new directory for each
  specification.

\end{itemize}

\subsubsection{Module Pico-typecheck}

\begin{itemize}

\item Open the module editor for Pico-typecheck.

\end{itemize}

Functions `{\tt tcp}' are defined for typechecking Pico-programs. The
typechecking of the declarations yields a type-environment: a table of
identifiers and their types. This type-environment, and the `{\tt look-up}'
function is specified in the module {\tt Type-environments}. The typechecking
of statements uses a type-environment and yields a Boolean value.

In the equations is defined how a Pico-program is typechecked. Equation {\tt
  [Tc1a]} says that the typechecking of a program is `{\tt true}' if the
typechecking of the Series in the type-environments, `{\tt tc[Decls]}', is
`{\tt true}'.

Equation {\tt [Tc1b]} says that the typechecking of a program is `{\tt false}'
if the typechecking of the Series in the type-environments, `{\tt tc[Decls]}',
is \emph{not} `{\tt true}'.

Equations {\tt [Tc2]} and {\tt [Tc3]} specify how a type-environment is
constructed, when the declarations are typechecked.

Equations {\tt [Tc4]} and {\tt [Tc5]} specify the typechecking of a, possibly
empty, list of statements. Equations [Tc6], [Tc7], and [Tc8] specify how the
three kinds of Statements are typechecked using the information from the
type-environment.

The rest of the equations deal with the typechecking of the expressions.

\subsubsection{Module Pico-eval}

\begin{itemize}

\item Open the module editor for Pico-eval.

\end{itemize}

Functions `{\tt eval}' are defined for describing the dynamic semantics of
Pico. The result of evaluation is a value-environment: a table of identifiers
and values with the final values of the declared identifiers. (Note that Pico
does not have an output-statement.)

In the equations is defined how a program is evaluated. Equation {\tt [Ev1]}
says that the evaluation of a program is the evaluation of the Series in the
value-environments, `{\tt eval [Decls]}'.

Equations {\tt [Ev2a]}, {\tt [Ev2b]}, and {\tt [Ev3]} specify how a
value-environment is constructed, when the declarations are evaluated.
Identifiers of type `{\tt natural}' get value `{\tt 0}', Identifiers of type
`{\tt string}' get value `{\tt ""}' (empty-string)

Equations {\tt [Ev4]} and {\tt [Ev5]} specify the evaluation of a, possibly
empty, list of statements. Equations {\tt [Ev6]}, {\tt [Ev7a]}, {\tt [Ev7b]},
{\tt [Ev8a]}, and {\tt [Ev8b]} specify how the three kinds of statements are
evaluated using the information from the type-environment. Evaluating
statements means updating the value-environment.

The rest of the equations deal with the evaluation of expressions. Evaluating
expressions results in a value.

\section{The ASF+SDF specification formalism}

\section{Miscellaneous}

\subsection{Parsing a term outside the \ASmetaenv}

\subsection{Rewriting a term using a compiled specification}

\subsection{Unparsing a (parsed/normalized) term}

\end{document}
