<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE chapter [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
]>
<chapter version="5.0" xml:id="rscript" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns6="http://www.w3.org/1999/xhtml"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>EASY Programming with Rascal</title>

    <subtitle>Leveraging the Extract-Analyze-SYthesize Paradigm for
    Meta-Programming</subtitle>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint, Jurgen Vinju,
        Tijs van der Storm</surname></personname>
      </author>
    </authorgroup>

    <pubdate>to be filled in</pubdate>
  </info>

  <warning>
    <para>This document is in the process of being written.</para>
  </warning>

  <section>
    <title>Introduction</title>

    <para></para>

    <section xml:id="section.EASY-programming">
      <title>EASY Programming</title>

      <para>Many programming problems follow a fixed pattern. Starting with
      some <emphasis>object-of-interest</emphasis>, first relevant information
      is extracted from it and stored in an internal representation. This
      internal representation is then analyzed and used to synthesize results.
      If the synthesis indicates this, these steps can be repeated over and
      over again. These steps are shown in <xref
      linkend="figure.extract-analyze-synthesize-paradigm" /> (yes some people
      do like old radios!).<note>
          <para>Find better images to illustrate this, e.g. in go a bicyle and
          a motor, and synthesize a motorbike.</para>
        </note><figure xml:id="figure.extract-analyze-synthesize-paradigm">
          <title>EASY: the Extract-Analyze-Synthesize Paradigm</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="easy-workflow.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>This is an abstract view on solving programming problems, but is
      it uncommon? No, so let's illustrate it with a few examples.</para>

      <para><example>
          <title>Finding security breaches</title>

          <para>Alice is system administrator of a large online marketplace
          and she is looking for security breaches in her system. The
          object-of-interest are the system's log files. First relevant
          entries are extracted. This will include, for instance, messages
          from the SecureShell demon that reports failed login attempts. From
          each entry login name and originating IP address are extracted and
          put in a table (the internal representation in this example). These
          data are analysed by detecting duplicates and counting frequencies.
          Finally results are synthesized by listing the most frequently used
          login names and IP addresses.</para>
        </example><example>
          <title>A Forensic DSL compiler</title>

          <para>Bernd is a senior software engineer working at the Berlin
          headquarters of a forensic investigation lab of the German
          government. His daily work is to find common patterns in files
          stored on digital media that have been confiscated during criminal
          investigations. Text, audio and video files are stored in zillions
          of different data formats and each data format requires its own
          analysis technique. For each new investigation ad hoc combinations
          of tools are used. This makes the process very labour-intensive and
          error-prone. Bernd convinces his manager that designing a new
          domain-specific language (DSL) for forensic investigations may
          relieve the pressure on their lab. After designing the DSL---let's
          call it DERRICK---he makes an EASY implementation for it. Given a
          DERRICK program for a specific case under investigation, he first
          extracts relevant information from it and analyzes it: which media
          formats are relevant? Which patterns to look for? How should search
          results be combined? Given this new information, Java code is
          synthesized that uses the various existing tools and combines their
          results.</para>
        </example><example>
          <title>Renovation Financial Software</title>

          <para>Charlotte is software engineer at a large financial
          institution in Paris and she is looking for options to connect an
          old and dusty software system to a web interface. She will need to
          analyze the sources of that system to understand how it can be
          changed to meet the new requirements. The objects-of-interest are in
          this case the source files, documentation, test scripts and any
          other available information. They have to be parsed in some way in
          order to extract relevant information, say the calls between various
          parts of the system. The call information can be represented as a
          binary relation between caller and callee (the internal
          representation in this example). This relation with 1-step calls is
          analyzed and further extended with 2-step calls, 3-step calls and so
          on. In this way call chains of arbitrary length become available.
          With this new information, we can synthesize results by determining
          the entry points of the software system, i.e. the points where calls
          from the outside world enter the system. Having completed this first
          cycle, Charlotte may be interested in which procedures can be called
          from the entry points and so on and so forth. Results will be
          typically represented as pictures that diplay the relationsships
          that were found. In the case of source code analysis, a variation of
          our workflow scheme is quite common. It is then called the
          extract-analyze-view paradigm and is shown in <xref
          linkend="figure.extract-analyze-view-paradigm" />.</para>
        </example><figure xml:id="figure.extract-analyze-view-paradigm">
          <title>The extract-analyze-view paradigm</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="extract-analyze-view-paradigm.png"
                         scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure><example>
          <title>Finding Concurrency Errors</title>

          <para>Daniel is concurrency researcher at one of the largests
          hardware manufacturers worldwide. He is working from an office in
          the Bay Area. Concurrency is the big issue for his company: it is
          becoming harder and harder to make CPUs faster, therefore more and
          of them are bundled on a single chip. Programming these multi-core
          chips is difficult and many programs that worked fine on a single
          CPU contain hard to detect concurrency errors due to subtle
          differences in the order of execution that results from executing
          the code on more than one CPU. Here is where Daniel enters the
          picture. He is working on tools for finding concurrency errors.
          First he extracts facts from the code that are relevant for
          concurrency problems and have to do with calls, threads, shared
          variables and locks. Next, he analyzes these facts and synthesizes
          an abstract model that captures the essentials of the concurrency
          behaviour of the program. Finally he runs a third-party verification
          tool with this model as input to do the actual verification.</para>
        </example></para>
    </section>

    <section>
      <title>Rascal</title>

      <para>With these examples in mind, you have a pretty good picture how
      EASY applies in different use cases. All these cases involve a form of
      <emphasis>meta-programming</emphasis>: software programs are the
      objects-of-interest that are being analyzed and transformed. The Rascal
      language you are about to learn is designed for meta-programming
      following the EASY paradigm. It can be applied in domains ranging from
      compiler construction to constraint solving.</para>

      <para>Since representation of data is central to the approach, Rascal
      provides a rich set of built-in data types. To support extraction and
      analysis, parsing and advanced pattern matching are provided. High-level
      control structures make analysis and synthesis of complex datastructures
      simple.</para>
    </section>

    <section>
      <title>Aim and Scope of this Book</title>

      <para></para>
    </section>

    <section>
      <title>Rascal Concepts</title>

      <para>Before explaining the Rascal language in more detail, it is good
      to have a general understanding of the concepts on which the language is
      built.</para>

      <section>
        <title>Values</title>

        <para>Rascal is a value-oriented language. This means that values are
        immutable and are always freshly constructed from existing parts and
        that sharing and aliasing problems are completely avoided. The
        language does provide assignment to variables either as the result of
        an explicit assignment statement or as the result of a successful
        match.</para>
      </section>

      <section>
        <title>Data structures</title>

        <para>Rascal provides a rich set of datatypes. From booleans, infinite
        precision integers and reals to strings and source code locations.
        From lists, (optionally labelled) tuples and sets to (optionally
        labelled) maps and relations. From untyped tree structures to fully
        typed abstract datatypes. Syntax trees that are the result of parsing
        source files are represented as ADTs. There is a wealth of built-in
        operators and library functions available on the standard datatypes. A
        fragment of the abstract syntax for statements in a programming
        language would look as follows:<programlisting>data STAT = asgStat(Id name, EXP exp) 
          | ifStat(EXP exp, list[STAT] thenpart, list[STAT] elsepart) 
          | whileStat(EXP exp, list[STAT] body) 
          ;</programlisting></para>
      </section>

      <section>
        <title>Pattern Matching</title>

        <para>Pattern matching is <emphasis>the</emphasis> mechanism for case
        distinction in Rascal. We provide string matching based on regular
        expressions, list (associative) and set (associative, commutative,
        identity) matching, matching of abstract datatypes, and matching of
        concrete syntax patterns. All these forms of matching can be used in a
        single pattern. Patterns may contain variables that are bound when the
        match is successful. Anonymous (don't care) positions are indicated by
        an underscore (<literal>_</literal>). The following abstract pattern
        matches the while statement defined above: <programlisting>whileStat(EXP Exp, list[STAT] Stats)</programlisting></para>

        <para>Variables in a pattern are either explicitly declared in the
        pattern itself---as done in this example---or they may be declared in
        the context in which the pattern occurs. Patterns can also be used in
        an explicit match operator <literal>:=</literal> and can then be part
        of larger boolean expressions. Since a pattern match may have more
        than one solution, local backtracking over the alternatives of a match
        is provided.</para>
      </section>

      <section>
        <title>Generators</title>

        <para>Generators enumerate the values in a given (finite) domain, be
        it the elements in a list, the substrings of a string, or all the
        nodes in a tree. Each value that is enumerated is first matched
        against a pattern before it can possibly contribute to the result of
        the generator. Examples are:</para>

        <para><programlisting>int x &lt;- { 1, 3, 5, 7, 11 }
int x &lt;- [ 1 .. 10 ]
asgStat(Id name, _) &lt;- P</programlisting></para>

        <para>The first two generate the integer elements of a set of
        integers, respectively, a range of integers. The third generator
        traverses the complete program <literal>P</literal> (that is assumed
        to have a <literal>PROGRAM</literal> as value) and only yields
        statements that match the assignment pattern. Note the use of an
        anonymous variable at the <literal>EXP</literal> position in the
        pattern.</para>
      </section>

      <section>
        <title>Comprehensions and Control Structures</title>

        <para>Rascal generalizes comprehensions in various ways.
        Comprehensions exist for lists, sets and maps. A comprehension
        consists of an expression that determines the successive elements to
        be included in the result and a list of generators and boolean
        expressions. The generators enumerate values and the boolean
        expressions filter them. A standard example is</para>

        <para><programlisting>{ x * x | int x &lt;- [1 .. 10], x % 3 == 0 }</programlisting></para>

        <para>which returns the set <literal>{9, 36, 81}</literal>, i.e., the
        squares of the integers in the range <literal>[ 1 .. 10 ]</literal>
        that are divisible by 3. A more intriguing example is</para>

        <para><programlisting>{name | asgStat(Id name, _) &lt;- P}</programlisting></para>

        <para>which returns a list of all identifiers that occur on the
        lefthand side of assignment statements in program
        <literal>P</literal>. Combinations of generators and boolean
        expressions also drive the control structures. For instance,
        <programlisting>for(asgStat(Id name, _) &lt;- P, size(Id) &gt; 10){
    println(Id);
}</programlisting></para>

        <para>prints all identifiers in assignment statements that consist of
        more than 10 characters.</para>
      </section>

      <section>
        <title>Switching and Visiting</title>

        <para>The switch statement as known from C and Java is generalized:
        the subject value to switch on may be an arbitrary value and the cases
        are arbitrary patterns. When a match fails, all its side-effects are
        undone and when it succeeds the statements associated with that case
        are executed. Visiting the elements of a datastructure is one of the
        most common operations in our domain and we give it first class
        support by way of visit expressions that resemble the switch
        statement. A visit expression consists of an expression that may yield
        an arbitrarily complex subject value and a number of cases. All the
        elements of the subject are visited and when one of the cases matches
        the statements associated with that case are executed. These cases
        may:</para>

        <itemizedlist>
          <listitem>
            <para>cause some side effect;</para>
          </listitem>

          <listitem>
            <para>execute an <literal>insert</literal> statement that replaces
            the current element;</para>
          </listitem>

          <listitem>
            <para>execute a <literal>fail</literal> statement that causes the
            match for the current case to fail (and undoing all side-effects
            due to the successfull match itself and the execution of the
            statements sofar).</para>
          </listitem>
        </itemizedlist>

        <para>The value of a visit expression is the original subject value
        with all replacements made as dictated by matching cases. The
        traversal order in a visit expressions can be explicitly defined by
        the programmer.</para>
      </section>

      <section>
        <title>Functions and Rewrite Rules</title>

        <para>Functions are explicitly declared and are fully typed. Here is
        an example of a function that counts the number of assignment
        statements in a program:</para>

        <para><programlisting>int countAssignments(PROGRAM P){
    int n = 0;
    visit (P){
    case asgStat(Id name, _):
         n += 1;
    }
    return n;
}</programlisting></para>

        <para>Rewrite rules are the only implicit control mechanism in the
        language and are used to maintain invariants during
        computations.</para>
      </section>

      <section>
        <title>Typechecking</title>

        <para>Rascal has a statically checked type system that prevents type
        errors and uninitialized variables at runtime. There are no runtime
        type casts as in Java and there are therefore less opportunities for
        run-time errors. The language provides higher-order, parametric,
        polymorphism. A type aliasing mechanism allows documenting specific
        uses of a type. Builtin operators are heavily overloaded: <literal>1 +
        [2,3]</literal> , <literal>[1, 2] + 3</literal>, and <literal>[1, 2] +
        [3]</literal> all give the same result <literal>[1,2,3]</literal>, but
        <literal>1 + ["1"]</literal> leads to a type error.</para>
      </section>

      <section>
        <title>Execution</title>

        <para>Following the what-you-see-is-what-you-get paradigm, control
        flow is completely explicit. Boolean expression determine choices that
        drive the control structures. Rewrite rules form the only exception to
        the explicit control flow principle. Only local backtracking is
        provided (no suprise) in the context of boolean expressions and
        pattern matching; side effects are undone in case of
        backtracking.</para>
      </section>
    </section>
  </section>

  <section xml:id="section.motivating-example">
    <title>A Motivating Example</title>

    <para>Suppose a mystery box ends up on your desk. When you open it, it
    contains a huge software system with several questions attached to
    it:</para>

    <itemizedlist>
      <listitem>
        <para>How many procedure calls occur in this system?</para>
      </listitem>

      <listitem>
        <para>How many procedures contains it?</para>
      </listitem>

      <listitem>
        <para>What are the entry points for this system, i.e., procedures that
        call others but are not called themselves?</para>
      </listitem>

      <listitem>
        <para>What are the leaves of this application, i.e., procedures that
        are called but do not make any calls themselves?</para>
      </listitem>

      <listitem>
        <para>Which procedures call each other indirectly?</para>
      </listitem>

      <listitem>
        <para>Which procedures are called directly or indirectly from each
        entry point?</para>
      </listitem>

      <listitem>
        <para>Which procedures are called from all entry points?</para>
      </listitem>
    </itemizedlist>

    <para>There are now two possibilities. Either you have this superb
    programming environment or tool suite that can immediately answer all
    these questions for you or you can use Rascal.</para>

    <section>
      <title>Preparations</title>

      <para>To illustrate this process consider the workflow in <xref
      linkend="figure.calls-workflow" />. First we have to extract the calls
      from the source code. Rascal is very at this, but to simplify this
      examples we assume that this call graph has already been extracted. Also
      keep in mind that a real call graph of a real application will contain
      thousands and thousands of calls. Drawing it in the way we do later on
      in <xref linkend="figure.calls" /> makes no sense since we get a
      uniformly black picture due to all the call dependencies. After the
      extraction phase, we try to understand the extracted facts by writing
      queries to explore their properties. For instance, we may want to know
      <emphasis>how many calls</emphasis> there are, or <emphasis>how many
      procedures</emphasis>. We may also want to enrich these facts, for
      instance, by computing who calls who in more than one step. Finally, we
      produce a simple textual report giving answers to the questions we are
      interested in.<figure xml:id="figure.calls-workflow">
          <title>Workflow for analyzing mystery box</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="calls-workflow.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>

          <para>Now consider the call graph shown in <xref
          linkend="figure.calls" />. This section is intended to give you a
          first impression what can be done with Rascal. Please return to this
          example when you have digested the detailed description of Rascal in
          <xref linkend="section.rascal-language" /> and <xref
          linkend="section.builtin" />.</para>
        </figure><figure xml:id="figure.calls">
          <title>Graphical representation of the <literal>calls</literal>
          relation</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="calls.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Rascal supports basic data types like integers and strings which
      are sufficient to formulate and answer the questions at hand. However,
      we can gain readability by introducing separately named types for the
      items we are describing. First, we introduce therefore a new type
      <literal>proc</literal> (an alias for strings) to denote
      procedures:</para>

      <screen>rascal&gt; alias proc = str
done</screen>

      <para>Suppose that the following facts have been extracted from the
      source code and are represented by the relation
      <literal>Calls</literal>:</para>

      <screen>rascal&gt; rel[proc , proc] Calls = 
   { &lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, &lt;"d", "c"&gt;, &lt;"d","e"&gt;, 
     &lt;"f", "e"&gt;, &lt;"f", "g"&gt;, &lt;"g", "e"&gt;
   }</screen>

      <para>This concludes the preparatory steps and now we move on to answer
      the questions.</para>
    </section>

    <section>
      <title>Questions</title>

      <section>
        <title>How many procedure calls occur in this system?</title>

        <para>To determine the numbers of calls, we simply determine the
        number of tuples in the <literal>Calls</literal> relation, as follows.
        First, we need the Relation library (described in <xref
        linkend="section.lib-Relation" />) so we import it:<screen>rascal&gt; import Relation;
done.</screen>next we describe a new variable and calculate the number of
        tuples:</para>

        <para><screen>rascal&gt; int nCalls = size(Calls)</screen>The library
        function <literal>size</literal> determines the number of elements in
        a set or relation and is explained in <xref
        linkend="section.lib-Relation" />. In this example,
        <literal>nCalls</literal> will get the value
        <literal>8</literal>.</para>
      </section>

      <section>
        <title>How many procedures contains it?</title>

        <para>We get the number of procedures by determining which names occur
        in the tuples in the relation <literal>Calls</literal> and then
        determining the number of names:</para>

        <screen>rascal&gt; set[proc] procs = carrier(Calls);
<literal>{"a", "b", "c", "d", "e", "f", "g"}</literal>
&gt; int nprocs = size(procs);
<literal>7</literal></screen>

        <para>The built-in function <literal>carrier</literal> determines all
        the values that occur in the tuples of a relation. In this case,
        <literal>procs</literal> will get the value <literal>{"a", "b", "c",
        "d", "e", "f", "g"}</literal> and <literal>nprocs</literal> will thus
        get value <literal>7</literal>. A more concise way of expressing this
        would be to combine both steps:</para>

        <screen>rascal&gt; int nprocs = size(carrier(Calls));
7</screen>
      </section>

      <section>
        <title>What are the entry points for this system?</title>

        <para>The next step in the analysis is to determine which
        <emphasis>entry points</emphasis> this application has, i.e.,
        procedures which call others but are not called themselves. Entry
        points are useful since they define the external interface of a system
        and may also be used as guidance to split a system in parts. The
        <literal>top</literal> of a relation contains those left-hand sides of
        tuples in a relation that do not occur in any right-hand side. When a
        relation is viewed as a graph, its top corresponds to the root nodes
        of that graph. Similarly, the <literal>bottom</literal> of a relation
        corresponds to the leaf nodes of the graph. See <xref
        linkend="section.lib-Graph" /> for more details. Using this knowledge,
        the entry points can be computed by determining the top of the
        <literal>Calls</literal> relation:</para>

        <screen>rascal&gt; import Graph;
done.
rascal&gt; set[proc] entryPoints = top(Calls);
<literal>{"a", "f"}</literal></screen>

        <para>In this case, <literal>entryPoints</literal> is equal to
        <literal>{"a", "f"}</literal>. In other words, procedures
        <literal>"a"</literal> and <literal>"f"</literal> are the entry points
        of this application.</para>
      </section>

      <section>
        <title>What are the leaves of this application?</title>

        <para>In a similar spirit, we can determine the
        <emphasis>leaves</emphasis> of this application, i.e., procedures that
        are being called but do not make any calls themselves:</para>

        <screen>rascal&gt; set[proc] bottomCalls = bottom(Calls);
<literal>{"c", "e"}</literal></screen>

        <para>In this case, <literal>bottomCalls</literal> is equal to
        <literal>{"c", "e"}</literal>.</para>
      </section>

      <section>
        <title>Which procedures call each other indirectly?</title>

        <para>We can also determine the <emphasis>indirect calls</emphasis>
        between procedures, by taking the transitive closure of the
        <literal>Calls</literal> relation:</para>

        <screen>rascal&gt; rel[proc, proc] closureCalls = Calls+;
{&lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, &lt;"d", "c"&gt;, &lt;"d","e"&gt;, 
 &lt;"f", "e"&gt;, &lt;"f", "g"&gt;, &lt;"g", "e"&gt;, &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, 
 &lt;"b", "e"&gt;, &lt;"a", "e"&gt;
}</screen>
      </section>

      <section>
        <title>Which procedures are called directly or indirectly from each
        entry point?</title>

        <para>We know now the entry points for this application (<literal>"a"
        </literal>and <literal>"f"</literal>) and the indirect call relations.
        Combining this information, we can determine which procedures are
        called from each entry point. This is done by indexing
        <literal>closureCalls</literal> with appropriate procedure name. The
        index operator yields all right-hand sides of tuples that have a given
        value as left-hand side. This gives the following:</para>

        <screen>rascal&gt; set[proc] calledFromA = closureCalls["a"];
<literal>{"b", "c", "d", "e"}</literal></screen>

        <para>and</para>

        <screen>rascal&gt; set[proc] calledFromF = closureCalls["f"];
<literal>{"e", "g"}</literal></screen>
      </section>

      <section>
        <title>Which procedures are called from all entry points?</title>

        <para>Finally, we can determine which procedures are called from both
        entry points by taking the intersection of the two sets
        <literal>calledFromA</literal> and
        <literal>calledFromF:</literal></para>

        <para><screen>rascal&gt; set[proc] commonProcs = calledFromA &amp; calledFromF;
<literal>{"e"}</literal></screen></para>

        <para>In other words, the procedures called from both entry points are
        mostly disjoint except for the common procedure
        <literal>"e"</literal>.</para>
      </section>

      <section>
        <title>Wrap-up</title>

        <para>These findings can be verified by inspecting a graph view of the
        calls relation as shown in <xref linkend="figure.calls" />. Such a
        visual inspection does <emphasis>not</emphasis> scale very well to
        large graphs and this makes the above form of analysis particularly
        suited for studying large systems.<note>
            <para>Add a screen dump here of the Eclipse browser.</para>
          </note></para>
      </section>
    </section>
  </section>

  <section xml:id="section.rascal-language">
    <title>The Rascal Language</title>

    <para>An Rascal program consists of one or more modules. Each module may
    import other modules and declare data types, variables and/or functions.
    The visibility of each declared entity may be <literal>private</literal>
    (only visible inside the module) or <literal>public</literal> (visible
    outside the module).</para>

    <section xml:id="section.types-and-values">
      <title>Types and Values</title>

      <section xml:id="section.elementary-types">
        <title>Elementary Types and Values</title>

        <formalpara>
          <title>Boolean</title>

          <para>The Booleans are represented by the type
          <literal>bool</literal> and have two values: <literal>true</literal>
          and <literal>false</literal>.</para>
        </formalpara>

        <formalpara>
          <title>Integer</title>

          <para>The integer values are represented by the type
          <literal>int</literal> and are written as usual, e.g.,
          <literal>0</literal>, <literal>1</literal>, or
          <literal>123</literal>. They can be arbitrarily large.</para>
        </formalpara>

        <formalpara>
          <title>Real</title>

          <para>The real values are represented by the type
          <literal>real</literal> and are written as usual, e.g.,
          <literal>1.5</literal>, or <literal>3.14e-123.</literal> They can
          have arbitrary size and precision.</para>
        </formalpara>

        <formalpara>
          <title>String</title>

          <para>The string values are represented by the type
          <literal>str</literal> and consist of character sequences surrounded
          by double quotes. e.g., <literal>"a"</literal> or <literal>"a\ long\
          string"</literal>.</para>
        </formalpara>

        <para>String literals permit <emphasis>interpolation</emphasis> of
        variable values: when
        <literal>&lt;<replaceable>X</replaceable>&gt;</literal> occurs inside
        a string literal, the value of the variable X is converted to string
        and replaces &lt;<replaceable>X</replaceable>&gt;. As a consequence,
        the character <literal>&lt; </literal>has to be escaped
        as<literal>\&lt;</literal> in string literals.</para>

        <formalpara>
          <title>Location</title>

          <para>Location values are represented by the type
          <literal>loc</literal> and serve as text coordinates in a specific
          source file. It is very handy to associate a source code location
          which extracted facts. Locations should <emphasis>always</emphasis>
          be generated automatically but for the curious here is an example
          how they look like:
          <literal>loc(file:/home/paulk/pico.trm?offset=0&amp;length=1&amp;begin=2,3&amp;end=4,5)</literal></para>
        </formalpara>

        <para>Source locations have the following syntax:</para>

        <para><programlisting>loc(<replaceable>Url</replaceable>?offset=<replaceable>O</replaceable>&amp;length=<replaceable>L</replaceable>&amp;begin=<replaceable>BL</replaceable>,<replaceable>BC</replaceable>&amp;end=<replaceable>EL</replaceable>,<replaceable>EC)</replaceable></programlisting>where:</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>Url</replaceable> is an arbitrary URL.</para>
          </listitem>

          <listitem>
            <para><replaceable>O</replaceable> and
            <replaceable>L</replaceable> are integer expressions giving the
            offset of this location to the begin of file, respectively , its
            length.</para>
          </listitem>

          <listitem>
            <para><replaceable>BL</replaceable> and
            <replaceable>BC</replaceable> are integers expressions giving the
            begin line and begin column.</para>
          </listitem>

          <listitem>
            <para><replaceable>EL</replaceable> and
            <replaceable>EC</replaceable> are integers expressions giving the
            end line and end column.</para>
          </listitem>
        </itemizedlist>

        <para>This element of a location value can be accessed and modified
        using the standard mechanism of field selection and field assignment.
        The corresponding field names are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>url</literal></para>
          </listitem>

          <listitem>
            <para><literal>offset</literal></para>
          </listitem>

          <listitem>
            <para><literal>length</literal></para>
          </listitem>

          <listitem>
            <para><literal>beginLine</literal>,
            <literal>beginColumn</literal></para>
          </listitem>

          <listitem>
            <para><literal>endLine</literal>,
            <literal>endColumn</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>List, Set, Map, Tuple, and Relation</title>

      <formalpara>
        <title>List</title>

        <para>Lists are represented by the type
        <literal>list[</literal><replaceable>T</replaceable><literal>]</literal>,
        where <replaceable>T</replaceable> is an arbitrary type. Examples are
        <literal>list[int]</literal>, <literal>list[tuple[int,int]]</literal>
        and <literal>list[list[str]]</literal>. Lists are denoted by a list of
        elements, separated by comma's and enclosed in bracket as in
        <literal>[</literal><replaceable>E</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>2</subscript><literal>,
        ...,</literal>
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript><literal>]</literal>,
        where the
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript>
        (1 &lt;= <replaceable>i</replaceable>&lt;=
        <replaceable>n</replaceable>) are expressions that yield the desired
        element type. For example,</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>[1, 2, 3]</literal> is of type
          <literal>list[int]</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}</literal>
          is of type <literal>set[tuple[int,int]]</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>[&lt;"a",10&gt;, &lt;"b",20&gt;,
          &lt;"c",30&gt;]</literal> is of type
          <literal>list[tuple[str,int]]</literal>, and</para>
        </listitem>

        <listitem>
          <para><literal>[["a", "b"], ["c", "d", "e"]]</literal> is of type
          <literal>list[list[str]]</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>When variables of type list occur inside a list, their elements
      are automatically spliced into the surrounding list. This can be
      prevented by surrounding them with extra [ and ] brackets.</para>

      <formalpara>
        <title>Range</title>

        <para>For lists of integers, a special shorthand exists to describe
        ranges of integers:<itemizedlist>
            <listitem>
              <para><literal>[<replaceable>F</replaceable> ..
              <replaceable>L</replaceable>]</literal> ranges from first
              element <replaceable>F</replaceable> to (and including) last
              element <replaceable>L</replaceable> with increments of
              1.</para>
            </listitem>

            <listitem>
              <para><literal>[<replaceable>F</replaceable>,<replaceable>S</replaceable>,..<replaceable>
              E</replaceable>]</literal>, ranges from first element
              <replaceable>F</replaceable>, second element S to (and
              including) last element <replaceable>L</replaceable> with
              increments of <literal>S</literal> -
              <replaceable>F</replaceable>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>

      <formalpara>
        <title>Set</title>

        <para>Sets are represented by the type
        <literal>set[</literal><replaceable>T</replaceable><literal>]</literal>,
        where <replaceable>T</replaceable> is an arbitrary type. Examples are
        <literal>set[int]</literal>, <literal>set[tuple[int,int]]</literal>
        and <literal>set[set[str]]</literal>. Sets are denoted by a list of
        elements, separated by comma's and enclosed in braces as in
        <literal>{</literal><replaceable>E</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>2</subscript><literal>,
        ...,</literal>
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript><literal>}</literal>,
        where the
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript>
        (1 &lt;= <replaceable>i </replaceable>&lt;=
        <replaceable>n</replaceable>) are expressions that yield the desired
        element type. For example,</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>{1, 2, 3}</literal> is of type
          <literal>set[int]</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}</literal>
          is of type <literal>set[tuple[int,int]]</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>{&lt;"a",10&gt;, &lt;"b",20&gt;,
          &lt;"c",30&gt;}</literal> is of type
          <literal>set[tuple[str,int]]</literal>, and</para>
        </listitem>

        <listitem>
          <para><literal>{{"a", "b"}, {"c", "d", "e"}}</literal> is of type
          <literal>set[set[str]]</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>In a similar fashion as with lists, sets variables are
      automatically spliced into a surrounding set. This can be prevented by
      surrounding them with extra { and } brackets.</para>

      <formalpara>
        <title>Map</title>

        <para>Maps are represented by the type
        <literal>map[</literal><replaceable>T</replaceable><literal><subscript>1</subscript>,
        <replaceable>T</replaceable><subscript>2</subscript>]</literal>, where
        <replaceable>
        </replaceable><replaceable>T</replaceable><literal><subscript>1</subscript>
        and <replaceable>T</replaceable><subscript>2</subscript></literal> are
        arbitrary types. Examples are <literal>map[int,int]</literal>, and
        <literal>map[str,int]</literal>. Sets are denoted by a list of pairs,
        separated by comma's and enclosed in parentheses as in
        <literal>(</literal><replaceable>K</replaceable><subscript>1</subscript><literal>:</literal>
        <replaceable>V</replaceable><subscript>1</subscript><literal>,
        ...,</literal>
        <replaceable>K</replaceable><subscript>n</subscript><literal>:</literal>
        <replaceable>V</replaceable><subscript>n</subscript><literal>})</literal>,
        where the
        <replaceable>K</replaceable><subscript><replaceable>n</replaceable></subscript>
        (1 &lt;= <replaceable>i</replaceable>&lt;=
        <replaceable>n</replaceable>) are expressions that yield the keys of
        the map and
        <replaceable>V</replaceable><subscript><replaceable>n</replaceable></subscript>
        (1 &lt;= <replaceable>i</replaceable>&lt;=
        <replaceable>n</replaceable>) are expressions that yield the values
        for each key. Map resemble functions rather than relations in the
        sense that only a single value can be associated with each key. For
        example,</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>("pear" : 1, "apple" : 3, "banana" : 0)</literal> is
          of type <literal>map[str,int]</literal>.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Tuple</title>

        <para>Tuples are represented by the type
        <literal>tuple[</literal><replaceable>T</replaceable><subscript>1</subscript><literal>
        <replaceable>L</replaceable><subscript>1</subscript>,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal>
        <replaceable>L<subscript>2</subscript></replaceable>, ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        <replaceable>L</replaceable><subscript>n</subscript> ], where
        <replaceable>T</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal>,
        ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        are arbitrary types and
        <replaceable>L<subscript>1</subscript></replaceable><literal>,</literal>
        <replaceable>L</replaceable><subscript>2</subscript><literal>,
        ...,</literal> <replaceable>L</replaceable><subscript>n</subscript>
        are optional labels. An example of a tuple type is <literal>tuple[str
        name, int freq&gt;]</literal>. Examples are:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>&lt;1, 2&gt;</literal> is of type <literal>tuple[int,
          int&gt;]</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>&lt;1, 2, 3&gt;</literal> is of type
          <literal>tuple[int, int, int&gt;]</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>&lt;"a", 3&gt;</literal> is of type
          <literal>tuple[str name, int freq].</literal></para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Relation</title>

        <para>Relations are nothing more than sets of tuples, but since they
        are used so often we provide a shorthand notation for them. Relations
        are represented by the type
        <literal>rel[</literal><replaceable>T</replaceable><subscript>1</subscript><literal><replaceable>L</replaceable><subscript>1</subscript>,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal><replaceable>L<subscript>2</subscript></replaceable>,
        ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        <replaceable>L</replaceable><subscript>n</subscript> ], where
        <replaceable>T</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal>,
        ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        are arbitrary types and
        <replaceable>L<subscript>1</subscript></replaceable><literal>,</literal>
        <replaceable>L</replaceable><subscript>2</subscript><literal>,
        ...,</literal> <replaceable>L</replaceable><subscript>n</subscript>
        are optional labels. It is a shorthand for
        <literal>set[tuple[</literal><replaceable>T</replaceable><subscript>1</subscript><literal><replaceable>L</replaceable><subscript>1</subscript>
        ,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal><replaceable>L<subscript>2</subscript></replaceable>,
        ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        <replaceable>L</replaceable><subscript>n</subscript>
        ]<literal>]</literal>. Examples are <literal>rel[int,str]</literal>
        and <literal>rel[int,set[str]]</literal>. An n-ary relations with m
        tuples is denoted by
        <literal>{&lt;</literal><replaceable>E</replaceable><subscript>11</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>12</subscript><literal>, ...,
        <replaceable>E</replaceable><subscript>1n</subscript>&gt;,
        </literal><literal>&lt;</literal><replaceable>E</replaceable><subscript>21</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>22</subscript><literal>, ...,
        <replaceable>E</replaceable><subscript>2n</subscript>&gt;</literal><literal>,
        ...,
        </literal><literal>&lt;</literal><replaceable>E</replaceable><subscript>m1</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>m2</subscript><literal>, ...,
        <replaceable>E</replaceable><subscript>mn</subscript>&gt;</literal><literal>}</literal>,
        where the
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable><replaceable>j</replaceable></subscript>
        are expressions that yield the desired element type. For example,
        <literal>{&lt;1, "a"&gt;, &lt;2, "b"&gt;, &lt;3,"c"&gt;}</literal> is
        of type <literal>rel[int, str]</literal>. Examples are:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}</literal>
          is of type <literal>rel[int,int]</literal> (yes indeed, you saw this
          same example before and then we gave
          <literal>set[tuple[int,int]]</literal> as its type; remember that
          these types are interchangeable.),</para>
        </listitem>

        <listitem>
          <para><literal>{&lt;"a",10&gt;, &lt;"b",20&gt;,
          &lt;"c",30&gt;}</literal> is of type
          <literal>rel[str,int]</literal>, and</para>
        </listitem>

        <listitem>
          <para><literal>{{"a", 1, "b"}, {"c", 2, "d"}}</literal> is of type
          <literal>rel[str,int,str]</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>User-defined Types</title>

      <formalpara>
        <title>Alias type</title>

        <para>Everything can be expressed using the elementary types and
        values that are provided by Rascal. However, for the purpose of
        documentation and readability it is sometimes better to use a
        descriptive name as type indication, rather than an elementary type.
        The alias declaration</para>
      </formalpara>

      <programlisting>alias <replaceable>T</replaceable><subscript>1</subscript> = <replaceable>T</replaceable><subscript>2</subscript>;</programlisting>

      <para>states that the new type name
      <replaceable>T</replaceable><subscript>1</subscript> can be used
      everywhere instead of the already defined type name
      <replaceable>T</replaceable><subscript>2</subscript>. For
      instance,</para>

      <programlisting>alias ModuleId = str;
alias Frequency = int;</programlisting>

      <para>introduces two new type names <literal>ModuleId</literal> and
      <literal>Frequency</literal>, both an alias for the type
      <literal>str</literal>. The use of type aliases is a good way to
      docuement your intentions. Another example is an alias definition for a
      graph containing integer nodes:</para>

      <para><programlisting>alias Graph = rel[int,int];</programlisting></para>

      <para>An alias definition may be parameterized. So we can generalize
      graphs as follows:</para>

      <para><programlisting>alias Graph[&amp;Node] = rel[&amp;Node, &amp;Node];</programlisting>Of
      course, the type variables that are used in the type in the left part
      should occur as parameters in the right part of the definition and vice
      versa.</para>

      <formalpara>
        <title>Abstract Data Type</title>

        <para>In ordinary programming languages record types or classes exist
        to introduce a new type name for a collection of related, named,
        values and to provide access to the elements of such a collection
        through their name. In Rascal, data declarations provide this
        facility. The type declaration</para>
      </formalpara>

      <programlisting>data N = Pat1 | Pat2 | ...</programlisting>

      <para>introduces a new codatatype N and Pat1, Pat2, are prefix patterns
      describing the variants of the datatype. For instance, <programlisting>data Bool = btrue | bfalse | band(Bool L, Bool R)  | bor(Bool L, Bool R);  </programlisting>defines
      the datatype <literal>Bool</literal> that contains various constants and
      constructor functions.</para>
    </section>

    <section>
      <title>Typing</title>

      <para>Rascal is based on static typing, this means that as many errors
      and inconsistencies as possible are spotted before the program is
      executed. TODO</para>
    </section>

    <section>
      <title>Expressions</title>

      <para><table xml:id="table.non-boolean-operators">
          <title>Non-Boolean Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript><literal>
                [</literal> <replaceable>name</replaceable>
                <literal>=</literal>
                <replaceable>exp</replaceable><subscript>2</subscript>
                <literal>]</literal></entry>

                <entry><replaceable>exp</replaceable><subscript>1</subscript>should
                evaluate to a datatype with a field
                <replaceable>name</replaceable>; assign value
                <replaceable>exp</replaceable><subscript>2</subscript> to that
                field</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable> <literal>.</literal>
                <replaceable>name</replaceable></entry>

                <entry><replaceable>exp </replaceable>should evaluate to a
                datatype with field <replaceable>name</replaceable>; return
                the value of that field</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable> <literal>&lt;</literal>
                <replaceable>field</replaceable>, ...<literal>
                &gt;</literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript><literal>
                [</literal>
                <replaceable>exp</replaceable><subscript>2</subscript>
                <literal>]</literal></entry>

                <entry>The value of
                <replaceable>exp</replaceable><subscript>2</subscript> is used
                as index in
                <replaceable>exp</replaceable><subscript>1</subscript>'s
                value. On string, list, tuple return the element with given
                index; for map return the value associated with
                <replaceable><replaceable>exp</replaceable><subscript>2</subscript>
                </replaceable>'s value</entry>
              </row>

              <row>
                <entry><literal>-</literal>
                <replaceable>exp</replaceable></entry>

                <entry>negation on integer or real</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable>
                <literal>+</literal></entry>

                <entry>transitive closure on relation</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable>
                <literal>*</literal></entry>

                <entry>reflexive transitive closure on relation</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable> <literal>@</literal>
                name</entry>

                <entry>value of attribute <replaceable>name</replaceable> of
                <replaceable>exp</replaceable>'s value</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>[@</literal> name <literal>=</literal><replaceable>
                exp</replaceable><subscript>2</subscript><literal>]</literal></entry>

                <entry>assign value of<replaceable>
                exp</replaceable><subscript>2</subscript> to attribute
                <replaceable>name</replaceable> of
                <replaceable><replaceable>exp</replaceable><subscript>1</subscript></replaceable>'s
                value</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>o</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Composition on relations</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>/</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Division on integer and real</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>%</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Modulo on integer</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>*</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Multiplication on integer and real; product on list,
                set, relation</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>&amp;</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Intersection on list, set, map and relation</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>+</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Addition on integer and real; concatenation on string,
                list and tuple; union on set, map, and relation</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>-</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Subtraction on integer and real; difference on list,
                set, map, and relation</entry>
              </row>

              <row>
                <entry><replaceable><replaceable>exp</replaceable><subscript>1</subscript></replaceable>
                <literal>join</literal>
                <replaceable><replaceable>exp</replaceable><subscript>2</subscript></replaceable></entry>

                <entry>Join on relation</entry>
              </row>
            </tbody>
          </tgroup>
        </table><table xml:id="table.boolean-operators">
          <title>Boolean Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>!</literal>
                <replaceable>exp</replaceable></entry>

                <entry>Negation</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable>
                <literal>?</literal></entry>

                <entry>Isdefined: true is exp has a well-defined value</entry>
              </row>

              <row>
                <entry><replaceable><replaceable>exp</replaceable><subscript>1</subscript></replaceable>
                <literal>in</literal>
                <replaceable><replaceable>exp</replaceable><subscript>2</subscript></replaceable></entry>

                <entry>Element of</entry>
              </row>

              <row>
                <entry><replaceable><replaceable>exp</replaceable><subscript>1</subscript></replaceable>
                <literal>notin</literal>
                <replaceable><replaceable>exp</replaceable><subscript>2</subscript></replaceable></entry>

                <entry>Not element of</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>&lt;=</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Less than or equal on bool, int, real or string;
                sublist on list; subset on set, map or relation</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>&lt;</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Less than on bool, int, real or string; strict sublist
                on list; strict subset on set, map or relation</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>&gt;=</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Greater than or equal on bool, int, real or string;
                superlist on list; superset on set, map or relation</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>&gt;</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Greater than on bool, int, real or string; strict
                superlist on list; strict superset on set, map or
                relation</entry>
              </row>

              <row>
                <entry><replaceable>pat</replaceable> <literal>:=</literal>
                <replaceable>exp</replaceable></entry>

                <entry>Value of <replaceable>exp</replaceable> matches with
                pattern <replaceable>pat</replaceable></entry>
              </row>

              <row>
                <entry><replaceable>pat</replaceable> <literal>!:=</literal>
                <replaceable>exp</replaceable></entry>

                <entry>Value of <replaceable>exp</replaceable> does not match
                with pattern <replaceable>pat</replaceable></entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>==</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Equality</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>!=</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Inequality</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>?</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Ifdefined Otherwise: the value of
                <replaceable>exp</replaceable><subscript>1</subscript> is it
                is well-defined, otherwise the value of
                <replaceable>exp</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>?</literal>
                <replaceable>exp</replaceable><subscript>2</subscript>
                <literal>:</literal>
                <replaceable>exp</replaceable><subscript>3</subscript></entry>

                <entry>Conditional expression</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>==&gt;</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Implication</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>&lt;==&gt;</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Equivalence</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                &amp;&amp;
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Boolean and</entry>
              </row>

              <row>
                <entry><replaceable>exp</replaceable><subscript>1</subscript>
                <literal>||</literal>
                <replaceable>exp</replaceable><subscript>2</subscript></entry>

                <entry>Boolean or</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>Patterns</title>

      <para>Patterns come in three flavours:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Regulars patterns</emphasis> to do string matching
          with regular expressions, see <xref
          linkend="section.regular-patterns" />.</para>
        </listitem>

        <listitem>
          <para><emphasis>Abstract patterns</emphasis> to matching on
          arbitrary values, see <xref
          linkend="section.abstract-patterns" />.</para>
        </listitem>

        <listitem>
          <para><emphasis>Concrete patterns</emphasis> to match syntax trees
          that are the result of parsing, see <xref
          linkend="section.concrete-patterns" />.</para>
        </listitem>
      </itemizedlist>

      <section xml:id="section.regular-patterns">
        <title>Regular Patterns</title>

        <para>Regular expression patterns are ordinary regular expressions
        that are used to match a string value and to decompose it in parts and
        also to compose new strings. Regular expression patterns bind
        variables of type <literal>str</literal> when the match succeeds,
        otherwise they do not bind anything. Their syntax and semantics
        parallels abstract and concrete syntax patterns as much as possible.
        This means that they can occur in cases of <literal>visit</literal>
        and <literal>switch</literal> statements, on the left-hand side of the
        match operator (<literal>:= or !:=</literal>) and as declarator in
        generators.</para>

        <para>We use a regular expression language that slightly extends the
        Java Regex language with the following exceptions:</para>

        <itemizedlist>
          <listitem>
            <para>Regular expression are delimited by / and / optionally
            followed by a modifier (see below).</para>
          </listitem>

          <listitem>
            <para>We allow named groups, syntax
            <literal>&lt;<replaceable>Name</replaceable>:<replaceable>Regex</replaceable>&gt;</literal>,
            which introduce a variable of type <literal>str</literal> named
            <replaceable>Name</replaceable>. Currently, these names have to be
            unique in the pattern.</para>
          </listitem>

          <listitem>
            <para>Java regular expressions might have optional groups, which
            may introduce null bindings. Since unitialized variables are not
            allowed in Rascal, we limit the kinds of expressions one can write
            here by not allowing nesting of named groups.</para>
          </listitem>

          <listitem>
            <para>Named groups have to be outermost, such that they can only
            bind in one way.</para>
          </listitem>

          <listitem>
            <para>Unlike Perl, Java uses the notation
            <literal>(?<replaceable>Option</replaceable>)</literal> inside the
            regular expression to set options like multi-line matching
            <literal>(?m)</literal>, case-insensitive matching
            <literal>(?i)</literal> etc. We let these options follow the
            regular expression.</para>
          </listitem>

          <listitem>
            <para>We allow name use in a regular expression:
            <literal>&lt;<replaceable>Name</replaceable>&gt;</literal> which
            inserts the string value of <replaceable>Name</replaceable> in the
            pattern.</para>
          </listitem>
        </itemizedlist>

        <para>Here are some examples of regular patterns.<programlisting>/\brascal\b/i</programlisting>does
        a case-insensitive match (<literal>i</literal>) of the word rascal
        between word boundaries (<literal>\b</literal>). And<programlisting>/^.*?&lt;word:\w+&gt;&lt;rest:.*$&gt;/m</programlisting>does
        a multi-line match (<literal>m</literal>), matches the first
        consecutive word characters (<literal>\w</literal>) and assigns them
        to the variable <literal>word</literal>. The remainder of the string
        is assigned to the variable <literal>rest</literal>.</para>
      </section>

      <section xml:id="section.abstract-patterns">
        <title>Abstract Patterns</title>

        <para>An abstract pattern is recursively defined and may contain the
        following elements:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Literal</emphasis> of one of the basic types
            <literal>bool</literal>, <literal>int</literal>,
            <literal>real</literal>, <literal>str</literal>, or
            <literal>loc</literal>.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>variable declaration
            pattern</emphasis><programlisting><replaceable>Type</replaceable> <replaceable>Var</replaceable></programlisting></para>
          </listitem>

          <listitem>
            <para>A <emphasis>variable pattern</emphasis><programlisting><replaceable>Var</replaceable></programlisting></para>
          </listitem>

          <listitem>
            <para>A <emphasis>list pattern</emphasis><programlisting>[ <replaceable>Pat</replaceable><subscript>1</subscript>, <replaceable>Pat</replaceable><subscript>2</subscript>, ..., <replaceable>Pat</replaceable><subscript>n</subscript> ]</programlisting></para>
          </listitem>

          <listitem>
            <para>A <emphasis>set pattern</emphasis><programlisting>{ <replaceable>Pat</replaceable><subscript>1</subscript>, <replaceable>Pat</replaceable><subscript>2</subscript>, ..., <replaceable>Pat</replaceable><subscript>n</subscript> }</programlisting></para>
          </listitem>

          <listitem>
            <para>A <emphasis>tuple pattern</emphasis><programlisting>&lt; <replaceable>Pat</replaceable><subscript>1</subscript>, <replaceable>Pat</replaceable><subscript>2</subscript>, ..., <replaceable>Pat</replaceable><subscript>n</subscript> &gt;</programlisting></para>
          </listitem>

          <listitem>
            <para>A <emphasis>node pattern</emphasis><programlisting><replaceable>name</replaceable> ( <replaceable>Pat</replaceable><subscript>1</subscript>, <replaceable>Pat</replaceable><subscript>2</subscript>, ..., <replaceable>Pat</replaceable><subscript>n</subscript> )</programlisting></para>
          </listitem>
        </itemizedlist>

        <caution>
          <para>Map patterns are currently not supported.</para>
        </caution>
      </section>

      <section xml:id="section.concrete-patterns">
        <title>Concrete patterns</title>

        <caution>
          <para>Concrete patterns are not yet implemented.</para>
        </caution>

        <para>A <emphasis>concrete pattern</emphasis> is a (possibly quoted)
        concrete syntax fragment that may contain variables. We want to cover
        the whole spectrum from maximally quoted patterns that can
        unambiguously describe <emphasis role="bold">any</emphasis> syntax
        fragment to minimally quoted patterns as we are used to in ASF+SDF. A
        concrete pattern may have the following forms:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>variable declaration</emphasis>
            <emphasis>pattern</emphasis><programlisting><replaceable>&lt;Type</replaceable> <replaceable>Var&gt;</replaceable></programlisting></para>
          </listitem>

          <listitem>
            <para>A <emphasis>variable pattern</emphasis><programlisting><replaceable>&lt;Var&gt;</replaceable></programlisting></para>
          </listitem>

          <listitem>
            <para><emphasis>Quoted pattern</emphasis><programlisting>[| <replaceable>Token</replaceable><subscript>1</subscript><replaceable> Token</replaceable><subscript>2</subscript> ... <replaceable>Token</replaceable><subscript>n</subscript> |]</programlisting></para>

            <para>Inside a quoted pattern arbitrary lexical tokens may occur,
            but the characters <literal>&lt;</literal>,
            <literal>&gt;</literal> and <literal>|</literal> have to be
            escaped as <literal>\&lt;</literal>, <literal>\&gt;</literal>,
            <literal>\|</literal>. Quoted patterns may contain variable
            declaration patterbs and variable patterns.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>typed quoted pattern</emphasis> <programlisting><replaceable>Symbol</replaceable> [| <replaceable>Token</replaceable><subscript>1</subscript><replaceable> Token</replaceable><subscript>2</subscript> ... <replaceable>Token</replaceable><subscript>n</subscript> |]</programlisting>is
            a quoted pattern that is preceeded by an SDF symbol to define its
            desired syntactic type.</para>
          </listitem>

          <listitem>
            <para>An <emphasis>unquoted pattern</emphasis><programlisting><replaceable>Token</replaceable><subscript>1</subscript><replaceable> Token</replaceable><subscript>2</subscript> ... <replaceable>Token</replaceable><subscript>n</subscript></programlisting></para>

            <para>is a quoted pattern without the surrounding quotes.</para>
          </listitem>

          <listitem>
            <para>Inside syntax patterns, layout is ignored.</para>
          </listitem>
        </itemizedlist>

        <para>Examples:</para>

        <itemizedlist>
          <listitem>
            <para>Quoted syntax pattern with two pattern variable
            declarations:<programlisting>[| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Quoted syntax pattern with two pattern variable
            uses:<programlisting>[| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Identical to the previous example, but with a declaration of
            the desired syntactic type:<programlisting>STATEMENT [| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with two pattern variable
            declarations:<programlisting>while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with two pattern variable
            uses:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>
          </listitem>
        </itemizedlist>

        <para>Obviously, with less quoting and type information, the
        probability of ambiguities increases. Our assumption is that a type
        checker can resolve most of them.</para>
      </section>
    </section>

    <section>
      <title>Comprehensions</title>

      <para>We will use the familiar notation for <emphasis>list
      comprehension</emphasis><programlisting>[<replaceable>E</replaceable> | <replaceable>G</replaceable><subscript>1</subscript>, ..., <replaceable>G</replaceable><subscript><replaceable>n</replaceable></subscript>]</programlisting></para>

      <para>to denote the construction of a list consisting of the successive
      values of the <emphasis>contributing expression</emphasis>
      <replaceable>E</replaceable>. The values and the resulting list are
      determined by <replaceable>E</replaceable> and the
      <emphasis>generators</emphasis>
      <replaceable>G</replaceable><subscript>1</subscript> ,...,
      <replaceable>G</replaceable><subscript><replaceable>n</replaceable></subscript>.
      <replaceable>E</replaceable> is computed for all possible combinations
      of values produced by the generators. Each generator may introduce new
      variables that can be used in subsequent generators as well as in the
      expressions <replaceable>E</replaceable>. A generator can use the
      variables introduced by preceding generators. Generators may enumerate
      all the values in a set or relation, or they may perform an arbitrary
      test.</para>

      <para>In addition to list comprehensions, Rascal also supports
      <emphasis>set comprehension</emphasis><programlisting>{<replaceable>E</replaceable> | <replaceable>G</replaceable><subscript>1</subscript>, ..., <replaceable>G</replaceable><subscript><replaceable>n</replaceable></subscript>}</programlisting></para>

      <para>that also serve as relation comprehension, provided that
      <replaceable>E</replaceable> is of a tuple type.</para>

      <para>Finally, <replaceable>map comprehension</replaceable>s are written
      as:</para>

      <programlisting>(<replaceable>E</replaceable><subscript>1</subscript> : <replaceable>E</replaceable><subscript>2</subscript> | <replaceable>G</replaceable><subscript>1</subscript>, ..., <replaceable>G</replaceable><subscript><replaceable>n</replaceable></subscript>)</programlisting>

      <para>Since the entries in a map require both a key and a value for each
      entry, two expressions are needed in this case.</para>

      <section>
        <title>Enumerator</title>

        <para>An enumerator generates all the values in a given list, set,
        map, tuple, relation or abstract datatype. They have the following
        form:<programlisting><replaceable>P</replaceable> &lt;- <replaceable>E</replaceable></programlisting></para>

        <para>where <replaceable>P</replaceable> is a pattern and
        <replaceable>E</replaceable> is an expression. An enumerator is
        evaluated as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Expression <replaceable>E</replaceable> is evaluated and may
            have an arbitrary value <replaceable>V</replaceable>.</para>
          </listitem>

          <listitem>
            <para>The elements of <replaceable>V</replaceable> are enumerated
            one by one.</para>
          </listitem>

          <listitem>
            <para>Each element value is matched against the pattern
            <replaceable>P</replaceable>. There are two cases:</para>

            <itemizedlist>
              <listitem>
                <para>The match succeeds, any variables in
                <replaceable>P</replaceable> are bound, and the next generator
                in the comprehension is evaluated. The variables that are
                introduced by an enumartor are only available to generators
                that appear later (i.e., to the right) in the comprehension.
                When this enumerator is the last generator in the
                comprehension its contributing expression is evaluated.</para>
              </listitem>

              <listitem>
                <para>The match fails, no variables are bound. If V has more
                elements, a next element is tried. Otherwise, a previous
                generator (i.e., to the left) is tried. If this enumerator is
                the first generator in the comprehension, the evaluation of
                the comprehension is complete.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>This are examples of enumerators:</para>

        <itemizedlist>
          <listitem>
            <para><literal>int N &lt;- {1, 2, 3, 4, 5}</literal>,</para>
          </listitem>

          <listitem>
            <para><literal>str K &lt;- KEYWORDS</literal>, where
            <literal>KEYWORDS</literal> should evaluate to a value of
            <literal>set[str]</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>&lt;str K, int N&gt; &lt;- {&lt;"a",10&gt;,
            &lt;"b",20&gt;, &lt;"c",30&gt;}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>&lt;str K, int N&gt; &lt;- FREQUENCIES</literal>,
            where <literal>FREQUENCIES</literal> should evaluate to a value of
            type <literal>rel[str,int]</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>&lt;str K, 10&gt; &lt;- FREQUENCIES</literal>, will
            only generate pairs with <literal>10</literal> as second
            element.</para>
          </listitem>
        </itemizedlist>

        <para><note>
            <para>Type information will be used to check the plausibity of an
            enumerator and guard you against mistakes. An impossible
            enumerator like <literal>int N &lt;- {"apples",
            "oranges"}</literal> will be flagged as an error since the pattern
            can never match.</para>
          </note><note>
            <para>An enumerator may be preceeded by a <emphasis>strategy
            indication</emphasis>:<itemizedlist>
                <listitem>
                  <para><literal>top-down</literal></para>
                </listitem>

                <listitem>
                  <para><literal>bottom-up</literal> (this is the
                  default)</para>
                </listitem>
              </itemizedlist></para>

            <para>These take only effect for enumerators that produce the
            elements of an abstract data type and determine the order in which
            the elements are enumerated.</para>
          </note></para>
      </section>

      <section>
        <title>Test</title>

        <para>A test is a boolean-valued expression. If the evaluation yields
        <literal>true</literal> this indicates that the current combination of
        generated values up to this test is still as desired and execution
        continues with subsequent generators. If the evaluation yields
        <literal>false</literal> this indicates that the current combination
        of values is undesired, and that another combination should be tried
        by going back to a previous generator.</para>

        <para>Examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>N &gt;= 3</literal> tests whether
            <literal>N</literal> has a value greater than or equal
            <literal>3</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>S == "coffee"</literal> tests whether
            <literal>S</literal> is equal to the string
            <literal>"coffee"</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>In both examples, the variable (<literal>N</literal>,
        respectively, <literal>S</literal>) should have been introduced by a
        generator that occurs earlier in the comprehension.</para>
      </section>

      <section>
        <title>Examples of Comprehensions</title>

        <itemizedlist>
          <listitem>
            <para><literal>{X | int X : {1, 2, 3, 4, 5}, X &gt;= 3}</literal>
            yields the set <literal>{3,4,5}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{&lt;X, Y&gt; | int X : {1, 2, 3}, int Y : {2, 3,
            4}, X &gt;= Y}</literal> yields the relation <literal>{&lt;2,
            2&gt;, &lt;3, 2&gt;, &lt;3, 3&gt;}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{&lt;Y, X&gt; | &lt;int X, int Y&gt; :
            {&lt;1,10&gt;, &lt;2,20&gt;}}</literal> yields the inverse of the
            given relation: <literal>{&lt;10,1&gt;,
            &lt;20,2&gt;}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{X, X * X | X : {1, 2, 3, 4, 5}, X &gt;=
            3}</literal> yields the set
            <literal>{3,4,5,9,16,25}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Switch and Visit</title>

      <para></para>
    </section>

    <section>
      <title>Other control flow</title>

      <para></para>

      <section>
        <title>While</title>

        <para></para>
      </section>

      <section>
        <title>Do</title>

        <para></para>
      </section>

      <section>
        <title>For</title>

        <para></para>
      </section>

      <section>
        <title>One</title>

        <para></para>
      </section>

      <section>
        <title>All</title>

        <para></para>
      </section>

      <section>
        <title>Solve</title>

        <para>It is also possible to define mutually dependent sets of
        equations:<programlisting>equations
       initial
          <literal><replaceable>T</replaceable></literal><subscript>1</subscript> <replaceable>V</replaceable><subscript>1</subscript> init <replaceable>I</replaceable><subscript>1</subscript>
          ...
          <literal><replaceable>T</replaceable></literal><subscript><replaceable>n</replaceable></subscript> <replaceable>V</replaceable><subscript><replaceable>n</replaceable></subscript> init <replaceable>I</replaceable><subscript><replaceable>n</replaceable></subscript>
       satisfy
          <replaceable>V</replaceable><subscript>1</subscript> = <replaceable>E</replaceable><subscript>1</subscript>
          ...
          <replaceable>V</replaceable><subscript><replaceable>n</replaceable></subscript> = <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript>
end equations</programlisting></para>

        <para>In the <literal>initial</literal> section, the variables
        <replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript>
        are declared and initialized. In the <literal>satisfy</literal>
        section, the actual set of equations is given. The expressions
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>
        may refer to any of the variables
        <replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript>
        (and to any variables declared earlier). This set of equations is
        solved by evaluating the expressions
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>,
        assigning their value to the corresponding variables
        <replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript>,
        and repeating this as long as the value of one of the variables was
        changed. This is typically used for solving a set of dataflow
        equations. Example:</para>

        <itemizedlist>
          <listitem>
            <para>Although transitive closure is provided as a built-in
            operator, we can use equations to define the transitive closure of
            a relation. Recall that \[R+ = R \cup (R \circ R) \cup (R \circ R
            \circ R) \cup ... .\] This can be expressed as follows.<warning>
                <para>Fix expression.</para>
              </warning></para>

            <para><programlisting>rel[int,int] R =  {&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;}

equations
  initial
     rel[int,int] T init R
  satisfy
     T = T union (T o R)
end equations</programlisting></para>

            <para>The resulting value of <literal>T</literal> is as
            expected:<programlisting>{&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, &lt;1, 3&gt;, &lt;2, 4&gt;, &lt;1, 4&gt;}</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Assertions</title>

      <para>An assert statement may occur everywhere where a declaration is
      allowed. It has the form<programlisting>assert <replaceable>L</replaceable>: <replaceable>E</replaceable></programlisting>where
      <replaceable>L</replaceable> is a string that serves as a label for this
      assertion, and <replaceable>E</replaceable> is a boolean-value
      expression. During execution, a list of true and false assertions is
      maintained. When the script is executed as a <emphasis>test
      suite</emphasis> a summary of this information is shown to the user.
      When the script is executed in the standard fashion, the assert
      statement has no affect. Example:</para>

      <itemizedlist>
        <listitem>
          <para><programlisting>assert "Equality on Sets 1": {1, 2, 3, 1} == {3, 2, 1, 1}</programlisting></para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.declarations">
      <title>Declarations</title>

      <section>
        <title>Variable Declarations</title>

        <para>A variable declaration has the form<programlisting><replaceable>T</replaceable> <replaceable>V</replaceable> = <replaceable>E</replaceable></programlisting>
        where <replaceable>T</replaceable> is a type,
        <replaceable>V</replaceable> is a variable name, and
        <replaceable>E</replaceable> is an expression that should have type
        <replaceable>T</replaceable>. The effect is that the value of
        expression <replaceable>E</replaceable> is assigned to
        <replaceable>V</replaceable> and can be used later on as
        <replaceable>V</replaceable>'s value. Double declarations are not
        allowed. As a convenience, also declarations without an initialization
        expression are permitted and have the form <programlisting><replaceable>T</replaceable> <replaceable>V</replaceable> </programlisting>and
        only introduce the variable <replaceable>V</replaceable>.
        Examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>int max = 100</literal> declares the integer
            variable <literal>max</literal> with value
            <literal>100</literal>.</para>
          </listitem>

          <listitem>
            <para>The definition<programlisting>rel[str,int] day = {&lt;"mon", 1&gt;, &lt;"tue", 2&gt;, &lt;"wed",3&gt;, 
                    &lt;"thu", 4&gt;, &lt;"fri", 5&gt;, &lt;"sat",6&gt;, &lt;"sun",7&gt;}</programlisting>declares
            the variable <literal>day</literal>, a relation that maps strings
            to integers.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Local Variable Declarations</title>

        <para>Local variables can be introduced as follows:<programlisting><replaceable>E</replaceable> where <literal><replaceable>T</replaceable></literal><subscript>1</subscript> <replaceable>V</replaceable><subscript>1</subscript> = <replaceable>E</replaceable><subscript>1</subscript>, ..., <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript> <replaceable>V</replaceable><replaceable><subscript>n</subscript></replaceable> = <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript> end where</programlisting>First
        the local variables
        <replaceable>V</replaceable><replaceable><subscript>i</subscript></replaceable>
        are bound to their respective values
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>,
        and then the value of expression <replaceable>E </replaceable>is
        yielded.</para>
      </section>

      <section>
        <title>Function Declarations</title>

        <para>A function declaration has the form<programlisting><replaceable>T</replaceable> <replaceable>F</replaceable>(<literal><replaceable>T</replaceable></literal><subscript>1</subscript> <replaceable>V</replaceable><subscript>1</subscript>, ..., <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript> <replaceable>V</replaceable><replaceable><subscript>n</subscript></replaceable>) = <replaceable>E</replaceable></programlisting>Here
        <replaceable>T</replaceable> is the result type of the function and
        this should be equal to the type of the associated expression
        <replaceable>E</replaceable>. Each
        <replaceable>T</replaceable><subscript><replaceable>i</replaceable></subscript>
        <replaceable>V</replaceable><replaceable><subscript>i</subscript></replaceable>
        represents a typed formal parameter of the function. The formal
        parameters may occur in <replaceable>E</replaceable> and get their
        value when <replaceable>F</replaceable> is invoked from another
        expression. Example:</para>

        <itemizedlist>
          <listitem>
            <para>The function declaration<programlisting>rel[int, int] invert(rel[int,int] R) = 
   {&lt;Y, X&gt; | &lt;int X, int Y&gt; : R }</programlisting>yields the
            inverse of the argument relation R. For instance,
            <literal>invert({&lt;1,10&gt;, &lt;2,20&gt;})</literal> yields
            <literal>{&lt;10,1&gt;, &lt;20,2&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>

        <formalpara>
          <title>Parameterized types in function declarations</title>

          <para>The types that occur in function declarations may also contain
          <emphasis>type variables</emphasis> that are written as
          <literal>&amp;</literal> followed by an identifier. In this way
          functions can be defined for arbitrary types. Examples:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>The declaration<programlisting>rel[&amp;T2, &amp;T1] invert2(rel[&amp;T1,&amp;T2] R) = 
   {&lt;Y, X&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R }</programlisting>yields
            an inversion function that is applicable to any binary relation.
            For instance,</para>

            <itemizedlist>
              <listitem>
                <para><literal>invert2({&lt;1,10&gt;, &lt;2,20&gt;})</literal>
                yields <literal>{&lt;10,1&gt;, &lt;20,2&gt;}</literal>,</para>
              </listitem>

              <listitem>
                <para><literal>invert2({&lt;"mon", 1&gt;, &lt;"tue",
                2&gt;})</literal> yields <literal>{&lt;1, "mon"&gt;, &lt;2,
                "tue"&gt;}</literal>.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>The function<programlisting>&lt;&amp;T2, &amp;T1&gt; swap(&amp;T1 A, &amp;T2 B) = &lt;B, A&gt;</programlisting>can
            be used to swap the elements of pairs of arbitrary types. For
            instance,</para>

            <itemizedlist>
              <listitem>
                <para><literal>swap(&lt;1, 2&gt;)</literal> yields
                <literal>&lt;2,1&gt;</literal> and</para>
              </listitem>

              <listitem>
                <para><literal>swap(&lt;"wed", 3&gt;)</literal> yields
                <literal>&lt;3, "wed"&gt;</literal>.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Attributes</title>

      <para>Attributes are adornments of data and programs and come in two
      flavours:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>node annotations</emphasis> that allow associating
          one or more named values with nodes in a tree.</para>
        </listitem>

        <listitem>
          <para><emphasis>declaration tags</emphasis> that allow associating
          one or more named values to a declaration in a Rascal
          program.</para>
        </listitem>
      </itemizedlist>

      <para>The former are intended to attach application data to values, like
      adding position information or control flow information to source code
      or adding visualization information to a relation. The latter are
      intended to add metadata to a Rascal program and allow to influence the
      execution of the Rascal program, for instance, by adding memoization
      hints or database mappings for relations.</para>

      <section>
        <title>Node annotations</title>

        <para>An annotation may be associated with any node value. An
        annotation has a name and the type of its value is explicitly
        declared. Any value of any named type can be annotated and the type of
        these annotations can be declared precisely.</para>

        <para>For instance, we can add to certain syntactic constructs of
        programs (e.g., <literal>EXPRESSION</literal>) an annotation with name
        <literal>posinfo</literal> that contains location
        information:<programlisting>anno loc EXPRESSION @ posinfo;</programlisting>or
        location information could be added for all syntax
        trees:<programlisting>anno loc node @ posinfo;</programlisting></para>

        <para>We can add to the graph datatype introduced earlier, the
        annotation with name <literal>LayoutStrategy</literal> that defines
        which graph layout algorithm to apply to a particular graph,
        e.g.,<programlisting>data LayoutStrategy = "dot" | "tree" | "force" | 
                      "hierarchy" | "fisheye";

anno LayoutStrategy Graph @ strategy;</programlisting></para>

        <para>The folllowing constructs are provided for handling
        annotations:</para>

        <itemizedlist>
          <listitem>
            <para><literal><replaceable>Val</replaceable> @
            <replaceable>Anno</replaceable></literal>: get the value of
            annotation <replaceable>Anno</replaceable> of value
            <replaceable>Val</replaceable> (may be undefined!).</para>
          </listitem>

          <listitem>
            <para><literal><replaceable>Val1</replaceable>[@<replaceable>Anno</replaceable>
            = <replaceable>Val2]</replaceable></literal>: set the value of
            annotation <replaceable>Anno</replaceable> of the value
            <replaceable>Val</replaceable><replaceable>1</replaceable> to
            <replaceable>Val2</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal><replaceable>Var</replaceable> @
            <replaceable>Anno</replaceable> =
            <replaceable>Val</replaceable></literal>: set the value of
            annotation <replaceable>Anno</replaceable> of the value of
            variable <replaceable>Var</replaceable> to
            <replaceable>Val</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Declaration tags</title>

        <para><warning>
            <para>Tags are not yet implemented.</para>
          </warning><warning>
            <para>The syntax of tags has to be aligned with the syntax of
            annotations. This is done in the examples below but not yet in the
            synyax.</para>
          </warning>All declarations in a Rascal program may contain (in fixed
        positions depending on the declaration type) one or more declaration
        tags (<literal>tag</literal>). A tag is defined by declaring its name,
        the declaration type to which it can be attached, and the name and
        type of the annotation. The declaration type <literal>all</literal>,
        makes the declaration tag applicable for all possible declaration
        types. All declaration tags have the generic format
        <literal>@<replaceable>Name</replaceable>{ ... }</literal>, with
        arbitrary text between the brackets that is further constrained by the
        declared type. Here is an example of a license tag:<programlisting>tag str license on module;</programlisting>This
        will allow to write things like:<programlisting>module Booleans
@license{This module is distributed under the GPL}
...</programlisting>Other examples of declaration tags are:<programlisting>tag str todo on all             %% a todo note for all declaration types
tag void deprecated on function %% marks a deprecated function
tag int memo on function        %% bounded memoization of 
                                %% function calls
tag str doc on all              %% documentation string
tag str primitive on function   %% a primitive, built-in, function</programlisting>Here
        is an example of a documentation string as used in the Rascal standard
        library:<programlisting>public &amp;T max(set[&amp;T] R)
  @doc{Maximum of a set: max}
{
  &amp;T result = arb(R);
  for(&amp;T E : R){
    result = max(result, E);
  }
  return result;
}</programlisting></para>
      </section>
    </section>
  </section>

  <section xml:id="section.larger-examples">
    <title>Larger Examples (TODO)</title>

    <para>Now we will have a closer look at some larger applications of
    Rascal. We start by analyzing the global structure of a software system.
    You may now want to reread the example of call graph analysis given
    earlier in <xref linkend="section.motivating-example" /> as a reminder.
    The component structure of an application is analyzed in <xref
    linkend="section.analyzing-components" /> and Java systems are analyzed in
    <xref linkend="section.analyzing-java" />. Next we move on to the
    detection of initialized variables in <xref
    linkend="section.unitialized-variables" /> and we explain how source code
    locations can be included in a such an analysis (<xref
    linkend="section.using-locations" />). As an example of computing code
    metrics, we describe the calculation of McCabe's cyclomatic complexity in
    <biblioref linkend="section.McCabe" />. Several examples of dataflow
    analysis follow in <xref linkend="section.dataflow" />. A description of
    program slicing concludes the chapter (<xref
    linkend="section.program-slicing" />).</para>

    <section xml:id="section.analyzing-components">
      <title>Analyzing the Component Structure of an Application</title>

      <para>A frequently occurring problem is that we know the call relation
      of a system but that we want to understand it at the component level
      rather than at the procedure level. If it is known to which component
      each procedure belongs, it is possible to <emphasis>lift</emphasis> the
      call relation to the component level as proposed in <biblioref
      linkend="Krikhaar99" />. First, introduce new types to denote procedure
      calls as well as components of a system:<programlisting>type proc = str
type comp = str</programlisting>Given a calls relation
      <literal>Calls2</literal>, the next step is to define the components of
      the system and to define a <literal>PartOf</literal> relation between
      procedures and components.<programlisting>rel[proc,proc] Calls = {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, 
                         &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, &lt;"b", "d"&gt;
                       }

set[comp] Components = {"Appl", "DB", "Lib"}

rel[proc, comp] PartOf = {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, 
                          &lt;"b", "DB"&gt;, &lt;"c", "Lib"&gt;, &lt;"d", "Lib"&gt;
                         }</programlisting>Actual lifting, amounts to
      translating each call between procedures by a call between components.
      This is achieved by the following function
      <literal>lift</literal>:<programlisting>rel[comp,comp] lift(rel[proc,proc] aCalls, rel[proc,comp] aPartOf)=
   { &lt;C1, C2&gt; | &lt;proc P1, proc P2&gt; : aCalls, 
                &lt;comp C1, comp C2&gt; : aPartOf[P1] x aPartOf[P2]
   }</programlisting>In our example, the lifted call relation between
      components is obtained by<programlisting>rel[comp,comp] ComponentCalls = lift(Calls2, PartOf)</programlisting>and
      has as value:<programlisting>{&lt;"DB", "Lib"&gt;, &lt;"Appl", "Lib"&gt;, &lt;"Appl", "DB"&gt;, &lt;"Appl", "Appl"&gt;}</programlisting>The
      relevant relations for this example are shown in <xref
      linkend="figure.parts" />.</para>

      <figure xml:id="figure.parts">
        <title>(a) <literal>Calls2</literal>; (b) <literal>PartOf</literal>;
        (c) <literal>ComponentCalls</literal>.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="parts.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="section.analyzing-java">
      <title>Analyzing the Structure of Java Systems</title>

      <para>Now we consider the analysis of Java systems (inspired by
      <biblioref linkend="BNL03" />. Suppose that the type
      <literal>class</literal> is defined as follows<programlisting>type class = str</programlisting>and
      that the following relations are available about a Java
      application:</para>

      <itemizedlist>
        <listitem>
          <para><literal>rel[class,class] CALL</literal>: If
          <literal>&lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt;</literal>
          is an element of <literal>CALL</literal>, then some method of
          <replaceable>C</replaceable><subscript>2</subscript> is called from
          <replaceable>C</replaceable><subscript>1</subscript>.</para>
        </listitem>

        <listitem>
          <para><literal>rel[class,class] INHERITANCE</literal>: If
          <literal>&lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt;</literal>
          is an element of <literal>INHERITANCE</literal>, then class
          <replaceable>C</replaceable><subscript>1</subscript> either extends
          class <replaceable>C</replaceable><subscript>2</subscript> or
          <replaceable>C</replaceable><subscript>1</subscript> implements
          interface
          <replaceable>C</replaceable><subscript>2</subscript>.</para>
        </listitem>

        <listitem>
          <para><literal>rel[class,class] CONTAINMENT</literal>: If
          &lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt; is an
          element of <literal>CONTAINMENT</literal>, then one of the
          attributes of class
          <replaceable>C</replaceable><subscript>1</subscript> is of type
          <replaceable>C</replaceable><subscript>2</subscript>.</para>
        </listitem>
      </itemizedlist>

      <para>To make this more explicit, consider the class
      <literal>LocatorHandle</literal> from the JHotDraw application (version
      5.2) as shown here:</para>

      <para><programlisting>package CH.ifa.draw.standard;

import java.awt.Point;
import CH.ifa.draw.framework.*;
/**
 * A LocatorHandle implements a Handle by delegating the 
 * location requests to a Locator object.
 */
public class LocatorHandle extends AbstractHandle {
    private Locator       fLocator;
    /**
     * Initializes the LocatorHandle with the given Locator.
     */
    public LocatorHandle(Figure owner, Locator l) {
        super(owner);
        fLocator = l;
    }
    /**
     * Locates the handle on the figure by forwarding the request
     * to its figure.
     */
    public Point locate() {
        return fLocator.locate(owner());
    }
}</programlisting></para>

      <para>It leads to the addition to the above relations of the following
      tuples:</para>

      <itemizedlist>
        <listitem>
          <para>To <literal>CALL</literal> the pairs
          <literal>&lt;"LocatorHandle", "AbstractHandle"&gt;</literal> and
          <literal>&lt;"LocatorHandle", "Locator"&gt;</literal> will be
          added.</para>
        </listitem>

        <listitem>
          <para>To <literal>INHERITANCE</literal> the pair
          <literal>&lt;"LocatorHandle", "AbstractHandle"&gt;</literal> will be
          added.</para>
        </listitem>

        <listitem>
          <para>To <literal>CONTAINMENT</literal> the pair
          <literal>&lt;"LocatorHandle", "Locator"&gt;</literal> will be
          added.</para>
        </listitem>
      </itemizedlist>

      <para>Cyclic structures in object-oriented systems makes understanding
      hard. Therefore it is interesting to spot classes that occur as part of
      a cyclic dependency. Here we determine cyclic uses of classes that
      include calls, inheritance and containment. This is achieved as
      follows:<programlisting>rel[class,class] USE = CALL union CONTAINMENT union INHERITANCE
set[str] ClassesInCycle =
   {C1 | &lt;class C1, class C2&gt; : USE+, C1 == C2}</programlisting>First,
      we define the <literal>USE</literal> relation as the union of the three
      available relations <literal>CALL</literal>,
      <literal>CONTAINMENT</literal> and <literal>INHERITANCE</literal>. Next,
      we consider all pairs
      &lt;<replaceable>C</replaceable><subscript>1</subscript>,
      <replaceable>C</replaceable><subscript>2</subscript>&gt; in the
      transitive closure of the <literal>USE</literal> relation such that
      <replaceable>C</replaceable><subscript>1</subscript> and
      <replaceable>C</replaceable><subscript>2</subscript> are equal. Those
      are precisely the cases of a class with a cyclic dependency on itself.
      Probably, we do not only want to know which classes occur in a cyclic
      dependency, but we also want to know which classes are involved in such
      a cycle. In other words, we want to associate with each class a set of
      classes that are responsible for the cyclic dependency. This can be done
      as follows.<programlisting>rel[class,class] USE = CALL union CONTAINMENT union INHERITANCE
set[class] CLASSES = carrier(USE)
rel[class,class] USETRANS = USE+
rel[class,set[class]] ClassCycles = 
   {&lt;C, USETRANS[C]&gt; | class C : CLASSES, &lt;C, C&gt; in USETRANS }</programlisting>First,
      we introduce two new shorthands: <literal>CLASSES</literal> and
      <literal>USETRANS</literal>. Next, we consider all classes
      <literal>C</literal> with a cyclic dependency and add the pair
      <literal>&lt;C, USETRANS[C]&gt;</literal> to the relation
      <literal>ClassCycles</literal>. Note that <literal>USETRANS[C]</literal>
      is the right image of the relation <literal>USETRANS</literal> for
      element <literal>C</literal>, i.e., all classes that can be called
      transitively from class <literal>C</literal>.</para>
    </section>

    <section xml:id="section.unitialized-variables">
      <title>Finding Uninitialized and Unused Variables in a Program</title>

      <para>Consider the following program in the toy language Pico: (This is
      an extended version of the example presented earlier in <biblioref
      linkend="KlintIWPC03" />.)<programlisting>[ 1] begin declare x : natural, y : natural,
[ 2]              z : natural, p : natural;
[ 3]  x := 3;
[ 4]  p := 4;
[ 5]  if q then
[ 6]        z := y + x
[ 7]  else
[ 8]        x := 4
[ 9]  fi;
[10]  y := z
[11] end</programlisting>Inspection of this program learns that some of the
      variables are being used before they have been initialized. The
      variables in question are <literal>q</literal> (line 5),
      <literal>y</literal> (line 6), and <literal>z</literal> (line 10). It is
      also clear that variable <literal>p</literal> is initialized (line 4),
      but is never used. How can we automate these kinds of analysis? Recall
      from <xref linkend="section.EASY-programming" /> that we follow
      Extract-Analyze-SYnthesize paradigm to approach such a problem. The
      first step is to determine which elementary facts we need about the
      program. For this and many other kinds of program analysis, we need at
      least the following:</para>

      <itemizedlist>
        <listitem>
          <para>The <emphasis>control flow graph</emphasis> of the program. We
          represent it by a relation <literal>PRED</literal> (for predecessor)
          which relates each statement with each predecessors.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>definitions</emphasis> of each variable, i.e.,
          the program statements where a value is assigned to the variable. It
          is represented by the relation <literal>DEFS</literal>.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>uses</emphasis> of each variable, i.e., the
          program statements where the value of the variable is used. It is
          represented by the relation <literal>USES</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>In this example, we will use line numbers to identify the
      statements in the program. (In <xref
      linkend="section.using-locations" />, we will use locations to represent
      statements.) Assuming that there is a tool to extract the above
      information from a program text, we get the following for the above
      example:<programlisting>type expr = int
type varname = str
expr ROOT = 1
rel[expr,expr] PRED = { &lt;1,3&gt;, &lt;3,4&gt;, &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,8&gt;, 
                        &lt;6,10&gt;, &lt;8,10&gt; 
                      }
rel[expr,varname] DEFS = { &lt;3,"x"&gt;, &lt;4,"p"&gt;, &lt;6,"z"&gt;, 
                           &lt;8,"x"&gt;, &lt;10,"y"&gt;
                         }
rel[expr,varname] USES = { &lt;5,"q"&gt;, &lt;6,"y"&gt;, &lt;6,"x"&gt;, &lt;10,"z"&gt; }</programlisting>This
      concludes the extraction phase. Next, we have to enrich these basic
      facts to obtain the initialized variables in the program. So, when is a
      variable <replaceable>V</replaceable> in some statement
      <replaceable>S</replaceable> initialized? If we execute the program
      (starting in <literal>ROOT</literal>), there may be several possible
      execution path that can reach statement <replaceable>S</replaceable>.
      All is well if <emphasis>all</emphasis> these execution path contain a
      definition of <replaceable>V</replaceable>. However, if one or more of
      these path do <emphasis>not</emphasis> contain a definition of
      <replaceable>V</replaceable>, then <replaceable>V</replaceable> may be
      uninitialized in statement <replaceable>S</replaceable>. This can be
      formalized as follows:<programlisting>rel[expr,varname] UNINIT = 
   { &lt;E, V&gt; | &lt;expr E, varname V&gt;: USES, 
              E in reachX({ROOT}, DEFS[-,V], PRED)
   }</programlisting></para>

      <para>We analyze this definition in detail:</para>

      <itemizedlist>
        <listitem>
          <para><literal>&lt;expr E, varname V&gt; : USES</literal> enumerates
          all tuples in the <literal>USES</literal> relation. In other words,
          we consider the use of each variable in turn.</para>
        </listitem>

        <listitem>
          <para><literal>E in reachX({ROOT}, DEFS[-,V], PRED) </literal>is a
          test that determines whether statement <replaceable>S</replaceable>
          is reachable from the <literal>ROOT</literal> without encountering a
          definition of variable <replaceable>V</replaceable>.</para>

          <itemizedlist>
            <listitem>
              <para><literal>{ROOT}</literal> represents the initial set of
              nodes from which all path should start.</para>
            </listitem>

            <listitem>
              <para><literal>DEFS[-,V]</literal> yields the set of all
              statements in which a definition of variable
              <literal>V</literal> occurs. These nodes form the exclusion set
              for <literal>reachX</literal>: no path will be extended beyond
              an element in this set.</para>
            </listitem>

            <listitem>
              <para><literal>PRED</literal> is the relation for which the
              reachability has to be determined.</para>
            </listitem>

            <listitem>
              <para>The result of <literal>reachX({ROOT}, DEFS[-,V], PRED)
              </literal>is a set that contains all nodes that are reachable
              from the <literal>ROOT</literal> (as well as all intermediate
              nodes on each path).</para>
            </listitem>

            <listitem>
              <para>Finally, <literal>E in reachX({ROOT}, DEFS[-,V], PRED)
              </literal>tests whether expression <literal>E</literal> can be
              reached from the <literal>ROOT</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The net effect is that <literal>UNINIT</literal> will only
          contain pairs that satisfy the test just described.</para>
        </listitem>
      </itemizedlist>

      <para>When we execute the resulting Rascal code (i.e., the declarations
      of <literal>ROOT</literal>, <literal>PRED</literal>,
      <literal>DEFS</literal>, <literal>USES</literal> and
      <literal>UNINIT</literal>), we get as value for
      <literal>UNINIT</literal>:<programlisting>{&lt;5, "q"&gt;, &lt;6, "y"&gt;, &lt;10, "z"&gt;}</programlisting>and
      this is in concordance with the informal analysis given at the beginning
      of this example.</para>

      <para>As a bonus, we can also determine the <emphasis>unused</emphasis>
      variables in a program, i.e., variables that are defined but are used
      nowhere. This is done as follows:<programlisting>set[var] UNUSED = range(DEFS) \ range(USES)</programlisting>Taking
      the range of the relations <literal>DEFS</literal> and
      <literal>USES</literal> yields the variables that are defined,
      respectively, used in the program. The difference of these two sets
      yields the unused variables, in this case
      <literal>{"p"}</literal>.</para>
    </section>

    <section xml:id="section.using-locations">
      <title>Using Locations to Represent Program Fragments</title>

      <para><warning>
          <para>Fix the following</para>
        </warning>\begin{figure}[tb] \begin{center}
      \epsfig{figure=figs/meta-pico.eps,width=6cm} \hspace*{0.5cm}
      \epsfig{figure=figs/pico-example.eps,width=6cm} \end{center} \hrulefill
      \caption{\label{FIG:meta-pico}Checking undefined variables in Pico
      programs using the ASF+SDF Meta-Environment. On the left, main window of
      Meta-Environment with error messages related to Pico program shown on
      the right.{\bf THIS FIGURE IS OUTDATED}} \end{figure}</para>

      <para>One aspect of the example we have just seen is artificial: where
      do these line numbers come from that we used to indicate expressions in
      the program? One solution is to let the extraction phase generate
      <emphasis>locations</emphasis> to precisely indicate relevant places in
      the program text. Recall from <xref
      linkend="section.elementary-types" />, that a location consists of a
      file name, a begin line, a begin position, an end line, and an end
      position. Also recall that locations can be compared: a location
      <replaceable>A</replaceable><subscript>1</subscript> is smaller than
      another location <replaceable>A</replaceable><subscript>2</subscript>,
      if <replaceable>A</replaceable><subscript>1</subscript> is textually
      contained in <replaceable>A</replaceable><subscript>2</subscript>. By
      including locations in the final answer of a relational expression,
      external tools will be able to highlight places of interest in the
      source text.</para>

      <para>The first step, is to define the type <literal>expr</literal> as
      aliases for <literal>loc</literal> (instead of
      <literal>int</literal>):</para>

      <para><programlisting>type expr = loc
type varname = str </programlisting></para>

      <para>Of course, the actual relations are now represented differently.
      For instance, the <literal>USES</literal> relation may now look
      like</para>

      <para><programlisting>{ &lt;area-in-file("/home/paulk/example.pico", 
                area(5,5,5,6,106,1)), "q"&gt;, 
  &lt;area-in-file("/home/paulk/example.pico", 
                area(6,13,6,14,127,1)), "y"&gt;, 
  &lt;area-in-file("/home/paulk/example.pico", 
                area(6,17,6,18,131,1)), "x"&gt;, 
  &lt;area-in-file("/home/paulk/example.pico", 
                area(10,7,10,8,168,1)), "z"&gt; 
} </programlisting></para>

      <para>The definition of <literal>UNINIT</literal> can be nearly reused
      as is. The only thing that remains to be changed is to map the
      (expression, variable-name) tuples to (variable-name,
      variable-occurrence) tuples, for the benefit of the precise highlighting
      of the relevant variables. We define a new type <literal>var</literal>
      to represent variable occurrences and an auxiliary set that
      <literal>VARNAMES</literal> that contains all variable names:</para>

      <para><programlisting>type var = loc
set[varname] VARNAMES = range(DEFS) union range(USES)</programlisting></para>

      <para>Remains the new definition of <literal>UNINIT</literal>:</para>

      <para><programlisting>rel[var, varname] UNINIT = 
   { &lt;V, VN&gt;| var-name VN : VARNAMES, 
              var V : USES[-,VN], 
              expr E : reachX({ROOT}, DEFS[-,VN], PRED), 
              V &lt;= E 
   }</programlisting></para>

      <para>This definition can be understood as follows:</para>

      <itemizedlist>
        <listitem>
          <para><literal>var-name VN : VARNAMES</literal> generates all
          variable names.</para>
        </listitem>

        <listitem>
          <para><literal>var V : USES[-,VN]</literal> generates all variable
          uses <literal>V</literal> for variables with name
          <literal>VN</literal>.</para>
        </listitem>

        <listitem>
          <para>As before, <literal>expr E : reachX({ROOT}, DEFS[-,VN],
          PRED)</literal> generates all expressions <literal>E</literal> that
          can be reached from the start of the program without encountering a
          definition for variables named <literal>VN</literal>.</para>
        </listitem>

        <listitem>
          <para>V<literal> &lt;= E</literal> tests whether variable use
          <literal>V</literal> is enclosed in that expression (using a
          comparison on locations). If so, we have found an uninitialized
          occurrence of the variable named <literal>VN</literal>.</para>
        </listitem>
      </itemizedlist>

      <para><warning>
          <para>Fix reference</para>
        </warning>In Figure~\ref{FIG:meta-pico} it is shown how checking of
      Pico programs in the ASF+SDF Meta-Environment looks like.</para>
    </section>

    <section xml:id="section.McCabe">
      <title>McCabe Cyclomatic Complexity</title>

      <para>The <emphasis>cyclomatic complexity</emphasis> of a program is
      defined as <replaceable>e</replaceable> - <replaceable>n</replaceable> +
      2, where <replaceable>e</replaceable> and <replaceable>n</replaceable>
      are the number of edges and nodes in the control flow graph,
      respectively. It was proposed by McCabe <biblioref linkend="McCabe76" />
      as a measure of program complexity. Experiments have shown that programs
      with a higher cyclomatic complexity are more difficult to understand and
      test and have more errors. It is generally accepted that a program,
      module or procedure with a cyclomatic complexity larger than 15 is
      <emphasis>too complex</emphasis>. Essentially, cyclomatic complexity
      measures the number of decision points in a program and can be computed
      by counting all if statement, case branches in switch statements and the
      number of conditional loops. Given a control flow in the form of a
      predecessor relation <literal>rel[stat,stat] PRED</literal> between
      statements, the cyclomatic complexity can be computed in an Rascal as
      follows: <programlisting>int cyclomatic-complexity(rel[stat,stat] PRED) = 
    #PRED - #carrier(PRED) + 2</programlisting> The number of edges
      <replaceable>e</replaceable> is equal to the number of tuples in
      <literal>PRED</literal>. The number of nodes
      <replaceable>n</replaceable> is equal to the number of elements in the
      carrier of PRED, i.e., all elements that occur in a tuple in
      <literal>PRED</literal>.</para>
    </section>

    <section xml:id="section.dataflow">
      <title>Dataflow Analysis</title>

      <para><emphasis>Dataflow analysis</emphasis> is a program analysis
      technique that forms the basis for many compiler optimizations. It is
      described in any text book on compiler construction, e.g. <biblioref
      linkend="AhoSethiUllman86" />. The goal of dataflow analysis is to
      determine the effect of statements on their surroundings. Typical
      examples are:</para>

      <itemizedlist>
        <listitem>
          <para>Dominators (<xref linkend="section.dominators" />): which
          nodes in the flow dominate the execution of other nodes?</para>
        </listitem>

        <listitem>
          <para>Reaching definitions (<xref
          linkend="section.reaching-definitions" />): which definitions of
          variables are still valid at each statement?</para>
        </listitem>

        <listitem>
          <para>Live variables (<xref linkend="section.live-variables" />): of
          which variables will the values be used by successors of a
          statement?</para>
        </listitem>

        <listitem>
          <para>Available expressions: an expression is available if it is
          computed along each path from the start of the program to the
          current statement.</para>
        </listitem>
      </itemizedlist>

      <section xml:id="section.dominators">
        <title>Dominators</title>

        <para>A node <replaceable>d</replaceable> of a flow graph
        <emphasis>dominates</emphasis> a node <replaceable>n</replaceable>, if
        every path from the initial node of the flow graph to
        <replaceable>n</replaceable> goes through <replaceable>d</replaceable>
        <biblioref linkend="AhoSethiUllman86" /> (Section 10.4). Dominators
        play a role in the analysis of conditional statements and loops. The
        function <literal>dominators</literal> that computes the dominators
        for a given flow graph <literal>PRED</literal> and an entry node
        <literal>ROOT</literal> is defined as follows:</para>

        <para><programlisting>rel[stat,stat] dominators(rel[stat,stat] PRED, int ROOT) = 
   DOMINATES
where
    set[int] VERTICES = carrier(PRED)

    rel[int,set[int]] DOMINATES =
    { &lt;V,  VERTICES \ {V, ROOT} \ reachX({ROOT}, {V}, PRED)&gt; |  
      int V : VERTICES }
endwhere</programlisting></para>

        <para>First, the auxiliary set <literal>VERTICES</literal> (all the
        statements) is computed. The relation <literal>DOMINATES</literal>
        consists of all pairs <literal>&lt;<replaceable>S</replaceable>,
        {<replaceable>S</replaceable><subscript>1</subscript>,...,<replaceable>S</replaceable><subscript><replaceable>n</replaceable></subscript>}&gt;</literal>
        such that</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>S</replaceable><subscript><replaceable>i</replaceable></subscript>
            is not an initial node or equal to
            <replaceable>S</replaceable>.</para>
          </listitem>

          <listitem>
            <para><replaceable>S</replaceable><subscript><replaceable>i</replaceable></subscript>
            cannot be reached from the initial node without going through
            <replaceable>S</replaceable>.</para>
          </listitem>
        </itemizedlist>

        <para>Consider the flow graph<programlisting>rel[int,int] PRED = {
&lt;1,2&gt;, &lt;1,3&gt;,
&lt;2,3&gt;,
&lt;3,4&gt;,
&lt;4,3&gt;,&lt;4,5&gt;, &lt;4,6&gt;,
&lt;5,7&gt;,
&lt;6,7&gt;,
&lt;7,4&gt;,&lt;7,8&gt;,
&lt;8,9&gt;,&lt;8,10&gt;,&lt;8,3&gt;,
&lt;9,1&gt;,
&lt;10,7&gt;
}</programlisting>It is illustrated in<xref
        linkend="figure.flow-graph" /><figure xml:id="figure.flow-graph">
            <title>Flow graph</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="dominators.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure>The result of applying <literal>dominators</literal> to it
        is as follows:<programlisting>{&lt;1, {2, 3, 4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;2, {}&gt;, 
&lt;3, {4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;4, {5, 6, 7, 8, 9, 10}&gt;, 
&lt;5, {}&gt;, 
&lt;6, {}&gt;, 
&lt;7, {8, 9, 10}&gt;, 
&lt;8, {9, 10}&gt;, 
&lt;9, {}&gt;, 
&lt;10, {}&gt;}</programlisting>The resulting <emphasis>dominator
        tree</emphasis> is shown in <xref linkend="figure.dominator-tree" />.
        The dominator tree has the initial node as root and each node
        <replaceable>d</replaceable> in the tree only dominates its
        descendants in the tree.</para>

        <para><figure xml:id="figure.dominator-tree">
            <title>Dominator tree</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="dominator-tree.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section xml:id="section.reaching-definitions">
        <title>Reaching Definitions</title>

        <para>We illustrate the calculation of reaching definitions using the
        example in <xref linkend="figure.dataflow-graph" /> which was inspired
        by <biblioref linkend="AhoSethiUllman86" /> (Example 10.15).</para>

        <para><figure xml:id="figure.dataflow-graph">
            <title>Flow graph for various dataflow problems</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="df-graph.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>As before, we assume the following basic relations
        <literal>PRED</literal>, <literal>DEFS</literal> and
        <literal>USES</literal> about the program:<programlisting>type stat = int
type var = str
rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, &lt;4,5&gt;, &lt;5,6&gt;, 
                        &lt;5,7&gt;, &lt;6,7&gt;, &lt;7,4&gt;
                      }
rel[stat, var] DEFS = { &lt;1, "i"&gt;, &lt;2, "j"&gt;, &lt;3, "a"&gt;, &lt;4, "i"&gt;, 
                       &lt;5, "j"&gt;, &lt;6, "a"&gt;, &lt;7, "i"&gt;
                      }
rel[stat, var] USES = { &lt;1, "m"&gt;, &lt;2, "n"&gt;, &lt;3, "u1"&gt;, &lt;4, "i"&gt;, 
                        &lt;5, "j"&gt;, &lt;6, "u2"&gt;, &lt;7, "u3"&gt;
                      }</programlisting></para>

        <para>For convenience, we introduce a notion <literal>def</literal>
        that describes that a certain statement defines some variable and we
        revamp the basic relations into a more convenient format using this
        new type:<programlisting>type def  = &lt;stat theStat, var theVar&gt;

rel[stat, def] DEF = {&lt;S, &lt;S, V&gt;&gt; | &lt;stat S, var V&gt; : DEFS}
rel[stat, def] USE = {&lt;S, &lt;S, V&gt;&gt; | &lt;stat S, var V&gt; : USES}</programlisting>The
        new <literal>DEF</literal> relation gets as value:<programlisting>{ &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, &lt;3, &lt;3, "a"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
  &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, &lt;7, &lt;7, "i"&gt;&gt;
}</programlisting>and <literal>USE</literal> gets as value:<programlisting>{ &lt;1, &lt;1, "m"&gt;&gt;, &lt;2, &lt;2, "n"&gt;&gt;, &lt;3, &lt;3, "u1"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
  &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "u2"&gt;&gt;, &lt;7, &lt;7, "u3"&gt;&gt;
}</programlisting></para>

        <para>Now we are ready to define an important new relation
        <literal>KILL</literal>. <literal>KILL</literal> defines which
        variable definitions are undone (killed) at each statement and is
        defined as follows:<programlisting>rel[stat, def] KILL = 
   {&lt;S1, &lt;S2, V&gt;&gt; | &lt;stat S1, var V&gt; : DEFS, 
                    &lt;stat S2, V&gt; : DEFS, 
                    S1 != S2
   }</programlisting>In this definition, all variable definitions are compared
        with each other, and for each variable definition all
        <emphasis>other</emphasis> definitions of the same variable are placed
        in its kill set. In the example, <literal>KILL</literal> gets the
        value <programlisting>{ &lt;1, &lt;4, "i"&gt;&gt;, &lt;1, &lt;7, "i"&gt;&gt;, &lt;2, &lt;5, "j"&gt;&gt;, &lt;3, &lt;6, "a"&gt;&gt;, 
  &lt;4, &lt;1, "i"&gt;&gt;, &lt;4, &lt;7, "i"&gt;&gt;, &lt;5, &lt;2, "j"&gt;&gt;, &lt;6, &lt;3, "a"&gt;&gt;, 
  &lt;7, &lt;1, "i"&gt;&gt;, &lt;7, &lt;4, "i"&gt;&gt;
}</programlisting>and, for instance, the definition of variable
        <literal>i</literal> in statement <literal>1</literal> kills the
        definitions of <literal>i</literal> in statements <literal>4</literal>
        and <literal>7</literal>. Next, we introduce the collection of
        statements<programlisting>set[stat] STATEMENTS = carrier(PRED)</programlisting>which
        gets as value <literal>{1, 2, 3, 4, 5, 6, 7}</literal> and two
        convenience functions to obtain the predecessor, respectively, the
        successor of a statement:</para>

        <para><programlisting>set[stat] predecessor(stat S) = PRED[-,S] 
set[stat] successor(stat S) = PRED[S,-]</programlisting></para>

        <para>After these preparations, we are ready to formulate the reaching
        definitions problem in terms of two relations <literal>IN</literal>
        and <literal>OUT</literal>. <literal>IN</literal> captures all the
        variable definitions that are valid at the entry of each statement and
        <literal>OUT</literal> captures the definitions that are still valid
        after execution of each statement. Intuitively, for each statement
        <literal>S</literal>, <literal>IN[S]</literal> is equal to the union
        of the <literal>OUT</literal> of all the predecessors of
        <literal>S</literal>. <literal>OUT[S]</literal>, on the other hand, is
        equal to the definitions generated by <literal>S</literal> to which we
        add <literal>IN[S]</literal> minus the definitions that are killed in
        <literal>S</literal>. Mathematically, the following set of equations
        captures this idea for each statement:</para>

        <para><warning>
            <para>Fix expression</para>
          </warning></para>

        <para>[ IN[S] = \bigcup_{P \in predecessor of S} OUT[P] \]</para>

        <para>\[ OUT[S] = DEF[S] \cup (IN[S] - KILL[S]) \]</para>

        <para></para>

        <para>This idea can be expressed in Rascal quite
        literally:<programlisting>equations
  initial
        rel[stat,def] IN init {}
        rel[stat,def] OUT init DEF
  satisfy
        IN  = {&lt;S, D&gt; | stat S : STATEMENTS, 
                        stat P : predecessor(S), 
                        def D : OUT[P]}
        OUT = {&lt;S, D&gt; | stat S : STATEMENTS, 
                        def D : DEF[S] union (IN[S] \ KILL[S])}
end equations</programlisting>First, the relations <literal>IN</literal> and
        <literal>OUT</literal> are declared and initialized. Next, two
        equations are given that very much resemble the ones given
        above.</para>

        <para><figure xml:id="figure.reaching-definitions">
            <title>Reaching definitions for flow graph in <xref
            linkend="figure.dataflow-graph" /></title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="reach.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure> For our running example (<xref
        linkend="figure.reaching-definitions" />) the results are as follows
        (see <xref linkend="figure.reaching-definitions" />). Relation
        <literal>IN</literal> has as value:<programlisting>{ &lt;2, &lt;1, "i"&gt;&gt;, &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, &lt;4, &lt;3, "a"&gt;&gt;, 
  &lt;4, &lt;2, "j"&gt;&gt;, &lt;4, &lt;1, "i"&gt;&gt;, &lt;4, &lt;7, "i"&gt;&gt;, &lt;4, &lt;5, "j"&gt;&gt;, 
  &lt;4, &lt;6, "a"&gt;&gt;, &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;2, "j"&gt;&gt;, 
  &lt;5, &lt;5, "j"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, &lt;6, &lt;5, "j"&gt;&gt;, &lt;6, &lt;4, "i"&gt;&gt;, 
  &lt;6, &lt;3, "a"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, &lt;7, &lt;5, "j"&gt;&gt;, &lt;7, &lt;4, "i"&gt;&gt;, 
  &lt;7, &lt;3, "a"&gt;&gt;, &lt;7, &lt;6, "a"&gt;&gt;
}</programlisting></para>

        <para>If we consider statement <literal>3</literal>, then the
        definitions of variables <literal>i</literal> and <literal>j</literal>
        from the preceding two statements are still valid. A more interesting
        case are the definitions that can reach statement
        <literal>4</literal>:</para>

        <itemizedlist>
          <listitem>
            <para>The definitions of variables <literal>a</literal>,
            <literal>j</literal> and <literal>i</literal> from, respectively,
            statements <literal>3</literal>, <literal>2</literal> and
            <literal>1</literal>.</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>i</literal> from
            statement <literal>7</literal> (via the backward control flow path
            from <literal>7</literal> to <literal>4</literal>).</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>j</literal> from
            statement <literal>5</literal> (via the path <literal>5</literal>,
            <literal>7</literal>, <literal>4</literal>).</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>a</literal> from
            statement <literal>6</literal> (via the path <literal>6</literal>,
            <literal>7</literal>, <literal>4</literal>).</para>
          </listitem>
        </itemizedlist>

        <para>Relation <literal>OUT</literal> has as value:<programlisting>{ &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, &lt;2, &lt;1, "i"&gt;&gt;, &lt;3, &lt;3, "a"&gt;&gt;, 
  &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, &lt;4, &lt;3, "a"&gt;&gt;, 
  &lt;4, &lt;2, "j"&gt;&gt;, &lt;4, &lt;5, "j"&gt;&gt;, &lt;4, &lt;6, "a"&gt;&gt;, &lt;5, &lt;5, "j"&gt;&gt;, 
  &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, 
  &lt;6, &lt;5, "j"&gt;&gt;, &lt;6, &lt;4, "i"&gt;&gt;, &lt;7, &lt;7, "i"&gt;&gt;, &lt;7, &lt;5, "j"&gt;&gt;, 
  &lt;7, &lt;3, "a"&gt;&gt;, &lt;7, &lt;6, "a"&gt;&gt;
}</programlisting>Observe, again for statement <literal>4</literal>, that all
        definitions of variable <literal>i</literal> are missing in
        <literal>OUT[4]</literal> since they are killed by the definition of
        <literal>i</literal> in statement <literal>4</literal> itself.
        Definitions for <literal>a</literal> and <literal>j</literal> are,
        however, contained in <literal>OUT[4]</literal>. The result of
        reaching definitions computation is illustrated in <xref
        linkend="figure.reaching-definitions" />. The above definitions are
        used to formulate the function
        <literal>reaching-definitions</literal>. It assumes appropriate
        definitions for the types <literal>stat</literal> and
        <literal>var</literal>. It also assumes more general versions of
        <literal>predecessor</literal> and <literal>successor</literal>. We
        will use it later on in <xref linkend="section.program-slicing" />
        when defining program slicing. Here is the definition of
        <literal>reaching-definitions</literal>:<programlisting>type def  = &lt;stat theStat, var theVar&gt;
type use  = &lt;stat theStat, var theVar&gt;

set[stat] predecessor(rel[stat,stat] P, stat S) = P[-,S]

set[stat] successor(rel[stat,stat] P, stat S) = P[S,-]

rel[stat, def] reaching-definitions(rel[stat,var] DEFS, 
                                    rel[stat,stat] PRED) = 
   IN
where
    set[stat] STATEMENT = carrier(PRED)

    rel[stat,def] DEF  = {&lt;S,&lt;S,V&gt;&gt; | &lt;stat S, var V&gt; : DEFS}

    rel[stat,def] KILL = 
        {&lt;S1, &lt;S2, V&gt;&gt; | &lt;stat S1, var V&gt; : DEFS, 
                         &lt;stat S2, V&gt; : DEFS, 
                         S1 != S2
        }

    equations 
       initial
           rel[stat,def] IN init {}
           rel[stat,def] OUT init DEF
       satisfy
           IN  =  {&lt;S, D&gt; | int S : STATEMENT, 
                            stat P : predecessor(PRED,S), 
                            def D : OUT[P]}
           OUT = {&lt;S, D&gt; |  int S : STATEMENT, 
                            def D : DEF[S] union (IN[S] \ KILL[S])}
    end equations
end where</programlisting></para>
      </section>

      <section xml:id="section.live-variables">
        <title>Live Variables</title>

        <para>The live variables of a statement are those variables whose
        value will be used by the current statement or some successor of it.
        The mathematical formulation of this problem is as follows:<warning>
            <para>Fix expression</para>
          </warning></para>

        <para>\[ IN[S] =USE[S] \cup (OUT[S] - DEF[S]) \]</para>

        <para>\[ OUT[S] = \bigcup_{S' \in successor of S} IN[S'] \]</para>

        <para>The first equation says that a variable is live coming into a
        statement if either it is used before redefinition in that statement
        or it is live coming out of the statement and is not redefined in it.
        The second equation says that a variable is live coming out of a
        statement if and only if it is live coming into one of its
        successors.</para>

        <para>This can be expressed in Rascal as follows:<programlisting>equations
  initial
      rel[stat,def] LIN init {}
      rel[stat,def] LOUT init DEF
  satisfy
      LIN = { &lt; S, D&gt; | stat S : STATEMENTS,  
                        def D : USE[S] union (LOUT[S] \ (DEF[S]))
            }
      LOUT= { &lt; S, D&gt; | stat S : STATEMENTS,  
                        stat Succ : successor(S), 
                        def D : LIN[Succ] 
            }
end equations</programlisting>The results of live variable analysis for our
        running example are illustrated in <xref
        linkend="figure.live-variables" />.</para>

        <para><figure xml:id="figure.live-variables">
            <title>Live variables for flow graph in <xref
            linkend="figure.dataflow-graph" /></title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="live.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>
    </section>

    <section xml:id="section.program-slicing">
      <title>Program Slicing</title>

      <para>Program slicing is a technique proposed by Weiser <biblioref
      linkend="Weiser84" /> for automatically decomposing programs in parts by
      analyzing their data flow and control flow. Typically, a given statement
      in a program is selected as the <emphasis>slicing criterion</emphasis>
      and the original program is reduced to an independent subprogram, called
      a <emphasis>slice</emphasis>, that is guaranteed to represent faithfully
      the behavior of the original program at the slicing criterion. An
      example will illustrate this:</para>

      <para><programlisting xml:id="programlisting.slice-example">[ 1] read(n)            [ 1] read(n)           [ 1] read(n)
[ 2] i := 1             [ 2] i := 1            [ 2] i := 1
[ 3] sum := 0           [ 3] sum := 0         
[ 4] product := 1                              [ 4] product := 1
[ 5] while i&lt;= n do     [ 5] while i&lt;= n do    [ 5] while i&lt;= n do
     begin                   begin                  begin
[ 6]   sum := sum + i   [ 6]   sum := sum + i
[ 7]   product :=                              [ 7]   product := 
         product * i                                    product * i
[ 8]   i := i + 1       [ 8]  i := i + 1       [ 8]   i := i + 1
     end                     end                    end
[ 9] write(sum)         [ 9] write(sum)
[10] write(product)                            [10] write(product)

<emphasis role="bold">(a)</emphasis> Sample program     <emphasis role="bold"> (b)</emphasis> Slice for          <emphasis
            role="bold">(c)</emphasis> Slice for
                           statement [9]           statement [10]</programlisting></para>

      <para>The initial program is given as (a). The slice with statement [9]
      as slicing criterion is shown in (b): statements <literal>[4]</literal>
      and <literal>[7]</literal> are irrelevant for computing statement
      <literal>[9]</literal> and do not occur in the slice. Similarly, (c)
      shows the slice with statement <literal>[10]</literal> as slicing
      criterion. This particular form of slicing is called <emphasis>backward
      slicing</emphasis>. Slicing can be used for debugging and program
      understanding, optimization and more. An overview of slicing techniques
      and applications can be found in <biblioref linkend="Tip95" />. Here we
      will explore a relational formulation of slicing adapted from a proposal
      in <biblioref linkend="JacksonRollins94" />J. The basic ingredients of
      the approach are as follows:</para>

      <itemizedlist>
        <listitem>
          <para>We assume the relations <literal>PRED</literal>,
          <literal>DEFS</literal> and <literal>USES</literal> as
          before.</para>
        </listitem>

        <listitem>
          <para>We assume an additional set
          <literal>CONTROL-STATEMENT</literal> that defines which statements
          are control statements.</para>
        </listitem>

        <listitem>
          <para>To tie together dataflow and control flow, three auxiliary
          variables are introduced:</para>

          <itemizedlist>
            <listitem>
              <para>The variable <literal>TEST</literal> represents the
              outcome of a specific test of a conditional statement. The
              conditional statement defines <literal>TEST</literal> and all
              statements that are control dependent on this conditional
              statement will use <literal>TEST</literal>.</para>
            </listitem>

            <listitem>
              <para>The variable <literal>EXEC</literal> represents the
              potential execution dependence of a statement on some
              conditional statement. The dependent statement defines
              <literal>EXEC</literal> and an explicit (control) dependence is
              made between <literal>EXEC</literal> and the corresponding
              <literal>TEST</literal>.</para>
            </listitem>

            <listitem>
              <para>The variable <literal>CONST</literal> represents an
              arbitrary constant.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>The calculation of a (backward) slice now proceeds in six
      steps:</para>

      <itemizedlist>
        <listitem>
          <para>Compute the relation <literal>rel[use,def] use-def</literal>
          that relates all uses to their corresponding definitions. The
          function <literal>reaching-definitions</literal> as shown earlier in
          <xref linkend="section.reaching-definitions" />does most of the
          work.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[def,use]
          def-use-per-stat</literal> that relates the
          <emphasis>internal</emphasis> definitions and uses of a
          statement.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[def,use]
          control-dependence</literal> that links all <literal>EXEC</literal>s
          to the corresponding <literal>TEST</literal>s.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[use,def]
          use-control-def</literal> combines use/def dependencies with control
          dependencies.</para>
        </listitem>

        <listitem>
          <para>After these preparations, compute the relation
          <literal>rel[use,use] USE-USE</literal> that contains dependencies
          of uses on uses.</para>
        </listitem>

        <listitem>
          <para>The backward slice for a given slicing criterion (a use) is
          now simply the projection of <literal>USE-USE</literal> for the
          slicing criterion.</para>
        </listitem>
      </itemizedlist>

      <para>This informal description of backward slicing can now be expressed
      in Rascal:</para>

      <para><programlisting>set[use] BackwardSlice(
    set[stat] CONTROL-STATEMENT, 
    rel[stat,stat] PRED,
    rel[stat,var] USES,
    rel[stat,var] DEFS,    
    use Criterion) 
= USE-USE[Criterion]

where
    rel[stat, def] REACH = reaching-definitions(DEFS, PRED)

    rel[use,def] use-def = 
       { &lt;&lt;S1,V&gt;, &lt;S2,V&gt;&gt; | &lt;stat S1, var V&gt; : USES, 
                            &lt;stat S2, V&gt; : REACH[S1]
       }

    rel[def,use] def-use-per-stat  = 
       {&lt;&lt;S,V1&gt;, &lt;S,V2&gt;&gt; | &lt;stat S, var V1&gt; : DEFS, 
                           &lt;S, var V2&gt; : USES
       }
             union
       {&lt;&lt;S,V&gt;, &lt;S,"EXEC"&gt;&gt; | &lt;stat S, var V&gt; : DEFS}
             union
       {&lt;&lt;S,"TEST"&gt;,&lt;S,V&gt;&gt; | stat S : CONTROL-STATEMENT, 
                             &lt;S, var V&gt; : domainR(USES, {S})
       }

    rel[stat, stat] CONTROL-DOMINATOR = 
       domainR(dominators(PRED), CONTROL-STATEMENT)

    rel[def,use] control-dependence  =
       { &lt;&lt;S2, "EXEC"&gt;,&lt;S1,"TEST"&gt;&gt; | 
         &lt;stat S1, stat S2&gt; : CONTROL-DOMINATOR
       }

    rel[use,def] use-control-def = use-def union control-dependence

    rel[use,use] USE-USE = (use-control-def o def-use-per-stat)*

endwhere</programlisting></para>

      <para>Let's apply this to the example from the start of this section and
      assume the following:<programlisting>rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,9&gt;, 
                        &lt;6,7&gt;, &lt;7,8&gt;,&lt;8,5&gt;, &lt;8,9&gt;, &lt;9,10&gt;
                      }

rel[stat,var] DEFS  = { &lt;1, "n"&gt;, &lt;2, "i"&gt;, &lt;3, "sum"&gt;, 
                        &lt;4,"product"&gt;, &lt;6, "sum"&gt;, &lt;7, "product"&gt;, 
                        &lt;8, "i"&gt;
                      }

rel[stat,var] USES  = { &lt;5, "i"&gt;, &lt;5, "n"&gt;, &lt;6, "sum"&gt;, &lt;6,"i"&gt;,
                        &lt;7, "product"&gt;, &lt;7, "i"&gt;, &lt;8, "i"&gt;, 
                        &lt;9, "sum"&gt;, &lt;10, "product"&gt;
                      }

set[int] CONTROL-STATEMENT = { 5 }</programlisting> The result of the
      slice<programlisting>BackwardSlice(CONTROL-STATEMENT, PRED, USES, DEFS, &lt;9, "sum"&gt;)</programlisting>will
      then be<programlisting> { &lt;1, "EXEC"&gt;, &lt;2, "EXEC"&gt;,  &lt;3, "EXEC"&gt;, &lt;5, "i"&gt;, &lt;5, "n"&gt;,  
   &lt;6, "sum"&gt;, &lt;6, "i"&gt;, &lt;6, "EXEC"&gt;, &lt;8, "i"&gt;, &lt;8, "EXEC"&gt;, 
   &lt;9, "sum"&gt; }</programlisting> Take the domain of this result and we
      get exactly the statements in (b) of the example.</para>
    </section>
  </section>

  <section xml:id="section.builtin">
    <title>Built-in Operators and Functions</title>

    <para>The built-in operators and functions can be subdivided in the
    following categories:</para>

    <itemizedlist>
      <listitem>
        <para>Benchmark: measuring functions, see <xref
        linkend="section.lib-Benchmark" />.</para>
      </listitem>

      <listitem>
        <para>Boolean: operators and functions on Boolean values, see <xref
        linkend="section.lib-Boolean" />.</para>
      </listitem>

      <listitem>
        <para>Exception: data definition of all soft exceptions that can be
        caught by Rascal programs, see <xref
        linkend="section.lib-Exception" />.</para>
      </listitem>

      <listitem>
        <para>Graph: graphs are a special kind of binary relation, see <xref
        linkend="section.lib-Graph" />.</para>
      </listitem>

      <listitem>
        <para>Integer: operators and functions on integers, see <xref
        linkend="section.lib-Integer" />.</para>
      </listitem>

      <listitem>
        <para>IO: simple print functions, see <xref
        linkend="section.lib-IO" />.</para>
      </listitem>

      <listitem>
        <para>Labelled Graph: labelled graphs with addition edge information,
        see <xref linkend="section.lib-LabelledGraph" />.</para>
      </listitem>

      <listitem>
        <para>List: operators and functions on lists, see <xref
        linkend="section.lib-List" />.</para>
      </listitem>

      <listitem>
        <para>Location: operators and functions on source locations, see <xref
        linkend="section.lib-Location" />.</para>
      </listitem>

      <listitem>
        <para>Map: operators and functions on maps, see <xref
        linkend="section.lib-Map" />.</para>
      </listitem>

      <listitem>
        <para>Node: operators and functions on nodes, see <xref
        linkend="section.lib-Map" />.</para>
      </listitem>

      <listitem>
        <para>Real: operators and functions on reals, see <xref
        linkend="section.lib-Real" />.</para>
      </listitem>

      <listitem>
        <para>Relation: operators and funcions on relations, see <xref
        linkend="section.lib-Relation" />.</para>
      </listitem>

      <listitem>
        <para>Resource: functions to retrieve resources from an Eclipse
        workspace, see <xref linkend="section.lib-Resource" />.</para>
      </listitem>

      <listitem>
        <para>RSF: function for reading files in Rigi Standard Format, see
        <xref linkend="section.lib-RSF" />.</para>
      </listitem>

      <listitem>
        <para>Set: operators and functions on sets, see <xref
        linkend="section.lib-Set" />.</para>
      </listitem>

      <listitem>
        <para>String: operators and functions on strings, see <xref
        linkend="section.lib-String" />.</para>
      </listitem>

      <listitem>
        <para>Tuple: operators and functions on tuples, see <xref
        linkend="section.lib-Tuple" />.</para>
      </listitem>

      <listitem>
        <para>UnitTest: functions for unit testing, see <xref
        linkend="section.lib-UnitTest" />.</para>
      </listitem>

      <listitem>
        <para>ValueIO: functions for reading and writing Rascal values, both
        in textual and in binary form, see <xref
        linkend="section.lib-ValueIO" />.</para>
      </listitem>

      <listitem>
        <para>View: functions for graphical display of values in Eclipse, see
        <xref linkend="section.lib-View" />.</para>
      </listitem>

      <listitem>
        <para>Void: the type void, see</para>
      </listitem>
    </itemizedlist>

    <para>All operators are directly available for each program, but library
    functions have to be imported in each module that uses them.</para>

    <section xml:id="section.lib-Benchmark">
      <title xml:id="x">Benchmark</title>

      <para></para>

      <table>
        <title>Benchmark Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="2*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>real currentTimeMillis()</literal></entry>

              <entry>current time in milliseconds since January 1, 1970
              GMT.</entry>
            </row>

            <row>
              <entry>p.m. benchmark</entry>

              <entry>measure and report the execution time of
              name:void-closure pairs.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-Boolean">
      <title>Boolean</title>

      <table>
        <title>Boolean Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are
              identical<literal></literal></entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are not
              identical</entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are identical
              or <replaceable>bool</replaceable><subscript>1</subscript> is
              <literal>false</literal> and
              <replaceable>bool</replaceable><subscript>2</subscript> is
              <literal>true</literal></entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>bool</replaceable><subscript>1</subscript> is
              <literal>false</literal> and
              <replaceable>bool</replaceable><subscript>2</subscript> is
              <literal>true</literal></entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are identical
              or <replaceable>bool</replaceable><subscript>1</subscript> is
              <literal>true</literal> and
              <replaceable>bool</replaceable><subscript>2</subscript> is
              <literal>false</literal></entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>bool</replaceable><subscript>1</subscript> is
              <literal>true</literal> and
              <replaceable>bool</replaceable><subscript>2</subscript> is
              <literal>false</literal></entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>&amp;&amp;</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments have the
              value true and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>||</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if either argument has the
              value true and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>==&gt;</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>false</literal> if
              <replaceable>bool</replaceable><subscript>1</subscript> has the
              value <literal>true</literal> and
              <replaceable>bool</replaceable><subscript>2</subscript> has
              value <literal>false</literal>, and <literal>true</literal>
              otherwise</entry>
            </row>

            <row>
              <entry><literal>!</literal>
              <replaceable>bool</replaceable></entry>

              <entry>yields true if bool is false and true otherwise</entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript> ?
              <replaceable>bool</replaceable><subscript>2</subscript> :
              <replaceable>bool</replaceable><subscript>3</subscript></entry>

              <entry>if
              <replaceable>bool</replaceable><subscript>1</subscript> is true
              then <replaceable>bool</replaceable><subscript>2</subscript>
              else
              <replaceable>bool</replaceable><subscript>3</subscript></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Boolean Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="2*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>bool arbBool()</literal></entry>

              <entry>arbitrary boolean value</entry>
            </row>

            <row>
              <entry><literal>bool fromInt(int i)</literal></entry>

              <entry>convert an integer to a bool</entry>
            </row>

            <row>
              <entry><literal>bool fromString(str s)</literal></entry>

              <entry>convert the strings "true" or "false" to a bool</entry>
            </row>

            <row>
              <entry><literal>int toInt(bool b)</literal></entry>

              <entry>convert a boolean value to integer</entry>
            </row>

            <row>
              <entry><literal>real toReal(bool b)</literal></entry>

              <entry>convert a boolean value to a real value</entry>
            </row>

            <row>
              <entry><literal>str toString(bool b)</literal></entry>

              <entry>convert a boolean value to a string</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-Exception">
      <title>Exception</title>

      <para>The following "soft" exceptions are defined:<programlisting>data RuntimeException = 
      EmptyList
    | EmptyMap 
    | EmptySet
    | IndexOutOfBounds(int index)
    | AssertionFailed 
    | AssertionFailed(str label)
    | NoSuchElement(value v)
    | IllegalArgument(value v)
    | IllegalArgument
    | IO(str message)
    | FileNotFound(str filename)
    | LocationNotFound(loc location)
    | PermissionDenied
    | PermissionDenied(str message)
    | ModuleNotFound(str name)
    | NoSuchKey(value key)
    | NoSuchAnnotation(str label)
    | Java(str message)
    ;</programlisting></para>
    </section>

    <section xml:id="section.lib-Graph">
      <title>Graph</title>

      <para>The graph datatype is a special form of binary relation defined as
      follows:</para>

      <para><programlisting>alias graph[&amp;T] = rel[&amp;T from, &amp;T to];</programlisting></para>

      <table>
        <title>Graph Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="3*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>set[&amp;T] bottom(graph[&amp;T]
              G)</literal></entry>

              <entry>bottom nodes of a graph</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] top(graph[&amp;T]
              G)</literal></entry>

              <entry>top nodes of a graph</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reach(graph[&amp;T] G, set[&amp;T]
              Start)</literal></entry>

              <entry>Reachability from set of start nodes.</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reachR(graph[&amp;T] G, set[&amp;T]
              Start, set[&amp;T] Restr)</literal></entry>

              <entry>Reachability from set of start nodes with restriction to
              certain nodes.</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reachX(graph[&amp;T] G, set[&amp;T]
              Start, set[&amp;T] Excl)</literal></entry>

              <entry>Reachability from set of start nodes with exclusion of
              certain nodes</entry>
            </row>

            <row>
              <entry><literal>list[&amp;T] shortestPathPair(graph[&amp;T] G,
              &amp;T From, &amp;T To)</literal></entry>

              <entry>Shortest path between pair of nodes</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The following examples illustrate these functions:<screen><literal>rascal&gt; top({&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;, &lt;3,4&gt;});
</literal><literal>{1}
</literal><literal>rascal&gt; bottom({&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;, &lt;3,4&gt;})</literal>;
<literal>{4}
</literal><literal>rascal&gt; reachR({1}, {1, 2, 3}, {&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;, &lt;3,4&gt;})</literal>;
<literal>{2, 3}
</literal><literal>rascal&gt; reachX({1}, {2}, {&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;, &lt;3,4&gt;})</literal>;
<literal>{3, 4}</literal></screen></para>
    </section>

    <section xml:id="section.lib-Integer">
      <title>Integer</title>

      <para>Rascal integers are unbounded in size.</para>

      <table>
        <title>Integer Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are numerically
              equal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are numerically
              unequal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>int</replaceable><subscript>1</subscript> is
              numerically less than or equal to
              <replaceable>int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>int</replaceable><subscript>1</subscript> is
              numerically less than
              <replaceable>int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>int</replaceable><subscript>1</subscript> is
              numerically greater than or equal than
              <replaceable>int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>int</replaceable><subscript>1</subscript> is
              numerically greater than
              <replaceable>int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>sum of
              <replaceable>int</replaceable><subscript>1</subscript> and
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>-</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>difference of
              <replaceable>int</replaceable><subscript>1</subscript> and
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>*</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry><replaceable>int</replaceable><subscript>1</subscript>
              multiplied by
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>/</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry><replaceable>int</replaceable><subscript>1</subscript>
              divided by
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>%</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>remainder of dividing
              <replaceable>int</replaceable><subscript>1</subscript> by
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry>- <replaceable>int</replaceable></entry>

              <entry>negate sign of <replaceable>int</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable> ?
              <replaceable>int</replaceable><subscript>1</subscript> :
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>if <replaceable>bool</replaceable> is true then
              <replaceable>int</replaceable><subscript>1</subscript> else
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Integer Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="2*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>int abs(int N)</literal></entry>

              <entry>absolute value of integer N</entry>
            </row>

            <row>
              <entry><literal>int arbInt()</literal></entry>

              <entry>arbitrary integer value</entry>
            </row>

            <row>
              <entry><literal>int arbInt(int limit)</literal></entry>

              <entry>arbitrary integer value in the interval [0,
              limit)</entry>
            </row>

            <row>
              <entry><literal>int max(int n, int m)</literal></entry>

              <entry>largest of two integers</entry>
            </row>

            <row>
              <entry><literal>int min(int n, int m)</literal></entry>

              <entry>smallest of two integers</entry>
            </row>

            <row>
              <entry><literal>real toReal(int n)</literal></entry>

              <entry>convert an integer value to a real value</entry>
            </row>

            <row>
              <entry><literal>str toString(int n)</literal></entry>

              <entry>convert an integer value to a string</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-IO">
      <title>IO</title>

      <para><table>
          <title>IO Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>void java println(value
                V...)</literal></entry>

                <entry>print a list of values on the output stream</entry>
              </row>

              <row>
                <entry><literal>list[str] readFile(str filename) throws
                NoSuchFileError(str msg), IOError(str msg)</literal></entry>

                <entry>read a named file as list of strings</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-LabelledGraph">
      <title>Labelled Graph</title>

      <para>The labelled graph datatype is a special form of binary relation
      with labelled edges and is defined as follows:</para>

      <para><programlisting>alias lgraph[&amp;T,&amp;L] = rel[&amp;T from, &amp;L label, &amp;T to];</programlisting></para>

      <table>
        <title>Labelled Graph Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="4*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>set[&amp;T] bottom(lgraph[&amp;T]
              G)</literal></entry>

              <entry>bottom nodes of a labelled graph</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] top(lgraph[&amp;T]
              G)</literal></entry>

              <entry>top nodes of a labelled graph</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reach(lgraph[&amp;T] G, set[&amp;T]
              Start)</literal></entry>

              <entry>Reachability from set of start nodes.</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reachR(lgraph[&amp;T] G, set[&amp;T]
              Start, set[&amp;T] Restr)</literal></entry>

              <entry>Reachability from set of start nodes with restriction to
              certain nodes.</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reachX(lgraph[&amp;T] G, set[&amp;T]
              Start, set[&amp;T] Excl)</literal></entry>

              <entry>Reachability from set of start nodes with exclusion of
              certain nodes</entry>
            </row>

            <row>
              <entry><literal>list[&amp;T] shortestPathPair(lgraph[&amp;T] G,
              &amp;T From, &amp;T To)</literal></entry>

              <entry>Shortest path between pair of nodes</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><warning>
          <para>shortestPath not yet implemented for lgraph.</para>
        </warning></para>
    </section>

    <section xml:id="section.lib-List">
      <title>List</title>

      <para><table>
          <title>List Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>list</replaceable><subscript>1</subscript>
                <literal>==</literal>
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments have the same
                elements in the same order</entry>
              </row>

              <row>
                <entry><replaceable>list</replaceable><subscript>1</subscript>
                <literal>!=</literal>
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments have
                different elements</entry>
              </row>

              <row>
                <entry><replaceable>list</replaceable><subscript>1</subscript>
                <literal>&lt;=</literal>
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both lists are equal or
                <replaceable>list</replaceable><subscript>1</subscript> is a
                sublist of
                <replaceable>list</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>list</replaceable><subscript>1</subscript>
                <literal>&lt;</literal>
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if
                <replaceable>list</replaceable><subscript>1</subscript> is a
                sublist of
                <replaceable>list</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>list</replaceable><subscript>1</subscript>
                <literal>&gt;=</literal>
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both lists are equal or
                <replaceable>list</replaceable><subscript>2</subscript> is a
                sublist of
                <replaceable>list</replaceable><subscript>1</subscript></entry>
              </row>

              <row>
                <entry><replaceable>list</replaceable><subscript>1</subscript>
                <literal>&gt;</literal>
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if
                <replaceable>list</replaceable><subscript>2</subscript> is a
                sublist of
                <replaceable>list</replaceable><subscript>1</subscript></entry>
              </row>

              <row>
                <entry><replaceable>list</replaceable><subscript>1</subscript>
                <literal>+</literal>
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry>concatenation of
                <replaceable>list</replaceable><subscript>1</subscript> and
                <replaceable>list</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>list</replaceable><subscript>1</subscript>
                <literal>-</literal>
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry>list consisting of all elements in
                <replaceable>list</replaceable><subscript>1</subscript> that
                do not occur in
                <replaceable>list</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>list</replaceable><subscript>1</subscript>
                <literal>*</literal>
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>list</replaceable><subscript>1</subscript>
                multiplied by
                <replaceable>list</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>elm</replaceable> <literal>in</literal>
                <replaceable>list</replaceable></entry>

                <entry><literal>true</literal> if
                <replaceable>elm</replaceable> occurs as element in
                <replaceable>list</replaceable></entry>
              </row>

              <row>
                <entry><replaceable>elm</replaceable> <literal>notin</literal>
                <replaceable>list</replaceable></entry>

                <entry><literal>true</literal> if
                <replaceable>elm</replaceable> does not occur as element in
                <replaceable>list</replaceable></entry>
              </row>

              <row>
                <entry><replaceable>bool</replaceable> ?
                <replaceable>list</replaceable><subscript>1</subscript> :
                <replaceable>list</replaceable><subscript>2</subscript></entry>

                <entry>if <replaceable>bool</replaceable> is true then
                <replaceable>list</replaceable><subscript>1</subscript> else
                <replaceable>list</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>list</replaceable><literal> [</literal>
                <replaceable>int</replaceable> <literal>]</literal></entry>

                <entry>element at position <replaceable>int</replaceable> in
                <replaceable>list</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </table><table>
          <title>List Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>&amp;T average(list[&amp;T] lst, &amp;T
                zero)</literal></entry>

                <entry>average of elements of a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] delete(list[&amp;T] lst, int
                n)</literal></entry>

                <entry>delete nth element from list</entry>
              </row>

              <row>
                <entry><literal>list[int] domain(list[&amp;T]
                lst)</literal></entry>

                <entry>a list of all legal index values for a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T java head(list[&amp;T] lst) throws
                EmptyListError</literal></entry>

                <entry>get the first element of a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] head(list[&amp;T] lst, int n)
                throws IndexOutOfBoundsError</literal></entry>

                <entry>get the first n elements of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T getOneFrom(list[&amp;T]
                lst)</literal></entry>

                <entry>get an arbitrary element from a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] insertAt(list[&amp;T] lst, int n,
                &amp;T elm) throws IndexOutOfBoundsError</literal></entry>

                <entry>add an element at a specific position in a list</entry>
              </row>

              <row>
                <entry><literal>bool isEmpty(list[&amp;T]
                lst)</literal></entry>

                <entry>is list empty?</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] mapper(list[&amp;T] lst, &amp;T
                (&amp;T) fn)</literal></entry>

                <entry>apply a function to each element of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T max(list[&amp;T] lst)</literal></entry>

                <entry>largest element of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T min(list[&amp;T] lst)</literal></entry>

                <entry>smallest element of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T multiply(list[&amp;T] lst, &amp;T
                unity)</literal></entry>

                <entry>multiply the elements of a list</entry>
              </row>

              <row>
                <entry><literal>list[list[&amp;T]] permutations(list[&amp;T]
                lst)</literal></entry>

                <entry>all permutations of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T reducer(list[&amp;T] lst, &amp;T
                (&amp;T, &amp;T) fn, &amp;T unit)</literal></entry>

                <entry>apply function F to successive elements of a
                list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] reverse(list[&amp;T]
                lst)</literal></entry>

                <entry>elements of a list in reverse order</entry>
              </row>

              <row>
                <entry><literal>int size(list[&amp;T] lst)</literal></entry>

                <entry>number of elements in a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] slice(list[&amp;T] lst, int
                start, int len)</literal></entry>

                <entry>sublist from start of length len</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] sort(list[&amp;T]
                lst)</literal></entry>

                <entry>sort the elements of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T sum(list[&amp;T] lst, &amp;T
                zero)</literal></entry>

                <entry>add elements of a List</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] tail(list[&amp;T]
                lst)</literal></entry>

                <entry>all but the first element of a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] tail(list[&amp;T] lst, int len)
                throws IndexOutOfBoundsError</literal></entry>

                <entry>last n elements of a list</entry>
              </row>

              <row>
                <entry><literal>tuple[&amp;T, list[&amp;T]]
                takeOneFrom(list[&amp;T] lst)</literal></entry>

                <entry>remove an arbitrary element from a list, returns the
                element and the modified list</entry>
              </row>

              <row>
                <entry><literal>map[&amp;A,&amp;B] toMap(list[tuple[&amp;A,
                &amp;B]] lst)</literal></entry>

                <entry>convert a list of tuples to a map</entry>
              </row>

              <row>
                <entry><literal>set[&amp;T] toSet(list[&amp;T]
                lst)</literal></entry>

                <entry>convert a list to a set</entry>
              </row>

              <row>
                <entry><literal>str toString(list[&amp;T]
                lst)</literal></entry>

                <entry>convert a list to a string</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Location">
      <title>Location</title>

      <table>
        <title>Operations on Locations</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are identical
              and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are not
              identical and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>loc</replaceable><subscript>1</subscript> is
              textually contained in or equal to
              <replaceable>loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>loc</replaceable><subscript>1</subscript> is
              strictly textually contained in
              <replaceable>loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>loc</replaceable><subscript>1</subscript> is
              textually encloses or is equal to
              <replaceable>loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>loc</replaceable><subscript>1</subscript> is
              textually encloses
              <replaceable>loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable> <literal>.</literal>
              <replaceable>field</replaceable></entry>

              <entry>retrieve one of the fields of location value</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The field names for locations are:</para>

      <itemizedlist>
        <listitem>
          <para><literal>url</literal></para>
        </listitem>

        <listitem>
          <para><literal>offset</literal></para>
        </listitem>

        <listitem>
          <para><literal>length</literal></para>
        </listitem>

        <listitem>
          <para><literal>beginLine</literal>,
          <literal>beginColumn</literal></para>
        </listitem>

        <listitem>
          <para><literal>endLine</literal>,
          <literal>endColumn</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.lib-Map">
      <title>Map</title>

      <para><table>
          <title>Map Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>map</replaceable><subscript>1</subscript>
                <literal>==</literal>
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments consist of
                the same pairs</entry>
              </row>

              <row>
                <entry><replaceable>map</replaceable><subscript>1</subscript>
                <literal>!=</literal>
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments have
                different pairs</entry>
              </row>

              <row>
                <entry><replaceable>map</replaceable><subscript>1</subscript>
                <literal>&lt;=</literal>
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if all pairs in
                <replaceable>map</replaceable><subscript>1</subscript> occur
                in <replaceable>map</replaceable><subscript>2</subscript> or
                <replaceable>map</replaceable><subscript>1</subscript> and
                <replaceable>map</replaceable><subscript>2</subscript> are
                equal</entry>
              </row>

              <row>
                <entry><replaceable>map</replaceable><subscript>1</subscript>
                <literal>&lt;</literal>
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if all pairs in
                <replaceable>map</replaceable><subscript>1</subscript> occur
                in <replaceable>map</replaceable><subscript>2</subscript> but
                <replaceable>map</replaceable><subscript>1</subscript> and
                <replaceable>map</replaceable><subscript>2</subscript> are not
                equal</entry>
              </row>

              <row>
                <entry><replaceable>map</replaceable><subscript>1</subscript>
                <literal>&gt;=</literal>
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if all pairs in
                <replaceable>map</replaceable><subscript>2</subscript> occur
                in <replaceable>map</replaceable><subscript>1</subscript> or
                <replaceable>map</replaceable><subscript>1</subscript> and
                <replaceable>map</replaceable><subscript>2</subscript> are
                equal</entry>
              </row>

              <row>
                <entry><replaceable>map</replaceable><subscript>1</subscript>
                <literal>&gt;</literal>
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if all pairs in
                <replaceable>map</replaceable><subscript>2</subscript> occur
                in <replaceable>map</replaceable><subscript>1</subscript>but
                <replaceable>map</replaceable><subscript>1</subscript> and
                <replaceable>map</replaceable><subscript>2</subscript> are not
                equal</entry>
              </row>

              <row>
                <entry><replaceable>map</replaceable><subscript>1</subscript>
                <literal>+</literal>
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry>union of
                <replaceable>map</replaceable><subscript>1</subscript> and
                <replaceable>map</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>map</replaceable><subscript>1</subscript>
                <literal>-</literal>
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry>difference of
                <replaceable>map</replaceable><subscript>1</subscript> and
                <replaceable>map</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>key</replaceable> <literal>in</literal>
                <replaceable>map</replaceable></entry>

                <entry>true if <replaceable>key</replaceable> occurs in a
                key:value pair in map</entry>
              </row>

              <row>
                <entry><replaceable>key</replaceable><subscript>1</subscript>
                <literal>notin</literal>
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry>true if <replaceable>key</replaceable> does not occur
                in a key:value pair in map</entry>
              </row>

              <row>
                <entry><replaceable>bool</replaceable> ?
                <replaceable>map</replaceable><subscript>1</subscript> :
                <replaceable>map</replaceable><subscript>2</subscript></entry>

                <entry>if <replaceable>bool</replaceable> is true then
                <replaceable>map</replaceable><subscript>1</subscript> else
                <replaceable>map</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>map</replaceable> <literal>[</literal>
                <replaceable>key</replaceable> <literal>]</literal></entry>

                <entry>the value associated with
                <replaceable>key</replaceable> in
                <replaceable>map</replaceable> if that exists, undefined
                otherwise</entry>
              </row>
            </tbody>
          </tgroup>
        </table><table>
          <title>Map Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>set[&amp;K] domain(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>the domain (keys) of a map</entry>
              </row>

              <row>
                <entry><literal>&amp;K getOneFrom(map[&amp;K, &amp;V] M)
                </literal></entry>

                <entry>arbitrary key of a map</entry>
              </row>

              <row>
                <entry><literal>map[&amp;V, &amp;K] invert(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>map with key and value inverted</entry>
              </row>

              <row>
                <entry><literal>bool isEmpty(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>is map empty?</entry>
              </row>

              <row>
                <entry><literal>map[&amp;K, &amp;V] mapper(map[&amp;K, &amp;V]
                M, &amp;K (&amp;K) F, &amp;V (&amp;V) G)</literal></entry>

                <entry>apply two functions to each key/value pair in a
                map.</entry>
              </row>

              <row>
                <entry><literal>set[&amp;V] range(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>the range (values) of a map</entry>
              </row>

              <row>
                <entry><literal>int size(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>number of elements in a map.</entry>
              </row>

              <row>
                <entry><literal>list[tuple[&amp;K, &amp;V]] toList(map[&amp;K,
                &amp;V] M)</literal></entry>

                <entry>convert a map to a list</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;K, &amp;V] toRel(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>convert a map to a relation</entry>
              </row>

              <row>
                <entry><literal>str toString(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>convert a map to a string.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Node">
      <title>Node</title>

      <para><table>
          <title>Node Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>node</replaceable><subscript>1</subscript>
                <literal>==</literal>
                <replaceable>node</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments are
                identical</entry>
              </row>

              <row>
                <entry><replaceable>node</replaceable><subscript>1</subscript>
                <literal>!=</literal>
                <replaceable>node</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments are not
                identical</entry>
              </row>

              <row>
                <entry><replaceable>node</replaceable><subscript>1</subscript>
                <literal>&lt;=</literal>
                <replaceable>node</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>node</replaceable><subscript>1</subscript>
                <literal>&lt;</literal>
                <replaceable>node</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>node</replaceable><subscript>1</subscript>
                <literal>&gt;=</literal>
                <replaceable>node</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>node</replaceable><subscript>1</subscript>
                <literal>&gt;</literal>
                <replaceable>node</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>bool</replaceable> ?
                <replaceable>node</replaceable><subscript>1</subscript> :
                <replaceable>node</replaceable><subscript>2</subscript></entry>

                <entry>if <replaceable>bool</replaceable> is true then
                <replaceable>node</replaceable><subscript>1</subscript> else
                <replaceable>node</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>node</replaceable> <literal>[</literal>
                <replaceable>int</replaceable> <literal>]</literal></entry>

                <entry>child of <replaceable>node</replaceable> at position
                <replaceable>int</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </table><table>
          <title>Node Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>int arity(node T)</literal></entry>

                <entry>number of children of a node</entry>
              </row>

              <row>
                <entry><literal>list[value] getChildren(node
                T)</literal></entry>

                <entry>get the children of a node</entry>
              </row>

              <row>
                <entry><literal>str getName(node T)</literal></entry>

                <entry>get the function name of a node</entry>
              </row>

              <row>
                <entry><literal>node makeNode(str N, value
                V...)</literal></entry>

                <entry>create a node given its function name and
                arguments</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Real">
      <title>Real</title>

      <table>
        <title>Real Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are numerically
              equal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are numerically
              unequal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>real</replaceable><subscript>1</subscript> is
              numerically less than or equal to
              <replaceable>real</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>real</replaceable><subscript>1</subscript> is
              numerically less than
              <replaceable>real</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>real</replaceable><subscript>1</subscript> is
              numerically greater than or equal than
              <replaceable>real</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>real</replaceable><subscript>1</subscript> is
              numerically greater than
              <replaceable>real</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry>sum of
              <replaceable>real</replaceable><subscript>1</subscript> and
              <replaceable>real</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>-</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry>difference of
              <replaceable>real</replaceable><subscript>1</subscript> and
              <replaceable>real</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>*</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry><replaceable>real</replaceable><subscript>1</subscript>
              multiplied by
              <replaceable>real</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>/</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry><replaceable>real</replaceable><subscript>1</subscript>
              divided by
              <replaceable>real</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry>- <replaceable>real</replaceable></entry>

              <entry>negate sign of <replaceable>real</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>real</replaceable><subscript>1</subscript>
              <literal>%</literal>
              <replaceable>real</replaceable><subscript>2</subscript></entry>

              <entry>remainder of dividing
              <replaceable>real</replaceable><subscript>1</subscript> by
              <replaceable>real</replaceable><subscript>2</subscript></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Real Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="2*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>real arbReal()</literal></entry>

              <entry>an arbitrary real value in the interval
              [0.0,1.0).</entry>
            </row>

            <row>
              <entry><literal>real max(real n, real m)</literal></entry>

              <entry>largest of two reals</entry>
            </row>

            <row>
              <entry><literal>int toInteger(real d)</literal></entry>

              <entry>convert a real to integer.</entry>
            </row>

            <row>
              <entry><literal>str toString(real d)</literal></entry>

              <entry>convert a real to a string.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-Relation">
      <title>Relation</title>

      <para>Relation are sets of tuples, therefore all set operators (see,
      <xref linkend="table.set-operators" />) apply to relations as
      well</para>

      <table>
        <title>Operations on Relations</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>rel</replaceable><subscript>1</subscript>
              <literal>o</literal>
              <replaceable>rel</replaceable><subscript>2</subscript></entry>

              <entry>yields the relation resulting from the composition of the
              two arguments</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>x</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry>yields the relation resulting from the Cartesian product
              of the two arguments</entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable>
              <literal>+</literal></entry>

              <entry>yields the relation resulting from the transitive closure
              of <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable>
              <literal>*</literal></entry>

              <entry>yields the relation resulting from the reflexive
              transitive closure of <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable> <literal>[</literal>
              <replaceable>elem</replaceable> <literal>]</literal></entry>

              <entry>yields the right image of
              <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable> <literal>[</literal>
              <replaceable>set</replaceable> <literal>]</literal></entry>

              <entry>yields the right image of
              <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable> <literal>&lt;</literal>
              <replaceable>index</replaceable><subscript>1</subscript><literal>,</literal>
              <replaceable>index</replaceable><subscript>2</subscript>, ...
              <literal>&gt;</literal></entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Examples:</para>

      <para><screen><literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,15&gt;} o {&lt;10,100&gt;, &lt;20,200&gt;}</literal> yields <literal>{&lt;1,100&gt;, &lt;2,200&gt;}</literal>.


<literal>{1, 2, 3} x {9}</literal> yields <literal>{&lt;1, 9&gt;, &lt;2, 9&gt;, &lt;3, 9&gt;}</literal>.



<literal>Rel</literal> has value <literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;1,11&gt;, &lt;3,30&gt;, &lt;2,21&gt;}</literal> in the following examples.

<literal>Rel[1]</literal> yields <literal>{10, 11}</literal>.

<literal>Rel[{1}]</literal> yields {10, 11}.

<literal>Rel[{1, 2}]</literal> yields <literal>{10, 11, 20, 21}</literal>.</screen><table>
          <title>Relation Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>set[&amp;T] carrier (rel[&amp;T,&amp;T]
                R)</literal></entry>

                <entry>all elements in any tuple in a relation</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T,&amp;T] carrierR
                (rel[&amp;T,&amp;T] R, set[&amp;T] S)</literal></entry>

                <entry>relation restricted to tuples with elements in a set
                S</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T,&amp;T] carrierX
                (rel[&amp;T,&amp;T] R, set[&amp;T] S)</literal></entry>

                <entry>relation excluded tuples with some element in S</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T0, &amp;T1] complement(rel[&amp;T0,
                &amp;T1] R)</literal></entry>

                <entry>complement of relation</entry>
              </row>

              <row>
                <entry><literal>set[&amp;T0] domain (rel[&amp;T0,&amp;T1]
                R)</literal></entry>

                <entry>first element of each tuple in binary relation</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T0,&amp;T1] domainR
                (rel[&amp;T0,&amp;T1] R, set[&amp;T0] S)</literal></entry>

                <entry>restriction of a relation to tuples with first element
                in S}</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T0,&amp;T1] domainX
                (rel[&amp;T0,&amp;T1] R, set[&amp;T0] S)</literal></entry>

                <entry>relation excluded tuples with first element in
                S</entry>
              </row>

              <row>
                <entry>ident?</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T1, &amp;T0] invert (rel[&amp;T0,
                &amp;T1] R)</literal></entry>

                <entry>inverse the tuples in a relation</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T2, &amp;T1, &amp;T0] invert
                (rel[&amp;T0, &amp;T1, &amp;T2] R)</literal></entry>

                <entry>all but the first element of each tuples in binary
                relation</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T0,&amp;T1] rangeR
                (rel[&amp;T0,&amp;T1] R, set[&amp;T2] S)</literal></entry>

                <entry>restriction of a binary relation to tuples with second
                element in set S</entry>
              </row>
            </tbody>
          </tgroup>
        </table>Examples:<screen><literal>id({1,2,3})</literal> yields <literal>{&lt;1,1&gt;, &lt;2,2&gt;, &lt;3,3&gt;}</literal>.

<literal>id({"mon", "tue", "wed"})</literal> yields <literal>{&lt;"mon","mon"&gt;, &lt;"tue","tue"&gt;, &lt;"wed","wed"&gt;}</literal>.
<literal>inv({&lt;1,10&gt;, &lt;2,20&gt;})</literal> yields <literal>{&lt;10,1&gt;,&lt;20,2&gt;}</literal>.

<literal>compl({&lt;1,10&gt;}</literal> yields <literal>{&lt;1, 1&gt;, &lt;10, 1&gt;, &lt;10, 10&gt;}</literal>.

<literal>domain({&lt;1,10&gt;, &lt;2,20&gt;})</literal> yields <literal>{1, 2}</literal>.

<literal>domain({&lt;"mon", 1&gt;, &lt;"tue", 2&gt;})</literal> yields <literal>{"mon", "tue"}</literal>.

<literal>range({&lt;1,10&gt;, &lt;2,20&gt;})</literal> yields <literal>{10, 20}</literal>.

<literal>range({&lt;"mon", 1&gt;, &lt;"tue", 2&gt;})</literal> yields <literal>{1, 2}</literal>.

<literal>carrier({&lt;1,10&gt;, &lt;2,20&gt;})</literal> yields <literal>{1, 10, 2, 20}

domainR({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {3, 1});
</literal><literal>{&lt;1,10&gt;, &lt;3,30&gt;}</literal>.


<literal>rangeR({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {30, 10})</literal> yields <literal>{&lt;1,10&gt;, &lt;3,30&gt;}</literal>.

<literal>carrierR({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {10, 1, 20})</literal> yields <literal>{&lt;1,10&gt;}</literal>.

<literal>domainX({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {3, 1})</literal> yields <literal>{&lt;2, 20&gt;}</literal>.
<literal>rangeX({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {30, 10})</literal> yields <literal>{&lt;2, 20&gt;}</literal>.

<literal>carrierX({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {10, 1, 20})</literal> yields <literal>{&lt;3,30&gt;}</literal>.</screen></para>
    </section>

    <section xml:id="section.lib-RSF">
      <title>RSF</title>

      <table>
        <title>RSF Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="3*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>map[str, rel[str,str]] readRSF(str
              nameRSFFile)</literal></entry>

              <entry>read a file in Rigi Standard Format (RSF).</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-Resource">
      <title>Resource (Eclipse only)</title>

      <para><programlisting>data Resource = root(set[Resource] projects) 
              | project(str name, set[Resource] contents) 
              | folder(str name, set[Resource] contents) 
              | file(str name, str extension); </programlisting></para>

      <para><table>
          <title>Resource Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>Resource java root() </literal></entry>

                <entry>The root of the Eclipse workspace</entry>
              </row>

              <row>
                <entry><literal>set[str] java projects()</literal></entry>

                <entry>The projects in the Eclipse workspace</entry>
              </row>

              <row>
                <entry><literal>set[str] java references(str
                project)</literal></entry>

                <entry>The project references of a given project</entry>
              </row>

              <row>
                <entry><literal>loc java location(str
                project)</literal></entry>

                <entry>Source location of given project</entry>
              </row>

              <row>
                <entry><literal>set[loc] java files(str
                project)</literal></entry>

                <entry>The files contained in a project</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Set">
      <title>Set</title>

      <para></para>

      <table xml:id="table.set-operators">
        <title>Set Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are equal sets
              and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are unequal
              sets and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>set</replaceable><subscript>1</subscript> is a
              subset of <replaceable>set</replaceable><subscript>2</subscript>
              and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>set</replaceable><subscript>1</subscript> is a
              strict subset of
              <replaceable>set</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>set</replaceable><subscript>1</subscript> is a
              superset of
              <replaceable>set</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>set</replaceable><subscript>1</subscript> is a
              strict superset of
              <replaceable>set</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry>set resulting from the union of the two arguments</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>-</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry>the set resulting from the difference of the two
              arguments</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>*</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry>set resulting from the product of the two
              arguments</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>&amp;</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry>set resulting from the intersection of the two
              arguments</entry>
            </row>

            <row>
              <entry><replaceable>elm</replaceable> <literal>in</literal>
              <replaceable>set</replaceable></entry>

              <entry><literal>true</literal> if <replaceable>elm</replaceable>
              occurs as element in <replaceable>set</replaceable> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>elm</replaceable> <literal>notin</literal>
              <replaceable>set</replaceable></entry>

              <entry><literal>false</literal> if
              <replaceable>elm</replaceable> occurs as element in
              <replaceable>set</replaceable> and <literal>false</literal>
              otherwise</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable> <literal>join</literal>
              <replaceable>set</replaceable></entry>

              <entry></entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable> <literal>?</literal>
              <replaceable>set</replaceable><subscript>1</subscript>
              <literal>:</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Examples:</para>

      <screen>rascal&gt; <literal>{1, 2, 3} + {4, 5, 6}</literal>;
<literal>{1, 2, 3, 4, 5, 6}</literal>

rascal&gt; <literal>{1, 2, 3} + {1, 2, 3}</literal><literal>;
{1, 2, 3}</literal>

rascal&gt; <literal>{1, 2, 3, 4} - {1, 2, 3}</literal><literal>;
{4}</literal>

rascal&gt; <literal>{1, 2, 3} - {4, 5, 6}</literal><literal>;
{1, 2, 3}</literal>

rascal&gt; <literal>{1, 2, 3} &amp; {4, 5, 6};
</literal><literal>{ }</literal>

rascal&gt; <literal>{1, 2, 3} &amp; {1, 2, 3};
</literal><literal>{1, 2, 3}</literal>

rascal&gt; <literal>3 in {1, 2, 3}</literal><literal>;
true</literal>

rascal&gt; 4 in {1, 2, 3}<literal>;
false</literal>

rascal&gt; <literal>3 notin {1, 2, 3};
</literal><literal>false</literal>

racsal&gt; <literal>4 notin {1, 2, 3};
</literal><literal>true</literal>

rascal&gt; <literal>&lt;2,20&gt; in {&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;};
</literal><literal>true</literal>

rascal&gt; <literal>&lt;4,40&gt; notin {&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;};
</literal><literal>true</literal>
</screen>

      <table>
        <title>Set Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="3*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>&amp;T average(set[&amp;T] st, &amp;T
              zero)</literal></entry>

              <entry>average of the elements of a set</entry>
            </row>

            <row>
              <entry><literal>&amp;T getOneFrom(set[&amp;T]
              st)</literal></entry>

              <entry>pick a random element from a set</entry>
            </row>

            <row>
              <entry><literal>bool isEmpty(set[&amp;T] st)</literal></entry>

              <entry>Is set empty?</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] mapper(set[&amp;T] st, &amp;T
              (&amp;T,&amp;T) fn)</literal></entry>

              <entry>apply a function to each element of a setacter</entry>
            </row>

            <row>
              <entry><literal>&amp;T max(set[&amp;T] st)</literal></entry>

              <entry>largest element of a set</entry>
            </row>

            <row>
              <entry><literal>&amp;T min(set[&amp;T] st)</literal></entry>

              <entry>smallest element of a set</entry>
            </row>

            <row>
              <entry><literal>&amp;T multiply(set[&amp;T] st, &amp;T
              unity)</literal></entry>

              <entry>multiply the elements of a set</entry>
            </row>

            <row>
              <entry><literal>set[set[&amp;T]] power(set[&amp;T]
              st)</literal></entry>

              <entry>all subsets of a set</entry>
            </row>

            <row>
              <entry><literal>set[set[&amp;T]] power1(set[&amp;T]
              st)</literal></entry>

              <entry>all subsets (excluding empty set) of a set</entry>
            </row>

            <row>
              <entry><literal>&amp;T reducer(set[&amp;T] st, &amp;T
              (&amp;T,&amp;T) fn, &amp;T unit)</literal></entry>

              <entry>apply function F to successive elements of a set</entry>
            </row>

            <row>
              <entry><literal>int size(set[&amp;T] st)</literal></entry>

              <entry>number of elements in a set</entry>
            </row>

            <row>
              <entry><literal>&amp;T sum(set[&amp;T] st, &amp;T
              zero)</literal></entry>

              <entry>add the elements of a set</entry>
            </row>

            <row>
              <entry><literal>tuple[&amp;T, set[&amp;T]]
              takeOneFrom(set[&amp;T] st)</literal></entry>

              <entry>remove an arbitrary element from a set, returns the
              element and the modified set</entry>
            </row>

            <row>
              <entry><literal>list[&amp;T] toList(set[&amp;T]
              st)</literal></entry>

              <entry>convert a set to a list</entry>
            </row>

            <row>
              <entry><literal>map[&amp;A,&amp;B] toMap(rel[&amp;A, &amp;B]
              st)</literal></entry>

              <entry>convert a set of tuples to a map</entry>
            </row>

            <row>
              <entry><literal>str toString(set[&amp;T] st)</literal></entry>

              <entry>convert a set to a string</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Examples:</para>

      <screen><literal>rascal&gt; power({1, 2, 3, 4})</literal>;
{ {}, {1}, {2}, {3}, {4},{1,2}, {1,3}, {1,4}, {2,3}, {2,4}, 
  {3,4}, {1,2,3}, {1,2,4}, {1,3,4}, {2,3,4}, {1,2,3,4}
}

rascal&gt; <literal>power1({1, 2, 3, 4})</literal>;
{ {1}, {2}, {3}, {4},{1,2}, {1,3}, {1,4}, {2,3}, {2,4}, 
  {3,4}, {1,2,3}, {1,2,4}, {1,3,4}, {2,3,4}, {1,2,3,4}
}

rascal&gt; size({1,2,3});
3

rascal&gt; <literal>size({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;});
3</literal></screen>
    </section>

    <section xml:id="section.lib-String">
      <title>String</title>

      <table>
        <title>Operations on Strings</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments are
              equal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments are
              unequal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>str</replaceable><subscript>1</subscript> is
              lexicographically less than or equal to
              <replaceable>str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>str</replaceable><subscript>1</subscript> is
              lexicographically less than
              <replaceable>str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>str</replaceable><subscript>1</subscript> is
              lexicographically greater than or equal to
              <replaceable>str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>str</replaceable><subscript>1</subscript> is
              lexicographically greater than
              <replaceable>str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>concatenates
              <replaceable>str</replaceable><subscript>1</subscript> and
              <replaceable>str</replaceable><subscript>2</subscript></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><table>
          <title>String Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>int charAt(str s, int i) throws
                out_of_range(str msg)</literal></entry>

                <entry>character at position i in string s.</entry>
              </row>

              <row>
                <entry><literal>bool endsWith(str s, str
                suffix)</literal></entry>

                <entry>true if string s ends with given string suffix.</entry>
              </row>

              <row>
                <entry><literal>str center(str s, int n)</literal></entry>

                <entry>center s in string of length n using spaces</entry>
              </row>

              <row>
                <entry><literal>str center(str s, int n, str
                pad)</literal></entry>

                <entry>center s in string of length n using a pad
                character</entry>
              </row>

              <row>
                <entry><literal>bool isEmpty(str s)</literal></entry>

                <entry>is string empty?</entry>
              </row>

              <row>
                <entry><literal>str left(str s, int n)</literal></entry>

                <entry>left align s in string of length n using spaces</entry>
              </row>

              <row>
                <entry><literal>str left(str s, int n, str
                pad)</literal></entry>

                <entry>left align s in string of length n using pad
                character</entry>
              </row>

              <row>
                <entry><literal>str right(str s, int n)</literal></entry>

                <entry>right align s in string of length n using
                spaces</entry>
              </row>

              <row>
                <entry><literal>str reverse(str s)</literal></entry>

                <entry>string with all characters in reverse order.</entry>
              </row>

              <row>
                <entry><literal>int size(str s)</literal></entry>

                <entry>the length of string s.</entry>
              </row>

              <row>
                <entry><literal>bool startsWith(str s, str
                prefix)</literal></entry>

                <entry>true if string s starts with the string prefix.</entry>
              </row>

              <row>
                <entry><literal>str toLowerCase(str s)</literal></entry>

                <entry>convert all characters in string s to
                lowercase.</entry>
              </row>

              <row>
                <entry><literal>str toUpperCase(str s)</literal></entry>

                <entry>convert all characters in string s to
                uppercase.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Tuple">
      <title>Tuple</title>

      <table>
        <title>Tuple Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>tuple</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are
              identical</entry>
            </row>

            <row>
              <entry><replaceable>tuple</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are not
              identical</entry>
            </row>

            <row>
              <entry><replaceable>tuple</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are identical
              or if the leftmost element in
              <replaceable>tuple</replaceable><subscript>1</subscript> that
              differs from the corresponding in
              <replaceable>tuple</replaceable><subscript>2</subscript> is
              smaller than that element in
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>tuple</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are not
              identical and the leftmost element in
              <replaceable>tuple</replaceable><subscript>1</subscript> that
              differs from the corresponding in
              <replaceable>tuple</replaceable><subscript>2</subscript> is
              smaller than that element in
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>tuple</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are identical
              or if the leftmost element in
              <replaceable>tuple</replaceable><subscript>1</subscript> that
              differs from the corresponding in
              <replaceable>tuple</replaceable><subscript>2</subscript> is
              greater than that element in
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>tuple</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are not
              identical and the leftmost element in
              <replaceable>tuple</replaceable><subscript>1</subscript> that
              differs from the corresponding in
              <replaceable>tuple</replaceable><subscript>2</subscript> is
              greater than that element in
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>tuple</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>

              <entry>concatenates
              <replaceable>tuple</replaceable><subscript>1</subscript> and
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable> ?
              <replaceable>tuple</replaceable><subscript>1</subscript> :
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>

              <entry>if <replaceable>bool</replaceable> is true then
              <replaceable>tuple</replaceable><subscript>1</subscript> else
              <replaceable>tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>tuple</replaceable> <literal>.</literal>
              name</entry>

              <entry>select field <replaceable>name</replaceable> from
              <replaceable>tuple</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>tuple</replaceable> <literal>[</literal>
              <replaceable>int</replaceable> <literal>]</literal></entry>

              <entry>select field at position <replaceable>int</replaceable>
              from <replaceable>tuple</replaceable></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-UnitTest">
      <title>UnitTest</title>

      <para>We provided a very rudimentary library for unit testing that will
      certainly evolve over time:</para>

      <table>
        <title>UnitTest Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="4*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>void assertTrue(bool outcome)</literal></entry>

              <entry>check that outcome is true</entry>
            </row>

            <row>
              <entry><literal>void assertEqual(value V1, value
              V2)</literal></entry>

              <entry>check that two values are equal</entry>
            </row>

            <row>
              <entry><literal>bool report()</literal></entry>

              <entry>print unit test summary</entry>
            </row>

            <row>
              <entry><literal>bool report(str msg)</literal></entry>

              <entry>print unit test summary, including msg</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Value</title>

      <para><table>
          <title>Value Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>value</replaceable><subscript>1</subscript>
                <literal>==</literal>
                <replaceable>value</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments are
                identical</entry>
              </row>

              <row>
                <entry><replaceable>value</replaceable><subscript>1</subscript>
                <literal>!=</literal>
                <replaceable>value</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments are not
                identical</entry>
              </row>

              <row>
                <entry><replaceable>value</replaceable><subscript>1</subscript>
                <literal>&lt;=</literal>
                <replaceable>value</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>value</replaceable><subscript>1</subscript>
                <literal>&lt;</literal>
                <replaceable>value</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>value</replaceable><subscript>1</subscript>
                <literal>&gt;=</literal>
                <replaceable>value</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>value</replaceable><subscript>1</subscript>
                <literal>&gt;</literal>
                <replaceable>value</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>bool</replaceable> ?
                <replaceable>value</replaceable><subscript>1</subscript> :
                <replaceable>value</replaceable><subscript>2</subscript></entry>

                <entry>if <replaceable>bool</replaceable> is true then
                <replaceable>value</replaceable><subscript>1</subscript> else
                <replaceable>value</replaceable><subscript>2</subscript></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-ValueIO">
      <title>ValueIO</title>

      <para><table>
          <title>ValueIO Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>value readValueFromBinaryFile(str
                namePBFFile)</literal></entry>

                <entry>read a value from a binary file in PBF format</entry>
              </row>

              <row>
                <entry><literal>value readValueFromTextFile(str
                namePBFFile)</literal></entry>

                <entry>read a value from a text file</entry>
              </row>

              <row>
                <entry><literal>void writeValueToBinaryFile(str namePBFFile,
                value val)</literal></entry>

                <entry>write a value to a binary file in PBF format</entry>
              </row>

              <row>
                <entry><literal>void writeValueToTextFile(str namePBFFile,
                value val)</literal></entry>

                <entry>write a value to a binary file in PBF format</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-View">
      <title>View (Eclipse only)</title>

      <table>
        <title>View Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="3*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>void show(value v)</literal></entry>

              <entry>Show value v in a graphical viewer</entry>
            </row>

            <row>
              <entry><literal>void browse(value v) </literal></entry>

              <entry>Show value v a graphical browser</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Void</title>

      <para>There are no operators or functions defined on the type
      <literal>void</literal>.</para>
    </section>
  </section>

  <section xml:id="section-extracting-facts">
    <title>Extracting Facts from Source Code (TODO)</title>

    <para>In this tutorial we have, so far, concentrated on querying and
    enriching facts that have been extracted from source code. As we have seen
    from the examples, once these facts are available, a concise Rascal
    program suffices to do the required processing. But how is fact extraction
    achieved and how difficult is it? To answer these questions we first
    describe the workflow of the fact extraction process (<xref
    linkend="section.workflow-fact-extraction" />) and give strategies for
    fact extraction (<xref
    linkend="section.strategies-fact-extraction" />).</para>

    <para><figure xml:id="figure.extract-workflow">
        <title>Workflow for fact extraction</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="extract-workflow.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure></para>

    <section xml:id="section.workflow-fact-extraction">
      <title>Workflow for Fact Extraction</title>

      <para><xref linkend="figure.extract-workflow" /> shows a typical
      workflow for fact extraction for a <emphasis>System Under
      Investigation</emphasis> (SUI). It assumes that the SUI uses only
      <emphasis>one</emphasis> programming language and that you need only one
      grammar. In realistic cases, however, several such grammars may be
      needed. The workflow consists of three main phases:</para>

      <itemizedlist>
        <listitem>
          <para>Grammar: Obtain and improve the grammar for the source
          language of the SUI.</para>
        </listitem>

        <listitem>
          <para>Facts: Obtain and improve facts extracted from the SUI.</para>
        </listitem>

        <listitem>
          <para>Queries: Write and improve queries that give the desired
          answers.</para>
        </listitem>
      </itemizedlist>

      <para>Of course, it may happen that you have a lucky day and that
      extracted facts are readily available or that you can reuse a good
      quality fact extractor that you can apply to the SUI. On ordinary days
      you have the above workflow as fall-back. It may come as a surprise that
      there is such a strong emphasis on validation in this workflow. The
      reason is that the SUI is usually a huge system that defeats manual
      inspection. Therefore we must be very careful that we validate the
      outcome of each phase.</para>

      <formalpara>
        <title>Grammar</title>

        <para>In many cases there is no canned grammar available that can be
        used to parse the programming language dialect used in the SUI.
        Usually an existing grammar can be adjusted to that dialect, but then
        it is then mandatory to validate that the adjusted grammar can be used
        to parse the sources of the SUI.</para>
      </formalpara>

      <formalpara>
        <title>Facts</title>

        <para>It may happen that the facts extracted from the source code are
        <emphasis>wrong</emphasis>. Typical error classes are:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para>Extracted facts are <emphasis>wrong</emphasis>: the extracted
          facts incorrectly state that procedure <literal>P</literal> calls
          procedure <literal>Q</literal> but this is contradicted by a source
          code inspection.</para>
        </listitem>

        <listitem>
          <para>Extracted facts are <emphasis>incomplete</emphasis>: the
          inheritance between certain classes in Java code is missing.</para>
        </listitem>
      </itemizedlist>

      <para>The strategy to validate extracted facts differ per case but here
      are three strategies:</para>

      <itemizedlist>
        <listitem>
          <para>Postprocess the extracted facts (using Rascal, of course) to
          obtain trivial facts about the source code such as total lines of
          source code and number of procedures, classes, interfaces and the
          like. Next validate these trivial facts with tools like
          <literal>wc</literal> (word and line count), <literal>grep</literal>
          (regular expression matching) and others.</para>
        </listitem>

        <listitem>
          <para>Do a manual fact extraction on a small subset of the code and
          compare this with the automatically extracted facts.</para>
        </listitem>

        <listitem>
          <para>Use another tool on the same source and compare results
          whenever possible. A typical example is a comparison of a call
          relation extracted with different tools.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Queries</title>

        <para>For the validation of the answers to the queries essentially the
        same approach can be used as for validating the facts. Manual checking
        of answers on random samples of the SUI may be mandatory. It also
        happens frequently that answers inspire new queries that lead to new
        answers, and so on.</para>
      </formalpara>
    </section>

    <section xml:id="section.strategies-fact-extraction">
      <title>Strategies for Fact Extraction</title>

      <para>The following global scenario's are available when writing a fact
      extractor:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Dump-and-Merge</emphasis>: Parse each source file,
          extract the relevant facts, and return the resulting (partial)
          Rstore. In a separate phase, merge all the partial Rstores into a
          complete Rstore for the whole SUI. The tool {\tt merge-rstores} is
          available for this.</para>
        </listitem>

        <listitem>
          <para><emphasis>Extract-and-Update</emphasis>: Parse each source
          file, extract the relevant facts, and add these directly to the
          partial Rstore that has been constructed for previous source
          files.</para>
        </listitem>
      </itemizedlist>

      <para>The experience is that the <emphasis>Extract-and-Update</emphasis>
      is more efficient. A second consideration is the scenario used for the
      fact extraction per file. Here there are again two possibilities:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>All-in-One</emphasis>: Write one function that
          extracts all facts in one traversal of the source file. Typically,
          this function has an Rstore as argument and returns an Rstore as
          well. During the visit of specific language constructs additions are
          made to named sets or relations in the Rstore.</para>
        </listitem>

        <listitem>
          <para><emphasis>Separation-of-Concerns</emphasis>: Write a separate
          function for each fact you want to extract. Typically, each function
          takes a set or relation as argument and returns an updated version
          of it. At the top level all these functions are called and their
          results are put into an Rstore. This strategy is illustrated in
          <xref linkend="figure.separation-of-concerns" />.</para>
        </listitem>
      </itemizedlist>

      <para>The experience here is that everybody starts with the
      <emphasis>All-in-One</emphasis> strategy but that the complexities of
      the interactions between the various fact extraction concerns soon start
      to hurt. The advice is therefore to use the
      <emphasis>Separation-of-Concerns</emphasis> strategy even if it may be
      seem to be less efficient since it requires a traversal of the source
      program for each extracted set or relation.</para>

      <figure xml:id="figure.separation-of-concerns">
        <title>Separation-of-Concerns strategy for fact extraction</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="sep-of-concerns.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="section.fact-extraction-asf-sdf">
      <title>Fact Extraction using ASF+SDF</title>

      <para>Although facts can be extracted in many ways, ASF+SDF is the tool
      of preference to do this. Examples are given In XXX.<warning>
          <para>Fix reference</para>
        </warning></para>

      <para><!--\section{Fact Extraction using ASF+SDF} \label{SEC:ASF+SDF-extraction}



\subsection{Extracting Facts for Pico}


\begin{figure}[tb]
{\small
\begin{verbatim}
module PicoFactExtraction
imports Pico-syntax
imports basic/Integers
imports Rstore
imports utilities/PosInfo[PROGRAM] utilities/PosInfo[STATEMENT]
        utilities/PosInfo[EXP] utilities/PosInfo[PICO-ID]
exports
  context-free syntax
    cflow({ STATEMENT ";"}*)     -> <Set[[Elem]], Rel[[Elem]], Set[[Elem]]>

    uses(PROGRAM, Rel[[Elem]])   -> Rel[[Elem]] {traversal(accu,top-down,continue)}
    uses(EXP, Rel[[Elem]])       -> Rel[[Elem]] {traversal(accu,top-down,continue)}

    defs(PROGRAM, Rel[[Elem]])   -> Rel[[Elem]] {traversal(accu,top-down,break)}
    defs(STATEMENT, Rel[[Elem]]) -> Rel[[Elem]] {traversal(accu,top-down,break)}

    id2str(PICO-ID)              -> String
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction.sdf}Syntax of functions for Pico fact extraction}
\end{figure}

After all these mental preparations, we are now ready to delve into the details
of a Pico fact extractor. Figure~\ref{FIG:PicoFactExtraction.sdf} shows the
syntax of the functions that we will need for Pico fact extraction. There are
some things to observe:
\begin{itemize}
\item Module {\tt Pico-syntax} is imported to make available the Pico
  grammar.
\item Module {\tt Rstore} is imported to get access to all functions on
  Rstores.
\item The module {\tt PosInfo} is imported with various sort names as
  parameter. For all these sorts, the function {\tt get-location} will be
  defined that extracts the source text location from a given language
  construct.
\item The function {\tt cflow} will extract the control flow from Pico
  programs.
\item The functions {\tt uses} and {\tt defs} extracts the uses and
  definitions of variables from the source text.
\item {\tt id2str} is an auxiliary function that converts Pico identifiers to
  strings that can be included in an Rstore.
\item We have omitted all declarations for ASF+SDF variables to be used in the
  specification. The convention is that such variables all start with a dollar
  sign ({\tt \$}).
\end{itemize}

\begin{figure}[tb]
{\small 
\begin{verbatim}
%%  control flow of statement lists
[cf1] <$Entry1, $Rel1, $Exit1> := cflow($Stat),
      <$Entry2, $Rel2, $Exit2> := cflow($Stat+)
       ==========================================================
       cflow($Stat ; $Stat+) =
       < $Entry1,
         $Rel1 union $Rel2 union ($Exit1 x $Entry2),
         $Exit2
       >
[cf2] cflow() = <{}, {}, {}>

%%  control flow of individual statements
[cf3]  <$Entry, $Rel, $Exit> := cflow($Stat*),
       $Control := get-location($Exp)
       =========================================================
       cflow(while $Exp do $Stat* od) =
       < {$Control},
         ({$Control} x $Entry) union $Rel union ($Exit x {$Control}),
         {$Control}
       >

[cf4]  <$Entry1, $Rel1, $Exit1> := cflow($Stat*1),
       <$Entry2, $Rel2, $Exit2> := cflow($Stat*2),
       $Control := get-location($Exp)
       =========================================================
       cflow(if $Exp then $Stat*1 else $Stat*2 fi) =
       < {$Control},
         ({$Control} x $Entry1) union ({$Control} x $Entry2) 
                                union  $Rel1 union $Rel2,
         $Exit1 union $Exit2
       >
[default-cf]
        $Loc := get-location($Stat)
       =========================================================
        cflow($Stat) = < {$Loc}, {}, {$Loc} >
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction-cflow}Equations for {\tt cflow}: computing control flow}
\end{figure}

\begin{figure}[tb]
{\small
\begin{verbatim}

%%  Variable definitions: <expression-location, var-name>

[vd1]  $Id := $Exp := $Stat
       ==========================================================
       defs($Stat, $Rel) = $Rel union {<get-location($Stat), id2str($Id)>}

%%  Variable uses <var-location, var-name>

[vu1]  $Id := $Exp
       ==========================================================
       uses($Exp, $Rel) = $Rel union  {<get-location($Id), id2str($Id)>}

%%  utilities

[i2s] id2str(pico-id($Char*)) = strcon(""" $Char* """)

\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction-defs-uses}Equations for {\tt defs}, {\tt uses} and
  {\tt id2str}}
\end{figure}


\begin{figure}[tb]
{\small
\begin{verbatim}
module PicoQuery
imports RscriptCalculator
imports PicoFactExtraction
imports basic/Errors

exports
  start-symbols Summary
  context-free syntax
     extractRelations(PROGRAM)                   -> RSTORE
     pico-query(RSCRIPT, RSTORE, StrCon, StrCon) -> Summary
     uninit(PROGRAM)                             -> Summary
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoQuery.sdf}Syntax of function for two styles of querying}
\end{figure}

\begin{figure}[tb]
{\small
\begin{verbatim}
%%  extractRelations

[er-1] begin $Decls $Stat+ end := $Program,
       $Start := get-location($Program),
       <$Entry, $Rel, $Exit> := cflow($Stat+),

       $Loc :=  get-location($Program),
       $Rstore1 := assign(ROOT, expr, $Loc, rstore()),
       $Rstore2 := assign(PRED, rel[expr,expr],
                                $Rel union ({$Start} x $Entry), $Rstore1),
       $Rstore3 := assign(DEFS, rel[expr,varname], defs($Program, {}), $Rstore2),
       $Rstore4 := assign(USES, rel[var,varname], uses($Program, {}), $Rstore3)
       ==========================================================================
       extractRelations($Program) = $Rstore4

%%  pico-query

[pq1]  pico-query($Script, $Rstore, $StrCon1, $StrCon2) =
       convert2summary(
          $StrCon2,
          eval-rscript-with-rstore-and-yield($Script, $Rstore, $StrCon1)
       )
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction-extractRelations}Build an Rstore with
  {\tt extractRelations} and apply it using {\tt pico-query}}
\end{figure}

\begin{figure}[tb]
{\small
\begin{verbatim}
[ui-1] begin $Decls $Stat+ end := $Program,
       $Start := get-location($Program),
       <$Entry, $Rel, $Exit> := cflow($Stat+),
       $Rel1 := $Rel union ({$Start} x $Entry),
       $Rval := [| type expr = loc
                   type var  = loc
                   type varname = str

                   expr ROOT = $Start

                   rel[expr,expr] PRED = $Rel1
                   rel[expr,varname] DEFS  = defs($Program, {})
                   rel[var,varname] USES  = uses($Program, {})
                   set[varname] VARNAMES  = range(DEFS) union range(USES)

                   rel[var, varname] UNINIT =
                   { <V, VN>| var-name VN : VARNAMES,
                              var V : USES[-,VN],
                              expr E : reachX({ROOT}, DEFS[-,VN], PRED),
                              V <= E
                   }

                |] yield UNINIT
       ===================================================================
       uninit($Program) = convert2summary("Uninitialized variable", $Rval)            
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction-uninit}Combined fact extraction and
  query processing}
\end{figure}

\paragraph{Extracting control flow}
The function {\tt cflow} extracts the control flow from Pico programs. It
takes a list of statements as input and returns a triple as output:
\begin{itemize}
\item A set of program elements that may enter a construct.
\item A relation between the entries and exits of a construct.
\item A set of program elements that form the exits from the construct.
\end{itemize}
For instance, the test in an if-then-else statement forms the entry of the
statement, it is connected to the entry of the first statement of the then and
the else branch. The exits of the if-then-else statement are the exits of the
last statement in the then and the else branch. The purpose of {\tt cflow} is
to determine this information for individual statements and to combine this
information for compound statements. Its definition is shown in
Figure~\ref{FIG:PicoFactExtraction-cflow}.

\paragraph{Extracting uses and defs}
The functions {\tt defs} and {\tt uses} are shown in
Figure~\ref{FIG:PicoFactExtraction-defs-uses}.  They extract the definition,
respectively, the use of variables from the source code. Both functions are
defined by means of an ASF+SDF \emph{traversal function} which silently visits
all constructs in a tree, and only performs an action for the constructs for
which the specification contains an equation. In the case of {\tt defs},
equation {\tt [vd1]} operations on assignment statements and extracts a pair
that relates the location of the complete statement to the name of the
variable on the left-hand side. For the function {\tt uses}, equation {\tt
[vu1]} acts on all uses of variables. For completeness sake, the figure also
show the definition of utility function {\tt id2str}.

\paragraph{Queries}
Figure~\ref{FIG:PicoQuery.sdf} shows the syntax of the functions we will use
for querying. In fact, we will demonstrate two styles of definition.  In the
first style, the function {\tt extractRelation} extracts facts from a Pico
program and yields an Rstore. This can be used by {\tt pico-query} to run an
arbitrary \rscript on that Rstore. In the second style, fact extraction and
running an \rscript are done in a single function.

Figure~\ref{FIG:PicoFactExtraction-extractRelations} shows the first
definition style. In equation {\tt [er1]}, we see a step-by-step construction
of an Rstore that contains all the information gathered by the extraction
functions. An Rstore that contains all this information is returned as result
of {\tt extractRelations}. The function {\tt pico-query} can then be used to
run an \rscript for a given Rstore.

The second definition style is shown in
Figure~\ref{FIG:PicoFactExtraction-uninit}.  In this case, we see that all
work is done in a single (indeed large) equation. The construct {\tt [| ... |]
yield UNINIT} is particularly noteworthy since it allows the embedding of a
complete \rscript in an ASF+SDF equation. Also pay attention to the following:

\begin{itemize}

\item The \rscript is first simplified as much as possible according to
  ordinary ASF+SDF simplification rules. This implies that variables like {\tt
  \$Start}, {\tt \$Rel1}, and {\tt \$Program} are replaced by their respective
  values. This is also the case for the functions {\tt defs} and {\tt uses}
  that occur in the \rscript.

\item The  effect of the {\tt [| ... |] yield UNINIT} construct is that the
  \rscript is evaluated and that the value of {\tt UNINIT} is returned as
  result.

\item The definition of the function {\tt convert2summary} is not shown: it
  performs a straightforward conversion of {\tt UNINIT}'s value to the message
  format ({\tt Summary}) that is used by the Meta-Environment.

\end{itemize}--></para>
    </section>

    <section>
      <title>Concluding remarks</title>

      <para>It is not unusual that the effort that is needed to write a fact
      extractor is much larger than the few lines of Rascal that are
      sufficient for the further processing of these facts. What can we learn
      from this observation? First, that even in simple cases fact extraction
      is more complicated than the processing of these facts. This may be due
      to the following:</para>

      <itemizedlist>
        <listitem>
          <para>The facts we are interested in may be scattered over different
          language constructs. This implies that the fact extractor has to
          cover all these cases.</para>
        </listitem>

        <listitem>
          <para>The extracted facts are completely optimized for relational
          processing but places a burden on the fact extractor to perform this
          optimization.</para>
        </listitem>
      </itemizedlist>

      <para>Second, that several research questions remain unanswered:</para>

      <itemizedlist>
        <listitem>
          <para>Is it possible to solve (parts of) the fact extraction in a
          language-parametric way. In other words, is it possible to define
          generic extraction methods that apply to multiple languages?</para>
        </listitem>

        <listitem>
          <para>Is a further integration of fact extraction with relational
          processing desirable? Is it, for instance, useful to bring some of
          the syntactic program domains like expressions and statements to the
          relational domain?</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.table-builtin-operators">
    <title>Table of Built-in Operators</title>

    <para></para>

    <table xml:id="table.all-operators">
      <title>All Operators</title>

      <tgroup cols="3">
        <colspec align="left" colname="col1" colwidth="2*" />

        <colspec align="left" colname="col2" colwidth="2*" />

        <colspec align="left" colname="col3" colwidth="3*" />

        <thead>
          <row>
            <entry>Operator</entry>

            <entry>Description</entry>

            <entry>See</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript><literal>
            [</literal> <replaceable>name</replaceable> <literal>=</literal>
            <replaceable>exp</replaceable><subscript>2</subscript>
            <literal>]</literal></entry>

            <entry>Field assignment</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable> <literal>.</literal>
            <replaceable>name</replaceable></entry>

            <entry>Field selection</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable> <literal>&lt;</literal>
            <replaceable>field</replaceable>, ...<literal>
            &gt;</literal></entry>

            <entry>Field projection</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript><literal>
            [</literal> <replaceable>exp</replaceable><subscript>2</subscript>
            <literal>]</literal></entry>

            <entry>Index</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable> <literal>?</literal></entry>

            <entry>Isdefined: true is exp has a well-defined value</entry>
          </row>

          <row>
            <entry><literal>!</literal> <replaceable>exp</replaceable></entry>

            <entry>Negation</entry>
          </row>

          <row>
            <entry><literal>-</literal> <replaceable>exp</replaceable></entry>

            <entry>Negation</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable> <literal>+</literal></entry>

            <entry>Transitive closure</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable> <literal>*</literal></entry>

            <entry>Reflexive transitive</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable> <literal>@</literal>
            name</entry>

            <entry>Attribute value</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>[@</literal> name <literal>=</literal><replaceable>
            exp</replaceable><subscript>2</subscript><literal>]</literal></entry>

            <entry>Assign attribute value</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>o</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Composition</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>/</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Division</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>%</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Modulo</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>*</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Multiplication/product</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>&amp;</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Intersection</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>+</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Addition/concatenation/union</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>-</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Subtraction/difference</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable><replaceable>exp</replaceable><subscript>1</subscript></replaceable>
            <literal>join</literal>
            <replaceable><replaceable>exp</replaceable><subscript>2</subscript></replaceable></entry>

            <entry>Join</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable><replaceable>exp</replaceable><subscript>1</subscript></replaceable>
            <literal>in</literal>
            <replaceable><replaceable>exp</replaceable><subscript>2</subscript></replaceable></entry>

            <entry>Element of</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable><replaceable>exp</replaceable><subscript>1</subscript></replaceable>
            <literal>notin</literal>
            <replaceable><replaceable>exp</replaceable><subscript>2</subscript></replaceable></entry>

            <entry>Not element of</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>&lt;=</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Less than/sublist /subset</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>&lt;</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Less than/strict sublist/strict subset</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>&gt;=</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Greater than/superlist/superset</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>&gt;</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Greater than/strict superlist/ strict superset</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>pat</replaceable> <literal>:=</literal>
            <replaceable>exp</replaceable></entry>

            <entry>Match</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>pat</replaceable> <literal>!:=</literal>
            <replaceable>exp</replaceable></entry>

            <entry>No Match</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>==</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Equality</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>!=</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Inequality</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>?</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Ifdefined Otherwise</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>?</literal>
            <replaceable>exp</replaceable><subscript>2</subscript>
            <literal>:</literal>
            <replaceable>exp</replaceable><subscript>3</subscript></entry>

            <entry>Conditional expression</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>==&gt;</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Implication</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>&lt;==&gt;</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Equivalence</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>&amp;&amp;</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Boolean and</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>exp</replaceable><subscript>1</subscript>
            <literal>||</literal>
            <replaceable>exp</replaceable><subscript>2</subscript></entry>

            <entry>Boolean or</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para></para>

    <para></para>
  </section>

  <section xml:id="section.table-builtin-functions">
    <title>Table of Built-in Functions</title>

    <para><table xml:id="table.all-functions">
        <title>All Functions</title>
        <?dbfo keep-together="auto" ?>
        <titleabbrev></titleabbrev>


        <tgroup cols="3">
          <colspec align="left" colname="col1" colwidth="3*" />

          <colspec align="left" colname="col2" colwidth="1*" />

          <colspec align="left" colname="col3" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Module</entry>

              <entry>See</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>abs</literal></entry>

              <entry>Integer</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>arbBool</literal></entry>

              <entry>Boolean</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>arbInt</literal></entry>

              <entry>Integer</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>arbReal</literal></entry>

              <entry>Real</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>arity</literal></entry>

              <entry>Node</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>assertEqual</literal></entry>

              <entry>UnitTest</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>assertTrue</literal></entry>

              <entry>UnitTest</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>average</literal></entry>

              <entry>List, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>bottom</literal></entry>

              <entry>Graph, LabelledGraph</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>browse</literal></entry>

              <entry>View</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>carrier</literal></entry>

              <entry>Relation</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>carrierR</literal></entry>

              <entry>Relation</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>carrierX</literal></entry>

              <entry>Relation</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>center</literal></entry>

              <entry>String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>charAt</literal> ? remove</entry>

              <entry>String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>complement</literal></entry>

              <entry>Relation</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>currentTimeMillis</literal></entry>

              <entry>Benchmark</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>delete</literal></entry>

              <entry>List</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>domain</literal></entry>

              <entry>List, Map, Relation</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>domainR</literal></entry>

              <entry>Relation</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>domainX</literal></entry>

              <entry>Relation</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>endsWith</literal></entry>

              <entry>String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>files</literal></entry>

              <entry>Resource</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>fromInt</literal></entry>

              <entry>Boolean</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>fromString</literal></entry>

              <entry>Boolean</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>getChildren</literal></entry>

              <entry>Node</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>getName</literal></entry>

              <entry>Node</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>getOneFrom</literal></entry>

              <entry>List, Map, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>head</literal></entry>

              <entry>List</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>insertAt</literal></entry>

              <entry>List</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>invert</literal></entry>

              <entry>Map, Relation</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>isEmpty</literal></entry>

              <entry>List, Map, Set, String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>left</literal></entry>

              <entry>String</entry>

              <entry></entry>
            </row>

            <row>
              <entry>location ?name</entry>

              <entry>Resource</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>makeNode</literal></entry>

              <entry>Node</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>mapper</literal>?</entry>

              <entry>Map, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>max</literal></entry>

              <entry>Integer, List, Real, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>min</literal></entry>

              <entry>Integer, List, Real?, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>multiply</literal></entry>

              <entry>List, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>permutations</literal></entry>

              <entry>List</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>power</literal></entry>

              <entry>Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>power1</literal></entry>

              <entry>Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>println</literal></entry>

              <entry>IO</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>projects</literal></entry>

              <entry>Resource</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>range</literal></entry>

              <entry>Map</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>reach</literal></entry>

              <entry>Graph, LabelledGraph</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>reachR</literal></entry>

              <entry>Graph, LabelledGraph</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>reachX</literal></entry>

              <entry>Graph, LabelledGraph</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>readFile</literal></entry>

              <entry>IO</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>readRSF</literal></entry>

              <entry>RSF</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>readValueFromBinaryFile</literal></entry>

              <entry>ValueIO</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>readValueFromTextFile</literal></entry>

              <entry>ValueIO</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>reducer</literal></entry>

              <entry>List, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>references</literal></entry>

              <entry>Resource</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>report</literal></entry>

              <entry>UnitTest</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>reverse</literal></entry>

              <entry>List, String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>right</literal></entry>

              <entry>String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>root</literal></entry>

              <entry>Resource</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>shortestPathPair</literal></entry>

              <entry>Graph, LabelledGraph</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>show</literal></entry>

              <entry>View</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>size</literal></entry>

              <entry>List?, Map, Set, String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>slice</literal></entry>

              <entry>List</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>sort</literal></entry>

              <entry>List</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>startsWith</literal></entry>

              <entry>String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>sum</literal></entry>

              <entry>List, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>tail</literal></entry>

              <entry>List</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>takeOneFrom</literal></entry>

              <entry>List, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toInt</literal></entry>

              <entry>Boolean</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toInteger</literal>!</entry>

              <entry>Real</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toList</literal></entry>

              <entry>Map, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toLowerCase</literal></entry>

              <entry>String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toMap</literal></entry>

              <entry>List, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>top</literal></entry>

              <entry>Graph, LabelledGraph</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toReal</literal></entry>

              <entry>Boolean, Integer</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toRel</literal></entry>

              <entry>Map</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toSet</literal></entry>

              <entry>List</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toString</literal></entry>

              <entry>Boolean, Integer, List, Map, Real, Set</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>toUpperCase</literal></entry>

              <entry>String</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>writeValueToBinaryFile</literal></entry>

              <entry>ValueIO</entry>

              <entry></entry>
            </row>

            <row>
              <entry><literal>writeValueToTextFile</literal></entry>

              <entry>ValueIO</entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <para></para>
  </section>

  <section xml:id="section.rscript-bibliography">
    <title>Bibliography</title>

    <para><bibliolist>
        <bibliomixed xml:id="AhoSethiUllman86"></bibliomixed>

        <bibliomixed xml:id="BNL03"></bibliomixed>

        <bibliomixed xml:id="Dot96"></bibliomixed>

        <bibliomixed xml:id="FeijsKrikhaarOmmering98"></bibliomixed>

        <bibliomixed xml:id="Holt96"></bibliomixed>

        <bibliomixed xml:id="JacksonRollins94"></bibliomixed>

        <bibliomixed xml:id="KlintIWPC03"></bibliomixed>

        <bibliomixed xml:id="Krikhaar99"></bibliomixed>

        <bibliomixed xml:id="McCabe76"></bibliomixed>

        <bibliomixed xml:id="Mueller88"></bibliomixed>

        <bibliomixed xml:id="Tip95"></bibliomixed>

        <bibliomixed xml:id="Weiser84"></bibliomixed>
      </bibliolist></para>
  </section>

  <!--




\chapter{Installing and Running \rscript} \label{SEC:running-rscript}

\begin{figure}[h]
\begin{center}
\epsfig{figure=figs/ruhmkorff.ps,width=15cm} \label{FIG:ruhmkorff}
\end{center}
\end{figure}

\section{Warning}
The information in the current chapter is outdated. As of august 2007, the
most convenient way to use \rscript is to use \texttt{rscript-meta}, an
instance of The Meta-Environment specialized for \rscript. It can be
downloaded (in binary and source form) from
\url{http://www.meta-environment.org}.

\section{Installing \rscript}
\rscript is available\footnote{\url{www.cwi.nl/projects/MetaEnv/...}}
as \texttt{relation-calculus-0.4.tar.gz} (or a newer version).  It
requires a recent version (e.g. at least 1.5.3) of the ASF+SDF
Meta-Environment to run.  A typical installation session on a typical
Unix/Linux system consists of the following steps:

\begin{itemize}

\item Extract all files from the distribution:
  \texttt{tar zxvf relation-calculus-0.4.tar.gz}
This command uncompresses the distribution file, creates a subdirectory
\texttt{relation-calculus-0.4} and places all directories and files
from the distribution in it.

\item Change to the new directory:
  \texttt{cd relation-calculus-0.4}
\item Configure the sources: \texttt{./configure}

\item Build and install application: \texttt{make install}

\end{itemize}

See the files \texttt{INSTALL} and \texttt{README} for more specific
installation instructions.


\section{Running \rscript from the command line} \label{SEC:running-commandline}

\subsection{File extensions}
The following file extensions are used by the command line tools:

\begin{itemize}

\item \texttt{.rscript} is the required file name extension for files that contain an \rscript.

\item \texttt{.rstore} is the required file name extension for files
that contain an rstore.  As intermediate result rstores also occur in
parsed form and then have the extension \texttt{.rstore.pt}. The tools
transparently accept rstores in both forms.

\item \texttt{.rviz} is the required file name extension for files that
contain relational data that are to be visualized (see
Chapter~\ref{SEC:Visualization}).

\end{itemize}

\subsection{\texttt{rscript}: check and execute an rscript}
The command \texttt{rscript} takes care of parsing, typechecking, and
executing an \rscript. Optionally, the script can only be checked, can
use a given rstore, be executed as test suite, or yield the value of a
given variable from the resulting rstore.

\begin{itemize}

\item \texttt{-c} or \texttt{-check-only}:
Only check the rscript for syntactic errors or typechecking errors
but do not execute it.

\item \texttt{-h} or \texttt{-help}; print help information.

\item \texttt{-i} \emph{name} or \texttt{-input} \emph{name}:
The \rscript to be processed is on file \emph{name}.
By default, the script is assumed to be on standard input.

\item \texttt{-o} \emph{name} or \texttt{-output-parse-tree} \emph{name}:
The result of the execution of the \rscript is an rstore and is written to file \emph{name}.
Note that this rstore is in the form of a parse tree.
By default, the resulting rstore is printed in textual form to standard output.

\item \texttt{-s} \emph{name} or \texttt{-store} \emph{name}:
The \rscript is executed using an initial rstore taken from file \emph{name}.
By default, the initial rstore is empty.


\item \texttt{-t} or \texttt{-testsuite}:
Execute the \rscript as a testsuite, i.e., execute all \texttt{assert} statements and report
which ones failed.

\item \texttt{-v} or \texttt{-verbose}: give verbose output.

\item \texttt{-y} \emph{name} or \texttt{-yield} \emph{name}:
Instead of producing a complete rstore as the result of executing the rscript,
only return the value of the variable \emph{name}.r
\end{itemize}

The following examples illustrate the use of the \texttt{rscript} command:

\begin{itemize}

\item  \texttt{rscript query.rscript} executes the script \texttt{query.rscript}
and prints the resulting rstore on standard output.

\item \texttt{rscript -i query.rscript -s previous.rstore -o result.rstore.pt}:
executes the same script, but uses \texttt{previous.rstore} as initial rstore
and writes the resulting store to \texttt{result.rstore.pt}>

\item \texttt{rscript -y nCalls calls.rscript}:
executes the script \texttt{calls.rscript} and prints the value of the variable \texttt{nCalls}
in the resulting rstore.

\item \texttt{rscript -t tests1.rscript}:
executes \texttt{tests2.rscript} as test suite and reports which assert
statements failed (if any).
\end{itemize}

\subsection{\texttt{extract-relations}: extract relations from source files} \label{SEC:extract-relations}

The command \texttt{extract-relations} provides a common framework for
\asfsdf-based fact extraction and has the following form:

\begin{exam}
\texttt{extract-relations [options] <input-files>}
\end{exam}

\noindent The following optional arguments are supported:

\begin{itemize}

\item \texttt{-h} or \texttt{-help}; print help information.

\item \texttt{-o} \emph{file} or \texttt{-output} \emph{file}: the name of
  the resulting rstore 
(default: \texttt{result.rstore.pt}).

\item \texttt{-e} \emph{program} or \texttt{-executable} \emph{program}: the
executable \emph{program} for performing extraction (default: none). This is most
likely to be a compiled \asfsdf specification.

\item \texttt{-s} \emph{sort} or \texttt{-sort} \emph{sort}:
\emph{sort} is the sort used for parsing each input file (default:
none). In other words, each input file should conform to the syntax of \emph{sort}.
Example: \texttt{CompilationUnit}.

\item \texttt{-f} \emph{name} or \texttt{-function} \emph{name}: the extraction function to be applied 
to each source file (default: \texttt{extractRelations}). The definition of
this function should conform to:
\begin{exam}
\texttt{extractRelations(}\emph{sort}\texttt{) -> RSTORE}
\end{exam}
where \emph{sort} is the sort of each input file as defined above.

\item \texttt{-p} \emph{file} or \texttt{-parse-table} \emph{file}: the parse table \emph{file} used for parsing input files (default: none).

\end{itemize}

\noindent The following examples illustrate the use of the \texttt{extract-relations} command:

\begin{itemize}

\item \texttt{extract-relations -e JavaAnalysis -s CompilationUnit -o
  jhotdraw.rstore.pt -p Java.trm.tbl dir/*.java}: extract relations from Java source
  code in the files \texttt{dir/*.java}. Use executable \texttt{JavaAnalysis}, each input file is of sort
  \texttt{CompilationUnit}, use parse table  \texttt{Java.trm.tbl}, and
  produce as output an rstore \texttt{jhotdraw.rstore.pt}.

\item
  \texttt{extract-relations -e TBExtr -s Tscript -p Tscript.trm.tbl *.tb}:
  extract relations from \TB source files. Use executable \texttt{TBExtr}, each input file is of
  sort \texttt{Tscript}, use parse table \texttt{Tscript.trm.tbl} and extract
  from the source files \texttt{*.tb}.

\end{itemize}


\subsection{\texttt{merge-rstores}: combine several rstores}

The command \texttt{merge-rstores} merges several rstores into a new
rstore.  This command is used in a scenario where an extraction tool
extracts facts from each source file in a software portfolio to be
analyzed and deposits these facts in a separate rstore per source
file.  When the complete portfolio is to be analyzed, the separate
rstores have to be merged into a single one. This merged rstore is then
used as initial rstore for the execution of some rscript.

The command has as arguments, a list of names of rstores to be merged.

The following optional arguments are supported:

\begin{itemize}
\item \texttt{-h} or \texttt{-help}: print help information.

\item \texttt{-o} \emph{name} or \texttt{-output} \emph{name}:
the name of the merged rstore is \emph{name}.
By default, the output is \texttt{result.rstore.pt}.
\note{tool should check for right output form}

\item \texttt{-v} or \texttt{-verbose}: give verbose output.

\end{itemize}

\section{Running \rscript Interactively} \label{SEC:running-interactive}
You can also edit and run Rscripts interactively:
\begin{itemize}
\item Change directory to your checked out copy of the directory {\tt relation-calculus/spec}.
\item Start the ASF+SDF Meta-Environment with the command {\tt meta}.
\item Open the module {\tt Rscript.sdf}.
\item Open your own term, using the {\tt Rscript} module.
\item Observe that a new menu with the name {\tt Rscript} appears in the menu bar.
\item Click the parse button in the {\tt Actions} menu of the editor:
now we know whether there are syntax errors. If so, correct them.

\item Click the {\tt Check} button in the {\tt Rscript} menu: this will
  perform a type check of your script. If there are type errors, correct them.

\item Click the {\tt Run} button in the {\tt Rscript} menu to execute your script: a new
editor pops up which shows all the variables at the end of the execution.
{\tt Run} also performs a type of your script so you may skip the previous step.

\item Click the {\tt Run with Rstore} button if you want to execute your
  \rscript with an existing ``Rstore'': a collection of relations that are the
  result of previous extraction phase. Currently, a fixed name is used for
  this Rstore: {\tt RSTORE.rstore}.

\end{itemize}

\paragraph{Running a Test suite} \label{running}
Same as above but use {\tt Testsuite} button instead of the {\tt Execute}
button in the {\tt Rscript} menu.  The effect is that the script is executed
and that a summary is printed of {\tt assert} statement that succeeded or
failed.

\section{Other Tools and Demos}

\subsection{Examples}

The subdirectory {\tt rscripts} contains several sample scripts.  See, for instance, {\tt
tests1.rscript} and {\tt tests2.rscript} for examples of the use of built-in
operators and functions.

\subsection{The Pico Demo}

The subdirectory {\tt demo/pico} contains in a single directory the
Pico syntax, Pico fact extraction (discussed in
Section~\ref{SEC:ASF+SDF-extraction}) and the test on uninitialized
variables presented in Section~\ref{SEC:uninit}.

\begin{itemize}

\item Change directory to \texttt{demo/pico}: \texttt{cd demo/pico}.

\item Start the \asfsdf Meta-Environment: \texttt{meta -m Pico-syntax.sdf}.

\item Open the term \texttt{exam.pico} over module \texttt{Pico-syntax.sdf}.

\item Under the \texttt{Pico} menu two styles of checking are available:
  \begin{itemize}
  \item Extract Relations: this extracts relations from the current Pico program.
  \item Uninitialized Vars (Style 1): uses the extracted facts and
  executes the \rscript \texttt{uninit.rscript}, see
  Figure~\ref{FIG:PicoFactExtraction-extractRelations}.
  \item Uninitialized Vars (Style 2): performs combined facts extraction and 
   query processing, see Figure~\ref{FIG:PicoFactExtraction-uninit}.
  \end{itemize}
  See Figure~\ref{FIG:meta-pico} for a screen dump.

\end{itemize}

\subsection{The Java Demo}

The Java demo consists of the following parts:

\begin{itemize}

\item \texttt{java/grammar}: Contains a SDF grammar for Java.

\item 
\begin{sloppypar}
\texttt{java/extraction}: defines \texttt{JavaAnalysis}, that
performs basic fact extraction from Java source code. It also defines the
command \texttt{extract-java}, a specialized version of
\texttt{extract-relations} (see Section~\ref{SEC:extract-relations}):
\end{sloppypar}

\item \texttt{java/rscripts}: defines a script \texttt{Enrich.rscript} enrich
  the facts extracted by JavaAnalysis. It also defines some sample scripts
that operate on the enriched rstores.

\item \texttt{java/example-hotdraw}: gives data for the JhotDraw example.

\end{itemize}

The command \texttt{extract-java} provides a common framework for
\asfsdf-based fact extraction from Java programs and has the following form:

\begin{exam}
\texttt{extract-java [options]}
\end{exam}

\noindent The following optional arguments are supported:

\begin{itemize}

\item \texttt{-h} or \texttt{-help}; print help information.

\item \texttt{-i} \emph{dir} or \texttt{-input} \emph{dir}: the name a
  directory \emph{dir} that contains the Java source code. All Java source
  files appearing in (subdirectories of) \emph{dir} will be used as input.
  (default: current directory).

\item \texttt{-o} \emph{file} or \texttt{-output} \emph{file}: the name of
  the resulting rstore 
(default: \texttt{result.rstore.pt}).

\item \texttt{-e} \emph{program} or \texttt{-executable} \emph{program}: the
executable \emph{program} for performing extraction (default: \texttt{JavaAnalysis}). This is most
likely to be a compiled \asfsdf specification.

\item \texttt{-f} \emph{name} or \texttt{-function} \emph{name}: the extraction function to be applied 
to each source file (default: \texttt{extractRelations}). The definition of
this function should conform to:
\begin{exam}
\texttt{extractRelations(CompilationUnit) -> RSTORE}
\end{exam}

\end{itemize}

\noindent The following examples illustrate the use of the
\texttt{extract-relations} command:
\begin{exam}
\texttt{extract-java -i JHotDraw5.2-sources -o jhotdraw.rstore.pt}
\end{exam}

Here is a scenario to go all the way from Java source code to the
visualization of the extracted and enriched facts:
{\footnotesize
\begin{verbatim}
cd example-hotdraw
extract-java -i /ufs/paulk/software/source/JHotDraw -o jhotdraw.rstore.pt
rscript -i ../rscripts/Enrich.rscript -s jhotdraw.rstore.pt -o enr.jhotdraw.rstore.pt
rscript -i validate.rscript -s enr.jhotdraw.rstore.pt
rstore2rviz -i enr.jhotdraw.rstore.pt -o jhotdraw.rviz
rviz jhotdraw.rviz
\end{verbatim}
}

\noindent In the next chapter, we will further explain this scenario.

\chapter{Visualization of Rstores} \label{SEC:Visualization}

\fbox{\epsfig{figure=figs/camera-obscura.ps,width=8cm}} \label{FIG:camera-obscura}
\hspace*{0.5cm}\parbox[b]{6cm}{ The sets and relations constructed for all but
the most trivial problems are voluminous and their textual representation is
hard to grasp for the human eye. This is where information visualization
techniques (**) come to our rescue.  In this chapter we present some initial
experiments to visualize the contents of an Rstore. This is a multi-stage
process described in Section~\ref{SEC:visualize-workflow}.
First facts are extracted from the source
(Section~\ref{SEC:ExtractingFactsAgain})
and are further enriched (Section~\ref{SEC:EnrichingFacts}).
Next the Rstore is converted to the \texttt{.rviz} format that is more
amenable as input for a visualization tool. This format is described in
Section~\ref{SEC:rvizformat} and the conversion from Rstore to this format is
discussed in Section~\ref{SEC:rstore2rviz}. Next, the \texttt{.rviz} file can
be visualized and explored. This is the topic of Section~\ref{SEC:rviz} }

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/visualize-workflow.eps,width=10cm}
\vspace*{-0cm}
\end{center}
\hrulefill
\caption{\label{FIG:visualize-workflow}Workflow for visualization of System Under Investigation}
\end{figure}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/rviz1.ps,width=15cm}
\end{center}
\hrulefill
\caption{\label{FIG:rviz1}File view}
\end{figure}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/rviz2.ps,width=15cm}
\end{center}
\hrulefill
\caption{\label{FIG:rviz2}Tree map view}
\end{figure}


\section{Warning}
The ideas described here remain relevant but their specific implementation is
 outdated. The interactive \rscript environment (\texttt{rscript-meta}) contains
built-in visualization techniques for Rstores.

\section{The visualization workflow} \label{SEC:visualize-workflow}

The process of achieving a visualization of a System under Investigation (SUI) is shown in
Figure~\ref{FIG:visualize-workflow} and consists of the following steps:
\begin{itemize}
\item Extract facts from a source code directory \texttt{SUISrcDir} and
  produce an Rstore \texttt{SUI.rstore.pt}.
\item \begin{sloppypar} Enrich this Rstore by running an rscript \texttt{enr.rscript} on it,
  with resulting enriched Rstore \texttt{enr.rstore.pt}. \end{sloppypar}
\item Convert the enriched Rstore to the the visualization format
  \texttt{.rviz}.
\item Run the visualization tool \texttt{rviz} on these data.
\end{itemize}
\noindent The details of this process are now further explained.

\section{Extracting Facts} \label{SEC:ExtractingFactsAgain}
In Chapter~\ref{SEC:ExtractingFacts} we have already seen how fact extraction can
be organized and implemented. For the current presentation it is sufficient to
assume that there exists an \texttt{extract} tool that can be used:
\begin{exam}
\texttt{extract -i SUISrcDir -o SUI.rstore.pt}
\end{exam}
where \texttt{SUISrcDir} is the source directory where the source of the SUI
can be found. In the distribution a tool \texttt{extract-java} is available with precisely
this behavior for Java programs.

\section{Enriching Facts} \label{SEC:EnrichingFacts}
Given the Rstore  \texttt{SUI.rstore.pt} we enrich it by writing and executing
an \rscript
\texttt{enr.rscript} that extends the extracted facts as required by the goal
we want to achieve:
\begin{exam}
\texttt{rscript enr.rscript -s SUI.rstore.pt -o enr.SUI.rstore.pt}
\end{exam}

\section{The \texttt{.rviz} Format} \label{SEC:rvizformat}

Before explaining the conversion to the rviz format, it is helpful to
understand this format first.
Only two forms of data definitions can currently appear in an rviz file.
\emph{Elements} are values that can occur in relations and are defined by the
keyword \texttt{elm}.  \emph{Tuples} are defined by the keyword
\texttt{tup}. The definition of an \emph{element} has the following form:

\begin{exam}
\texttt{elm} \emph{Type} \emph{Name} \emph{File} \emph{BeginLine} \emph{BeginCol} \emph{EndLine} \emph{EndCol}
\end{exam}

\noindent \emph{Type} is the type as declared in the \rscript, \emph{Name} is
the textual name of the element, and the subsequent file and location
information characterize the precise coordinates of the element in the source
text. An example of an element definition is:

\begin{exam}
\texttt{elm "ClassName" "PolyLineFigure" ".../PolyLineFigure.java" 21 0 339 1}
\end{exam}

The definition of a \emph{tuple} has the following form:
\begin{exam}
\texttt{tup} \emph{RelName} \emph{Type1} \emph{Value1} \emph{Type2} \emph{Value2}
\end{exam}
\noindent \emph{RelName} is the name of the relation to which the tuple belongs.
It is followed two type/value pairs that define the two items in the tuple.
An example of a tuple definition is:

\begin{exam}
\texttt{tup IMPLEMENTS "ClassName" "AbstractHandle" "InterfaceName" "Handle"}
\end{exam}

\paragraph{Discussion} Observe that the current visualization format is very simple and does not 
allow the representation of all data that may be present in an Rstore. In particular, sets and
$n$-ary relations ($n > 2$) are not represented. Clearly, this format will further evolve.

\section{\texttt{rstore2rviz}: Convert Rstore to Visualization Format} \label{SEC:rstore2rviz}
The command \texttt{rstore2rviz} takes an rstore as input and converts it
to the \texttt{.rviz} format that is accepted by the visualization tool \texttt{rviz}.

\begin{itemize}

\item \texttt{-h} or \texttt{-help}: print help information.

\item \texttt{-i} \emph{name} or \texttt{-input} \emph{name}:
rstore comes from file \emph{name}. By default: standard input.

\item \texttt{-o} \emph{name} or \texttt{-output} \emph{name}:
the result is written to file \emph{name}. By default, this is
a file named \texttt{result.rviz}.

\item \texttt{-v} or \texttt{-verbose}: give verbose output.

\end{itemize}
Example:
   \texttt{rstore2rviz -i enr.SUI.rstore.pt -o SUI.rviz}

\section{\texttt{rviz}: Visualize an Rstore} \label{SEC:rviz}


Visualization is simply started by the command \texttt{rviz} with the
given visualization data as input, as in:

\begin{exam}
\texttt{rviz SUI.rviz}
\end{exam}

\noindent The result is a window as shown in Figure~\ref{FIG:rviz1} which
consists of several panes.  On the left-hand side three panes occur. On top is
the \emph{Relations} pane that lists the relations that are available.  One of
these relations can be selected and its elements will be displayed.  In the
middle appears an \emph{Element Type} pane that shows the element types that
are available for the selected relation.  Selecting one of these types lists
in the the bottom all \emph{Elements} that occur in the selected relation and
are of the selected type. By selecting one element from the \emph{Elements}
pane, that element (and all elements it is associated with by the selected
relation) will be highlighted in the large graphical pane on the right.

There are two visualization methods available that can be selected by the button
at the bottom left that is alternatively labeled as \texttt{View as Files} or
\texttt{View as TreeMap}. In the former case, files are shown as rectangles
with a a pattern of horizontal lines inside that reflect their textual
structure. In the latter case, a tree map is shown of the directory structure
of all files.

Figure Figure~\ref{FIG:rviz1} shows the visualization of facts extracted from
the JHotDraw application. The relation \texttt{IMPLEMENTS} has been selected,
and of the two possible element types \texttt{ClassName} has been chosen.
From the list of possible class names, \texttt{AbstractHandle} has been selected.
The result is that the element itself is shown in the file view (with all lines of its definition displayed in blue),
and all its ``related'' elements (e.g., the interfaces it implements) shown in red.

Figure Figure~\ref{FIG:rviz2} shows the same selection, but this time in the tree map view.

\vspace*{3cm}
\begin{figure}[b]
\begin{center}
\vspace*{-3cm}
\epsfig{figure=figs/teleskoop.ps,width=8cm} \label{FIG:teleskoop}

\end{center}
\end{figure}




%%\begin{figure}[h]
%%\begin{center}
%%\epsfig{figure=figs/sonometer.ps,width=15cm}
%%\end{center}
%%\end{figure}



%% \newpage
\section*{Acknowledgments}
Thanks to Tijs van der Storm for many useful discussions and experiments.
Thanks to Murat Ahat, Jan van Eijck, Taeke Kooiker, Tijs van der Storm, Ivan Vankov,
and Jurgen Vinju for comments on this tutorial.

\section*{Illustrations}

Most illustrations used in this tutorial concern physical instruments for
  measurement or observation and are taken from H. van de Stadt, \emph{Beknopt
  Leerboek der Natuurkunde} (Concise Text-book of Physics) Tjeenk Willink,
  Zwolle, 1902.
On the front page appears a windlass that amplifies manual power and is used in
water wells, drilling devices, and wind mills.
Page~\pageref{FIG:balloon}  shows a hot air balloon combined with a parachute
(circa 1900).
On page~\pageref{FIG:microscope} appears a composite microscope as proposed by
Drebbel (1621).
On page~\pageref{FIG:declinatorium} appears a \emph{declinatorium} used to
measure the difference between the magnetic and geographic north pole.
On page~\pageref{FIG:vuurtoren} the cross section is shown of a lighthouse as used along
the Dutch cost.
The spectroscope on page~\pageref{FIG:spektroskoop} is a design using four
prisms by Steinheil
and is used for the improved dispersion and analysis of the light emitted by
sodium vapor.
On page~\pageref{FIG:ruhmkorff} appears Ruhmkorff's induction-coil (1851) used
to create high-Voltage electric currents. 
Page \pageref{FIG:camera-obscura} shows a variation of the \emph{camera obscura} as
used for producing realistic drawings of a landscape.
Lassell's telescope (1863) appears on page~\pageref{FIG:teleskoop}.

 The photograph on page~\pageref{FIG:caruso} is the ``Caruso'' loudspeaker and
  appeared in an advertisement in J. Corver, \emph{Het Draadloos
  Amateurstation} (The Wireless Amateur (Radio) Station), Veenstra, 's
  Gravenhage, 1928.
The sign alphabet on page~\pageref{FIG:signalpha} has been taken from
\url{ www.inquiry.net/outdoor/skills/b-p/signaling.htm}
\bibliographystyle{plain} \bibliography{iwpc,tutorial}

%%\chapter{TO DO}
%%\begin{itemize}
%%\item {\tt all-path-to}, {\tt sort} not described.
%%\item $n$-ary relations
%%\item Termination criteria for solving equations
%%\item Access functions for $n$-ary tuples.
%%\item Describe Rstores
%%\item Give Rscript grammar
%%\item Yield
%%\item Make an index.

%%\end{itemize}

\end{document
}
-->
</chapter>
