<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
]>
<chapter version="5.0" xml:id="EASY-Meta-Programming-with-Rascal"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns6="http://www.w3.org/1999/xhtml"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>EASY Meta-Programming with Rascal</title>

    <subtitle>Leveraging the Extract-Analyze-SYnthesize Paradigm for
    Meta-Programming</subtitle>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint, Jurgen Vinju,
        Tijs van der Storm</surname></personname>
      </author>
    </authorgroup>

    <pubdate>June 26, 2009 (Version 0.2)</pubdate>
  </info>

  <warning>
    <para>Rascal is a work in progress both regarding implementation and
    documentation. The current version of this document is a preview version
    only. Comments labelled "Warning" (like this one) or other
    <remark>remarks</remark> (like this one) are temporary notes that will
    disappear in the final version.</para>
  </warning>

  <section xml:id="section.why-a-new-language">
    <title>A New Language for Meta-Programming</title>

    <para><emphasis>Meta-programs</emphasis> are programs that analyze,
    transform or generate other programs. Ordinary programs work on data;
    meta-programs work on programs. The range of programs to which
    meta-programming can be applied is large: from programs in standard
    languages like C and Java to domain-specific languages for describing
    high-level system models or applications in specialized areas like gaming
    or finance. In some cases, even test results or performance data are used
    as input for meta-programs.</para>

    <para>Rascal is a new language for <emphasis>meta-programming</emphasis>,
    this is the activity of writing meta-programs.</para>

    <section xml:id="section.EASY-programming">
      <title>EASY Programming</title>

      <para>Many meta-programming problems follow a fixed pattern. Starting
      with some input system (a black box that we usually call
      <emphasis>system-of-interest</emphasis>), first relevant information is
      extracted from it and stored in an internal representation. This
      internal representation is then analyzed and used to synthesize results.
      If the synthesis indicates this, these steps can be repeated over and
      over again. These steps are shown in <xref
      linkend="figure.extract-analyze-synthesize-paradigm" />.<figure
          xml:id="figure.extract-analyze-synthesize-paradigm">
          <title>EASY: the Extract-Analyze-Synthesize Paradigm</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="easy-workflow.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>This is an abstract view on solving meta-programming problems, but
      is it uncommon? No, so let's illustrate it with a few examples.</para>

      <para><example>
          <title>Finding security breaches</title>

          <para><emphasis>Alice</emphasis> is system administrator of a large
          online marketplace and she is looking for security breaches in her
          system. The objects-of-interest are the system's log files. First
          relevant entries are extracted. This will include, for instance,
          messages from the SecureShell demon that reports failed login
          attempts. From each entry login name and originating IP address are
          extracted and put in a table (the internal representation in this
          example). These data are analysed by detecting duplicates and
          counting frequencies. Finally results are synthesized by listing the
          most frequently used login names and IP addresses.</para>
        </example><example>
          <title>A Forensic DSL compiler</title>

          <para><emphasis>Bernd</emphasis> is a senior software engineer
          working at the Berlin headquarters of a forensic investigation lab
          of the German government. His daily work is to find common patterns
          in files stored on digital media that have been confiscated during
          criminal investigations. Text, audio and video files are stored in
          zillions of different data formats and each data format requires its
          own analysis technique. For each new investigation ad hoc
          combinations of tools are used. This makes the process very
          labour-intensive and error-prone. Bernd convinces his manager that
          designing a new domain-specific language (DSL) for forensic
          investigations may relieve the pressure on their lab. After
          designing the DSL---let's call it DERRICK---he makes an EASY
          implementation for it. Given a DERRICK program for a specific case
          under investigation, he first extracts relevant information from it
          and analyzes it: which media formats are relevant? Which patterns to
          look for? How should search results be combined? Given this new
          information, Java code is synthesized that uses the various existing
          tools and combines their results.</para>
        </example><example>
          <title>Renovating Financial Software</title>

          <para><emphasis>Charlotte</emphasis> is software engineer at a large
          financial institution in Paris and she is looking for options to
          connect an old and dusty software system to a web interface. She
          will need to analyze the sources of that system to understand how it
          can be changed to meet the new requirements. The objects-of-interest
          are in this case the source files, documentation, test scripts and
          any other available information. They have to be parsed in some way
          in order to extract relevant information, say the calls between
          various parts of the system. The call information can be represented
          as a binary relation between caller and callee (the internal
          representation in this example). This relation with 1-step calls is
          analyzed and further extended with 2-step calls, 3-step calls and so
          on. In this way call chains of arbitrary length become available.
          With this new information, we can synthesize results by determining
          the entry points of the software system, i.e., the points where
          calls from the outside world enter the system. Having completed this
          first cycle, Charlotte may be interested in which procedures can be
          called from the entry points and so on and so forth. Results will be
          typically represented as pictures that display the relationships
          that were found. In the case of source code analysis, a variation of
          our workflow scheme is quite common. It is then called the
          extract-analyze-view paradigm and is shown in <xref
          linkend="figure.extract-analyze-view-paradigm" />.</para>
        </example><figure xml:id="figure.extract-analyze-view-paradigm">
          <title>The extract-analyze-view paradigm</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="extract-analyze-view-paradigm.png"
                         scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure><example>
          <title>Finding Concurrency Errors</title>

          <para><emphasis>Daniel</emphasis> is concurrency researcher at one
          of the largest hardware manufacturers worldwide. He is working from
          an office in the Bay Area. Concurrency is the big issue for his
          company: it is becoming harder and harder to make CPUs faster,
          therefore more and more of them are bundled on a single chip.
          Programming these multi-core chips is difficult and many programs
          that worked fine on a single CPU contain hard to detect concurrency
          errors due to subtle differences in the order of execution that
          results from executing the code on more than one CPU. Here is where
          Daniel enters the picture. He is working on tools for finding
          concurrency errors. First he extracts facts from the code that are
          relevant for concurrency problems and have to do with calls,
          threads, shared variables and locks. Next, he analyzes these facts
          and synthesizes an abstract model that captures the essentials of
          the concurrency behaviour of the program. Finally he runs a
          third-party verification tool with this model as input to do the
          actual verification.</para>
        </example><example>
          <title>Model driven engineering</title>

          <para><emphasis>Elisabeth</emphasis> is a software architect at a
          large airplane manufacturer and her concern is reliability and
          dependability of airplane control software. She and her team have
          designed a UML model of the control software and have extended it
          with annotations that describe the reliability of individual
          components. She will use this annotated model in two ways: (a) to
          extract relevant information from it to synthesize input for a
          statistical tool that will compute overall system reliability from
          the reliability of individual components; (b) to generate executable
          code that takes the reliability issues into account.</para>
        </example></para>
    </section>

    <section>
      <title>Rascal</title>

      <para>With these examples in mind, you have a pretty good picture how
      EASY applies in different use cases. All these cases involve a form of
      <emphasis>meta-programming</emphasis>: software programs (in a wide
      sense) are the objects-of-interest that are being analyzed and
      transformed. The Rascal language you are about to learn is designed for
      meta-programming following the EASY paradigm. It can be applied in
      domains ranging from compiler construction and implementing
      domain-specific languages to constraint solving and software
      renovation.</para>

      <para>Since representation of data is central to the approach, Rascal
      provides a rich set of built-in data types. To support extraction and
      analysis, parsing and advanced pattern matching are provided. High-level
      control structures make analysis and synthesis of complex datastructures
      simple.</para>
    </section>

    <section>
      <title>Benefits of Rascal</title>

      <para>Before you spend your time on studying the Rascal language it may
      help to first hear our elevator pitch about the main benefits offered by
      the language:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Familiar</emphasis> <emphasis
          role="bold">syntax</emphasis> in a <emphasis>what-you-see
          is-what-you-get style</emphasis> is used even for sophisticated
          concepts and this makes the language easy to learn and easy to
          use.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Sophisticated built-in data
          types</emphasis> provide standard solutions for many
          meta-programming problems.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Safety</emphasis> is achieved by finding
          most errors even before the program is executed and by making common
          errors like missing initializations or wrong pointers
          impossible.<remark> At the time of writing, this checking is done
          during execution.</remark></para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Local type inference</emphasis> makes
          local variable declarations redundant.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Pattern matching</emphasis> is used to
          analyze even the most complex datastructures.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Syntax definitions</emphasis> make it
          possible to define new and existing languages and to write tools for
          them.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Visiting</emphasis> makes it easy to
          traverse datastructures and to extract information from them or to
          synthesize results.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Templates</emphasis> enable easy code
          generation.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Functions as values </emphasis>permit
          programming styles with high re-use.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Generic types</emphasis> allow writing
          functions that are applicable for many different types.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Eclipse integration</emphasis> makes
          Rascal programming a breeze. All familiar tools are at your
          fingertips.</para>
        </listitem>
      </itemizedlist>

      <para>Interested? Read on!</para>
    </section>

    <section>
      <title>Aim and Scope of this Book</title>

      <formalpara>
        <title>Aim</title>

        <para>The aim of this book is to give an easy to understand but
        comprehensive overview of the Rascal language and to offer problem
        solving strategies to handle realistic problems that require
        meta-programming. Problems may range from security analysis and model
        extraction to software renovation, domain-specific languages and code
        generation.</para>
      </formalpara>

      <formalpara>
        <title>Audience</title>

        <para>The book is intended for students, practitioners and researchers
        who want to solve meta-programming problems.</para>
      </formalpara>

      <formalpara>
        <title>Background</title>

        <para>Readers should have some background in computer science,
        software engineering or programming languages. Familiarity with
        several main stream programming languages and experience with larger
        software projects will make it easier to appreciate the relevance of
        the meta-programming domain that Rascal is addressing. Some
        familiarity with concepts like sets, relations and pattern matching is
        assumed.</para>
      </formalpara>

      <formalpara>
        <title>Scope</title>

        <para>The scope of the book is limited to the Rascal language and its
        applications but does not address implementation aspects of the
        language.</para>
      </formalpara>
    </section>

    <section>
      <title>Installing and Running Rascal</title>

      <para>See http://www.meta-environment.org/Meta-Environment/Rascal for
      information.</para>
    </section>

    <section>
      <title>Reading Guide</title>

      <para><figure xml:id="figure.structure-manual">
          <title>Structure of this Book</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="manual-structure.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>The structure of this book is shown in <xref
      linkend="figure.structure-manual" />. It consists of five parts:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Introduction</emphasis>: gives a
          high-level overview of Rascal and consists of <xref
          linkend="section.why-a-new-language" /> and <xref
          linkend="section.rascal-concepts" /> . It also presents some simple
          examples in <xref linkend="section.classical-examples" />.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Problem Solving</emphasis>: describes
          the major problem solving strategies in Rascal's application domain,
          see <xref linkend="section.problem-solving-strategies" />.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Examples</emphasis>: gives a collection
          of larger examples, see <xref
          linkend="section.more-examples" />.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Reference</emphasis>: gives a detailed
          description of the Rascal language, see <xref
          linkend="section.rascal-language" />, and all built-in operators and
          library functions, see <xref linkend="section.lib" />.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Support</emphasis>: gives tables with
          operators, see <xref linkend="table.all-operators" />, and library
          functions, see <xref linkend="table.all-functions" />, a
          bibliography, see <xref linkend="section.bibliography" />, and a
          glossary, see <xref linkend="section.glossary" /> that explains many
          concepts that are used in this book and tries to make the book
          self-contained.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Typographic Conventions</title>

      <para>Rascal code fragments are always shown as a listing like
      this:<programlisting>  .. here is some Rascal code ...</programlisting>Interactive
      sessions are show as a screen like this:<!--Make a more clear typographic distinction between lsitings and screens--><screen><prompt>rascal&gt;</prompt> <userinput><replaceable>Command</replaceable>;</userinput>
<computeroutput><replaceable>Type</replaceable>: <replaceable>Value</replaceable></computeroutput></screen>where:</para>

      <itemizedlist>
        <listitem>
          <para><prompt>rascal&gt;</prompt> is the prompt of the Rascal
          system.</para>
        </listitem>

        <listitem>
          <para><userinput>Command</userinput> is an arbitrary Rascal
          statement or declaration typed in by the user.</para>
        </listitem>

        <listitem>
          <para><computeroutput>Type: Value</computeroutput> is the type of
          the answer followed by the value of the answer as computed by
          Rascal. In some cases, the response will simply be
          <computeroutput>ok</computeroutput> when there is no other
          meaningful answer to give.</para>

          <note>
            <para>For typographic reasons the output is abbreviated or
            slightly edited in some examples.</para>
          </note>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <?hard-pagebreak ?>

  <section xml:id="section.rascal-concepts">
    <title>Rascal Concepts</title>

    <para>Before explaining the Rascal language in more detail, we detail our
    elevator pitch a bit and give you a general understanding of the concepts
    on which the language is based.</para>

    <section>
      <title>Values</title>

      <para>Values are the basic building blocks of a language and the type of
      values determines how they may be used.</para>

      <para>Rascal is a value-oriented language. This means that values are
      immutable and are always freshly constructed from existing parts and
      that sharing and aliasing problems are completely avoided. The language
      does provide assignment to variables either as the result of an explicit
      assignment statement or as the result of a successful match.</para>
    </section>

    <section>
      <title>Data structures</title>

      <para>Rascal provides a rich set of datatypes. From Booleans
      (<keysym>bool</keysym>), infinite precision integers
      (<keysym>int</keysym>) and reals (<keysym>real</keysym>) to strings
      (<keysym>str</keysym>) that can act as templates with embedded
      expressions and statements. From source code locations
      (<keysym>loc</keysym>) based on an extension of Universal Resource
      Identifiers (URI) that allow precise description of text areas in local
      and remote files to lists (<keysym>list</keysym>), optionally labelled
      tuples (<keysym>tuple</keysym>), sets (<keysym>set</keysym>), and
      optionally labelled maps (<keysym>map</keysym>) and relations
      (<keysym>rel</keysym>). From untyped tree structures
      (<keysym>node</keysym>) to fully typed datastructures. Syntax trees that
      are the result of parsing source files are represented as datatypes
      (<keysym>Tree</keysym>). There is a wealth of built-in operators and
      library functions available on the standard datatypes. The basic Rascal
      datatypes are illustrated in <xref linkend="table.types" />.</para>

      <para>These builtin datatypes are closely related to ech other:</para>

      <itemizedlist>
        <listitem>
          <para>In a list all elements have the same static type and the order
          of elements matters. A list may contain the same value more than
          once.</para>
        </listitem>

        <listitem>
          <para>In a set all elements have the same static type and the order
          of elements does not matter. A set contains an element only once. In
          other words, duplicate elements are eliminated and no matter how
          many times an element is added to a set, it will occur in it only
          once.</para>
        </listitem>

        <listitem>
          <para>In a tuple alle elements (may) have a different static type.
          Each element of a tuple may have a label that can be used to select
          that element of the tuple.</para>
        </listitem>

        <listitem>
          <para>A relation is a set of tuples which all have the same static
          tuple type.</para>
        </listitem>

        <listitem>
          <para>A map is a binary relation consisting of (key, value) pairs.
          Key and value (may) have different static type and a key can only be
          associated with a value once</para>
        </listitem>
      </itemizedlist>

      <para>Untyped trees can be constructed with the builtin type <emphasis
      role="bold">node</emphasis>. User-defined datatypes allow the
      introduction of problem-specific types and are a subtype of <emphasis
      role="bold">node</emphasis>. A fragment of the abstract syntax for
      statements in a programming language would look as
      follows:<programlisting>data STAT = asgStat(Id name, EXP exp) 
          | ifStat(EXP exp,list[STAT] thenpart,
                           list[STAT] elsepart) 
          | whileStat(EXP exp, list[STAT] body) 
          ;</programlisting><table xml:id="table.types">
          <title>Basic Rascal Types</title>

          <tgroup cols="2">
            <colspec align="left" colwidth="2*" />

            <colspec align="left" colwidth="5*" />

            <thead>
              <row>
                <entry align="left">Type </entry>

                <entry align="left">Examples </entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>bool</literal></entry>

                <entry><literal>true</literal>,
                <literal>false</literal></entry>
              </row>

              <row>
                <entry><literal>int</literal></entry>

                <entry><literal>1</literal>, <literal>0</literal>,
                <literal>-1</literal>, <literal>123456789</literal></entry>
              </row>

              <row>
                <entry><literal>real</literal></entry>

                <entry><literal>1.0</literal>,
                <literal>1.0232e20</literal>,<literal> -25.5</literal></entry>
              </row>

              <row>
                <entry><literal>str</literal></entry>

                <entry><literal>"abc"</literal>,
                <literal>"first\nnext"</literal>, <literal>"result:
                &lt;X&gt;"</literal></entry>
              </row>

              <row>
                <entry><literal>loc</literal></entry>

                <entry><literal>|file:///etc/passwd|</literal></entry>
              </row>

              <row>
                <entry><literal>tuple[<replaceable>T</replaceable><subscript>1</subscript>,...,<replaceable>T</replaceable><subscript>n</subscript>]</literal></entry>

                <entry><literal>&lt;1,2&gt;</literal>, <literal>&lt;"john",
                43, true&gt;</literal></entry>
              </row>

              <row>
                <entry><literal>list[<replaceable>T</replaceable>]</literal></entry>

                <entry><literal>[]</literal>, <literal>[1]</literal>,
                <literal>[1,2,3]</literal>, <literal>[true, 2,
                "abc"]</literal></entry>
              </row>

              <row>
                <entry><literal>set[<replaceable>T</replaceable>]</literal></entry>

                <entry><literal>{}</literal>,
                <literal>{1,2,3,5,7}</literal>,<literal> {"john",
                4.0}</literal></entry>
              </row>

              <row>
                <entry><literal>rel[</literal><literal><replaceable>T</replaceable></literal><subscript>1</subscript><literal>,...,</literal><replaceable>T</replaceable><subscript>n</subscript>]</entry>

                <entry><literal>{&lt;1,2&gt;,&lt;2,3&gt;,&lt;1,3&gt;}</literal>,
                <literal>{&lt;1,10,100&gt;,
                &lt;2,20,200&gt;}</literal></entry>
              </row>

              <row>
                <entry><literal>map[<replaceable>T</replaceable>,
                <replaceable>U</replaceable>]</literal></entry>

                <entry><literal>()</literal>, <literal>(1:true,
                2:false)</literal>, <literal>("a":1, "b":2)</literal></entry>
              </row>

              <row>
                <entry><literal>node</literal></entry>

                <entry><literal>f()</literal>, <literal>add(x,y)</literal>,
                <literal>g("abc", [2,3,4])</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>Pattern Matching</title>

      <para>Pattern matching determines whether a given pattern matches a
      given value. The outcome can be false (no match) or true (a match). A
      pattern match that succeeds may assign values to variables.</para>

      <para>Pattern matching is <emphasis>the</emphasis> mechanism for case
      distinction (<keysym>switch</keysym> statement) and search
      (<keysym>visit</keysym> statement) in Rascal. Patterns can also be used
      in an explicit match operator <literal>:=</literal> and can then be part
      of larger boolean expressions. Since a pattern match may have more than
      one solution, local backtracking over the alternatives of a match is
      provided. Patterns can thus also be used in enumerators and control
      structures like <keysym>for</keysym> and <keysym>while</keysym>
      statement.</para>

      <para>A very rich pattern language is provided that includes string
      matching based on regular expressions, matching of abstract patterns,
      and matching of concrete syntax patterns. Some of the features that are
      provided are list (associative) matching, set (associative, commutative,
      identity) matching, and deep matching of descendant (nested) patterns.
      All these forms of matching can be used in a single pattern and can be
      nested. Patterns may contain variables that are bound when the match is
      successful. Anonymous (don't care) positions are indicated by an
      underscore (<literal>_</literal>).</para>

      <para>Here is a <emphasis>regular expression</emphasis> that matches a
      line of text, finds the first alphanumeric word in it, and extracts the
      word itself as well as the before and after it (<literal>\W</literal>
      matches all non-word characters; <literal>\w</literal> matches all word
      characters):</para>

      <para><programlisting>/^&lt;before:\W*&gt;&lt;word:\w+&gt;&lt;after:.*$&gt;/</programlisting></para>

      <para>Regular expressions follow the Java regular expression syntax with
      one exception: instead of using <literal>$1</literal>,
      <literal>$2</literal> as names for parts of the subject string that have
      been matched by a part of the regular expression we use the
      notation:<programlisting>&lt;<replaceable>Name</replaceable>:<replaceable>RegularExpression</replaceable>&gt;</programlisting></para>

      <para>If <replaceable>RegularExpression</replaceable> matches, the
      matched substring is assigned to string variable
      <replaceable>Name</replaceable>.</para>

      <para>The following <emphasis>abstract pattern</emphasis> matches the
      abstract syntax of a while statement defined earlier: <programlisting>whileStat(EXP Exp, list[STAT] Stats)</programlisting></para>

      <para>Variables in a pattern are either explicitly declared in the
      pattern itself---as done in the example---or they may be declared in the
      context in which the pattern occurs. So-called
      <emphasis>multi-variables</emphasis> in list and set patterns are
      declared by a <literal>*</literal> suffix. The above pattern can then be
      written as</para>

      <para><programlisting>whileStat(EXP Exp, Stats*)</programlisting>or, if
      you are not interested in the actual value of the statements as</para>

      <para><programlisting>whileStat(EXP Exp, _*)</programlisting></para>

      <para>When there is a grammar for this example language (in the form of
      an imported SDF definition), we can also write <emphasis>concrete
      patterns</emphasis> as we will see below.</para>
    </section>

    <section>
      <title>Enumerators</title>

      <para>Enumerators enumerate the values in a given (finite) domain, be it
      the elements in a list, the substrings of a string, or all the nodes in
      a tree. Each value that is enumerated is first matched against a pattern
      before it can possibly contribute to the result of the enumerator.
      Examples are:</para>

      <para><programlisting>int x &lt;- { 1, 3, 5, 7, 11 }
int x &lt;- [ 1 .. 10 ]
/asgStat(Id name, _) &lt;- P</programlisting></para>

      <para>The first two produce the integer elements of a set of integers,
      respectively, a range of integers. The third enumerator does a deep
      traversal (as denoted by the descendant operator <literal>/</literal>)
      of the complete program <literal>P</literal> (that is assumed to have a
      <literal>PROGRAM</literal> as value) and only yields statements that
      match the assignment pattern. Note the use of an anonymous variable at
      the <literal>EXP</literal> position in the pattern.</para>
    </section>

    <section>
      <title>Comprehensions</title>

      <para>A comprehension is a notation inspired by mathematical set-builder
      notation that helps to write succinct definitions of lists and
      sets.</para>

      <para>Rascal generalizes comprehensions in various ways. Comprehensions
      exist for lists, sets and maps. A comprehension consists of an
      expression that determines the successive elements to be included in the
      result and a list of enumerators and tests (boolean expressions). The
      enumerators produce values and the tests filter them. A standard example
      is</para>

      <para><programlisting>{ x * x | int x &lt;- [1 .. 10], x % 3 == 0 }</programlisting></para>

      <para>which returns the set <literal>{9, 36, 81}</literal>, i.e., the
      squares of the integers in the range <literal>[ 1 .. 10 ]</literal> that
      are divisible by 3. A more intriguing example is</para>

      <para><programlisting>{name | /asgStat(Id name, _) &lt;- P}</programlisting></para>

      <para>which returns a list of all identifiers that occur on the left
      hand side of assignment statements in program
      <literal>P</literal>.</para>
    </section>

    <section>
      <title>Control structures</title>

      <para>Control structures like <literal>if</literal> and
      <literal>while</literal> statement are driven by Boolean expressions,
      for instance<programlisting>if(N &lt;= 0)
     return 1; 
  else
     return N * fac(N - 1);</programlisting>Actually, combinations of
      generators and Boolean expressions can be used to drive the control
      structures. For instance,</para>

      <para><programlisting>
for(/asgStat(Id name, _) &lt;- P, size(name) &gt; 10){
    println(Id);
}</programlisting></para>

      <para>prints all identifiers in assignment statements that consist of
      more than 10 characters.</para>
    </section>

    <section>
      <title>Switching</title>

      <para>The switch statement as known from C and Java is generalized: the
      subject value to switch on may be an arbitrary value and the cases are
      arbitrary patterns. When a match fails, all its side-effects are undone
      and when it succeeds the statements associated with that case are
      executed. Here is an example where we take a program P and distinguish
      two cases for while and if statement:<programlisting>switch (P){
case whileStat(EXP Exp, Stats*):
     println("A while statement");
case ifStat(Exp, Stats1*, Stat2*):
     println("An if statement");
}</programlisting></para>
    </section>

    <section>
      <title>Visiting</title>

      <para>Visiting the elements of a datastructure is one of the most common
      operations in our domain and the visitor design pattern is a solution
      known to every software engineer. Given a tree-like datastructure we
      want to perform an operation on some (or all) nodes of the tree. The
      purpose of the visitor design pattern is to decouple the logistics of
      visiting each node from the actual operation. In Rascal the logistics of
      visiting is completely automated.</para>

      <para>Visiting is achieved by way of visit expressions that resemble the
      switch statement. A visit expression consists of an expression that may
      yield an arbitrarily complex subject value and a number of cases. All
      the elements of the subject are visited and when one of the cases
      matches the statements associated with that case are executed. These
      cases may:</para>

      <itemizedlist>
        <listitem>
          <para>cause some side effect, i.e., assign a value to local or
          global variables;</para>
        </listitem>

        <listitem>
          <para>execute an <literal>insert</literal> statement that replaces
          the current element;</para>
        </listitem>

        <listitem>
          <para>execute a <literal>fail</literal> statement that causes the
          match for the current case to fail (and undoing all side-effects due
          to the successful match itself and the execution of the statements
          so far).</para>
        </listitem>
      </itemizedlist>

      <para>Side-effects including assignments to local and global variables
      in the Rascal program are undone on failure. External side-effects like
      I/O and side-effects in user-defined Java code are not undone.</para>

      <para>The value of a visit expression is the original subject value with
      all replacements made as dictated by matching cases. The traversal order
      in a visit expressions can be explicitly defined by the programmer. An
      example of visiting is given in <xref
      linkend="section.colored-trees" />.</para>
    </section>

    <section>
      <title>Functions</title>

      <para>Functions allow the definition of frequently used operations. They
      have a name and formal parameters. They are explicitly declared and are
      fully typed. Here is an example of a function that counts the number of
      assignment statements in a program:</para>

      <para><programlisting>int countAssignments(PROGRAM P){
    int n = 0;
    visit (P){
    case asgStat(_, _):
         n += 1;
    }
    return n;
}</programlisting>Functions can also be used as values thus enabling
      higher-order functions. Consider the following
      declarations:<programlisting>int double(int x) { return 2 * x; }

int triple(int x) { return 3 * x; }

int f(int x, int (int) multi){ return multi(x); }</programlisting></para>

      <para>The functions double and triple simply multiply their argument
      with a constant. Function f is, however, more interesting. It takes an
      integer <literal>x</literal> and a function <literal>multi</literal>
      (with integer argument and integer result) as argument and applies
      <literal>multi</literal> to its own argument. <literal>f(5,
      triple)</literal> will hence return <literal>15</literal>. Function
      values can also be created anonymously as illustrated by the following,
      alternative, manner of writing this same call to f:</para>

      <para><programlisting>f(5, int (int y){return 3 * y;});</programlisting>Here
      the second argument of f is an anonymous function that is declared her
      on the spot.</para>
    </section>

    <section>
      <title>Syntax Definition and Parsing</title>

      <para><warning>
          <para>Verify this section.</para>
        </warning>All source code analysis projects need to extract
      information directly from the source code. There are two main approaches
      to this:</para>

      <itemizedlist>
        <listitem>
          <para>Use regular expressions to extract useful, but somewhat
          superficial, information. This can be achieved using regular
          expression patterns.</para>
        </listitem>

        <listitem>
          <para>Use syntax analysis to extract the complete, nested, structure
          of the source code in the form of a syntax tree.</para>
        </listitem>
      </itemizedlist>

      <para>In Rascal, we reuse the Syntax Definition Formalism (SDF) and its
      tooling. See <link
      xlink:href="http://www.meta-environment.org/Meta-Environment/Documentation">http://www.meta-environment.org/Meta-Environment/Documentation</link>
      for tutorials and manuals for SDF.</para>

      <para>SDF modules define grammars and these modules can be imported in a
      Rascal module. These grammar rules can be applied in writing concrete
      patterns to match parts of parsed source code. Here is an example of the
      same pattern we saw above, but now in concrete form:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>

      <para>Importing an SDF module has the following effects:</para>

      <itemizedlist>
        <listitem>
          <para>All non-terminals (<emphasis>sorts</emphasis> in SDF jargon)
          that are used in the imported grammar are implicitly declared as
          Rascal types. This makes it possible to handle parse trees and parse
          tree fragments as fully typed values and assign them to variables,
          store them in larger datastructures or pass them as arguments to
          functions.</para>
        </listitem>

        <listitem>
          <para>For all <emphasis>start symbols</emphasis> of the grammar
          <emphasis>parse functions</emphasis> are implicitly declared that
          can parse source files according to a specific start symbol.</para>
        </listitem>

        <listitem>
          <para>Concrete syntax patterns for that specific grammar can be
          used.</para>
        </listitem>

        <listitem>
          <para>Concrete syntax constructors can be used that allow the
          construction of new parse trees.</para>
        </listitem>
      </itemizedlist>

      <para>The following example parses a Java compilation unit from a text
      file and counts the number of method declarations:</para>

      <programlisting>module Count
import languages::syntax::Java;
import ParseTree;

public int countMethods(loc file){
  int n = 0;
  for(/MethodDeclaration md &lt;- parse(CompilationUnit, file))
      n += 1;
  return n;
}</programlisting>

      <para>First observe that importing the Java grammar has as effect that
      non-terminals like <literal>MethodDeclaration</literal> and
      <literal>CompilationUnit</literal> become available as type in the
      Rascal program.</para>

      <para>The library function <literal>parse</literal> takes a non-terminal
      (CompilationUnit) and a location as arguments and parses the contents of
      the location according to the given non-terminal. Next a match for
      embedded <literal>MethodDeclaration</literal>s is done in the
      enumetrator of the <keysym>for</keysym> statement. This example ignores
      many potential error issues but does illustrate some of Rascal's syntax
      and parsing features.</para>
    </section>

    <section>
      <title>Rewrite Rules</title>

      <para>A <emphasis>rewrite rule</emphasis> is a recipe how to simplify
      values. Remember: <literal>(a + b)<superscript>2</superscript> =
      a<superscript>2</superscript> + 2ab +
      b<superscript>2</superscript></literal>? A rewrite rule has a pattern as
      left-hand side (here: <literal>(a +
      b)<superscript>2</superscript></literal>) and a replacement as
      right-hand side (here: <literal>a<superscript>2</superscript> + 2ab +
      b<superscript>2</superscript></literal>). Given a value and a set of
      rewrite rules the patterns are tried on every subpart of the value and
      replacements are made on the way. This is repeated as long as some
      pattern matches.</para>

      <para>Rewrite rules are the only implicit control mechanism in the
      language and are used to maintain invariants during computations. For
      example, in a package for symbolic differentiation it is desirable to
      keep expressions in simplified form in order to avoid intermediate
      results like <literal>sum(product(1, x), product(0, y))</literal> that
      can be simplified to <literal>x</literal>. The following rules achieve
      this:<programlisting>rule simplify1 product(1, Expression e) =&gt; e;
rule simplify2 product(Expression e, 1) =&gt; e;
rule simplify3 product(0, Expression e) =&gt; 0;
rule simplify4 product(Expression e, 0) =&gt; 0;
rule simplify5 sum(0, Expression e)     =&gt; e;
rule simplify6 sum(Expression e, 0)     =&gt; e;</programlisting>Whenever a
      new expression is constructed during symbolic differentiation, these
      rules are applied to that expression and all its subexpressions and when
      a pattern at the left-hand side of a rule applies the matching
      subexpression is replaced by the right-hand side of the rule. This is
      repeated as long as any rule can be applied.</para>

      <para>Since rewrite rules are activated automatically, one may always
      assume that expressions are in simplified form.</para>

      <para>Rewrite rules are <emphasis>computationally complete</emphasis>,
      in other words any computable function can be defined using rewrite
      rules, including functions that do not terminate. This is a point of
      attention when using rewrite rules.</para>
    </section>

    <section>
      <title>Constraint solving</title>

      <para>Many problems can be solved by forms of <emphasis>constraint
      solving</emphasis>. This is a declarative way of programming: specify
      the constraints that a problem solution should satisfy and how potential
      solutions can be generated. The actual solution (if any) is found by
      enumerating solutions and testing their compliance with the
      constraints.</para>

      <para>Rascal provides a <literal>solve</literal> statement that helps
      writing constraint solvers. A typical example is dataflow analysis where
      the propagation of values through a program can be described by a set of
      equations. Their solution can be found with the <literal>solve</literal>
      statement. See <xref linkend="section.dataflow" /> for examples.</para>
    </section>

    <section>
      <title>Other features</title>

      <para>All language features (including the ones just mentioned) are
      described in more detail later on in this book. Some features we have
      not yet mentioned are:</para>

      <itemizedlist>
        <listitem>
          <para>Rascal programs consist of modules that are organized in
          packages.</para>
        </listitem>

        <listitem>
          <para>Modules can import other modules.</para>
        </listitem>

        <listitem>
          <para>The visibility of entities declared in modules can be
          controlled by a public/private mechanism.</para>
        </listitem>

        <listitem>
          <para>Datastructures may have annotations that can be explicitly
          used and modified.</para>
        </listitem>

        <listitem>
          <para>There is an extensive library for builtin datatypes,
          input/output, fact extraction from Java source code, visualization,
          and more.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Typechecking and Execution</title>

      <para>Rascal has a statically checked type system that prevents type
      errors and uninitialized variables at runtime. There are no runtime type
      casts as in Java and there are therefore less opportunities for run-time
      errors. The language provides <emphasis>higher-order, parametric,
      polymorphism</emphasis>. A type aliasing mechanism allows documenting
      specific uses of a type. Built-in operators are heavily overloaded. For
      instance, the operator + is used for addition on integers and reals but
      also for list concatenation, set union etc.</para>

      <para>The flow of Rascal program execution is completely explicit.
      Boolean expressions determine choices that drive the control structures.
      Rewrite rules form the only exception to the explicit control flow
      principle. Only local backtracking is provided (no surprise) in the
      context of boolean expressions and pattern matching; side effects are
      undone in case of backtracking.</para>
    </section>
  </section>

  <?hard-pagebreak ?>

  <section xml:id="section.classical-examples">
    <title>Some Classical Examples</title>

    <para>The following simple examples will help you to grasp the main
    features of Rascal quickly. You can also look ahead and consult <xref
    linkend="section.rascal-language" /> for details of the language or <xref
    linkend="section.lib" /> for specific operators or functions.</para>

    <section>
      <title>Hello</title>

      <para>The ubiquitous hello world program looks in Rascal as
      follows:<screen><prompt>rascal&gt;</prompt> <userinput>import IO;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>println("Hello, this is my first Rascal program");</userinput>
<computeroutput>Hello, this is my first Rascal program
ok</computeroutput>
</screen>First, the library module IO (see <xref linkend="section.lib-IO" />)
      is imported since hello world requires printing. Next, we call
      <literal>println</literal> and proudly observe our first Rascal
      output!</para>

      <para>A slightly more audacious approach is to wrap the print statement
      in a function and call it:</para>

      <para><screen><prompt>rascal&gt; </prompt><userinput>void hello() {
   println("Hello, this is my first Rascal program");
}</userinput>
<computeroutput>void (): void hello();</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>hello();</userinput>
<computeroutput>Hello, this is my first Rascal program
ok</computeroutput></screen>Don't get scared by the <computeroutput>void ():
      void hello();</computeroutput> that you get back when typing in the
      <literal>hello</literal> function. The first <computeroutput>void
      ()</computeroutput> part says the result is a function that returns
      nothing, and the second part <computeroutput>void
      hello()</computeroutput> summarizes its value (or would you prefer a hex
      dump?).</para>

      <para>The summit of hello-engineering can be reached by placing all the
      above in a separate module:<programlisting>module demo::Hello
	import IO;

public void hello() {
   println("Hello, this is my first Rascal program");
}</programlisting>Note that we added a public modifier to the definition of
      hello, since we want it to be visible outside the Hello module. Using
      this Hello module is now simple:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Hello;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>hello();</userinput>
<computeroutput>Hello, this is my first Rascal program
ok</computeroutput></screen><note>
          <para>All examples in this book can be found in the
          <literal>demo</literal> directory of the Rascal distribution. That
          is why we prefix all names of examples modules with
          <literal>demo::</literal>.</para>
        </note></para>
    </section>

    <section>
      <title>Factorial</title>

      <para>Here is another classical example, computing the factorial
      function:<programlisting>module demo::Factorial

public int fac(int N)
{
  if(N &lt;= 0)
     return 1; 
  else
     return N * fac(N - 1);
}</programlisting></para>

      <para>It uses a conditional statement to distinguish cases and here is
      how to use it:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Factorial;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>fac(47);</userinput>
<computeroutput>int: 2586232415111681806429643551536119799691976323891200
00000000</computeroutput></screen></para>

      <para>Indeed, Rascal has infinite length integers.</para>
    </section>

    <section xml:id="section.colored-trees">
      <title>Colored Trees</title>

      <para>Suppose we have binary trees---trees with exactly two
      children--that have integers as their leaves. Also suppose that our
      trees can have red and black nodes. Such trees can be defined as
      follows:<programlisting>module demo::ColoredTrees

data ColoredTree = 
            leaf(int N) 
          | red(ColoredTree left, ColoredTree right) 
          | black(ColoredTree left, ColoredTree right);</programlisting></para>

      <para>We can use them as follows:</para>

      <para><screen><prompt>rascal&gt;</prompt> <userinput>import demo::ColoredTrees;</userinput>
<computeroutput>ok
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>rb = red(black(leaf(1), red(leaf(2),leaf(3))), 
                 black(leaf(3), leaf(4)));</userinput>
<computeroutput>ColoredTree: red(black(leaf(1),red(leaf(2),leaf(3))),
                 black(leaf(3),leaf(4)))</computeroutput></screen>We define
      two operations on ColoredTrees, one to count the red nodes, and one to
      add the values contained in all leaves:<programlisting>// continuing module demo::ColoredTrees

public int cntRed(ColoredTree t){
   int c = 0;
   visit(t) {
     case red(_,_): c = c + 1;<co xml:id="co.cntRed" />
   };
   return c;
}

public int addLeaves(ColoredTree t){
   int c = 0;
   visit(t) {
     case leaf(int N): c = c + N;<co xml:id="co.cntLeaves" />
   };
   return c;
}</programlisting><calloutlist>
          <callout arearefs="co.cntRed">
            <para>Visit all the nodes of the tree and increment the counter
            <literal>c</literal> for each red node.</para>
          </callout>

          <callout arearefs="co.cntLeaves">
            <para>Visit all nodes of the tree and add the integers in the leaf
            nodes.</para>
          </callout>
        </calloutlist></para>

      <para>This can be used as follows:</para>

      <para><screen><prompt>rascal&gt;</prompt> <userinput>cntRed(rb);</userinput>
<computeroutput>int: 2</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>addLeaves(rb);</userinput>
<computeroutput>int: 13</computeroutput></screen></para>

      <para>A final touch to this example is to introduce green nodes and to
      replace all red nodes by green ones:<programlisting>// continuing module demo::ColoredTrees

data ColoredTree = green(ColoredTree left, 
                         ColoredTree right);<co xml:id="co.Tree-green" />

public ColoredTree makeGreen(ColoredTree t){
   return visit(t) {
     case red(l, r) =&gt; green(l, r)      <co xml:id="co.makeGreen" />
   };
}</programlisting><calloutlist>
          <callout arearefs="co.Tree-green">
            <para>Extend the ColoredTree datatype with a new green
            constructor.</para>
          </callout>

          <callout arearefs="co.makeGreen">
            <para>Visit all nodes in the tree and replace red nodes by green
            ones. Note that the variables <literal>l</literal> and
            <literal>r</literal> are introduced here without a
            declaration.</para>
          </callout>
        </calloutlist></para>

      <para>This is used as follows:<screen><prompt>rascal&gt;</prompt> <userinput>makeGreen(rb);</userinput>
<computeroutput>ColoredTree: green(black(leaf(1),green(leaf(2),leaf(3))),
                   black(leaf(3),leaf(4)))</computeroutput></screen></para>
    </section>

    <section>
      <title>Word Replacement</title>

      <para>Suppose you are in the publishing business and are responsible for
      the systematic layout of publications. Authors do not systematically
      capitalize words in titles---"Word replacement" instead of Word
      Replacement"--- and you want to correct this. Here is one way to solve
      this problem:<programlisting>module demo::WordReplacement
import String;

public str capitalize(str word)
{
   if(/^&lt;letter:[a-z]&gt;&lt;rest:.*$&gt;/ := word) <co
            xml:id="co.capitalize-regexp" />
      return toUpperCase(letter) + rest;<co
            xml:id="co.capitalize-regexp-return1" />
   else
     return word;<co xml:id="co.capitalize-regexp-return2" />
}</programlisting><calloutlist>
          <callout arearefs="co.capitalize-regexp">
            <para>The function capitalize takes a string as input and
            capitalizes its first character if that is a letter. This is done
            using a regular expression match that anchors the match at the
            beginning (<literal>^</literal>), expects a single letter and
            assigns it to the variable letter
            (<literal>letter:[a-z]</literal>) followed by an arbitrary
            sequence of letters until the end of the string that is assigned
            to the variable rest (<literal>&lt;rest:.*$&gt;</literal>).</para>
          </callout>

          <callout arearefs="co.capitalize-regexp-return1">
            <para>If the regular expression matches we return a new string
            with the first letter capitalized.</para>
          </callout>

          <callout arearefs="co.capitalize-regexp-return2">
            <para>Otherwise we return the word unmodified.</para>
          </callout>
        </calloutlist></para>

      <para>The next challenge is how to capitalize all the words in a string.
      Here are two solutions:<programlisting>// continuing module demo::WordReplacement

public str capAll1(str S)
{
 result = "";
 while (/^&lt;before:\W*&gt;&lt;word:\w+&gt;&lt;after:.*$&gt;/ := S) { <co
            xml:id="co.capAll1-regexp" />
    result += before + capitalize(word);
    S = after;
  }
  return result;
}

public str capAll2(str S)
{
   return visit(S){<co xml:id="co.capAll2-visit" />
     case /&lt;word:\w+&gt;/i <co xml:id="co.capAll2-match" /> =&gt; capitalize(word)<co
            xml:id="co.capAll1-insert" />
   };
}</programlisting><calloutlist>
          <callout arearefs="co.capAll1-regexp">
            <para>In the first solution <literal>capAll1</literal> we just
            loop over all the words in the string and capitalize each word.
            The variable <literal>result</literal> is used to collect the
            successive capitalized words.</para>
          </callout>

          <callout arearefs="co.capAll2-visit">
            <para>In the second solution we use a visit expression to visit
            all the substrings of S. Each matching case advances the substring
            by the length of the pattern it matches and replaces that pattern
            by another string. If no case matches the next substring is
            tried.</para>
          </callout>

          <callout arearefs="co.capAll2-match">
            <para>The single case matches a word (note that
            <literal>\w</literal> matches a word character).</para>
          </callout>

          <callout arearefs="co.capAll1-insert">
            <para>When the case matches a word, it is replaced by a
            capitalized version.</para>
          </callout>
        </calloutlist></para>

      <para>We can apply this all as follows:</para>

      <para><screen><prompt>rascal&gt;</prompt> <userinput>import demo::WordReplacement;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>capitalize("rascal");</userinput>
<computeroutput>str: "rascal"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>capAll1("rascal is great");</userinput>
<computeroutput>str: "Rascal Is Great"</computeroutput></screen></para>
    </section>

    <section>
      <title>Template Programming</title>

      <para>Many websites and code generators use template-based code
      generation. They start from a text template that contains embedded
      variables and code. The template is "executed" by replacing the embedded
      variables and code by their string value. A language like PHP is popular
      for this feature. Let's see how we can do this in Rascal. Given a
      mapping from field names to their type, the task at hand is to generate
      a Java class that contains those fields and corresponding getters and
      setters. Given a mapping</para>

      <para><programlisting>public map[str, str] fields = (
   "name" : "String",
   "age" : "Integer",
   "address" : "String"
);</programlisting>we expect the call<programlisting>genClass("Person", fields)</programlisting>to
      produce the following output:<programlisting>    public class Person {

        private Integer age;
        public void setAge(Integer age) {
          this.age = age;
        }
        public Integer getAge() {
          return age;
        }

        private String name;
        public void setName(String name) {
          this.name = name;
        }
        public String getName() {
          return name;
        }

        private String address;
        public void setAddress(String address) {
          this.address = address;
        }
        public String getAddress() {
          return address;
        }

    }</programlisting>This is achieved by the following definition of
      <literal>genClass</literal>:</para>

      <para><programlisting>module demo::StringTemplate

import String;

public str capitalize(str s) {
  return toUpperCase(substring(s, 0, 1)) + substring(s, 1);
}

public str genClass(str name, map[str,str] fields) {
  return "
    public class &lt;name&gt; {
      &lt;for (x &lt;- fields) {&gt;
        private &lt;fields[x]&gt; &lt;x&gt;;
        public void set&lt;capitalize(x)&gt;(&lt;fields[x]&gt; &lt;x&gt;) {
          this.&lt;x&gt; = &lt;x&gt;;
        }
        public &lt;fields[x]&gt; get&lt;capitalize(x)&gt;() {
          return &lt;x&gt;;
        }
      &lt;}&gt;
    }
  ";
}
</programlisting>Observe how the <keysym>for</keysym> statement and
      expressions that access the map fields that are embedded in the string
      constant customize the given template for a Java class. The details of
      string interpolation are explained in <xref
      linkend="section.elementary-types" />.</para>
    </section>
  </section>

  <?hard-pagebreak ?>

  <section xml:id="section.problem-solving-strategies">
    <title>Problem Solving Strategies</title>

    <para>Before we study more complicated examples, it is useful to discuss
    some general problem solving strategies that are relevant in Rascal's
    application domain.</para>

    <para>To appreciate these general strategies, it is good to keep some
    specific problem areas in mind:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Documentation generation</emphasis>:
        extract facts from source code and use them to generate textual
        documentation. A typical example is generating web-based documentation
        for legacy languages like Cobol and PL/I.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Metrics calculation</emphasis>: extract
        facts from source code (and possibly other sources like test runs) and
        use them to calculate code metrics. Examples are cohesion and coupling
        of modules and test coverage.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Model extraction</emphasis>: extract facts
        from source code and use them to build an abstract model of the source
        code. An example is extracting lock and unlock calls from source code
        and to build an automaton that guarantees that lock/unlock occurs in
        pairs along every control flow path.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Model-based code generation</emphasis>:
        given a high-level model of a software system, described in UML or
        some other modelling language, transform this model into executable
        code. UML-to-Java code generation falls in this category.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Source-to-source
        transformation</emphasis>: large-scale, fully automated, source code
        transformation with certain objectives like removing deprecated
        language features, upgrading to newer APIs and the like.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Interactive refactoring</emphasis>: given
        known "code smells" a user can interactively indicate how these smells
        should be removed. The refactoring features in Eclipse and Visual
        Studio are examples.</para>
      </listitem>
    </itemizedlist>

    <para>With these examples in mind, we can study the overall problem
    solving workflow as shown in <xref linkend="figure.problem-solving" />. It
    consists of three optional phases:</para>

    <itemizedlist>
      <listitem>
        <para>Is <emphasis role="bold">extraction needed</emphasis> to solve
        the problem, then define the extraction phase, see <xref
        linkend="section.defining-extraction" />.</para>
      </listitem>

      <listitem>
        <para>Is <emphasis role="bold">analysis needed</emphasis>, then define
        the analysis phase, see <xref
        linkend="section.defining-analysis" />.</para>
      </listitem>

      <listitem>
        <para>Is <emphasis role="bold">synthesis needed</emphasis>, then
        define the synthesis phase, see <xref
        linkend="section.defining-synthesis" />.</para>
      </listitem>
    </itemizedlist>

    <para><figure xml:id="figure.problem-solving">
        <title>General 3-Phased Problem Solving Workflow</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="problem-solving.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Each phase is subject to a validation and improvement workflow as
    shown in <xref linkend="figure.validation" />. Each individual phase as
    well as the combination of phases may introduce errors and has thus to be
    carefully validated. In combination with the detailed strategies for each
    phase, this forms a complete approach for problem solving and validation
    using Rascal.<figure xml:id="figure.validation">
        <title>Validation and Improvement Workflow</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="validation.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>A major question in every problem solving situation is how to
    determine the requirements for each phase of the solution. For instance,
    how do we know what to extract from the source code if we do not know what
    the desired end results of the project are? The standard solution is to
    use a workflow for requirements gathering that is the inverse of the
    phases needed to solve the complete problem. This is shown in <xref
    linkend="figure.requirements" /> and amounts to the phases:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Requirements of the synthesis
        phase</emphasis>. This amounts to making an inventory of the desired
        results of the whole project and may include generated source code,
        abstract models, or visualizations.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Requirements of the analysis
        phase</emphasis>. Once these results of the synthesis phase are known,
        it is possible to list the analysis results that are needed to
        synthesize desired results. Possible results of the analysis phase
        include type information, structural information of the original
        source.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Requirements of the extraction
        phase</emphasis>. As a last step, one can make an inventory of the
        facts that have to be extracted to form the starting point for the
        analysis phase. Typical facts include method calls, inheritance
        relations, control flow graphs, usage patterns of specific library
        functions or language constructs.</para>
      </listitem>
    </itemizedlist>

    <para><figure xml:id="figure.requirements">
        <title>Requirements Workflow</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="requirements.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>You will have no problem in identifying requirements for each phase
    when you apply them to a specific example from the list given
    earlier.</para>

    <para>When these requirements have been established, it becomes much
    easier to actually carry out the project using the three phases of <xref
    linkend="figure.problem-solving" />.</para>

    <section xml:id="section.defining-extraction">
      <title>Defining Extraction</title>

      <para>How can we extract facts from the <emphasis>System under
      Investigation</emphasis> (SUI) that we are interested in? The extraction
      workflow is shown in <xref linkend="figure.define-extraction" />and
      consists of the following steps:</para>

      <itemizedlist>
        <listitem>
          <para>First and foremost we have to determine which facts we need.
          This sounds trivial, but it is not. The problem is that we have to
          anticipate which facts will be needed in the next---not yet
          defined---analysis phase. A common approach is to use look-ahead and
          to sketch the queries that are likely to be used in the analysis
          phase and to determine which facts are needed for them. Start with
          extracting these facts and refine the extraction phase when the
          analysis phase is completely defined.</para>
        </listitem>

        <listitem>
          <para>If relevant facts are already available (and they are
          reliable!) then we are done. This may happen when you are working on
          a system that has already been analyzed by others.</para>
        </listitem>

        <listitem>
          <para>Otherwise you need the source code of the SUI. This
          requires:</para>

          <itemizedlist>
            <listitem>
              <para>Checking that all sources are available (and can be
              compiled by the host system on which they are usually compiled
              and executed). Due to missing or unreliable configuration
              management on the original system this may be a labour-intensive
              step that requires many iterations.</para>
            </listitem>

            <listitem>
              <para>Determining in which languages the sources are written. In
              larger systems it is common that three or more different
              languages are being used.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If there are reliable third-party extraction tools available
          for this language mix, then we only have to apply them and we are
          done. Here again, validation is needed that the extracted facts are
          as expected.</para>
        </listitem>

        <listitem>
          <para>The extraction may require syntax analysis. This is the case
          when more structural properties of the source code are needed such
          as the flow-of-control, nesting of declarations, and the like. There
          two approaches here:</para>

          <itemizedlist>
            <listitem>
              <para>Use a third-party parser, convert the source code to parse
              trees and do the further processing of these parse trees in
              Rascal. The advantage is that the parser can be re-used, the
              disadvantage is that data conversion is needed to adapt the
              generated parse tree to Rascal. Validate that the parser indeed
              accepts the language the SUI is written in, since you will not
              be the first who has been bitten by the language dialect monster
              when it turns out that the SUI uses a local variant that
              slightly deviates from a mainstream language.</para>
            </listitem>

            <listitem>
              <para>Use an existing SDF definition of the source language or
              write your own definition. In both cases you can profit from
              Rascal's seamless integration with SDF. Be aware, however, that
              writing a grammar for a non-trivial language is a major
              undertaking and may require weeks to month of work. Whatever
              approach you choose, validate that the result.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The extraction phase may only require lexical analysis. This
          happens when more superficial, textual, facts have to be extracted
          like procedure calls, counts of certain statements and the like. Use
          Rascal's full regular expression facilities to do the lexical
          analysis.</para>
        </listitem>
      </itemizedlist>

      <para>It may happen that the facts extracted from the source code are
      <emphasis>wrong</emphasis>. Typical error classes are:</para>

      <itemizedlist>
        <listitem>
          <para>Extracted facts are <emphasis>wrong</emphasis>: the extracted
          facts incorrectly state that procedure <literal>P</literal> calls
          procedure <literal>Q</literal> but this is contradicted by a source
          code inspection. This may happen when the fact extractor uses a
          conservative approximation when precise information is not
          statically available. In the language C, when procedure P performs
          an indirect call via a pointer variable, the approximation may be
          that P calls all procedures in the procedures.</para>
        </listitem>

        <listitem>
          <para>Extracted facts are <emphasis>incomplete</emphasis>: the
          inheritance between certain classes in Java code is missing.</para>
        </listitem>
      </itemizedlist>

      <para>The strategy to validate extracted facts differ per case but here
      are three strategies:</para>

      <itemizedlist>
        <listitem>
          <para>Post process the extracted facts (using Rascal, of course) to
          obtain trivial facts about the source code such as total lines of
          source code and number of procedures, classes, interfaces and the
          like. Next validate these trivial facts with tools like
          <literal>wc</literal> (word and line count), <literal>grep</literal>
          (regular expression matching) and others.</para>
        </listitem>

        <listitem>
          <para>Do a manual fact extraction on a small subset of the code and
          compare this with the automatically extracted facts.</para>
        </listitem>

        <listitem>
          <para>Use another tool on the same source and compare results
          whenever possible. A typical example is a comparison of a call
          relation extracted with different tools.</para>
        </listitem>
      </itemizedlist>

      <para><figure xml:id="figure.define-extraction">
          <title>Extraction Workflow</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="define-extraction.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The Rascal features that are most frequently used for extraction
      are:</para>

      <itemizedlist>
        <listitem>
          <para>Regular expression patterns to extract textual facts from
          source code.</para>
        </listitem>

        <listitem>
          <para>Syntax definitions and concrete patterns to match syntactic
          structures in source code.</para>
        </listitem>

        <listitem>
          <para>Pattern matching (used in many Rascal statements).</para>
        </listitem>

        <listitem>
          <para>Visits to traverse syntax trees and to locally extract
          information.</para>
        </listitem>

        <listitem>
          <para>The repertoire of built-in datatypes (like lists, maps, sets
          and relations) to represent the extracted facts.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.defining-analysis">
      <title>Defining Analysis</title>

      <para>The analysis workflow is shown in <xref
      linkend="figure.define-analysis" /> and consists of two steps:</para>

      <itemizedlist>
        <listitem>
          <para>Determine the results that are needed for the synthesis
          phase.</para>
        </listitem>

        <listitem>
          <para>Write the Rascal code to perform the analysis. This may amount
          to:</para>

          <itemizedlist>
            <listitem>
              <para>Reordering extracted facts to make them more suitable for
              the synthesis phase.</para>
            </listitem>

            <listitem>
              <para>Enriching extracted facts. Examples are computing
              transitive closures of extracted facts (e.g., A may call B in
              one or more calls), or performing data reduction by abstracting
              aways details (i.e., reducing a program to a finite
              automaton).</para>
            </listitem>

            <listitem>
              <para>Combining enriched, extracted, facts to create new
              facts.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>As before, validate, validate and validate the results of
      analysis. Essentially the same approach can be used as for validating
      the facts. Manual checking of answers on random samples of the SUI may
      be mandatory. It also happens frequently that answers inspire new
      queries that lead to new answers, and so on.</para>

      <para><figure xml:id="figure.define-analysis">
          <title>Analysis Workflow</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="define-analysis.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The Rascal features that are frequently used for analysis
      are:</para>

      <itemizedlist>
        <listitem>
          <para>List, set and map comprehensions.</para>
        </listitem>

        <listitem>
          <para>The built-in operators and library functions, in particular
          for lists, maps, sets and relations.</para>
        </listitem>

        <listitem>
          <para>Pattern matching (used in many Rascal statements).</para>
        </listitem>

        <listitem>
          <para>Visits and switches to further process extracted facts.</para>
        </listitem>

        <listitem>
          <para>The solve statement for constraint solving.</para>
        </listitem>

        <listitem>
          <para>Rewrite rules to simplify results and to enforce
          constraints.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.defining-synthesis">
      <title>Defining Synthesis</title>

      <para>Results are synthesized as shown in <xref
      linkend="figure.define-synthesis" />. This consists of the following
      steps:</para>

      <itemizedlist>
        <listitem>
          <para>Determine the results of the synthesis phase. Wide range of
          results is possible including:</para>

          <itemizedlist>
            <listitem>
              <para>Generated source code.</para>
            </listitem>

            <listitem>
              <para>Generated abstract representations, like finite automata
              or other formals models that capture properties of the
              SUI.</para>
            </listitem>

            <listitem>
              <para>Generated data for visualizations that will be used by
              visualization tools.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If source code is to be generated, there are various
          options.</para>

          <itemizedlist>
            <listitem>
              <para>Print strings with embedded variables.</para>
            </listitem>

            <listitem>
              <para>Convert abstract syntax trees to strings (perhaps using
              forms of pretty printing).</para>
            </listitem>

            <listitem>
              <para>Use a grammar of the target source language, also for code
              generation. Note that this approach guarantees the generation of
              syntactically correct source code as opposed to code generation
              using print statements</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If other output is needed (e.g., an automaton or other formal
          structure) write data declarations to represent that output.</para>
        </listitem>

        <listitem>
          <para>Finally, write functions and rewrite rules that generate the
          desired results.</para>
        </listitem>
      </itemizedlist>

      <para><figure xml:id="figure.define-synthesis">
          <title>Synthesis Workflow</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="define-synthesis.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The Rascal features that are frequently used for synthesis
      are:</para>

      <itemizedlist>
        <listitem>
          <para>Syntax definitions or data declarations to define output
          formats.</para>
        </listitem>

        <listitem>
          <para>Pattern matching (used in many Rascal statements).</para>
        </listitem>

        <listitem>
          <para>Visits of datastructures and on-the-fly code
          generation.</para>
        </listitem>

        <listitem>
          <para>Rewrite rules.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <?hard-pagebreak ?>

  <section xml:id="section.more-examples">
    <title>Larger Examples</title>

    <para>Now we will have a closer look at some larger applications of
    Rascal. We start with a call graph analysis in <xref
    linkend="section.motivating-example" /> and then continue with the
    analysis of the component structure of an application in <xref
    linkend="section.analyzing-components" /> and of Java systems in <xref
    linkend="section.analyzing-java" />. Next we move on to the detection of
    uninitialized variables in <xref
    linkend="section.unitialized-variables" />. As an example of computing
    code metrics, we describe the calculation of McCabe's cyclomatic
    complexity in <biblioref linkend="section.McCabe" />. Several examples of
    dataflow analysis follow in <xref linkend="section.dataflow" />. A
    description of program slicing concludes the chapter, see <xref
    linkend="section.program-slicing" />.<warning>
        <para>The examples in this section are biased towards pure analysis.
        We intend to add more extraction and synthesis examples.</para>
      </warning></para>

    <section xml:id="section.motivating-example">
      <title>Call Graph Analysis</title>

      <para>Suppose a mystery box ends up on your desk. When you open it, it
      contains a huge software system with several questions attached to
      it:</para>

      <itemizedlist>
        <listitem>
          <para>How many procedure calls occur in this system?</para>
        </listitem>

        <listitem>
          <para>How many procedures does it contains?</para>
        </listitem>

        <listitem>
          <para>What are the entry points for this system, i.e., procedures
          that call others but are not called themselves?</para>
        </listitem>

        <listitem>
          <para>What are the leaves of this application, i.e., procedures that
          are called but do not make any calls themselves?</para>
        </listitem>

        <listitem>
          <para>Which procedures call each other indirectly?</para>
        </listitem>

        <listitem>
          <para>Which procedures are called directly or indirectly from each
          entry point?</para>
        </listitem>

        <listitem>
          <para>Which procedures are called from all entry points?</para>
        </listitem>
      </itemizedlist>

      <para>There are now two possibilities. Either you have this superb
      programming environment or tool suite that can immediately answer all
      these questions for you or you can use Rascal.</para>

      <section>
        <title>Preparations</title>

        <para>To illustrate this process consider the workflow in <xref
        linkend="figure.calls-workflow" />. First we have to extract the calls
        from the source code. Rascal is very good at this, but to simplify
        this example we assume that this call graph has already been
        extracted. Also keep in mind that a real call graph of a real
        application will contain thousands and thousands of calls. Drawing it
        in the way we do later on in <xref linkend="figure.calls" /> makes no
        sense since we get a uniformly black picture due to all the call
        dependencies. After the extraction phase, we try to understand the
        extracted facts by writing queries to explore their properties. For
        instance, we may want to know <emphasis>how many calls</emphasis>
        there are, or <emphasis>how many procedures</emphasis>. We may also
        want to enrich these facts, for instance, by computing who calls who
        in more than one step. Finally, we produce a simple textual report
        giving answers to the questions we are interested in.<figure
            xml:id="figure.calls-workflow">
            <title>Workflow for analyzing mystery box</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="calls-workflow.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>

            <para>Now consider the call graph shown in <xref
            linkend="figure.calls" />. This section is intended to give you a
            first impression what can be done with Rascal. Please return to
            this example when you have digested the detailed description of
            Rascal in <xref linkend="section.rascal-language" /> and <xref
            linkend="section.lib" />.</para>
          </figure><figure xml:id="figure.calls">
            <title>Graphical representation of the <literal>calls</literal>
            relation</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="calls.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>Rascal supports basic data types like integers and strings which
        are sufficient to formulate and answer the questions at hand. However,
        we can gain readability by introducing separately named types for the
        items we are describing. First, we introduce therefore a new type
        <literal>proc</literal> (an alias for strings) to denote
        procedures:</para>

        <screen>rascal&gt; <userinput>alias proc = str;</userinput>
<computeroutput>ok</computeroutput></screen>

        <para>Suppose that the following facts have been extracted from the
        source code and are represented by the relation
        <literal>Calls</literal>:<caution>
            <para>Here we should illustrate how to do this.</para>
          </caution></para>

        <screen><prompt>rascal&gt;</prompt> <userinput>rel[proc, proc] Calls = 
   { &lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, &lt;"d", "c"&gt;, 
     &lt;"d","e"&gt;, &lt;"f", "e"&gt;, &lt;"f", "g"&gt;, &lt;"g", "e"&gt;
   };</userinput>
<computeroutput>rel[proc,proc]: { &lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, 
                  &lt;"d", "c"&gt;, &lt;"d","e"&gt;, &lt;"f", "e"&gt;, 
                  &lt;"f", "g"&gt;, &lt;"g", "e"&gt;}</computeroutput></screen>

        <para>This concludes the preparatory steps and now we move on to
        answer the questions.</para>
      </section>

      <section>
        <title>Questions</title>

        <section>
          <title>How many procedure calls occur in this system?</title>

          <para>To determine the numbers of calls, we simply determine the
          number of tuples in the <literal>Calls</literal> relation, as
          follows. First, we need the Relation library (described in <xref
          linkend="section.lib-Relation" />) so we import it:<screen><prompt>rascal&gt;</prompt> <userinput>import Relation;</userinput>
<computeroutput>ok</computeroutput></screen>next we describe a new variable
          and calculate the number of tuples:</para>

          <para><screen><prompt>rascal&gt;</prompt> <userinput>nCalls = size(Calls);</userinput>
<computeroutput>int: 8</computeroutput></screen>The library function
          <literal>size</literal> determines the number of elements in a set
          or relation and is explained in <xref
          linkend="section.lib-Relation" />. In this example,
          <literal>nCalls</literal> will get the value
          <literal>8</literal>.</para>
        </section>

        <section>
          <title>How many procedures are contained in it?</title>

          <para>We get the number of procedures by determining which names
          occur in the tuples in the relation <literal>Calls</literal> and
          then determining the number of names:</para>

          <screen><prompt>rascal&gt;</prompt> <userinput>procs = carrier(Calls);</userinput>
<computeroutput><literal>set[proc]: {"a", "b", "c", "d", "e", "f", "g"}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>nprocs = size(procs);</userinput>
<computeroutput>int: 7</computeroutput></screen>

          <para>The built-in function <literal>carrier</literal> determines
          all the values that occur in the tuples of a relation. In this case,
          <literal>procs</literal> will get the value <literal>{"a", "b", "c",
          "d", "e", "f", "g"}</literal> and <literal>nprocs</literal> will
          thus get value <literal>7</literal>. A more concise way of
          expressing this would be to combine both steps:</para>

          <screen><prompt>rascal&gt;</prompt> <userinput>nprocs = size(carrier(Calls));</userinput>
<computeroutput>int: 7</computeroutput></screen>
        </section>

        <section>
          <title>What are the entry points for this system?</title>

          <para>The next step in the analysis is to determine which
          <emphasis>entry points</emphasis> this application has, i.e.,
          procedures which call others but are not called themselves. Entry
          points are useful since they define the external interface of a
          system and may also be used as guidance to split a system in parts.
          The <literal>top</literal> of a relation contains those left-hand
          sides of tuples in a relation that do not occur in any right-hand
          side. When a relation is viewed as a graph, its top corresponds to
          the root nodes of that graph. Similarly, the
          <literal>bottom</literal> of a relation corresponds to the leaf
          nodes of the graph. See <xref linkend="section.lib-Graph" /> for
          more details. Using this knowledge, the entry points can be computed
          by determining the top of the <literal>Calls</literal>
          relation:</para>

          <screen><prompt>rascal&gt;</prompt> <userinput>import Graph;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>entryPoints = top(Calls);</userinput>
<computeroutput>set[proc]: {"a", "f"}</computeroutput></screen>

          <para>In this case, <literal>entryPoints</literal> is equal to
          <literal>{"a", "f"}</literal>. In other words, procedures
          <literal>"a"</literal> and <literal>"f"</literal> are the entry
          points of this application.</para>
        </section>

        <section>
          <title>What are the leaves of this application?</title>

          <para>In a similar spirit, we can determine the
          <emphasis>leaves</emphasis> of this application, i.e., procedures
          that are being called but do not make any calls themselves:</para>

          <screen><prompt>rascal&gt;</prompt> <userinput>bottomCalls = bottom(Calls);</userinput>
<computeroutput>set[proc]: {"c", "e"}</computeroutput></screen>

          <para>In this case, <literal>bottomCalls</literal> is equal to
          <literal>{"c", "e"}</literal>.</para>
        </section>

        <section>
          <title>Which procedures call each other indirectly?</title>

          <para>We can also determine the <emphasis>indirect calls</emphasis>
          between procedures, by taking the transitive closure of the
          <literal>Calls</literal> relation. Observe that the transitive
          closure will contain both the direct and the indirect calls.</para>

          <screen><prompt>rascal&gt;</prompt> <userinput>closureCalls = Calls+;</userinput>
<computeroutput>rel[proc, proc]: {&lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, 
                  &lt;"d", "c"&gt;, &lt;"d","e"&gt;, &lt;"f", "e"&gt;, 
                  &lt;"f", "g"&gt;, &lt;"g", "e"&gt;, &lt;"a", "c"&gt;, 
                  &lt;"a", "d"&gt;, &lt;"b", "e"&gt;, &lt;"a", "e"&gt;}</computeroutput></screen>
        </section>

        <section>
          <title>Which procedures are called directly or indirectly from each
          entry point?</title>

          <para>We now know the entry points for this application
          (<literal>"a" </literal>and <literal>"f"</literal>) and the indirect
          call relations. Combining this information, we can determine which
          procedures are called from each entry point. This is done by
          indexing <literal>closureCalls</literal> with appropriate procedure
          name. The index operator yields all right-hand sides of tuples that
          have a given value as left-hand side. This gives the
          following:</para>

          <screen><prompt>rascal&gt;</prompt> <userinput>calledFromA = closureCalls["a"];</userinput>
<computeroutput>set[proc]: {"b", "c", "d", "e"}</computeroutput></screen>

          <para>and</para>

          <screen><prompt>rascal&gt;</prompt> <userinput>calledFromF = closureCalls["f"];</userinput>
<computeroutput>set[proc]: {"e", "g"}</computeroutput></screen>
        </section>

        <section>
          <title>Which procedures are called from all entry points?</title>

          <para>Finally, we can determine which procedures are called from
          both entry points by taking the intersection of the two sets
          <literal>calledFromA</literal> and
          <literal>calledFromF:</literal></para>

          <para><screen><prompt>rascal&gt;</prompt> <userinput>commonProcs = calledFromA &amp; calledFromF;</userinput>
<computeroutput>set[proc]: {"e"}</computeroutput></screen></para>

          <para>In other words, the procedures called from both entry points
          are mostly disjoint except for the common procedure
          <literal>"e"</literal>.</para>
        </section>

        <section>
          <title>Wrap-up</title>

          <para>These findings can be verified by inspecting a graph view of
          the calls relation as shown in <xref linkend="figure.calls" />. Such
          a visual inspection does <emphasis>not</emphasis> scale very well to
          large graphs and this makes the above form of analysis particularly
          suited for studying large systems.</para>
        </section>
      </section>
    </section>

    <section xml:id="section.analyzing-components">
      <title>Analyzing the Component Structure of an Application</title>

      <para>A frequently occurring problem is that we know the call relation
      of a system but that we want to understand it at the component level
      rather than at the procedure level. If it is known to which component
      each procedure belongs, it is possible to <emphasis>lift</emphasis> the
      call relation to the component level as proposed in <biblioref
      linkend="Krikhaar99" />. Actual lifting, amounts to translating each
      call between procedures by a call between components. This described in
      the following module:<programlisting>module demo::Lift

alias proc = str;
alias comp = str;

public rel[comp,comp] lift(rel[proc,proc] aCalls, 
                           rel[proc,comp] aPartOf){
   return { &lt;C1, C2&gt; | &lt;proc P1, proc P2&gt; &lt;- aCalls, 
                       &lt;comp C1, comp C2&gt; &lt;- aPartOf[P1] * 
                                             aPartOf[P2]
          };
}</programlisting>Let's now apply this. First import the above module, and
      define a call relation and a partof relation:</para>

      <para><screen><prompt>rascal&gt;</prompt> <userinput>import demo::Lift;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>Calls = {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, 
                 &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, &lt;"b", "d"&gt;
                };</userinput>
<computeroutput>rel[str,str] : {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, 
                &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, &lt;"b", "d"&gt;
               }</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>Components = {"Appl", "DB", "Lib"};</userinput>
<computeroutput>set[str] : {"Appl", "DB", "Lib"}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>PartOf = {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, 
                  &lt;"b", "DB"&gt;, &lt;"c", "Lib"&gt;, 
                  &lt;"d", "Lib"&gt;};</userinput>
<computeroutput>rel[str,str] : {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, 
                &lt;"b", "DB"&gt;, &lt;"c", "Lib"&gt;, 
                &lt;"d", "Lib"&gt;}</computeroutput></screen>The lifted call
      relation between components is now obtained by:<screen><prompt>rascal&gt; </prompt><userinput>ComponentCalls = lift(Calls, PartOf);</userinput>
<computeroutput>rel[str,str] : {&lt;"DB", "Lib"&gt;, &lt;"Appl", "Lib"&gt;, 
                &lt;"Appl", "DB"&gt;, &lt;"Appl", "Appl"&gt;}</computeroutput></screen>The
      relevant relations for this example are shown in <xref
      linkend="figure.parts" />.</para>

      <figure xml:id="figure.parts">
        <title>(a) <literal>Calls</literal>; (b) <literal>PartOf</literal>;
        (c) <literal>ComponentCalls</literal>.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="parts.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="section.analyzing-java">
      <title>Analyzing the Structure of Java Systems</title>

      <para>Now we consider the analysis of Java systems (inspired by
      <biblioref linkend="BNL03" />). Suppose that the type
      <literal>class</literal> is defined as follows<programlisting>alias class = str;</programlisting>and
      that the following relations are available about a Java
      application:</para>

      <itemizedlist>
        <listitem>
          <para><literal>rel[class,class] CALL</literal>: If
          <literal>&lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt;</literal>
          is an element of <literal>CALL</literal>, then some method of
          <replaceable>C</replaceable><subscript>2</subscript> is called from
          <replaceable>C</replaceable><subscript>1</subscript>.</para>
        </listitem>

        <listitem>
          <para><literal>rel[class,class] INHERITANCE</literal>: If
          <literal>&lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt;</literal>
          is an element of <literal>INHERITANCE</literal>, then class
          <replaceable>C</replaceable><subscript>1</subscript> either extends
          class <replaceable>C</replaceable><subscript>2</subscript> or
          <replaceable>C</replaceable><subscript>1</subscript> implements
          interface
          <replaceable>C</replaceable><subscript>2</subscript>.</para>
        </listitem>

        <listitem>
          <para><literal>rel[class,class] CONTAINMENT</literal>: If
          &lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt; is an
          element of <literal>CONTAINMENT</literal>, then one of the fields of
          class <replaceable>C</replaceable><subscript>1</subscript> is of
          type <replaceable>C</replaceable><subscript>2</subscript>.</para>
        </listitem>
      </itemizedlist>

      <para>To make this more explicit, consider the class
      <literal>LocatorHandle</literal> from the JHotDraw application (version
      5.2) as shown here:</para>

      <para><programlisting>package CH.ifa.draw.standard;

import java.awt.Point;
import CH.ifa.draw.framework.*;
/**
 * A LocatorHandle implements a Handle by delegating the 
 * location requests to a Locator object.
 */
public class LocatorHandle extends AbstractHandle {
    private Locator       fLocator;
    /**
     * Initializes the LocatorHandle with the 
     * given Locator.
     */
    public LocatorHandle(Figure owner, Locator l) {
        super(owner);
        fLocator = l;
    }
    /**
     * Locates the handle on the figure by forwarding 
     * the request to its figure.
     */
    public Point locate() {
        return fLocator.locate(owner());
    }
}</programlisting></para>

      <para>It leads to the addition to the above relations of the following
      tuples:</para>

      <itemizedlist>
        <listitem>
          <para>To <literal>CALL</literal> the pairs
          <literal>&lt;"LocatorHandle", "AbstractHandle"&gt;</literal> and
          <literal>&lt;"LocatorHandle", "Locator"&gt;</literal> will be
          added.</para>
        </listitem>

        <listitem>
          <para>To <literal>INHERITANCE</literal> the pair
          <literal>&lt;"LocatorHandle", "AbstractHandle"&gt;</literal> will be
          added.</para>
        </listitem>

        <listitem>
          <para>To <literal>CONTAINMENT</literal> the pair
          <literal>&lt;"LocatorHandle", "Locator"&gt;</literal> will be
          added.</para>
        </listitem>
      </itemizedlist>

      <para>Cyclic structures in object-oriented systems makes understanding
      hard. Therefore it is interesting to spot classes that occur as part of
      a cyclic dependency. Here we determine cyclic uses of classes that
      include calls, inheritance and containment. This is achieved as
      follows:<programlisting>rel[class,class] USE = CALL + CONTAINMENT + INHERITANCE;
set[str] ClassesInCycle =
   {C1 | &lt;class C1, class C2&gt; &lt;- USE+, C1 == C2};</programlisting>First,
      we define the <literal>USE</literal> relation as the union of the three
      available relations <literal>CALL</literal>,
      <literal>CONTAINMENT</literal> and <literal>INHERITANCE</literal>. Next,
      we consider all pairs
      &lt;<replaceable>C</replaceable><subscript>1</subscript>,
      <replaceable>C</replaceable><subscript>2</subscript>&gt; in the
      transitive closure of the <literal>USE</literal> relation such that
      <replaceable>C</replaceable><subscript>1</subscript> and
      <replaceable>C</replaceable><subscript>2</subscript> are equal. Those
      are precisely the cases of a class with a cyclic dependency on itself.
      Probably, we do not only want to know which classes occur in a cyclic
      dependency, but we also want to know which classes are involved in such
      a cycle. In other words, we want to associate with each class a set of
      classes that are responsible for the cyclic dependency. This can be done
      as follows.<programlisting>rel[class,class] USE = CALL + CONTAINMENT + INHERITANCE;
set[class] CLASSES = carrier(USE);
rel[class,class] USETRANS = USE+;
rel[class,set[class]] ClassCycles = 
   {&lt;C, USETRANS[C]&gt; | class C &lt;- CLASSES, 
                       &lt;C, C&gt; in USETRANS };</programlisting>First, we
      introduce two new shorthands: <literal>CLASSES</literal> and
      <literal>USETRANS</literal>. Next, we consider all classes
      <literal>C</literal> with a cyclic dependency and add the pair
      <literal>&lt;C, USETRANS[C]&gt;</literal> to the relation
      <literal>ClassCycles</literal>. Note that <literal>USETRANS[C]</literal>
      is the right image of the relation <literal>USETRANS</literal> for
      element <literal>C</literal>, i.e., all classes that can be called
      transitively from class <literal>C</literal>.</para>
    </section>

    <section xml:id="section.unitialized-variables">
      <title>Finding Uninitialized and Unused Variables in a Program</title>

      <para>Consider the following program in the toy language Pico: (This is
      an extended version of the example presented earlier in <biblioref
      linkend="KlintIWPC03" />.)<programlisting>[ 1] begin declare x : natural, y : natural,
[ 2]              z : natural, p : natural;
[ 3]  x := 3;
[ 4]  p := 4;
[ 5]  if q then
[ 6]        z := y + x
[ 7]  else
[ 8]        x := 4
[ 9]  fi;
[10]  y := z
[11] end</programlisting>Inspection of this program learns that some of the
      variables are being used before they have been initialized. The
      variables in question are <literal>q</literal> (line 5),
      <literal>y</literal> (line 6), and <literal>z</literal> (line 10). It is
      also clear that variable <literal>p</literal> is initialized (line 4),
      but is never used. How can we automate these kinds of analysis? Recall
      from <xref linkend="section.EASY-programming" /> that we follow the
      Extract-Analyze-SYnthesize paradigm to approach such a problem. The
      first step is to determine which elementary facts we need about the
      program. For this and many other kinds of program analysis, we need at
      least the following:</para>

      <itemizedlist>
        <listitem>
          <para>The <emphasis>control flow graph</emphasis> of the program. We
          represent it by a graph <literal>PRED</literal> (for predecessor)
          which relates each statement with its predecessors.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>definitions</emphasis> of each variable, i.e.,
          the program statements where a value is assigned to the variable. It
          is represented by the relation <literal>DEFS</literal>.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>uses</emphasis> of each variable, i.e., the
          program statements where the value of the variable is used. It is
          represented by the relation <literal>USES</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>In this example, we will use line numbers to identify the
      statements in the program. Assuming that there is a tool to extract the
      above information from a program text, we get the following for the
      above example:<programlisting>module demo::Uninit
import Relation;
import Graph;

alias expr = int;
alias varname = str;

public expr ROOT = 1;

public graph[expr] PRED = { &lt;1,3&gt;, &lt;3,4&gt;, &lt;4,5&gt;, &lt;5,6&gt;, 
                            &lt;5,8&gt;, &lt;6,10&gt;, &lt;8,10&gt; };

public rel[varname,expr] DEFS = { &lt;"x", 3&gt;, &lt;"p", 4&gt;, 
                                  &lt;"z", 6&gt;, &lt;"x", 8&gt;, 
                                  &lt;"y", 10&gt; };

public rel[varname, expr] USES = { &lt;"q", 5&gt;, &lt;"y", 6&gt;, 
                                   &lt;"x", 6&gt;, &lt;"z", 10&gt; };
</programlisting>This concludes the extraction phase. Next, we have to enrich
      these basic facts to obtain the initialized variables in the program.
      So, when is a variable <replaceable>V</replaceable> in some statement
      <replaceable>S</replaceable> initialized? If we execute the program
      (starting in <literal>ROOT</literal>), there may be several possible
      execution paths that can reach statement <replaceable>S</replaceable>.
      All is well if <emphasis>all</emphasis> these execution path contain a
      definition of <replaceable>V</replaceable>. However, if one or more of
      these path do <emphasis>not</emphasis> contain a definition of
      <replaceable>V</replaceable>, then <replaceable>V</replaceable> may be
      uninitialized in statement <replaceable>S</replaceable>. This can be
      formalized as follows:<programlisting>// module demo::Unit continued
public rel[varname,expr] UNINIT = 
   { &lt;V,E&gt; | &lt;varname V, expr E&gt; &lt;- USES, 
              E in reachX(PRED, {ROOT}, DEFS[V])
   };</programlisting></para>

      <para>We analyze this definition in detail:</para>

      <itemizedlist>
        <listitem>
          <para><literal>&lt;varname V, expr E&gt; : USES</literal> enumerates
          all tuples in the <literal>USES</literal> relation. In other words,
          we consider the use of each variable in turn.</para>
        </listitem>

        <listitem>
          <para><literal>E in reachX(PRED, {ROOT}, DEFS[V]) </literal>is a
          test that determines whether expression <replaceable>E</replaceable>
          is reachable from the <literal>ROOT</literal> without encountering a
          definition of variable <replaceable>V</replaceable>.</para>

          <itemizedlist>
            <listitem>
              <para><literal>{ROOT}</literal> represents the initial set of
              nodes from which all path should start.</para>
            </listitem>

            <listitem>
              <para><literal>DEFS[V]</literal> yields the set of all
              statements in which a definition of variable
              <literal>V</literal> occurs. These nodes form the exclusion set
              for <literal>reachX</literal>: no path will be extended beyond
              an element in this set.</para>
            </listitem>

            <listitem>
              <para><literal>PRED</literal> is the relation for which the
              reachability has to be determined.</para>
            </listitem>

            <listitem>
              <para>The result of <literal>reachX(PRED, {ROOT}, DEFS[V])
              </literal>is a set that contains all nodes that are reachable
              from the <literal>ROOT</literal> (as well as all intermediate
              nodes on each path).</para>
            </listitem>

            <listitem>
              <para>Finally, <literal>E in reachX(PRED, {ROOT}, DEFS[V])
              </literal>tests whether expression <literal>E</literal> can be
              reached from the <literal>ROOT</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The net effect is that <literal>UNINIT</literal> will only
          contain pairs that satisfy the test just described.</para>
        </listitem>
      </itemizedlist>

      <para>When we execute the resulting Rascal code (i.e., the declarations
      of <literal>ROOT</literal>, <literal>PRED</literal>,
      <literal>DEFS</literal>, <literal>USES</literal> and
      <literal>UNINIT</literal>), we get as value for
      <literal>UNINIT</literal>:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Uninit;</userinput>
ok

<prompt>rascal&gt;</prompt> <userinput>UNINIT;</userinput>
<computeroutput>rel[varname,expr]: {&lt;"q", 5&gt;, &lt;"y", 6&gt;, &lt;"z", 10&gt;}</computeroutput></screen>and
      this is in concordance with the informal analysis given at the beginning
      of this example.</para>

      <para>As a bonus, we can also determine the <emphasis>unused</emphasis>
      variables in a program, i.e., variables that are defined but are used
      nowhere. This is done as follows:<programlisting>// module demo::Unit continued

public set[varname] UNUSED = domain(DEFS) - domain(USES);</programlisting>Taking
      the domain of the relations <literal>DEFS</literal> and
      <literal>USES</literal> yields the variables that are defined,
      respectively, used in the program. The difference of these two sets
      yields the unused variables, in this case
      <literal>{"p"}</literal>.</para>
    </section>

    <section xml:id="section.McCabe">
      <title>McCabe Cyclomatic Complexity</title>

      <para>The <emphasis>cyclomatic complexity</emphasis> of a program is
      defined as <replaceable>e</replaceable> - <replaceable>n</replaceable> +
      2, where <replaceable>e</replaceable> and <replaceable>n</replaceable>
      are the number of edges and nodes in the control flow graph,
      respectively. It was proposed by McCabe <biblioref linkend="McCabe76" />
      as a measure of program complexity. Experiments have shown that programs
      with a higher cyclomatic complexity are more difficult to understand and
      test and have more errors. It is generally accepted that a program,
      module or procedure with a cyclomatic complexity larger than 15 is
      <emphasis>too complex</emphasis>. Essentially, cyclomatic complexity
      measures the number of decision points in a program and can be computed
      by counting all if statement, case branches in switch statements and the
      number of conditional loops. Given a control flow in the form of a
      predecessor graph <literal>graph[&amp;T] PRED</literal> between elements
      of arbitrary type <literal>&amp;T</literal>, the cyclomatic complexity
      can be computed in Rascal as follows: <programlisting>module demo::McCabe
import Graph;

public int cyclomaticComplexity(graph[&amp;T] PRED){
    return size(PRED) - size(carrier(PRED)) + 2;
}</programlisting>The number of edges <replaceable>e</replaceable> is equal to
      the number of tuples in <literal>PRED</literal>. The number of nodes
      <replaceable>n</replaceable> is equal to the number of elements in the
      carrier of PRED, i.e., all elements that occur in a tuple in
      <literal>PRED</literal>.</para>
    </section>

    <section xml:id="section.dataflow">
      <title>Dataflow Analysis</title>

      <para><emphasis>Dataflow analysis</emphasis> is a program analysis
      technique that forms the basis for many compiler optimizations. It is
      described in any text book on compiler construction, e.g. <biblioref
      linkend="AhoSethiUllman86" />. The goal of dataflow analysis is to
      determine the effect of statements on their surroundings. Typical
      examples are:</para>

      <itemizedlist>
        <listitem>
          <para>Dominators (<xref linkend="section.dominators" />): which
          nodes in the flow dominate the execution of other nodes?</para>
        </listitem>

        <listitem>
          <para>Reaching definitions (<xref
          linkend="section.reaching-definitions" />): which definitions of
          variables are still valid at each statement?</para>
        </listitem>

        <listitem>
          <para>Live variables (<xref linkend="section.live-variables" />): of
          which variables will the values be used by successors of a
          statement?</para>
        </listitem>

        <listitem>
          <para>Available expressions: an expression is available if it is
          computed along each path from the start of the program to the
          current statement.</para>
        </listitem>
      </itemizedlist>

      <section xml:id="section.dominators">
        <title>Dominators</title>

        <para>A node <replaceable>d</replaceable> of a flow graph
        <emphasis>dominates</emphasis> a node <replaceable>n</replaceable>, if
        every path from the initial node of the flow graph to
        <replaceable>n</replaceable> goes through <replaceable>d</replaceable>
        <biblioref linkend="AhoSethiUllman86" /> (Section 10.4). Dominators
        play a role in the analysis of conditional statements and loops. The
        function <literal>dominators</literal> that computes the dominators
        for a given flow graph <literal>PRED</literal> and an entry node
        <literal>ROOT</literal> is defined as follows:</para>

        <para><programlisting>module demo::Dominators
import Set;
import Relation;
import Graph;

public rel[&amp;T, set[&amp;T]] dominators(rel[&amp;T,&amp;T] PRED, 
                                   &amp;T ROOT)
{
  set[&amp;T] VERTICES = carrier(PRED);
  return  { &lt;V,  (VERTICES - {V, ROOT}) - 
                 reachX(PRED,{ROOT},{V})&gt; 
            |  &amp;T V &lt;- VERTICES
          };
}</programlisting></para>

        <para>First, the auxiliary set <literal>VERTICES</literal> (all the
        statements) is computed. The relation <literal>DOMINATES</literal>
        consists of all pairs <literal>&lt;<replaceable>S</replaceable>,
        {<replaceable>S</replaceable><subscript>1</subscript>,...,<replaceable>S</replaceable><subscript><replaceable>n</replaceable></subscript>}&gt;</literal>
        such that</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>S</replaceable><subscript><replaceable>i</replaceable></subscript>
            is not an initial node or equal to
            <replaceable>S</replaceable>.</para>
          </listitem>

          <listitem>
            <para><replaceable>S</replaceable><subscript><replaceable>i</replaceable></subscript>
            cannot be reached from the initial node without going through
            <replaceable>S</replaceable>.</para>
          </listitem>
        </itemizedlist>

        <para>First import the above module and consider the sample flow graph
        PRED:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Dominators;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[int,int] PRED = {
&lt;1,2&gt;, &lt;1,3&gt;,
&lt;2,3&gt;,
&lt;3,4&gt;,
&lt;4,3&gt;,&lt;4,5&gt;, &lt;4,6&gt;,
&lt;5,7&gt;,
&lt;6,7&gt;,
&lt;7,4&gt;,&lt;7,8&gt;,
&lt;8,9&gt;,&lt;8,10&gt;,&lt;8,3&gt;,
&lt;9,1&gt;,
&lt;10,7&gt;
};</userinput>

<computeroutput>rel[int,int]: { &lt;1,2&gt;, &lt;1,3&gt;, ...</computeroutput></screen>It
        is illustrated in<xref linkend="figure.flow-graph" /><figure
            xml:id="figure.flow-graph">
            <title>Flow graph</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="dominators.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure>The result of applying <literal>dominators</literal> to it
        is as follows:<screen><prompt>rascal&gt;</prompt> <userinput>dominators(PRED);</userinput>
<computeroutput>rel[int,int]: {&lt;1, {2, 3, 4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;2, {}&gt;, 
&lt;3, {4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;4, {5, 6, 7, 8, 9, 10}&gt;, 
&lt;5, {}&gt;, 
&lt;6, {}&gt;, 
&lt;7, {8, 9, 10}&gt;, 
&lt;8, {9, 10}&gt;, 
&lt;9, {}&gt;, 
&lt;10, {}&gt;}</computeroutput></screen>The resulting <emphasis>dominator
        tree</emphasis> is shown in <xref linkend="figure.dominator-tree" />.
        The dominator tree has the initial node as root and each node
        <replaceable>d</replaceable> in the tree only dominates its
        descendants in the tree.</para>

        <para><figure xml:id="figure.dominator-tree">
            <title>Dominator tree</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="dominator-tree.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section xml:id="section.reaching-definitions">
        <title>Reaching Definitions</title>

        <para>We illustrate the calculation of reaching definitions using the
        example in <xref linkend="figure.dataflow-graph" /> which was inspired
        by <biblioref linkend="AhoSethiUllman86" /> (Example 10.15).</para>

        <para><figure xml:id="figure.dataflow-graph">
            <title>Flow graph for various dataflow problems</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="df-graph.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>We assume the following basic definitions to represent
        information about the program:<programlisting>module demo::ReachingDefs

import Relation;
import Graph;
import IO;

public alias stat = int;
public alias var = str;
public alias def  = tuple[stat, var];
public alias use = tuple[stat,var];

public rel[stat,def] definition(rel[stat,var] DEFS){
  return {&lt;S,&lt;S,V&gt;&gt; | &lt;stat S, var V&gt; &lt;- DEFS};
}

public rel[stat,def] use(rel[stat, var] USES){
  return {&lt;S, &lt;S, V&gt;&gt; | &lt;stat S, var V&gt; &lt;- USES};
}
</programlisting></para>

        <para>Let's use the following values to represent our example:</para>

        <para><screen><prompt>rascal&gt;</prompt> <userinput>rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, 
                                &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,7&gt;, 
                                &lt;6,7&gt;, &lt;7,4&gt; };</userinput>
<computeroutput>rel[stat,stat]: { &lt;1,2&gt;, &lt;2,3&gt;, ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat, var] DEFS = { &lt;1, "i"&gt;, &lt;2, "j"&gt;, 
                                &lt;3, "a"&gt;, &lt;4, "i"&gt;, 
                                &lt;5, "j"&gt;, &lt;6, "a"&gt;, 
                                &lt;7, "i"&gt; };</userinput>
<computeroutput>rel[stat,var]: { &lt;1, "i"&gt;, &lt;2, "j"&gt;, ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat,var] USES = { &lt;1, "m"&gt;, &lt;2, "n"&gt;, 
                               &lt;3, "u1"&gt;, &lt;4, "i"&gt;, 
                               &lt;5, "j"&gt;, &lt;6, "u2"&gt;, 
                               &lt;7, "u3"&gt; };</userinput>
<computeroutput>rel[stat,var]: { &lt;1, "m"&gt;, &lt;2, "n"&gt;,...</computeroutput></screen></para>

        <!--leg uit waarom het handig is om voor relaties zoals 
DEFS elementen van de
       vorm <X,<X,Y>> te gebruiken in plaats van het voor de hand liggende 
<X,Y>-->

        <para>For convenience, we have introduced above a notion
        <literal>def</literal> that describes that a certain statement defines
        some variable and we revamp the basic relations into a more convenient
        format using this new type and the auxiliary functions
        <literal>definition</literal> and <literal>use</literal>:<screen><prompt>rascal&gt;</prompt> <userinput>definition(DEFS);</userinput>
<computeroutput>rel[stat,def]: { &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, 
                 &lt;3, &lt;3, "a"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
                 &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, 
                 &lt;7, &lt;7, "i"&gt;&gt; }</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>use(USES);</userinput>
<computeroutput>rel[stat,def]: { &lt;1, &lt;1, "m"&gt;&gt;, &lt;2, &lt;2, "n"&gt;&gt;, 
                 &lt;3, &lt;3, "u1"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
                 &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "u2"&gt;&gt;, 
                 &lt;7, &lt;7, "u3"&gt;&gt; }</computeroutput></screen></para>

        <!--de definitie van "kill" komt niet overeen met wat ik zou 
verwachten. Ik zou nl. verwachten
    dat een definitie D1 een definitie D2 alleen "killt" als D1 een 
dominator is van D2.  Het is
    anders ook niet zo duidelijk waarom je eerst een definitie geeft van 
dominators.-->

        <para>Now we are ready to define an important new relation
        <literal>KILL</literal>. <literal>KILL</literal> defines which
        variable definitions are undone (killed) at each statement and is
        defined by the following function
        <literal>kill</literal>:<programlisting>// continuing module demo::ReachingDefs

public rel[stat,def] kill(rel[stat,var] DEFS) { 
  return {&lt;S1, &lt;S2, V&gt;&gt; | &lt;stat S1, var V&gt; &lt;- DEFS, 
                          &lt;stat S2, V&gt; &lt;- DEFS, 
                          S1 != S2};
}</programlisting>In this definition, all variable definitions are compared
        with each other, and for each variable definition all
        <emphasis>other</emphasis> definitions of the same variable are placed
        in its kill set. In the example, <literal>KILL</literal> gets the
        value <screen><prompt>rascal&gt;</prompt> <userinput>kill(DEFS);</userinput>
<computeroutput>rel[stat,def]: 
{ &lt;1, &lt;4, "i"&gt;&gt;, &lt;1, &lt;7, "i"&gt;&gt;, &lt;2, &lt;5, "j"&gt;&gt;, 
  &lt;3, &lt;6, "a"&gt;&gt;, &lt;4, &lt;1, "i"&gt;&gt;, &lt;4, &lt;7, "i"&gt;&gt;, 
  &lt;5, &lt;2, "j"&gt;&gt;, &lt;6, &lt;3, "a"&gt;&gt;, &lt;7, &lt;1, "i"&gt;&gt;, 
  &lt;7, &lt;4, "i"&gt;&gt;
}</computeroutput></screen>and, for instance, the definition of variable
        <literal>i</literal> in statement <literal>1</literal> kills the
        definitions of <literal>i</literal> in statements <literal>4</literal>
        and <literal>7</literal>.</para>

        <para>After these preparations, we are ready to formulate the reaching
        definitions problem in terms of two relations <literal>IN</literal>
        and <literal>OUT</literal>. <literal>IN</literal> captures all the
        variable definitions that are valid at the entry of each statement and
        <literal>OUT</literal> captures the definitions that are still valid
        after execution of each statement. Intuitively, for each statement
        <literal>S</literal>, <literal>IN[S]</literal> is equal to the union
        of the <literal>OUT</literal> of all the predecessors of
        <literal>S</literal>. <literal>OUT[S]</literal>, on the other hand, is
        equal to the definitions generated by <literal>S</literal> to which we
        add <literal>IN[S]</literal> minus the definitions that are killed in
        <literal>S</literal>. Mathematically, the following set of equations
        captures this idea for each statement:</para>

        <para>IN[S] = UNION<subscript>P in predecessors of S</subscript>
        OUT[P]</para>

        <para>OUT[S] = DEF[S] + (IN[S] - KILL[S])</para>

        <para>This idea can be expressed in Rascal quite
        literally:<programlisting>public rel[stat, def] reachingDefinitions(
                            rel[stat,var] DEFS, 
                            rel[stat,stat] PRED){
  set[stat] STATEMENT = carrier(PRED);
  rel[stat,def] DEF  = definition(DEFS);
  rel[stat,def] KILL = kill(DEFS);

  // The set of mutually recursive dataflow equations 
  // that has to be solved:

  with
    rel[stat,def] IN = {};
    rel[stat,def] OUT = DEF;
  solve {
    IN  = {&lt;S, D&gt; | int S &lt;- STATEMENT, 
                    stat P &lt;- predecessors(PRED,S), 
                    def D &lt;- OUT[P]};
    OUT = {&lt;S, D&gt; | int S &lt;- STATEMENT, 
                    def D &lt;- DEF[S] + (IN[S] - KILL[S])};
  };
  return IN;
}</programlisting>First, the relations <literal>IN</literal> and
        <literal>OUT</literal> are declared and initialized. Next, two
        equations are given that resemble the mathematical equations given
        above. Note the use of the library function
        <literal>predecessors</literal> to obtain the predecessors of a
        statement for a given control flow graph.</para>

        <para><figure xml:id="figure.reaching-definitions">
            <title>Reaching definitions for flow graph in <xref
            linkend="figure.dataflow-graph" /></title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="reach.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure> For our running example (<xref
        linkend="figure.reaching-definitions" />) the results are as follows
        (see <xref linkend="figure.reaching-definitions" />). Relation
        <literal>IN</literal> has as value:<programlisting>{ &lt;2, &lt;1, "i"&gt;&gt;, &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, 
  &lt;4, &lt;3, "a"&gt;&gt;, &lt;4, &lt;2, "j"&gt;&gt;, &lt;4, &lt;1, "i"&gt;&gt;, 
  &lt;4, &lt;7, "i"&gt;&gt;, &lt;4, &lt;5, "j"&gt;&gt;, &lt;4, &lt;6, "a"&gt;&gt;, 
  &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;2, "j"&gt;&gt;, 
  &lt;5, &lt;5, "j"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, &lt;6, &lt;5, "j"&gt;&gt;, 
  &lt;6, &lt;4, "i"&gt;&gt;, &lt;6, &lt;3, "a"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, 
  &lt;7, &lt;5, "j"&gt;&gt;, &lt;7, &lt;4, "i"&gt;&gt;, &lt;7, &lt;3, "a"&gt;&gt;, 
  &lt;7, &lt;6, "a"&gt;&gt;
}</programlisting></para>

        <para>If we consider statement <literal>3</literal>, then the
        definitions of variables <literal>i</literal> and <literal>j</literal>
        from the preceding two statements are still valid. A more interesting
        case are the definitions that can reach statement
        <literal>4</literal>:</para>

        <itemizedlist>
          <listitem>
            <para>The definitions of variables <literal>a</literal>,
            <literal>j</literal> and <literal>i</literal> from, respectively,
            statements <literal>3</literal>, <literal>2</literal> and
            <literal>1</literal>.</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>i</literal> from
            statement <literal>7</literal> (via the backward control flow path
            from <literal>7</literal> to <literal>4</literal>).</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>j</literal> from
            statement <literal>5</literal> (via the path <literal>5</literal>,
            <literal>7</literal>, <literal>4</literal>).</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>a</literal> from
            statement <literal>6</literal> (via the path <literal>6</literal>,
            <literal>7</literal>, <literal>4</literal>).</para>
          </listitem>
        </itemizedlist>

        <para>Relation <literal>OUT</literal> has as value:<programlisting>{ &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, &lt;2, &lt;1, "i"&gt;&gt;, 
  &lt;3, &lt;3, "a"&gt;&gt;, &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, 
  &lt;4, &lt;4, "i"&gt;&gt;, &lt;4, &lt;3, "a"&gt;&gt;, &lt;4, &lt;2, "j"&gt;&gt;, 
  &lt;4, &lt;5, "j"&gt;&gt;, &lt;4, &lt;6, "a"&gt;&gt;, &lt;5, &lt;5, "j"&gt;&gt;, 
  &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, 
  &lt;6, &lt;6, "a"&gt;&gt;, &lt;6, &lt;5, "j"&gt;&gt;, &lt;6, &lt;4, "i"&gt;&gt;, 
  &lt;7, &lt;7, "i"&gt;&gt;, &lt;7, &lt;5, "j"&gt;&gt;, &lt;7, &lt;3, "a"&gt;&gt;, 
  &lt;7, &lt;6, "a"&gt;&gt;
}</programlisting>Observe, again for statement <literal>4</literal>, that all
        definitions of variable <literal>i</literal> are missing in
        <literal>OUT[4]</literal> since they are killed by the definition of
        <literal>i</literal> in statement <literal>4</literal> itself.
        Definitions for <literal>a</literal> and <literal>j</literal> are,
        however, contained in <literal>OUT[4]</literal>. The result of
        reaching definitions computation is illustrated in <xref
        linkend="figure.reaching-definitions" />. We will use the function
        <literal>reachingDefinitions</literal> later on in <xref
        linkend="section.program-slicing" /> when defining program
        slicing.</para>
      </section>

      <section xml:id="section.live-variables">
        <title>Live Variables</title>

        <para>The live variables of a statement are those variables whose
        value will be used by the current statement or some successor of it.
        The mathematical formulation of this problem is as follows:</para>

        <para>IN[S] =USE[S] + (OUT[S] - DEF[S])</para>

        <para>OUT[S] = UNION<subscript>S' in successors of S</subscript>
        IN[S']</para>

        <para>The first equation says that a variable is live coming into a
        statement if either it is used before redefinition in that statement
        or it is live coming out of the statement and is not redefined in it.
        The second equation says that a variable is live coming out of a
        statement if and only if it is live coming into one of its
        successors.</para>

        <para>This can be expressed in Rascal as follows:<programlisting>public rel[stat,def] liveVariables(rel[stat,var] DEFS, 
                                   rel[stat, var] USES, 
                                   rel[stat,stat] PRED){
  set[stat] STATEMENT = carrier(PRED);
  rel[stat,def] DEF  = definition(DEFS);
  rel[stat,def] USE = use(USES);
  with
    rel[stat,def] LIN = {};
    rel[stat,def] LOUT = DEF;
  solve {
    LIN  = { &lt;S, D&gt; | stat S &lt;- STATEMENT,  
                      def D &lt;- USE[S] + 
                               (LOUT[S] - (DEF[S]))};
    LOUT = { &lt;S, D&gt; | stat S &lt;- STATEMENT,  
                      stat Succ &lt;- successors(PRED,S), 
                      def D &lt;- LIN[Succ] };
  }
  return LIN;
}</programlisting>The results of live variable analysis for our running
        example are illustrated in <xref
        linkend="figure.live-variables" />.</para>

        <para><figure xml:id="figure.live-variables">
            <title>Live variables for flow graph in <xref
            linkend="figure.dataflow-graph" /></title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="live.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>
    </section>

    <section xml:id="section.program-slicing">
      <title>Program Slicing</title>

      <para>Program slicing is a technique proposed by Weiser <biblioref
      linkend="Weiser84" /> for automatically decomposing programs in parts by
      analyzing their data flow and control flow. Typically, a given statement
      in a program is selected as the <emphasis>slicing criterion</emphasis>
      and the original program is reduced to an independent subprogram, called
      a <emphasis>slice</emphasis>, that is guaranteed to represent faithfully
      the behavior of the original program at the slicing criterion. An
      example will illustrate this (we use line numbers for later
      reference):</para>

      <para><programlisting xml:id="programlisting.slice-example">[ 1] read(n)        [1] read(n)      [ 1] read(n)
[ 2] i := 1         [2] i := 1       [ 2] i := 1
[ 3] sum := 0       [3] sum := 0      
[ 4] product := 1                    [ 4] product := 1
[ 5] while i&lt;= n    [5] while i&lt;= n  [ 5] while i&lt;= n
     do                 do                do
     begin              begin             begin
[ 6]  sum :=        [6]  sum :=
          sum + i            sum + i
[ 7]  product :=                     [ 7]  product := 
        product * i                          product * i
[ 8]  i := i + 1    [8]  i := i + 1  [ 8]  i := i + 1
     end                 end              end
[ 9] write(sum)     [9] write(sum)
[10] write(product)                  [10] write(product)

<emphasis role="bold">(a)</emphasis> Sample program  <emphasis role="bold">(b)</emphasis> Slice for    <emphasis
            role="bold">(c)</emphasis> Slice for
                        statement [9]    statement [10]</programlisting></para>

      <para>The initial program is given as (a). The slice with statement [9]
      as slicing criterion is shown in (b): statements <literal>[4]</literal>
      and <literal>[7]</literal> are irrelevant for computing statement
      <literal>[9]</literal> and do not occur in the slice. Similarly, (c)
      shows the slice with statement <literal>[10]</literal> as slicing
      criterion. This particular form of slicing is called <emphasis>backward
      slicing</emphasis>. Slicing can be used for debugging and program
      understanding, optimization and more. An overview of slicing techniques
      and applications can be found in <biblioref linkend="Tip95" />. Here we
      will explore a relational formulation of slicing adapted from a proposal
      in <biblioref linkend="JacksonRollins94" />. The basic ingredients of
      the approach are as follows:</para>

      <itemizedlist>
        <listitem>
          <para>We assume the relations <literal>PRED</literal>,
          <literal>DEFS</literal> and <literal>USES</literal> as
          before.</para>
        </listitem>

        <listitem>
          <para>We assume an additional set
          <literal>CONTROL-STATEMENT</literal> that defines which statements
          are control statements.</para>
        </listitem>

        <listitem>
          <para>To tie together dataflow and control flow, three auxiliary
          variables are introduced:</para>

          <itemizedlist>
            <listitem>
              <para>The variable <literal>TEST</literal> represents the
              outcome of a specific test of some conditional statement. The
              conditional statement defines <literal>TEST</literal> and all
              statements that are control dependent on this conditional
              statement will use <literal>TEST</literal>.</para>
            </listitem>

            <listitem>
              <para>The variable <literal>EXEC</literal> represents the
              potential execution dependence of a statement on some
              conditional statement. The dependent statement defines
              <literal>EXEC</literal> and an explicit (control) dependence is
              made between <literal>EXEC</literal> and the corresponding
              <literal>TEST</literal>.</para>
            </listitem>

            <listitem>
              <para>The variable <literal>CONST</literal> represents an
              arbitrary constant.</para>

              <!--where is CONST used?-->
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>The calculation of a (backward) slice now proceeds in six
      steps:</para>

      <itemizedlist>
        <listitem>
          <para>Compute the relation <literal>rel[use,def] use-def</literal>
          that relates all uses to their corresponding definitions. The
          function <literal>reaching-definitions</literal> as shown earlier in
          <xref linkend="section.reaching-definitions" />does most of the
          work.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[def,use]
          def-use-per-stat</literal> that relates the
          <emphasis>internal</emphasis> definitions and uses of a
          statement.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[def,use]
          control-dependence</literal> that links all <literal>EXEC</literal>s
          to the corresponding <literal>TEST</literal>s.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[use,def]
          use-control-def</literal> combines use/def dependencies with control
          dependencies.</para>
        </listitem>

        <listitem>
          <para>After these preparations, compute the relation
          <literal>rel[use,use] USE-USE</literal> that contains dependencies
          of uses on uses.</para>
        </listitem>

        <listitem>
          <para>The backward slice for a given slicing criterion (a use) is
          now simply the projection of <literal>USE-USE</literal> for the
          slicing criterion.</para>
        </listitem>
      </itemizedlist>

      <para>This informal description of backward slicing can now be expressed
      in Rascal:</para>

      <para><programlisting>module demo::Slicing

import Set;
import Relation;
import demo::ReachingDefs;
import demo::Dominators;
import UnitTest;

set[use] BackwardSlice(set[stat] CONTROLSTATEMENT, 
                       rel[stat,stat] PRED,
                       rel[stat,var] USES,
                       rel[stat,var] DEFS,	
                       use Criterion) {

  rel[stat, def] REACH = reachingDefinitions(DEFS, PRED);

  // Compute the relation between each use and 
  // corresponding definitions: use_def

  rel[use,def] use_def =
  {&lt;&lt;S1,V&gt;, &lt;S2,V&gt;&gt; | &lt;stat S1, var V&gt; &lt;- USES, 
                      &lt;stat S2, V&gt; &lt;- REACH[S1]};

  // Internal dependencies per statement

  rel[def,use] def_use_per_stat  = 
       {&lt;&lt;S,V1&gt;, &lt;S,V2&gt;&gt; | &lt;stat S, var V1&gt; &lt;- DEFS, 
                           &lt;S, var V2&gt; &lt;- USES}
       +
       {&lt;&lt;S,V&gt;, &lt;S,"EXEC"&gt;&gt; | &lt;stat S, var V&gt; &lt;- DEFS}
       +
       {&lt;&lt;S,"TEST"&gt;,&lt;S,V&gt;&gt; | stat S &lt;- CONTROLSTATEMENT, 
                             &lt;S, var V&gt; &lt;- 
                                      domainR(USES, {S})};

  // Control dependence: control-dependence

  rel[stat, set[stat]] CONTROLDOMINATOR = 
  domainR(dominators(PRED, 1), CONTROLSTATEMENT);

  rel[def,use] control_dependence  =
  { &lt;&lt;S2, "EXEC"&gt;,&lt;S1,"TEST"&gt;&gt; 
    | &lt;stat S1, stat S2&gt; &lt;- CONTROLDOMINATOR};

  // Control and data dependence: use-control-def

  rel[use,def] use_control_def = 
               use_def + control_dependence;
  rel[use,use] USE_USE = 
               (use_control_def o def_use_per_stat)*;

  return USE_USE[Criterion];
}</programlisting></para>

      <para>Let's apply this to the example from the start of this section and
      assume the following:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Slicing;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, 
                                &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,9&gt;, 
                                &lt;6,7&gt;, &lt;7,8&gt;, &lt;8,5&gt;, 
                                &lt;8,9&gt;, &lt;9,10&gt; };</userinput>
<computeroutput>rel[stat,stat]: {&lt;1,2&gt;, ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat,var] DEFS  = { &lt;1, "n"&gt;, &lt;2, "i"&gt;, 
                                &lt;3, "sum"&gt;, 
                                &lt;4,"product"&gt;, 
                                &lt;6, "sum"&gt;, 
                                &lt;7, "product"&gt;, 
                                &lt;8, "i"&gt; };</userinput>
<computeroutput>rel[stat,var]: {&lt;1, "n"&gt;, ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat,var] USES  = { &lt;5, "i"&gt;, &lt;5, "n"&gt;, 
                                &lt;6, "sum"&gt;, &lt;6,"i"&gt;, 
                                &lt;7, "product"&gt;, &lt;7, "i"&gt;, 
                                &lt;8, "i"&gt;, &lt;9, "sum"&gt;, 
                                &lt;10, "product"&gt;
                              };</userinput>
<computeroutput>rel[stat,var]; { &lt;5, "i"&gt; ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>set[int] CONTROL-STATEMENT = { 5 };</userinput>
<computeroutput>set[int]: {5}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>BackwardSlice(CONTROL-STATEMENT, 
                      PRED, USES, DEFS, &lt;9, "sum"&gt;);</userinput>
<computeroutput>set[use]: { &lt;1, "EXEC"&gt;, &lt;2, "EXEC"&gt;,  &lt;3, "EXEC"&gt;, 
            &lt;5, "i"&gt;, &lt;5, "n"&gt;, &lt;6, "sum"&gt;, &lt;6, "i"&gt;, 
            &lt;6, "EXEC"&gt;, &lt;8, "i"&gt;, &lt;8, "EXEC"&gt;, 
            &lt;9, "sum"&gt; }</computeroutput></screen>Take the domain of
      this result and we get exactly the statements in (b) of the
      example.</para>
    </section>
  </section>

  <?hard-pagebreak ?>

  <section xml:id="section.rascal-language">
    <title>The Rascal Language</title>

    <para>A Rascal program consists of one or more modules. Each module may
    import other modules and declare data types, variables, functions or
    rewrite rules. We now describe the basic ingredients of Rascal in more
    detail:</para>

    <itemizedlist>
      <listitem>
        <para>Types and values, see <xref
        linkend="section.types-and-values" />.</para>
      </listitem>

      <listitem>
        <para>Declarations, see <xref
        linkend="section.declarations" />.</para>
      </listitem>

      <listitem>
        <para>Expressions, see <xref linkend="section.expressions" />.</para>
      </listitem>

      <listitem>
        <para>Statements, see <xref linkend="section.statements" />.</para>
      </listitem>
    </itemizedlist>

    <section xml:id="section.types-and-values">
      <title>Types and Values</title>

      <section xml:id="section.elementary-types">
        <title>Elementary Types and Values</title>

        <formalpara>
          <title>Void</title>

          <para>Void stands for <emphasis>nothing</emphasis> and is
          represented by the type <literal>void</literal>. It is a type
          without any values.</para>
        </formalpara>

        <formalpara>
          <title>Value</title>

          <para>Value stands for all possible Rascal values and is represented
          by the type <literal>value</literal>. This type is a container for
          all other types and does not have any values itself.</para>
        </formalpara>

        <formalpara>
          <title>Boolean</title>

          <para>The Booleans are represented by the type
          <literal>bool</literal> which has two values:
          <literal>true</literal> and <literal>false</literal>.</para>
        </formalpara>

        <formalpara>
          <title>Integer</title>

          <para>The integer values are represented by the type
          <literal>int</literal> and are written as usual, e.g.,
          <literal>0</literal>, <literal>1</literal>, or
          <literal>123</literal>. They can be arbitrarily large.</para>
        </formalpara>

        <formalpara>
          <title>Real</title>

          <para>The real values are represented by the type
          <literal>real</literal> and are written as usual, e.g.,
          <literal>1.5</literal>, or <literal>3.14e-123.</literal> They can
          have arbitrary size and precision.</para>
        </formalpara>

        <formalpara>
          <title>String</title>

          <para>The string values are represented by the type
          <literal>str</literal> and consist of character sequences surrounded
          by double quotes. e.g., <literal>"a"</literal> or
          <literal>"a\nlong\tstring"</literal>.</para>

          <!--Escape sequences!-->
        </formalpara>

        <para>String literals support so-called <emphasis>string
        interpolation</emphasis>: inside string constants text between angle
        brackets (<literal>&lt;</literal> and <literal>&gt;</literal>) is
        first executed and then replaced by its string value. Let's try
        this:<screen><prompt>rascal&gt;</prompt> <userinput>N = 13;</userinput>
<computeroutput>int : 13</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>"The value of N is &lt;N&gt;";</userinput>
<computeroutput>str: "The value of N is 13"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>"The value of N*N is &lt;N*N&gt;";</userinput>
<userinput>str: "The value of N*N is 169"</userinput>

<prompt>rascal&gt;</prompt> <userinput>"The value is &lt;(N &lt; 10) ? 10 : N*N&gt;";</userinput>
<computeroutput>str: "The value of 169"</computeroutput>
</screen></para>

        <para>As you can see the string value of variables and expressions is
        interpolated in the result as expected. As we will see later on,
        various statements (<keysym>if</keysym>, <keysym>for</keysym>,
        <keysym>while</keysym>, <keysym>do</keysym>) also return a value and
        can be used in this way. In the interpolation variant of these
        statements the block or blocks that are part of the statement become
        arbitrary text (that may itself contain interpolations). Their forms
        are:<programlisting>&lt;if(<replaceable>Exp</replaceable>){&gt; ... <replaceable>Text</replaceable> ... &lt;}&gt;
&lt;if(<replaceable>Exp</replaceable>){&gt; ... <replaceable>Text</replaceable> ... &lt;} else {&gt;  ... <replaceable>Text</replaceable> ... &lt;}&gt;
&lt;for(<replaceable>Exp</replaceable>){&gt;... <replaceable>Text</replaceable> ... &lt;}&gt;
&lt;while(<replaceable>Exp</replaceable>){&gt; ... <replaceable>Text</replaceable> ... &lt;}&gt;
&lt;do {&gt;... <replaceable>Text</replaceable> ... &lt;} while (<replaceable>Exp</replaceable>)&gt;
</programlisting></para>

        <para>Here <replaceable>Text </replaceable>is arbitrary text that may
        itself contain again contain interpolations.</para>

        <para>Let's apply this to some examples:<screen><prompt>rascal&gt;</prompt> <userinput>"N is &lt;if(N &lt; 10){&gt; small &lt;} else {&gt; large &lt;}&gt;";</userinput>
<computeroutput>str: "N is large "</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>"N is &lt;if(N &lt; 10){&gt; small &lt;} else {&gt; large (&lt;N&gt;)&lt;}&gt;";</userinput>
<computeroutput>str: "N is  large (13)"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>"before &lt;for(x&lt;-[1..5]){&gt;a &lt;x&gt; b &lt;}&gt;after";</userinput>
<computeroutput>str: "before a 1 b a 2 b a 3 b a 4 b a 5 b after"</computeroutput>
</screen>String interpolation enables very flexible template-based text
        generation.</para>

        <formalpara>
          <title>Location</title>

          <para>Location values are represented by the type
          <literal>loc</literal> and serve as text coordinates in a specific
          local or remote source file. It is very handy to associate a source
          code location which extracted facts.</para>
        </formalpara>

        <para>Source locations have the following syntax:</para>

        <para><programlisting>|<replaceable>Uri</replaceable>|(<replaceable>O</replaceable>,<replaceable>L</replaceable>,&lt;<replaceable>BL</replaceable>,<replaceable>BC</replaceable>&gt;,&lt;<replaceable>EL</replaceable>,<replaceable>EC&gt;)</replaceable></programlisting>where:</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>Url</replaceable> is an arbitrary Uniform
            Resource Identifier (URI).</para>
          </listitem>

          <listitem>
            <para><replaceable>O</replaceable> and
            <replaceable>L</replaceable> are integer expressions giving the
            offset of this location to the begin of file, respectively , its
            length.</para>
          </listitem>

          <listitem>
            <para><replaceable>BL</replaceable> and
            <replaceable>BC</replaceable> are integers expressions giving the
            begin line and begin column.</para>
          </listitem>

          <listitem>
            <para><replaceable>EL</replaceable> and
            <replaceable>EC</replaceable> are integers expressions giving the
            end line and end column.</para>
          </listitem>
        </itemizedlist>

        <para>URIs are explained in <link
        xlink:href="http://en.wikipedia.org/wiki/Uniform_Resource_Identifier">http://en.wikipedia.org/wiki/Uniform_Resource_Identifier</link>.
        From their original definition in RFC3986 we cite the following useful
        overview of an URI:<programlisting>         foo://example.com:8042/over/there?name=ferret#nose
         \_/   \______________/\_________/ \_________/ \__/
          |           |            |            |        |
       scheme     authority       path        query   fragment
          |   _____________________|__
         / \ /                        \
         urn:example:animal:ferret:nose</programlisting></para>

        <para>Locations should <emphasis>always</emphasis> be generated
        automatically but for the curious here is an example: <programlisting>|file:///home/paulk/pico.trm|(0,1,&lt;2,3&gt;,&lt;4,5&gt;)</programlisting></para>

        <para>The elements of a location value can be accessed and modified
        using the standard mechanism of field selection and field assignment.
        The corresponding field names are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>uri</literal>: the URI of the location. Also
            subfields of the URI can be accessed:</para>

            <itemizedlist>
              <listitem>
                <para><literal>scheme</literal>: the scheme (or protocol) like
                <literal>http</literal> or <literal>file</literal>. Also
                supported is <literal>cwd:</literal> for current working
                directory (the directory from which Rascal was
                started).</para>
              </listitem>

              <listitem>
                <para><literal>authority</literal>: the domain where the data
                are located.</para>
              </listitem>

              <listitem>
                <para><literal>host</literal>: the host where the URI is
                hosted (part of auhtority).</para>
              </listitem>

              <listitem>
                <para><literal>port</literal>: port on host (part
                ofauthority).</para>
              </listitem>

              <listitem>
                <para><literal>path</literal>: path name of file on
                host.</para>
              </listitem>

              <listitem>
                <para><literal>extension</literal>: file name
                extension.</para>
              </listitem>

              <listitem>
                <para><literal>query</literal>: query data</para>
              </listitem>

              <listitem>
                <para><literal>fragment</literal>: the fragment name following
                the path name and query data.</para>
              </listitem>

              <listitem>
                <para><literal>user</literal>: user info (only present in
                schemes like mailto).</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><literal>offset</literal>: start of text area.</para>
          </listitem>

          <listitem>
            <para><literal>length</literal>: length of text area</para>
          </listitem>

          <listitem>
            <para><literal>begin.line</literal>,
            <literal>begin.column</literal>: begin line and column of text
            area.</para>
          </listitem>

          <listitem>
            <para><literal>end.line</literal>, <literal>end.column</literal>
            end line and column of text area.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>List, Set, Map, Tuple, and Relation</title>

        <formalpara>
          <title>List</title>

          <para>A list is an ordered sequence of values and has the following
          properties:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>All elements have the same static type.</para>
          </listitem>

          <listitem>
            <para>The order of the elements matters.</para>
          </listitem>

          <listitem>
            <para>The list may contain the same element more than once.</para>
          </listitem>
        </itemizedlist>

        <para>Lists are represented by the type
        <literal>list[</literal><replaceable>T</replaceable><literal>]</literal>,
        where <replaceable>T</replaceable> is an arbitrary type. Examples are
        <literal>list[int]</literal>, <literal>list[tuple[int,int]]</literal>
        and <literal>list[list[str]]</literal>. Lists are denoted by a list of
        elements, separated by comma's and enclosed in bracket as in
        <literal>[</literal><replaceable>E</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>2</subscript><literal>,
        ...,</literal>
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript><literal>]</literal>,
        where the
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript>
        (1 &lt;= <replaceable>i</replaceable>&lt;=
        <replaceable>n</replaceable>) are expressions that yield the desired
        element type. For example,</para>

        <itemizedlist>
          <listitem>
            <para><literal>[1, 2, 3]</literal> is of type
            <literal>list[int]</literal>,</para>
          </listitem>

          <listitem>
            <para><literal>{&lt;1,10&gt;, &lt;2,20&gt;,
            &lt;3,30&gt;}</literal> is of type
            <literal>set[tuple[int,int]]</literal>,</para>
          </listitem>

          <listitem>
            <para><literal>[1, "b", 3]</literal> is of type
            <literal>list[value]</literal>,</para>
          </listitem>

          <listitem>
            <para><literal>[&lt;"a",10&gt;, &lt;"b",20&gt;,
            &lt;"c",30&gt;]</literal> is of type
            <literal>list[tuple[str,int]]</literal>, and</para>
          </listitem>

          <listitem>
            <para><literal>[["a", "b"], ["c", "d", "e"]]</literal> is of type
            <literal>list[list[str]]</literal>.</para>
          </listitem>
        </itemizedlist>

        <para><note>
            <para><literal>[1, 2, 3]</literal> and <literal>[3, 2,
            1]</literal> are different lists.</para>
          </note><note>
            <para><literal>[1, 2, 3]</literal> and <literal>[1, 2, 3,
            1]</literal> are also different lists.</para>
          </note></para>

        <para>When variables of type list occur inside a list, their elements
        are automatically <emphasis>spliced</emphasis> into the surrounding
        list. This can be prevented by surrounding them with extra [ and ]
        brackets.<screen><prompt>rascal&gt;</prompt> <userinput>L = [1, 2, 3];</userinput>
<computeroutput>list[int]: [1,2,3]</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>[10, L, 20];</userinput>
<computeroutput>list[int]: [10, 1, 2, 3, 20]</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>[10, [L], 20];</userinput>
<computeroutput>list[value]: [10, [1,2,3], 20]</computeroutput></screen></para>

        <formalpara>
          <title>Range</title>

          <para>For lists of integers, a special shorthand exists to describe
          ranges of integers:<itemizedlist>
              <listitem>
                <para><literal>[<replaceable>F</replaceable> ..
                <replaceable>L</replaceable>]</literal> ranges from first
                element <replaceable>F</replaceable> up to (and including)
                last element <replaceable>L</replaceable> with increments of
                1.</para>
              </listitem>

              <listitem>
                <para><literal>[<replaceable>F</replaceable>,<replaceable>S</replaceable>,..<replaceable>
                E</replaceable>]</literal>, ranges from first element
                <replaceable>F</replaceable>, second element S up to (and
                including) last element <replaceable>L</replaceable> with
                increments of <literal>S</literal> -
                <replaceable>F</replaceable>.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <formalpara>
          <title>Set</title>

          <para>A set is an unordered sequence of values and has the following
          properties:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>All elements have the same static type.</para>
          </listitem>

          <listitem>
            <para>The order of the elements does not matter.</para>
          </listitem>

          <listitem>
            <para>A set contains an element only once. In other words,
            duplicate elements are eliminated and no matter how many times an
            element is added to a set, it will occur in it only once.</para>
          </listitem>
        </itemizedlist>

        <para>Sets are represented by the type
        <literal>set[</literal><replaceable>T</replaceable><literal>]</literal>,
        where <replaceable>T</replaceable> is an arbitrary type. Examples are
        <literal>set[int]</literal>, <literal>set[tuple[int,int]]</literal>
        and <literal>set[set[str]]</literal>. Sets are denoted by a list of
        elements, separated by comma's and enclosed in braces as in
        <literal>{</literal><replaceable>E</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>2</subscript><literal>,
        ...,</literal>
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript><literal>}</literal>,
        where the
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript>
        (1 &lt;= <replaceable>i</replaceable>&lt;=
        <replaceable>n</replaceable>) are expressions that yield the desired
        element type. For example,</para>

        <itemizedlist>
          <listitem>
            <para><literal>{1, 2, 3}</literal> is of type
            <literal>set[int]</literal>,</para>
          </listitem>

          <listitem>
            <para><literal>{&lt;1,10&gt;, &lt;2,20&gt;,
            &lt;3,30&gt;}</literal> is of type
            <literal>set[tuple[int,int]]</literal>,</para>
          </listitem>

          <listitem>
            <para><literal>{1, "b", 3}</literal> is of type
            <literal>set[value]</literal>,</para>
          </listitem>

          <listitem>
            <para><literal>{&lt;"a",10&gt;, &lt;"b",20&gt;,
            &lt;"c",30&gt;}</literal> is of type
            <literal>set[tuple[str,int]]</literal>, and</para>
          </listitem>

          <listitem>
            <para><literal>{{"a", "b"}, {"c", "d", "e"}}</literal> is of type
            <literal>set[set[str]]</literal>.</para>
          </listitem>
        </itemizedlist>

        <para><note>
            <para><literal>{1, 2, 3}</literal> and <literal>{3, 2,
            1}</literal> are identical sets.</para>
          </note><note>
            <para><literal>{1, 2, 3}</literal> and <literal>{1, 2, 3,
            1}</literal> are also identical sets.</para>
          </note>In a similar fashion as with lists, sets variables are
        automatically spliced into a surrounding set. This can be prevented by
        surrounding them with extra { and } brackets.<screen><prompt>rascal&gt;</prompt> <userinput>S = {1, 2, 3};</userinput>
<computeroutput>set[int]: {1,2,3]}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{10, S, 20};</userinput>
<computeroutput>set[int]: {10, 1, 2, 3, 20]}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{10, {L}, 20};</userinput>
<computeroutput>lsetist[value]: {10, {1,2,3}, 20}</computeroutput></screen></para>

        <formalpara>
          <title>Map</title>

          <para>A map is a set of key : value pairs and has the following
          properties:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>Key and value may have different static types.</para>
          </listitem>

          <listitem>
            <para>A key can only occur once.</para>
          </listitem>
        </itemizedlist>

        <para>Maps are represented by the type
        <literal>map[</literal><replaceable>T</replaceable><literal><subscript>1</subscript>,
        <replaceable>T</replaceable><subscript>2</subscript>]</literal>, where
        <replaceable>T</replaceable><literal><subscript>1</subscript> and
        <replaceable>T</replaceable><subscript>2</subscript></literal> are
        arbitrary types. Examples are <literal>map[int,int]</literal>, and
        <literal>map[str,int]</literal>. Maps are denoted by a list of pairs,
        separated by comma's and enclosed in parentheses as in
        <literal>(</literal><replaceable>K</replaceable><subscript>1</subscript><literal>:</literal>
        <replaceable>V</replaceable><subscript>1</subscript><literal>,
        ...,</literal>
        <replaceable>K</replaceable><subscript>n</subscript><literal>:</literal>
        <replaceable>V</replaceable><subscript>n</subscript><literal>)</literal>,
        where the
        <replaceable>K</replaceable><subscript><replaceable>n</replaceable></subscript>
        (1 &lt;= <replaceable>i</replaceable>&lt;=
        <replaceable>n</replaceable>) are expressions that yield the keys of
        the map and
        <replaceable>V</replaceable><subscript><replaceable>n</replaceable></subscript>
        (1 &lt;= <replaceable>i</replaceable>&lt;=
        <replaceable>n</replaceable>) are expressions that yield the values
        for each key. Maps resemble functions rather than relations in the
        sense that only a single value can be associated with each key. For
        example,</para>

        <itemizedlist>
          <listitem>
            <para><literal>("pear" : 1, "apple" : 3, "banana" : 0)</literal>
            is of type <literal>map[str,int]</literal>.</para>
          </listitem>
        </itemizedlist>

        <formalpara>
          <title>Tuple</title>

          <para>A tuple is a sequence of elements with the following
          properties:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>Each element in a tuple (may) have a different type.</para>
          </listitem>

          <listitem>
            <para>Each element of a tuple may have a label that can be used to
            select that element of the tuple.</para>
          </listitem>
        </itemizedlist>

        <para>Tuples are represented by the type
        <literal>tuple[</literal><replaceable>T</replaceable><subscript>1</subscript><literal><replaceable>L</replaceable><subscript>1</subscript>,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal><replaceable>L<subscript>2</subscript></replaceable>,
        ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        <replaceable>L</replaceable><subscript>n</subscript> ], where
        <replaceable>T</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal>,
        ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        are arbitrary types and
        <replaceable>L<subscript>1</subscript></replaceable><literal>,</literal>
        <replaceable>L</replaceable><subscript>2</subscript><literal>,
        ...,</literal> <replaceable>L</replaceable><subscript>n</subscript>
        are optional labels. An example of a tuple type is <literal>tuple[str
        name, int freq]</literal>. Examples are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>&lt;1, 2&gt;</literal> is of type
            <literal>tuple[int, int]</literal>,</para>
          </listitem>

          <listitem>
            <para><literal>&lt;1, 2, 3&gt;</literal> is of type
            <literal>tuple[int, int, int]</literal>,</para>
          </listitem>

          <listitem>
            <para><literal>&lt;"a", 3&gt;</literal> is of type
            <literal>tuple[str name, int freq].</literal></para>
          </listitem>
        </itemizedlist>

        <para>The elements of a tuple can also be labelled and can then be
        accessed using the field selection operator (<literal>.</literal>).
        Fields can be changed (yielding a new tuple value) by a combination of
        field selection and assignment. For instance,<screen><prompt>rascal&gt;</prompt> <userinput>tuple[str first, str last, int age] P = &lt;"Jo","Jones",35&gt;;</userinput>
<computeroutput>tuple[str first, str last, int age] P = &lt;"Jo", "Jones", 35&gt;;
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>P.first;</userinput>
<computeroutput>str: "Jo"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>P.first = "Bo";</userinput>
<computeroutput>tuple[str first,str last,int age]: &lt;"Bo","Jones",35&gt;</computeroutput></screen></para>

        <formalpara>
          <title>Relation</title>

          <para>A relation is a set of elements with the following
          property:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>All elements have the same static tuple type.</para>
          </listitem>
        </itemizedlist>

        <para>Relations are thus nothing more than sets of tuples, but since
        they are used so often we provide a shorthand notation for them.
        Relations are represented by the type
        <literal>rel[</literal><replaceable>T</replaceable><subscript>1</subscript><literal><replaceable>L</replaceable><subscript>1</subscript>,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal><replaceable>L<subscript>2</subscript></replaceable>,
        ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        <replaceable>L</replaceable><subscript>n</subscript> ], where
        <replaceable>T</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal>,
        ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        are arbitrary types and
        <replaceable>L<subscript>1</subscript></replaceable><literal>,</literal>
        <replaceable>L</replaceable><subscript>2</subscript><literal>,
        ...,</literal> <replaceable>L</replaceable><subscript>n</subscript>
        are optional labels. It is a shorthand for
        <literal>set[tuple[</literal><replaceable>T</replaceable><subscript>1</subscript><literal><replaceable>L</replaceable><subscript>1</subscript>
        ,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal><replaceable>L<subscript>2</subscript></replaceable>,
        ...,</literal>
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>
        <replaceable>L</replaceable><subscript>n</subscript>
        ]<literal>]</literal>. Examples are <literal>rel[int,str]</literal>
        and <literal>rel[int,set[str]]</literal>. An n-ary relations with m
        tuples is denoted by
        <literal>{&lt;</literal><replaceable>E</replaceable><subscript>11</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>12</subscript><literal>, ...,
        <replaceable>E</replaceable><subscript>1n</subscript>&gt;,</literal><literal>&lt;</literal><replaceable>E</replaceable><subscript>21</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>22</subscript><literal>, ...,
        <replaceable>E</replaceable><subscript>2n</subscript>&gt;</literal><literal>,
        ...,</literal><literal>&lt;</literal><replaceable>E</replaceable><subscript>m1</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>m2</subscript><literal>, ...,
        <replaceable>E</replaceable><subscript>mn</subscript>&gt;</literal><literal>}</literal>,
        where the
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable><replaceable>j</replaceable></subscript>
        are expressions that yield the desired element type. For example,
        <literal>{&lt;1, "a"&gt;, &lt;2, "b"&gt;, &lt;3,"c"&gt;}</literal> is
        of type <literal>rel[int, str]</literal>. Examples are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>{&lt;1,10&gt;, &lt;2,20&gt;,
            &lt;3,30&gt;}</literal> is of type <literal>rel[int,int]</literal>
            (yes indeed, you saw this same example before and then we gave
            <literal>set[tuple[int,int]]</literal> as its type; remember that
            these types are interchangeable.),</para>
          </listitem>

          <listitem>
            <para><literal>{&lt;"a",10&gt;, &lt;"b",20&gt;,
            &lt;"c",30&gt;}</literal> is of type
            <literal>rel[str,int]</literal>, and</para>
          </listitem>

          <listitem>
            <para><literal>{&lt;"a", 1, "b"&gt;, &lt;"c", 2,
            "d"&gt;}</literal> is of type
            <literal>rel[str,int,str]</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.alias">
        <title>Alias Type</title>

        <para>Everything can be expressed using the elementary types and
        values that are provided by Rascal. However, for the purpose of
        documentation and readability it is sometimes better to use a
        descriptive name as type indication, rather than an elementary type.
        The alias declaration</para>

        <programlisting>alias <replaceable>Name</replaceable>  = <replaceable>Type</replaceable>;</programlisting>

        <para>states that <replaceable>Name</replaceable> can be used
        everywhere instead of the already defined type
        <replaceable>Type</replaceable>. Both types are thus structurally
        equivalent. For instance,</para>

        <programlisting audience="" role="check">alias ModuleId = str;
alias Frequency = int;</programlisting>

        <para>introduces two new type names <literal>ModuleId</literal> and
        <literal>Frequency</literal>, both an alias for the type
        <literal>str</literal>. The use of type aliases is a good way to
        document your intentions. Another example is an alias definition for a
        graph containing integer nodes:</para>

        <para><programlisting>alias IntGraph = rel[int,int];</programlisting></para>

        <para>Note that Rascal Standard Library provides a graph data type
        that is defined as follows:</para>

        <para><programlisting>alias Graph[&amp;T] = rel[&amp;T, &amp;T];</programlisting>In
        other words the standard graph datatype can be parameterized with any
        element type. See <xref linkend="section.lib-Graph" /> for
        details.</para>
      </section>

      <section xml:id="section.abstract-data-type">
        <title>Data Type</title>

        <para>In ordinary programming languages record types or classes exist
        to introduce a new type name for a collection of related, named,
        values and to provide access to the elements of such a collection
        through their name. In Rascal, data declarations provide this
        facility. The type declaration</para>

        <programlisting><literal>data <replaceable>Name</replaceable> = <replaceable>Alt</replaceable><subscript>1</subscript> | <replaceable>Alt</replaceable><subscript>1</subscript> | ...</literal></programlisting>

        <para>introduces a new datatype <replaceable>Name</replaceable> and
        its alternative forms
        <replaceable>Alt</replaceable><subscript>1</subscript>,
        <replaceable>Alt</replaceable><subscript>2</subscript>, ... . The
        description of an alternative is identical in form to the type
        declaration of a function. For instance, <programlisting>data Bool = 
     tt() | ff() | conj(Bool L, Bool R)  | disj(Bool L, Bool R);  </programlisting>defines
        the datatype <literal>Bool</literal> that contains various constants
        (<literal>Ttt()</literal> and <literal>F</literal>ff() and constructor
        functions <literal>conj</literal> and <literal>disj</literal>.</para>

        <!--Exception: data constructors do not allow variable arguments.-->
      </section>

      <section>
        <title>Type Parameters, Type Constaints and Parameterized Types and
        Aliases</title>

        <para>In addition to the types that we have already discussed, a type
        may also be a <emphasis>type parameter</emphasis> of the
        form<programlisting><literal>&amp;</literal><replaceable>Name</replaceable></programlisting>A
        type parameter may occur at every syntactic position where a type is
        required and turns an ordinary type into a parameterized type.
        Parameterized types are used to define polymorphic functions and data
        types, i.e., functions and data types that are applicable for more
        than one type. Type parameters are bound to an actual type when the
        function or data type is applied and further uses of the type
        parameter are consistently replaced by the actual type.</para>

        <para>The following syntactic positions are <emphasis>binding
        occurrences</emphasis> for type parameters:</para>

        <itemizedlist>
          <listitem>
            <para>Type parameters in the type declaration of a function are
            bound to the types of the actual parameters in the call of that
            function. Type parameters that occur in the body of the function
            are replaced by the corresponding actual types.</para>
          </listitem>

          <listitem>
            <para>The left-hand side of an alias. The type parameters are
            bound when the alias is used and occurrences of type parameters in
            the right hand side are replaced by corresponding actual
            types.</para>
          </listitem>

          <listitem>
            <para>The alternatives of a data type. Binding and replacement is
            identical to that of function declarations.</para>
          </listitem>
        </itemizedlist>

        <para>All other occurrences of type parameters are <emphasis>using
        occurrences</emphasis>. The following rules apply:</para>

        <itemizedlist>
          <listitem>
            <para>When the same type parameter is used at different binding
            occurrences it should be bound to the same actual type.</para>
          </listitem>

          <listitem>
            <para>For every using occurrence of a type parameter there should
            be a binding occurrence of a type parameter with the same
            name.</para>
          </listitem>
        </itemizedlist>

        <para>As a final refinement, constraints can be imposed on the actual
        types to which a type parameter may be bound. This is expressed by a
        subtype constraint of the form:</para>

        <para><programlisting><literal>&amp;</literal><replaceable>Name &lt;: Type</replaceable></programlisting>which
        expresses that actual types bound to <replaceable>Name</replaceable>
        should be a subtype of <replaceable>Type</replaceable>. More on
        subtyping in <xref linkend="section.typing" />.</para>

        <para>Let's consider a small example of the use of function parameters
        in a function declaration, we refer to <xref
        linkend="section.function" /> for a full description of function
        declarations. The following function <literal>swap</literal> returns a
        tuple in which its arguments are swapped and can be applied to
        arbitrary values in a type safe manner:<screen><prompt>rascal&gt;</prompt> <userinput>tuple[&amp;B, &amp;A] swap(&amp;A a, &amp;B b) { return &lt;b, a&gt;; }</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>swap(1,2);</userinput>
<computeroutput>tuple[int,int]: &lt;2,1&gt;
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>swap("abc", 3);</userinput>
<computeroutput>tuple[int,str]: &lt;3, "abc"&gt;</computeroutput></screen>Observe
        that the type parameters that are used in the return type should be
        defined in the declarations of the formal parameter of the
        function.</para>

        <para>An alias definition may also be parameterized. So we can
        generalize graphs as follows:</para>

        <para><screen><prompt>rascal&gt;</prompt> <userinput>alias Graph[&amp;Node] = rel[&amp;Node, &amp;Node];</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>Graph[int] GI = {&lt;1,2&gt;, &lt;3,4&gt;, &lt;4,1&gt;};</userinput>
<computeroutput>Graph[int] :  {&lt;1,2&gt;, &lt;3,4&gt;, &lt;4,1&gt;}
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>Graph[str] GS = {&lt;"a", "b"&gt;, &lt;"c","d"&gt;, &lt;"d", "a"&gt;};</userinput>
<computeroutput>Graph[str] : {&lt;"a", "b"&gt;, &lt;"c","d"&gt;, &lt;"d", "a"&gt;}</computeroutput></screen>The
        type parameters that are used in the type in the right part of the
        alias declaration should be defined in the left part of the alias
        definition.</para>
      </section>

      <section xml:id="section.reified-types">
        <title>Reified Types</title>

        <para>Usually one declares functions that have arguments that have a
        type that corresponds to one of the many forms of values in Rascal. In
        exceptional circumstances it is desirable to define functions that
        have a type itself as argument. The prototypical example is a parse
        function: how to write a type safe parse function that expresses the
        type of the result we expect? Suppose we want to parse a language that
        has the non-terminals <literal>EXP</literal>, <literal>STAT</literal>
        and <literal>PROGRAM</literal>. A first, naive, solution introduces a
        parse function for each non-terminal:</para>

        <para><programlisting>EXP parseEXP(str s){ ... }
STAT parsePROGRAM(str s) { ... }
PROGRAM parsePROGRAM(str s) { ... }</programlisting>Unfortunately this
        solution does not scale well to large languages with many
        non-terminals and it breaks down completely when we do not know the
        non-terminals before hand.</para>

        <para>To solve this problem in a more general manner something special
        has to be done. Types are not values and without an additional
        mechanism they cannot be passed as arguments to functions. To achieve
        this effect we introduce <emphasis>reified types</emphasis> that are
        denoted by the type <keysym>type</keysym>. Now we can
        write:<programlisting>&amp;T parse(type[&amp;T] start, str s) { ... }</programlisting>and
        use the parse by giving it a type as argument:<programlisting>parse(EXP, "1+3");</programlisting><!--Er zijn vele vragen hier:
(1) Is het mogelijk een dergelijk functie in Rascal zelf te schrijven?
(2) Kunne reified types ook in aliasen gebruikt worden? Zo ja hoe?
(3) Idem voor data declaraties.--></para>
      </section>

      <section xml:id="section.typing">
        <title>Typing</title>

        <para xml:id="figure.type-lattice">Rascal is based on static typing,
        this means that as many errors and inconsistencies as possible are
        spotted before the program is executed. The types introduced earlier
        are ordered in a so-called <emphasis>type lattice</emphasis> shown in
        <xref linkend="figure.type-lattice" />. The arrows describe a
        <emphasis>subtype-of</emphasis> relation between types. The type void
        is the <emphasis>smallest</emphasis> type and is included in all other
        types and the type value is the <emphasis>largest</emphasis> type that
        includes all other types. We also see that <literal>rel</literal> is a
        subtype of <literal>set</literal> and that each ADT is a subtype of
        <literal>node</literal>. A special role is played by the datatype
        <literal>Tree</literal> that is the generic type of syntax trees.
        Syntax trees for specific languages are all subtypes of Tree. As a
        result, syntax trees can be addressed at two levels: in a generic
        fashion as <literal>Tree</literal> and in a specific fashion as a more
        precisely typed syntax tree. Finally, each alias is structurally
        equivalent to one or more specific other types.<figure>
            <title>The Rascal Type Lattice</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="type-lattice.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>
    </section>

    <section xml:id="section.declarations">
      <title>Declarations</title>

      <section>
        <title>Rascal Program</title>

        <para>A Rascal program consists of a number of modules that may import
        each other.</para>
      </section>

      <section>
        <title>Module</title>

        <para>A module declaration has the following form:</para>

        <para><programlisting><keysym>module</keysym> <replaceable>Name</replaceable>
<literal><replaceable>Imports;
Declaration</replaceable><subscript>1</subscript>;
...
<replaceable>Declaration</replaceable><subscript>n</subscript>;</literal></programlisting>and
        consists of a <replaceable>Name</replaceable> and zero or more imports
        of other modules, see<xref linkend="section.import" />, and
        declarations for</para>

        <itemizedlist>
          <listitem>
            <para>Data type, see <xref
            linkend="section.abstract-data-type" />.</para>
          </listitem>

          <listitem>
            <para>Alias, see <xref linkend="section.alias" />.</para>
          </listitem>

          <listitem>
            <para>Variable, see <xref linkend="section.variable" />.</para>
          </listitem>

          <listitem>
            <para>Function, see <xref linkend="section.function" />.</para>
          </listitem>

          <listitem>
            <para>Rewrite rule, see <xref
            linkend="section.rewrite-rule" />.</para>
          </listitem>

          <listitem>
            <para>Node annotation, see <xref
            linkend="section.node-annotation" />.</para>
          </listitem>

          <listitem>
            <para>Declaration tag, see <xref
            linkend="section.declaration-tag" />.</para>
          </listitem>
        </itemizedlist>

        <para>The module name <replaceable>Name</replaceable> will be used
        when the current module is imported in another module. A module is
        usually a qualified name of the form:<programlisting><replaceable>Name</replaceable><subscript>1</subscript><literal>::</literal><replaceable>Name</replaceable><subscript>2</subscript><literal>::</literal> ... <literal>::</literal><replaceable>Name</replaceable><subscript>n</subscript></programlisting></para>

        <para>which corresponds to a path relative to the root of the current
        workspace.</para>

        <!--Explain this better.-->

        <para>The constituents of a module are also shown in <xref
        linkend="figure.parts-module" />. The less familiar features are shown
        in a separate color.</para>

        <para>The entities that are <emphasis>visible</emphasis> inside a
        module are</para>

        <itemizedlist>
          <listitem>
            <para>The private or public entities declared in the module
            itself.</para>
          </listitem>

          <listitem>
            <para>The public entities declared in any imported module.</para>
          </listitem>
        </itemizedlist>

        <para>The only entities that are visible outside the module, are the
        public entities declared in the module itself. The visible entities of
        an imported may be explicitly qualified with their module
        name:<programlisting><replaceable>Module</replaceable><literal>::</literal><replaceable>Name</replaceable></programlisting><figure
            xml:id="figure.parts-module">
            <title>Constituents of a Module</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="module-parts.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section xml:id="section.import">
        <title>Import</title>

        <para>An import has the form:<programlisting><keysym>import</keysym> <literal><replaceable>QualifiedName</replaceable>;</literal></programlisting>and
        has as effect that all public entities declared in module
        <replaceable>QualifiedName</replaceable> are made available to the
        importing module. Circular imports are allowed. Two kinds of imported
        modules are supported:</para>

        <itemizedlist>
          <listitem>
            <para>Another Rascal module.</para>
          </listitem>

          <listitem>
            <para>An SDF module that defines the syntax of some language,
            say<replaceable> L</replaceable>.</para>
          </listitem>
        </itemizedlist>

        <para>In the former case, all publicly visible entities in the
        imported module become available in the importing module. In the
        latter case, all non-terminals (symbols in SDF parlance) that are
        declared in <replaceable>L</replaceable> become available as types in
        the importing module. In addition, concrete syntax patterns and parse
        functions can be used for any non-terminal that is defined in
        <replaceable>L</replaceable>.</para>
      </section>

      <section xml:id="section.function">
        <title>Function Declaration</title>

        <para>A function declaration has the form<programlisting><replaceable>Type</replaceable> <replaceable>Name</replaceable>(<literal><replaceable>Type</replaceable></literal><subscript>1</subscript> <replaceable>Var</replaceable><subscript>1</subscript>, ..., <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript> <replaceable>Var</replaceable><replaceable><subscript>n</subscript></replaceable>) <replaceable>Statement</replaceable></programlisting>Here
        <replaceable>Type</replaceable> is the result type of the function and
        this should be equal to the type of the result of
        <replaceable>Statement</replaceable> (using the return statement, see
        <xref linkend="section.return" />). Each
        <replaceable>Type</replaceable><subscript><replaceable>i</replaceable></subscript>
        <replaceable>Var</replaceable><replaceable><subscript>i</subscript></replaceable>
        represents a typed formal parameter of the function. The formal
        parameters may be used in <replaceable>Statement</replaceable> and get
        their value when function <replaceable>Name</replaceable> is invoked.
        Example:<screen><prompt>rascal&gt;</prompt> <userinput>rel[int, int] invert(rel[int,int] R){
            return {&lt;Y, X&gt; | &lt;int X, int Y&gt; &lt;- R }
        }</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput><literal>invert({&lt;1,10&gt;, &lt;2,20&gt;})</literal>;</userinput>
<computeroutput>rel[int,int] : {&lt;10,1&gt;, &lt;20,2&gt;}</computeroutput></screen></para>

        <formalpara>
          <title>Variable argument lists</title>

          <para>A function may have a variable list of arguments, this has the
          form:<programlisting><replaceable>Type</replaceable> <replaceable>Name</replaceable>(<emphasis>ordinary parameters</emphasis>, <replaceable>Type</replaceable> <replaceable>Var</replaceable>...) <replaceable>Statement</replaceable></programlisting></para>
        </formalpara>

        <para>The last parameter of a function may be followed by
        <literal>...</literal> and this has as effect that all remaining
        actual parameters that occur in a call to this function are collected
        as list value of the last formal parameter. Inside the function body,
        the type of this parameter will therefore be
        <literal>list[</literal><replaceable>Type</replaceable><literal>]</literal>.</para>

        <formalpara>
          <title>Exceptions</title>

          <para>The exceptions that can be thrown by a function can be
          (optionally) declared as follows:<programlisting><replaceable>Type</replaceable> <replaceable>Name</replaceable>(<literal><replaceable>Type</replaceable></literal><subscript>1</subscript> <replaceable>Var</replaceable><subscript>1</subscript>, ..., <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript> <replaceable>Var</replaceable><replaceable><subscript>n</subscript></replaceable>) 
     throws <replaceable>Exception</replaceable><subscript>1</subscript>, <replaceable>Exception</replaceable><subscript>2</subscript>, ...<replaceable> </replaceable></programlisting>See
          <xref linkend="section.try-catch" /> and <xref
          linkend="section.throw" /> for details.</para>
        </formalpara>

        <formalpara>
          <title>Parameterized types in function declaration</title>

          <para>The types that occur in function declarations may also contain
          <emphasis>type variables</emphasis> that are written as
          <literal>&amp;</literal> followed by an identifier. In this way
          functions can be defined for arbitrary types. In the following
          example, we declare an inversion function that is applicable to any
          binary relation. :<screen><prompt>rascal&gt;</prompt> <userinput>rel[&amp;T2, &amp;T1] invert2(rel[&amp;T1,&amp;T2] R){  
            return {&lt;Y, X&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; &lt;- R };
        }</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt><literal> </literal><userinput><literal>invert2({&lt;1,10&gt;, &lt;2,20&gt;})</literal>;</userinput>
<computeroutput>rel[int,int] : {&lt;10,1&gt;, &lt;20,2&gt;}
</computeroutput>
<prompt>rascal&gt;</prompt><literal> </literal><userinput><literal>invert2({&lt;"mon", 1&gt;, &lt;"tue", 2&gt;})</literal>;</userinput>
<computeroutput>rel[int,str] : {&lt;1, "mon"&gt;, &lt;2, "tue"&gt;}</computeroutput></screen>Here
          we declare a function that can be used to swap the elements of pairs
          of arbitrary types:<screen><prompt>rascal&gt;</prompt> <userinput>tuple[&amp;T2, &amp;T1] swap(&amp;T1 A, &amp;T2 B) { return &lt;B, A&gt;;;}</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput><literal>swap(&lt;1, 2&gt;)</literal>;</userinput>
<computeroutput><literal>tuple[int,int] : &lt;2,1&gt;</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>swap(&lt;"wed", 3&gt;);</userinput>
<computeroutput>tuple[int,str] : &lt;3, "wed"&gt;</computeroutput></screen></para>
        </formalpara>
      </section>

      <section xml:id="section.variable">
        <title>Variable Declaration</title>

        <para>A variable declaration has the form<programlisting><replaceable>Type</replaceable> <replaceable>Var</replaceable> = <replaceable>Exp</replaceable></programlisting>where
        <replaceable>Type</replaceable> is a type,
        <replaceable>Var</replaceable> is a variable name, and
        <replaceable>Exp</replaceable> is an expression that should have type
        <replaceable>Type</replaceable>. The effect is that the value of
        expression <replaceable>Exp</replaceable> is assigned to
        <replaceable>Var</replaceable> and can be used later on as
        <replaceable>Var</replaceable>'s value. The following rules
        apply:</para>

        <itemizedlist>
          <listitem>
            <para>Double declarations in the same scope are not
            allowed.</para>
          </listitem>

          <listitem>
            <para>The type of <replaceable>Exp</replaceable> should be
            compatible with <replaceable>Type</replaceable>, i.e., it should
            be a subtype of <replaceable>Type</replaceable>.</para>
          </listitem>
        </itemizedlist>

        <para>As a convenience, also declarations without an initialization
        expression are permitted inside functions (but not at the module
        level) and have the form <programlisting><replaceable>Type</replaceable> <replaceable>Var</replaceable> </programlisting>and
        only introduce the variable <replaceable>Var</replaceable>. When a
        variable is declared, it has as scope the nearest enclosing block, see
        <xref linkend="section.block" />.</para>

        <para>Rascal provides <emphasis>local type inference</emphasis>, which
        allows the implicit declaration of variables that are used locally in
        functions. The following rules apply:</para>

        <itemizedlist>
          <listitem>
            <para>An implicitly declared variable is declared at the level of
            the current scope, this may the whole function body or a block
            nested in it.</para>
          </listitem>

          <listitem>
            <para>An implicitly declared variable gets as type the type of the
            first value that is assignment to it.</para>
          </listitem>

          <listitem>
            <para>If a variable is implicitly declared in different execution
            path of a function, all these implicit declarations should result
            in the same type.</para>
          </listitem>

          <listitem>
            <para>All uses of an implicitly declared variable must be
            compatible with its implicit type.</para>
          </listitem>
        </itemizedlist>

        <para>Examples.<screen><prompt>rascal&gt;</prompt> <userinput>int max = 100;</userinput>
<computeroutput>int: 100</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>min = 0</userinput>;
<computeroutput>int : 0</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>day = {&lt;"mon", 1&gt;, &lt;"tue", 2&gt;, &lt;"wed",3&gt;, 
              &lt;"thu", 4&gt;, &lt;"fri", 5&gt;, &lt;"sat",6&gt;, &lt;"sun",7&gt;}</userinput>
<computeroutput>rel[str,int]: {&lt;"mon", 1&gt;, &lt;"tue", 2&gt;, &lt;"wed",3&gt;, 
               &lt;"thu", 4&gt;, &lt;"fri", 5&gt;, &lt;"sat",6&gt;, &lt;"sun",7&gt;}</computeroutput></screen></para>
      </section>

      <section xml:id="section.declaration-tag">
        <title>Declaration Tag</title>

        <para><warning>
            <para>Tags declarations are not yet implemented.</para>
          </warning><warning>
            <para>The syntax of tags has to be aligned with the syntax of
            annotations.</para>
          </warning>Tags are intended to add meta data to a Rascal program and
        allow to influence the execution of the Rascal program, for instance,
        by adding memoization hints or database mappings for relations.</para>

        <para>All declarations in a Rascal program may contain (in fixed
        positions depending on the declaration type) one or more declaration
        tags (<literal>tag</literal>). A tag is defined by declaring its name,
        the declaration type to which it can be attached, and the name and
        type of the annotation. The declaration type <literal>all</literal>,
        makes the declaration tag applicable for all possible declaration
        types. All declaration tags have the generic format
        <literal>@<replaceable>Name</replaceable>{ ... }</literal>, with
        arbitrary text between the brackets that is further constrained by the
        declared type. Here is an example of a license tag:<programlisting>tag str license on module;</programlisting>This
        will allow to write things like:<programlisting>@license{This module is distributed under the BSD license}
module Booleans
...</programlisting>Other examples of declaration tags are:<programlisting>tag str todo on all             %% todo note for all types
tag void deprecated on function %% marks a deprecated function
tag int memo on function        %% bounded memoization of 
                                %% function calls
tag str doc on all              %% documentation string</programlisting>Here
        is an example of a documentation string as used in the Rascal standard
        library:<programlisting>@doc{Maximum of a set: max}
public &amp;T max(set[&amp;T] R)
{
  &amp;T result = arb(R);
  for(&amp;T E : R){
    result = max(result, E);
  }
  return result;
}</programlisting></para>

        <para>Although user-defined tags are not yet available, the following
        tags are currently provided:<programlisting>tag str doc on function         %% documentation string
tag str javaClass on function   %% implementation class of library 
                                %% function
tag void reflective on function %% library function with access to 
                                %% interpreter state
tag str javaImports on function %% imports needed by a Rascal 
                                %% function with Java body
tag str deprecated on function  %% deprecated function</programlisting></para>
      </section>

      <section xml:id="section.node-annotation">
        <title>Node Annotation Declaration</title>

        <para>An annotation may be associated with any node value. Annotations
        are intended to attach application data to values, like adding
        position information or control flow information to source code or
        adding visualization information to a relation. An annotation has a
        name and the type of its value is explicitly declared. Any value of
        any named type can be annotated and the type of these annotations can
        be declared precisely.</para>

        <para>For instance, we can add to certain syntactic constructs of
        programs (e.g., <literal>EXPRESSION</literal>) an annotation with name
        <literal>posinfo</literal> that contains location
        information:<programlisting>anno loc EXPRESSION @ posinfo;</programlisting>or
        location information could be added for all syntax
        trees:<programlisting>anno loc Tree @ posinfo;</programlisting></para>

        <para>We can add to the graph datatype introduced earlier, the
        annotation with name <literal>LayoutStrategy</literal> that defines
        which graph layout algorithm to apply to a particular graph,
        e.g.,<programlisting>data LayoutStrategy = dot() | tree() | force() | 
                      hierarchy() | fisheye();

anno LayoutStrategy Graph @ strategy;</programlisting></para>

        <para>The following constructs are provided for handling
        annotations:</para>

        <itemizedlist>
          <listitem>
            <para><literal><replaceable>Val</replaceable> @
            <replaceable>Anno</replaceable></literal>: is an expression that
            retrieves the value of annotation <replaceable>Anno</replaceable>
            of value <replaceable>Val</replaceable> (may be
            undefined!).</para>
          </listitem>

          <listitem>
            <para><literal><replaceable>Val1</replaceable>[@<replaceable>Anno</replaceable>
            = <replaceable>Val2]</replaceable></literal>: is an expression
            that sets the value of annotation <replaceable>Anno</replaceable>
            of the value
            <replaceable>Val</replaceable><replaceable>1</replaceable> to
            <replaceable>Val2</replaceable> and returns
            <replaceable>Val1</replaceable> with the new annotation value as
            result.</para>
          </listitem>

          <listitem>
            <para><literal><replaceable>Var</replaceable> @
            <replaceable>Anno</replaceable> =
            <replaceable>Val</replaceable></literal>: is an assignment
            statement that sets the value of annotation
            <replaceable>Anno</replaceable> of the value of variable
            <replaceable>Var</replaceable> to
            <replaceable>Val</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.rewrite-rule">
        <title>Rewrite Rule Declaration</title>

        <para>Functions are the workhorses of Rascal. They can have any value
        as parameter or result and are explicitly called by the user. Also,
        functions are declared inside modules and their visibility can be
        controlled.</para>

        <para>Rewrite rules, on the other hand, operate only on nodes and
        user-defined datatypes, they are implicitly applied when a new value
        (we refer to this as the <emphasis>subject value</emphasis>) is
        constructed. The scope of rewrite rules is the whole Rascal program.
        Rewrite rules are applied to the subject value in a bottom-up fashion.
        As a result, the subject value may be changed. This process is
        repeated as long as there are rules that can be applied to the current
        subject value. Technically, this is called <emphasis>innermost
        rewriting</emphasis>. When done, the result of rewriting the original
        subject value is used instead of that original value.</para>

        <para>Rules have the general form:<programlisting><keysym>rule</keysym> <replaceable>Name</replaceable> <replaceable>PatternWithAction</replaceable></programlisting></para>

        <para>where <replaceable>Name</replaceable> is the name of the rule
        and <replaceable>PatternWithAction</replaceable> is the body of the
        rule consisting of a pattern and an associated action, see <xref
        linkend="section.pattern-with-action" /> for a detailed
        description.</para>

        <para>Here is an example for a user-defined type Booleans:<screen><prompt>rascal&gt;</prompt>
<userinput>data Bool = btrue;
data Bool = bfalse;
data Bool = band(Bool left, Bool right);
data Bool = bor(Bool left, Bool right);  

rule a1 band(btrue, Bool B)    =&gt; B;
rule a2 band(bfalse, Bool B)   =&gt; bfalse;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>band(band(btrue,btrue),band(btrue, bfalse));</userinput>
<computeroutput>Bool: bfalse</computeroutput></screen></para>

        <para>During execution of rules the following applies:</para>

        <itemizedlist>
          <listitem>
            <para>Rules are applied non-deterministically, and in any order of
            matching.</para>
          </listitem>

          <listitem>
            <para>The right-hand side of rules can contain fail statements,
            which cause backtracking over the alternative matches or
            alternative rules for a certain constructor.</para>
          </listitem>

          <listitem>
            <para>When the right-hand side is a statement, an
            <literal>insert</literal> statement determines the value of the
            actual replacement. The insert statement is explained in <xref
            linkend="section.visit" />.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="section.expressions">
      <title>Expressions</title>

      <para>The Expression is the basic unit of evaluation and may consist of
      the ingredients shwon in <xref linkend="figure.exp-parts" />:</para>

      <itemizedlist>
        <listitem>
          <para>An <emphasis>elementary literal value</emphasis>, e.g.,
          constants of type <literal>bool</literal>, <literal>int</literal>,
          <literal>real</literal>, <literal>str</literal> or
          <literal>loc</literal>. Elementary literals evaluate to
          themselves.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>structured value</emphasis> for
          <literal>list</literal>, <literal>set</literal>,
          <literal>map</literal>, <literal>tuple</literal>, or
          <literal>rel</literal>. The elements are first evaluated before the
          structured value is built.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>variable</emphasis>, evaluates to its current
          value.</para>
        </listitem>

        <listitem>
          <para>A call to a function or constructor:</para>

          <itemizedlist>
            <listitem>
              <para>A <emphasis>function call</emphasis>. First the arguments
              are evaluated and the corresponding function is called. The
              value returned by the function is used as value of the function
              call.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>constructor</emphasis>. First the arguments
              are evaluated and then a data value is constructed for the
              corresponding type. This data value is used as value of the
              constructor.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>An <emphasis>operator expression</emphasis>. The operator is
          applied to the arguments; the evaluation order of the arguments
          depends on the operator. The result returned by the operator is used
          as value of the operator expression. We distinguish:</para>

          <itemizedlist>
            <listitem>
              <para>non-Boolean expressions, see <xref
              linkend="section.expressions-non-boolean" />.</para>
            </listitem>

            <listitem>
              <para>Boolean expressions, see <xref
              linkend="section.expressions-boolean" />.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>A pattern, see <xref linkend="section.pattern" />.</para>
        </listitem>

        <listitem>
          <para>A pattern with associated action, see <xref
          linkend="section.pattern-with-action" />.</para>
        </listitem>

        <listitem>
          <para>A comprehension, see <xref
          linkend="section.comprehension" />.</para>
        </listitem>

        <listitem>
          <para>A visit expression, see <xref
          linkend="section.visit" />.</para>
        </listitem>

        <listitem>
          <para>A one expression, see <xref linkend="section.one" />.</para>
        </listitem>

        <listitem>
          <para>An all expression, see <xref linkend="section.all" />.</para>
        </listitem>

        <listitem>
          <para>Some statements like if, for, while and do can also be used in
          expressions, see <xref
          linkend="section.statement-as-expression" />.</para>
        </listitem>
      </itemizedlist>

      <para><figure xml:id="figure.exp-parts">
          <title>Expression Forms</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="exp-parts.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <section xml:id="section.expressions-non-boolean">
        <title>Non-Boolean Operator Expressions</title>

        <para>The non-Boolean operators are summarized in <xref
        linkend="table.non-boolean-operators" />. All operators are highly
        overloaded and we refer to <xref linkend="section.lib" /> for a
        description of their meaning for each specific type. The following
        rules apply:</para>

        <itemizedlist>
          <listitem>
            <para>All <replaceable>name</replaceable> arguments stand for
            themselves and are not evaluated.</para>
          </listitem>

          <listitem>
            <para>For all operators, except, IfThenElse, the argument
            expressions are first evaluated before the operator is
            applied.</para>
          </listitem>

          <listitem>
            <para>The operators in <xref
            linkend="table.non-boolean-operators" /> are listed from high
            precedence to low precedence. In other words, operators listed
            higher in the table bind stronger.</para>
          </listitem>
        </itemizedlist>

        <para><table xml:id="table.non-boolean-operators">
            <title>Non-Boolean Operators</title>

            <tgroup cols="3">
              <colspec align="left" colname="col1" colwidth="2*" />

              <colspec align="left" colname="col2" colwidth="2*" />

              <colspec align="left" colname="col3" colwidth="3*" />

              <thead>
                <row>
                  <entry>Operator</entry>

                  <entry>Name</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><replaceable>Exp</replaceable> <literal>.</literal>
                  <replaceable>Name</replaceable></entry>

                  <entry>Field selection</entry>

                  <entry><replaceable>Exp </replaceable>should evaluate to a
                  tuple or datatype with field
                  <replaceable>Name</replaceable>; return the value of that
                  field</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript><literal>
                  [</literal> <replaceable>Name</replaceable>
                  <literal>=</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript>
                  <literal>]</literal></entry>

                  <entry>Field assignment</entry>

                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  should evaluate to a tuple or datatype with a field
                  <replaceable>Name</replaceable>; assign value
                  <replaceable>Exp</replaceable><subscript>2</subscript> to
                  that field</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable>
                  <literal>&lt;</literal> <replaceable>field</replaceable>,
                  ...<literal> &gt;</literal></entry>

                  <entry>Field projection</entry>

                  <entry><replaceable>Exp</replaceable> should evaluate to a
                  tuple or relation, and field should be a field name or an
                  integer constant. A new tuple or relation is returned that
                  only contains the listed fields.</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript><literal>
                  [</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript> ,
                  <literal><replaceable>Exp</replaceable><subscript>3</subscript>,
                  .... ]</literal></entry>

                  <entry>Subscription</entry>

                  <entry>The value of
                  <replaceable>Exp</replaceable><subscript>2</subscript> ,
                  <replaceable>Exp</replaceable><subscript>3</subscript>, ...
                  are used as index in
                  <replaceable>Exp</replaceable><subscript>1</subscript>'s
                  value. On list, tuple return the element with given
                  (single!) index value; for map return the value associated
                  with
                  <replaceable><replaceable>Exp</replaceable><subscript>2</subscript>
                  </replaceable>'s value. On relations more than one index is
                  allowed. All tuples are returned that have the values of
                  <replaceable>Exp</replaceable><subscript>2</subscript>,
                  <replaceable>Exp</replaceable><subscript>3</subscript>, ...
                  as first elements. These values are removed from each
                  tuple.</entry>
                </row>

                <row>
                  <entry><literal>-</literal>
                  <replaceable>Exp</replaceable></entry>

                  <entry>Negation</entry>

                  <entry>Negative of <replaceable>Exp</replaceable>'s integer
                  or real value</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable>
                  <literal>+</literal></entry>

                  <entry>Transitive closure</entry>

                  <entry>Transitive closure on relation</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable>
                  <literal>*</literal></entry>

                  <entry>Reflexive transitive closure</entry>

                  <entry>Reflexive transitive closure on relation</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable> <literal>@</literal>
                  <replaceable>Name</replaceable></entry>

                  <entry>Annotation selection</entry>

                  <entry>Value of annotation <replaceable>Name</replaceable>
                  of <replaceable>Exp</replaceable>'s value</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>[@</literal> <replaceable>Name</replaceable>
                  <literal>=</literal><replaceable>
                  Exp</replaceable><subscript>2</subscript><literal>]</literal></entry>

                  <entry>Annotation replacement</entry>

                  <entry>Assign value of<replaceable>
                  Exp</replaceable><subscript>2</subscript> to annotation
                  <replaceable>Name</replaceable> of
                  <replaceable><replaceable>Exp</replaceable><subscript>1</subscript></replaceable>'s
                  value</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>o</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Composition</entry>

                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  and <replaceable>Exp</replaceable><subscript>2</subscript>
                  should evaluate to a relation; return their
                  composition</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>/</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Division</entry>

                  <entry>Divide two integers and reals</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>%</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Modulo</entry>

                  <entry>Modulo on integer</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>*</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Multiplication / Product</entry>

                  <entry>Multiply integers or real; product of list, set,
                  relation</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>&amp;</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Intersection</entry>

                  <entry>Intersection of list, set, map or relation</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>+</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Addition / concatenation / union</entry>

                  <entry>Add integer and real; concatenate string, list or
                  tuple; union on set, map, or relation</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>-</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Subtraction / difference</entry>

                  <entry>Subtract integer or real; difference of list, set,
                  map, or relation</entry>
                </row>

                <row>
                  <entry><replaceable><replaceable>Exp</replaceable><subscript>1</subscript></replaceable>
                  <literal>join</literal>
                  <replaceable><replaceable>Exp</replaceable><subscript>2</subscript></replaceable></entry>

                  <entry>Join</entry>

                  <entry>Join on relation</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>Most of these operators are described in detail in <xref
        linkend="section.lib" /> for specific types. Here we describe the
        remaining generic operators.</para>

        <formalpara>
          <title>Field Selection and Field Assignment</title>

          <para>Field selection and field assignment apply to all values that
          have named components like tuples and relations with named elements,
          data types, and locations. Field selection returns the value of the
          named component and Field assignment returns a new value in which
          the named component has been replaced by a new value. We illustrate
          this for tuples:<screen><prompt>rascal&gt;</prompt> <userinput>tuple[int key, str val] T = &lt;1, "abc"&gt;;</userinput>
<computeroutput>tuple[int, str] : &lt;1, "abc"&gt;</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>T.val;</userinput>
<computeroutput>str : "abc"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>T[val = "def"];</userinput>
<computeroutput>tuple[int, str] : &lt;1, "def"&gt;</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>T;</userinput>
<computeroutput>tuple[int, str] : &lt;1, "abc"&gt;</computeroutput></screen></para>
        </formalpara>

        <para>Observe that field assignment creates a <emphasis>new</emphasis>
        value with an updated field. The old value remains unchanged as can be
        seen from the unchanged value of <literal>T</literal> in the above
        example. In<xref linkend="section.assignment" /> we explain how to
        change a field of variable value.</para>

        <formalpara>
          <title>Field projection</title>

          <para>Field projection applies to tuples and relations and may
          contain element names or integer constants that refer to elements in
          the order in which they occur in the original value (counting from
          0). A field projection returns a new value that consists of the
          selected elements. Suppose we have a relation with traffic
          information that records the name of the day, the day number, and
          the length of the traffic jams at that day.</para>
        </formalpara>

        <screen><prompt>rascal&gt;</prompt> <userinput>rel[str day, int daynum, int length] Traffic = 
        {&lt;"mon", 1, 100&gt;, &lt;"tue", 2, 150&gt;, &lt;"wed", 3, 125&gt;, 
         &lt;"thur", 4, 110&gt;, &lt;"fri", 5, 90&gt;};</userinput>
<computeroutput>rel[str, int, int]: {&lt;"thur",4,110&gt;,&lt;"tue",2,150&gt;,&lt;"wed",3,125&gt;,
         &lt;"fri",5,90&gt;,&lt;"mon",1,100&gt;}</computeroutput>

<userinput><prompt>rascal&gt;</prompt> </userinput>Traffic&lt;length,daynum&gt;;
<computeroutput>rel[int, int]: {&lt;110,4&gt;,&lt;150,2&gt;,&lt;90,5&gt;,&lt;100,1&gt;,&lt;125,3&gt;}
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>Traffic&lt;2,day&gt;;</userinput>
<computeroutput>rel[int, str]: {&lt;125,"wed"&gt;,&lt;110,"thur"&gt;,&lt;100,"mon"&gt;,&lt;90,"fri"&gt;,
                &lt;150,"tue"&gt;}</computeroutput></screen>

        <para>Field projection thus selects parts from a larger value that has
        a fixed number of parts. The selection is based on position and not on
        value and can be used to completely reorder or remove the parts of a
        larger value.</para>

        <formalpara>
          <title>Subscription</title>

          <para>Subscription selects values with a given computed index from a
          larger value that has a variable number of elements. For lists and
          tuples a single integer expression is allowed as index and the
          returned value is the element with that index (counting from 0). For
          maps, the index type should correspond to the key type of the map
          and the value associated with the index is returned. For relations,
          more than one index expression is allowed and as value a new,
          reduced, relation is returned with all elements that contained the
          index values at the corresponding tuples positions (but these values
          are removed, hence a reduced relation). Some examples illustrate
          this:<screen><prompt>rascal&gt;</prompt> <userinput>L = [10, 20, 30];</userinput>
<computeroutput>list[int] : [10,20,30]
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>L[1];</userinput>
<computeroutput>int : 20</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>T = &lt;"mon", 1&gt;;</userinput>
<computeroutput>tuple[str,int] : &lt;"mon", 1&gt;;</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>T[0];</userinput>
<computeroutput>str : "mon"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>colors = ("hearts":"red", "clover":"black", 
                  "trumps":"black", "clubs":"red");</userinput>
<computeroutput>map[str,str] : ("hearts":"red", "clover":"black", 
                "trumps":"black", "clubs":"red")
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>colors["trumps"];</userinput>
<computeroutput>str: "black"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>colors[0];</userinput>
<computeroutput>Static Error: -:1,0: Expected str, but got int</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>colors["square"];</userinput>
<computeroutput>Uncaught Rascal Exception: -:1,0: NoSuchKey("square")</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[str country, int year, int amount] GDP =
           {&lt;"US", 2008, 14264600&gt;, &lt;"EU", 2008, 18394115&gt;,
            &lt;"Japan", 2008, 4923761&gt;, &lt;"US", 2007, 13811200&gt;, 
            &lt;"EU", 2007, 13811200&gt;, &lt;"Japan", 2007, 4376705&gt;};</userinput>
<computeroutput>rel[str,int,int] : 
           {&lt;"US", 2008, 14264600&gt;, &lt;"EU", 2008, 18394115&gt;, 
            &lt;"Japan", 2008, 4923761&gt;, &lt;"US", 2007, 13811200&gt;, 
            &lt;"EU", 2007, 13811200&gt;, &lt;"Japan", 2007, 4376705&gt;}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>GDP["Japan"];</userinput>
<computeroutput>rel[int,int] : {&lt;2008, 4923761&gt;, &lt;2007, 4376705&gt;}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>GDP["Japan", 2008];</userinput>
<computeroutput>set[int] : {4923761}</computeroutput></screen></para>
        </formalpara>

        <formalpara>
          <title>Other Non-Boolean Operator Expressions</title>

          <para>The other non-Boolean operator expressions are explained in
          more detail for each datatype, see <xref
          linkend="section.lib" />.</para>
        </formalpara>
      </section>

      <section xml:id="section.expressions-boolean">
        <title>Boolean Operator Expressions</title>

        <para>The Boolean operators are summarized in <xref
        linkend="table.boolean-operators" />. All operators are highly
        overloaded and we refer to <xref linkend="section.lib" /> for a
        description of their meaning for each specific type. Most operator are
        self-explanatory except the Match and NoMatch operators that are also
        the main reason to treat Boolean operator expressions separately.
        Although we describe patterns in full detail in <xref
        linkend="section.pattern" />, a preview is useful here. A pattern
        can</para>

        <itemizedlist>
          <listitem>
            <para>match (or not match) any arbitrary value (that we will call
            the <emphasis>subject value</emphasis>);</para>
          </listitem>

          <listitem>
            <para>during the match variables may be bound to subvalues of the
            subject value.</para>
          </listitem>
        </itemizedlist>

        <formalpara>
          <title>Match Operator</title>

          <para>The match operator</para>
        </formalpara>

        <para><programlisting><replaceable>Pat</replaceable> <literal>:=</literal> <replaceable>Exp</replaceable></programlisting></para>

        <para>is evaluated as follows:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Exp</emphasis> is evaluated, the result is a
            subject value;</para>
          </listitem>

          <listitem>
            <para>the subject value is matched against the pattern
            <emphasis>pat</emphasis>;</para>
          </listitem>

          <listitem>
            <para>if the match succeeds, any variables in the pattern are
            bound to subvalues of the subject value and the match expression
            yields <literal>true</literal>;</para>
          </listitem>

          <listitem>
            <para>if the match fails, no variables are bound and the match
            expression yields <literal>false</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>This looks and <emphasis>is</emphasis> nice and dandy, so why
        all this fuss about Boolean operators? The catch is that--as we will
        see in detail in <xref linkend="section.pattern" />--a match need not
        be unique. This means that there may be more than one way of matching
        the subject value resulting in different variable bindings. A quick
        example. Consider the following match of a list<programlisting>[1, list[int] <replaceable>L</replaceable>, 2, list[int] <replaceable>M</replaceable>] := [1,2,3,2,4]</programlisting></para>

        <para>By definition <literal>list[int] L </literal>and
        <literal>list[int] M</literal> match list elements that are part of
        the enclosing list in which they occur. If they should match a nested
        list each should be enclosed in list brackets.</para>

        <para>There are two solutions for the above match:</para>

        <itemizedlist>
          <listitem>
            <para><literal>L = []</literal> and <literal>M = [2, 3, 2,
            4]</literal>; and</para>
          </listitem>

          <listitem>
            <para><literal>L = [2,3]</literal> and <literal>M =
            [4]</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>Depending on the context, only the first solution of a match
        expression is used, respectively all solutions are used. If a match
        expression occurs in a larger Boolean expression, a subsequent
        subexpression may yield false and -- depending on the actual operator
        -- evaluation <emphasis>backtracks</emphasis> to a previously
        evaluated match operator to try a next solution. Let's illustrate this
        by extending the above example:<programlisting>[1, list[int] <replaceable>L</replaceable>, 2, list[int] <replaceable>M</replaceable>] := [1,2,3,2,4] &amp;&amp; size(L) &gt; 0</programlisting>where
        we are looking for a solution in which <literal>L</literal> has a
        non-empty list as value. Evaluation proceeds as follows:</para>

        <itemizedlist>
          <listitem>
            <para>The left argument of the <literal>&amp;&amp;</literal>
            operator is evaluated: the match expression is evaluated resulting
            in the bindings <literal>L = []</literal> and <literal>M = [2, 3,
            2, 4]</literal>;</para>
          </listitem>

          <listitem>
            <para>The right argument of the <literal>&amp;&amp;</literal>
            operator is evaluated: <literal>size(L) &gt; 0</literal> yields
            false;</para>
          </listitem>

          <listitem>
            <para>Backtrack to the left argument of the &amp;&amp; operator to
            check for more solutions: indeed there are more solutions
            resulting in the bindings <literal>L = [2,3]</literal> and
            <literal>M = [4]</literal>;</para>
          </listitem>

          <listitem>
            <para>Proceed to the right operator of
            <literal>&amp;&amp;</literal>: this time <literal>size(L) &gt;
            0</literal> yields <literal>true</literal>;</para>
          </listitem>

          <listitem>
            <para>The result of evaluating the complete expression is
            <literal>true</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>This behaviour is applicable in the context of all Rascal
        constructs where a pattern match determines the flow of control of the
        program, in particular:</para>

        <itemizedlist>
          <listitem>
            <para>Boolean expressions: when a pattern match fails that is part
            of a Boolean expression, further solutions are tried in order to
            try to make the Boolean expression true.</para>
          </listitem>

          <listitem>
            <para>Tests in <keysym>for</keysym>, <keysym>while</keysym>,
            <keysym>do</keysym> statements.</para>
          </listitem>

          <listitem>
            <para>Tests in <keysym>one</keysym> and <keysym>all</keysym>
            expressions.</para>
          </listitem>

          <listitem>
            <para>Tests and enumerators in comprehensions.</para>
          </listitem>

          <listitem>
            <para>Pattern matches in <keysym>visit</keysym> expression and
            <keysym>switch</keysym> statement.</para>
          </listitem>

          <listitem>
            <para>Pattern matches during rewriting.</para>
          </listitem>
        </itemizedlist>

        <para><table xml:id="table.boolean-operators">
            <title>Boolean Operators</title>

            <tgroup cols="3">
              <colspec align="left" colname="col1" colwidth="2*" />

              <colspec align="left" colname="col2" colwidth="2*" />

              <colspec align="left" colname="col3" colwidth="3*" />

              <thead>
                <row>
                  <entry>Operator</entry>

                  <entry>Name</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>!</literal>
                  <replaceable>Exp</replaceable></entry>

                  <entry>Negation</entry>

                  <entry>Negate <replaceable>Exp</replaceable>'s boolean
                  value</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable>
                  <literal>?</literal></entry>

                  <entry>IsDefined</entry>

                  <entry>true if <replaceable>Exp</replaceable> has a
                  well-defined value, i.e., is the result of expression
                  evaluation that ended without raising an exception</entry>
                </row>

                <row>
                  <entry><replaceable><replaceable>Exp</replaceable><subscript>1</subscript></replaceable>
                  <literal>in</literal>
                  <replaceable><replaceable>Exp</replaceable><subscript>2</subscript></replaceable></entry>

                  <entry>ElementOf</entry>

                  <entry>Element of</entry>
                </row>

                <row>
                  <entry><replaceable><replaceable>Exp</replaceable><subscript>1</subscript></replaceable>
                  <literal>notin</literal>
                  <replaceable><replaceable>Exp</replaceable><subscript>2</subscript></replaceable></entry>

                  <entry>NotElementOf</entry>

                  <entry>Not element of</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>&lt;=</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>LessThanOrEqual</entry>

                  <entry>Less than or equal on bool, int, real or string;
                  sublist on list; subset on set, map or relation</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>&lt;</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>LessThan</entry>

                  <entry>Less than on bool, int, real or string; strict
                  sublist on list; strict subset on set, map or
                  relation</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>&gt;=</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>GreaterThanOrEqual</entry>

                  <entry>Greater than or equal on bool, int, real or string;
                  superlist on list; superset on set, map or relation</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>&gt;</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>GreaterThan</entry>

                  <entry>Greater than on bool, int, real or string; strict
                  superlist on list; strict superset on set, map or
                  relation</entry>
                </row>

                <row>
                  <entry><replaceable>Pat</replaceable> <literal>:=</literal>
                  <replaceable>Exp</replaceable></entry>

                  <entry>Match</entry>

                  <entry>Value of <replaceable>Exp</replaceable> matches with
                  pattern <replaceable>Pat</replaceable></entry>
                </row>

                <row>
                  <entry><replaceable>Pat</replaceable> <literal>!:=</literal>
                  <replaceable>Exp</replaceable></entry>

                  <entry>NoMatch</entry>

                  <entry>Value of <replaceable>Exp</replaceable> does not
                  match with pattern <replaceable>Pat</replaceable></entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>==</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Equal</entry>

                  <entry>Equality</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>!=</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>NotEqual</entry>

                  <entry>Inequality</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>?</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>IfDefinedElse</entry>

                  <entry>The value of
                  <replaceable>Exp</replaceable><subscript>1</subscript> if
                  that is defined (i.e., is the result of expression
                  evaluation that ended without raising an exception thus
                  excluding, for instance, uninitialized variables and
                  undefined map elements) otherwise the value of
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>?</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript>
                  <literal>:</literal>
                  <replaceable>Exp</replaceable><subscript>3</subscript></entry>

                  <entry>IfThenElse</entry>

                  <entry>Conditional expression</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>==&gt;</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Implication</entry>

                  <entry><literal>true</literal>, unless the value of
                  <replaceable>Exp</replaceable><subscript>1</subscript> is
                  <literal>true</literal> and that of
                  <replaceable>Exp</replaceable><subscript>2</subscript> is
                  <literal>false</literal></entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>&lt;==&gt;</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Equivalence</entry>

                  <entry>true if
                  <replaceable>Exp</replaceable><subscript>1</subscript> and
                  <replaceable>Exp</replaceable><subscript>2</subscript> have
                  the same value</entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>&amp;&amp;</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>And</entry>

                  <entry><literal>true</literal> if the value of both
                  <replaceable>Exp</replaceable><subscript>1</subscript> and
                  <replaceable>Exp</replaceable><subscript>2</subscript> is
                  <literal>true</literal></entry>
                </row>

                <row>
                  <entry><literal><replaceable>Exp</replaceable><subscript>1</subscript>,
                  <replaceable>Exp</replaceable><subscript>2</subscript>,</literal>
                  ...<literal>,
                  <replaceable>Exp</replaceable><subscript>n</subscript></literal></entry>

                  <entry>MultiCondition</entry>

                  <entry><literal>Equivalent to:
                  <replaceable>Exp</replaceable><subscript>1</subscript>
                  &amp;&amp;
                  <replaceable>Exp</replaceable><subscript>2</subscript>
                  &amp;&amp;</literal> ... <literal>&amp;&amp;
                  <replaceable>Exp</replaceable><subscript>n</subscript></literal></entry>
                </row>

                <row>
                  <entry><replaceable>Exp</replaceable><subscript>1</subscript>
                  <literal>||</literal>
                  <replaceable>Exp</replaceable><subscript>2</subscript></entry>

                  <entry>Or</entry>

                  <entry><literal>true</literal> if the value of either
                  <replaceable>Exp</replaceable><subscript>1</subscript> or
                  <replaceable>Exp</replaceable><subscript>2</subscript> is
                  <literal>true</literal></entry>
                </row>

                <row>
                  <entry><literal><replaceable>Pat</replaceable> &lt;-
                  <replaceable>Exp</replaceable></literal></entry>

                  <entry>Enumerator</entry>

                  <entry><literal>true</literal> for every element in
                  <replaceable>Exp</replaceable>'s value (set/list element,
                  direct subtree) that matches
                  <replaceable>Pat</replaceable></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.pattern">
        <title>Patterns</title>

        <para>Patterns come in three flavours:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Regular expression patterns</emphasis> to do
            string matching with regular expressions, see <xref
            linkend="section.regular-patterns" />.</para>
          </listitem>

          <listitem>
            <para><emphasis>Abstract patterns</emphasis> to do matching on
            arbitrary values, see <xref
            linkend="section.abstract-patterns" />.</para>
          </listitem>

          <listitem>
            <para><emphasis>Concrete syntax patterns</emphasis> to match
            syntax trees that are the result of parsing, see <xref
            linkend="section.concrete-patterns" />.</para>
          </listitem>
        </itemizedlist>

        <section xml:id="section.regular-patterns">
          <title>Regular Expression Patterns</title>

          <para>Regular expression patterns are ordinary regular expressions
          that are used to match a string value and to decompose it in parts
          and also to compose new strings. Regular expression patterns bind
          variables of type <literal>str</literal> when the match succeeds,
          otherwise they do not bind anything. Their syntax and semantics
          parallels abstract and concrete syntax patterns as much as possible.
          This means that they can occur in cases of <literal>visit</literal>
          and <literal>switch</literal> statements, on the left-hand side of
          the match operator (<literal>:= or !:=</literal>) and as declarator
          in enumerators.</para>

          <para>Here are some examples of regular expression
          patterns.<programlisting>/\brascal\b/i</programlisting>does a
          case-insensitive match (<literal>i</literal>) of the word rascal
          between word boundaries (<literal>\b</literal>). And<programlisting>/^.*?&lt;word:\w+&gt;&lt;rest:.*$&gt;/m</programlisting>does
          a multi-line match (<literal>m</literal>), matches the first
          consecutive word characters (<literal>\w</literal>) and assigns them
          to the variable <literal>word</literal>. The remainder of the string
          is assigned to the variable <literal>rest</literal>. Constructs of
          the form
          <literal>&lt;<replaceable>Name</replaceable>:<replaceable>Regex</replaceable>&gt;</literal>
          are called variable <emphasis role="bold">introductions</emphasis>.
          They introduce a new variable for the duration of the regular
          expression match.</para>

          <para>Regular expressions may also contain <emphasis
          role="bold">references</emphasis> to variables: their string value
          is used at the position of the variable reference. This can be used
          to define so-called <emphasis role="bold">non-linear</emphasis>
          patterns. This example</para>

          <para><programlisting>/&lt;x:[a-z]+&gt;---&lt;x&gt;/</programlisting>matches
          strings like <literal>abc---abc</literal> that consist of two
          identical sequences of letters separated by three dashes. Variables
          that are referenced in a regular expression may also come from the
          context in which the regular expression occurs. For instance,</para>

          <para><programlisting>/&lt;x&gt;&lt;n&gt;/</programlisting>will use
          the current values of <literal>x</literal> and <literal>n</literal>
          as regular expression. For values <literal>"abc"</literal>,
          respectively, <literal>3</literal> this would be equivalent to the
          regular expression:</para>

          <para><programlisting>/abc3/</programlisting>Observe that context
          variables may be of arbitrary type and that their value is first
          converted to a string before it is inserted in the regular
          expression. This can be used in many ways. For instance, regular
          expressions may contain restrictions on the number of repetitions of
          an element: <literal>/a{3}/</literal> will match exactly three
          letters <literal>a</literal>. Also minimum and maximum number of
          occurrences can be defined. Here is how the repetition count can be
          inserted by a variable reference (where n is assumed to have an
          integer value):</para>

          <para><programlisting>/a{&lt;n&gt;}/</programlisting>Taking this
          example one step further, we can even write</para>

          <para><programlisting>/&lt;x:a{&lt;n&gt;}&gt;/</programlisting>in
          other words, we introduce variable <literal>x</literal> and its
          defining regular expression contains a reference to a context
          variable.</para>

          <para>We use a regular expression language that slightly
          extends/modifies the Java Regex language:</para>

          <itemizedlist>
            <listitem>
              <para>Regular expression are delimited by <literal>/</literal>
              and <literal>/</literal> optionally followed by modifiers (see
              below).</para>
            </listitem>

            <listitem>
              <para>We allow variable introductions, syntax
              <literal>&lt;<replaceable>Name</replaceable>:<replaceable>Regex</replaceable>&gt;</literal>,
              which introduce a variable of type <literal>str</literal> named
              <replaceable>Name</replaceable>. A variable introduction
              corresponds to a group in a Java regexp. Each variable that is
              introduced should be unique, but may be referenced more than
              once later in the regular expression.</para>
            </listitem>

            <listitem>
              <para>Java regular expressions allow optional groups, which may
              introduce null bindings. Since uninitialized variables are not
              allowed in Rascal, we limit the kinds of expressions one can
              write here by not allowing nesting of variable
              introductions.</para>
            </listitem>

            <listitem>
              <para>We allow variable references in a regular expression of
              the form:
              <literal>&lt;<replaceable>Name</replaceable>&gt;</literal> which
              inserts the string value of <replaceable>Name</replaceable> in
              the pattern. Name should have been introduced in the regular
              experession itself or in the context in which the regular
              expression occurs.</para>
            </listitem>

            <listitem>
              <para>Unlike Perl, Java uses the notation
              <literal>(?<replaceable>Option</replaceable>)</literal> inside
              the regular expression to set matching options. We let these
              options follow the regular expression as a modifiers. The
              following modifiers are supported:</para>

              <itemizedlist>
                <listitem>
                  <para>multi-line matching (<literal>?m</literal>): the
                  anchors <literal>^</literal> and <literal>$</literal>
                  usually only match at the beginning and end of the subject
                  string. When this option is set they also match any begin or
                  end of line that is embedded in the subject string.</para>
                </listitem>

                <listitem>
                  <para>case-insensitive matching (<literal>?i</literal>):
                  match characters irrespective of their case.</para>
                </listitem>

                <listitem>
                  <para>single-line mode (<literal>?s</literal>): the .
                  expression does usually not match line terminators. When
                  single-line mode is set, it will match any character
                  including line terminators.</para>
                </listitem>

                <listitem>
                  <para>unix lines (<literal>?d</literal>): usually newlines
                  (<literal>\n</literal>), carriage return
                  (<literal>\r</literal>) and new line carriage return
                  (<literal>\n\r</literal>) sequences are all considered line
                  terminators. When this option is set, only newline is
                  considered to be a line terminator.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>

          <para><warning>
              <para>Further discuss here:</para>

              <itemizedlist>
                <listitem>
                  <para>grouping versus variable introduction.</para>
                </listitem>

                <listitem>
                  <para>Quoting issues.</para>
                </listitem>

                <listitem>
                  <para>Multiple matches.</para>
                </listitem>
              </itemizedlist>
            </warning>For convenience, we summarize the most frequently used
          constructs in regular expressions in <xref
          linkend="table.regexp-syntax" />.</para>

          <para><table xml:id="table.regexp-syntax">
              <title>Frequently used elements of Regular Expression
              Syntax</title>

              <tgroup cols="2">
                <colspec align="left" colname="col1" colwidth="1*" />

                <colspec align="left" colname="col2" colwidth="5*" />

                <thead>
                  <row>
                    <entry>Operator</entry>

                    <entry>Description</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><replaceable>x</replaceable></entry>

                    <entry>The single character <replaceable>x</replaceable>
                    as long as it is not a punctuation character with a
                    special meaning in the regular expression syntax</entry>
                  </row>

                  <row>
                    <entry><literal>\<replaceable>p</replaceable></literal></entry>

                    <entry>The punctuation character
                    <replaceable>p</replaceable></entry>
                  </row>

                  <row>
                    <entry><literal>\\</literal></entry>

                    <entry>The backslah character</entry>
                  </row>

                  <row>
                    <entry><literal>\n</literal></entry>

                    <entry>Newline character</entry>
                  </row>

                  <row>
                    <entry><literal>\t</literal></entry>

                    <entry>Tab character</entry>
                  </row>

                  <row>
                    <entry><literal>[...]</literal></entry>

                    <entry>One of the characters between the brackets (also
                    known as <emphasis role="bold">character
                    class</emphasis>). Character ranges and set operations on
                    character classes may be used.</entry>
                  </row>

                  <row>
                    <entry><literal>[^...]</literal></entry>

                    <entry>Any one character not between the brackets.</entry>
                  </row>

                  <row>
                    <entry><literal>[a-z0-9]</literal></entry>

                    <entry>Character range: character between a and z or 0 and
                    9.</entry>
                  </row>

                  <row>
                    <entry><literal>\d</literal></entry>

                    <entry>Digit: <literal>[0-9]</literal></entry>
                  </row>

                  <row>
                    <entry><literal>\D</literal></entry>

                    <entry>Non-digit: <literal>[^0-9]</literal></entry>
                  </row>

                  <row>
                    <entry><literal>\s</literal></entry>

                    <entry>Whitespace</entry>
                  </row>

                  <row>
                    <entry><literal>\S</literal></entry>

                    <entry>Anything but whitespace.</entry>
                  </row>

                  <row>
                    <entry><literal>\w</literal></entry>

                    <entry>A word: <literal>[a-zA-Z0-9_]</literal></entry>
                  </row>

                  <row>
                    <entry><literal>\W</literal></entry>

                    <entry>A non-word: <literal>[^\w]</literal></entry>
                  </row>

                  <row>
                    <entry><replaceable>xy</replaceable></entry>

                    <entry>Match <replaceable>x</replaceable> followed by
                    <replaceable>y</replaceable></entry>
                  </row>

                  <row>
                    <entry><literal><replaceable>x</replaceable>|<replaceable>y</replaceable></literal></entry>

                    <entry>Match <replaceable>x</replaceable> or
                    <replaceable>y</replaceable></entry>
                  </row>

                  <row>
                    <entry><literal><replaceable>x</replaceable>?</literal></entry>

                    <entry>Optional occurrence of
                    <replaceable>x</replaceable></entry>
                  </row>

                  <row>
                    <entry><literal><replaceable>x</replaceable>*</literal></entry>

                    <entry>Zero or more occurrences of<replaceable>
                    x</replaceable></entry>
                  </row>

                  <row>
                    <entry><literal><replaceable>x</replaceable>+</literal></entry>

                    <entry>One or more occurrences of
                    <replaceable>x</replaceable></entry>
                  </row>

                  <row>
                    <entry><literal><replaceable>x</replaceable>{<replaceable>n</replaceable>}</literal></entry>

                    <entry>Exactly <replaceable>n</replaceable> occurrences of
                    <replaceable>x</replaceable></entry>
                  </row>

                  <row>
                    <entry><literal><replaceable>x</replaceable>{<replaceable>n</replaceable>,}</literal></entry>

                    <entry><replaceable>n</replaceable> or more occurrences of
                    <replaceable>x</replaceable></entry>
                  </row>

                  <row>
                    <entry><literal><replaceable>x</replaceable>{<replaceable>n</replaceable>,<replaceable>m</replaceable>}</literal></entry>

                    <entry>At least <replaceable>n</replaceable>, at most
                    <replaceable>m</replaceable> occurrences of
                    <replaceable>x</replaceable></entry>
                  </row>

                  <row>
                    <entry><literal>^</literal></entry>

                    <entry>The beginning of the subject string</entry>
                  </row>

                  <row>
                    <entry><literal>$</literal></entry>

                    <entry>The end of the input string</entry>
                  </row>

                  <row>
                    <entry><literal>\b</literal></entry>

                    <entry>Word boundary: position between a word and a
                    non-word character</entry>
                  </row>

                  <row>
                    <entry><literal>\B</literal></entry>

                    <entry>Non-word boundary: position that is a not a word
                    boundary</entry>
                  </row>
                </tbody>
              </tgroup>
            </table></para>
        </section>

        <section xml:id="section.abstract-patterns">
          <title>Abstract Patterns</title>

          <para>An abstract pattern is recursively defined and may contain the
          following elements:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis>Literal</emphasis> of one of the basic types
              <literal>bool</literal>, <literal>int</literal>,
              <literal>real</literal>, <literal>str</literal>, or
              <literal>loc</literal>. A literal pattern matches with a value
              that is identical to the literal.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>variable declaration
              pattern</emphasis><programlisting><replaceable>Type</replaceable> <replaceable>Var</replaceable></programlisting></para>

              <para>A variable declaration introduces a new variable that
              matches any value of the given type. That value is assigned to
              <replaceable>Var</replaceable> when the whole match
              succeeds.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>multi-variable
              pattern</emphasis><programlisting><replaceable>Var*</replaceable></programlisting>A
              multi-variable is an abbreviation for a variable declaration
              pattern. It can occur in a list pattern or set pattern and can
              match zero or more list or set elements.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>variable pattern</emphasis><programlisting><replaceable>Var</replaceable></programlisting></para>

              <para>A variable pattern can act in two roles:</para>

              <itemizedlist>
                <listitem>
                  <para>If <replaceable>Var</replaceable> has already a
                  defined value then it matches with that value.</para>
                </listitem>

                <listitem>
                  <para>If Var has not been defined before (or it has been
                  declared but not initialized) then it matches any value.
                  That value is assigned to <replaceable>Var</replaceable>.
                  <remark>Explain scope.</remark></para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>A <emphasis>list pattern</emphasis><programlisting>[ <replaceable>Pat</replaceable><subscript>1</subscript>, <replaceable>Pat</replaceable><subscript>2</subscript>, ..., <replaceable>Pat</replaceable><subscript>n</subscript> ]</programlisting></para>

              <para>A list pattern matches a list value, provided that
              <replaceable>Pat</replaceable><subscript>1</subscript>,
              <replaceable>Pat</replaceable><subscript>2</subscript>, ...,
              <replaceable>Pat</replaceable><subscript>n</subscript> match the
              elements of that list in order. Two special cases exist when one
              of the patterns
              <replaceable>Pat</replaceable><subscript>i</subscript> is</para>

              <itemizedlist>
                <listitem>
                  <para>a variable declaration pattern with a list type that
                  is identical to the type of the list that is being
                  matched.</para>
                </listitem>

                <listitem>
                  <para>a variable pattern, where the variable has been
                  declared, but not initialized, outside the pattern with a
                  list type that is identical to the type of the list that is
                  being matched.</para>
                </listitem>
              </itemizedlist>

              <para>In both cases list matching is applied and the variable
              can match an arbitrary number of elements of the subject
              list.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>set pattern</emphasis><programlisting>{ <replaceable>Pat</replaceable><subscript>1</subscript>, <replaceable>Pat</replaceable><subscript>2</subscript>, ..., <replaceable>Pat</replaceable><subscript>n</subscript> }</programlisting></para>

              <para>A set pattern matches a set value, provided that
              <replaceable>Pat</replaceable><subscript>1</subscript>,
              <replaceable>Pat</replaceable><subscript>2</subscript>, ...,
              <replaceable>Pat</replaceable><subscript>n</subscript> match the
              elements of that set in any order. Completely analogous to list
              patterns, there are two special cases when one of the patterns
              <replaceable>Pat</replaceable><subscript>i</subscript> is</para>

              <itemizedlist>
                <listitem>
                  <para>a variable declaration pattern with a set type that is
                  identical to the type of the set that is being
                  matched.</para>
                </listitem>

                <listitem>
                  <para>a variable pattern, where the variable has been
                  declared, but not initialized, outside the pattern with a
                  set type that is identical to the type of the set that is
                  being matched.</para>
                </listitem>
              </itemizedlist>

              <para>In both cases set matching is applied and the variable can
              match an arbitrary number (in arbitrary order!) of elements of
              the subject set.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>tuple pattern</emphasis><programlisting>&lt; <replaceable>Pat</replaceable><subscript>1</subscript>, <replaceable>Pat</replaceable><subscript>2</subscript>, ..., <replaceable>Pat</replaceable><subscript>n</subscript> &gt;</programlisting></para>

              <para>A tuple pattern matches a tuple value, provided that
              <replaceable>Pat</replaceable><subscript>1</subscript>,
              <replaceable>Pat</replaceable><subscript>2</subscript>, ...,
              <replaceable>Pat</replaceable><subscript>n</subscript> match the
              elements of that tuple in order.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>node pattern</emphasis><programlisting><replaceable>Name</replaceable> ( <replaceable>Pat</replaceable><subscript>1</subscript>, <replaceable>Pat</replaceable><subscript>2</subscript>, ..., <replaceable>Pat</replaceable><subscript>n</subscript> )</programlisting></para>

              <para>A node pattern matches a node value or a datatype value,
              provided that <replaceable>Name</replaceable> matches with the
              constructor symbol of that value and
              <replaceable>Pat</replaceable><subscript>1</subscript>,
              <replaceable>Pat</replaceable><subscript>2</subscript>, ...,
              <replaceable>Pat</replaceable><subscript>n</subscript> match the
              children of that value in order.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>descendant pattern</emphasis><programlisting><replaceable>/ Pat</replaceable></programlisting>performs
              a deep match of the pattern <replaceable>Pat</replaceable>. In
              other words, it matches when any element of the subject at any
              depth matches <replaceable>Pat</replaceable> and is used to
              match, for instance, tree nodes at an arbitrary distance from
              the root.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>labelled pattern</emphasis><programlisting><replaceable>Var</replaceable> <literal>:</literal> <replaceable>Pat</replaceable></programlisting></para>

              <para>A labelled pattern matches the same values as
              <replaceable>Pat</replaceable>, but has as side-effect that the
              matched value is assigned to
              <replaceable>Var</replaceable>.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>typed, labelled,
              pattern</emphasis><programlisting><replaceable>Type Var</replaceable> <literal>:</literal> <replaceable>Pat</replaceable></programlisting></para>

              <para>A typed, labelled, pattern matches when the subject value
              has type <replaceable>Type</replaceable> and
              <replaceable>Pat</replaceable> matches. The matched value is
              assigned to <replaceable>Var</replaceable>.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>type constrained
              pattern</emphasis><programlisting><literal>[</literal><replaceable>Type</replaceable><literal>]</literal> <replaceable>Pat</replaceable></programlisting></para>

              <para>matches provided that the subject has type
              <replaceable>Type</replaceable> and
              <replaceable>Pat</replaceable> matches.</para>
            </listitem>
          </itemizedlist>

          <note>
            <para>Map patterns are currently not supported.</para>
          </note>
        </section>

        <section xml:id="section.concrete-patterns">
          <title>Concrete Syntax Patterns</title>

          <para>A <emphasis>concrete pattern</emphasis> is a (possibly quoted)
          concrete syntax fragment that may contain variables. The syntax that
          is used to parse the concrete pattern may come from any SDF module
          that has been imported in the module in which the concrete pattern
          occurs.</para>

          <para>We want to cover the whole spectrum from maximally quoted
          patterns that can unambiguously describe <emphasis
          role="bold">any</emphasis> syntax fragment to minimally quoted
          patterns as we are used to in ASF+SDF. A concrete pattern may have
          the following forms:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis>Quoted pattern</emphasis><programlisting>[| <replaceable>Token</replaceable><subscript>1</subscript><replaceable> Token</replaceable><subscript>2</subscript> ... <replaceable>Token</replaceable><subscript>n</subscript> |]</programlisting></para>

              <para>Inside a quoted pattern arbitrary lexical tokens may
              occur, but the characters <literal>&lt;</literal>,
              <literal>&gt;</literal> and <literal>|</literal> have to be
              escaped as <literal>\&lt;</literal>, <literal>\&gt;</literal>,
              <literal>\|</literal>. Quoted patterns may contain variable
              declaration patterns and variable patterns (see below).</para>
            </listitem>

            <listitem>
              <para>A <emphasis>typed quoted pattern</emphasis>
              <programlisting><replaceable>Symbol</replaceable> [| <replaceable>Token</replaceable><subscript>1</subscript><replaceable> Token</replaceable><subscript>2</subscript> ... <replaceable>Token</replaceable><subscript>n</subscript> |]</programlisting>is
              a quoted pattern that is preceded by an SDF symbol to define its
              desired syntactic type.</para>
            </listitem>

            <listitem>
              <para>An <emphasis>unquoted pattern</emphasis><programlisting><replaceable>Token</replaceable><subscript>1</subscript><replaceable> Token</replaceable><subscript>2</subscript> ... <replaceable>Token</replaceable><subscript>n</subscript></programlisting></para>

              <para>is a quoted pattern without the surrounding quotes.</para>
            </listitem>

            <listitem>
              <para>A <emphasis>typed variable</emphasis>
              <emphasis>pattern</emphasis><programlisting><replaceable>&lt;Type</replaceable> <replaceable>Var&gt;</replaceable></programlisting></para>
            </listitem>

            <listitem>
              <para>A <emphasis>variable pattern</emphasis><programlisting><replaceable>&lt;Var&gt;</replaceable></programlisting></para>
            </listitem>

            <listitem>
              <para>Inside syntax patterns, layout is ignored.</para>
            </listitem>
          </itemizedlist>

          <para>Examples (in a context where an SDF module has been imported
          that defines the appropriate syntax):</para>

          <itemizedlist>
            <listitem>
              <para>Quoted syntax pattern with two pattern variable
              declarations:<programlisting>[| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od |]</programlisting>Two
              observations can be made about this example:</para>

              <itemizedlist>
                <listitem>
                  <para>The non-terminals (sorts in SDF parlance)
                  <literal>EXP</literal> and <literal>{STATEMENT
                  ";"}*</literal> are declared in the imported SDF module and
                  can be used as types in the Rascal program.</para>
                </listitem>

                <listitem>
                  <para>When this pattern is matched successfully against a
                  subject, the variables <literal>Exp</literal> and
                  <literal>Stats</literal> will be bound.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Quoted syntax pattern with two pattern variable
              uses:<programlisting>[| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
            </listitem>

            <listitem>
              <para>Identical to the previous example, but with a declaration
              of the desired syntactic type:<programlisting>STATEMENT [| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
            </listitem>

            <listitem>
              <para>Unquoted syntax pattern with two pattern variable
              declarations:<programlisting>while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od</programlisting></para>
            </listitem>

            <listitem>
              <para>Unquoted syntax pattern with two pattern variable
              uses:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>
            </listitem>
          </itemizedlist>

          <para>Obviously, with less quoting and type information, the
          probability of ambiguities increases. These ambiguities may have the
          following sources:</para>

          <itemizedlist>
            <listitem>
              <para>The most common situation is that the concrete pattern
              interferes with other imported SDF modules or with the syntax of
              Rascal itself. In this case, adding more quotes and declaring
              the type of pattern variables and patterns will utlimately
              resolve the ambiguity. Our assumption is that better type
              checkers for Rascal can resolve many of them.</para>
            </listitem>

            <listitem>
              <para>The imported SDF module defines an ambiguous language. In
              this case the only possible approach is to remove the
              ambiguities from that SDF definition. This is an art form and
              may require advanced skills in grammar engineering.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section xml:id="section.pattern-with-action">
        <title>PatternWithAction</title>

        <para>Patterns can be used in various contexts, but a common context
        is a <replaceable>PatternWithAction</replaceable>, which in its turn,
        may be used in a <keysym>visit</keysym> expression a
        <keysym>switch</keysym> statement or a rewrite
        <keysym>rule</keysym>.</para>

        <para>A <replaceable>PatternWithAction </replaceable>can have one of
        the following two forms:</para>

        <itemizedlist>
          <listitem>
            <para><programlisting><literal><replaceable>Pat</replaceable> =&gt; <replaceable>Exp</replaceable></literal></programlisting>When
            the subject matches <replaceable>Pat</replaceable>, the expression
            <replaceable>Exp</replaceable> is evaluated. The use of the
            resulting value depends on the context and is described in <xref
            linkend="section.visit" />, <xref
            linkend="section.rewrite-rule" />. This forms is not usable in
            switch statements.</para>
          </listitem>

          <listitem>
            <para><programlisting><replaceable>Pat</replaceable> : <replaceable>Statement</replaceable></programlisting></para>

            <para>This is the most general case and can be used in
            <keysym>visit</keysym>, <keysym>switch</keysym> and
            <keysym>rule</keysym>. When the subject matches
            <replaceable>Pat</replaceable>, the
            <replaceable>Statement</replaceable> is executed. The execution of
            <replaceable>Statement</replaceable> should, depending on the
            context, lead to one of the following:</para>

            <itemizedlist>
              <listitem>
                <para>Execution of a <literal>return</literal> statement that
                returns a value from the enclosing function.</para>
              </listitem>

              <listitem>
                <para>Execution of a <keysym>fail</keysym> statement: all side
                effects of <replaceable>Statement</replaceable> are undone and
                further alternatives of <replaceable>Pat</replaceable> are
                tried. If no alternatives remain,
                <replaceable>PatternWithAction</replaceable> as a whole
                fails.</para>
              </listitem>

              <listitem>
                <para>Execution of an <keysym>insert</keysym> statement (only
                <keysym>visit</keysym> expressions).</para>
              </listitem>

              <listitem>
                <para>None of the above: execution continues dependeing on the
                context in which the PatternWithAction occurs: the enclosing
                construct ends successfully (<keysym>switch</keysym>,
                <keysym>rule</keysym>) or the traversal continues
                (<keysym>visit</keysym>).</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.comprehension">
        <title>Comprehension Expression</title>

        <para>Comprehensions provide a concise notation to conditionally
        generate new values. We will use the familiar notation for
        <emphasis>list comprehension</emphasis><programlisting>[<replaceable>Exp</replaceable><subscript>1</subscript>, ..., <replaceable>Exp</replaceable><subscript><replaceable>n</replaceable></subscript> | <replaceable>Gen</replaceable><subscript>1</subscript>, ..., <replaceable>Gen</replaceable><subscript><replaceable>m</replaceable></subscript>]</programlisting></para>

        <para>to denote the construction of a list consisting of the
        successive values of the <emphasis>contributing expressions</emphasis>
        <replaceable><replaceable>Exp</replaceable><subscript>1</subscript>,
        ...,
        <replaceable>Exp</replaceable><subscript><replaceable>n</replaceable></subscript></replaceable>.
        The value of the resulting list is determined by
        <replaceable><replaceable>Exp</replaceable><subscript>1</subscript>,
        ...,
        <replaceable>Exp</replaceable><subscript><replaceable>n</replaceable></subscript></replaceable>
        and the <emphasis>generators</emphasis>
        <replaceable>Gen</replaceable><subscript>1</subscript> ,...,
        <replaceable>Gen</replaceable><subscript><replaceable>m</replaceable></subscript>.
        <replaceable>Exp</replaceable><subscript>1</subscript>, ...,
        <replaceable>Exp</replaceable><subscript><replaceable>n</replaceable></subscript>
        are computed for all possible combinations of values produced by the
        generators. Each generator may introduce new variables that can be
        used in subsequent generators as well as in the expressions. A
        generator can use the variables introduced by preceding generators.
        Generators may enumerate all the values in a subject value.</para>

        <para>Generators may also perform an arbitrary test. When the test
        fails, execution continues with the preceding generator (if
        any).</para>

        <para>In addition to list comprehensions, Rascal also supports
        <emphasis>set comprehension</emphasis><programlisting>{<replaceable><replaceable>Exp</replaceable><subscript>1</subscript>, ..., <replaceable>Exp</replaceable><subscript><replaceable>n</replaceable></subscript></replaceable> | <replaceable>Gen</replaceable><subscript>1</subscript>, ..., <replaceable>Gen</replaceable><subscript><replaceable>m</replaceable></subscript>}</programlisting></para>

        <para>that also serve as relation comprehension in the case that
        <replaceable>Exp</replaceable> is of a tuple type.</para>

        <para>Finally, <replaceable>map comprehension</replaceable>s are
        written as:</para>

        <programlisting>(<replaceable>Exp</replaceable><subscript>1</subscript> : <replaceable>Exp</replaceable><subscript>2</subscript> | <replaceable>Gen</replaceable><subscript>1</subscript>, ..., <replaceable>Gen</replaceable><subscript><replaceable>m</replaceable></subscript>)</programlisting>

        <para>Since the entries in a map require both a key and a value for
        each entry, always two expressions are needed in this case.</para>

        <section>
          <title>Enumerator</title>

          <para>The first of the two possible forms of a generator is an
          <emphasis>enumerator</emphasis> that generates all the values in a
          given subject value. For elementary types (bool, int, real, loc,
          str) this is just a singleton. For compositie types (list, set, map,
          tuple, rel, node) the values of their elements, respectively, their
          direct children are enumerated. An enumerator has the following
          form:<programlisting><replaceable>Pat</replaceable> &lt;- <replaceable>Exp</replaceable></programlisting></para>

          <para>where <replaceable>Pat</replaceable> is a pattern and
          <replaceable>Exp</replaceable> is an expression. An enumerator is
          evaluated as follows:</para>

          <itemizedlist>
            <listitem>
              <para>Expression <replaceable>Exp</replaceable> is evaluated and
              may have an arbitrary value <replaceable>V</replaceable>.</para>
            </listitem>

            <listitem>
              <para>The elements of <replaceable>V</replaceable> are
              enumerated one by one.</para>
            </listitem>

            <listitem>
              <para>Each element value is matched against the pattern
              <replaceable>Pat</replaceable>. There are two cases:</para>

              <itemizedlist>
                <listitem>
                  <para>The match succeeds, any variables in
                  <replaceable>Pat</replaceable> are bound, and the next
                  generator in the comprehension is evaluated. The variables
                  that are introduced by an enumerator are only available to
                  generators that appear later (i.e., to the right) in the
                  comprehension. When this enumerator is the last generator in
                  the comprehension, the contributing expressions of the
                  comprehension are evaluated.</para>
                </listitem>

                <listitem>
                  <para>The match fails, no variables are bound. If V has more
                  elements, a next element is tried. Otherwise, a previous
                  generator (i.e., to the left) is tried. If this enumerator
                  is the first generator in the comprehension, the evaluation
                  of the comprehension is complete.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>

          <para>This are examples of enumerators:</para>

          <itemizedlist>
            <listitem>
              <para><literal>int N &lt;- {1, 2, 3, 4, 5}</literal>,</para>
            </listitem>

            <listitem>
              <para><literal>str K &lt;- KEYWORDS</literal>, where
              <literal>KEYWORDS</literal> should evaluate to a value of
              <literal>set[str]</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>&lt;str K, int N&gt; &lt;- {&lt;"a",10&gt;,
              &lt;"b",20&gt;, &lt;"c",30&gt;}</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>&lt;str K, int N&gt; &lt;- FREQUENCIES</literal>,
              where <literal>FREQUENCIES</literal> should evaluate to a value
              of type <literal>rel[str,int]</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>&lt;str K, 10&gt; &lt;- FREQUENCIES</literal>,
              will only generate pairs with <literal>10</literal> as second
              element.</para>
            </listitem>

            <listitem>
              <para><literal>int N &lt;- 17</literal>, will only generate the
              value 17.</para>
            </listitem>
          </itemizedlist>

          <para><note>
              <para>Type information is used to check the plausibility of an
              enumerator and guard you against mistakes. An impossible
              enumerator like <literal>int N &lt;- {"apples",
              "oranges"}</literal> will be flagged as an error since the
              pattern can never match.</para>
            </note></para>
        </section>

        <section>
          <title>Test</title>

          <para>The first of the two possible forms of a generator is a
          <emphasis>test, </emphasis>a boolean-valued expression. If the
          evaluation of the test gives <literal>true</literal> this indicates
          that the current combination of generated values up to this test is
          still as desired and execution continues with subsequent generators.
          If the evaluation gives <literal>false</literal> this indicates that
          the current combination of values is undesired, and that another
          combination should be tried by going back to the previous
          generator.</para>

          <para>Examples:</para>

          <itemizedlist>
            <listitem>
              <para><literal>N &gt;= 3</literal> tests whether
              <literal>N</literal> has a value greater than or equal
              <literal>3</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>S == "coffee"</literal> tests whether
              <literal>S</literal> is equal to the string
              <literal>"coffee"</literal>.</para>
            </listitem>
          </itemizedlist>

          <para>In both examples, the variable (<literal>N</literal>,
          respectively, <literal>S</literal>) should have been introduced by a
          generator that occurs earlier in the comprehension.</para>
        </section>

        <section>
          <title>Examples of Comprehensions</title>

          <para>Here are some examples of comprehensions:</para>

          <screen><literal>rascal&gt; </literal><userinput><literal>{X | int X &lt;- {1, 2, 3, 4, 5}, X &gt;= 3}</literal>;</userinput>
<computeroutput>set[int] : <literal>{3,4,5}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{&lt;X, Y&gt; | int X &lt;- {1, 2, 3}, int Y : {2, 3, 4}, X &gt;= Y};</userinput>
<computeroutput><literal>rel[int,int] : {&lt;2, 2&gt;, &lt;3, 2&gt;, &lt;3, 3&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{&lt;Y, X&gt; | &lt;int X, int Y&gt; &lt;- {&lt;1,10&gt;, &lt;2,20&gt;}};</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;10,1&gt;, &lt;20,2&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{X, X * X | int X &lt;- {1, 2, 3, 4, 5}, X &gt;= 3};</userinput>
<computeroutput>set[int] : <literal>{3,4,5,9,16,25}</literal></computeroutput></screen>
        </section>
      </section>

      <section xml:id="section.visit">
        <title>Visit Expression</title>

        <para>Visiting the nodes in a tree is a very common task in the EASY
        domain. In many cases (but certainly not all) the tree is a syntax
        tree of some source code file and the nodes correspond to expressions
        or statements. Computing metrics or refactoring are examples of tasks
        that require a tree visit. In object-oriented programming, the
        <emphasis>visitor pattern</emphasis> is in common use for this. There
        are three frequently occurring scenarios:</para>

        <itemizedlist>
          <listitem>
            <para>Accumulator: traverse the tree and collect
            information.</para>
          </listitem>

          <listitem>
            <para>Transformer: traverse the tree and transform it into another
            tree.</para>
          </listitem>

          <listitem>
            <para>Accumulating Transformer: traverse the tree, collect
            information and also transform the tree.</para>
          </listitem>
        </itemizedlist>

        <para>The <literal>visit</literal> expression in Rascal can
        accommodate all these (and more) use cases and has the form:</para>

        <para><programlisting><replaceable>Strategy</replaceable> <keysym>visit</keysym> ( <replaceable>Exp</replaceable> ) {
<keysym>case</keysym> <replaceable>PatternWithAction</replaceable><subscript>1</subscript>;
<keysym>case</keysym> <replaceable>PatternWithAction</replaceable><subscript>2</subscript>;
...
<keysym>default</keysym>: ...
}</programlisting></para>

        <para>Given a subject term (the current value of
        <replaceable>Exp</replaceable>) and a list of cases (consisting of
        PatternWithActions, see <xref
        linkend="section.pattern-with-action" />) it traverses the term.
        Depending on the precise actions it may perform replacement (mimicking
        a transformer), update local variables (mimicking an accumulator) or a
        combination of these two (accumulating transformer). If <emphasis
        role="bold">any</emphasis> of the actions contains an
        <literal>insert</literal> statement, the value of the visit expression
        is a new value that is obtained by successive insertions in the
        subject term by executing one or more cases. Otherwise, the original
        value of the subject term is returned.</para>

        <para>The visit expression is optionally preceded by one of the
        following strategy indications that determine the traversal order of
        the subject:</para>

        <itemizedlist>
          <listitem>
            <para>top-down: visit the subject from root to leaves.</para>
          </listitem>

          <listitem>
            <para><literal>top-down-break</literal>: visit the subject from
            root to leaves, but stop at the current path when a case
            matches.</para>
          </listitem>

          <listitem>
            <para><literal>bottom-up</literal>: visit the subject from leaves
            to root (this is the default).</para>
          </listitem>

          <listitem>
            <para><literal>bottom-up-break</literal>: visit the subject from
            leaves to root, but stop at the current path when a case
            matches.</para>
          </listitem>

          <listitem>
            <para><literal>innermost</literal>: repeat a bottom-up traversal
            as long as the traversal changes the resulting value (compute a
            fixed-point).</para>
          </listitem>

          <listitem>
            <para><literal>outermost</literal>: repeat a top-down traversal as
            long as the traversal changes the resulting value (compute a
            fixed-point).</para>
          </listitem>
        </itemizedlist>

        <para>The execution of the cases has the following effect:</para>

        <itemizedlist>
          <listitem>
            <para>A <replaceable>PatternWithAction</replaceable> of the form
            <replaceable>Pat</replaceable> =&gt;
            <replaceable>Exp</replaceable> replaces the current subtree of the
            subject by the value of <replaceable>Exp</replaceable>. Note that
            a copy of the subject is created at the start of the visit
            statement and all replacements are made in this copy. As a
            consequence, modifcations made during the visit cannot influence
            matches later on.The modified copy of the subject is ultimately
            returned by the visit expression.</para>
          </listitem>

          <listitem>
            <para>A <replaceable>PatternWithAction</replaceable> of the form
            <literal><replaceable>Pat</replaceable> :
            <replaceable>Statement</replaceable></literal> executes
            <replaceable>Statement</replaceable> and this should lead to one
            of the following:</para>

            <itemizedlist>
              <listitem>
                <para>Execution of an <literal>insert</literal> statement of
                the form<programlisting><keysym>insert</keysym> <replaceable>Exp2</replaceable></programlisting>The
                value of <replaceable>Exp2</replaceable> replaces the subtree
                of the subject that is currently being visited. Once again,
                this modification takes place in a copy of the original
                subject (see above).<note>
                    <para>An <literal>insert</literal> statement may only
                    occur in a <replaceable>PatternWithAction</replaceable> in
                    a <keysym>visit</keysym> expression.</para>
                  </note></para>
              </listitem>

              <listitem>
                <para>Execution of a <keysym>fail</keysym> statement: all side
                effects of <replaceable>Statement</replaceable> are undone, no
                insertion is made, and the next case is tried.</para>
              </listitem>

              <listitem>
                <para>Execution of a <literal>return</literal> statement that
                returns a value from the enclosing function.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>The precise behaviour of the visit expression depends on the
        type of the subject:</para>

        <itemizedlist>
          <listitem>
            <para>For type <literal>node or ADT</literal>, all nodes of the
            tree are visited (in the order determined by the strategy).
            Concrete patterns and abstract patterns directly match tree nodes.
            Regular expression patterns match only values of type
            string.</para>
          </listitem>

          <listitem>
            <para>For other structured types (list, set, map, tuple, rel), the
            elements of the structured type are visited and matched against
            the cases. When inserts are made, a new structured value is
            created. In thises cases a stragegy does not have any
            effect.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.one">
        <title>One Expression</title>

        <para><programlisting><keysym>one</keysym> <literal>(</literal> <literal><replaceable>Exp</replaceable><subscript>1</subscript> , <replaceable>Exp</replaceable><subscript>2</subscript> ,</literal> ... <literal>, <replaceable>Exp</replaceable><subscript>n</subscript></literal><literal> )</literal></programlisting>The
        <keysym>one</keysym> expression yields true when one combination of
        values of <replaceable>Exp</replaceable><subscript>i</subscript> is
        true.</para>
      </section>

      <section xml:id="section.all">
        <title>All Expression</title>

        <para><programlisting><keysym>all</keysym> <literal>(</literal> <literal><replaceable>Exp</replaceable><subscript>1</subscript> , <replaceable>Exp</replaceable><subscript>2</subscript> ,</literal> ... <literal>, <replaceable>Exp</replaceable><subscript>n</subscript></literal><literal> )</literal> </programlisting>The
        all expression yields true when all combinations of values of
        <replaceable>Exp</replaceable><subscript>i</subscript> are
        true.</para>
      </section>

      <section xml:id="section.statement-as-expression">
        <title>Statement as Expression</title>

        <para>Several forms of statements produce a value and can be used as
        expression. This is further explained in the sections for the relevant
        statements, see <xref linkend="section.if" />, <xref
        linkend="section.while" />, <xref linkend="section.do" />, and <xref
        linkend="section.for" />.</para>
      </section>
    </section>

    <section xml:id="section.statements">
      <title>Statements</title>

      <para><figure xml:id="figure.statement-parts">
          <title>Various Statement Forms</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="statement-parts.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>The various statements forms are summarized in <xref
      linkend="figure.statement-parts" />. The less familiarstatements are
      shown in a different color.</para>

      <section xml:id="section.block">
        <title>Block Statement</title>

        <para>A block consists of a sequence of statements separated by
        semi-colons:<programlisting><literal>{ <replaceable>Statement</replaceable><subscript>1</subscript>; ... <replaceable>Statement</replaceable><subscript>n</subscript> }</literal></programlisting>Since
        a block is itself a statement, it may be used in all places where a
        statement is required. A block also introduces a new scope and
        variables that are declared in the block are local to that block. The
        value produced by a block is the value produced by its last
        statement.</para>
      </section>

      <section xml:id="section.assignment">
        <title>Assignment Statement</title>

        <para>The purpose of an assignment is to assign a new value to a
        simple variable or to an element of a more complex data structure. The
        most general form of an assignment statement is</para>

        <para><programlisting><replaceable>Assignable</replaceable> <replaceable>AssignmentOp</replaceable> <replaceable>Exp</replaceable></programlisting>where
        <replaceable>AssignmentOp</replaceable> may be <literal>=</literal>,
        <literal>+=</literal>, <literal>-=</literal>, <literal>*=</literal>,
        <literal>/=</literal>, or <literal>?=</literal>. Here = is the
        ordinary assignment operators and the other forms can be derived from
        it according to <xref linkend="table.assignment-operators" />.<table
            xml:id="table.assignment-operators">
            <title>Assignment Operators</title>

            <tgroup cols="2">
              <colspec align="left" colname="col1" colwidth="2*" />

              <colspec align="left" colname="col2" colwidth="2*" />

              <thead>
                <row>
                  <entry>Assignment Operator</entry>

                  <entry>Equivalent to</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><replaceable>Assignable</replaceable>
                  <literal>+=</literal> <replaceable>Exp</replaceable></entry>

                  <entry><replaceable>Assignable</replaceable>
                  <literal>=</literal> <replaceable>Assignable</replaceable>
                  <literal>+</literal> <replaceable>Exp</replaceable></entry>
                </row>

                <row>
                  <entry><replaceable>Assignable</replaceable>
                  <literal>-=</literal> <replaceable>Exp</replaceable></entry>

                  <entry><replaceable>Assignable</replaceable>
                  <literal>=</literal> <replaceable>Assignable</replaceable>
                  <literal>-</literal> <replaceable>Exp</replaceable></entry>
                </row>

                <row>
                  <entry><replaceable>Assignable</replaceable>
                  <literal>*=</literal> <replaceable>Exp</replaceable></entry>

                  <entry><replaceable>Assignable</replaceable>
                  <literal>=</literal> <replaceable>Assignable</replaceable>
                  <literal>*</literal> <replaceable>Exp</replaceable></entry>
                </row>

                <row>
                  <entry><replaceable>Assignable</replaceable>
                  <literal>/=</literal> <replaceable>Exp</replaceable></entry>

                  <entry><replaceable>Assignable</replaceable>
                  <literal>=</literal> <replaceable>Assignable</replaceable>
                  <literal>/</literal> <replaceable>Exp</replaceable></entry>
                </row>

                <row>
                  <entry><replaceable>Assignable</replaceable>
                  <literal>&amp;=</literal>
                  <replaceable>Exp</replaceable></entry>

                  <entry><replaceable>Assignable</replaceable>
                  <literal>=</literal> <replaceable>Assignable</replaceable>
                  <literal>&amp;</literal>
                  <replaceable>Exp</replaceable></entry>
                </row>

                <row>
                  <entry><replaceable>Assignable</replaceable>
                  <literal>?=</literal> <replaceable>Exp</replaceable></entry>

                  <entry><replaceable>Assignable</replaceable>
                  <literal>=</literal> <replaceable>Assignable</replaceable>
                  <literal>?</literal> <replaceable>Exp</replaceable></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>An assignable is either a single variable, (the <emphasis>base
        variable</emphasis>), optionally followed by subscriptions or field
        selections. The assignment statement always results in assigning a
        <emphasis>completely new value</emphasis> to the base variable. We
        distinguish the following forms of assignment:</para>

        <itemizedlist>
          <listitem>
            <para><programlisting><replaceable>Var</replaceable> = <replaceable>Exp</replaceable></programlisting>The
            expression <replaceable>Exp</replaceable> is evaluated and its
            value is assigned to the base variable<replaceable>
            Var</replaceable>.</para>
          </listitem>

          <listitem>
            <para><programlisting><replaceable>Assignable</replaceable> <literal>[</literal> <replaceable>Exp</replaceable><subscript>1</subscript><literal>] =</literal> <replaceable>Exp</replaceable><subscript>2</subscript></programlisting>First
            the value V of <replaceable>Assignable</replaceable> is
            determined. Next the value of
            <replaceable>Exp</replaceable><subscript>1</subscript>is used as
            index in <replaceable>V</replaceable> and the value of
            <replaceable><replaceable>Exp</replaceable><subscript>2</subscript></replaceable>
            replaces the original value at that index position. The result is
            a new value <replaceable>V</replaceable>' that is assigned to the
            <replaceable>Assignable</replaceable>.</para>
          </listitem>

          <listitem>
            <para><programlisting><replaceable>Assignable</replaceable> <literal>.</literal> <replaceable>Name</replaceable> = <replaceable>Exp</replaceable></programlisting>The
            value V of <replaceable>Assignable</replaceable> is determined and
            should be of a type that has a field Name. The value of that field
            is replaced in <replaceable>V</replaceable> by the value of
            <replaceable>Exp</replaceable> resulting in a new value V' that is
            assigned to Assignable.</para>
          </listitem>

          <listitem>
            <para><programlisting><literal>&lt;</literal> <replaceable>Assignable</replaceable><subscript>1</subscript><literal>,</literal> <replaceable>Assignable</replaceable><subscript>2</subscript><literal>,</literal> ..., <replaceable>Assignable</replaceable><subscript>n</subscript> <literal>&gt; =</literal> <replaceable>Exp</replaceable></programlisting></para>

            <para>First the value <replaceable>Exp</replaceable> is determined
            and should be a tuple of the form
            <literal>&lt;</literal><replaceable>V</replaceable><subscript>1</subscript>,
            <replaceable>V</replaceable><subscript>2</subscript>,
            ...,<replaceable>
            V</replaceable><subscript>n</subscript><literal>&gt;</literal>.
            Next the assignments
            <replaceable>Assignable</replaceable><subscript>i</subscript> =
            <replaceable>V</replaceable><subscript>i </subscript>are performed
            for 1 &lt;= i &lt;= n.</para>
          </listitem>

          <listitem>
            <para><programlisting><replaceable>Assignable</replaceable> <literal>?</literal> <replaceable><replaceable>Exp</replaceable><subscript>1</subscript></replaceable> = <replaceable><replaceable>Exp</replaceable><subscript>2</subscript></replaceable></programlisting>First
            the value of
            <replaceable>Exp</replaceable><subscript>2</subscript> is
            determined and if that is defined it is assigned to Assignable.
            Otherwise, the value of
            <replaceable><replaceable>Exp</replaceable><subscript>1</subscript></replaceable>is
            assigned to <replaceable>Assignable</replaceable>.<warning>
                <para>Does not seem to work</para>
              </warning></para>
          </listitem>

          <listitem>
            <para><programlisting><replaceable>Assignable</replaceable> <literal>@</literal> <replaceable>Name</replaceable> = <replaceable>Exp</replaceable></programlisting>The
            value V of <replaceable>Assignable</replaceable> is determined and
            should be of a type that has an annotation
            <replaceable>Name</replaceable>. The value of that annotation is
            replaced in <replaceable>V</replaceable> by the value of
            <replaceable>Exp</replaceable> resulting in a new value V' that is
            assigned to <replaceable>Assignable</replaceable>.</para>
          </listitem>

          <listitem>
            <para><programlisting><literal><replaceable>Name</replaceable> (</literal> <replaceable>Assignable</replaceable><subscript>1</subscript><literal>,</literal> <replaceable>Assignable</replaceable><subscript>2</subscript><literal>,</literal> ... <literal>) =</literal> <replaceable>Exp</replaceable></programlisting>First
            the value <replaceable>Exp</replaceable> is determined and should
            be a data value of the form
            <literal><replaceable>Name</replaceable>(</literal><replaceable>V</replaceable><subscript>1</subscript>,
            <replaceable>V</replaceable><subscript>2</subscript>,
            ...,<replaceable>V</replaceable><subscript>n</subscript><literal>)</literal>.
            Next the assignments
            <replaceable>Assignable</replaceable><subscript>i</subscript> =
            <replaceable>V</replaceable><subscript>i</subscript>are performed
            for 1 &lt;= i &lt;= n.<note>
                <para>Constructor assignable is not yet implemented.</para>
              </note></para>
          </listitem>
        </itemizedlist>

        <para>Here are some examples:<screen><prompt>rascal&gt;</prompt> <userinput>N = 3;</userinput>
<computeroutput>int : 3</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>N;</userinput>
<computeroutput>int : 3</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>L = [10,20,30];</userinput>
<computeroutput>list[int] : [10,20,30]</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>P = L;</userinput>
<computeroutput>list[int] : [10,20,30]</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>L[1] = 200;</userinput>
<computeroutput>list[int] : [10,200,30]</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>P;</userinput>  // Value of P is unchanged!
<computeroutput>list[int] : [10,20,30]</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>M = ("abc": 1, "def" : 2);</userinput>
<computeroutput>map[str,int] : ("abc": 1, "def" : 2)</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>M["def"] = 3;</userinput>
<computeroutput>map[str,int] : ("abc": 1, "def" : 3)
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>T = &lt;1, "abc", true&gt;;</userinput>
<computeroutput>tuple[int,str,bool] : &lt;1, "abc", true&gt;</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>T[1] = "def";</userinput>
<computeroutput>tuple[int,str,bool] : &lt;1, "def", true&gt;</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>data FREQ = wf(str word, int freq);</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>W = wf("rascal", 1000);</userinput>
<computeroutput>FREQ : wf("rascal", 1000)
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>W.freq = 100000;</userinput>
<computeroutput>FREQ : wf("rascal",100000)</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>&lt;A, B, C&gt; = &lt;"abc", 2.5, [1,2,3]&gt;;</userinput>
<computeroutput>tuple[str,real,list[int]] : &lt;"abc", 2.5, [1,2,3]&gt;</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>A;</userinput>
<computeroutput>str : "abc"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>B;</userinput>
<computeroutput>real : 2.5</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>C;</userinput>
<computeroutput>list[int] : [1,2,3]</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>** good V ? E1 = E2 example here **</userinput>


<prompt>rascal&gt;</prompt> <userinput>anno str FREQ@color;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>W @ color = "red";</userinput>
<computeroutput>FREQ: wf("rascal",100000)[@color="red"]</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>wf(S, I) = W;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>S;</userinput>
<computeroutput>str : "rascal"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>I;</userinput>
<computeroutput>int : 100000</computeroutput></screen></para>
      </section>

      <section xml:id="section.if">
        <title>If Statement</title>

        <para>The if-statement comes in an if-then and an if-then-else
        variant:<programlisting><keysym>if</keysym> <literal>( <replaceable>Bool</replaceable> ) <replaceable>Statement</replaceable></literal></programlisting><programlisting><keysym>if</keysym><literal> ( <replaceable>Bool</replaceable> ) <replaceable>Statement</replaceable><subscript>1</subscript> </literal><keysym>else</keysym><literal> <replaceable>Statement</replaceable><subscript>2</subscript></literal></programlisting></para>

        <para>In both cases the test <replaceable>Bool</replaceable> is
        evaluated and its outcome determines the statement to be executed.
        Recall from <xref linkend="section.expressions-boolean" /> that
        boolean expression maybe multi-valued. In this case only the first
        true value (if any) is used. The value of an if-then statement is
        always void. The value of an if-then-else statement is the value of
        the statement executed in the then or else branch.</para>
      </section>

      <section xml:id="section.switch">
        <title>Switch Statement</title>

        <para>A <literal>switch</literal> statement is similar to a switch
        statement in C or Java and has the form:<programlisting>switch ( <replaceable>Exp</replaceable> ) {
case <replaceable>PatternWithAction</replaceable><subscript>1</subscript>;
case <replaceable>PatternWithAction</replaceable><subscript>2</subscript>;
...
default: ...
}</programlisting></para>

        <para>The value of the expression <replaceable>Exp</replaceable> is
        the subject term that will be matched by the successive
        PatternWithActions (see <xref
        linkend="section.pattern-with-action" />) in the switch statement. The
        switch statement provides <emphasis role="bold">only</emphasis>
        matching at the top level of the subject term and does not traverse
        it. The type of the pattern in each case must be identical to the type
        of the subject term (or be a subtype of it). If no case matches, the
        switch acts as a dummy statement. There is no fall through from one
        case to the next.<warning>
            <para>The switch statement does not yet return a value, this will
            be changed.</para>
          </warning></para>
      </section>

      <section xml:id="section.while">
        <title>While Statement</title>

        <para>The while-statement has the form:<programlisting><keysym>while</keysym><literal> ( <replaceable>Bool</replaceable> ) <replaceable>Statement</replaceable></literal></programlisting>The
        test <replaceable>Bool</replaceable> is evaluated repeatedly and
        <replaceable>Statement</replaceable> is executed when the test is
        true. Execution ends the first time that the test yields false. The
        test <replaceable>Bool</replaceable> is executed from scratch in each
        repetition and only the first true value (if any) is used.</para>

        <para>By default, the value of a while statement is the empty list. In
        general, the value of a while statement consists of all values
        contributed by <keysym>append</keysym> statements that are executed
        during the repeated execution of its body
        <replaceable>Statement</replaceable>.<warning>
            <para>Append is not yet implemented for this statement.</para>
          </warning></para>
      </section>

      <section xml:id="section.do">
        <title>Do Statement</title>

        <para>The do-while-statement has the form:<programlisting><keysym>do</keysym> <replaceable>Statement</replaceable> <keysym>while</keysym> <literal>( <replaceable>Bool</replaceable> ) </literal></programlisting><replaceable>Statement</replaceable>
        is executed repeatedly, as long as the test
        <replaceable>Bool</replaceable> yields true. The test
        <replaceable>Bool</replaceable> is executed from scratch in each
        repetition and only the first true value (if any) is used.</para>

        <para>By default, the value of a do statement is the empty list. In
        general, the value of a do statement consists of all values
        contributed by <keysym>append</keysym> statements that are executed
        during the repeated execution of its body
        <replaceable>Statement</replaceable>.</para>

        <warning>
          <para>Append is not yet implemented for this statement.</para>
        </warning>
      </section>

      <section xml:id="section.for">
        <title>For Statement</title>

        <para>The for-statement has the form:<programlisting><keysym>for</keysym> <literal>(</literal> <literal><replaceable>Exp</replaceable><subscript>1</subscript> , <replaceable>Exp</replaceable><subscript>2</subscript> ,</literal> ... <literal>, <replaceable>Exp</replaceable><subscript>n</subscript></literal><literal> )</literal> <replaceable>Statement</replaceable></programlisting>It
        executes <replaceable>Statement</replaceable> for all possible
        combinations of values of the expressions
        <replaceable>Exp</replaceable><subscript>i</subscript>. Note that if
        one of the expressions is a boolean expression, we do try all its
        possible values.</para>

        <para>By default, the value of a for statement is the empty list. In
        general, the value of a for statement consists of all values
        contributed by <keysym>append</keysym> statements that are executed
        during the repeated execution of its body
        <replaceable>Statement</replaceable>.</para>
      </section>

      <section xml:id="section.return">
        <title>Return Statement</title>

        <para>A return statement has either the form<programlisting><keysym>return</keysym>;</programlisting>or<programlisting><keysym>return</keysym> <replaceable>Exp</replaceable>;</programlisting></para>

        <para>both end the execution of the current function. The first form
        applies to functions with <literal>void</literal> as return type. The
        second form applies to non-void functions and returns the value of
        <replaceable>Exp</replaceable> as result of the function. The
        following rules apply:</para>

        <itemizedlist>
          <listitem>
            <para>The static type of <replaceable>Exp</replaceable> should be
            compatible with the declared return type of the function in which
            the return statement occurs.</para>
          </listitem>

          <listitem>
            <para>In each function with a return type that is not
            <literal>void</literal>, every possible execution path through the
            body of the function should end in a return statement.<note>
                <para>This rule is not yet enforced.</para>
              </note></para>
          </listitem>

          <listitem>
            <para>In each function with a return type that is
            <literal>void</literal>, a return statement is implicitly assumed
            at the end of each execution path through the function
            body.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.append">
        <title>Append Statement</title>

        <para>An append statement may only occur in the body of a
        <keysym>while</keysym>, <keysym>do</keysym> or <keysym>for</keysym>
        statement. It has the form<programlisting><keysym>append</keysym> <replaceable>Exp</replaceable>;</programlisting>and
        appends the value of <replaceable>Exp</replaceable> to the result
        value of the loop construct in which it occurs.</para>
      </section>

      <section xml:id="section.insert">
        <title>Insert Statement</title>

        <para>An insert statement has the form<programlisting><keysym>insert</keysym> <replaceable>Exp</replaceable>;</programlisting>and
        replaces the value of the <emphasis>current subject</emphasis> (see
        below) by the value of <replaceable>Exp</replaceable>. An insert
        statement may only occur in the action part of a PatternWithAction
        (see <xref linkend="section.pattern-with-action" />), more precisely
        in</para>

        <itemizedlist>
          <listitem>
            <para>A case in a visit expression, see <xref
            linkend="section.visit" />. The current subject is the value
            matched by the pattern of this case.</para>
          </listitem>

          <listitem>
            <para>An action of a rewrite rule, see <xref
            linkend="section.rewrite-rule" />. The current subject is the
            value matched by the pattern of the rewrite rule.</para>
          </listitem>
        </itemizedlist>

        <para>The following rule applies:</para>

        <itemizedlist>
          <listitem>
            <para>The static type of <replaceable>Exp</replaceable> and of the
            current subject should be comparable.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.fail">
        <title>Fail Statement</title>

        <para>A fail statement has the form<programlisting><keysym>fail</keysym>;</programlisting></para>

        <para>and may only occur in the action of PatternWithAction (see <xref
        linkend="section.pattern-with-action" />). The fail statement forces
        the failure of that action. Any bindings caused by the pattern or
        side-effects caused by the action are undone.</para>
      </section>

      <section xml:id="section.try-catch">
        <title>Try Catch Statement</title>

        <para>A try catch statement has the form<programlisting>try
   Statement<subscript>1</subscript>;
catch <replaceable>PatternWithAction</replaceable><subscript>1</subscript>;
catch <replaceable>PatternWithAction</replaceable><subscript>2</subscript>;
...
catch: <replaceable>Statement</replaceable><subscript>2</subscript>;
finally: <replaceable>Statement</replaceable><subscript>3</subscript>;</programlisting>and
        has as purpose to catch any exceptions that are raised during the
        execution of
        <replaceable>Statement</replaceable><subscript>1</subscript>. These
        exceptions may caused by:</para>

        <itemizedlist>
          <listitem>
            <para>The execution of an explicit throw statement, see <xref
            linkend="section.throw" />.</para>
          </listitem>

          <listitem>
            <para>The Rascal system that discover an abnormal condition, e.g.,
            an out of bounds error when accessing a list element.</para>
          </listitem>
        </itemizedlist>

        <para>Note that all elements of the try catch statement are optional
        but that at least one has to be present. Their meaning is as
        follows:</para>

        <itemizedlist>
          <listitem>
            <para>If a pattern of some
            <replaceable>PatternWithAction</replaceable><subscript>i</subscript>
            matches, the corresponding action is executed.</para>
          </listitem>

          <listitem>
            <para>Otherwise,
            <replaceable>Statement</replaceable><subscript>2</subscript> is
            executed (when present).</para>
          </listitem>

          <listitem>
            <para>Before leaving the try catch statement
            <replaceable>Statement</replaceable><subscript>3</subscript> is
            always executed (when present).</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.throw">
        <title>Throw Statement</title>

        <para>A throw statement has the form<programlisting><keysym>throw</keysym> <replaceable>Exp</replaceable>;</programlisting>and
        causes the immediate abortion of the execution of the current function
        with <replaceable>Exp</replaceable>'s value as exception value. The
        exception can be caught by a try catch statement (<xref
        linkend="section.try-catch" />) in the current function or in one of
        its callers. If the exception is not caught, the execution of the
        Rascal program is terminated. The following rules apply:</para>

        <itemizedlist>
          <listitem>
            <para>The static type of <replaceable>Exp</replaceable> should be
            <literal>RuntimeException</literal>, see <xref
            linkend="section.lib-Exception" />.</para>
          </listitem>

          <listitem>
            <para>The Rascal program may contain data declarations that extend
            the type RuntimeException.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Assert Statement</title>

        <para>An assert statement may occur everywhere where a declaration is
        allowed. It has two forms:</para>

        <para><programlisting><keysym>assert</keysym> <literal><replaceable>Exp</replaceable><subscript>1</subscript></literal></programlisting></para>

        <para>and <programlisting><keysym>assert</keysym><literal> <replaceable>Exp</replaceable><subscript>1</subscript> : <replaceable>Exp</replaceable><subscript>2</subscript></literal></programlisting>where
        <replaceable>Exp</replaceable><subscript>1</subscript> is a
        boolean-value expression and
        <replaceable>Exp</replaceable><subscript>2</subscript> is a
        string-valued expression that serves as a identifying message for this
        assertion. When <replaceable>Exp</replaceable><subscript>1</subscript>
        evaluates to false, an <literal>AssertionFailed</literal> exception is
        thrown.</para>

        <para>Example:</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>assert {1, 2, 3, 1} == {3, 2, 1, 1} : "Equality on Sets";</userinput>
bool: true

<prompt>rascal&gt;</prompt> <userinput>assert 1==2 : "is never true";</userinput>
<computeroutput>Uncaught Rascal Exception: -:1,0: AssertionFailed("is never true")</computeroutput></screen>
      </section>

      <section xml:id="section.test">
        <title>Test Statement</title>

        <para>A test statement forms the basis for Rascal's unit-testing
        framework and may occur everywhere where a declaration is allowed. It
        has two forms:</para>

        <para><programlisting><keysym>test</keysym> <literal><replaceable>Exp</replaceable><subscript>1</subscript></literal></programlisting></para>

        <para>and <programlisting><keysym>test</keysym><literal> <replaceable>Exp</replaceable><subscript>1</subscript> : <replaceable>Exp</replaceable><subscript>2</subscript></literal></programlisting>where
        <replaceable>Exp</replaceable><subscript>1</subscript> is a
        boolean-value expression and
        <replaceable>Exp</replaceable><subscript>2</subscript> is a
        string-valued expression that serves as a identifying message for this
        test.</para>

        <para>During normal execution tests are ignored. When the script is
        executed as a <emphasis>test suite</emphasis> a summary of this
        information is shown to the user. When the script is executed in the
        standard fashion, the test statement has no affect. <screen>rascal&gt;test 1==2;      <co
              xml:id="co.test1" />
ok
rascal&gt;:test           <co xml:id="co.test2" />
failed  : test 1==2
ok
</screen><calloutlist>
            <callout arearefs="co.test1">
              <para>The test is ignored during standard execution.</para>
            </callout>

            <callout arearefs="co.test2">
              <para>There are two ways to execute as test suite. By executing
              the <literal>:test</literal> directive of the Rascal shell
              (shown here) or by setting the option
              <literal>rascal.options.testsuite</literal> (<remark>not yet
              implemented</remark>).</para>
            </callout>
          </calloutlist></para>
      </section>

      <section>
        <title>Solve Statement</title>

        <para>Rascal provides a solve statement for performing arbitrary
        fixed-point computations. This means, repeating a certain computation
        as long as it causes changes. This can, for instance, be used for the
        solution of sets of simultaneous linear equations but has much wider
        applicability. The format is:<programlisting><literal>with {
  <replaceable>Type</replaceable><subscript>1</subscript> <replaceable>Var</replaceable><subscript>1</subscript> = <replaceable>Exp</replaceable><subscript>1</subscript>;
  <replaceable>Type</replaceable><subscript>2</subscript> <replaceable>Var</replaceable><subscript>2</subscript> = <replaceable>Exp</replaceable><subscript>2</subscript>;
  ...
} solve
  <replaceable>Statement</replaceable></literal></programlisting></para>

        <para>The solve statement consists of an initialization section and a
        statement. Optionally, an expression directly following the
        <literal>solve</literal> keyword, gives an upper bound on the number
        of iterations.</para>

        <para>In the <literal>initial</literal> section, the variables
        <replaceable>Var</replaceable><subscript><replaceable>i</replaceable></subscript>
        are declared and initialized. In the <literal>solve</literal> section,
        the statement can use and modify these variables. The statement is
        executed, assigning new values to the variables
        <replaceable>Var</replaceable><subscript><replaceable>i</replaceable></subscript>,
        and this is repeated as long as the value of any of the variables was
        changed compared to the previous repetition.</para>

        <para>Let's consider transitive closure as an example (transitive
        closure is already available as built-in operator, we use it here just
        as a simple illustration). Transitive closure of a relation is usually
        defined as:<programlisting>R+ = R + (R o R) + (R o R o R) + ...</programlisting>This
        can be expressed as follows:</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>rel[int,int] R = {&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;};</userinput>
<computeroutput>rel[int,int] : {&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;}</computeroutput>
<prompt>rascal&gt;</prompt>
  <userinput>with
     rel[int,int] T = R;
  solve
     T = T + (T o R);</userinput>

<computeroutput>rel[int,int] : {&lt;1,2&gt;, &lt;1,3&gt;,&lt;1,4&gt;,&lt;2,3&gt;,&lt;2,4&gt;,&lt;3,4&gt;}</computeroutput></screen>
      </section>
    </section>
  </section>

  <?hard-pagebreak ?>

  <section xml:id="section.lib">
    <title>Built-in Operators and Library Functions</title>

    <para>The built-in operators and library functions can be subdivided in
    the following categories:</para>

    <itemizedlist>
      <listitem>
        <para>ATermIO: reading and writing values in the ATerm format, see
        <xref linkend="section.lib-ATermIO" />.</para>
      </listitem>

      <listitem>
        <para>Benchmark: measuring functions, see <xref
        linkend="section.lib-Benchmark" />.</para>
      </listitem>

      <listitem>
        <para>Boolean: operators and functions on Boolean values, see <xref
        linkend="section.lib-Boolean" />.</para>
      </listitem>

      <listitem>
        <para>Chart: functions to draw various charts, see <xref
        linkend="section.lib-Chart" />.</para>
      </listitem>

      <listitem>
        <para>Exception: data definition of all soft exceptions that can be
        caught by Rascal programs, see <xref
        linkend="section.lib-Exception" />.</para>
      </listitem>

      <listitem>
        <para>Graph: graphs are a special kind of binary relation, see <xref
        linkend="section.lib-Graph" />.</para>
      </listitem>

      <listitem>
        <para>Integer: operators and functions on integers, see <xref
        linkend="section.lib-Integer" />.</para>
      </listitem>

      <listitem>
        <para>IO: simple print functions, see <xref
        linkend="section.lib-IO" />.</para>
      </listitem>

      <listitem>
        <para>JDT: Java fact extraction functions, see <xref
        linkend="section.lib-JDT" />.</para>
      </listitem>

      <listitem>
        <para>Labelled Graph: labelled graphs with addition edge information,
        see <xref linkend="section.lib-LabelledGraph" />.</para>
      </listitem>

      <listitem>
        <para>List: operators and functions on lists, see <xref
        linkend="section.lib-List" />.</para>
      </listitem>

      <listitem>
        <para>Location: operators and functions on source locations, see <xref
        linkend="section.lib-Location" />.</para>
      </listitem>

      <listitem>
        <para>Map: operators and functions on maps, see <xref
        linkend="section.lib-Map" />.</para>
      </listitem>

      <listitem>
        <para>Node: operators and functions on nodes, see <xref
        linkend="section.lib-Node" />.</para>
      </listitem>

      <listitem>
        <para>PriorityQueu: functions on priority queues, see <xref
        linkend="section.lib-PriorityQueue" />.</para>
      </listitem>

      <listitem>
        <para>Real: operators and functions on reals, see <xref
        linkend="section.lib-Real" />.</para>
      </listitem>

      <listitem>
        <para>Relation: operators and functions on relations, see <xref
        linkend="section.lib-Relation" />.</para>
      </listitem>

      <listitem>
        <para>Resource: functions to retrieve resources from an Eclipse
        workspace, see <xref linkend="section.lib-Resource" />.</para>
      </listitem>

      <listitem>
        <para>RSF: function for reading files in Rigi Standard Format, see
        <xref linkend="section.lib-RSF" />.</para>
      </listitem>

      <listitem>
        <para>Set: operators and functions on sets, see <xref
        linkend="section.lib-Set" />.</para>
      </listitem>

      <listitem>
        <para>String: operators and functions on strings, see <xref
        linkend="section.lib-String" />.</para>
      </listitem>

      <listitem>
        <para>Tree: functions on parse trees, see <xref
        linkend="section.lib-Tree" />.</para>
      </listitem>

      <listitem>
        <para>Tuple: operators and functions on tuples, see <xref
        linkend="section.lib-Tuple" />.</para>
      </listitem>

      <listitem>
        <para>UnitTest: functions for unit testing, see <xref
        linkend="section.lib-UnitTest" />.</para>
      </listitem>

      <listitem>
        <para>ValueIO: functions for reading and writing Rascal values, both
        in textual and in binary form, see <xref
        linkend="section.lib-ValueIO" />.</para>
      </listitem>

      <listitem>
        <para>View: functions for graphical display of values in Eclipse, see
        <xref linkend="section.lib-View" />.</para>
      </listitem>

      <listitem>
        <para>Void: the type void, see <xref
        linkend="section.lib-Void" />.</para>
      </listitem>
    </itemizedlist>

    <para>All operators are directly available for each program, but library
    functions have to be imported in each module that uses them.</para>

    <para>We use some notational conventions to describe the argument of
    operators, as shown in <xref linkend="table.notational-conventions" />.
    When an operator has more than one argument of the same type, they are
    distinguished by subscripts.<table xml:id="table.notational-conventions">
        <title>Notational conventions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="2*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Argument</entry>

              <entry>Describes expression of type</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>Bool</replaceable></entry>

              <entry><keysym>bool</keysym></entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable></entry>

              <entry><keysym>int</keysym></entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable></entry>

              <entry><keysym>real</keysym></entry>
            </row>

            <row>
              <entry><replaceable>Number</replaceable></entry>

              <entry><keysym>int</keysym> or <keysym>real</keysym></entry>
            </row>

            <row>
              <entry><replaceable>Str</replaceable></entry>

              <entry><keysym>str</keysym></entry>
            </row>

            <row>
              <entry><replaceable>Loc</replaceable></entry>

              <entry><keysym>loc</keysym></entry>
            </row>

            <row>
              <entry><replaceable>Node</replaceable></entry>

              <entry><keysym>node</keysym></entry>
            </row>

            <row>
              <entry><replaceable>List</replaceable></entry>

              <entry>Any <keysym>list</keysym> type</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable></entry>

              <entry>Any <keysym>set</keysym> type</entry>
            </row>

            <row>
              <entry><replaceable>Map</replaceable></entry>

              <entry>Any <keysym>map</keysym> type</entry>
            </row>

            <row>
              <entry><replaceable>Tuple</replaceable></entry>

              <entry>Any <keysym>tuple</keysym> type</entry>
            </row>

            <row>
              <entry><replaceable>Rel</replaceable></entry>

              <entry>Any <keysym>rel</keysym> type</entry>
            </row>

            <row>
              <entry><replaceable>Value</replaceable></entry>

              <entry><keysym>value</keysym></entry>
            </row>

            <row>
              <entry><replaceable>Elm</replaceable></entry>

              <entry>Compatible with element type of list, set, map,
              relation</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <section xml:id="section.lib-ATermIO">
      <title>ATermIO</title>

      <para>ATerms are a general data format for exchanging tree structured
      data between programs. ATerms are language and computer architecture
      neutral and can thus be used to exchange data between programs that are
      written in different programming languages and that run on different,
      incompatible, computers. ATerms are extensively used in the ToolBus, the
      ASF+SDF Meta-Environment, Stratego, TOM, and other systems. The ATermIO
      library provides functions to convert a Rascal value to an ATerm and to
      write that ATerm to a text file and also to read an ATerm from a text
      file and to convert that ATerm to a Rascal value.<table>
          <title>ATermIO Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="2*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>public &amp;T readTextATermFile(type[&amp;T]
                start, loc location)</literal></entry>

                <entry>Read a value in ATerm format from a text file and
                convert it to a specific type</entry>
              </row>

              <row>
                <entry><literal>public value readTextATermFile(loc
                location)</literal></entry>

                <entry>Read a value in ATerm format from a text file</entry>
              </row>

              <row>
                <entry><literal>public void java writeTextATermFile(loc
                location, value v)</literal></entry>

                <entry>Convert a value to ATerm format and write it to a text
                file</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Benchmark">
      <title xml:id="x">Benchmark</title>

      <para>Benchmark provides a rudimentary benchmarking framework.<warning>
          <para>Check benchmark function</para>
        </warning></para>

      <table>
        <title>Benchmark Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="2*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>real currentTimeMillis()</literal></entry>

              <entry>Current time in milliseconds since January 1, 1970
              GMT.</entry>
            </row>

            <row>
              <entry><literal>public void benchmark(map[str, void()]
              Cases)</literal></entry>

              <entry>Measure and report the execution time of
              name:void-closure pairs.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-Boolean">
      <title>Boolean</title>

      <table>
        <title>Boolean Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if both arguments are
              identical<literal></literal></entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if both arguments are not
              identical</entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if both arguments are
              identical or
              <replaceable>Bool</replaceable><subscript>1</subscript> is
              <literal>false</literal> and
              <replaceable>Bool</replaceable><subscript>2</subscript> is
              <literal>true</literal></entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Bool</replaceable><subscript>1</subscript> is
              <literal>false</literal> and
              <replaceable>Bool</replaceable><subscript>2</subscript> is
              <literal>true</literal></entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if both arguments are
              identical or
              <replaceable>Bool</replaceable><subscript>1</subscript> is
              <literal>true</literal> and
              <replaceable>Bool</replaceable><subscript>2</subscript> is
              <literal>false</literal></entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Bool</replaceable><subscript>1</subscript> is
              <literal>true</literal> and
              <replaceable>Bool</replaceable><subscript>2</subscript> is
              <literal>false</literal></entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>&amp;&amp;</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if both arguments have the
              value true and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>||</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if either argument has the
              value true and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>==&gt;</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>false</literal> if
              <replaceable>Bool</replaceable><subscript>1</subscript> has the
              value <literal>true</literal> and
              <replaceable>Bool</replaceable><subscript>2</subscript> has
              value <literal>false</literal>, and <literal>true</literal>
              otherwise</entry>
            </row>

            <row>
              <entry><literal>!</literal>
              <replaceable>Bool</replaceable></entry>

              <entry>Yields true if Bool is false and true otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable><subscript>1</subscript>
              <literal>?</literal>
              <replaceable>Bool</replaceable><subscript>2</subscript>
              <literal>:</literal>
              <replaceable>Bool</replaceable><subscript>3</subscript></entry>

              <entry>If
              <replaceable>Bool</replaceable><subscript>1</subscript> is true
              then <replaceable>Bool</replaceable><subscript>2</subscript>
              else
              <replaceable>Bool</replaceable><subscript>3</subscript></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Boolean Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="2*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>bool arbBool()</literal></entry>

              <entry>Arbitrary boolean value</entry>
            </row>

            <row>
              <entry><literal>bool fromInt(int i)</literal></entry>

              <entry>Convert an integer to a bool</entry>
            </row>

            <row>
              <entry><literal>bool fromString(str s)</literal></entry>

              <entry>Convert the strings "true" or "false" to a bool</entry>
            </row>

            <row>
              <entry><literal>int toInt(bool b)</literal></entry>

              <entry>Convert a boolean value to integer</entry>
            </row>

            <row>
              <entry><literal>real toReal(bool b)</literal></entry>

              <entry>Convert a boolean value to a real value</entry>
            </row>

            <row>
              <entry><literal>str toString(bool b)</literal></entry>

              <entry>Convert a boolean value to a string</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-Chart">
      <title>Chart</title>

      <para><warning>
          <para>A copy of the chart functions also exists in the View module
          for use in Eclipse. Unify this.</para>
        </warning>These functions provide chart drawing facilities and are
      based on JFreeChart. Different charts need their input data in different
      formats that can be summarized as follows:</para>

      <para><programlisting>// A named series of int or real values

public alias intSeries  = 
       tuple[str name,list[int]  values];
       
public alias realSeries = 
       tuple[str name,list[real] values];

// Some charts need multiple values instead of a single one and
// include a category name for each subseries.

public alias intSeriesMultipleData  = 
       tuple[str name,
             list[tuple[str category, 
                        list[int] values]] allvalues];
       
public alias realSeriesMultipleData = 
       tuple[str name,
             list[tuple[str category, 
                        list[real] values2]] allvalues];
</programlisting></para>

      <para>All chart drawing functions take as arguments:</para>

      <itemizedlist>
        <listitem>
          <para>A title string.</para>
        </listitem>

        <listitem>
          <para>A single value that is to be displayed as a chart.</para>
        </listitem>

        <listitem>
          <para>Some functions have one or two additonal arguments.</para>
        </listitem>

        <listitem>
          <para>Finally, zero or more settings that give control over the way
          in which the chart is drawn.</para>
        </listitem>
      </itemizedlist>

      <para><table>
          <title>Chart Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="6*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>public void barChart(str title, map[str,int]
                facts, chartSetting settings...)</literal></entry>

                <entry>Draw a bar chart for integers</entry>
              </row>

              <row>
                <entry><literal>public void barChart(str title, map[str,real]
                facts, chartSetting settings...)</literal></entry>

                <entry>Draw a bar chart for reals</entry>
              </row>

              <row>
                <entry><literal>public void barChart(str title, list[str]
                categories, list[intSeries] facts, chartSetting
                settings...)</literal></entry>

                <entry>Draw a bar chart for multiples series of
                integere</entry>
              </row>

              <row>
                <entry><literal>public void barChart(str title, list[str]
                categories, list[realSeries] facts, chartSetting
                settings...)</literal></entry>

                <entry>Draw a bar chart for multiple series of reals</entry>
              </row>

              <row>
                <entry><literal>public void boxplot(str title,
                list[intSeriesMultipleData] facts, chartSetting
                settings...)</literal></entry>

                <entry>Draw a boxplot for integers</entry>
              </row>

              <row>
                <entry><literal>public void boxplot(str title,
                list[realSeriesMultipleData] facts, chartSetting
                settings...)</literal></entry>

                <entry>Draw a boxplot for reals</entry>
              </row>

              <row>
                <entry><literal>public void histogram(str title,
                list[intSeries] facts, int nbins, chartSetting
                settings...)</literal></entry>

                <entry>Draw a histogram for integers</entry>
              </row>

              <row>
                <entry><literal>public void histogram(str title,
                list[realSeries] facts, int nbins, chartSetting
                settings...)</literal></entry>

                <entry>Draw a histogram for reals</entry>
              </row>

              <row>
                <entry><literal>public void pieChart(str title, map[str, int]
                facts, chartSetting settings...)</literal></entry>

                <entry>Draw a pieChart for integers</entry>
              </row>

              <row>
                <entry><literal>public void pieChart(str title, map[str, real]
                facts, chartSetting settings...)</literal></entry>

                <entry>Draw a pieChart for reals</entry>
              </row>

              <row>
                <entry><literal>public void xyChart(str title,
                list[intSeries], chartSetting settings...)</literal></entry>

                <entry>Draw an xyChart for integers</entry>
              </row>

              <row>
                <entry><literal>public void xyChart(str title,
                list[realSeries], chartSetting settings...)</literal></entry>

                <entry>Draw an xyChart for reals</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>In its simplest form, a <emphasis>barChart</emphasis> displays a
      map of integer or real values. Vertical bars are drawn with length
      according to the values and the associated keys in the map acts as
      labels. A barChart may also display several series of integer or real
      values. In this case a list of category names and a list of int or real
      series are needed. The <replaceable>n</replaceable>-th category name
      corresponds with the <replaceable>n</replaceable>-th element in each
      series. Names of series act thus as row names and category names act as
      column names. Each series is grouped together in the bar chart and
      corresponding category elements in different series get the same color.
      See <link
      xlink:href="http://en.wikipedia.org/wiki/Bar_chart">http://en.wikipedia.org/wiki/Bar_chart</link>
      for further details</para>

      <para>BoxPlots are also known as box-and-whisker diagrams and are
      usefull to display statistical data. One of the most famous box plots
      stems from the Michelson-Morley Experiment in 1887, see <link
      xlink:href="http://en.wikipedia.org/wiki/Box_plot">http://en.wikipedia.org/wiki/Box_plot</link>
      for further details. For each named subseries of data, the following
      characteristics are shown:</para>

      <itemizedlist>
        <listitem>
          <para>The sample minimum.</para>
        </listitem>

        <listitem>
          <para>The lower quartile (Q1).</para>
        </listitem>

        <listitem>
          <para>The median (Q2).</para>
        </listitem>

        <listitem>
          <para>The upper quartile (Q3).</para>
        </listitem>

        <listitem>
          <para>The sample maximum.</para>
        </listitem>
      </itemizedlist>

      <para>The values from minimum to maximum are indicated by a vertical
      line. Values between Q1 and Q3 are indicated by a small box superimposed
      on this vertical line. A horizontal line inside the box indicates the
      medium. Outliers are explicitly indicated in the plot.</para>

      <para>A histogram displays observations in a fixed number of bins, see
      <link
      xlink:href="http://en.wikipedia.org/wiki/Histogram">http://en.wikipedia.org/wiki/Histogram</link>
      for details.</para>

      <para><replaceable>PieCharts</replaceable> essentially take maps of
      integers or reals as input. The strings are used to label each sector of
      the pieChart and the number determines the relative size of the sector.
      See <link
      xlink:href="http://en.wikipedia.org/wiki/Pie_chart">http://en.wikipedia.org/wiki/Pie_chart</link>
      for further details.</para>

      <para>An xyChart plots the graph of one or more functions on the same
      grid. Each series is interpreted as a list of (x,y) values; the name of
      the series acts as function name.</para>

      <para>All chart functions can have zero or more chartSettings that give
      control over the way in which the chart is drawn. A chartSetting can be
      one of the following:</para>

      <para><programlisting>data chartSetting =       
     area()
   | dim3()                       
   | domainLabel(str txt)
   | horizontal()   
   | noSectionLabels() 
   | rangeLabel(str txt)
   | ring()     
   | scatter()  
   | stacked()               
   | subtitle(str txt)
   | vertical()
   ;</programlisting>The applicability and meaning of these settings is as
      follows.<table>
          <title>Chart Settings</title>

          <tgroup cols="3">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="1*" />

            <colspec align="left" colname="col3" colwidth="2*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Applicable for</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>area()</literal></entry>

                <entry>xyChart</entry>

                <entry>Changes an xyChart from a line graph into an area
                graph, i.e., all surface below the line graph is
                colored.</entry>
              </row>

              <row>
                <entry><literal>dim3()</literal></entry>

                <entry>barChart, pieChart</entry>

                <entry>Draw a 3D version of the chart.</entry>
              </row>

              <row>
                <entry><literal>domainLabel(str txt)</literal></entry>

                <entry>barChart, boxPlot, histogram, xyPlot</entry>

                <entry>Draw a label at the bottom (domain, x-axis) of the
                chart</entry>
              </row>

              <row>
                <entry><literal>horizontal()</literal></entry>

                <entry>barChart, boxPlot, histogram, xyChart</entry>

                <entry>Default, horizontal, drawing mode</entry>
              </row>

              <row>
                <entry><literal>noSectionLabels()</literal></entry>

                <entry>pieChart</entry>

                <entry>Do not draw labels for the sections of a
                pieChart</entry>
              </row>

              <row>
                <entry><literal>rangeLabel(str txt)</literal></entry>

                <entry>barChart, boxPlot, histogram, xyPlot</entry>

                <entry>Draw a label at the left (range, y-axis) of the
                chart</entry>
              </row>

              <row>
                <entry><literal>ring()</literal></entry>

                <entry>pieChart</entry>

                <entry>Draw pieChart as a ring</entry>
              </row>

              <row>
                <entry><literal>scatter()</literal></entry>

                <entry>xyChart</entry>

                <entry>Draw xyChart as a scatter plot</entry>
              </row>

              <row>
                <entry><literal>stacked()</literal></entry>

                <entry>barChart</entry>

                <entry>Draw barChart in stacked fashion</entry>
              </row>

              <row>
                <entry><literal>subtitle(str txt)</literal></entry>

                <entry>barChart, boxPlot, histogram, peiChart xyChart</entry>

                <entry>At the top of the chart, draw a subtitle below the
                title</entry>
              </row>

              <row>
                <entry><literal>vertical()</literal></entry>

                <entry>barChart, boxPlot, histogram, xyChart</entry>

                <entry>Vertical drawing mode.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Exception">
      <title>Exception</title>

      <para>The following "soft" exceptions can be caught by the Rascal
      program:<programlisting>ddata RuntimeException = 
      EmptyList()
    | EmptyMap() 
    | EmptySet()
    | IndexOutOfBounds(int index)
    | AssertionFailed() 
    | AssertionFailed(str label)
    | NoSuchElement(value v)
    | IllegalArgument(value v)
    | IllegalArgument()
    | IO(str message)
    | PathNotFound(loc l)
    | SchemeNotSupported(loc l)
    | HostNotFound(loc l)
    | AccessDenied(loc l)
    | PermissionDenied()
    | PermissionDenied(str message)
    | ModuleNotFound(str name)
    | NoSuchKey(value key)
    | NoSuchAnnotation(str label)
    | Java(str message)
    | ParseError(loc location)
    | IllegalIdentifier(str name)
    ;</programlisting></para>
    </section>

    <section xml:id="section.lib-Graph">
      <title>Graph</title>

      <para>The graph datatype is a special form of binary relation defined as
      follows:</para>

      <para><programlisting>alias graph[&amp;T] = rel[&amp;T from, &amp;T to];</programlisting></para>

      <table>
        <title>Graph Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="3*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>set[&amp;T] bottom(graph[&amp;T]
              G)</literal></entry>

              <entry>Leaf nodes of a graph</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] predecessors(graph[&amp;T], &amp;T
              From)</literal></entry>

              <entry>Direct predecessors of node From</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reach(graph[&amp;T] G, set[&amp;T]
              Start)</literal></entry>

              <entry>Reachability from set of start nodes.</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reachR(graph[&amp;T] G, set[&amp;T]
              Start, set[&amp;T] Restr)</literal></entry>

              <entry>Reachability from set of start nodes with restriction to
              certain nodes.</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reachX(graph[&amp;T] G, set[&amp;T]
              Start, set[&amp;T] Excl)</literal></entry>

              <entry>Reachability from set of start nodes with exclusion of
              certain nodes</entry>
            </row>

            <row>
              <entry><literal>list[&amp;T] shortestPathPair(graph[&amp;T] G,
              &amp;T From, &amp;T To)</literal></entry>

              <entry>Shortest path between pair of nodes</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] successors(graph[&amp;T], &amp;T
              From)</literal></entry>

              <entry>Direct successors of node From</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] top(graph[&amp;T]
              G)</literal></entry>

              <entry>Root nodes of a graph</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The following examples illustrate these functions:<screen><prompt>rascal&gt;</prompt> <userinput>top({&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;, &lt;3,4&gt;});</userinput>
<computeroutput>set[int] : {1}</computeroutput>

<literal>rascal&gt; </literal><userinput><literal>bottom({&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;, &lt;3,4&gt;})</literal>;</userinput>
<computeroutput>set[int] : {4}</computeroutput>

<literal>rascal&gt; </literal><userinput><literal>reachR({&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;, &lt;3,4&gt;}, {1}, {1, 2, 3})</literal>;</userinput>
<computeroutput>set[int] : {2, 3}</computeroutput>

<literal>rascal&gt; </literal><userinput><literal>reachX({&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;, &lt;3,4&gt;}, {1}, {2})</literal>;</userinput>
<computeroutput>set[int,int] : {3, 4}</computeroutput></screen></para>
    </section>

    <section xml:id="section.lib-Integer">
      <title>Integer</title>

      <para>Rascal integers are unbounded in size.</para>

      <table>
        <title>Integer Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if both arguments are
              numerically equal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if both arguments are
              numerically unequal and <literal>false</literal>
              otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Int</replaceable><subscript>1</subscript> is
              numerically less than or equal to
              <replaceable>Int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Int</replaceable><subscript>1</subscript> is
              numerically less than
              <replaceable>Int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Int</replaceable><subscript>1</subscript> is
              numerically greater than or equal than
              <replaceable>Int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Int</replaceable><subscript>1</subscript> is
              numerically greater than
              <replaceable>Int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>Sum of
              <replaceable>Int</replaceable><subscript>1</subscript> and
              <replaceable>Int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>-</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>Difference of
              <replaceable>Int</replaceable><subscript>1</subscript> and
              <replaceable>Int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>*</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              multiplied by
              <replaceable>Int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>/</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              divided by
              <replaceable>Int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Int</replaceable><subscript>1</subscript>
              <literal>%</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>Remainder of dividing
              <replaceable>Int</replaceable><subscript>1</subscript> by
              <replaceable>Int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry>- <replaceable>Int</replaceable></entry>

              <entry>Negate sign of <replaceable>Int</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable> <literal>?</literal>
              <replaceable>Int</replaceable><subscript>1</subscript>
              <literal>:</literal>
              <replaceable>Int</replaceable><subscript>2</subscript></entry>

              <entry>If <replaceable>Bool</replaceable> is true then
              <replaceable>Int</replaceable><subscript>1</subscript> else
              <replaceable>Int</replaceable><subscript>2</subscript></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Integer Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="2*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>int abs(int N)</literal></entry>

              <entry>Absolute value of integer N</entry>
            </row>

            <row>
              <entry><literal>int arbInt()</literal></entry>

              <entry>Arbitrary integer value</entry>
            </row>

            <row>
              <entry><literal>int arbInt(int limit)</literal></entry>

              <entry>Arbitrary integer value in the interval [0,
              limit)</entry>
            </row>

            <row>
              <entry><literal>int max(int n, int m)</literal></entry>

              <entry>Largest of two integers</entry>
            </row>

            <row>
              <entry><literal>int min(int n, int m)</literal></entry>

              <entry>Smallest of two integers</entry>
            </row>

            <row>
              <entry><literal>real toReal(int n)</literal></entry>

              <entry>Convert an integer value to a real value</entry>
            </row>

            <row>
              <entry><literal>str toString(int n)</literal></entry>

              <entry>Convert an integer value to a string</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-IO">
      <title>IO</title>

      <para><table>
          <title>IO Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>void println(value V...)</literal></entry>

                <entry>Print a list of values on the output stream</entry>
              </row>

              <row>
                <entry><literal>bool print(value V...)</literal></entry>

                <entry>Print a list of values on the output stream and return
                true (used for debugging).</entry>
              </row>

              <row>
                <entry><literal>void rawPrintln(value V...)</literal></entry>

                <entry>Print a list of values on the output stream, but do not
                convert parse trees or remove quotes from strings (used for
                debugging)</entry>
              </row>

              <row>
                <entry><literal>list[str] readFile(str filename) throws
                NoSuchFileError(str msg), IO(str msg)</literal></entry>

                <entry>Read a named file as list of strings</entry>
              </row>

              <row>
                <entry><literal>str readFile(loc file) throws
                UnsupportedScheme(loc file), PathNotFound(loc file),
                IOError(str msg)</literal></entry>

                <entry>Read the contents of a file location as single
                string</entry>
              </row>

              <row>
                <entry><literal>list[str] readFileLines(loc file) throws
                UnsupportedScheme(loc file), PathNotFound(loc file),
                IOError(str msg)</literal></entry>

                <entry>Read the contents of a file location as a list of
                lines</entry>
              </row>

              <row>
                <entry><literal>void writeFile(loc file, value V...) throws
                UnsupportedScheme(loc file), PathNotFound(loc file),
                IOError(str msg)</literal></entry>

                <entry>Write a textual representation of some values to a
                file</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>Resources (Eclipse only)</title>

      <para>The Resources library provides direct access to Eclipse projects
      and the resources they contain. A Resource is the Rascal representation
      of an Eclipse project, or a folder or a file in an Eclipse project. In
      combination with the IO library module, users of the Resources library
      gain access to the contents of any file that is in an Eclipse
      project.</para>

      <programlisting>data Resource = root(set[Resource] projects) 
              | project(loc id, set[Resource] contents)
              | folder(loc id, set[Resource] contents)
              | file(loc id);</programlisting>

      <para>Resource is a recursive data-type, where recursion indicates
      "containment". I.e. a folder contains many other resources, a project
      also contains other resources. The root of an Eclipse workspace also
      contains other resources, in particular "projects".</para>

      <para>Each Resource, but the root, has an 'id' field that explains the
      exact location of the resource. Examples of Eclipse Resource locations
      are:</para>

      <programlisting>|project://myProject| // a location that points to a project in the Eclipse workspace named "myProject"
|project://myProject/src/Main.java| // a location that points to a file named Main.java in the src folder of the myProject project in the workspace|
|project://myProject/src/Main.java|(0,10,1,0,1,10) // a location that points to a part of the previous file, namely the first 10 characters on the first line.</programlisting>

      <para>Using the IO library, one can easily read the contents of a such
      an Eclipse project location:</para>

      <programlisting>import IO;
str contents = readFile(|project://myProject/src/Main.java|);</programlisting>

      <para>Other library functions in the Resource library provide more
      information about resources:<table>
          <title>Resources Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>Resource root()</literal></entry>

                <entry>Retrieve a full hierarchical representation of all
                resources in the Eclipse workspace</entry>
              </row>

              <row>
                <entry>set[loc] projects()</entry>

                <entry>Convenience function to retrieve a set of project
                locations of the Eclipse workspace</entry>
              </row>

              <row>
                <entry>set[loc] references(loc project);</entry>

                <entry>Find out which other projects this project references
                (depends on)</entry>
              </row>

              <row>
                <entry>set[loc] dependencies(loc project);</entry>

                <entry>Computes referenced projects transitively</entry>
              </row>

              <row>
                <entry>public Resource getProject(loc project);</entry>

                <entry>Retrieves the hierarchical representation of a single
                named project</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-JDT">
      <title>JDT (Eclipse only)</title>

      <para>Detailed information can be extracted from Java projects in the
      current Eclipse workspace. The JDT library module depends heavily on the
      Resources library module.</para>

      <para>The access to facts about Java files proceeds in two steps:</para>

      <itemizedlist>
        <listitem>
          <para>First all facts are extracted from given projects or files.
          The result is a <literal>Resource</literal> that is annotated with
          all kinds of interesting information about that specific Resource,
          and usually also about Resources that are contained inside that
          resource. The project/file annotation declarations are shown
          below.</para>
        </listitem>

        <listitem>
          <para>Next, specific facts about the Java source code can be
          retrieved fromthe annotations.. These annotations are shown in <xref
          linkend="table.JDT-fact-retrieval-functions" />. They all represent
          values of type <literal>BindingRel</literal> or
          <literal>EntityRel</literal> that are explained below.</para>
        </listitem>
      </itemizedlist>

      <para>The Java constructs that may occur in extracted facts are
      represented by the datatype Entity that is defined in the library module
      <literal>Java</literal> (not further described here). An "Entity"
      represents a fully qualified identifier pointing to a very specific part
      of a Java source code file. Entity is therefore a nested data-type,
      defined as follows:</para>

      <para><programlisting>data Entity = entity(list[Id] id);

data Id = package(str name)
        | class(str name)
        | class(str name, list[Entity] params)
        | interface(str name)
        | interface(str name, list[Entity] params)
        | anonymousClass(int nr)
        | enum(str name)
        
        | method(str name, list[Entity] params, Entity returnType)
        | constructor(list[Entity] params)
        | initializer
        | initializer(int nr)

        | field(str name)
        | parameter(str name)
        | variable(str name)
        | enumConstant(str name)
        
        | primitive(PrimitiveType type)
        | array(Entity elementType)
        
        | typeParameter(str name)
        | wildcard
        | wildcard(Bound bound)
        ;

data PrimitiveType = 
          byte
        | short
        | \int
        | long
        | float
        | double
        | char
        | boolean
        | \void
        | null
        ;

data Bound = 
          extends(Entity type)
        | super(Entity type)
        ;
</programlisting><note>
          <para>Observe how the Rascal keywords <literal>int</literal> and
          <literal>void</literal> are used to construct symbols in the above
          data definition by escaping them as <literal>\int</literal> and
          <literal>\void</literal>.</para>
        </note><programlisting>public alias BindingRel = rel[loc, Entity];                        // maps locations to qualified names in the form of Entities
public alias EntityRel = rel[Entity, Entity];                      // a short-hand for any relation between two Entities
public alias ModifierRel = rel[Entity entity, Modifier modifier];  // a short-hand for mappings from Entities to their declared Modifiers</programlisting></para>

      <para>A BindingRel is thus always used to map a source code location to
      a fully qualified Entity label of that part of the source code.
      EntityRel is simply a short hand for any kind of relation between
      entities.</para>

      <para>The following annotations declare the kind of information that the
      JDT library module provides after retrieving it from an Eclipse Java
      project:<programlisting>anno BindingRel Resource@types;        // contains all type declarations
anno BindingRel Resource@methods;      // contains all method declarations
anno BindingRel Resource@constructors; // contains all constructor declarations
anno BindingRel Resource@fields;       // contains all field declarations
anno BindingRel Resource@variables;    // contains all local variable and method parameter declarations
anno BindingRel Resource@packages;     // contains all package declarations

anno ModifierRel Resource@modifiers;   // maps Entities to the modifiers that have {been declared for it

anno EntityRel  Resource@implements;   // defines which types implement which interfaces
anno EntityRel  Resource@extends;      // defines which classes extends which other classes
anno EntitySet  Resource@declaredTopTypes; // defines which top-level classes are declared
anno EntityRel  Resource@declaredSubTypes; // defines which inner classes are declared
anno EntityRel  Resource@declaredMethods;  // defines which class defines which methods
anno EntityRel  Resource@declaredFields;   // defines which class defines which fields
anno EntityRel  Resource@calls;            // defines which methods call which other methods, and which class initialization code calls which methods</programlisting>To
      get access to all this information, please use the following
      functions:</para>

      <para><table xml:id="table.JDT-project-functions">
          <title>JDT Project/File Extraction Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>Resource extractClass(loc
                javaFile)</literal></entry>

                <entry>Import JDT facts from file </entry>
              </row>

              <row>
                <entry><literal>Resource extractProject(loc
                project)</literal></entry>

                <entry>Import JDT facts from a project </entry>
              </row>

              <row>
                <entry><literal>FactMap extractFactsTransitive(loc
                project)</literal></entry>

                <entry>Extracts facts from a project and all projects it
                depends on</entry>
              </row>

              <row>
                <entry><literal>tuple[rel[&amp;T1, &amp;T2] found,
                rel[JDTlocation, &amp;T2] notfound]
                matchLocations(rel[&amp;T1, loc] RSClocs, rel[JDTlocation,
                &amp;T2] JDTlocs)</literal></entry>

                <entry>Compose two relations by matching JDT locations with
                Rascal locations and return a tuple with the composition
                result and the locations that could not be matched. The source
                code locations of the JDT AST nodes might not always be the
                same as the ones in your own parse tree. This function picks
                the 'best fitting' user provided locations for JDT locations
                that don't have a direct match. It works correctly for the
                Java 1.4 grammar in the sdf-library, but other grammars might
                need a specific implementation.</entry>
              </row>

              <row>
                <entry><literal>Resource unionFacts(Resource m1, Resource
                m2)</literal></entry>

                <entry>Take all facts annotated on m1 and m2, merge them and
                return m1 annotated with the unified results</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>This is the implementation of <literal>extractFacts(set[str]
      projects)</literal>, showing how to use the unionFacts() function
      :</para>

      <para>Here is an example function that extracts the sub-type relation
      from a given project:<programlisting>EntityRel getSubTypeInformation(loc project){
  fm = extractProject(project);
  return fm@extends + fm@implements + {class("Object") x top(fm@extends + fm@implements);
}</programlisting></para>

      <para>The following example shows how to link the JDT type bindings to
      your own parse tree nodes. Suppose you have a relation
      <literal>nodeLocations</literal> that links your parse tree nodes to
      their location, you can get the type information of each node (if any)
      as follows:<programlisting>Resource fm = extractProject(myProject);
BindingRel jdtTypeBindings = fm@types;

rel[node, Entity] myTypeBindings;
BindingRel unmatchedBindings;
&lt;myTypeBindings, unmatchedBindings&gt; = matchLocations(nodeLocations, jdtTypeBindings);</programlisting></para>
    </section>

    <section xml:id="section.lib-LabelledGraph">
      <title>Labelled Graph</title>

      <para>The labelled graph datatype is a special form of binary relation
      with labelled edges and is defined as follows:</para>

      <para><programlisting>alias lgraph[&amp;T,&amp;L] = rel[&amp;T from, &amp;L label, &amp;T to];</programlisting></para>

      <table>
        <title>Labelled Graph Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="4*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>set[&amp;T] bottom(lgraph[&amp;T]
              G)</literal></entry>

              <entry>Bottom nodes of a labelled graph</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] predecessors(graph[&amp;T], &amp;T
              From)</literal></entry>

              <entry>Direct predecessors of node From</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reach(lgraph[&amp;T] G, set[&amp;T]
              Start)</literal></entry>

              <entry>Reachability from set of start nodes.</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reachR(lgraph[&amp;T] G, set[&amp;T]
              Start, set[&amp;T] Restr)</literal></entry>

              <entry>Reachability from set of start nodes with restriction to
              certain nodes.</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] reachX(lgraph[&amp;T] G, set[&amp;T]
              Start, set[&amp;T] Excl)</literal></entry>

              <entry>Reachability from set of start nodes with exclusion of
              certain nodes</entry>
            </row>

            <row>
              <entry><literal>list[&amp;T] shortestPathPair(lgraph[&amp;T] G,
              &amp;T From, &amp;T To)</literal></entry>

              <entry>Shortest path between pair of nodes</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] successors(graph[&amp;T], &amp;T
              From)</literal></entry>

              <entry>Direct successors of node From</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] top(lgraph[&amp;T]
              G)</literal></entry>

              <entry>Top nodes of a labelled graph</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><warning>
          <para>shortestPathPair not yet implemented for lgraph.</para>
        </warning></para>
    </section>

    <section xml:id="section.lib-List">
      <title>List</title>

      <para><table>
          <title>List Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>List</replaceable><subscript>1</subscript>
                <literal>==</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>Yields <literal>true</literal> if both arguments have
                the same elements in the same order</entry>
              </row>

              <row>
                <entry><replaceable>List</replaceable><subscript>1</subscript>
                <literal>!=</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>Yields <literal>true</literal> if both arguments have
                different elements</entry>
              </row>

              <row>
                <entry><replaceable>List</replaceable><subscript>1</subscript>
                <literal>&lt;=</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>Yields <literal>true</literal> if both lists are equal
                or <replaceable>List</replaceable><subscript>1</subscript> is
                a sublist of
                <replaceable>List</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>List</replaceable><subscript>1</subscript>
                <literal>&lt;</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>Yields <literal>true</literal> if
                <replaceable>List</replaceable><subscript>1</subscript> is a
                sublist of
                <replaceable>List</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>List</replaceable><subscript>1</subscript>
                <literal>&gt;=</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>Yields <literal>true</literal> if both lists are equal
                or <replaceable>List</replaceable><subscript>2</subscript> is
                a sublist of
                <replaceable>List</replaceable><subscript>1</subscript></entry>
              </row>

              <row>
                <entry><replaceable>List</replaceable><subscript>1</subscript>
                <literal>&gt;</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>Yields <literal>true</literal> if
                <replaceable>List</replaceable><subscript>2</subscript> is a
                sublist of
                <replaceable>List</replaceable><subscript>1</subscript></entry>
              </row>

              <row>
                <entry><replaceable>List</replaceable><subscript>1</subscript>
                <literal>+</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>Concatenation of
                <replaceable>List</replaceable><subscript>1</subscript> and
                <replaceable>List</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>List</replaceable><subscript>1</subscript>
                <literal>-</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>List consisting of all elements in
                <replaceable>List</replaceable><subscript>1</subscript> that
                do not occur in
                <replaceable>List</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>List</replaceable><subscript>1</subscript>
                <literal>*</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>List consisting of tuples with first element from
                <replaceable>List</replaceable><subscript>1</subscript> and
                second element from
                <replaceable>List</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Elm</replaceable> <literal>in</literal>
                <replaceable>List</replaceable></entry>

                <entry>Yields <literal>true</literal> if
                <replaceable>Elm</replaceable> occurs as element in
                <replaceable>List</replaceable></entry>
              </row>

              <row>
                <entry><replaceable>Elm</replaceable> <literal>notin</literal>
                <replaceable>List</replaceable></entry>

                <entry>Yields <literal>true</literal> if
                <replaceable>Elm</replaceable> does not occur as element in
                <replaceable>List</replaceable></entry>
              </row>

              <row>
                <entry><replaceable>Bool</replaceable> <literal>?</literal>
                <replaceable>List</replaceable><subscript>1</subscript>
                <literal>:</literal>
                <replaceable>List</replaceable><subscript>2</subscript></entry>

                <entry>If <replaceable>bool</replaceable> is true then
                <replaceable>List</replaceable><subscript>1</subscript> else
                <replaceable>List</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>List</replaceable><literal> [</literal>
                <replaceable>int</replaceable> <literal>]</literal></entry>

                <entry>Element at position <replaceable>int</replaceable> in
                <replaceable>List</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </table><table>
          <title>List Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>&amp;T average(list[&amp;T] lst, &amp;T
                zero)</literal></entry>

                <entry>Average of elements of a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] delete(list[&amp;T] lst, int n)
                throws IndexOutOfBounds(int index)</literal></entry>

                <entry>Delete nth element from list</entry>
              </row>

              <row>
                <entry><literal>set[int] domain(list[&amp;T]
                lst)</literal></entry>

                <entry>Set of all legal index values for a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T head(list[&amp;T] lst) throws
                EmptyList</literal></entry>

                <entry>Get the first element of a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] head(list[&amp;T] lst, int n)
                throws IndexOutOfBounds(int index)</literal></entry>

                <entry>Get the first n elements of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T getOneFrom(list[&amp;T] lst) throws
                EmptyList</literal></entry>

                <entry>Get an arbitrary element from a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] insertAt(list[&amp;T] lst, int n,
                &amp;T elm) throws IndexOutOfBounds(int
                index)</literal></entry>

                <entry>Add an element at a specific position in a list</entry>
              </row>

              <row>
                <entry><literal>bool isEmpty(list[&amp;T]
                lst)</literal></entry>

                <entry>Is list empty?</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] mapper(list[&amp;T] lst, &amp;T
                (&amp;T) fn)</literal></entry>

                <entry>Apply a function to each element of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T max(list[&amp;T] lst)</literal></entry>

                <entry>Largest element of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T min(list[&amp;T] lst)</literal></entry>

                <entry>Smallest element of a list</entry>
              </row>

              <row>
                <entry><literal>set[list[&amp;T]] permutations(list[&amp;T]
                lst)</literal></entry>

                <entry>All permutations of a list</entry>
              </row>

              <row>
                <entry><literal>&amp;T reducer(list[&amp;T] lst, &amp;T
                (&amp;T, &amp;T) fn, &amp;T unit)</literal></entry>

                <entry>Apply function <literal>fn</literal> to successive
                elements of a list, with given unit element.</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] reverse(list[&amp;T]
                lst)</literal></entry>

                <entry>Elements of a list in reverse order</entry>
              </row>

              <row>
                <entry><literal>int size(list[&amp;T] lst)</literal></entry>

                <entry>Number of elements in a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] slice(list[&amp;T] lst, int
                start, int len) throws IndexOutOfBounds(int
                index)</literal></entry>

                <entry>Sublist from start of length len</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] sort(list[&amp;T]
                lst)</literal></entry>

                <entry>Sort the elements of a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] tail(list[&amp;T] lst) throws
                EmptyList</literal></entry>

                <entry>All but the first element of a list</entry>
              </row>

              <row>
                <entry><literal>list[&amp;T] tail(list[&amp;T] lst, int len)
                throws IndexOutOfBounds(in index)</literal></entry>

                <entry>Last n elements of a list</entry>
              </row>

              <row>
                <entry><literal>tuple[&amp;T, list[&amp;T]]
                takeOneFrom(list[&amp;T] lst) throws
                EmptyList</literal></entry>

                <entry>Remove an arbitrary element from a list, returns the
                element and the modified list</entry>
              </row>

              <row>
                <entry><literal>map[&amp;A,set[&amp;B]]
                toMap(list[tuple[&amp;A, &amp;B]] lst) throws
                DuplicateKey</literal></entry>

                <entry>Convert a list of tuples to a map in which the first
                element of each tuple is associated with the set of second
                elements from all tuples with the same first element Keys
                should be unique.</entry>
              </row>

              <row>
                <entry><literal>map[&amp;A,&amp;B]
                toMapUnique(list[tuple[&amp;A, &amp;B]] lst) throws
                DuplicateKey</literal></entry>

                <entry>Convert a list of tuples to a map; result must be a
                map</entry>
              </row>

              <row>
                <entry><literal>set[&amp;T] toSet(list[&amp;T]
                lst)</literal></entry>

                <entry>Convert a list to a set</entry>
              </row>

              <row>
                <entry><literal>str toString(list[&amp;T]
                lst)</literal></entry>

                <entry>Convert a list to a string</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Location">
      <title>Location</title>

      <table>
        <title>Operations on Locations</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>Loc</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>Loc</replaceable><subscript>2</subscript></entry>

              <entry>Yield <literal>true</literal> if both arguments are
              identical and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Loc</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>Loc</replaceable><subscript>2</subscript></entry>

              <entry>Yield <literal>true</literal> if both arguments are not
              identical and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Loc</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>Loc</replaceable><subscript>2</subscript></entry>

              <entry>Yield <literal>true</literal> if
              <replaceable>Loc</replaceable><subscript>1</subscript> is
              textually contained in or equal to
              <replaceable>Loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Loc</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>Loc</replaceable><subscript>2</subscript></entry>

              <entry>Yield <literal>true</literal> if
              <replaceable>Loc</replaceable><subscript>1</subscript> is
              strictly textually contained in
              <replaceable>Loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Loc</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>Loc</replaceable><subscript>2</subscript></entry>

              <entry>Yield <literal>true</literal> if
              <replaceable>Loc</replaceable><subscript>1</subscript> textually
              encloses or is equal to
              <replaceable>Loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Loc</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>Loc</replaceable><subscript>2</subscript></entry>

              <entry>Yield <literal>true</literal> if
              <replaceable>Loc</replaceable><subscript>1</subscript> textually
              encloses <replaceable>Loc</replaceable><subscript>2</subscript>
              and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Loc</replaceable> <literal>.</literal>
              <replaceable>Field</replaceable></entry>

              <entry>Retrieve one of the fields of location value
              <replaceable>Loc</replaceable></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The field names for locations are:</para>

      <itemizedlist>
        <listitem>
          <para><literal>uri</literal>: the URI of the location. Also
          subfields of the URI can be accessed:</para>

          <itemizedlist>
            <listitem>
              <para><literal>scheme</literal>: the scheme (or protocol) like
              <literal>http</literal> or <literal>file</literal>. Also
              supported is <literal>cwd:</literal> for current working
              directory (the directory from which Rascal was started).</para>
            </listitem>

            <listitem>
              <para><literal>authority</literal>: the domain where the data
              are located.</para>
            </listitem>

            <listitem>
              <para><literal>host</literal>: the host where the URI is hosted
              (part of auhtority).</para>
            </listitem>

            <listitem>
              <para><literal>port</literal>: port on host (part
              ofauthority).</para>
            </listitem>

            <listitem>
              <para><literal>path</literal>: path name of file on host.</para>
            </listitem>

            <listitem>
              <para><literal>extension</literal>: file name extension.</para>
            </listitem>

            <listitem>
              <para><literal>query</literal>: query data</para>
            </listitem>

            <listitem>
              <para><literal>fragment</literal>: the fragment name following
              the path name and query data.</para>
            </listitem>

            <listitem>
              <para><literal>user</literal>: user info (only present in
              schemes like mailto).</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><literal>offset</literal>: start of text area.</para>
        </listitem>

        <listitem>
          <para><literal>length</literal>: length of text area</para>
        </listitem>

        <listitem>
          <para><literal>begin.line</literal>,
          <literal>begin.column</literal>: begin line and column of text
          area.</para>
        </listitem>

        <listitem>
          <para><literal>end.line</literal>, <literal>end.column</literal> end
          line and column of text area.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.lib-Map">
      <title>Map</title>

      <para><table>
          <title>Map Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>Map</replaceable><subscript>1</subscript>
                <literal>==</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>Yield <literal>true</literal> if both arguments consist
                of the same pairs</entry>
              </row>

              <row>
                <entry><replaceable>Map</replaceable><subscript>1</subscript>
                <literal>!=</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>Yield <literal>true</literal> if both arguments have
                different pairs</entry>
              </row>

              <row>
                <entry><replaceable>Map</replaceable><subscript>1</subscript>
                <literal>&lt;=</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>Yield <literal>true</literal> if all pairs in
                <replaceable>Map</replaceable><subscript>1</subscript> occur
                in <replaceable>Map</replaceable><subscript>2</subscript> or
                <replaceable>Map</replaceable><subscript>1</subscript> and
                <replaceable>Map</replaceable><subscript>2</subscript> are
                equal</entry>
              </row>

              <row>
                <entry><replaceable>Map</replaceable><subscript>1</subscript>
                <literal>&lt;</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>Yield <literal>true</literal> if all pairs in
                <replaceable>Map</replaceable><subscript>1</subscript> occur
                in <replaceable>Map</replaceable><subscript>2</subscript> but
                <replaceable>Map</replaceable><subscript>1</subscript> and
                <replaceable>Map</replaceable><subscript>2</subscript> are not
                equal</entry>
              </row>

              <row>
                <entry><replaceable>Map</replaceable><subscript>1</subscript>
                <literal>&gt;=</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>Yield <literal>true</literal> if all pairs in
                <replaceable>Map</replaceable><subscript>2</subscript> occur
                in <replaceable>Map</replaceable><subscript>1</subscript> or
                <replaceable>Map</replaceable><subscript>1</subscript> and
                <replaceable>Map</replaceable><subscript>2</subscript> are
                equal</entry>
              </row>

              <row>
                <entry><replaceable>Map</replaceable><subscript>1</subscript>
                <literal>&gt;</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>Yield <literal>true</literal> if all pairs in
                <replaceable>Map</replaceable><subscript>2</subscript> occur
                in <replaceable>Map</replaceable><subscript>1</subscript>but
                <replaceable>Map</replaceable><subscript>1</subscript> and
                <replaceable>Map</replaceable><subscript>2</subscript> are not
                equal</entry>
              </row>

              <row>
                <entry><replaceable>Map</replaceable><subscript>1</subscript>
                <literal>+</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>Union of
                <replaceable>Map</replaceable><subscript>1</subscript> and
                <replaceable>Map</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Map</replaceable><subscript>1</subscript>
                <literal>-</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>Difference of
                <replaceable>Map</replaceable><subscript>1</subscript> and
                <replaceable>Map</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Key</replaceable> <literal>in</literal>
                <replaceable>Map</replaceable></entry>

                <entry>Yield <literal>true</literal> if
                <replaceable>Key</replaceable> occurs in a key:value pair in
                <replaceable>Map</replaceable></entry>
              </row>

              <row>
                <entry><replaceable>Key</replaceable><subscript>1</subscript>
                <literal>notin</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>Yield <literal>true</literal> if
                <replaceable>Key</replaceable> does not occur in a key:value
                pair in map</entry>
              </row>

              <row>
                <entry><replaceable>Bool</replaceable> <literal>?</literal>
                <replaceable>Map</replaceable><subscript>1</subscript>
                <literal>:</literal>
                <replaceable>Map</replaceable><subscript>2</subscript></entry>

                <entry>If <replaceable>Bool</replaceable> is true then
                <replaceable>Map</replaceable><subscript>1</subscript> else
                <replaceable>Map</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Map</replaceable> <literal>[</literal>
                <replaceable>Key</replaceable> <literal>]</literal></entry>

                <entry>The value associated with
                <replaceable>Key</replaceable> in
                <replaceable>Map</replaceable> if that exists, undefined
                otherwise</entry>
              </row>
            </tbody>
          </tgroup>
        </table><table>
          <title>Map Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>set[&amp;K] domain(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>The domain (keys) of a map</entry>
              </row>

              <row>
                <entry><literal>map[&amp;K, &amp;V] domainR(map[&amp;K,
                &amp;V] M, set[&amp;K] S)</literal></entry>

                <entry>Restrict the map to elements with keys in S</entry>
              </row>

              <row>
                <entry><literal>map[&amp;K, &amp;V] domainX(map[&amp;K,
                &amp;V] M, set[&amp;K] S)</literal></entry>

                <entry>Restrict the map to elements with keys not in S</entry>
              </row>

              <row>
                <entry><literal>&amp;K getOneFrom(map[&amp;K, &amp;V] M)
                throws emptyMap</literal></entry>

                <entry>Arbitrary key of a map</entry>
              </row>

              <row>
                <entry><literal>map[&amp;V, set[&amp;K]] invert(map[&amp;K,
                &amp;V] M)</literal></entry>

                <entry>Inverted map in which each value in the old map is
                associated with a set of key values from the old map</entry>
              </row>

              <row>
                <entry><literal>map[&amp;V, &amp;K] invertUnique(map[&amp;K,
                &amp;V] M) throws MultipleKey</literal></entry>

                <entry>Map with key and value inverted; result should be a
                map</entry>
              </row>

              <row>
                <entry><literal>bool isEmpty(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>Is map empty?</entry>
              </row>

              <row>
                <entry><literal>map[&amp;K, &amp;V] mapper(map[&amp;K, &amp;V]
                M, &amp;K (&amp;K) F, &amp;V (&amp;V) G)</literal></entry>

                <entry>Apply two functions to each key/value pair in a
                map.</entry>
              </row>

              <row>
                <entry><literal>set[&amp;V] range(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>The range (values) of a map</entry>
              </row>

              <row>
                <entry><literal>map[&amp;K, &amp;V] rangeR(map[&amp;K, &amp;V]
                M, set[&amp;V] S)</literal></entry>

                <entry>Restrict the map to elements with value in S</entry>
              </row>

              <row>
                <entry><literal>map[&amp;K, &amp;V] rangeX(map[&amp;K, &amp;V]
                M, set[&amp;V] S)</literal></entry>

                <entry>Restrict the map to elements with value not in
                S</entry>
              </row>

              <row>
                <entry><literal>int size(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>Number of elements in a map.</entry>
              </row>

              <row>
                <entry><literal>list[tuple[&amp;K, &amp;V]] toList(map[&amp;K,
                &amp;V] M)</literal></entry>

                <entry>Convert a map to a list</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;K, &amp;V] toRel(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>Convert a map to a relation</entry>
              </row>

              <row>
                <entry><literal>str toString(map[&amp;K, &amp;V]
                M)</literal></entry>

                <entry>Convert a map to a string.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Node">
      <title>Node</title>

      <para><table>
          <title>Node Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>Node</replaceable><subscript>1</subscript>
                <literal>==</literal>
                <replaceable>Node</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments are
                identical</entry>
              </row>

              <row>
                <entry><replaceable>Node</replaceable><subscript>1</subscript>
                <literal>!=</literal>
                <replaceable>Node</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments are not
                identical</entry>
              </row>

              <row>
                <entry><replaceable>Node</replaceable><subscript>1</subscript>
                <literal>&lt;=</literal>
                <replaceable>Node</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>Node</replaceable><subscript>1</subscript>
                is less than or equal to
                <replaceable>Node</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Node</replaceable><subscript>1</subscript>
                <literal>&lt;</literal>
                <replaceable>Node</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>Node</replaceable><subscript>1</subscript>
                is less than
                <replaceable>Node</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Node</replaceable><subscript>1</subscript>
                <literal>&gt;=</literal>
                <replaceable>Node</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>Node</replaceable><subscript>2</subscript>
                is less than or equal to
                <replaceable>Node</replaceable><subscript>1</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Node</replaceable><subscript>1</subscript>
                <literal>&gt;</literal>
                <replaceable>Node</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>Node</replaceable><subscript>2</subscript>
                is less than
                <replaceable>Node</replaceable><subscript>1</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Bool</replaceable> <literal>?</literal>
                <replaceable>Node</replaceable><subscript>1</subscript>
                <literal>:</literal>
                <replaceable>Node</replaceable><subscript>2</subscript></entry>

                <entry>if <replaceable>Bool</replaceable> is true then
                <replaceable>Node</replaceable><subscript>1</subscript> else
                <replaceable>Node</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Node</replaceable> <literal>[</literal>
                <replaceable>Int</replaceable> <literal>]</literal></entry>

                <entry>child of <replaceable>Node</replaceable> at position
                <replaceable>Int</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </table>Comparison of nodes is defined by a lexicograpic ordering.
      Node <replaceable>N</replaceable> =
      <replaceable>F</replaceable>(<replaceable>N</replaceable><subscript>1</subscript>,
      ...,
      <replaceable>N</replaceable><replaceable><subscript>k</subscript></replaceable>)
      is less than node <replaceable>M</replaceable> =
      <replaceable>G</replaceable>(<replaceable>M</replaceable><subscript>1</subscript>,
      ...,
      <replaceable>M</replaceable><subscript><replaceable>l</replaceable></subscript>)
      when:</para>

      <itemizedlist>
        <listitem>
          <para><replaceable>N</replaceable> is not equal to
          <replaceable>M</replaceable>, and</para>
        </listitem>

        <listitem>
          <para><replaceable>F</replaceable> is lexicographically less than
          <replaceable>G</replaceable>, or F is equal to G and <replaceable>k
          </replaceable> &lt; <replaceable>l.</replaceable></para>
        </listitem>
      </itemizedlist>

      <para><table>
          <title>Node Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>int arity(node T)</literal></entry>

                <entry>Number of children of a node</entry>
              </row>

              <row>
                <entry><literal>map[str,value] getAnnotations(node
                x)</literal></entry>

                <entry>Retrieve the annnotations of a node value as a
                map</entry>
              </row>

              <row>
                <entry><literal>list[value] getChildren(node
                T)</literal></entry>

                <entry>The children of a node</entry>
              </row>

              <row>
                <entry><literal>str getName(node T)</literal></entry>

                <entry>The function name of a node</entry>
              </row>

              <row>
                <entry><literal>node makeNode(str N, value
                V...)</literal></entry>

                <entry>Create a node given its function name and
                arguments</entry>
              </row>

              <row>
                <entry><literal>&amp;T &lt;: node java setAnnotations(&amp;T
                &lt;: node x, map[str, value] annotations)</literal></entry>

                <entry>Set a map of annotations on a value.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-PriorityQueue">
      <title>PriorityQueue</title>

      <para>Priority queues maintain (value, priority) pairs in sorted order.
      They are implemented using a binomial heap, see <link
      xlink:href="http://en.wikipedia.org/wiki/Binomial_heap">http://en.wikipedia.org/wiki/Binomial_heap</link>.
      Priority queue are, for instance, used to implement shortest path
      algorithms.<table>
          <title>PriorityQueue Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>tuple[int, int, PriorityQueue]
                extractMinimum(PriorityQueue Q):</literal></entry>

                <entry>Find the (value, priority) pair with minimum priority
                and delete it</entry>
              </row>

              <row>
                <entry>int findMinimum(PriorityQueue Q)</entry>

                <entry>Find the minimum priority.</entry>
              </row>

              <row>
                <entry><literal>PriorityQueue insertElement(PriorityQueue Q,
                int priority, int val):</literal></entry>

                <entry>Insert a (value, priority) pair</entry>
              </row>

              <row>
                <entry><literal>bool isEmpty(PriorityQueue
                Q):</literal></entry>

                <entry>Is queue empty?</entry>
              </row>

              <row>
                <entry><literal>PriorityQueue
                priorityQueue():</literal></entry>

                <entry>Create an empty queue.</entry>
              </row>

              <row>
                <entry><literal>PriorityeQueue priorityQueue(int priority, int
                val):</literal></entry>

                <entry>Create queue with one (value, priority) pair.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Real">
      <title>Real</title>

      <para>Rascal reals are unbounded in size and precision.</para>

      <table>
        <title>Real Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are numerically
              equal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are numerically
              unequal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>Real</replaceable><subscript>1</subscript> is
              numerically less than or equal to
              <replaceable>Real</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>Real</replaceable><subscript>1</subscript> is
              numerically less than
              <replaceable>Real</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>Real</replaceable><subscript>1</subscript> is
              numerically greater than or equal than
              <replaceable>Real</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>Real</replaceable><subscript>1</subscript> is
              numerically greater than
              <replaceable>Real</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry>Sum of
              <replaceable>Real</replaceable><subscript>1</subscript> and
              <replaceable>Real</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>-</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry>Difference of
              <replaceable>Real</replaceable><subscript>1</subscript> and
              <replaceable>Real</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>*</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              multiplied by
              <replaceable>Real</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>/</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              divided by
              <replaceable>Real</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry>- <replaceable>Real</replaceable></entry>

              <entry>Negate sign of <replaceable>Real</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>Real</replaceable><subscript>1</subscript>
              <literal>%</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry>Remainder of dividing
              <replaceable>Real</replaceable><subscript>1</subscript> by
              <replaceable>Real</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable> <literal>?</literal>
              <replaceable>Real</replaceable><subscript>1</subscript>
              <literal>:</literal>
              <replaceable>Real</replaceable><subscript>2</subscript></entry>

              <entry>If <replaceable>Bool</replaceable> is true then
              <replaceable>Real</replaceable><subscript>1</subscript> else
              <replaceable>Real</replaceable><subscript>2</subscript></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Real Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="2*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>real arbReal()</literal></entry>

              <entry>Arbitrary real value in the interval [0.0,1.0).</entry>
            </row>

            <row>
              <entry><literal>real max(real n, real m)</literal></entry>

              <entry>Largest of two reals</entry>
            </row>

            <row>
              <entry><literal>real min(real n, real m)</literal></entry>

              <entry>Smallest of two reals</entry>
            </row>

            <row>
              <entry><literal>int toInt(real d)</literal></entry>

              <entry>Converts this real (implemented as BigDecimal) to an
              integer (implemented as BigInteger). This conversion is
              analogous to a narrowing primitive conversion from double to
              long as defined in the Java Language Specification: any
              fractional part of this BigDecimal will be discarded. Note that
              this conversion can lose information about the precision of the
              BigDecimal value.</entry>
            </row>

            <row>
              <entry><literal>str toString(real d)</literal></entry>

              <entry>Convert a real to a string.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-Relation">
      <title>Relation</title>

      <para>Relation are sets of tuples, therefore all set operators (see,
      <xref linkend="table.set-operators" />) apply to relations as
      well</para>

      <table>
        <title>Operations on Relations</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>Rel</replaceable><subscript>1</subscript>
              <literal>o</literal>
              <replaceable>Rel</replaceable><subscript>2</subscript></entry>

              <entry>Relation resulting from the composition of the two
              arguments</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>x</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry>Relation resulting from the Cartesian product of the two
              arguments</entry>
            </row>

            <row>
              <entry><replaceable>Rel</replaceable>
              <literal>+</literal></entry>

              <entry>Relation resulting from the transitive closure of
              <replaceable>Rel</replaceable>. <remark>Explain type
              constraints</remark>.</entry>
            </row>

            <row>
              <entry><replaceable>Rel</replaceable>
              <literal>*</literal></entry>

              <entry>Relation resulting from the reflexive transitive closure
              of <replaceable>Rel</replaceable></entry>
            </row>

            <row>
              <entry><literal><replaceable>Rel</replaceable>
              [<replaceable>Exp</replaceable><subscript>1</subscript>,
              <replaceable>Exp</replaceable><subscript>2</subscript>, ...
              ]</literal></entry>

              <entry>Relation resulting from subscription of
              <replaceable>Rel</replaceable> with the index values of
              <replaceable>Exp</replaceable><subscript>1</subscript>,
              <replaceable>Exp</replaceable><subscript>2</subscript>, .... The
              result is a relation with all tuples that have these index
              values as first elements with the index values removed from the
              tuple. If the resulting tuple has only a single element, a set
              is returned instead of a relation. A wildcard
              <literal>_</literal> as index value matches all possible values
              at that index position.</entry>
            </row>

            <row>
              <entry><replaceable>Rel</replaceable> <literal>[</literal>
              <replaceable>Set</replaceable> <literal>]</literal></entry>

              <entry>Relation resulting from subscription of
              <replaceable>Rel</replaceable> with all elements of
              <replaceable>Set</replaceable>.</entry>
            </row>

            <row>
              <entry><replaceable>Rel</replaceable> <literal>&lt;</literal>
              <replaceable>Index</replaceable><subscript>1</subscript><literal>,</literal>
              <replaceable>Index</replaceable><subscript>2</subscript>, ...
              <literal>&gt;</literal></entry>

              <entry>Relation resulting from restricting
              <replaceable>Rel</replaceable> to the columns described by
              <replaceable>Index</replaceable><subscript>1</subscript><literal>,</literal>
              <replaceable>Index</replaceable><subscript>2</subscript>,
              ...</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Examples:</para>

      <para><screen><literal>rascal&gt; </literal><userinput><literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,15&gt;} o {&lt;10,100&gt;, &lt;20,200&gt;}</literal>;</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;1,100&gt;, &lt;2,200&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput><literal>{1, 2, 3} x {9}</literal>;</userinput>
<computeroutput>rel[int,int] :  <literal>{&lt;1, 9&gt;, &lt;2, 9&gt;, &lt;3, 9&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;}+;</userinput>
<computeroutput>rel[int,int]: {&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, &lt;1, 3&gt;, &lt;2, 4&gt;, &lt;1, 4&gt;}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;}*;</userinput>
<computeroutput>rel[int,int]: {&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, &lt;1, 3&gt;, &lt;2, 4&gt;, &lt;1, 4&gt;, 
               &lt;1, 1&gt;, &lt;2, 2&gt;, &lt;3, 3&gt;, &lt;4, 4&gt;}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>R = <literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;1,11&gt;, &lt;3,30&gt;, &lt;2,21&gt;}</literal>;</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;1,11&gt;, &lt;3,30&gt;, &lt;2,21&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>R[1];</userinput>
<computeroutput>set[int] : <literal>{10, 11}</literal></computeroutput>

<prompt>rascal&gt; </prompt><userinput><literal>R[{1}]</literal>;</userinput>
<computeroutput>set[int] : {10, 11}</computeroutput>

<prompt>rascal&gt; </prompt><userinput><literal>R[{1, 2}]</literal>;</userinput>
<computeroutput>set[int] : {10, 11, 20, 21}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>RR = {&lt;1,10,100&gt;,&lt;1,11,101&gt;,&lt;2,20,200&gt;,&lt;2,22,202&gt;,
              &lt;3,30,300&gt;};</userinput>
<computeroutput>rel[int,int,int]:{&lt;1,10,100&gt;,&lt;1,11,101&gt;,&lt;2,20,200&gt;,&lt;2,22,202&gt;,
                  &lt;3,30,300&gt;}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>RR[1];</userinput>
<computeroutput>rel[int,int]: {&lt;10,100&gt;,&lt;11,101&gt;};</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>RR[1,_];</userinput>
<computeroutput>set[int]: {100,101}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>RR&lt;2,0,1&gt;;</userinput>
<computeroutput>rel[int,int,int]: {&lt;101,1,11&gt;,&lt;200,2,20&gt;,&lt;100,1,10&gt;,
                   &lt;300,3,30&gt;,&lt;202,2,22&gt;} ;</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>RR&lt;2.0,1&gt;[100];</userinput>
<computeroutput>rel[int,int]: {&lt;1,10&gt;}</computeroutput></screen><table>
          <title>Relation Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>set[&amp;T] carrier (rel[&amp;T,&amp;T]
                R)</literal></entry>

                <entry>All elements in any tuple in a relation</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T,&amp;T] carrierR
                (rel[&amp;T,&amp;T] R, set[&amp;T] S)</literal></entry>

                <entry>Relation restricted to tuples with elements in a set
                S</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T,&amp;T] carrierX
                (rel[&amp;T,&amp;T] R, set[&amp;T] S)</literal></entry>

                <entry>Relation excluded tuples with some element in S</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T0, &amp;T1] complement(rel[&amp;T0,
                &amp;T1] R)</literal></entry>

                <entry>Complement of relation</entry>
              </row>

              <row>
                <entry><literal>set[&amp;T0] domain (rel[&amp;T0,&amp;T1]
                R)</literal></entry>

                <entry>First element of each tuple in binary relation</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T0,&amp;T1] domainR
                (rel[&amp;T0,&amp;T1] R, set[&amp;T0] S)</literal></entry>

                <entry>Restriction of a relation to tuples with first element
                in S}</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T0,&amp;T1] domainX
                (rel[&amp;T0,&amp;T1] R, set[&amp;T0] S)</literal></entry>

                <entry>Relation excluded tuples with first element in
                S</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T,&amp;T] ident(set[&amp;T]
                S)</literal></entry>

                <entry>The identity relation for set S.</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T1, &amp;T0] invert (rel[&amp;T0,
                &amp;T1] R)</literal></entry>

                <entry>Inverse the tuples in a relation</entry>
              </row>

              <row>
                <entry><literal>set[&amp;T1] range (rel[&amp;T0,&amp;T1]
                R)</literal></entry>

                <entry>The range of a binary relation</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T0,&amp;T1] rangeR
                (rel[&amp;T0,&amp;T1] R, set[&amp;T2] S)</literal></entry>

                <entry>Restriction of a binary relation to tuples with second
                element in set S</entry>
              </row>

              <row>
                <entry><literal>rel[&amp;T0,&amp;T1] rangeX
                (rel[&amp;T0,&amp;T1] R, set[&amp;T2] S)</literal></entry>

                <entry>Restriction of a binary relation to tuples with second
                element not in set S</entry>
              </row>
            </tbody>
          </tgroup>
        </table>Examples:<screen><literal>rascal&gt; </literal><userinput><literal>id({1,2,3})</literal>;</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;1,1&gt;, &lt;2,2&gt;, &lt;3,3&gt;}</literal></computeroutput>

<literal>rascal&gt; </literal><userinput><literal>id({"mon", "tue", "wed"})</literal>;</userinput>
<computeroutput>rel[str,str] : <literal>{&lt;"mon","mon"&gt;, &lt;"tue","tue"&gt;, &lt;"wed","wed"&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>invert({&lt;1,10&gt;, &lt;2,20&gt;});</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;10,1&gt;,&lt;20,2&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>compl({&lt;1,10&gt;});</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;1, 1&gt;, &lt;10, 1&gt;, &lt;10, 10&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>domain({&lt;1,10&gt;, &lt;2,20&gt;});</userinput>
<computeroutput>set[int] : <literal>{1, 2}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>domain({&lt;"mon", 1&gt;, &lt;"tue", 2&gt;});</userinput>
<computeroutput>set[str] : <literal>{"mon", "tue"}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>range({&lt;1,10&gt;, &lt;2,20&gt;});</userinput>
<computeroutput>set[int] : <literal>{10, 20}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>range({&lt;"mon", 1&gt;, &lt;"tue", 2&gt;});</userinput>
<computeroutput>set[int] : <literal>{1, 2}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>carrier({&lt;1,10&gt;, &lt;2,20&gt;});</userinput>
<computeroutput>set[int] : <literal>{1, 10, 2, 20}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>domainR({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {3, 1});</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;1,10&gt;, &lt;3,30&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rangeR({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {30, 10});</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;1,10&gt;, &lt;3,30&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>carrierR({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {10, 1, 20});</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;1,10&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>domainX({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {3, 1});</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;2, 20&gt;}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rangeX({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {30, 10});
</userinput><computeroutput>rel[int,int] : {&lt;2, 20&gt;}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>carrierX({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}, {10, 1, 20});</userinput>
<computeroutput>rel[int,int] : <literal>{&lt;3,30&gt;}</literal></computeroutput></screen></para>
    </section>

    <section xml:id="section.lib-RSF">
      <title>RSF</title>

      <para>Rigi Standard Format (RSF) is a textual format to represent binary
      relations and is used to exchange relaional facts between different
      tools. The following functions allows reading in RSF data.</para>

      <table>
        <title>RSF Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="3*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>map[str, rel[str,str]] readRSF(str nameRSFFile)
              throws IO(str msg)</literal></entry>

              <entry>Read a file in Rigi Standard Format (RSF).</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-Resource">
      <title>Resource (Eclipse only)</title>

      <para><programlisting>data Resource = root(set[Resource] projects) 
              | project(str name, set[Resource] contents) 
              | folder(str name, set[Resource] contents) 
              | file(str name, str extension); </programlisting></para>

      <para><table>
          <title>Resource Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>set[loc] files(str project)</literal></entry>

                <entry>The files contained in a project</entry>
              </row>

              <row>
                <entry><literal>loc location(str project)</literal></entry>

                <entry>Source location of given project</entry>
              </row>

              <row>
                <entry><literal>set[str] projects()</literal></entry>

                <entry>The projects in the Eclipse workspace</entry>
              </row>

              <row>
                <entry><literal>set[str] references(str
                project)</literal></entry>

                <entry>The project references of a given project</entry>
              </row>

              <row>
                <entry><literal>Resource root() </literal></entry>

                <entry>The root of the Eclipse workspace</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-Set">
      <title>Set</title>

      <table xml:id="table.set-operators">
        <title>Set Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are equal sets
              and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are unequal
              sets and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>Set</replaceable><subscript>1</subscript> is a
              subset of <replaceable>Set</replaceable><subscript>2</subscript>
              and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>Set</replaceable><subscript>1</subscript> is a
              strict subset of
              <replaceable>Set</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>Set</replaceable><subscript>1</subscript> is a
              superset of
              <replaceable>Set</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if
              <replaceable>Set</replaceable><subscript>1</subscript> is a
              strict superset of
              <replaceable>Set</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry>Set resulting from the union of the two arguments</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>-</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry>Set resulting from the difference of the two
              arguments</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>*</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry>Relation resulting from the product of the two arguments.
              It contains a tuple for each combination of values from both
              arguments</entry>
            </row>

            <row>
              <entry><replaceable>Set</replaceable><subscript>1</subscript>
              <literal>&amp;</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry>Set resulting from the intersection of the two
              arguments</entry>
            </row>

            <row>
              <entry><replaceable>Elm</replaceable> <literal>in</literal>
              <replaceable>Set</replaceable></entry>

              <entry><literal>true</literal> if <replaceable>Elm</replaceable>
              occurs as element in <replaceable>Set</replaceable> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Elm</replaceable> <literal>notin</literal>
              <replaceable>Set</replaceable></entry>

              <entry><literal>false</literal> if
              <replaceable>Elm</replaceable> occurs as element in
              <replaceable>Set</replaceable> and <literal>false</literal>
              otherwise</entry>
            </row>

            <row>
              <entry><replaceable><replaceable>Set</replaceable><subscript>1</subscript></replaceable>
              <literal>join</literal>
              <replaceable><replaceable>Set</replaceable><subscript>2</subscript></replaceable></entry>

              <entry>Relation resulting from the natural join of the two
              arguments. It contains tuples that are the result from
              concatenating the elements from both arguments</entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable> <literal>?</literal>
              <replaceable>Set</replaceable><subscript>1</subscript>
              <literal>:</literal>
              <replaceable>Set</replaceable><subscript>2</subscript></entry>

              <entry>If <replaceable>Bool</replaceable> is true then
              <replaceable>Set</replaceable><subscript>1</subscript> else
              <replaceable>Set</replaceable><subscript>2</subscript></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Examples:</para>

      <screen><prompt>rascal&gt;</prompt> <userinput><literal>{1, 2, 3} + {4, 5, 6}</literal>;</userinput>
<computeroutput><literal>set[int] : {1, 2, 3, 4, 5, 6}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput><literal>{1, 2, 3} + {1, 2, 3}</literal>;</userinput>
<computeroutput>set[int] : {1, 2, 3}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{1, 2, 3, 4} - {1, 2, 3}<literal>;</literal></userinput><literal>
</literal><computeroutput><literal>set[int] : {4}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput><literal>{1, 2, 3} - {4, 5, 6}</literal>;</userinput>
<computeroutput>set[int] : {1, 2, 3}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{1,2,3} * {4,5,6};</userinput>
<computeroutput>rel[int,int]: {&lt;1,4&gt;,&lt;1,5&gt;,&lt;1,6&gt;,&lt;3,4&gt;,&lt;3,5&gt;,
               &lt;3,6&gt;,&lt;2,4&gt;,&lt;2,5&gt;,&lt;2,6&gt;}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{1, 2, 3} &amp; {4, 5, 6};</userinput>
<computeroutput><literal>set[int] : { }</literal>
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>{1, 2, 3} &amp; {1, 2, 3};</userinput>
<computeroutput><literal>set[int] : {1, 2, 3}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput><literal>3 in {1, 2, 3}</literal><literal>;</literal></userinput><literal>
</literal><computeroutput><literal>bool : true</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>4 in {1, 2, 3};</userinput>
<computeroutput>bool : false</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>3 notin {1, 2, 3};</userinput>
<computeroutput>bool : false</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>4 notin {1, 2, 3};</userinput>
<computeroutput><literal>bool : true</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>&lt;2,20&gt; in {&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;};</userinput>
<computeroutput>bool : true</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>&lt;4,40&gt; notin {&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;};</userinput>
<computeroutput>bool : true</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{&lt;1,2&gt;, &lt;10,20&gt;} join {&lt;2,3&gt;};</userinput>
<computeroutput>rel[int, int, int, int]: {&lt;1,2,2,3&gt;,&lt;10,20,2,3&gt;}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>{&lt;1,2&gt;} join {3, 4};</userinput>
<computeroutput>rel[int, int, int]: {&lt;1,2,3&gt;,&lt;1,2,4&gt;}</computeroutput></screen>

      <table>
        <title>Set Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="3*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>&amp;T getOneFrom(set[&amp;T] st) throws
              emptySet</literal></entry>

              <entry>Pick a random element from a set</entry>
            </row>

            <row>
              <entry><literal>bool isEmpty(set[&amp;T] st)</literal></entry>

              <entry>Is set empty?</entry>
            </row>

            <row>
              <entry><literal>set[&amp;T] mapper(set[&amp;T] st, &amp;T
              (&amp;T,&amp;T) fn)</literal></entry>

              <entry>Apply a function to each element of a set</entry>
            </row>

            <row>
              <entry><literal>&amp;T max(set[&amp;T] st)</literal></entry>

              <entry>Largest element of a set</entry>
            </row>

            <row>
              <entry><literal>&amp;T min(set[&amp;T] st)</literal></entry>

              <entry>Smallest element of a set</entry>
            </row>

            <row>
              <entry><literal>set[set[&amp;T]] power(set[&amp;T]
              st)</literal></entry>

              <entry>All subsets of a set</entry>
            </row>

            <row>
              <entry><literal>set[set[&amp;T]] power1(set[&amp;T]
              st)</literal></entry>

              <entry>All subsets (excluding empty set) of a set</entry>
            </row>

            <row>
              <entry><literal>&amp;T reducer(set[&amp;T] st, &amp;T
              (&amp;T,&amp;T) fn, &amp;T unit)</literal></entry>

              <entry>Apply function F to successive elements of a set</entry>
            </row>

            <row>
              <entry><literal>int size(set[&amp;T] st)</literal></entry>

              <entry>Number of elements in a set</entry>
            </row>

            <row>
              <entry><literal>tuple[&amp;T, set[&amp;T]]
              takeOneFrom(set[&amp;T] st) throws emptySet</literal></entry>

              <entry>Remove an arbitrary element from a set, returns the
              element and the modified set</entry>
            </row>

            <row>
              <entry><literal>list[&amp;T] toList(set[&amp;T]
              st)</literal></entry>

              <entry>Convert a set to a list</entry>
            </row>

            <row>
              <entry><literal>map[&amp;A,set[&amp;B]] toMap(rel[&amp;A,
              &amp;B] st)</literal></entry>

              <entry>Convert a set of tuples to a map in which the first
              element of each tuple is associated with the set of second
              elements from all tuples with the same first element</entry>
            </row>

            <row>
              <entry><literal>map[&amp;A,&amp;B] toMapUnique(rel[&amp;A,
              &amp;B] st) throws DuplicateKey</literal></entry>

              <entry>Convert a set of tuples to a map; the result should be a
              legal map</entry>
            </row>

            <row>
              <entry><literal>str toString(set[&amp;T] st)</literal></entry>

              <entry>Convert a set to a string</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Examples:</para>

      <screen><prompt>rascal&gt;</prompt> <userinput>power({1, 2, 3, 4});</userinput>
<computeroutput>set[set[int]] : { {}, {1}, {2}, {3}, {4},{1,2}, {1,3}, {1,4}, 
                  {2,3}, {2,4}, {3,4}, {1,2,3}, {1,2,4}, 
                  {1,3,4}, {2,3,4}, {1,2,3,4}
                }</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>power1({1, 2, 3, 4});</userinput>
<computeroutput>set[set[int]] : { {1}, {2}, {3}, {4},{1,2}, {1,3}, {1,4}, {2,3}, 
                  {2,4}, {3,4}, {1,2,3}, {1,2,4}, {1,3,4}, 
                  {2,3,4}, {1,2,3,4}
                }</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>size({1,2,3});</userinput>
<computeroutput>int : 3</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>size({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;});</userinput>
<computeroutput>int : 3</computeroutput></screen>
    </section>

    <section xml:id="section.lib-String">
      <title>String</title>

      <table>
        <title>Operations on Strings</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>Str</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>Str</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if both arguments are
              equal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Str</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>Str</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if both arguments are
              unequal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Str</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>Str</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Str</replaceable><subscript>1</subscript> is
              lexicographically less than or equal to
              <replaceable>Str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Str</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>Str</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Str</replaceable><subscript>1</subscript> is
              lexicographically less than
              <replaceable>Str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Str</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>Str</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Str</replaceable><subscript>1</subscript> is
              lexicographically greater than or equal to
              <replaceable>Str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Str</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>Str</replaceable><subscript>2</subscript></entry>

              <entry>Yields <literal>true</literal> if
              <replaceable>Str</replaceable><subscript>1</subscript> is
              lexicographically greater than
              <replaceable>Str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>Str</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>Str</replaceable><subscript>2</subscript></entry>

              <entry>Concatenates
              <replaceable>Str</replaceable><subscript>1</subscript> and
              <replaceable>Str</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable> <literal>?</literal>
              <replaceable>Str</replaceable><subscript>1</subscript>
              <literal>:</literal>
              <replaceable>Str</replaceable><subscript>2</subscript></entry>

              <entry>If <replaceable>Bool</replaceable> is true then
              <replaceable>Str</replaceable><subscript>1</subscript> else
              <replaceable>Str<subscript>2</subscript></replaceable></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><table>
          <title>String Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>int charAt(str s, int i) throws
                IndexOutOfBounds(int index)</literal></entry>

                <entry>Character at position i in string s.</entry>
              </row>

              <row>
                <entry><literal>bool endsWith(str s, str
                suffix)</literal></entry>

                <entry>Yields <literal>true</literal> if string s ends with
                given string suffix.</entry>
              </row>

              <row>
                <entry><literal>str center(str s, int n)</literal></entry>

                <entry>Center s in string of length n using spaces</entry>
              </row>

              <row>
                <entry><literal>str center(str s, int n, str
                pad)</literal></entry>

                <entry>Center s in string of length n using a pad
                character</entry>
              </row>

              <row>
                <entry><literal>bool isEmpty(str s)</literal></entry>

                <entry>Is string empty?</entry>
              </row>

              <row>
                <entry><literal>str left(str s, int n)</literal></entry>

                <entry>Left align s in string of length n using spaces</entry>
              </row>

              <row>
                <entry><literal>str left(str s, int n, str
                pad)</literal></entry>

                <entry>Left align s in string of length n using pad
                character</entry>
              </row>

              <row>
                <entry><literal>str replaceAll(str input, str find, str
                replacement)</literal></entry>

                <entry>Replace all occurences of (regex) find in input by
                replacement</entry>
              </row>

              <row>
                <entry><literal>str replaceFirst(str input, str find, str
                replacement) </literal></entry>

                <entry>Replace the first occurence of (regex) find in input by
                replacement</entry>
              </row>

              <row>
                <entry><literal>str replaceLast(str input, str find, str
                replacement)</literal></entry>

                <entry>Replace the last occurence of (regex) find in input by
                replacement</entry>
              </row>

              <row>
                <entry><literal>str right(str s, int n)</literal></entry>

                <entry>Right align s in string of length n using
                spaces</entry>
              </row>

              <row>
                <entry><literal>str reverse(str s)</literal></entry>

                <entry>String with all characters in reverse order.</entry>
              </row>

              <row>
                <entry><literal>int size(str s)</literal></entry>

                <entry>Length of string s.</entry>
              </row>

              <row>
                <entry><literal>bool startsWith(str s, str
                prefix)</literal></entry>

                <entry>Yields <literal>true</literal> if string s starts with
                the string prefix.</entry>
              </row>

              <row>
                <entry><literal>int toInt(str s) throws IllegalArgument(value
                v)</literal></entry>

                <entry>Convert string s to integer. Throws IllegalArgument
                when s cannot be converted.</entry>
              </row>

              <row>
                <entry><literal>str toLowerCase(str s)</literal></entry>

                <entry>Convert all characters in string s to
                lowercase.</entry>
              </row>

              <row>
                <entry><literal>double toReal(str s) throws
                IllegalArgument(value v)</literal></entry>

                <entry>Convert s to a real. Throws IllegalArgument when s
                cannot be converted.</entry>
              </row>

              <row>
                <entry><literal>str toUpperCase(str s)</literal></entry>

                <entry>Convert all characters in string s to
                uppercase.</entry>
              </row>
            </tbody>
          </tgroup>
        </table><warning>
          <para>Remove charAt when string subscriptis implemented.</para>
        </warning></para>
    </section>

    <section xml:id="section.lib-Tree">
      <title>Tree</title>

      <para>Tree is the universal parse tree data type and can be used to
      parse text in any language. We do not give its full declaration here
      since internal details are never needed by Rascal users. The following
      is noteworthy:</para>

      <itemizedlist>
        <listitem>
          <para><literal>Tree</literal> is a subtype of the type node.</para>
        </listitem>

        <listitem>
          <para>All parse trees for a specific language are a subtype of
          <literal>Tree</literal>.</para>
        </listitem>

        <listitem>
          <para>Trees are annotated with location annotations defined as
          follows: <programlisting>anno loc Tree@\loc;</programlisting><note>
              <para>For historical reasons the name of the annotation is "loc"
              and this interferes with the Rascal keyword
              <keysym>loc</keysym>. Therefore the annotation name has to be
              escaped as <literal>\loc</literal> when it is declared or
              used.</para>
            </note></para>
        </listitem>
      </itemizedlist>

      <para><table>
          <title>Tree Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="3*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>&amp;T&lt;:Tree java
                parse(type[&amp;T&lt;:Tree] start, loc
                input);</literal></entry>

                <entry>Parse the contents of a resource pointed to by the
                input parameter and return a parse tree</entry>
              </row>

              <row>
                <entry><literal>&amp;T&lt;:Tree java
                parse(type[&amp;T&lt;:Tree] start, str
                input)</literal></entry>

                <entry>Parse a string and return a parse tree.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>These declarations use type reification as explained in <xref
      linkend="section.reified-types" />.</para>
    </section>

    <section xml:id="section.lib-Tuple">
      <title>Tuple</title>

      <table>
        <title>Tuple Operators</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="1*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>Tuple</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are
              identical</entry>
            </row>

            <row>
              <entry><replaceable>Tuple</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are not
              identical</entry>
            </row>

            <row>
              <entry><replaceable>Tuple</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are identical
              or if the leftmost element in
              <replaceable>Tuple</replaceable><subscript>1</subscript> that
              differs from the corresponding in
              <replaceable>Tuple</replaceable><subscript>2</subscript> is
              smaller than that element in
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Tuple</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are not
              identical and the leftmost element in
              <replaceable>Tuple</replaceable><subscript>1</subscript> that
              differs from the corresponding in
              <replaceable>Tuple</replaceable><subscript>2</subscript> is
              smaller than that element in
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Tuple</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are identical
              or if the leftmost element in
              <replaceable>Tuple</replaceable><subscript>1</subscript> that
              differs from the corresponding in
              <replaceable>Tuple</replaceable><subscript>2</subscript> is
              greater than that element in
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Tuple</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>

              <entry><literal>true</literal> if both arguments are not
              identical and the leftmost element in
              <replaceable>Tuple</replaceable><subscript>1</subscript> that
              differs from the corresponding in
              <replaceable>Tuple</replaceable><subscript>2</subscript> is
              greater than that element in
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Tuple</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>

              <entry>Concatenates
              <replaceable>Tuple</replaceable><subscript>1</subscript> and
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Bool</replaceable> <literal>?</literal>
              <replaceable>Tuple</replaceable><subscript>1</subscript>
              <literal>:</literal>
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>

              <entry>If <replaceable>Bool</replaceable> is true then
              <replaceable>Tuple</replaceable><subscript>1</subscript> else
              <replaceable>Tuple</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>Tuple</replaceable> <literal>.</literal>
              <replaceable>Name</replaceable></entry>

              <entry>Select field <replaceable>Name</replaceable> from
              <replaceable>Tuple</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>Tuple</replaceable> <literal>[</literal>
              <replaceable>Int</replaceable> <literal>]</literal></entry>

              <entry>Select field at position <replaceable>int</replaceable>
              from <replaceable>Tuple</replaceable></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-UnitTest">
      <title>UnitTest</title>

      <para>We provided a rudimentary library for unit testing that is
      currently used. This will soon be replaced by the use of test statements
      and test suites, see <xref linkend="section.test" />.</para>

      <table>
        <title>UnitTest Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="4*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>void assertTrue(bool outcome)</literal></entry>

              <entry>Check that outcome is true</entry>
            </row>

            <row>
              <entry><literal>void assertEqual(value V1, value
              V2)</literal></entry>

              <entry>Check that two values are equal</entry>
            </row>

            <row>
              <entry><literal>bool report()</literal></entry>

              <entry>Print unit test summary</entry>
            </row>

            <row>
              <entry><literal>bool report(str msg)</literal></entry>

              <entry>Print unit test summary, including msg</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.lib-Value">
      <title>Value</title>

      <para><table>
          <title>Value Operators</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="1*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>Value</replaceable><subscript>1</subscript>
                <literal>==</literal>
                <replaceable>Value</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments are
                identical</entry>
              </row>

              <row>
                <entry><replaceable>Value</replaceable><subscript>1</subscript>
                <literal>!=</literal>
                <replaceable>Value</replaceable><subscript>2</subscript></entry>

                <entry><literal>true</literal> if both arguments are not
                identical</entry>
              </row>

              <row>
                <entry><replaceable>Value</replaceable><subscript>1</subscript>
                <literal>&lt;=</literal>
                <replaceable>Value</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>Value</replaceable><subscript>1</subscript>
                is less than or equal to
                <replaceable>Value</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Value</replaceable><subscript>1</subscript>
                <literal>&lt;</literal>
                <replaceable>Value</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>Value</replaceable><subscript>1</subscript>
                is less than
                <replaceable>Value</replaceable><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Value</replaceable><subscript>1</subscript>
                <literal>&gt;=</literal>
                <replaceable>Value</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>Value</replaceable><subscript>2</subscript>
                is less than or equal to
                <replaceable>Value</replaceable><subscript>1</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Value</replaceable><subscript>1</subscript>
                <literal>&gt;</literal>
                <replaceable>Value</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>Value</replaceable><subscript>2</subscript>
                is less than
                <replaceable>Value</replaceable><subscript>1</subscript></entry>
              </row>

              <row>
                <entry><replaceable>Bool</replaceable> <literal>?</literal>
                <replaceable>Value</replaceable><subscript>1</subscript>
                <literal>:
                </literal><replaceable>Value</replaceable><subscript>2</subscript></entry>

                <entry>if <replaceable>Bool</replaceable> is true then
                <replaceable>Value</replaceable><subscript>1</subscript> else
                <replaceable>Value</replaceable><subscript>2</subscript></entry>
              </row>
            </tbody>
          </tgroup>
        </table>By brute force, a total less than operator between two values
      V1 and V2 of arbitrary types T1 and T2 is defined:</para>

      <itemizedlist>
        <listitem>
          <para>If the types T1 and T2 can be compared then V1 less than V2 is
          used.</para>
        </listitem>

        <listitem>
          <para>Otherwise values are ordered according their type name, i.e.,
          <keysym>int</keysym> is smaller than <keysym>list</keysym>, and
          <keysym>map</keysym> is smaller than <keysym>rel</keysym>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.lib-ValueIO">
      <title>ValueIO</title>

      <para><table>
          <title>ValueIO Functions</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colwidth="4*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <thead>
              <row>
                <entry>Function</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>value readValueFile(loc file) throws IO(str
                msg)</literal></entry>

                <entry>Read a value from a binary file in PBF format</entry>
              </row>

              <row>
                <entry><literal>&amp;T readBinaryValueFile(type[&amp;T]
                result, loc file) throws IO(str msg)</literal></entry>

                <entry>Read a typed value from a binary file.</entry>
              </row>

              <row>
                <entry><literal>value readBinaryValueFile(loc file) throws
                IO(str msg)</literal></entry>

                <entry>Read a value from a binary file.</entry>
              </row>

              <row>
                <entry><literal>&amp;T readTextValueFile(type[&amp;T] result,
                loc file) throws IO(str msg)</literal></entry>

                <entry>Read a typed value from a text file</entry>
              </row>

              <row>
                <entry><literal>value readTextValueFile(loc file) throws
                IO(str msg)</literal></entry>

                <entry>Read a value from a text file</entry>
              </row>

              <row>
                <entry><literal>void writeBinaryValueFile(loc file, value
                val)</literal></entry>

                <entry>Write a value to a file using an efficient binary file
                format (PBF)</entry>
              </row>

              <row>
                <entry><literal>void writeTextValueFile(loc file, value
                val)</literal></entry>

                <entry>Write a value to a file using a textual file
                format</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section xml:id="section.lib-View">
      <title>View (Eclipse only)</title>

      <table>
        <title>View Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colwidth="3*" />

          <colspec align="left" colname="col2" colwidth="3*" />

          <thead>
            <row>
              <entry>Function</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>void graphView(value v)</literal></entry>

              <entry>Show value <literal>v</literal> as a graph</entry>
            </row>

            <row>
              <entry><literal>void textView(value v) </literal></entry>

              <entry>Show value <literal>v</literal> as text</entry>
            </row>

            <row>
              <entry><literal>void treeView(value v) </literal></entry>

              <entry>Show value <literal>v</literal> as a collapsible
              tree</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>At the moment, this module also provides Eclipse-versions of the
      Chart functions, see <xref linkend="section.lib-Chart" /> for further
      details.</para>
    </section>

    <section xml:id="section.lib-Void">
      <title>Void</title>

      <para>There are no operators or functions defined on the type
      <literal>void</literal>.</para>
    </section>
  </section>

  <?hard-pagebreak ?>

  <section>
    <title>Running Rascal</title>

    <para>The Rascal system comes in two flavours: a command line version and
    a version integrated in Eclipse.</para>

    <section>
      <title>Rascal at the Command Line</title>

      <para>At the command line the Rascal system can be invoked by typing the
      command <command>rascal</command>. Next, the Rascal prompt
      <prompt>rascal&gt;</prompt> appears and you can start typing commands
      (declarations, statements, expressions). To simplify interactive use,
      semicolons (<literal>;</literal>) that end commands may be omitted at
      the top level.</para>

      <para>In addition to Rascal expressions and statements, the command line
      interface also supports some additional directives that you can find by
      typing <literal>:help</literal> as show here:<screen><productname>rascal&gt;</productname> <userinput>:help</userinput>
<computeroutput>Welcome to the Rascal command shell.

Shell commands:
:help                      Prints this message
:quit or EOF               Quits the shell
:list                      Lists all visible rules, functions and 
                           variables
:set &lt;option&gt; &lt;expression&gt; Sets an option
:edit &lt;modulename&gt;         Opens an editor for that module
:modules                   Lists all imported modules
:test                      Runs all unit tests currently loaded
:unimport &lt;modulename&gt;     Undo an import
:undeclare &lt;name&gt;          Undeclares a variable or function 
                           introduced in the shell
:history                   Print the command history

Example rascal statements and declarations:
1 + 1;                     Expressions simply print their output 
                           and (static) type
int a;                     Declarations allocate a name in the 
                           current scope
a = 1;                     Assignments store a value in a 
                           (optionally previously declared) 
                           variable
int a = 1;                 Declaration with initialization
import IO;                 Importing a module makes its public 
                           members available
println("Hello World")     Function calling

Please read the manual for further information
ok</computeroutput>
<prompt>rascal&gt;</prompt></screen><warning>
          <para>Further discuss here arguments of the rascal command.</para>
        </warning></para>
    </section>

    <section>
      <title>Rascal in Eclipse</title>

      <para><warning>
          <para>To be written</para>
        </warning></para>
    </section>
  </section>

  <section xml:id="section.table-builtin-operators">
    <title>Table of Built-in Operators</title>

    <table xml:id="table.all-operators">
      <title>All Operators</title>

      <tgroup cols="3">
        <colspec align="left" colname="col1" colwidth="2*" />

        <colspec align="left" colname="col2" colwidth="2*" />

        <colspec align="left" colname="col3" colwidth="4*" />

        <thead>
          <row>
            <entry>Operator</entry>

            <entry>Description</entry>

            <entry>See Library Module/Section</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript><literal>[</literal><replaceable>Name</replaceable>
            <literal>=</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript><literal>]</literal></entry>

            <entry>Field assignment</entry>

            <entry><xref linkend="section.expressions-non-boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable> <literal>.</literal>
            <replaceable>Name</replaceable></entry>

            <entry>Field selection</entry>

            <entry><xref linkend="section.expressions-non-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Location"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Tuple"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable> <literal>&lt;</literal>
            <replaceable>field</replaceable>, ...<literal>
            &gt;</literal></entry>

            <entry>Field projection</entry>

            <entry><xref linkend="section.expressions-non-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript><literal>[</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript> ,
            <literal><replaceable>Exp</replaceable><subscript>3</subscript>,
            .... ]</literal></entry>

            <entry>Index</entry>

            <entry><xref linkend="section.expressions-non-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Node"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Relation"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Tuple"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable> <literal>?</literal></entry>

            <entry>Isdefined: true if Exp has a defined value</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>!</literal> <replaceable>Exp</replaceable></entry>

            <entry>Negation</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>-</literal> <replaceable>Exp</replaceable></entry>

            <entry>Negation</entry>

            <entry><xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable> <literal>+</literal></entry>

            <entry>Transitive closure</entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable> <literal>*</literal></entry>

            <entry>Reflexive transitive</entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable> <literal>@</literal>
            <replaceable>Name</replaceable></entry>

            <entry>Attribute value</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>[@</literal> <replaceable>Name</replaceable>
            <literal>=</literal><replaceable>
            Exp</replaceable><subscript>2</subscript><literal>]</literal></entry>

            <entry>Assign attribute value</entry>

            <entry></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>o</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Composition</entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>x</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Cartesian product</entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>/</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Division</entry>

            <entry><xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>%</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Modulo</entry>

            <entry><xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>*</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Multiplication/product</entry>

            <entry><xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>&amp;</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Intersection</entry>

            <entry><xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>+</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Addition/concatenation/union</entry>

            <entry><xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" />, <xref linkend="section.lib-String"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Tuple"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>-</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Subtraction/difference</entry>

            <entry><xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable><replaceable>Exp</replaceable><subscript>1</subscript></replaceable>
            <literal>join</literal>
            <replaceable><replaceable>Exp</replaceable><subscript>2</subscript></replaceable></entry>

            <entry>Join</entry>

            <entry><xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable><replaceable>Exp</replaceable><subscript>1</subscript></replaceable>
            <literal>in</literal>
            <replaceable><replaceable>Exp</replaceable><subscript>2</subscript></replaceable></entry>

            <entry>Element of</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable><replaceable>Exp</replaceable><subscript>1</subscript></replaceable>
            <literal>notin</literal>
            <replaceable><replaceable>Exp</replaceable><subscript>2</subscript></replaceable></entry>

            <entry>Not element of</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>&lt;=</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Less than/sublist /subset</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Location"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Node"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />,<xref linkend="section.lib-Set"
            xrefstyle="template:%t" />, <xref linkend="section.lib-String"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Tuple"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Value"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>&lt;</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Less than/strict sublist/strict subset</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Location"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Node"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" />, <xref linkend="section.lib-String"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Tuple"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Value"
            xreflabel="" xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>&gt;=</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Greater than/superlist/superset</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Location"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Node"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" />, <xref linkend="section.lib-String"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Tuple"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Value"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>&gt;</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Greater than/strict superlist/ strict superset</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Location"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Node"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xreflabel="" xrefstyle="template:%t" />, <xref
            linkend="section.lib-Set" xrefstyle="template:%t" />, <xref
            linkend="section.lib-String" xrefstyle="template:%t" />, <xref
            linkend="section.lib-Tuple" xrefstyle="template:%t" />, <xref
            linkend="section.lib-Value" xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Pat</replaceable> <literal>:=</literal>
            <replaceable>Exp</replaceable></entry>

            <entry>Match</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Pat</replaceable> <literal>!:=</literal>
            <replaceable>Exp</replaceable></entry>

            <entry>No Match</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>==</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Equality</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Location"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Node"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" />, <xref linkend="section.lib-String"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Tuple"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Value"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>!=</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Inequality</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Location"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Node"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xreflabel="" xrefstyle="template:%t" />, <xref
            linkend="section.lib-Set" xrefstyle="template:%t" />, <xref
            linkend="section.lib-String" xrefstyle="template:%t" />,<xref
            linkend="section.lib-Tuple" xrefstyle="template:%t" />, <xref
            linkend="section.lib-Value" xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>?</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Ifdefined Otherwise</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>?</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript>
            <literal>:</literal>
            <replaceable>Exp</replaceable><subscript>3</subscript></entry>

            <entry>Conditional Expression</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Node"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" />, <xref linkend="section.lib-String"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Tuple"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Value"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>==&gt;</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Implication</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>&lt;==&gt;</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Equivalence</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>&amp;&amp;</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Boolean and</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><replaceable>Exp</replaceable><subscript>1</subscript>
            <literal>||</literal>
            <replaceable>Exp</replaceable><subscript>2</subscript></entry>

            <entry>Boolean or</entry>

            <entry><xref linkend="section.expressions-boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" /></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <?hard-pagebreak ?>

  <section xml:id="section.table-builtin-functions">
    <title>Table of Built-in Functions</title>

    <table xml:id="table.all-functions">
      <title>All Functions</title>

      <tgroup cols="2">
        <colspec align="left" colname="col1" colwidth="2*" />

        <colspec align="left" colname="col3" colwidth="3*" />

        <thead>
          <row>
            <entry>Function</entry>

            <entry>See Library Module</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>abs</literal></entry>

            <entry><xref linkend="section.lib-Integer"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>arbBool</literal></entry>

            <entry><xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>arbInt</literal></entry>

            <entry><xref linkend="section.lib-Integer"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>arbReal</literal></entry>

            <entry><xref linkend="section.lib-Real"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>area</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>arity</literal></entry>

            <entry><xref linkend="section.lib-Node"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>assertEqual</literal></entry>

            <entry><xref linkend="section.lib-UnitTest"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>assertTrue</literal></entry>

            <entry><xref linkend="section.lib-UnitTest"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>average</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>barChart</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" />, <xref linkend="section.lib-View"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>bottom</literal></entry>

            <entry><xref linkend="section.lib-Graph"
            xrefstyle="template:%t" />, <xref
            linkend="section.lib-LabelledGraph"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>boxPlot</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" />, <xref linkend="section.lib-View"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>carrier</literal></entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>carrierR</literal></entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>carrierX</literal></entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>center</literal></entry>

            <entry><xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>charAt</literal></entry>

            <entry><xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>complement</literal></entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>currentTimeMillis</literal></entry>

            <entry><xref linkend="section.lib-Benchmark"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>delete</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>dim3</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>domain</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>domainLabel</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>domainR</literal></entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>domainX</literal></entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>endsWith</literal></entry>

            <entry><xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>files</literal></entry>

            <entry><xref linkend="section.lib-Resource"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>fromInt</literal></entry>

            <entry><xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>fromString</literal></entry>

            <entry><xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>getChildren</literal></entry>

            <entry><xref linkend="section.lib-Node"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>getName</literal></entry>

            <entry><xref linkend="section.lib-Node"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>getOneFrom</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>graphView</literal></entry>

            <entry><xref linkend="section.lib-View"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>head</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>histogram</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" />, <xref linkend="section.lib-View"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>horizontal</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>ident</literal></entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>insertAt</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>invert</literal></entry>

            <entry><xref linkend="section.lib-Map" xrefstyle="template:%t" />,
            <xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>invertUnique</literal></entry>

            <entry><xref linkend="section.lib-Map"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>isEmpty</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" />, <xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>left</literal></entry>

            <entry><xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry>location</entry>

            <entry><xref linkend="section.lib-Resource"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>makeNode</literal></entry>

            <entry><xref linkend="section.lib-Node"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>mapper</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>max</literal></entry>

            <entry><xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>min</literal></entry>

            <entry><xref linkend="section.lib-Integer" xreflabel=""
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>noSectionLabels</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>permutations</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>pieChart</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" />, <xref linkend="section.lib-View"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>power</literal></entry>

            <entry><xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>power1</literal></entry>

            <entry><xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>predecessors</literal></entry>

            <entry><xref linkend="section.lib-Graph"
            xrefstyle="template:%t" />, <xref
            linkend="section.lib-LabelledGraph"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>println</literal></entry>

            <entry><xref linkend="section.lib-IO"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>projects</literal></entry>

            <entry><xref linkend="section.lib-Resource"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>range</literal></entry>

            <entry><xref linkend="section.lib-Map"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>rangeLabel</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>rangeR</literal></entry>

            <entry><xref linkend="section.lib-Relation"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>reach</literal></entry>

            <entry><xref linkend="section.lib-Graph"
            xrefstyle="template:%t" />, <xref
            linkend="section.lib-LabelledGraph"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>reachR</literal></entry>

            <entry><xref linkend="section.lib-Graph"
            xrefstyle="template:%t" />, <xref
            linkend="section.lib-LabelledGraph"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>reachX</literal></entry>

            <entry><xref linkend="section.lib-Graph"
            xrefstyle="template:%t" />, <xref
            linkend="section.lib-LabelledGraph"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>readFile</literal></entry>

            <entry><xref linkend="section.lib-IO"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>readRSF</literal></entry>

            <entry><xref linkend="section.lib-RSF"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>readValueFromBinaryFile</literal></entry>

            <entry><xref linkend="section.lib-ValueIO"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>readValueFromTextFile</literal></entry>

            <entry><xref linkend="section.lib-ValueIO"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>reducer</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>references</literal></entry>

            <entry><xref linkend="section.lib-Resource"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>report</literal></entry>

            <entry><xref linkend="section.lib-UnitTest"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>reverse</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>right</literal></entry>

            <entry><xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>ring</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>root</literal></entry>

            <entry><xref linkend="section.lib-Resource"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>shortestPathPair</literal></entry>

            <entry><xref linkend="section.lib-Graph"
            xrefstyle="template:%t" />, <xref
            linkend="section.lib-LabelledGraph"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>size</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" />, <xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>slice</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>sort</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>scatter</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>stacked</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>startsWith</literal></entry>

            <entry><xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>subtitle</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>successors</literal></entry>

            <entry><xref linkend="section.lib-Graph"
            xrefstyle="template:%t" />, <xref
            linkend="section.lib-LabelledGraph"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>tail</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>takeOneFrom</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>textView</literal></entry>

            <entry><xref linkend="section.lib-View"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>treeView</literal></entry>

            <entry><xref linkend="section.lib-View"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toReal</literal></entry>

            <entry><xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toInt</literal></entry>

            <entry><xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />,<xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toList</literal></entry>

            <entry><xref linkend="section.lib-Map" xrefstyle="template:%t" />,
            <xref linkend="section.lib-Set" xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toLowerCase</literal></entry>

            <entry><xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toMap</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toMapUnique</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" />,<xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>top</literal></entry>

            <entry><xref linkend="section.lib-Graph"
            xrefstyle="template:%t" />, <xref
            linkend="section.lib-LabelledGraph"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toReal</literal></entry>

            <entry><xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Integer"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toRel</literal></entry>

            <entry><xref linkend="section.lib-Map"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toSet</literal></entry>

            <entry><xref linkend="section.lib-List"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toString</literal></entry>

            <entry><xref linkend="section.lib-Boolean"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Integer"
            xrefstyle="template:%t" />, <xref linkend="section.lib-List"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Map"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Real"
            xrefstyle="template:%t" />, <xref linkend="section.lib-Set"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>toUpperCase</literal></entry>

            <entry><xref linkend="section.lib-String"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>vertical</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>writeValueToBinaryFile</literal></entry>

            <entry><xref linkend="section.lib-ValueIO"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>writeValueToTextFile</literal></entry>

            <entry><xref linkend="section.lib-ValueIO"
            xrefstyle="template:%t" /></entry>
          </row>

          <row>
            <entry><literal>xyChart</literal></entry>

            <entry><xref linkend="section.lib-Chart"
            xrefstyle="template:%t" />, <xref linkend="section.lib-View"
            xrefstyle="template:%t" /></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <?hard-pagebreak ?>

  <section xml:id="section.bibliography">
    <title>Bibliography</title>

    <para><bibliolist>
        <bibliomixed xml:id="AhoSethiUllman86"></bibliomixed>

        <bibliomixed xml:id="BNL03"></bibliomixed>

        <bibliomixed xml:id="Dot96"></bibliomixed>

        <bibliomixed xml:id="FeijsKrikhaarOmmering98"></bibliomixed>

        <bibliomixed xml:id="Holt96"></bibliomixed>

        <bibliomixed xml:id="JacksonRollins94"></bibliomixed>

        <bibliomixed xml:id="KlintIWPC03"></bibliomixed>

        <bibliomixed xml:id="Krikhaar99"></bibliomixed>

        <bibliomixed xml:id="McCabe76"></bibliomixed>

        <bibliomixed xml:id="Mueller88"></bibliomixed>

        <bibliomixed xml:id="Tip95"></bibliomixed>

        <bibliomixed xml:id="Weiser84"></bibliomixed>
      </bibliolist></para>
  </section>

  <section>
    <title>Acknowledgements</title>

    <para>Rascal has been designed and implemented by the authors but they
    have received strong support, encouragement, and help from the following
    individuals. We are very grateful to them.</para>

    <para>Emilie Balland implemented the Rascal debugger in the Eclipse
    version of Rascal during her visit to CWI in the summer of 2009.</para>

    <para>Bas Basten provided useful feedback on the design and contributed
    the Rascal/JDT interface that makes it easy to extract facts from Java
    source code.</para>

    <para>Bob Fuhrer's inspiring IMP project motivated us to build Rascal on
    top of IMP. The PDB was designed and implemented during Jurgen's visit to
    IBM Research in 2007-2008.</para>

    <para>Arnold Lankamp implemented a very efficient version of the Program
    Data Base (PDB), added a binary streaming format, implemented the SGLR
    invoker, and takes care of deployment issues.</para>

    <para>Karel Pieterson used Rascal as topic for a usability study in his
    Master's thesis. The results will be included in the final version of this
    document.</para>

    <para>Frank Tip and Yaroslav Usenko provided feedback on this manual and
    suggested several improvements.</para>
  </section>

  <?hard-pagebreak ?>

  <glossary version="5.0" xml:id="section.glossary">
    <title>Glossary of Terminology</title>

    <glossentry>
      <glossterm>Annotation</glossterm>

      <glossdef>
        <para>An annotation is a (name, value) pair that can be attached to a
        datatype value. The value can be retrieved and changed via the name.
        One datatype value can have more than one annotation.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>ASF</glossterm>

      <glossdef>
        <para>Algebraic Specification Formalism. This a notation for
        describing rewrite rules and is mostly used for defining software
        analysis, fact extraction, and software transformation. It is the
        predecessor of Rascal.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>ASF+SDF</glossterm>

      <glossdef>
        <para>The combination of the formalisms ASF and SDF. ASF+SDF can
        describe both the syntax of a language and the operations on that
        language (checking, execution, analysis, transformation). It is the
        predecessor of Rascal.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>AsFix</glossterm>

      <glossdef>
        <para>ASF+SDF Fixed format. A dataformat used to represent parse
        trees. AsFix is a specialized view on ATerms. Important features
        are:</para>

        <itemizedlist>
          <listitem>
            <para>The AsFix format is a full parse tree that contains all the
            original layout and comments from the original source code program
            that was parsed.</para>
          </listitem>

          <listitem>
            <para>The AsFix format is self-descriptive: each subtree contains
            information about the exact grammar production that has been used
            to parse the text that has resulted in that parse tree.</para>
          </listitem>

          <listitem>
            <para>The AsFix format does not contain source code coordinates
            per se, but a separate tool can easily compute these coordinates
            and add them to the parse tree in the form of annotations.</para>
          </listitem>
        </itemizedlist>

        <para>AsFix is the predecessor of the ParseTree format used by
        Rascal</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>ATerm</glossterm>

      <glossdef>
        <para>Annotated terms. A dataformat used for the internal
        representation of all data. Distinguishing features are:</para>

        <itemizedlist>
          <listitem>
            <para>ATerms are language-independent and can be processed by
            programs in any language.</para>
          </listitem>

          <listitem>
            <para>ATerms can be annotated with auxiliary information that does
            not affect the tree structure.</para>
          </listitem>

          <listitem>
            <para>ATerms preserve <emphasis>maximal subterm
            sharing</emphasis>. This means that common parts of the data are
            not duplicated but shared. This leads to considerable
            size-reduction of the data.</para>
          </listitem>
        </itemizedlist>

        <para>ATerms are the predecessors of the shared PDB implementation
        used in Rascal.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Backtracking</glossterm>

      <glossdef>
        <para>Backtracking is a general algorithmic method for finding all (or
        some) solutions to some computational problem, in the case of Rascal
        for pattern matching. It incrementally builds candidate matches, and
        abandons each partial match ("backtracks") as soon as it determines
        that it cannot possibly be completed to a valid match.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Bag</glossterm>

      <glossdef>
        <para>A bag can contain arbitrary values, without any particular
        order, and possibly repeated elements. All elements of a bag have the
        same type. <remark>Rascal does not (yet?) support
        bags.</remark></para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Comprehension</glossterm>

      <glossdef>
        <para>An algorithmic schema for computing lists, sets or
        relations.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Constraint solving</glossterm>

      <glossdef>
        <para>The process of finding solutions to a problem that is only
        specified by the boundary conditions (constraints) that a solution
        should satisfy.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Control flow</glossterm>

      <glossdef>
        <para>The order in which the statements in a program can be executed.
        Usually represented as a control flow graph.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Debugger</glossterm>

      <glossdef>
        <para>A debugger allows the step-by-step execution of a
        program.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Dataflow</glossterm>

      <glossdef>
        <para>The order in which values may be assigned to variables during
        program execution. Usually represented as a data flow graph.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Eclipse</glossterm>

      <glossdef>
        <para>Interactive Development Environment (IDE) for Java and other
        languages. The Rascal IDE is built on top of Eclipse and IMP.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Enumerator</glossterm>

      <glossdef>
        <para>A Rascal construct that enumerates all the elements of a given
        value.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Function (higher order)</glossterm>

      <glossdef>
        <para>A function is a computational entity with typed formal
        parameters and a typed result. When applied to actual parameters, the
        function is applied and the result replaces the function call. A
        higher-order function is a function that has one or more functions as
        parameter.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Graph</glossterm>

      <glossdef>
        <para>In mathematics a graph is a set of objects (nodes) that may be
        pairwise connected with links (edges). In Rascal, a graph is a binary
        relation in which each tuple represents an edge in the corresponding
        (mathematical) graph.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Interactive Development Environment (IDE)</glossterm>

      <glossdef>
        <para>A programming environment for the interactive design,
        development, debugging and testing of programs. Eclipse is an example
        of an IDE.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>IDE Meta Platform (IMP)</glossterm>

      <glossdef>
        <para>IMP is an extension of Eclipse and is intended to make it easier
        to add support for new languages to Eclipse. The Rascal implementation
        is part of IMP.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Location</glossterm>

      <glossdef>
        <para>Data format to describe locations in source code.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>List</glossterm>

      <glossdef>
        <para>A list can contain arbitrary values, with a particular order,
        and possibly repeated elements. All elements of a list have the same
        type.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Map</glossterm>

      <glossdef>
        <para>A map is a binary relation consisting of 2-tuples (pairs) of the
        form (key, value) that associate each key with a unique value.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Meta-Environment</glossterm>

      <glossdef>
        <para>The ASF+SDF Meta-Environment is the IDE for writing ASF+SDF
        specifications.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Meta-programming</glossterm>

      <glossdef>
        <para>The activity of writing programs that manipulate other programs
        as data.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Parser</glossterm>

      <glossdef>
        <para>A program that performs syntactic analysis on a given input text
        and builds a parse tree.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Parse table</glossterm>

      <glossdef>
        <para>A parse table is produced by a parse table generator and is an
        efficient representation of grammar that can be used by a
        parser.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Parse table generator</glossterm>

      <glossdef>
        <para>A parse table generator takes a grammar as input and converts it
        to a parse table to be used by a parser.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Parse tree</glossterm>

      <glossdef>
        <para>Tree-structured representation of a text that has been analyzed
        by a parser.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>ParseTree</glossterm>

      <glossdef>
        <para>The ParseTree datatype is the parse tree format used in Rascal.
        It is the successor of AsFix.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Pattern</glossterm>

      <glossdef>
        <para>A structural description of values that is used for
        matching.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Pattern matching</glossterm>

      <glossdef>
        <para>Matching is an algorithmic method for determining the structural
        similarity of a pattern and a subject value. The pattern may contain
        variables that are bound to corresponding parts of the subject value
        when the match succeeds.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Program Data Base (PDB)</glossterm>

      <glossdef>
        <para>Subsystem of IMP that is responsible for implementing Rascal's
        datatypes.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Polymorphism</glossterm>

      <glossdef>
        <para>Functions and datatypes that can handle values of different
        types in a uniform manner.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Prettyprinter</glossterm>

      <glossdef>
        <para>A prettyprinter converts parse trees to text. The prettyprinter
        uses default rules to insert layout in a parse tree so that its
        corresponding text is presented in a uniform way. Optionally,
        user-defined formatting rules can replace this default
        behaviour.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Relation</glossterm>

      <glossdef>
        <para>A relation is a set of tuples. All tuples of a relation have the
        same type.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Rscript</glossterm>

      <glossdef>
        <para>A small scripting language for defining relational expressions.
        Used for the analysis of facts extracted from software. Predecessor of
        Rascal.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Relational Algebra</glossterm>

      <glossdef>
        <para>An algebra on relations that provides operators on relations
        that yield new relations. Relational algebra uses no variables and
        provides an operational view on relations.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Relational calculus</glossterm>

      <glossdef>
        <para>Relational calculus provides a more declarative and descriptive
        way to formulate operations on relations and depends on the use of
        variables.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Read-Eval-Print-Loop (REPL)</glossterm>

      <glossdef>
        <para>Command-line loop that reads user input, evaluates it and prints
        the result.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Rewrite rule</glossterm>

      <glossdef>
        <para>A rewrite rule consists of a pattern and a replacement. A
        rewrite rule is applied to all subparts of a datastructure and when
        the pattern matches the matching subpart is replaced. Pattern and
        replacement may contain variables and variables in the replacement are
        first replaced by their value before the replacement is
        applied.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>SDF</glossterm>

      <glossdef>
        <para>Syntax Definition Formalism. A notation for describing the
        grammar of programming and application languages. SDF definitions can
        be imported in Rascal.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Set</glossterm>

      <glossdef>
        <para>A set can contain arbitrary values, without any particular
        order, and no repeated elements. All elements of a set have the same
        type.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Side-effect</glossterm>

      <glossdef>
        <para>In imperative programming languages like C and Java, assignments
        cause changes in a global state that are visible for other statements
        and procedures.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Syntax tree</glossterm>

      <glossdef>
        <para>Tree-structured representation of a text that has been analyzed
        by a parser.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Summary</glossterm>

      <glossdef>
        <para>An error or message summary. A dataformat for the internal
        representation of errors and messages. Summaries are produced by
        checker and compilers and are used by the GUI.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Term rewriting</glossterm>

      <glossdef>
        <para>Term rewriting is the act of applying a set of rewrite rules to
        a subject value. The rules are applied as long as any pattern in some
        rule matches. The result is the subject value with replacements made
        as prescribed by the matching rules.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Traversal</glossterm>

      <glossdef>
        <para>The process of visiting all the sub-elements of a larger
        datastructure. The <literal>visit</literal> expression and enumerators
        provide traversal functionality in Rascal.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Tuple</glossterm>

      <glossdef>
        <para>A tuple is an ordered list of values of possibly different type.
        An element of a tuple may have a label by which that element can be
        selected or modified.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Type checking</glossterm>

      <glossdef>
        <para>The activity to check that all entities in a program are
        declared and are used in a way that is consistent with their declared
        type.</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Type inference</glossterm>

      <glossdef>
        <para>The activity to infer the type of program entities from their
        use.</para>
      </glossdef>
    </glossentry>
  </glossary>

  <!--

%% \newpage
\section*{Acknowledgments}
Thanks to Tijs van der Storm for many useful discussions and experiments.
Thanks to Murat Ahat, Jan van Eijck, Taeke Kooiker, Tijs van der Storm, Ivan Vankov,
and Jurgen Vinju for comments on this tutorial.

\section*{Illustrations}

Most illustrations used in this tutorial concern physical instruments for
  measurement or observation and are taken from H. van de Stadt, \emph{Beknopt
  Leerboek der Natuurkunde} (Concise Text-book of Physics) Tjeenk Willink,
  Zwolle, 1902.
On the front page appears a windlass that amplifies manual power and is used in
water wells, drilling devices, and wind mills.
Page~\pageref{FIG:balloon}  shows a hot air balloon combined with a parachute
(circa 1900).
On page~\pageref{FIG:microscope} appears a composite microscope as proposed by
Drebbel (1621).
On page~\pageref{FIG:declinatorium} appears a \emph{declinatorium} used to
measure the difference between the magnetic and geographic north pole.
On page~\pageref{FIG:vuurtoren} the cross section is shown of a lighthouse as used along
the Dutch cost.
The spectroscope on page~\pageref{FIG:spektroskoop} is a design using four
prisms by Steinheil
and is used for the improved dispersion and analysis of the light emitted by
sodium vapor.
On page~\pageref{FIG:ruhmkorff} appears Ruhmkorff's induction-coil (1851) used
to create high-Voltage electric currents. 
Page \pageref{FIG:camera-obscura} shows a variation of the \emph{camera obscura} as
used for producing realistic drawings of a landscape.
Lassell's telescope (1863) appears on page~\pageref{FIG:teleskoop}.

 The photograph on page~\pageref{FIG:caruso} is the ``Caruso'' loudspeaker and
  appeared in an advertisement in J. Corver, \emph{Het Draadloos
  Amateurstation} (The Wireless Amateur (Radio) Station), Veenstra, 's
  Gravenhage, 1928.
The sign alphabet on page~\pageref{FIG:signalpha} has been taken from
\url{ www.inquiry.net/outdoor/skills/b-p/signaling.htm}
\bibliographystyle{plain} \bibliography{iwpc,tutorial}
-->
</chapter>
