<?xml version="1.0"?>
<fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format" font-family="serif,Symbol,ZapfDingbats" font-size="10pt" text-align="justify" line-height="normal" font-selection-strategy="character-by-character" line-height-shift-adjustment="disregard-shifts" writing-mode="lr-tb" language="en"><fo:layout-master-set><fo:simple-page-master master-name="blank" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body display-align="center" margin-bottom="0mm" margin-top="0mm" region-name="blank-body"/><fo:region-before region-name="xsl-region-before-blank" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-blank" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="titlepage-first" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="titlepage-odd" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="titlepage-even" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="lot-first" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="lot-odd" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="lot-even" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="front-first" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="front-odd" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="front-even" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="body-first" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="body-odd" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="body-even" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="back-first" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="back-odd" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="back-even" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="index-first" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="2"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="index-odd" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="2"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="index-even" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="2"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="blank-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-blank" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-blank" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="titlepage-first-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="titlepage-odd-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="titlepage-even-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="lot-first-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="lot-odd-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="lot-even-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="front-first-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="front-odd-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="front-even-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="body-first-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="body-odd-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="body-even-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="back-first-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="back-odd-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="back-even-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="1" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="index-first-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="2" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-first" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-first" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="index-odd-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="47mm" margin-right="41mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="2" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-odd" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-odd" extent="0" display-align="after"/></fo:simple-page-master><fo:simple-page-master master-name="index-even-draft" page-width="210mm" page-height="297mm" margin-top="41mm" margin-bottom="63mm" margin-left="41mm" margin-right="47mm"><fo:region-body margin-bottom="0mm" margin-top="0mm" column-gap="12pt" column-count="2" background-image="url(http://docbook.sourceforge.net/release/images/draft.png)" background-attachment="fixed" background-repeat="no-repeat" background-position-horizontal="center" background-position-vertical="center"/><fo:region-before region-name="xsl-region-before-even" extent="0" display-align="before"/><fo:region-after region-name="xsl-region-after-even" extent="0" display-align="after"/></fo:simple-page-master><fo:page-sequence-master master-name="titlepage"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="titlepage-first" page-position="first"/><fo:conditional-page-master-reference master-reference="titlepage-odd" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="titlepage-odd"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="lot"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="lot-first" page-position="first"/><fo:conditional-page-master-reference master-reference="lot-odd" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="lot-odd"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="front"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="front-first" page-position="first"/><fo:conditional-page-master-reference master-reference="front-odd" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="front-odd"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="body"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="body-first" page-position="first"/><fo:conditional-page-master-reference master-reference="body-odd" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="body-odd"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="back"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="back-first" page-position="first"/><fo:conditional-page-master-reference master-reference="back-odd" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="back-odd"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="index"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="index-first" page-position="first"/><fo:conditional-page-master-reference master-reference="index-odd" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="index-odd"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="titlepage-draft"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank-draft" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="titlepage-first-draft" page-position="first"/><fo:conditional-page-master-reference master-reference="titlepage-odd-draft" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="titlepage-odd-draft"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="lot-draft"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank-draft" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="lot-first-draft" page-position="first"/><fo:conditional-page-master-reference master-reference="lot-odd-draft" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="lot-odd-draft"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="front-draft"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank-draft" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="front-first-draft" page-position="first"/><fo:conditional-page-master-reference master-reference="front-odd-draft" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="front-odd-draft"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="body-draft"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank-draft" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="body-first-draft" page-position="first"/><fo:conditional-page-master-reference master-reference="body-odd-draft" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="body-odd-draft"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="back-draft"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank-draft" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="back-first-draft" page-position="first"/><fo:conditional-page-master-reference master-reference="back-odd-draft" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="back-odd-draft"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master><fo:page-sequence-master master-name="index-draft"><fo:repeatable-page-master-alternatives><fo:conditional-page-master-reference master-reference="blank-draft" blank-or-not-blank="blank"/><fo:conditional-page-master-reference master-reference="index-first-draft" page-position="first"/><fo:conditional-page-master-reference master-reference="index-odd-draft" odd-or-even="odd"/><fo:conditional-page-master-reference odd-or-even="even" master-reference="index-odd-draft"/></fo:repeatable-page-master-alternatives></fo:page-sequence-master></fo:layout-master-set><fo:page-sequence xmlns:axf="http://www.antennahouse.com/names/XSL/Extensions" hyphenate="true" master-reference="body" language="en" format="1" initial-page-number="auto" force-page-count="no-force" hyphenation-character="-" hyphenation-push-character-count="2" hyphenation-remain-character-count="2"><fo:static-content flow-name="xsl-region-before-first"><fo:block font-family="serif,Symbol,ZapfDingbats" margin-left="0pt"><fo:table table-layout="fixed" width="100%"><fo:table-column column-number="1" column-width="proportional-column-width(1)"/><fo:table-column column-number="2" column-width="proportional-column-width(4)"/><fo:table-column column-number="3" column-width="proportional-column-width(1)"/><fo:table-body><fo:table-row block-progression-dimension.minimum="14pt"><fo:table-cell text-align="start" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="center" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="right" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:block></fo:static-content><fo:static-content flow-name="xsl-region-before-odd"><fo:block font-family="serif,Symbol,ZapfDingbats" margin-left="0pt"><fo:table table-layout="fixed" width="100%"><fo:table-column column-number="1" column-width="proportional-column-width(1)"/><fo:table-column column-number="2" column-width="proportional-column-width(4)"/><fo:table-column column-number="3" column-width="proportional-column-width(1)"/><fo:table-body><fo:table-row block-progression-dimension.minimum="14pt"><fo:table-cell text-align="start" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="center" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="right" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:block></fo:static-content><fo:static-content flow-name="xsl-region-before-even"><fo:block font-family="serif,Symbol,ZapfDingbats" margin-left="0pt"><fo:table table-layout="fixed" width="100%"><fo:table-column column-number="1" column-width="proportional-column-width(1)"/><fo:table-column column-number="2" column-width="proportional-column-width(4)"/><fo:table-column column-number="3" column-width="proportional-column-width(1)"/><fo:table-body><fo:table-row block-progression-dimension.minimum="14pt"><fo:table-cell text-align="start" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="center" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="right" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:block></fo:static-content><fo:static-content flow-name="xsl-region-before-blank"><fo:block font-family="serif,Symbol,ZapfDingbats" margin-left="0pt"><fo:table table-layout="fixed" width="100%"><fo:table-column column-number="1" column-width="proportional-column-width(1)"/><fo:table-column column-number="2" column-width="proportional-column-width(4)"/><fo:table-column column-number="3" column-width="proportional-column-width(1)"/><fo:table-body><fo:table-row block-progression-dimension.minimum="14pt"><fo:table-cell text-align="start" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="center" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="right" display-align="before" relative-align="baseline"><fo:block/></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:block></fo:static-content><fo:static-content flow-name="xsl-footnote-separator"><fo:block><fo:leader color="black" leader-pattern="rule" leader-length="1in"/></fo:block></fo:static-content><fo:static-content flow-name="blank-body"><fo:block text-align="center"/></fo:static-content><fo:static-content flow-name="xsl-region-after-first"><fo:block font-family="serif,Symbol,ZapfDingbats" margin-left="0pt"><fo:table table-layout="fixed" width="100%"><fo:table-column column-number="1" column-width="proportional-column-width(1)"/><fo:table-column column-number="2" column-width="proportional-column-width(1)"/><fo:table-column column-number="3" column-width="proportional-column-width(1)"/><fo:table-body><fo:table-row block-progression-dimension.minimum="14pt"><fo:table-cell text-align="start" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="center" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="end" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:block></fo:static-content><fo:static-content flow-name="xsl-region-after-odd"><fo:block font-family="serif,Symbol,ZapfDingbats" margin-left="0pt"><fo:table table-layout="fixed" width="100%"><fo:table-column column-number="1" column-width="proportional-column-width(1)"/><fo:table-column column-number="2" column-width="proportional-column-width(1)"/><fo:table-column column-number="3" column-width="proportional-column-width(1)"/><fo:table-body><fo:table-row block-progression-dimension.minimum="14pt"><fo:table-cell text-align="start" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="center" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="end" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:block></fo:static-content><fo:static-content flow-name="xsl-region-after-even"><fo:block font-family="serif,Symbol,ZapfDingbats" margin-left="0pt"><fo:table table-layout="fixed" width="100%"><fo:table-column column-number="1" column-width="proportional-column-width(1)"/><fo:table-column column-number="2" column-width="proportional-column-width(1)"/><fo:table-column column-number="3" column-width="proportional-column-width(1)"/><fo:table-body><fo:table-row block-progression-dimension.minimum="14pt"><fo:table-cell text-align="start" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="center" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="end" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:block></fo:static-content><fo:static-content flow-name="xsl-region-after-blank"><fo:block font-family="serif,Symbol,ZapfDingbats" margin-left="0pt"><fo:table table-layout="fixed" width="100%"><fo:table-column column-number="1" column-width="proportional-column-width(1)"/><fo:table-column column-number="2" column-width="proportional-column-width(1)"/><fo:table-column column-number="3" column-width="proportional-column-width(1)"/><fo:table-body><fo:table-row block-progression-dimension.minimum="14pt"><fo:table-cell text-align="start" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="center" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell><fo:table-cell text-align="end" display-align="after" relative-align="baseline"><fo:block/></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:block></fo:static-content><fo:flow flow-name="xsl-region-body" start-indent="0pt" end-indent="0pt"><fo:block id="EASY-Meta-Programming-with-Rascal"><fo:block font-family="sans-serif,Symbol,ZapfDingbats"><fo:block margin-left="0pt"><fo:block font-size="24.8832pt" font-weight="bold"><fo:block keep-with-next.within-column="always" space-before.optimum="10pt" space-before.minimum="10pt * 0.8" space-before.maximum="10pt * 1.2" hyphenate="false" text-align="center" start-indent="0pt" hyphenation-character="-" hyphenation-push-character-count="2" hyphenation-remain-character-count="2">EASY Meta-Programming with Rascal</fo:block></fo:block><fo:block space-before="0.5em" space-after="0.5em" font-size="14.4pt"><fo:wrapper>
  <fo:block text-align="center" font-size="12pt">Paul Klint, Jurgen Vinju, Tijs van der Storm</fo:block>
      <fo:block> </fo:block>
      <fo:block text-align="center" font-size="10pt">Centrum Wiskunde &amp; Informatica </fo:block>
<fo:block text-align="center" font-size="10pt">and</fo:block>
<fo:block text-align="center" font-size="10pt">University of Amsterdam</fo:block>

    </fo:wrapper></fo:block></fo:block></fo:block></fo:block>

  <fo:block margin-left="0.5in" margin-right="0.5in" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em"><fo:block><fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:inline font-weight="bold">Abstract.</fo:inline> Rascal is a new language
    for meta-programming and is intended to solve problems in the domain of
    source code analysis and transformation. In this article we give a
    high-level overview of the language and illustrate its use by many
    examples. Rascal is a work in progress both regarding implementation and
    documentation. More information is available at <fo:basic-link external-destination="url(http://www.meta-environment.org/Meta-Environment/Rascal)"><fo:inline>http://www.meta-environment.org/Meta-Environment/Rascal</fo:inline></fo:basic-link>.</fo:block><fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:inline font-weight="bold">Key words:</fo:inline> source code analysis,
    source code transformation, meta-programming.</fo:block></fo:block></fo:block>

  <fo:block id="section.why-a-new-language"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">A New Language for Meta-Programming</fo:marker><fo:block font-size="11pt">1. A New Language for Meta-Programming</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
    

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:inline font-style="italic">Meta-programs</fo:inline> are programs that analyze,
    transform or generate other programs. Ordinary programs work on data;
    meta-programs work on programs. The range of programs to which
    meta-programming can be applied is large: from programs in standard
    languages like C and Java to domain-specific languages for describing
    high-level system models or applications in specialized areas like gaming
    or finance. In some cases, even test results or performance data are used
    as input for meta-programs. Rascal is a new language for
    <fo:inline font-style="italic">meta-programming</fo:inline>, this is the activity of writing
    meta-programs.</fo:block>

    <fo:block id="section.EASY-programming"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">The EASY Paradigm</fo:marker><fo:block font-size="10pt">1.1. The EASY Paradigm</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Many meta-programming problems follow a fixed pattern. Starting
      with some input system (a black box that we usually call
      <fo:inline font-style="italic">system-of-interest</fo:inline>), first relevant information is
      extracted from it and stored in an internal representation. This
      internal representation is then analyzed and used to synthesize results.
      If the synthesis indicates this, these steps can be repeated over and
      over again. These steps are shown in <fo:basic-link internal-destination="figure.extract-analyze-synthesize-paradigm"><fo:inline>Figure 1.1, “EASY: the Extract-Analyze-Synthesize Paradigm”</fo:inline></fo:basic-link>.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">This is an abstract view on solving meta-programming problems, but
      is it uncommon? No, so let's illustrate it with a few examples.</fo:block>

      <fo:block id="id1667581"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">1.1.1. Finding security breaches</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:inline font-style="italic">Alice</fo:inline> is system administrator of a large
        online marketplace and she is looking for security breaches in her
        system. The objects-of-interest are the system's log files. First
        relevant entries are extracted. This will include, for instance,
        messages from the SecureShell demon that reports failed login
        attempts. From each entry login name and originating IP address are
        extracted and put in a table (the internal representation in this
        example). These data are analyzed by detecting duplicates and counting
        frequencies. Finally results are synthesized by listing the most
        frequently used login names and IP addresses.</fo:block>

        <fo:block id="figure.extract-analyze-synthesize-paradigm" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.1. EASY: the Extract-Analyze-Synthesize Paradigm</fo:block>
          

          <fo:block id="id1667605"><fo:external-graphic src="url(easy-workflow.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
        </fo:block>
      </fo:block>

      <fo:block id="id1667621"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">1.1.2. A Forensic DSL compiler</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:inline font-style="italic">Bernd</fo:inline> is a senior software engineer working
        at the Berlin headquarters of a forensic investigation lab of the
        German government. His daily work is to find common patterns in files
        stored on digital media that have been confiscated during criminal
        investigations. Text, audio and video files are stored in zillions of
        different data formats and each data format requires its own analysis
        technique. For each new investigation ad hoc combinations of tools are
        used. This makes the process very labour-intensive and error-prone.
        Bernd convinces his manager that designing a new domain-specific
        language (DSL) for forensic investigations may relieve the pressure on
        their lab. After designing the DSL---let's call it DERRICK---he makes
        an EASY implementation for it. Given a DERRICK program for a specific
        case under investigation, he first extracts relevant information from
        it and analyzes it: which media formats are relevant? Which patterns
        to look for? How should search results be combined? Given this new
        information, Java code is synthesized that uses the various existing
        tools and combines their results.</fo:block>
      </fo:block>

      <fo:block id="id812455"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">1.1.3. Renovating Financial Software</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:inline font-style="italic">Charlotte</fo:inline> is software engineer at a large
        financial institution in Paris and she is looking for options to
        connect an old and dusty software system to a web interface. She will
        need to analyze the sources of that system to understand how it can be
        changed to meet the new requirements. The objects-of-interest are in
        this case the source files, documentation, test scripts and any other
        available information. They have to be parsed in some way in order to
        extract relevant information, say the calls between various parts of
        the system. The call information can be represented as a binary
        relation between caller and callee (the internal representation in
        this example). This relation with 1-step calls is analyzed and further
        extended with 2-step calls, 3-step calls and so on. In this way call
        chains of arbitrary length become available. With this new
        information, we can synthesize results by determining the entry points
        of the software system, i.e., the points where calls from the outside
        world enter the system. Having completed this first cycle, Charlotte
        may be interested in which procedures can be called from the entry
        points and so on and so forth. Results will be typically represented
        as pictures that display the relationships that were found. In the
        case of source code analysis, a variation of our workflow scheme is
        quite common. It is then called the extract-analyze-view paradigm and
        is shown in <fo:basic-link internal-destination="figure.extract-analyze-view-paradigm"><fo:inline>Figure 1.2, “The extract-analyze-view paradigm”</fo:inline></fo:basic-link>.</fo:block>

        <fo:block id="figure.extract-analyze-view-paradigm" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.2. The extract-analyze-view paradigm</fo:block>
          

          <fo:block id="id1667648"><fo:external-graphic src="url(extract-analyze-view-paradigm.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
        </fo:block>
      </fo:block>

      <fo:block id="id1667662"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">1.1.4. Finding Concurrency Errors</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:inline font-style="italic">Daniel</fo:inline> is concurrency researcher at one of
        the largest hardware manufacturers worldwide. He is working from an
        office in the Bay Area. Concurrency is the big issue for his company:
        it is becoming harder and harder to make CPUs faster, therefore more
        and more of them are bundled on a single chip. Programming these
        multi-core chips is difficult and many programs that worked fine on a
        single CPU contain hard to detect concurrency errors due to subtle
        differences in the order of execution that results from executing the
        code on more than one CPU. Here is where Daniel enters the picture. He
        is working on tools for finding concurrency errors. First he extracts
        facts from the code that are relevant for concurrency problems and
        have to do with calls, threads, shared variables and locks. Next, he
        analyzes these facts and synthesizes an abstract model that captures
        the essentials of the concurrency behaviour of the program. Finally he
        runs a third-party verification tool with this model as input to do
        the actual verification.</fo:block>
      </fo:block>

      <fo:block id="id1667684"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">1.1.5. Model-driven Engineering</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:inline font-style="italic">Elisabeth</fo:inline> is a software architect at a
        large airplane manufacturer and her concern is reliability and
        dependability of airplane control software. She and her team have
        designed a UML model of the control software and have extended it with
        annotations that describe the reliability of individual components.
        She will use this annotated model in two ways: (a) to extract relevant
        information from it to synthesize input for a statistical tool that
        will compute overall system reliability from the reliability of
        individual components; (b) to generate executable code that takes the
        reliability issues into account.</fo:block>
      </fo:block>
    </fo:block>

    <fo:block id="id1667701"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Rascal</fo:marker><fo:block font-size="10pt">1.2. Rascal</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">With these examples in mind, you have a pretty good picture how
      EASY applies in different use cases. All these cases involve a form of
      <fo:inline font-style="italic">meta-programming</fo:inline>: software programs (in a wide
      sense) are the objects-of-interest that are being analyzed, transformed
      or generated. The Rascal language you are about to learn is designed for
      meta-programming following the EASY paradigm. It can be applied in
      domains ranging from compiler construction and implementing
      domain-specific languages to constraint solving and software
      renovation.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Since representation of information is central to the approach,
      Rascal provides a rich set of built-in data types. To support extraction
      and analysis, parsing and advanced pattern matching are provided.
      High-level control structures make analysis and synthesis of complex
      datastructures simple.</fo:block>
    </fo:block>

    <fo:block id="id1667725"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Benefits of Rascal</fo:marker><fo:block font-size="10pt">1.3. Benefits of Rascal</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Before you spend your time on studying the Rascal language it may
      help to first hear our elevator pitch about the main benefits offered by
      the language:</fo:block>

      <fo:list-block id="id1667735" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1667740" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Familiar</fo:inline> <fo:inline font-weight="bold">syntax</fo:inline> in a <fo:inline font-style="italic">what-you-see
          is-what-you-get style</fo:inline> is used even for sophisticated
          concepts and this makes the language easy to learn and easy to
          use.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667763" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Sophisticated built-in data
          types</fo:inline> provide standard solutions for many
          meta-programming problems.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667776" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Safety</fo:inline> is achieved by finding
          most errors before the program is executed and by making common
          errors like missing initializations or invalid pointers
          impossible.<fo:inline font-style="italic"> At the time of writing, this checking is done
          during execution.</fo:inline></fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667792" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Local type inference</fo:inline> makes
          local variable declarations redundant.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667804" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Pattern matching</fo:inline> can be used
          to analyze all complex datastructures.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667817" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Syntax definitions</fo:inline> make it
          possible to define new and existing languages and to write tools for
          them.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667831" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Visiting</fo:inline> makes it easy to
          traverse datastructures and to extract information from them or to
          synthesize results.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667844" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Templates</fo:inline> enable easy code
          generation.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667855" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Functions as values </fo:inline>permit
          programming styles with high re-use.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667868" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Generic types</fo:inline> allow writing
          functions that are applicable for many different types.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1667881" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Eclipse integration</fo:inline> makes
          Rascal programming a breeze. All familiar tools are at your
          fingertips.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Interested? Read on!</fo:block>
    </fo:block>

    <fo:block id="id1667898"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Aim and Scope of this Article</fo:marker><fo:block font-size="10pt">1.4. Aim and Scope of this Article</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">
        <fo:inline font-weight="bold" keep-with-next.within-line="always" padding-end="1em">Aim. </fo:inline>

        The aim of this article is to give an easy to understand but
        comprehensive overview of the Rascal language and to offer problem
        solving strategies to handle realistic problems that require
        meta-programming. Problems may range from security analysis and model
        extraction to software renovation, domain-specific languages and code
        generation.
      </fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">
        <fo:inline font-weight="bold" keep-with-next.within-line="always" padding-end="1em">Audience. </fo:inline>

        This article is intended for students, practitioners and
        researchers who want to solve meta-programming problems.
      </fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">
        <fo:inline font-weight="bold" keep-with-next.within-line="always" padding-end="1em">Background. </fo:inline>

        Readers should have some background in computer science,
        software engineering or programming languages. Familiarity with
        several main stream programming languages and experience with larger
        software projects will make it easier to appreciate the relevance of
        the meta-programming domain that Rascal is addressing. Some
        familiarity with concepts like sets, relations and pattern matching is
        assumed.
      </fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">
        <fo:inline font-weight="bold" keep-with-next.within-line="always" padding-end="1em">Scope. </fo:inline>

        The scope of this article is limited to the Rascal language and
        its applications but does not address implementation aspects of the
        language.
      </fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">
        <fo:inline font-weight="bold" keep-with-next.within-line="always" padding-end="1em">Related Work. </fo:inline>

        Rascal owes a lot to other languages that aim at
        meta-programming, in particular the user-defined, modular, syntax and
        term rewriting of ASF+SDF [<fo:basic-link internal-destination="Klint93">Kli93</fo:basic-link>], [<fo:basic-link internal-destination="BDHJJKKMOSVVV01">BDH+01</fo:basic-link>], the relational calculus as used in
        Rscript [<fo:basic-link internal-destination="KlintRscript">Kli08</fo:basic-link>] and pioneered by GROK
        [<fo:basic-link internal-destination="Grok">Hol08</fo:basic-link>], traversal functions as introduced in
        [<fo:basic-link internal-destination="BKV03">BKV03</fo:basic-link>], strategies as introduced in ELAN
        [<fo:basic-link internal-destination="ElanBKKMR-wrla98">BKK+98</fo:basic-link>] and Stratego [<fo:basic-link internal-destination="BKVV08">BKVV08</fo:basic-link>], and integration of term rewriting in Java as done
        in TOM [<fo:basic-link internal-destination="BallandBKMR-RTA2007">BBK+07</fo:basic-link>]. We also
        acknowledge less specific influences by systems like TXL [<fo:basic-link internal-destination="CordyTXL06">Cor06</fo:basic-link>], ANTLR [<fo:basic-link internal-destination="ANTLRBook">Par07</fo:basic-link>],
        JastAdd [<fo:basic-link internal-destination="HedinMagnusson03">HM03</fo:basic-link>], Semmle [<fo:basic-link internal-destination="Semmle.QL">dMSV+08</fo:basic-link>], DMS [<fo:basic-link internal-destination="DMS">BPM04</fo:basic-link>], and various
        others. A first application of Rascal in the domain of refactoring is
        described in [<fo:basic-link internal-destination="KSV-SCAM09">KvdSV09</fo:basic-link>].
      </fo:block>
    </fo:block>

    <fo:block id="id1668043"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Downloading, Installing and Running Rascal</fo:marker><fo:block font-size="10pt">1.5. Downloading, Installing and Running Rascal</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">See http://www.meta-environment.org/Meta-Environment/Rascal for
      information.</fo:block>
    </fo:block>

    <fo:block id="id1668056"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Reading Guide</fo:marker><fo:block font-size="10pt">1.6. Reading Guide</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.structure-manual" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.3. Structure of the Rascal Description</fo:block>
          

          <fo:block id="id1668072"><fo:external-graphic src="url(manual-structure.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
        </fo:block>The structure of the description of Rascal is shown in <fo:basic-link internal-destination="figure.structure-manual"><fo:inline>Figure 1.3, “Structure of the Rascal Description”</fo:inline></fo:basic-link>. This article provides the first
      three parts:</fo:block>

      <fo:list-block id="id1668095" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1668097" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Introduction</fo:inline>: gives a
          high-level overview of Rascal and consists of <fo:basic-link internal-destination="section.why-a-new-language"><fo:inline>Section 1, “A New Language for Meta-Programming”</fo:inline></fo:basic-link> and <fo:basic-link internal-destination="section.rascal-concepts"><fo:inline>Section 2, “Rascal Concepts”</fo:inline></fo:basic-link> . It also presents some simple
          examples in <fo:basic-link internal-destination="section.classical-examples"><fo:inline>Section 3, “Some Classical Examples”</fo:inline></fo:basic-link>.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1668126" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Problem Solving</fo:inline>: describes
          the major problem solving strategies in Rascal's application domain,
          see <fo:basic-link internal-destination="section.problem-solving-strategies"><fo:inline>Section 4, “Problem Solving Strategies”</fo:inline></fo:basic-link>.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1668143" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Examples</fo:inline>: gives a collection
          of larger examples, see <fo:basic-link internal-destination="section.more-examples"><fo:inline>Section 5, “Larger Examples”</fo:inline></fo:basic-link>.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The other parts can be found <fo:basic-link external-destination="url(http://www.meta-environment.org/doc/books//analysis/rascal-manual/rascal-manual.pdf)"><fo:inline>online</fo:inline></fo:basic-link><fo:inline hyphenate="false"> [<fo:basic-link external-destination="url(http://www.meta-environment.org/doc/books//analysis/rascal-manual/rascal-manual.pdf)">http://www.meta-environment.org/doc/books//analysis/rascal-manual/rascal-manual.pdf</fo:basic-link>]</fo:inline>:</fo:block>

      <fo:list-block id="id1668169" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1668171" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Reference</fo:inline>: gives a detailed
          description of the Rascal language, and all built-in operators and
          library functions.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1668184" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Support</fo:inline>: gives tables with
          operators and library functions, a bibliography and a glossary that
          explains many concepts that are used in the descriptions of Rascal
          and tries to make them self-contained.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
    </fo:block>

    <fo:block id="id1668199"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Typographic Conventions</fo:marker><fo:block font-size="10pt">1.7. Typographic Conventions</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal code fragments are always shown as a listing like
      this:<fo:block id="id1668206" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">  .. here is some Rascal code ...</fo:block>Interactive
      sessions are show as a screen like this:<fo:block id="id1668209" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace"><fo:inline font-style="italic" font-family="monospace">Command</fo:inline>;</fo:inline>
<fo:inline font-family="monospace"><fo:inline font-style="italic" font-family="monospace">Type</fo:inline>: <fo:inline font-style="italic" font-family="monospace">Value</fo:inline></fo:inline></fo:block>where:</fo:block>

      <fo:list-block id="id1668228" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1668230" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-family="monospace">rascal&gt;</fo:inline> is the prompt of the Rascal
          system.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1668238" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold" font-family="monospace">Command</fo:inline> is an arbitrary Rascal
          statement or declaration typed in by the user.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1668247" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-family="monospace">Type: Value</fo:inline> is the type of
          the answer followed by the value of the answer as computed by
          Rascal. In some cases, the response will simply be
          <fo:inline font-family="monospace">ok</fo:inline> when there is no other
          meaningful answer to give.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
    </fo:block>
  </fo:block>

  <fo:block id="section.rascal-concepts"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Rascal Concepts</fo:marker><fo:block font-size="11pt">2. Rascal Concepts</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
    

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Before explaining the Rascal language in more detail, we detail our
    elevator pitch a bit and give you a general understanding of the concepts
    on which the language is based.</fo:block>

    <fo:block id="id1668280"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Values</fo:marker><fo:block font-size="10pt">2.1. Values</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Values are the basic building blocks of a language and the type of
      values determines how they may be used.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal is a value-oriented language. This means that values are
      immutable and are always freshly constructed from existing parts and
      that sharing and aliasing problems are completely avoided. The language
      also provides variables. A value can be associated with a variable as
      the result of an explicit assignment statement: during the lifetime of a
      variable different (immutable) values may be assignment to it. Other
      ways to associate a value with a variable is by way of function calls
      (binding of formal parameters to actual values) and as the result of a
      successful pattern match.</fo:block>
    </fo:block>

    <fo:block id="id1668300"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Data structures</fo:marker><fo:block font-size="10pt">2.2. Data structures</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal provides a rich set of datatypes. From Booleans
      (bool), infinite precision integers
      (int) and reals (real) to strings
      (str) that can act as templates with embedded
      expressions and statements. From source code locations
      (loc) based on an extension of Universal Resource
      Identifiers (URI) that allow precise description of text areas in local
      and remote files to lists (list), optionally labelled
      tuples (tuple), sets (set), and
      optionally labelled maps (map) and relations
      (rel). From untyped tree structures
      (node) to fully typed datastructures. Syntax trees that
      are the result of parsing source files are represented as datatypes
      (Tree). There is a wealth of built-in operators and
      library functions available on the standard datatypes. The basic Rascal
      datatypes are illustrated in <fo:basic-link internal-destination="table.types"><fo:inline>Table 1.1, “Basic Rascal Types”</fo:inline></fo:basic-link>.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">These builtin datatypes are closely related to each other:</fo:block>

      <fo:list-block id="id1668373" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1668377" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>In a list all elements have the same static type and the order
          of elements matters. A list may contain the same value more than
          once.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1668385" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>In a set all elements have the same static type and the order
          of elements does not matter. A set contains an element only once. In
          other words, duplicate elements are eliminated and no matter how
          many times an element is added to a set, it will occur in it only
          once.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1668395" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>In a tuple alle elements (may) have a different static type.
          Each element of a tuple may have a label that can be used to select
          that element of the tuple.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1668404" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>A relation is a set of tuples which all have the same static
          tuple type.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1668412" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>A map is an asosciative table of (key, value) pairs. Key and
          value (may) have different static type and a key can only be
          associated with a value once</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Untyped trees can be constructed with the builtin type <fo:inline font-weight="bold">node</fo:inline>. User-defined algebraic datatypes allow the
      introduction of problem-specific types and are a subtype of <fo:inline font-weight="bold">node</fo:inline>. A fragment of the abstract syntax for
      statements (assignment, if, while) in a programming language would look
      as follows:<fo:block id="id1668430" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">data STAT = asgStat(Id name, EXP exp)
          | ifStat(EXP exp,list[STAT] thenpart,
                           list[STAT] elsepart) 
          | whileStat(EXP exp, list[STAT] body)
          ;</fo:block><fo:block id="table.types" keep-together="auto" keep-together.within-column="auto" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Table 1.1. Basic Rascal Types</fo:block><fo:table border-before-width.conditionality="retain" border-collapse="collapse" border-start-style="solid" border-end-style="solid" border-top-style="solid" border-bottom-style="solid" border-start-width="0.5pt" border-end-width="0.5pt" border-top-width="0.5pt" border-bottom-width="0.5pt" border-start-color="black" border-end-color="black" border-top-color="black" border-bottom-color="black" table-layout="fixed" width="100%"><fo:table-column column-number="1" column-width="proportional-column-width(2)"/><fo:table-column column-number="2" column-width="proportional-column-width(5)"/><fo:table-header xmlns:rx="http://www.renderx.com/XSL/Extensions" start-indent="0pt" end-indent="0pt"><fo:table-row keep-with-next.within-column="always"><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block font-weight="bold">Type </fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block font-weight="bold">Examples </fo:block></fo:table-cell></fo:table-row></fo:table-header><fo:table-body xmlns:rx="http://www.renderx.com/XSL/Extensions" start-indent="0pt" end-indent="0pt"><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">bool</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">true</fo:inline>,
                <fo:inline font-family="monospace">false</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">int</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">1</fo:inline>, <fo:inline font-family="monospace">0</fo:inline>,
                <fo:inline font-family="monospace">-1</fo:inline>, <fo:inline font-family="monospace">123456789</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">real</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">1.0</fo:inline>,
                <fo:inline font-family="monospace">1.0232e20</fo:inline>,<fo:inline font-family="monospace"> -25.5</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">str</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">"abc"</fo:inline>,
                <fo:inline font-family="monospace">"first\nnext"</fo:inline>, <fo:inline font-family="monospace">"result:
                &lt;X&gt;"</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">loc</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">|file:///etc/passwd|</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">tuple[<fo:inline font-style="italic" font-family="monospace">T</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline>,...,<fo:inline font-style="italic" font-family="monospace">T</fo:inline><fo:inline font-size="75%" baseline-shift="sub">n</fo:inline>]</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">&lt;1,2&gt;</fo:inline>, <fo:inline font-family="monospace">&lt;"john",
                43, true&gt;</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">list[<fo:inline font-style="italic" font-family="monospace">T</fo:inline>]</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">[]</fo:inline>, <fo:inline font-family="monospace">[1]</fo:inline>,
                <fo:inline font-family="monospace">[1,2,3]</fo:inline>, <fo:inline font-family="monospace">[true, 2,
                "abc"]</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">set[<fo:inline font-style="italic" font-family="monospace">T</fo:inline>]</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">{}</fo:inline>,
                <fo:inline font-family="monospace">{1,2,3,5,7}</fo:inline>,<fo:inline font-family="monospace"> {"john",
                4.0}</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">rel[</fo:inline><fo:inline font-family="monospace"><fo:inline font-style="italic" font-family="monospace">T</fo:inline></fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline><fo:inline font-family="monospace">,...,</fo:inline><fo:inline font-style="italic" font-family="monospace">T</fo:inline><fo:inline font-size="75%" baseline-shift="sub">n</fo:inline>]</fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">{&lt;1,2&gt;,&lt;2,3&gt;,&lt;1,3&gt;}</fo:inline>,
                <fo:inline font-family="monospace">{&lt;1,10,100&gt;,
                &lt;2,20,200&gt;}</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">map[<fo:inline font-style="italic" font-family="monospace">T</fo:inline>,
                <fo:inline font-style="italic" font-family="monospace">U</fo:inline>]</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-bottom-width="0.5pt" border-bottom-style="solid" border-bottom-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">()</fo:inline>, <fo:inline font-family="monospace">(1:true,
                2:false)</fo:inline>, <fo:inline font-family="monospace">("a":1, "b":2)</fo:inline></fo:block></fo:table-cell></fo:table-row><fo:table-row><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" border-end-width="0.5pt" border-end-style="solid" border-end-color="black" text-align="left"><fo:block><fo:inline font-family="monospace">node</fo:inline></fo:block></fo:table-cell><fo:table-cell padding-start="2pt" padding-end="2pt" padding-top="2pt" padding-bottom="2pt" text-align="left"><fo:block><fo:inline font-family="monospace">f()</fo:inline>, <fo:inline font-family="monospace">add(x,y)</fo:inline>,
                <fo:inline font-family="monospace">g("abc", [2,3,4])</fo:inline></fo:block></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:block></fo:block>
    </fo:block>

    <fo:block id="id1668761"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Pattern Matching</fo:marker><fo:block font-size="10pt">2.3. Pattern Matching</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Pattern matching determines whether a given pattern matches a
      given value. The outcome can be false (no match) or true (a match). A
      pattern match that succeeds may bind values to variables.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Pattern matching is <fo:inline font-style="italic">the</fo:inline> mechanism for case
      distinction (switch statement) and search
      (visit statement) in Rascal. Patterns can also be used
      in an explicit match operator <fo:inline font-family="monospace">:=</fo:inline> and can then be part
      of larger boolean expressions. Since a pattern match may have more than
      one solution, local backtracking over the alternatives of a match is
      provided. Patterns can also be used in enumerators and control
      structures like for and while
      statement.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">A very rich pattern language is provided that includes string
      matching based on regular expressions, matching of abstract patterns,
      and matching of concrete syntax patterns. Some of the features that are
      provided are list (associative) matching, set (associative, commutative,
      idempotent) matching, and deep matching of descendant patterns. All
      these forms of matching can be used in a single pattern and can be
      nested. Patterns may contain variables that are bound when the match is
      successful. Anonymous (don't care) positions are indicated by the
      underscore (<fo:inline font-family="monospace">_</fo:inline>).</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Here is a <fo:inline font-style="italic">regular expression</fo:inline> that matches a
      line of text, finds the first alphanumeric word in it, and extracts the
      word itself as well as the before and after it (<fo:inline font-family="monospace">\W</fo:inline>
      matches all non-word characters; <fo:inline font-family="monospace">\w</fo:inline> matches all word
      characters):</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1668831" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">/^&lt;before:\W*&gt;&lt;word:\w+&gt;&lt;after:.*$&gt;/</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Regular expressions follow the Java regular expression syntax with
      one exception: instead of using numbered groups to refer to parts of the
      subject string that have been matched by a part of the regular
      expression we use the notation:<fo:block id="id1668839" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">&lt;<fo:inline font-style="italic" font-family="monospace">Name</fo:inline>:<fo:inline font-style="italic" font-family="monospace">RegularExpression</fo:inline>&gt;</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">If <fo:inline font-style="italic" font-family="monospace">RegularExpression</fo:inline> matches, the
      matched substring is assigned to string variable
      <fo:inline font-style="italic" font-family="monospace">Name</fo:inline>.</fo:block>

      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The following <fo:inline font-style="italic">abstract pattern</fo:inline> matches the
      abstract syntax of a while statement defined earlier: <fo:block id="id1668870" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">whileStat(EXP Exp, list[STAT] Stats)</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Variables in a pattern are either explicitly declared in the
      pattern itself---as done in the example---or they may be declared in the
      context in which the pattern occurs. So-called
      <fo:inline font-style="italic">multi-variables</fo:inline> in list and set patterns are
      declared by a <fo:inline font-family="monospace">*</fo:inline> suffix: <fo:inline font-family="monospace">X*</fo:inline> is thus
      an abbreviation for <fo:inline font-family="monospace">list[...] X</fo:inline> or <fo:inline font-family="monospace">set[...]
      X</fo:inline>, where the precise element type depends on the context. The
      above pattern can then be written as</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1668900" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">whileStat(EXP Exp, Stats*)</fo:block>or, if
      you are not interested in the actual value of the statements as</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1668906" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">whileStat(EXP Exp, _*)</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">When there is a grammar for this example language (in the form of
      an imported SDF definition), we can also write <fo:inline font-style="italic">concrete
      patterns</fo:inline> as we will see below.</fo:block>
    </fo:block>

    <fo:block id="id1668919"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Enumerators</fo:marker><fo:block font-size="10pt">2.4. Enumerators</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Enumerators enumerate the values in a given (finite) domain, be it
      the elements in a list, the substrings of a string, or all the nodes in
      a tree. Each value that is enumerated is first matched against a pattern
      before it can possibly contribute to the result of the enumerator.
      Examples are:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1668932" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">int x &lt;- { 1, 3, 5, 7, 11 }
int x &lt;- [ 1 .. 10 ]
/asgStat(Id name, _) &lt;- P</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The first two produce the integer elements of a set of integers,
      respectively, a range of integers. Observe that the left-hand side of an
      enumerator is a pattern, of which <fo:inline font-family="monospace">int x</fo:inline> is a specific
      instance. The use of more general patterns is illustrated by the third
      enumerator that does a deep traversal (as denoted by the descendant
      operator <fo:inline font-family="monospace">/</fo:inline>) of the complete program
      <fo:inline font-family="monospace">P</fo:inline> (that is assumed to have a
      <fo:inline font-family="monospace">PROGRAM</fo:inline> as value) and only yields statements that
      match the assignment pattern (<fo:inline font-family="monospace">asgStat</fo:inline>) we have seen
      earlier. Note the use of an anonymous variable at the
      <fo:inline font-family="monospace">EXP</fo:inline> position in the pattern.</fo:block>
    </fo:block>

    <fo:block id="id1668968"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Comprehensions</fo:marker><fo:block font-size="10pt">2.5. Comprehensions</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Comprehensions are a notation inspired by mathematical set-builder
      notation that helps to write succinct definitions of lists and sets.
      They are also inspired by queries as found in a language like
      SQL.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal generalizes comprehensions in various ways. Comprehensions
      exist for lists, sets and maps. A comprehension consists of an
      expression that determines the successive elements to be included in the
      result and a list of enumerators and tests (boolean expressions). The
      enumerators produce values and the tests filter them. A standard example
      is</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1668988" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">{ x * x | int x &lt;- [1 .. 10], x % 3 == 0 }</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">which returns the set <fo:inline font-family="monospace">{9, 36, 81}</fo:inline>, i.e., the
      squares of the integers in the range <fo:inline font-family="monospace">[ 1 .. 10 ]</fo:inline> that
      are divisible by 3. A more intriguing example is</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1669007" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">{name | /asgStat(Id name, _) &lt;- P}</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">which traverses program <fo:inline font-family="monospace">P</fo:inline> and constructs a set
      of all identifiers that occur on the left hand side of assignment
      statements in <fo:inline font-family="monospace">P</fo:inline>.</fo:block>
    </fo:block>

    <fo:block id="id1669022"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Control structures</fo:marker><fo:block font-size="10pt">2.6. Control structures</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Control structures like <fo:inline font-family="monospace">if</fo:inline> and
      <fo:inline font-family="monospace">while</fo:inline> statement are driven by Boolean expressions,
      for instance<fo:block id="id1669041" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">if(N &lt;= 0)
     return 1; 
  else
     return N * fac(N - 1);</fo:block>Actually, combinations of
      generators and Boolean expressions can be used to drive the control
      structures. For instance,</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1669048" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">
for(/asgStat(Id name, _) &lt;- P, size(name) &gt; 10){
    println(name);
}</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">prints all identifiers in assignment statements
      (<fo:inline font-family="monospace">asgStat</fo:inline>) that consist of more than 10
      characters.</fo:block>
    </fo:block>

    <fo:block id="id1669059"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Case Distinction</fo:marker><fo:block font-size="10pt">2.7. Case Distinction</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The switch statement as known from C and Java is generalized: the
      subject value to switch on may be an arbitrary value and the cases are
      arbitrary patterns followed by a statement. Each case is comparable to a
      <fo:inline font-style="italic">transaction</fo:inline>: when the pattern succeeds and the
      following statement is executed successfully, all changes to variables
      made by the statement are <fo:inline font-style="italic">committed</fo:inline> and thus become
      permanent. The variables bound by the pattern are always local to the
      statement associated with the case. When a match fails or when the
      associated statement fails, a <fo:inline font-style="italic">rollback</fo:inline> takes place
      and all side-effects are undone. External side-effects like I/O and
      side-effects in user-defined Java code are not undone. Here is an
      example where we take a program P and distinguish two cases for while
      and if statement:<fo:block id="id1669090" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">switch (P){
case whileStat(_, _):
     println("A while statement");
case ifStat(_, _, _):
     println("An if statement");
}</fo:block></fo:block>
    </fo:block>

    <fo:block id="id1669095"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Visiting</fo:marker><fo:block font-size="10pt">2.8. Visiting</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Visiting the elements of a datastructure is one of the most common
      operations in our domain and the visitor design pattern is a solution
      known to every software engineer. Given a tree-like datastructure we
      want to perform an operation on some (or all) nodes of the tree. The
      purpose of the visitor design pattern is to decouple the logistics of
      visiting each node from the actual operation on each node. In Rascal the
      logistics of visiting is completely automated.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Visiting is achieved by way of visit expressions that resemble the
      switch statement. A visit expressions traverses an arbitrarily complex
      subject value and applies a number of cases to all its subtrees. All the
      elements of the subject are visited and when one of the cases matches
      the statements associated with that case are executed. These cases
      may:</fo:block>

      <fo:list-block id="id1669117" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1669119" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>cause some side effect, i.e., assign a value to local or
          global variables;</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669128" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>execute an <fo:inline font-family="monospace">insert</fo:inline> statement that replaces
          the current element;</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669140" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>execute a <fo:inline font-family="monospace">fail</fo:inline> statement that causes the
          match for the current case to fail (and undoing all side-effects due
          to the successful match itself and the execution of the statements
          so far).</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The value of a visit expression is the original subject value with
      all replacements made as dictated by matching cases. The traversal order
      in a visit expressions can be explicitly defined by the programmer. An
      example of visiting is given below and in <fo:basic-link internal-destination="section.colored-trees"><fo:inline>Section 3.3, “Colored Trees”</fo:inline></fo:basic-link>.</fo:block>
    </fo:block>

    <fo:block id="id1669166"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Functions</fo:marker><fo:block font-size="10pt">2.9. Functions</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Functions allow the definition of frequently used operations. They
      have a name and formal parameters. They are explicitly declared and are
      fully typed. Here is an example of a function that counts the number of
      assignment statements in a program:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1669180" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">int countAssignments(PROGRAM P){
    int n = 0;
    visit (P){
    case asgStat(_, _):
         n += 1;
    }
    return n;
}</fo:block>Functions can also be used as values thus enabling
      higher-order functions. Consider the following
      declarations:<fo:block id="id1669187" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">int double(int x) { return 2 * x; }

int triple(int x) { return 3 * x; }

int f(int x, int (int) multi){ return multi(x); }</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The functions double and triple simply multiply their argument
      with a constant. Function f is, however, more interesting. It takes an
      integer <fo:inline font-family="monospace">x</fo:inline> and a function <fo:inline font-family="monospace">multi</fo:inline>
      (with integer argument and integer result) as argument and applies
      <fo:inline font-family="monospace">multi</fo:inline> to its own argument. <fo:inline font-family="monospace">f(5,
      triple)</fo:inline> will hence return <fo:inline font-family="monospace">15</fo:inline>. Function
      values can also be created anonymously as illustrated by the following,
      alternative, manner of writing this same call to f:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1669216" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">f(5, int (int y){return 3 * y;});</fo:block>Here
      the second argument of f is an anonymous function.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal is a higher-order language in which functions are
      first-class values.</fo:block>
    </fo:block>

    <fo:block id="section.syntax-defintion-and-parsing"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Syntax Definition and Parsing</fo:marker><fo:block font-size="10pt">2.10. Syntax Definition and Parsing</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">All source code analysis projects need to extract information
      directly from the source code. There are two main approaches to
      this:</fo:block>

      <fo:list-block id="id1669226" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1669243" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-style="italic">Lexical information</fo:inline>: Use regular
          expressions to extract useful, but somewhat superficial, flat,
          information. This can be achieved using regular expression
          patterns.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669256" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-style="italic">Structured information</fo:inline>: Use syntax
          analysis to extract the complete, nested, structure of the source
          code in the form of a syntax tree.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">In Rascal, we reuse the Syntax Definition Formalism (SDF) and its
      tooling. See <fo:basic-link external-destination="url(http://www.meta-environment.org/Meta-Environment/Documentation)"><fo:inline>http://www.meta-environment.org/Meta-Environment/Documentation</fo:inline></fo:basic-link>
      for tutorials and manuals for SDF.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">SDF modules define grammars and these modules can be imported in a
      Rascal module. These grammar rules can be applied in writing concrete
      patterns to match parts of parsed source code. Here is an example of the
      same pattern we saw above, but now in concrete form:<fo:block id="id1669286" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">while &lt;Exp&gt; do &lt;Stats&gt; od</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Importing an SDF module has the following effects:</fo:block>

      <fo:list-block id="id1669291" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1669294" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>All non-terminals (<fo:inline font-style="italic">sorts</fo:inline> in SDF jargon)
          that are used in the imported grammar are implicitly declared as
          Rascal types. For each SDF sort <fo:inline font-style="italic" font-family="monospace">S</fo:inline> also
          composite symbols like
          <fo:inline font-family="monospace"><fo:inline font-style="italic" font-family="monospace">S</fo:inline>*</fo:inline>,
          <fo:inline font-family="monospace">{<fo:inline font-style="italic" font-family="monospace">S</fo:inline> ","}+</fo:inline> also become
          available as type. This makes it possible to handle parse trees and
          parse tree fragments as fully typed values and assign them to
          variables, store them in larger datastructures or pass them as
          arguments to functions and use them in pattern matching.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669329" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>For all <fo:inline font-style="italic">start symbols</fo:inline> of the grammar
          <fo:inline font-style="italic">parse functions</fo:inline> are implicitly declared that
          can parse source files according to a specific start symbol.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669344" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Concrete syntax patterns for that specific grammar can be
          used.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669351" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Concrete syntax constructors can be used that allow the
          construction of new parse trees.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The following example parses a Java compilation unit from a text
      file and counts the number of method declarations:</fo:block>

      <fo:block id="id1669365" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module Count
import languages::java::syntax::Java;
import ParseTree;

public int countMethods(loc file){
  int n = 0;
  for(/MethodDeclaration md &lt;- parse(#CompilationUnit, 
                                     file))
      n += 1;
  return n;
}</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">First observe that importing the Java grammar has as effect that
      non-terminals like <fo:inline font-family="monospace">MethodDeclaration</fo:inline> and
      <fo:inline font-family="monospace">CompilationUnit</fo:inline> become available as type in the
      Rascal program.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The implicitly declared function <fo:inline font-family="monospace">parse</fo:inline> takes a
      reified type (<fo:inline font-family="monospace">#CompilationUnit</fo:inline>) and a location as
      arguments and parses the contents of the location according to the given
      non-terminal. Next, a match for embedded
      <fo:inline font-family="monospace">MethodDeclaration</fo:inline>s is done in the enumetrator of the
      for statement. This example ignores many potential
      error conditions but does illustrate some of Rascal's syntax and parsing
      features.</fo:block>
    </fo:block>

    <fo:block id="id1669398"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Rewrite Rules</fo:marker><fo:block font-size="10pt">2.11. Rewrite Rules</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">A <fo:inline font-style="italic">rewrite rule</fo:inline> is a recipe on how to simplify
      values. Remember: <fo:inline font-family="monospace">(a + b)<fo:inline font-size="75%" baseline-shift="super">2</fo:inline> =
      a<fo:inline font-size="75%" baseline-shift="super">2</fo:inline> + 2ab +
      b<fo:inline font-size="75%" baseline-shift="super">2</fo:inline></fo:inline>? A rewrite rule has a pattern as
      left-hand side (here: <fo:inline font-family="monospace">(a +
      b)<fo:inline font-size="75%" baseline-shift="super">2</fo:inline></fo:inline>) and a replacement as
      right-hand side (here: <fo:inline font-family="monospace">a<fo:inline font-size="75%" baseline-shift="super">2</fo:inline> + 2ab +
      b<fo:inline font-size="75%" baseline-shift="super">2</fo:inline></fo:inline>). Given a value and a set of
      rewrite rules the patterns are tried on every subpart of the value and
      replacements are made if a match is successful. This is repeated as long
      as some pattern matches.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rewrite rules are the only implicit control mechanism in the
      language and are used to maintain invariants during computations. For
      example, in a package for symbolic differentiation it is desirable to
      keep expressions in simplified form in order to avoid intermediate
      results like <fo:inline font-family="monospace">sum(product(num(1), x), product(num(0),
      y))</fo:inline> that can be simplified to <fo:inline font-family="monospace">x</fo:inline>. The
      following rules achieve this:<fo:block id="id1669465" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">rule simplify1 product(num(1), Expression e) =&gt; e;
rule simplify2 product(Expression e, num(1)) =&gt; e;
rule simplify3 product(num(0), Expression e) =&gt; num(0);
rule simplify4 product(Expression e, num(0)) =&gt; num(0);
rule simplify5 sum(num(0), Expression e)     =&gt; e;
rule simplify6 sum(Expression e, num(0))     =&gt; e;</fo:block>Whenever
      a new expression is constructed during symbolic differentiation, these
      rules are <fo:inline font-style="italic">implicitly</fo:inline> applied to that expression and
      all its subexpressions and when a pattern at the left-hand side of a
      rule applies the matching subexpression is replaced by the right-hand
      side of the rule. This is repeated as long as any rule can be
      applied.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Since rewrite rules are activated automatically, one may always
      assume that expressions are in simplified form.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rewrite rules are <fo:inline font-style="italic">Turing complete</fo:inline>, in other
      words any computable function can be defined using rewrite rules,
      including functions that do not terminate. This is a point of attention
      when using rewrite rules.</fo:block>
    </fo:block>

    <fo:block id="id1669491"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Equation Solving</fo:marker><fo:block font-size="10pt">2.12. Equation Solving</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Many problems can be solved by forms of <fo:inline font-style="italic">constraint
      solving</fo:inline>. This is a declarative way of programming: specify
      the constraints that a problem solution should satisfy and how potential
      solutions can be generated. The actual solution (if any) is found by
      enumerating solutions and testing their compliance with the
      constraints.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal provides a <fo:inline font-family="monospace">solve</fo:inline> statement that helps
      writing constraint solvers. A typical example is dataflow analysis where
      the propagation of values through a program can be described by a set of
      equations. Their solution can be found with the <fo:inline font-family="monospace">solve</fo:inline>
      statement. See <fo:basic-link internal-destination="section.dataflow"><fo:inline>Section 5.6, “Dataflow Analysis”</fo:inline></fo:basic-link> for examples.</fo:block>
    </fo:block>

    <fo:block id="id1669528"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Other features</fo:marker><fo:block font-size="10pt">2.13. Other features</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">All language features (including the ones just mentioned) are
      described in more detail later on in this article. Some features we have
      not yet mentioned are:</fo:block>

      <fo:list-block id="id1669538" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1669541" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Rascal programs consist of modules that are organized in
          packages.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669552" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Modules can import other modules. These can be Rascal modules
          or SDF modules (as shown above in <fo:basic-link internal-destination="section.syntax-defintion-and-parsing"><fo:inline>Section 2.10, “Syntax Definition and Parsing”</fo:inline></fo:basic-link>).</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669566" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The visibility of entities declared in modules can be
          controlled using public/private
          modifiers.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669562" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Datastructures may have annotations that can be explicitly
          used and modified.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669587" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>There is an extensive library for builtin datatypes,
          input/output, fact extraction from Java source code, visualization,
          and more.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
    </fo:block>

    <fo:block id="id1669597"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Typechecking and Execution</fo:marker><fo:block font-size="10pt">2.14. Typechecking and Execution</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal has a statically checked type system that prevents type
      errors and uninitialized variables at runtime. There are no runtime type
      casts as in Java and there are therefore less opportunities for run-time
      errors. The language provides <fo:inline font-style="italic">higher-order, parametric
      polymorphism</fo:inline>. A type aliasing mechanism allows documenting
      specific uses of a type. Built-in operators are heavily overloaded. For
      instance, the operator + is used for addition on integers and reals but
      also for list concatenation, set union etc.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The flow of Rascal program execution is completely explicit.
      Boolean expressions determine choices that drive the control structures.
      Rewrite rules form the only exception to the explicit control flow
      principle. Only local backtracking is provided in the context of boolean
      expressions and pattern matching; side effects are undone in case of
      backtracking.</fo:block>
    </fo:block>
  </fo:block>

  <fo:block id="section.classical-examples"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Some Classical Examples</fo:marker><fo:block font-size="11pt">3. Some Classical Examples</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
    

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The following simple examples will help you to grasp the main
    features of Rascal quickly. You can also consult the online documentation
    at <fo:basic-link external-destination="url(http://www.meta-environment.org/Meta-Environment/Rascal)"><fo:inline>http://www.meta-environment.org/Meta-Environment/Rascal</fo:inline></fo:basic-link>
    for details of the language or specific operators or functions.</fo:block>

    <fo:block id="id1669645"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Hello</fo:marker><fo:block font-size="10pt">3.1. Hello</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The ubiquitous hello world program looks in Rascal as
      follows:<fo:block id="id1669655" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import IO;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">println("Hello world, my first Rascal program");</fo:inline>
<fo:inline font-family="monospace">Hello world, my first Rascal program
ok</fo:inline>
</fo:block>First, the library module IO is imported since hello world requires
      printing. Next, we call <fo:inline font-family="monospace">println</fo:inline> and proudly observe
      our first Rascal output!</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">A slightly more audacious approach is to wrap the print statement
      in a function and call it:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1669694" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt; </fo:inline><fo:inline font-weight="bold" font-family="monospace">void hello() {
   println("Hello world, my first Rascal program");
}</fo:inline>
<fo:inline font-family="monospace">void (): void hello();</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">hello();</fo:inline>
<fo:inline font-family="monospace">Hello world, my first Rascal program
ok</fo:inline></fo:block>Don't get scared by the <fo:inline font-family="monospace">void ():
      void hello();</fo:inline> that you get back when typing in the
      <fo:inline font-family="monospace">hello</fo:inline> function. The first <fo:inline font-family="monospace">void
      ()</fo:inline> part says the result is a function that returns
      nothing, and the second part <fo:inline font-family="monospace">void
      hello()</fo:inline> summarizes its value (or would you prefer a hex
      dump?).</fo:block>

      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The summit of hello-engineering can be reached by placing all the
      above in a separate module:<fo:block id="id1669741" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::Hello
import IO;

public void hello() {
   println("Hello world, my first Rascal program");
}</fo:block>Note that we added a public modifier to the definition of
      hello, since we want it to be visible outside the Hello module. Using
      this Hello module is now simple:<fo:block id="id1669747" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import demo::Hello;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">hello();</fo:inline>
<fo:inline font-family="monospace">Hello world, my first Rascal program
ok</fo:inline></fo:block></fo:block>
    </fo:block>

    <fo:block id="id1669771"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Factorial</fo:marker><fo:block font-size="10pt">3.2. Factorial</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Here is another classical example, computing the factorial
      function:<fo:block id="id1669781" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::Factorial

public int fac(int N)
{
  if(N &lt;= 0)
     return 1; 
  else
     return N * fac(N - 1);
}</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">It uses a conditional statement to distinguish cases and here is
      how to use it:<fo:block id="id1669788" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import demo::Factorial;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">fac(47);</fo:inline>
<fo:inline font-family="monospace">int: 25862324151116818064296435515361197996919763238912000
0000000</fo:inline></fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Indeed, Rascal has arbitrary length integers.</fo:block>
    </fo:block>

    <fo:block id="section.colored-trees"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Colored Trees</fo:marker><fo:block font-size="10pt">3.3. Colored Trees</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Suppose we have binary trees---trees with exactly two
      children--that have integers as their leaves. Also suppose that our
      trees can have red and black nodes. Such trees can be defined as
      follows:<fo:block id="id1669832" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::ColoredTrees

data ColoredTree = 
            leaf(int N) 
          | red(ColoredTree left, ColoredTree right) 
          | black(ColoredTree left, ColoredTree right);</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We can use them as follows:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1669842" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import demo::ColoredTrees;</fo:inline>
<fo:inline font-family="monospace">ok
</fo:inline>
<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">rb = red(black(leaf(1), red(leaf(2),leaf(3))), 
                 black(leaf(3), leaf(4)));</fo:inline>
<fo:inline font-family="monospace">ColoredTree: red(black(leaf(1),red(leaf(2),leaf(3))),
                 black(leaf(3),leaf(4)))</fo:inline></fo:block>Observe that
      the type of variable <fo:inline font-family="monospace">rb</fo:inline> was autimatically inferred to
      be <fo:inline font-family="monospace">ColoredTree</fo:inline>.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We define two operations on ColoredTrees, one to count the red
      nodes, and one to sum the values contained in all
      leaves:<fo:block id="id1669881" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">// continuing module demo::ColoredTrees

public int cntRed(ColoredTree t){
   int c = 0;
   visit(t) {
     case red(_,_): c = c + 1;<fo:inline id="co.cntRed"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/1.svg)"/></fo:inline>
   };
   return c;
}

public int addLeaves(ColoredTree t){
   int c = 0;
   visit(t) {
     case leaf(int N): c = c + N;<fo:inline id="co.cntLeaves"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/2.svg)"/></fo:inline>
   };
   return c;
}</fo:block><fo:block id="id1669894" text-align="justify"><fo:list-block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" provisional-distance-between-starts="2.2em" provisional-label-separation="0.2em"><fo:list-item id="id1669898"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/1.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>Visit all the nodes of the tree and increment the counter
            <fo:inline font-family="monospace">c</fo:inline> for each red node.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669911"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/2.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>Visit all nodes of the tree and add the integers in the leaf
            nodes.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item></fo:list-block></fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">This can be used as follows:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1669928" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">cntRed(rb);</fo:inline>
<fo:inline font-family="monospace">int: 2</fo:inline>
<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">addLeaves(rb);</fo:inline>
<fo:inline font-family="monospace">int: 13</fo:inline></fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">A final touch to this example is to introduce green nodes and to
      replace all red nodes by green ones:<fo:block id="id1669954" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">// continuing module demo::ColoredTrees

data ColoredTree = green(ColoredTree left, 
                         ColoredTree right);<fo:inline id="co.Tree-green"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/1.svg)"/></fo:inline>

public ColoredTree makeGreen(ColoredTree t){
   return visit(t) {
     case red(l, r) =&gt; green(l, r)      <fo:inline id="co.makeGreen"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/2.svg)"/></fo:inline>
   };
}</fo:block><fo:block id="id1669967" text-align="justify"><fo:list-block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" provisional-distance-between-starts="2.2em" provisional-label-separation="0.2em"><fo:list-item id="id1669970"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/1.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>Extend the ColoredTree datatype with a new
            <fo:inline font-family="monospace">green</fo:inline> constructor.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1669986"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/2.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>Visit all nodes in the tree and replace red nodes by green
            ones. Note that the variables <fo:inline font-family="monospace">l</fo:inline> and
            <fo:inline font-family="monospace">r</fo:inline> are introduced here without a
            declaration.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item></fo:list-block></fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">This is used as follows:<fo:block id="id1670006" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">makeGreen(rb);</fo:inline>
<fo:inline font-family="monospace">ColoredTree: green(black(leaf(1),green(leaf(2),leaf(3))),
                   black(leaf(3),leaf(4)))</fo:inline></fo:block></fo:block>
    </fo:block>

    <fo:block id="id1670019"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Word Replacement</fo:marker><fo:block font-size="10pt">3.4. Word Replacement</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Suppose you are in the publishing business and are responsible for
      the systematic layout of publications. Authors do not systematically
      capitalize words in titles---"Word replacement" instead of Word
      Replacement"--- and you want to correct this. Here is one way to solve
      this problem:<fo:block id="id1670032" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::WordReplacement
import String;

public str capitalize(str word)
{
   if(/^&lt;letter:[a-z]&gt;&lt;rest:.*$&gt;/ := word) <fo:inline id="co.capitalize-regexp"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/1.svg)"/></fo:inline>
      return toUpperCase(letter) + rest;<fo:inline id="co.capitalize-regexp-return1"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/2.svg)"/></fo:inline>
   else
     return word;<fo:inline id="co.capitalize-regexp-return2"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/3.svg)"/></fo:inline>
}</fo:block><fo:block id="id1670049" text-align="justify"><fo:list-block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" provisional-distance-between-starts="2.2em" provisional-label-separation="0.2em"><fo:list-item id="id1670051"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/1.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>The function capitalize takes a string as input and
            capitalizes its first character if that is a letter. This is done
            using a regular expression match that anchors the match at the
            beginning (<fo:inline font-family="monospace">^</fo:inline>), expects a single letter and
            assigns it to the variable letter
            (<fo:inline font-family="monospace">letter:[a-z]</fo:inline>) followed by an arbitrary
            sequence of letters until the end of the string that is assigned
            to the variable rest (<fo:inline font-family="monospace">&lt;rest:.*$&gt;</fo:inline>).</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670077"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/2.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>If the regular expression matches we return a new string
            with the first letter capitalized.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670087"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/3.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>Otherwise we return the word unmodified.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item></fo:list-block></fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The next challenge is how to capitalize all the words in a string.
      Here are two solutions:<fo:block id="id1670101" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">// continuing module demo::WordReplacement

public str capAll1(str S)
{
 result = "";
 while (/^&lt;before:\W*&gt;&lt;word:\w+&gt;&lt;after:.*$&gt;/ := S) { <fo:inline id="co.capAll1-regexp"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/1.svg)"/></fo:inline>
    result += before + capitalize(word);
    S = after;
  }
  return result;
}

public str capAll2(str S)
{
   return visit(S){<fo:inline id="co.capAll2-visit"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/2.svg)"/></fo:inline>
     case /&lt;word:\w+&gt;/i <fo:inline id="co.capAll2-match"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/3.svg)"/></fo:inline> =&gt; capitalize(word)<fo:inline id="co.capAll1-insert"><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/4.svg)"/></fo:inline>
   };
}</fo:block><fo:block id="id1670124" text-align="justify"><fo:list-block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" provisional-distance-between-starts="2.2em" provisional-label-separation="0.2em"><fo:list-item id="id1670127"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/1.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>In the first solution <fo:inline font-family="monospace">capAll1</fo:inline> we just
            loop over all the words in the string and capitalize each word.
            The variable <fo:inline font-family="monospace">result</fo:inline> is used to collect the
            successive capitalized words. Here we use <fo:inline font-family="monospace">\W</fo:inline> do
            denote non-word characters and<fo:inline font-family="monospace">\w</fo:inline> for word
            characters.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670154"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/2.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>In the second solution we use a visit expression to visit
            all the substrings of S. Each matching case advances the substring
            by the length of the pattern it matches and replaces that pattern
            by another string. If no case matches the next substring is
            tried.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670166"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/3.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>The single case matches a word (note that
            <fo:inline font-family="monospace">\w</fo:inline> matches a word character).</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670180"><fo:list-item-label end-indent="label-end()"><fo:block><fo:external-graphic content-width="7pt" width="7pt" src="url(images/callouts/4.svg)"/></fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>When the case matches a word, it is replaced by a
            capitalized version. The modifier <fo:inline font-family="monospace">i</fo:inline> at the end
            of the regular expressions denotes case-insensitive
            matching.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item></fo:list-block></fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We can apply this all as follows:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1670200" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import demo::WordReplacement;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">capitalize("rascal");</fo:inline>
<fo:inline font-family="monospace">str: "rascal"</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">capAll1("rascal is great");</fo:inline>
<fo:inline font-family="monospace">str: "Rascal Is Great"</fo:inline></fo:block></fo:block>
    </fo:block>

    <fo:block id="id1670234"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Template Programming</fo:marker><fo:block font-size="10pt">3.5. Template Programming</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Many websites and code generators use template-based code
      generation. They start from a text template that contains embedded
      variables and code. The template is "executed" by replacing the embedded
      variables and code by their string value. A language like PHP is popular
      for this feature. Let's see how we can do this in Rascal. Given a
      mapping from field names to their type, the task at hand is to generate
      a Java class that contains those fields and corresponding getters and
      setters. Given a mapping</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1670250" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">public map[str, str] fields = (
   "name" : "String",
   "age" : "Integer",
   "address" : "String"
);</fo:block>we expect the call<fo:block id="id1670255" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">genClass("Person", fields)</fo:block>to
      produce the following output:<fo:block id="id1670258" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">    public class Person {

        private Integer age;
        public void setAge(Integer age) {
          this.age = age;
        }
        public Integer getAge() {
          return age;
        }

        private String name;
        public void setName(String name) {
          this.name = name;
        }
        public String getName() {
          return name;
        }

        private String address;
        public void setAddress(String address) {
          this.address = address;
        }
        public String getAddress() {
          return address;
        }

    }</fo:block>This is achieved by the following definition of
      <fo:inline font-family="monospace">genClass</fo:inline>:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1670273" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::StringTemplate

import String;

public str capitalize(str s) {
  return toUpperCase(substring(s, 0, 1)) + 
         substring(s, 1);
}

public str genClass(str name, map[str,str] fields) {
 return "
   public class &lt;name &gt; {
     &lt;for (x &lt;- fields) {
       str t = fields[x];
       str n = capitalize(x);&gt;
       private &lt;t&gt; &lt;x&gt;;
       public void set&lt;n&gt;(&lt;t&gt; &lt;x&gt;) {
         this.&lt;x&gt; = &lt;x&gt;;
       }
       public &lt;t&gt; get&lt;n&gt;() {
         return &lt;x&gt;;
       }
     &lt;}&gt;
   }
";
}</fo:block>Observe how the for statement and
      expressions that access the map fields that are embedded in the string
      constant customize the given template for a Java class.</fo:block>
    </fo:block>

    <fo:block id="id1670289"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">A Domain-Specific Language for Finite State Machines</fo:marker><fo:block font-size="10pt">3.6. A Domain-Specific Language for Finite State Machines</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Finite State Machines (FSMs) are a universal device in Computer
      Science and are used to model problems ranging from lexical tokens to
      concurent processes. An FSM consists of named states and labeled
      transitions between states. An example is shown in <fo:basic-link internal-destination="figure.fsm-example"><fo:inline>Figure 1.4, “Example of a Finite State Machine”</fo:inline></fo:basic-link>. This example was suggested by Goerel
      Hedin at GTTSE09.<fo:block id="figure.fsm-example" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.4. Example of a Finite State Machine</fo:block>
          

          <fo:block id="id1670317"><fo:external-graphic src="url(fsm.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
        </fo:block>This same information can be represented in textual form as
      follows:<fo:block id="id1670333" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">finite-state machine
    state S1;
    state S2;
    state S3;
    trans a: S1 -&gt; S2;
    trans b: S2 -&gt; S1;
    trans a: S1 -&gt; S3</fo:block>and here is where the idea is born to
      design a Domain-Specific Language for finite state machines (aptly
      called FSM). This always proceeds in three steps:</fo:block>

      <fo:list-block id="id1670340" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-distance-between-starts="1.2em" provisional-label-separation="0.2em"><fo:list-item id="id1670342" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>1.</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Do domain analysis</fo:inline>. Explore
          the domain and make an inventory of the relevant concepts and their
          interactions.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670355" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>2.</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Define syntax</fo:inline>. Design a
          textual syntax to represent these concepts and interactions.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670369" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>3.</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-weight="bold">Define operations</fo:inline>. Define
          operations on DSL programs. This maybe, for example, be
          typechecking, validation, or execution.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We will now apply these steps to the FSM domain.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">
        <fo:inline font-weight="bold" keep-with-next.within-line="always" padding-end="1em">Do domain analysis. </fo:inline>

        We assume that the FSM domain is sufficiently known. The
        concepts are states and labeled transitions.
      </fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">
        <fo:inline font-weight="bold" keep-with-next.within-line="always" padding-end="1em">Define syntax. </fo:inline>

        We define a textual syntax for FSMs. This syntax is written in
        the Syntax Definition Formalism SDF. See <fo:basic-link external-destination="url(http://www.meta-environment.org/Meta-Environment/Documentation)"><fo:inline>http://www.meta-environment.org/Meta-Environment/Documentation</fo:inline></fo:basic-link>
        for tutorials and manuals for SDF. The syntax definition looks as
        follows:
      </fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1670423" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo/StateMachine/Syntax

imports basic/Whitespace
imports basic/IdentifierCon

exports
  context-free start-symbols
    FSM
  
  sorts FSM Decl Trans State IdCon

  context-free syntax
    "state" IdCon                         -&gt; State
    "trans" IdCon ":" IdCon  "-&gt;" IdCon   -&gt; Trans
    State                                 -&gt; Decl
    Trans                                 -&gt; Decl
    "finite-state" "machine" {Decl ";"}+  -&gt; FSM
</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Two standard modules for whitespace and identifiers are imported
      and next a fairly standard grammar for state machines is defined.
      Observe that in SDF rules are written in reverse order as compared to
      standard BNF notation.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">
        <fo:inline font-weight="bold" keep-with-next.within-line="always" padding-end="1em"><fo:inline font-weight="bold">Define Operations</fo:inline>. </fo:inline>

        There are various operations one could define on a FSM:
        executing it for given input tokens, reducing a non-deterministic
        automaton to a deterministic one, and so on. Here we select a
        reachability check on FSMs as example.
      </fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We start with the usual imports and define a function
      getTransitions that extracts all transitions from an FSM:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1670459" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::StateMachine::CanReach

import demo::StateMachine::Syntax;
import Relation;
import Map;
import IO;

// Extract from a give FSM all transitions as a relation

public rel[str, str] getTransitions(FSM fsm){
   return
    {&lt;"&lt;from&gt;", "&lt;to&gt;"&gt; | 
     /`trans &lt;IdCon a&gt;: &lt;IdCon from&gt; -&gt; &lt;IdCon to&gt;` &lt;- fsm 
    };
}</fo:block>The function <fo:inline font-family="monospace">getTransitions</fo:inline> illustrates
      several issues. Given a concrete fsm, a deep pattern match (/) is done
      searching for <fo:inline font-family="monospace">trans</fo:inline> constructs. For each match three
      identifiers (<fo:inline font-family="monospace">IdCon</fo:inline>) are extracted from it and
      assigned to the variables<fo:inline font-family="monospace"> a</fo:inline>, <fo:inline font-family="monospace">from</fo:inline>,
      respectively, <fo:inline font-family="monospace">to</fo:inline>. Next from and to are converted to a
      string (using the string interpolations "&lt;from&gt;" and "&lt;to&gt;")
      and finally they are placed in a tuple in the resulting relation. The
      net effect is that transitions encoded in the syntax tree of
      <fo:inline font-family="monospace">fsm</fo:inline> are collected in a relation for further
      processing.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Next, we compute all reachable states in the function
      <fo:inline font-family="monospace">canReach</fo:inline>:<fo:block id="id1670504" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">// continuing module demo::StateMachine::CanReach

public map[str, set[str]] canReach(FSM fsm){
  transitions = getTransitions(fsm);
  return
    ( s: (transitions+)[s] | 
      str s &lt;- carrier(transitions) 
    );
}</fo:block>Here <fo:inline font-family="monospace">str s &lt;- carrier(transitions)</fo:inline>
      enumerates all elements that occur in the relations that is extracted
      from <fo:inline font-family="monospace">fsm</fo:inline>. A map comprehension is used to construct a
      map from each state to all states that can be reached it. Here
      <fo:inline font-family="monospace">transitions+</fo:inline> is the transitive closure of the
      transition relation and <fo:inline font-family="monospace">(transitions+)[s]</fo:inline> gives the
      image of that closure for a given state; in other words all states that
      can be reached from it.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Finally, we declare an example FSM (observe that it uses FSM
      syntax in Rascal code!):</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1670535" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">// continuing module demo::StateMachine::CanReach

public FSM example = 
       finite-state machine
          state S1;
          state S2;
          state S3;
          trans a: S1 -&gt; S2;
          trans b: S2 -&gt; S1;
          trans a: S1 -&gt; S3;</fo:block>Testing the above functions
      gives the following results:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1670540" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import demo::StateMachine::CanReach;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">getTransitions(example);</fo:inline>

<fo:inline font-family="monospace">rel[str,str]: {&lt;"S1", "S2"&gt;, &lt;"S2", "S1"&gt;, &lt;"S1", "S3"&gt;}</fo:inline>
<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">canReach(example);</fo:inline>

<fo:inline font-family="monospace">map[str: set[str]: ("S1" : {"S1", "S2", "S3"}, 
                    "S2" : {"S1", "S2", "S3"},
                    "S3" : {})</fo:inline></fo:block></fo:block>
    </fo:block>
  </fo:block>

  <fo:block id="section.problem-solving-strategies"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Problem Solving Strategies</fo:marker><fo:block font-size="11pt">4. Problem Solving Strategies</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
    

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Before we study more complicated examples, it is useful to discuss
    some general problem solving strategies that are relevant in Rascal's
    application domain.</fo:block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">To appreciate these general strategies, it is good to keep some
    specific problem areas in mind:</fo:block>

    <fo:list-block id="id1670595" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1670599" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block><fo:inline font-weight="bold">Documentation generation</fo:inline>:
        extract facts from source code and use them to generate textual
        documentation. A typical example is generating web-based documentation
        for legacy languages like Cobol and PL/I.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670614" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block><fo:inline font-weight="bold">Metrics calculation</fo:inline>: extract
        facts from source code (and possibly other sources like test runs) and
        use them to calculate code metrics. Examples are cohesion and coupling
        of modules and test coverage.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670628" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block><fo:inline font-weight="bold">Model extraction</fo:inline>: extract facts
        from source code and use them to build an abstract model of the source
        code. An example is extracting lock and unlock calls from source code
        and to build an automaton that guarantees that lock/unlock occurs in
        pairs along every control flow path.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670646" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block><fo:inline font-weight="bold">Model-based code generation</fo:inline>:
        given a high-level model of a software system, described in UML or
        some other modelling language, transform this model into executable
        code. UML-to-Java code generation falls in this category.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670659" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block><fo:inline font-weight="bold">Source-to-source
        transformation</fo:inline>: large-scale, fully automated, source code
        transformation with certain objectives like removing deprecated
        language features, upgrading to newer APIs and the like.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670674" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block><fo:inline font-weight="bold">Interactive refactoring</fo:inline>: given
        known "code smells" a user can interactively indicate how these smells
        should be removed. The refactoring features in Eclipse and Visual
        Studio are examples.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">With these examples in mind, we can study the overall problem
    solving workflow as shown in <fo:basic-link internal-destination="figure.problem-solving"><fo:inline>Figure 1.5, “General 3-Phased Problem Solving Workflow”</fo:inline></fo:basic-link>. It
    consists of three optional phases:</fo:block>

    <fo:list-block id="id1670696" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1670698" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block>Is <fo:inline font-weight="bold">extraction needed</fo:inline> to solve
        the problem, then define the extraction phase, see <fo:basic-link internal-destination="section.defining-extraction"><fo:inline>Section 4.1, “Defining Extraction”</fo:inline></fo:basic-link>.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670717" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block>Is <fo:inline font-weight="bold">analysis needed</fo:inline>, then define
        the analysis phase, see <fo:basic-link internal-destination="section.defining-analysis"><fo:inline>Section 4.2, “Defining Analysis”</fo:inline></fo:basic-link>.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670738" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block>Is <fo:inline font-weight="bold">synthesis needed</fo:inline>, then
        define the synthesis phase, see <fo:basic-link internal-destination="section.defining-synthesis"><fo:inline>Section 4.3, “Defining Synthesis”</fo:inline></fo:basic-link>.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.problem-solving" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.5. General 3-Phased Problem Solving Workflow</fo:block>
        

        <fo:block id="id1670765"><fo:external-graphic src="url(problem-solving.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
      </fo:block></fo:block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Each phase is subject to a validation and improvement workflow as
    shown in <fo:basic-link internal-destination="figure.validation"><fo:inline>Figure 1.6, “Validation and Improvement Workflow”</fo:inline></fo:basic-link>. Each individual phase as
    well as the combination of phases may introduce errors and has thus to be
    carefully validated. In combination with the detailed strategies for each
    phase, this forms a complete approach for problem solving and validation
    using Rascal.<fo:block id="figure.validation" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.6. Validation and Improvement Workflow</fo:block>
        

        <fo:block id="id1670785"><fo:external-graphic src="url(validation.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
      </fo:block>A major question in every problem solving situation is how to
    determine the requirements for each phase of the solution. For instance,
    how do we know what to extract from the source code if we do not know what
    the desired end results of the project are? The standard solution is to
    use a workflow for requirements gathering that is the inverse of the
    phases needed to solve the complete problem. This is shown in <fo:basic-link internal-destination="figure.requirements"><fo:inline>Figure 1.7, “Requirements Workflow”</fo:inline></fo:basic-link> and amounts to the phases:</fo:block>

    <fo:list-block id="id1670824" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1670826" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block><fo:inline font-weight="bold">Requirements of the synthesis
        phase</fo:inline>. This amounts to making an inventory of the desired
        results of the whole project and may include generated source code,
        abstract models, or visualizations.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670841" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block><fo:inline font-weight="bold">Requirements of the analysis
        phase</fo:inline>. Once these results of the synthesis phase are known,
        it is possible to list the analysis results that are needed to
        synthesize desired results. Possible results of the analysis phase
        include type information, structural information of the original
        source.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670856" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block><fo:inline font-weight="bold">Requirements of the extraction
        phase</fo:inline>. As a last step, one can make an inventory of the
        facts that have to be extracted to form the starting point for the
        analysis phase. Typical facts include method calls, inheritance
        relations, control flow graphs, usage patterns of specific library
        functions or language constructs.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.requirements" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.7. Requirements Workflow</fo:block>
        

        <fo:block id="id1670885"><fo:external-graphic src="url(requirements.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
      </fo:block></fo:block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">You will have no problem in identifying requirements for each phase
    when you apply them to a specific example from the list given
    earlier.</fo:block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">When these requirements have been established, it becomes much
    easier to actually carry out the project using the three phases of <fo:basic-link internal-destination="figure.problem-solving"><fo:inline>Figure 1.5, “General 3-Phased Problem Solving Workflow”</fo:inline></fo:basic-link>.</fo:block>

    <fo:block id="section.defining-extraction"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Defining Extraction</fo:marker><fo:block font-size="10pt">4.1. Defining Extraction</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">How can we extract facts from the <fo:inline font-style="italic">System under
      Investigation</fo:inline> (SUI) that we are interested in? The extraction
      workflow is shown in <fo:basic-link internal-destination="figure.define-extraction"><fo:inline>Figure 1.8, “Extraction Workflow”</fo:inline></fo:basic-link>and
      consists of the following steps:</fo:block>

      <fo:list-block id="id1670937" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1670940" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>First and foremost we have to determine which facts we need.
          This sounds trivial, but it is not. The problem is that we have to
          anticipate which facts will be needed in the next---not yet
          defined---analysis phase. A common approach is to use look-ahead and
          to sketch the queries that are likely to be used in the analysis
          phase and to determine which facts are needed for them. Start with
          extracting these facts and refine the extraction phase when the
          analysis phase is completely defined.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670954" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>If relevant facts are already available (and they are
          reliable!) then we are done. This may happen when you are working on
          a system that has already been analyzed by others.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670962" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Otherwise you need the source code of the SUI. This
          requires:</fo:block>

          <fo:list-block id="id1670968" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1670971" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Checking that all sources are available (and can be
              compiled by the host system on which they are usually compiled
              and executed). Due to missing or unreliable configuration
              management on the original system this may be a labour-intensive
              step that requires many iterations.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670982" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Determining in which languages the sources are written. In
              larger systems it is common that three or more different
              languages are being used.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1670995" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>If there are reliable third-party extraction tools available
          for this language mix, then we only have to apply them and we are
          done. Here again, validation is needed that the extracted facts are
          as expected.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671003" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The extraction may require syntax analysis. This is the case
          when more structural properties of the source code are needed such
          as the flow-of-control, nesting of declarations, and the like. There
          two approaches here:</fo:block>

          <fo:list-block id="id1671011" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671013" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Use a third-party parser, convert the source code to parse
              trees and do the further processing of these parse trees in
              Rascal. The advantage is that the parser can be re-used, the
              disadvantage is that data conversion is needed to adapt the
              generated parse tree to Rascal. Validate that the parser indeed
              accepts the language the SUI is written in, since you will not
              be the first who has been bitten by the language dialect monster
              when it turns out that the SUI uses a local variant that
              slightly deviates from a mainstream language.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671028" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Use an existing SDF definition of the source language or
              write your own definition. In both cases you can profit from
              Rascal's seamless integration with SDF. Be aware, however, that
              writing a grammar for a non-trivial language is a major
              undertaking and may require weeks to month of work. Whatever
              approach you choose, validate that the result.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671041" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The extraction phase may only require lexical analysis. This
          happens when more superficial, textual, facts have to be extracted
          like procedure calls, counts of certain statements and the like. Use
          Rascal's full regular expression facilities to do the lexical
          analysis.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">It may happen that the facts extracted from the source code are
      <fo:inline font-style="italic">wrong</fo:inline>. Typical error classes are:</fo:block>

      <fo:list-block id="id1671057" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671059" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Extracted facts are <fo:inline font-style="italic">wrong</fo:inline>: the extracted
          facts incorrectly state that procedure <fo:inline font-family="monospace">P</fo:inline> calls
          procedure <fo:inline font-family="monospace">Q</fo:inline> but this is contradicted by a source
          code inspection. This may happen when the fact extractor uses a
          conservative approximation when precise information is not
          statically available. In the language C, when procedure P performs
          an indirect call via a pointer variable, the approximation may be
          that P calls all procedures in the procedures.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671082" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Extracted facts are <fo:inline font-style="italic">incomplete</fo:inline>: the
          inheritance between certain classes in Java code is missing.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The strategy to validate extracted facts differ per case but here
      are three strategies:</fo:block>

      <fo:list-block id="id1671098" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671100" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Post process the extracted facts (using Rascal, of course) to
          obtain trivial facts about the source code such as total lines of
          source code and number of procedures, classes, interfaces and the
          like. Next validate these trivial facts with tools like
          <fo:inline font-family="monospace">wc</fo:inline> (word and line count), <fo:inline font-family="monospace">grep</fo:inline>
          (regular expression matching) and others.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671118" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Do a manual fact extraction on a small subset of the code and
          compare this with the automatically extracted facts.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671126" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Use another tool on the same source and compare results
          whenever possible. A typical example is a comparison of a call
          relation extracted with different tools.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.define-extraction" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.8. Extraction Workflow</fo:block>
          

          <fo:block id="id1671148"><fo:external-graphic src="url(define-extraction.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
        </fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The Rascal features that are most frequently used for extraction
      are:</fo:block>

      <fo:list-block id="id1671167" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671173" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Regular expression patterns to extract textual facts from
          source code.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671179" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Syntax definitions and concrete patterns to match syntactic
          structures in source code.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671188" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Pattern matching (used in many Rascal statements).</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671195" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Visits to traverse syntax trees and to locally extract
          information.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671203" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The repertoire of built-in datatypes (like lists, maps, sets
          and relations) to represent the extracted facts.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
    </fo:block>

    <fo:block id="section.defining-analysis"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Defining Analysis</fo:marker><fo:block font-size="10pt">4.2. Defining Analysis</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The analysis workflow is shown in <fo:basic-link internal-destination="figure.define-analysis"><fo:inline>Figure 1.9, “Analysis Workflow”</fo:inline></fo:basic-link> and consists of two steps:</fo:block>

      <fo:list-block id="id1671229" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671231" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Determine the results that are needed for the synthesis
          phase.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671240" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Write the Rascal code to perform the analysis. This may amount
          to:</fo:block>

          <fo:list-block id="id1671248" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671249" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Reordering extracted facts to make them more suitable for
              the synthesis phase.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671259" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Enriching extracted facts. Examples are computing
              transitive closures of extracted facts (e.g., A may call B in
              one or more calls), or performing data reduction by abstracting
              aways details (i.e., reducing a program to a finite
              automaton).</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671270" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Combining enriched, extracted, facts to create new
              facts.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">As before, validate, validate and validate the results of
      analysis. Essentially the same approach can be used as for validating
      the facts. Manual checking of answers on random samples of the SUI may
      be mandatory. It also happens frequently that answers inspire new
      queries that lead to new answers, and so on.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.define-analysis" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.9. Analysis Workflow</fo:block>
          

          <fo:block id="id1671294"><fo:external-graphic src="url(define-analysis.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
        </fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The Rascal features that are frequently used for analysis
      are:</fo:block>

      <fo:list-block id="id1671315" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671318" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>List, set and map comprehensions.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671325" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The built-in operators and library functions, in particular
          for lists, maps, sets and relations.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671333" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Pattern matching (used in many Rascal statements).</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671341" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Visits and switches to further process extracted facts.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671349" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The solve statement for constraint solving.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671356" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Rewrite rules to simplify results and to enforce
          constraints.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
    </fo:block>

    <fo:block id="section.defining-synthesis"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Defining Synthesis</fo:marker><fo:block font-size="10pt">4.3. Defining Synthesis</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Results are synthesized as shown in <fo:basic-link internal-destination="figure.define-synthesis"><fo:inline>Figure 1.10, “Synthesis Workflow”</fo:inline></fo:basic-link>. This consists of the following
      steps:</fo:block>

      <fo:list-block id="id1671385" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671387" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Determine the results of the synthesis phase. Wide range of
          results is possible including:</fo:block>

          <fo:list-block id="id1671395" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671397" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Generated source code.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671405" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Generated abstract representations, like finite automata
              or other formals models that capture properties of the
              SUI.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671413" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Generated data for visualizations that will be used by
              visualization tools.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671422" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>If source code is to be generated, there are various
          options.</fo:block>

          <fo:list-block id="id1671428" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671430" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Print strings with embedded variables.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671438" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Convert abstract syntax trees to strings (perhaps using
              forms of pretty printing).</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671447" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Use a grammar of the target source language, also for code
              generation. Note that this approach guarantees the generation of
              syntactically correct source code as opposed to code generation
              using print statements or string templates.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671460" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>If other output is needed (e.g., an automaton or other formal
          structure) write data declarations to represent that output.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671468" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Finally, write functions and rewrite rules that generate the
          desired results.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.define-synthesis" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.10. Synthesis Workflow</fo:block>
          

          <fo:block id="id1671486"><fo:external-graphic src="url(define-synthesis.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
        </fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The Rascal features that are frequently used for synthesis
      are:</fo:block>

      <fo:list-block id="id1671478" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671496" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Syntax definitions or data declarations to define output
          formats.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671515" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Pattern matching (used in many Rascal statements).</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671524" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Visits of datastructures and on-the-fly code
          generation.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671533" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Rewrite rules.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
    </fo:block>
  </fo:block>

  <fo:block id="section.more-examples"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Larger Examples</fo:marker><fo:block font-size="11pt">5. Larger Examples</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
    

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Now we will have a closer look at some larger applications of
    Rascal. We start with a call graph analysis in <fo:basic-link internal-destination="section.motivating-example"><fo:inline>Section 5.1, “Call Graph Analysis”</fo:inline></fo:basic-link> and then continue with the
    analysis of the component structure of an application in <fo:basic-link internal-destination="section.analyzing-components"><fo:inline>Section 5.2, “Analyzing the Component Structure of an Application”</fo:inline></fo:basic-link> and of Java systems in <fo:basic-link internal-destination="section.analyzing-java"><fo:inline>Section 5.3, “Analyzing the Structure of Java Systems”</fo:inline></fo:basic-link>. Next we move on to the detection of
    uninitialized variables in <fo:basic-link internal-destination="section.unitialized-variables"><fo:inline>Section 5.4, “Finding Uninitialized and Unused Variables in a Program”</fo:inline></fo:basic-link>. As an example of computing
    code metrics, we describe the calculation of McCabe's cyclomatic
    complexity in <fo:basic-link internal-destination="section.McCabe">Section 5.5, “McCabe Cyclomatic Complexity”</fo:basic-link>. Several examples of
    dataflow analysis follow in <fo:basic-link internal-destination="section.dataflow"><fo:inline>Section 5.6, “Dataflow Analysis”</fo:inline></fo:basic-link>. A
    description of program slicing concludes the chapter, see <fo:basic-link internal-destination="section.program-slicing"><fo:inline>Section 5.7, “Program Slicing”</fo:inline></fo:basic-link>.</fo:block>

    <fo:block id="section.motivating-example"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Call Graph Analysis</fo:marker><fo:block font-size="10pt">5.1. Call Graph Analysis</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Suppose a mystery box ends up on your desk. When you open it, it
      contains a huge software system with several questions attached to
      it:</fo:block>

      <fo:list-block id="id1671604" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1671608" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>How many procedure calls occur in this system?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671615" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>How many procedures does it contains?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671623" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>What are the entry points for this system, i.e., procedures
          that call others but are not called themselves?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671631" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>What are the leaves of this application, i.e., procedures that
          are called but do not make any calls themselves?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671639" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Which procedures call each other indirectly?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671647" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Which procedures are called directly or indirectly from each
          entry point?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1671656" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Which procedures are called from all entry points?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Let's see how these questions can be answered using Rascal.</fo:block>

      <fo:block id="id1671667"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.1.1. Preparations</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">To illustrate this process consider the workflow in <fo:basic-link internal-destination="figure.calls-workflow"><fo:inline>Figure 1.11, “Workflow for analyzing mystery box”</fo:inline></fo:basic-link>. First we have to extract the calls
        from the source code. Rascal is very good at this, but to simplify
        this example we assume that this call graph has already been
        extracted. Also keep in mind that a real call graph of a real
        application will contain thousands and thousands of calls. Drawing it
        in the way we do later on in <fo:basic-link internal-destination="figure.calls"><fo:inline>Figure 1.12, “Graphical representation of the <fo:inline font-family="monospace">calls</fo:inline>
            relation”</fo:inline></fo:basic-link> makes no
        sense since we get a uniformly black picture due to all the call
        dependencies. After the extraction phase, we try to understand the
        extracted facts by writing queries to explore their properties. For
        instance, we may want to know <fo:inline font-style="italic">how many calls</fo:inline>
        there are, or <fo:inline font-style="italic">how many procedures</fo:inline>. We may also
        want to enrich these facts, for instance, by computing who calls who
        in more than one step. Finally, we produce a simple textual report
        giving answers to the questions we are interested in.<fo:block id="figure.calls-workflow" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.11. Workflow for analyzing mystery box</fo:block>
            

            <fo:block id="id1671714"><fo:external-graphic src="url(calls-workflow.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>

            <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Now consider the call graph shown in <fo:basic-link internal-destination="figure.calls"><fo:inline>Figure 1.12, “Graphical representation of the <fo:inline font-family="monospace">calls</fo:inline>
            relation”</fo:inline></fo:basic-link>. This section is intended to give you a
            first impression what can be done with Rascal.</fo:block>
          </fo:block><fo:block id="figure.calls" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.12. Graphical representation of the <fo:inline font-family="monospace">calls</fo:inline>
            relation</fo:block>
            

            <fo:block id="id1671751"><fo:external-graphic src="url(calls.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
          </fo:block></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal supports basic data types like integers and strings which
        are sufficient to formulate and answer the questions at hand. However,
        we can gain readability by introducing separately named types for the
        items we are describing. First, we introduce therefore a new type
        <fo:inline font-family="monospace">proc</fo:inline> (an alias for strings) to denote
        procedures:</fo:block>

        <fo:block id="id1671775" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">rascal&gt; <fo:inline font-weight="bold" font-family="monospace">alias proc = str;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Suppose that the following facts have been extracted from the
        source code and are represented by the relation
        <fo:inline font-family="monospace">Calls</fo:inline>:</fo:block>

        <fo:block id="id1671791" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">rel[proc, proc] Calls = 
   { &lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, &lt;"d", "c"&gt;, 
     &lt;"d","e"&gt;, &lt;"f", "e"&gt;, &lt;"f", "g"&gt;, &lt;"g", "e"&gt;
   };</fo:inline>
<fo:inline font-family="monospace">rel[proc,proc]: { &lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, 
                  &lt;"d", "c"&gt;, &lt;"d","e"&gt;, &lt;"f", "e"&gt;, 
                  &lt;"f", "g"&gt;, &lt;"g", "e"&gt;}</fo:inline></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">This concludes the preparatory steps and now we move on to
        answer the questions.</fo:block>
      </fo:block>

      <fo:block id="id1671811"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.1.2. How many procedure calls occur in this system?</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">To determine the numbers of calls, we simply determine the
        number of tuples in the <fo:inline font-family="monospace">Calls</fo:inline> relation, as follows.
        First, we need the Relation library so we import it:<fo:block id="id1671826" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import Relation;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline></fo:block>next we describe a new variable
        and calculate the number of tuples:</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1671840" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">nCalls = size(Calls);</fo:inline>
<fo:inline font-family="monospace">int: 8</fo:inline></fo:block>The library function
        <fo:inline font-family="monospace">size</fo:inline> determines the number of elements in a set or
        relation. In this example, <fo:inline font-family="monospace">nCalls</fo:inline> will get the
        value <fo:inline font-family="monospace">8</fo:inline>.</fo:block>
      </fo:block>

      <fo:block id="id1671868"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.1.3. How many procedures are contained in it?</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We get the number of procedures by determining which names occur
        in the tuples in the relation <fo:inline font-family="monospace">Calls</fo:inline> and then
        determining the number of names:</fo:block>

        <fo:block id="id1671882" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">procs = carrier(Calls);</fo:inline>
<fo:inline font-family="monospace"><fo:inline font-family="monospace">set[proc]: {"a", "b", "c", "d", "e", "f", "g"}</fo:inline></fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">nprocs = size(procs);</fo:inline>
<fo:inline font-family="monospace">int: 7</fo:inline></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The built-in function <fo:inline font-family="monospace">carrier</fo:inline> determines all
        the values that occur in the tuples of a relation. In this case,
        <fo:inline font-family="monospace">procs</fo:inline> will get the value <fo:inline font-family="monospace">{"a", "b", "c",
        "d", "e", "f", "g"}</fo:inline> and <fo:inline font-family="monospace">nprocs</fo:inline> will thus
        get value <fo:inline font-family="monospace">7</fo:inline>. A more concise way of expressing this
        would be to combine both steps:</fo:block>

        <fo:block id="id1671931" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">nprocs = size(carrier(Calls));</fo:inline>
<fo:inline font-family="monospace">int: 7</fo:inline></fo:block>
      </fo:block>

      <fo:block id="id1671946"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.1.4. What are the entry points for this system?</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The next step in the analysis is to determine which
        <fo:inline font-style="italic">entry points</fo:inline> this application has, i.e.,
        procedures which call others but are not called themselves. Entry
        points are useful since they define the external interface of a system
        and may also be used as guidance to split a system in parts. The
        <fo:inline font-family="monospace">top</fo:inline> of a relation contains those left-hand sides of
        tuples in a relation that do not occur in any right-hand side. When a
        relation is viewed as a graph, its top corresponds to the root nodes
        of that graph. Similarly, the <fo:inline font-family="monospace">bottom</fo:inline> of a relation
        corresponds to the leaf nodes of the graph. Using this knowledge, the
        entry points can be computed by determining the top of the
        <fo:inline font-family="monospace">Calls</fo:inline> relation:</fo:block>

        <fo:block id="id1671978" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import Graph;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">entryPoints = top(Calls);</fo:inline>
<fo:inline font-family="monospace">set[proc]: {"a", "f"}</fo:inline></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">In this case, <fo:inline font-family="monospace">entryPoints</fo:inline> is equal to
        <fo:inline font-family="monospace">{"a", "f"}</fo:inline>. In other words, procedures
        <fo:inline font-family="monospace">"a"</fo:inline> and <fo:inline font-family="monospace">"f"</fo:inline> are the entry points
        of this application.</fo:block>
      </fo:block>

      <fo:block id="id1672021"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.1.5. What are the leaves of this application?</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">In a similar spirit, we can determine the
        <fo:inline font-style="italic">leaves</fo:inline> of this application, i.e., procedures that
        are being called but do not make any calls themselves:</fo:block>

        <fo:block id="id1672037" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">bottomCalls = bottom(Calls);</fo:inline>
<fo:inline font-family="monospace">set[proc]: {"c", "e"}</fo:inline></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">In this case, <fo:inline font-family="monospace">bottomCalls</fo:inline> is equal to
        <fo:inline font-family="monospace">{"c", "e"}</fo:inline>.</fo:block>
      </fo:block>

      <fo:block id="id1672061"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.1.6. Which procedures call each other indirectly?</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We can also determine the <fo:inline font-style="italic">indirect calls</fo:inline>
        between procedures, by taking the transitive closure of the
        <fo:inline font-family="monospace">Calls</fo:inline> relation, written as
        <fo:inline font-family="monospace">Calls+</fo:inline>. Observe that the transitive closure will
        contain both the direct and the indirect calls.</fo:block>

        <fo:block id="id1672084" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">closureCalls = Calls+;</fo:inline>
<fo:inline font-family="monospace">rel[proc, proc]: {&lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, 
                  &lt;"d", "c"&gt;, &lt;"d","e"&gt;, &lt;"f", "e"&gt;, 
                  &lt;"f", "g"&gt;, &lt;"g", "e"&gt;, &lt;"a", "c"&gt;, 
                  &lt;"a", "d"&gt;, &lt;"b", "e"&gt;, &lt;"a", "e"&gt;}</fo:inline></fo:block>
      </fo:block>

      <fo:block id="id1672099"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.1.7. Which procedures are called directly or indirectly from each
        entry point?</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We now know the entry points for this application (<fo:inline font-family="monospace">"a"
        </fo:inline>and <fo:inline font-family="monospace">"f"</fo:inline>) and the indirect call relations.
        Combining this information, we can determine which procedures are
        called from each entry point. This is done by indexing
        <fo:inline font-family="monospace">closureCalls</fo:inline> with appropriate procedure name. The
        index operator yields all right-hand sides of tuples that have a given
        value as left-hand side. This gives the following:</fo:block>

        <fo:block id="id1672126" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">calledFromA = closureCalls["a"];</fo:inline>
<fo:inline font-family="monospace">set[proc]: {"b", "c", "d", "e"}</fo:inline></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">and</fo:block>

        <fo:block id="id1672141" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">calledFromF = closureCalls["f"];</fo:inline>
<fo:inline font-family="monospace">set[proc]: {"e", "g"}</fo:inline></fo:block>
      </fo:block>

      <fo:block id="id1672153"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.1.8. Which procedures are called from all entry points?</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Finally, we can determine which procedures are called from both
        entry points by taking the intersection of the two sets
        <fo:inline font-family="monospace">calledFromA</fo:inline> and
        <fo:inline font-family="monospace">calledFromF:</fo:inline></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1672173" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">commonProcs = calledFromA &amp; calledFromF;</fo:inline>
<fo:inline font-family="monospace">set[proc]: {"e"}</fo:inline></fo:block></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">In other words, the procedures called from both entry points are
        mostly disjoint except for the common procedure
        <fo:inline font-family="monospace">"e"</fo:inline>.</fo:block>
      </fo:block>

      <fo:block id="id1672197"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.1.9. Wrap-up</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">These findings can be verified by inspecting a graph view of the
        calls relation as shown in <fo:basic-link internal-destination="figure.calls"><fo:inline>Figure 1.12, “Graphical representation of the <fo:inline font-family="monospace">calls</fo:inline>
            relation”</fo:inline></fo:basic-link>. Such a
        visual inspection does <fo:inline font-style="italic">not</fo:inline> scale very well to
        large graphs and this makes the above form of analysis particularly
        suited for studying large systems.</fo:block>
      </fo:block>
    </fo:block>

    <fo:block id="section.analyzing-components"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Analyzing the Component Structure of an Application</fo:marker><fo:block font-size="10pt">5.2. Analyzing the Component Structure of an Application</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">A frequently occurring problem is that we know the call relation
      of a system but that we want to understand it at the component level
      rather than at the procedure level. If it is known to which component
      each procedure belongs, it is possible to <fo:inline font-style="italic">lift</fo:inline> the
      call relation to the component level as proposed in [<fo:basic-link internal-destination="Krikhaar99">Kri99</fo:basic-link>]. Actual lifting amounts to translating each call
      between procedures by a call between components. This is described in
      the following module:<fo:block id="id1672243" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::Lift

alias proc = str;
alias comp = str;

public rel[comp,comp] lift(rel[proc,proc] aCalls, 
                           rel[proc,comp] aPartOf){
   return 
      { &lt;C1, C2&gt; | &lt;proc P1, proc P2&gt; &lt;- aCalls, 
                   &lt;comp C1, comp C2&gt; &lt;- aPartOf[P1] * 
                                         aPartOf[P2]
      };
}</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">For each pair <fo:inline font-family="monospace">&lt;P1,P2&gt;</fo:inline> in the Calls
      relation we compose the corresponding parts
      <fo:inline font-family="monospace">aPartOf[P1]</fo:inline> and <fo:inline font-family="monospace">aPartOf[P2]</fo:inline> (each
      yielding a set of components) into a new relation of calls between
      components. This relation is added pair by pair to the result.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Let's now apply this. First import the above module, and define a
      call relation and a partof relation:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1672269" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import demo::Lift;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">Calls = {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, 
                 &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, &lt;"b", "d"&gt;
                };</fo:inline>
<fo:inline font-family="monospace">rel[str,str] : {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, 
                &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, &lt;"b", "d"&gt;
               }</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">Components = {"Appl", "DB", "Lib"};</fo:inline>
<fo:inline font-family="monospace">set[str] : {"Appl", "DB", "Lib"}</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">PartOf = {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, 
                  &lt;"b", "DB"&gt;, &lt;"c", "Lib"&gt;, 
                  &lt;"d", "Lib"&gt;};</fo:inline>
<fo:inline font-family="monospace">rel[str,str] : {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, 
                &lt;"b", "DB"&gt;, &lt;"c", "Lib"&gt;, 
                &lt;"d", "Lib"&gt;}</fo:inline></fo:block>The lifted call
      relation between components is now obtained by:<fo:block id="id1672272" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt; </fo:inline><fo:inline font-weight="bold" font-family="monospace">ComponentCalls = lift(Calls, PartOf);</fo:inline>
<fo:inline font-family="monospace">rel[str,str] : {&lt;"DB", "Lib"&gt;, &lt;"Appl", "Lib"&gt;, 
                &lt;"Appl", "DB"&gt;, &lt;"Appl", "Appl"&gt;}</fo:inline></fo:block>The
      relevant relations for this example are shown in <fo:basic-link internal-destination="figure.parts"><fo:inline>Figure 1.13, “(a) <fo:inline font-family="monospace">Calls</fo:inline>; (b) <fo:inline font-family="monospace">PartOf</fo:inline>;
        (c) <fo:inline font-family="monospace">ComponentCalls</fo:inline>.”</fo:inline></fo:basic-link>.</fo:block>

      <fo:block id="figure.parts" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.13. (a) <fo:inline font-family="monospace">Calls</fo:inline>; (b) <fo:inline font-family="monospace">PartOf</fo:inline>;
        (c) <fo:inline font-family="monospace">ComponentCalls</fo:inline>.</fo:block>
        

        <fo:block id="id1672359"><fo:external-graphic src="url(parts.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
      </fo:block>
    </fo:block>

    <fo:block id="section.analyzing-java"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Analyzing the Structure of Java Systems</fo:marker><fo:block font-size="10pt">5.3. Analyzing the Structure of Java Systems</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Now we consider the analysis of Java systems (inspired by
      [<fo:basic-link internal-destination="BNL05">BNL05</fo:basic-link>]). Suppose that the type
      <fo:inline font-family="monospace">class</fo:inline> is defined as follows<fo:block id="id1672396" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">alias class = str;</fo:block>and
      that the following relations are available about a Java
      application:</fo:block>

      <fo:list-block id="id1672401" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1672405" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-family="monospace">rel[class,class] CALL</fo:inline>: If
          <fo:inline font-family="monospace">&lt;<fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline>,
          <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">2</fo:inline>&gt;</fo:inline>
          is an element of <fo:inline font-family="monospace">CALL</fo:inline>, then some method of
          <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">2</fo:inline> is called from
          <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline>.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672448" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-family="monospace">rel[class,class] INHERITANCE</fo:inline>: If
          <fo:inline font-family="monospace">&lt;<fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline>,
          <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">2</fo:inline>&gt;</fo:inline>
          is an element of <fo:inline font-family="monospace">INHERITANCE</fo:inline>, then class
          <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline> either extends
          class <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">2</fo:inline> or
          <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline> implements
          interface
          <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">2</fo:inline>.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672502" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-family="monospace">rel[class,class] CONTAINMENT</fo:inline>: If
          &lt;<fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline>,
          <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">2</fo:inline>&gt; is an
          element of <fo:inline font-family="monospace">CONTAINMENT</fo:inline>, then one of the fields of
          class <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline> is of
          type <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">2</fo:inline>.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">To make this more explicit, consider the class
      <fo:inline font-family="monospace">LocatorHandle</fo:inline> from the JHotDraw application (version
      5.2) as shown here:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1672548" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">package CH.ifa.draw.standard;

import java.awt.Point;
import CH.ifa.draw.framework.*;
/**
 * A LocatorHandle implements a Handle by delegating the 
 * location requests to a Locator object.
 */
public class LocatorHandle extends AbstractHandle {
    private Locator       fLocator;
    /**
     * Initializes the LocatorHandle with the 
     * given Locator.
     */
    public LocatorHandle(Figure owner, Locator l) {
        super(owner);
        fLocator = l;
    }
    /**
     * Locates the handle on the figure by forwarding 
     * the request to its figure.
     */
    public Point locate() {
        return fLocator.locate(owner());
    }
}</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">It leads to the addition to the above relations of the following
      tuples:</fo:block>

      <fo:list-block id="id1672546" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1672561" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>To <fo:inline font-family="monospace">CALL</fo:inline> the pairs
          <fo:inline font-family="monospace">&lt;"LocatorHandle", "AbstractHandle"&gt;</fo:inline> and
          <fo:inline font-family="monospace">&lt;"LocatorHandle", "Locator"&gt;</fo:inline> will be
          added.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672583" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>To <fo:inline font-family="monospace">INHERITANCE</fo:inline> the pair
          <fo:inline font-family="monospace">&lt;"LocatorHandle", "AbstractHandle"&gt;</fo:inline> will be
          added.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672597" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>To <fo:inline font-family="monospace">CONTAINMENT</fo:inline> the pair
          <fo:inline font-family="monospace">&lt;"LocatorHandle", "Locator"&gt;</fo:inline> will be
          added.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Cyclic structures in object-oriented systems makes understanding
      hard. Therefore it is interesting to spot classes that occur as part of
      a cyclic dependency. Here we determine cyclic uses of classes that
      include calls, inheritance and containment. This is achieved as
      follows:<fo:block id="id1672625" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">rel[class,class] USE = CALL + CONTAINMENT + INHERITANCE;
set[str] ClassesInCycle =
   {C1 | &lt;class C1, class C2&gt; &lt;- USE+, C1 == C2};</fo:block>First,
      we define the <fo:inline font-family="monospace">USE</fo:inline> relation as the union of the three
      available relations <fo:inline font-family="monospace">CALL</fo:inline>,
      <fo:inline font-family="monospace">CONTAINMENT</fo:inline> and <fo:inline font-family="monospace">INHERITANCE</fo:inline>. Next,
      we consider all pairs
      &lt;<fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline>,
      <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">2</fo:inline>&gt; in the
      transitive closure of the <fo:inline font-family="monospace">USE</fo:inline> relation such that
      <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline> and
      <fo:inline font-style="italic" font-family="monospace">C</fo:inline><fo:inline font-size="75%" baseline-shift="sub">2</fo:inline> are equal. Those
      are precisely the cases of a class with a cyclic dependency on itself.
      Probably, we do not only want to know which classes occur in a cyclic
      dependency, but we also want to know which classes are involved in such
      a cycle. In other words, we want to associate with each class a set of
      classes that are responsible for the cyclic dependency. This can be done
      as follows.<fo:block id="id1672671" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">rel[class,class] USE = CALL + CONTAINMENT + INHERITANCE;
set[class] CLASSES = carrier(USE);
rel[class,class] USETRANS = USE+;
rel[class,set[class]] ClassCycles = 
   {&lt;C, USETRANS[C]&gt; | class C &lt;- CLASSES, 
                       &lt;C, C&gt; in USETRANS };</fo:block>First, we
      introduce two new shorthands: <fo:inline font-family="monospace">CLASSES</fo:inline> and
      <fo:inline font-family="monospace">USETRANS</fo:inline>. Next, we consider all classes
      <fo:inline font-family="monospace">C</fo:inline> with a cyclic dependency and add the pair
      <fo:inline font-family="monospace">&lt;C, USETRANS[C]&gt;</fo:inline> to the relation
      <fo:inline font-family="monospace">ClassCycles</fo:inline>. Note that <fo:inline font-family="monospace">USETRANS[C]</fo:inline>
      is the right image of the relation <fo:inline font-family="monospace">USETRANS</fo:inline> for
      element <fo:inline font-family="monospace">C</fo:inline>, i.e., all classes that can be called
      transitively from class <fo:inline font-family="monospace">C</fo:inline>.</fo:block>
    </fo:block>

    <fo:block id="section.unitialized-variables"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Finding Uninitialized and Unused Variables in a Program</fo:marker><fo:block font-size="10pt">5.4. Finding Uninitialized and Unused Variables in a Program</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Consider the following program in the toy language Pico: (This is
      an extended version of the example presented earlier in [<fo:basic-link internal-destination="KlintIWPC03">Kli03</fo:basic-link>].)<fo:block id="id1672735" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">[ 1] begin declare x : natural, y : natural,
[ 2]              z : natural, p : natural;
[ 3]  x := 3;
[ 4]  p := 4;
[ 5]  if q then
[ 6]        z := y + x
[ 7]  else
[ 8]        x := 4
[ 9]  fi;
[10]  y := z
[11] end</fo:block>Inspection of this program learns that some of the
      variables are being used before they have been initialized. The
      variables in question are <fo:inline font-family="monospace">q</fo:inline> (line 5),
      <fo:inline font-family="monospace">y</fo:inline> (line 6), and <fo:inline font-family="monospace">z</fo:inline> (line 10). It is
      also clear that variable <fo:inline font-family="monospace">p</fo:inline> is initialized (line 4),
      but is never used. How can we automate these kinds of analysis? Recall
      from <fo:basic-link internal-destination="section.EASY-programming"><fo:inline>Section 1.1, “The EASY Paradigm”</fo:inline></fo:basic-link> that we follow the
      Extract-Analyze-SYnthesize paradigm to approach such a problem. The
      first step is to determine which elementary facts we need about the
      program. For this and many other kinds of program analysis, we need at
      least the following:</fo:block>

      <fo:list-block id="id1672749" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1672766" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The <fo:inline font-style="italic">control flow graph</fo:inline> of the program. We
          represent it by a graph <fo:inline font-family="monospace">PRED</fo:inline> (for predecessor)
          which relates each statement with its predecessors.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672783" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The <fo:inline font-style="italic">definitions</fo:inline> of each variable, i.e.,
          the program statements where a value is assigned to the variable. It
          is represented by the relation <fo:inline font-family="monospace">DEFS</fo:inline>.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672798" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The <fo:inline font-style="italic">uses</fo:inline> of each variable, i.e., the
          program statements where the value of the variable is used. It is
          represented by the relation <fo:inline font-family="monospace">USES</fo:inline>.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">In this example, we will use line numbers to identify the
      statements in the program. Assuming that there is a tool to extract the
      above information from a program text, we get the following for the
      above example:<fo:block id="id1672824" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::Uninit
import Relation;
import Graph;

alias expr = int;
alias varname = str;

public expr ROOT = 1;

public graph[expr] PRED = { &lt;1,3&gt;, &lt;3,4&gt;, &lt;4,5&gt;, &lt;5,6&gt;, 
                            &lt;5,8&gt;, &lt;6,10&gt;, &lt;8,10&gt; };

public rel[varname,expr] DEFS = { &lt;"x", 3&gt;, &lt;"p", 4&gt;, 
                                  &lt;"z", 6&gt;, &lt;"x", 8&gt;, 
                                  &lt;"y", 10&gt; };

public rel[varname, expr] USES = { &lt;"q", 5&gt;, &lt;"y", 6&gt;, 
                                   &lt;"x", 6&gt;, &lt;"z", 10&gt; };
</fo:block>This concludes the extraction phase. Next, we have to enrich
      these basic facts to obtain the initialized variables in the program.
      So, when is a variable <fo:inline font-style="italic" font-family="monospace">V</fo:inline> in some statement
      <fo:inline font-style="italic" font-family="monospace">S</fo:inline> initialized? If we execute the program
      (starting in <fo:inline font-family="monospace">ROOT</fo:inline>), there may be several possible
      execution paths that can reach statement <fo:inline font-style="italic" font-family="monospace">S</fo:inline>.
      All is well if <fo:inline font-style="italic">all</fo:inline> these execution path contain a
      definition of <fo:inline font-style="italic" font-family="monospace">V</fo:inline>. However, if one or more of
      these path do <fo:inline font-style="italic">not</fo:inline> contain a definition of
      <fo:inline font-style="italic" font-family="monospace">V</fo:inline>, then <fo:inline font-style="italic" font-family="monospace">V</fo:inline> may be
      uninitialized in statement <fo:inline font-style="italic" font-family="monospace">S</fo:inline>. This can be
      formalized as follows:<fo:block id="id1672871" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">// module demo::Unit continued
public rel[varname,expr] UNINIT = 
   { &lt;V,E&gt; | &lt;varname V, expr E&gt; &lt;- USES, 
              E in reachX(PRED, {ROOT}, DEFS[V])
   };</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We analyze this definition in detail:</fo:block>

      <fo:list-block id="id1672878" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1672880" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-family="monospace">&lt;varname V, expr E&gt; : USES</fo:inline> enumerates
          all tuples in the <fo:inline font-family="monospace">USES</fo:inline> relation. In other words,
          we consider the use of each variable in turn.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672895" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block><fo:inline font-family="monospace">E in reachX(PRED, {ROOT}, DEFS[V]) </fo:inline>is a
          test that determines whether expression <fo:inline font-style="italic" font-family="monospace">E</fo:inline>
          is reachable from the <fo:inline font-family="monospace">ROOT</fo:inline> without encountering a
          definition of variable <fo:inline font-style="italic" font-family="monospace">V</fo:inline>.</fo:block>

          <fo:list-block id="id1672915" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1672919" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block><fo:inline font-family="monospace">{ROOT}</fo:inline> represents the initial set of
              nodes from which all path should start.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672930" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block><fo:inline font-family="monospace">DEFS[V]</fo:inline> yields the set of all
              statements in which a definition of variable
              <fo:inline font-family="monospace">V</fo:inline> occurs. These nodes form the exclusion set
              for <fo:inline font-family="monospace">reachX</fo:inline>: no path will be extended beyond
              an element in this set.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672951" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block><fo:inline font-family="monospace">PRED</fo:inline> is the relation for which the
              reachability has to be determined.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672950" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>The result of <fo:inline font-family="monospace">reachX(PRED, {ROOT}, DEFS[V])
              </fo:inline>is a set that contains all nodes that are reachable
              from the <fo:inline font-family="monospace">ROOT</fo:inline> (as well as all intermediate
              nodes on each path).</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672976" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>Finally, <fo:inline font-family="monospace">E in reachX(PRED, {ROOT}, DEFS[V])
              </fo:inline>tests whether expression <fo:inline font-family="monospace">E</fo:inline> can be
              reached from the <fo:inline font-family="monospace">ROOT</fo:inline>.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1672996" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The net effect is that <fo:inline font-family="monospace">UNINIT</fo:inline> will only
          contain pairs that satisfy the test just described.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">When we execute the resulting Rascal code (i.e., the declarations
      of <fo:inline font-family="monospace">ROOT</fo:inline>, <fo:inline font-family="monospace">PRED</fo:inline>,
      <fo:inline font-family="monospace">DEFS</fo:inline>, <fo:inline font-family="monospace">USES</fo:inline> and
      <fo:inline font-family="monospace">UNINIT</fo:inline>), we get as value for
      <fo:inline font-family="monospace">UNINIT</fo:inline>:<fo:block id="id1673036" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import demo::Uninit;</fo:inline>
ok

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">UNINIT;</fo:inline>
<fo:inline font-family="monospace">rel[varname,expr]: {&lt;"q", 5&gt;, &lt;"y", 6&gt;, &lt;"z", 10&gt;}</fo:inline></fo:block>and
      this is in concordance with the informal analysis given at the beginning
      of this example.</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">As a bonus, we can also determine the <fo:inline font-style="italic">unused</fo:inline>
      variables in a program, i.e., variables that are defined but are used
      nowhere. This is done as follows:<fo:block id="id1673065" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">// module demo::Unit continued

public set[varname] UNUSED = domain(DEFS) - domain(USES);</fo:block>Taking
      the domain of the relations <fo:inline font-family="monospace">DEFS</fo:inline> and
      <fo:inline font-family="monospace">USES</fo:inline> yields the variables that are defined,
      respectively, used in the program. The difference of these two sets
      yields the unused variables, in this case
      <fo:inline font-family="monospace">{"p"}</fo:inline>.</fo:block>
    </fo:block>

    <fo:block id="section.McCabe"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">McCabe Cyclomatic Complexity</fo:marker><fo:block font-size="10pt">5.5. McCabe Cyclomatic Complexity</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The <fo:inline font-style="italic">cyclomatic complexity</fo:inline> of a program is
      defined as <fo:inline font-style="italic" font-family="monospace">e</fo:inline> - <fo:inline font-style="italic" font-family="monospace">n</fo:inline> +
      2, where <fo:inline font-style="italic" font-family="monospace">e</fo:inline> and <fo:inline font-style="italic" font-family="monospace">n</fo:inline>
      are the number of edges and nodes in the control flow graph,
      respectively. It was proposed by McCabe [<fo:basic-link internal-destination="McCabe76">McC76</fo:basic-link>]
      as a measure of program complexity. Experiments have shown that programs
      with a higher cyclomatic complexity are more difficult to understand and
      test and have more errors. It is generally accepted that a program,
      module or procedure with a cyclomatic complexity larger than 15 is
      <fo:inline font-style="italic">too complex</fo:inline>. Essentially, cyclomatic complexity
      measures the number of decision points in a program and can be computed
      by counting all if statement, case branches in switch statements and the
      number of conditional loops. Given a control flow in the form of a
      predecessor graph <fo:inline font-family="monospace">Graph[&amp;T] PRED</fo:inline> between elements
      of arbitrary type <fo:inline font-family="monospace">&amp;T</fo:inline>, the cyclomatic complexity
      can be computed in Rascal as follows: <fo:block id="id1673139" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::McCabe
import Graph;

public int cyclomaticComplexity(Graph[&amp;T] PRED){
    return size(PRED) - size(carrier(PRED)) + 2;
}</fo:block>The number of edges <fo:inline font-style="italic" font-family="monospace">e</fo:inline> is equal to
      the number of tuples in <fo:inline font-family="monospace">PRED</fo:inline>. The number of nodes
      <fo:inline font-style="italic" font-family="monospace">n</fo:inline> is equal to the number of elements in the
      carrier of PRED, i.e., all elements that occur in a tuple in
      <fo:inline font-family="monospace">PRED</fo:inline>.</fo:block>
    </fo:block>

    <fo:block id="section.dataflow"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Dataflow Analysis</fo:marker><fo:block font-size="10pt">5.6. Dataflow Analysis</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:inline font-style="italic">Dataflow analysis</fo:inline> is a program analysis
      technique that forms the basis for many compiler optimizations. It is
      described in any text book on compiler construction, e.g. [<fo:basic-link internal-destination="AhoSethiUllman86">ASU86</fo:basic-link>]. The goal of dataflow analysis is to
      determine the effect of statements on their surroundings. Typical
      examples are:</fo:block>

      <fo:list-block id="id1673184" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1673186" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Dominators (<fo:basic-link internal-destination="section.dominators"><fo:inline>Section 5.6.1, “Dominators”</fo:inline></fo:basic-link>): which
          nodes in the flow dominate the execution of other nodes?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1673199" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Reaching definitions (<fo:basic-link internal-destination="section.reaching-definitions"><fo:inline>Section 5.6.2, “Reaching Definitions”</fo:inline></fo:basic-link>): which definitions of
          variables are still valid at each statement?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1673212" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Live variables (<fo:basic-link internal-destination="section.live-variables"><fo:inline>Section 5.6.3, “Live Variables”</fo:inline></fo:basic-link>): of
          which variables will the values be used by successors of a
          statement?</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1673224" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Available expressions: an expression is available if it is
          computed along each path from the start of the program to the
          current statement.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block id="section.dominators"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.6.1. Dominators</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">A node <fo:inline font-style="italic" font-family="monospace">d</fo:inline> of a flow graph
        <fo:inline font-style="italic">dominates</fo:inline> a node <fo:inline font-style="italic" font-family="monospace">n</fo:inline>, if
        every path from the initial node of the flow graph to
        <fo:inline font-style="italic" font-family="monospace">n</fo:inline> goes through <fo:inline font-style="italic" font-family="monospace">d</fo:inline>
        [<fo:basic-link internal-destination="AhoSethiUllman86">ASU86</fo:basic-link>] (Section 10.4). Dominators
        play a role in the analysis of conditional statements and loops. The
        function <fo:inline font-family="monospace">dominators</fo:inline> that computes the dominators
        for a given flow graph <fo:inline font-family="monospace">PRED</fo:inline> and an entry node
        <fo:inline font-family="monospace">ROOT</fo:inline> is defined as follows:</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1673284" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::Dominators
import Set;
import Relation;
import Graph;

public rel[&amp;T, set[&amp;T]] dominators(rel[&amp;T,&amp;T] PRED, 
                                   &amp;T ROOT)
{
  set[&amp;T] VERTICES = carrier(PRED);
  return  { &lt;V,  (VERTICES - {V, ROOT}) - 
                 reachX(PRED,{ROOT},{V})&gt; 
            |  &amp;T V &lt;- VERTICES
          };
}</fo:block></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">First, the auxiliary set <fo:inline font-family="monospace">VERTICES</fo:inline> (all the
        statements) is computed. The relation <fo:inline font-family="monospace">DOMINATES</fo:inline>
        consists of all pairs <fo:inline font-family="monospace">&lt;<fo:inline font-style="italic" font-family="monospace">S</fo:inline>,
        {<fo:inline font-style="italic" font-family="monospace">S</fo:inline><fo:inline font-size="75%" baseline-shift="sub">1</fo:inline>,...,<fo:inline font-style="italic" font-family="monospace">S</fo:inline><fo:inline font-size="75%" baseline-shift="sub"><fo:inline font-style="italic" font-family="monospace">n</fo:inline></fo:inline>}&gt;</fo:inline>
        such that</fo:block>

        <fo:list-block id="id1673324" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1673326" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block><fo:inline font-style="italic" font-family="monospace">S</fo:inline><fo:inline font-size="75%" baseline-shift="sub"><fo:inline font-style="italic" font-family="monospace">i</fo:inline></fo:inline>
            is not an initial node or equal to
            <fo:inline font-style="italic" font-family="monospace">S</fo:inline>.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1673344" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block><fo:inline font-style="italic" font-family="monospace">S</fo:inline><fo:inline font-size="75%" baseline-shift="sub"><fo:inline font-style="italic" font-family="monospace">i</fo:inline></fo:inline>
            cannot be reached from the initial node without going through
            <fo:inline font-style="italic" font-family="monospace">S</fo:inline>.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">First import the above module and consider the sample flow graph
        PRED:<fo:block id="id1673368" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import demo::Dominators;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">rel[int,int] PRED = {
&lt;1,2&gt;, &lt;1,3&gt;,
&lt;2,3&gt;,
&lt;3,4&gt;,
&lt;4,3&gt;,&lt;4,5&gt;, &lt;4,6&gt;,
&lt;5,7&gt;,
&lt;6,7&gt;,
&lt;7,4&gt;,&lt;7,8&gt;,
&lt;8,9&gt;,&lt;8,10&gt;,&lt;8,3&gt;,
&lt;9,1&gt;,
&lt;10,7&gt;
};</fo:inline>

<fo:inline font-family="monospace">rel[int,int]: { &lt;1,2&gt;, &lt;1,3&gt;, ...</fo:inline></fo:block>It
        is illustrated in<fo:basic-link internal-destination="figure.flow-graph"><fo:inline>Figure 1.14, “Flow graph”</fo:inline></fo:basic-link><fo:block id="figure.flow-graph" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.14. Flow graph</fo:block>
            

            <fo:block id="id1673405"><fo:external-graphic src="url(dominators.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
          </fo:block>The result of applying <fo:inline font-family="monospace">dominators</fo:inline> to it
        is as follows:<fo:block id="id1673425" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">dominators(PRED);</fo:inline>
<fo:inline font-family="monospace">rel[int,int]: {&lt;1, {2, 3, 4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;2, {}&gt;, 
&lt;3, {4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;4, {5, 6, 7, 8, 9, 10}&gt;, 
&lt;5, {}&gt;, 
&lt;6, {}&gt;, 
&lt;7, {8, 9, 10}&gt;, 
&lt;8, {9, 10}&gt;, 
&lt;9, {}&gt;, 
&lt;10, {}&gt;}</fo:inline></fo:block>The resulting <fo:inline font-style="italic">dominator
        tree</fo:inline> is shown in <fo:basic-link internal-destination="figure.dominator-tree"><fo:inline>Figure 1.15, “Dominator tree”</fo:inline></fo:basic-link>.
        The dominator tree has the initial node as root and each node
        <fo:inline font-style="italic" font-family="monospace">d</fo:inline> in the tree only dominates its
        descendants in the tree.</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.dominator-tree" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.15. Dominator tree</fo:block>
            

            <fo:block id="id1673462"><fo:external-graphic src="url(dominator-tree.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
          </fo:block></fo:block>
      </fo:block>

      <fo:block id="section.reaching-definitions"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.6.2. Reaching Definitions</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We illustrate the calculation of reaching definitions using the
        example in <fo:basic-link internal-destination="figure.dataflow-graph"><fo:inline>Figure 1.16, “Flow graph for various dataflow problems”</fo:inline></fo:basic-link> which was inspired
        by [<fo:basic-link internal-destination="AhoSethiUllman86">ASU86</fo:basic-link>] (Example 10.15).</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.dataflow-graph" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.16. Flow graph for various dataflow problems</fo:block>
            

            <fo:block id="id1673514"><fo:external-graphic src="url(df-graph.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
          </fo:block></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We assume the following basic definitions to represent
        information about the program:<fo:block id="id1673532" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::ReachingDefs

import Relation;
import Graph;
import IO;

public alias stat = int;
public alias var = str;
public alias def  = tuple[stat, var];
public alias use = tuple[stat,var];

public rel[stat,def] definition(rel[stat,var] DEFS){
  return {&lt;S,&lt;S,V&gt;&gt; | &lt;stat S, var V&gt; &lt;- DEFS};
}

public rel[stat,def] use(rel[stat, var] USES){
  return {&lt;S, &lt;S, V&gt;&gt; | &lt;stat S, var V&gt; &lt;- USES};
}
</fo:block></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Let's use the following values to represent our example:</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1673543" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, 
                                &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,7&gt;, 
                                &lt;6,7&gt;, &lt;7,4&gt; };</fo:inline>
<fo:inline font-family="monospace">rel[stat,stat]: { &lt;1,2&gt;, &lt;2,3&gt;, ...</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">rel[stat, var] DEFS = { &lt;1, "i"&gt;, &lt;2, "j"&gt;, 
                                &lt;3, "a"&gt;, &lt;4, "i"&gt;, 
                                &lt;5, "j"&gt;, &lt;6, "a"&gt;, 
                                &lt;7, "i"&gt; };</fo:inline>
<fo:inline font-family="monospace">rel[stat,var]: { &lt;1, "i"&gt;, &lt;2, "j"&gt;, ...</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">rel[stat,var] USES = { &lt;1, "m"&gt;, &lt;2, "n"&gt;, 
                               &lt;3, "u1"&gt;, &lt;4, "i"&gt;, 
                               &lt;5, "j"&gt;, &lt;6, "u2"&gt;, 
                               &lt;7, "u3"&gt; };</fo:inline>
<fo:inline font-family="monospace">rel[stat,var]: { &lt;1, "m"&gt;, &lt;2, "n"&gt;,...</fo:inline></fo:block></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">For convenience, we have introduced above a notion
        <fo:inline font-family="monospace">def</fo:inline> that describes that a certain statement defines
        some variable and we revamp the basic relations into a more convenient
        format using this new type and the auxiliary functions
        <fo:inline font-family="monospace">definition</fo:inline> and <fo:inline font-family="monospace">use</fo:inline>:<fo:block id="id1673595" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">definition(DEFS);</fo:inline>
<fo:inline font-family="monospace">rel[stat,def]: { &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, 
                 &lt;3, &lt;3, "a"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
                 &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, 
                 &lt;7, &lt;7, "i"&gt;&gt; }</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">use(USES);</fo:inline>
<fo:inline font-family="monospace">rel[stat,def]: { &lt;1, &lt;1, "m"&gt;&gt;, &lt;2, &lt;2, "n"&gt;&gt;, 
                 &lt;3, &lt;3, "u1"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
                 &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "u2"&gt;&gt;, 
                 &lt;7, &lt;7, "u3"&gt;&gt; }</fo:inline></fo:block></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Now we are ready to define an important new relation
        <fo:inline font-family="monospace">KILL</fo:inline>. <fo:inline font-family="monospace">KILL</fo:inline> defines which
        variable definitions are undone (killed) at each statement and is
        defined by the following function
        <fo:inline font-family="monospace">kill</fo:inline>:<fo:block id="id1673635" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">// continuing module demo::ReachingDefs

public rel[stat,def] kill(rel[stat,var] DEFS) { 
  return {&lt;S1, &lt;S2, V&gt;&gt; | &lt;stat S1, var V&gt; &lt;- DEFS, 
                          &lt;stat S2, V&gt; &lt;- DEFS, 
                          S1 != S2};
}</fo:block>In this definition, all variable definitions are compared
        with each other, and for each variable definition all
        <fo:inline font-style="italic">other</fo:inline> definitions of the same variable are placed
        in its kill set. In the example, <fo:inline font-family="monospace">KILL</fo:inline> gets the
        value <fo:block id="id1673652" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">kill(DEFS);</fo:inline>
<fo:inline font-family="monospace">rel[stat,def]: 
{ &lt;1, &lt;4, "i"&gt;&gt;, &lt;1, &lt;7, "i"&gt;&gt;, &lt;2, &lt;5, "j"&gt;&gt;, 
  &lt;3, &lt;6, "a"&gt;&gt;, &lt;4, &lt;1, "i"&gt;&gt;, &lt;4, &lt;7, "i"&gt;&gt;, 
  &lt;5, &lt;2, "j"&gt;&gt;, &lt;6, &lt;3, "a"&gt;&gt;, &lt;7, &lt;1, "i"&gt;&gt;, 
  &lt;7, &lt;4, "i"&gt;&gt;
}</fo:inline></fo:block>and, for instance, the definition of variable
        <fo:inline font-family="monospace">i</fo:inline> in statement <fo:inline font-family="monospace">1</fo:inline> kills the
        definitions of <fo:inline font-family="monospace">i</fo:inline> in statements <fo:inline font-family="monospace">4</fo:inline>
        and <fo:inline font-family="monospace">7</fo:inline>.</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">After these preparations, we are ready to formulate the reaching
        definitions problem in terms of two relations <fo:inline font-family="monospace">IN</fo:inline>
        and <fo:inline font-family="monospace">OUT</fo:inline>. <fo:inline font-family="monospace">IN</fo:inline> captures all the
        variable definitions that are valid at the entry of each statement and
        <fo:inline font-family="monospace">OUT</fo:inline> captures the definitions that are still valid
        after execution of each statement. Intuitively, for each statement
        <fo:inline font-family="monospace">S</fo:inline>, <fo:inline font-family="monospace">IN[S]</fo:inline> is equal to the union
        of the <fo:inline font-family="monospace">OUT</fo:inline> of all the predecessors of
        <fo:inline font-family="monospace">S</fo:inline>. <fo:inline font-family="monospace">OUT[S]</fo:inline>, on the other hand, is
        equal to the definitions generated by <fo:inline font-family="monospace">S</fo:inline> to which we
        add <fo:inline font-family="monospace">IN[S]</fo:inline> minus the definitions that are killed in
        <fo:inline font-family="monospace">S</fo:inline>. Mathematically, the following set of equations
        captures this idea for each statement:</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">IN[S] = UNION<fo:inline font-size="75%" baseline-shift="sub">P in predecessors of S</fo:inline>
        OUT[P]</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">OUT[S] = DEF[S] + (IN[S] - KILL[S])</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">This idea can be expressed in Rascal quite
        literally:<fo:block id="id1673755" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">public rel[stat, def] reachingDefinitions(
                            rel[stat,var] DEFS, 
                            rel[stat,stat] PRED){
  set[stat] STATEMENT = carrier(PRED);
  rel[stat,def] DEF  = definition(DEFS);
  rel[stat,def] KILL = kill(DEFS);

  // The set of mutually recursive dataflow equations 
  // that has to be solved:
  
  rel[stat,def] IN = {};
  rel[stat,def] OUT = DEF;

  solve (IN, OUT) {
    IN  = {&lt;S, D&gt; | int S &lt;- STATEMENT, 
                    stat P &lt;- predecessors(PRED,S), 
                    def D &lt;- OUT[P]};
    OUT = {&lt;S, D&gt; | int S &lt;- STATEMENT, 
                    def D &lt;- DEF[S] + (IN[S] - KILL[S])};
  };
  return IN;
}</fo:block>First, the relations <fo:inline font-family="monospace">IN</fo:inline> and
        <fo:inline font-family="monospace">OUT</fo:inline> are declared and initialized. Next follows a
        solve statement that uses <fo:inline font-family="monospace">IN</fo:inline> and
        <fo:inline font-family="monospace">OUT</fo:inline> as variables and contains two equations that
        resemble the mathematical equations given above. Note the use of the
        library function <fo:inline font-family="monospace">predecessors</fo:inline> to obtain the
        predecessors of a statement for a given control flow graph.</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.reaching-definitions" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.17. Reaching definitions for flow graph in <fo:basic-link internal-destination="figure.dataflow-graph"><fo:inline>Figure 1.16, “Flow graph for various dataflow problems”</fo:inline></fo:basic-link></fo:block>
            

            <fo:block id="id1673805"><fo:external-graphic src="url(reach.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
          </fo:block> For our running example (<fo:basic-link internal-destination="figure.reaching-definitions"><fo:inline>Figure 1.17, “Reaching definitions for flow graph in Figure 1.16, “Flow graph for various dataflow problems””</fo:inline></fo:basic-link>) the results are as follows
        (see <fo:basic-link internal-destination="figure.reaching-definitions"><fo:inline>Figure 1.17, “Reaching definitions for flow graph in Figure 1.16, “Flow graph for various dataflow problems””</fo:inline></fo:basic-link>). Relation
        <fo:inline font-family="monospace">IN</fo:inline> has as value:<fo:block id="id1673832" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">{ &lt;2, &lt;1, "i"&gt;&gt;, &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, 
  &lt;4, &lt;3, "a"&gt;&gt;, &lt;4, &lt;2, "j"&gt;&gt;, &lt;4, &lt;1, "i"&gt;&gt;, 
  &lt;4, &lt;7, "i"&gt;&gt;, &lt;4, &lt;5, "j"&gt;&gt;, &lt;4, &lt;6, "a"&gt;&gt;, 
  &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;2, "j"&gt;&gt;, 
  &lt;5, &lt;5, "j"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, &lt;6, &lt;5, "j"&gt;&gt;, 
  &lt;6, &lt;4, "i"&gt;&gt;, &lt;6, &lt;3, "a"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, 
  &lt;7, &lt;5, "j"&gt;&gt;, &lt;7, &lt;4, "i"&gt;&gt;, &lt;7, &lt;3, "a"&gt;&gt;, 
  &lt;7, &lt;6, "a"&gt;&gt;
}</fo:block></fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">If we consider statement <fo:inline font-family="monospace">3</fo:inline>, then the
        definitions of variables <fo:inline font-family="monospace">i</fo:inline> and <fo:inline font-family="monospace">j</fo:inline>
        from the preceding two statements are still valid. A more interesting
        case are the definitions that can reach statement
        <fo:inline font-family="monospace">4</fo:inline>:</fo:block>

        <fo:list-block id="id1673858" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1673860" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>The definitions of variables <fo:inline font-family="monospace">a</fo:inline>,
            <fo:inline font-family="monospace">j</fo:inline> and <fo:inline font-family="monospace">i</fo:inline> from, respectively,
            statements <fo:inline font-family="monospace">3</fo:inline>, <fo:inline font-family="monospace">2</fo:inline> and
            <fo:inline font-family="monospace">1</fo:inline>.</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1673893" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>The definition of variable <fo:inline font-family="monospace">i</fo:inline> from
            statement <fo:inline font-family="monospace">7</fo:inline> (via the backward control flow path
            from <fo:inline font-family="monospace">7</fo:inline> to <fo:inline font-family="monospace">4</fo:inline>).</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1673914" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>The definition of variable <fo:inline font-family="monospace">j</fo:inline> from
            statement <fo:inline font-family="monospace">5</fo:inline> (via the path <fo:inline font-family="monospace">5</fo:inline>,
            <fo:inline font-family="monospace">7</fo:inline>, <fo:inline font-family="monospace">4</fo:inline>).</fo:block>
          </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1673940" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
            <fo:block>The definition of variable <fo:inline font-family="monospace">a</fo:inline> from
            statement <fo:inline font-family="monospace">6</fo:inline> (via the path <fo:inline font-family="monospace">6</fo:inline>,
            <fo:inline font-family="monospace">7</fo:inline>, <fo:inline font-family="monospace">4</fo:inline>).</fo:block>
          </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Relation <fo:inline font-family="monospace">OUT</fo:inline> has as value:<fo:block id="id1673977" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">{ &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, &lt;2, &lt;1, "i"&gt;&gt;, 
  &lt;3, &lt;3, "a"&gt;&gt;, &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, 
  &lt;4, &lt;4, "i"&gt;&gt;, &lt;4, &lt;3, "a"&gt;&gt;, &lt;4, &lt;2, "j"&gt;&gt;, 
  &lt;4, &lt;5, "j"&gt;&gt;, &lt;4, &lt;6, "a"&gt;&gt;, &lt;5, &lt;5, "j"&gt;&gt;, 
  &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, 
  &lt;6, &lt;6, "a"&gt;&gt;, &lt;6, &lt;5, "j"&gt;&gt;, &lt;6, &lt;4, "i"&gt;&gt;, 
  &lt;7, &lt;7, "i"&gt;&gt;, &lt;7, &lt;5, "j"&gt;&gt;, &lt;7, &lt;3, "a"&gt;&gt;, 
  &lt;7, &lt;6, "a"&gt;&gt;
}</fo:block>Observe, again for statement <fo:inline font-family="monospace">4</fo:inline>, that all
        definitions of variable <fo:inline font-family="monospace">i</fo:inline> are missing in
        <fo:inline font-family="monospace">OUT[4]</fo:inline> since they are killed by the definition of
        <fo:inline font-family="monospace">i</fo:inline> in statement <fo:inline font-family="monospace">4</fo:inline> itself.
        Definitions for <fo:inline font-family="monospace">a</fo:inline> and <fo:inline font-family="monospace">j</fo:inline> are,
        however, contained in <fo:inline font-family="monospace">OUT[4]</fo:inline>. The result of
        reaching definitions computation is illustrated in <fo:basic-link internal-destination="figure.reaching-definitions"><fo:inline>Figure 1.17, “Reaching definitions for flow graph in Figure 1.16, “Flow graph for various dataflow problems””</fo:inline></fo:basic-link>. We will use the function
        <fo:inline font-family="monospace">reachingDefinitions</fo:inline> later on in <fo:basic-link internal-destination="section.program-slicing"><fo:inline>Section 5.7, “Program Slicing”</fo:inline></fo:basic-link> when defining program
        slicing.</fo:block>
      </fo:block>

      <fo:block id="section.live-variables"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:block font-size="10pt">5.6.3. Live Variables</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
        

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The live variables of a statement are those variables whose
        value will be used by the current statement or some successor of it.
        The mathematical formulation of this problem is as follows:</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">IN[S] =USE[S] + (OUT[S] - DEF[S])</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">OUT[S] = UNION<fo:inline font-size="75%" baseline-shift="sub">S' in successors of S</fo:inline>
        IN[S']</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The first equation says that a variable is live coming into a
        statement if either it is used before redefinition in that statement
        or it is live coming out of the statement and is not redefined in it.
        The second equation says that a variable is live coming out of a
        statement if and only if it is live coming into one of its
        successors.</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">This can be expressed in Rascal as follows:<fo:block id="id1674061" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">public rel[stat,def] liveVariables(rel[stat, var] DEFS, 
                                   rel[stat, var] USES, 
                                   rel[stat,stat] PRED){
  set[stat] STATEMENT = carrier(PRED);
  rel[stat,def] DEF  = definition(DEFS);
  rel[stat,def] USE = use(USES);
 
  rel[stat,def] LIN = {};
  rel[stat,def] LOUT = DEF;

  solve(LIN, LOUT) {
    LIN  = { &lt;S, D&gt; | stat S &lt;- STATEMENT,  
                      def D &lt;- USE[S] + 
                               (LOUT[S] - (DEF[S]))};
    LOUT = { &lt;S, D&gt; | stat S &lt;- STATEMENT,  
                      stat Succ &lt;- successors(PRED,S), 
                      def D &lt;- LIN[Succ] };
  }
  return LIN;
}</fo:block>The results of live variable analysis for our running
        example are illustrated in <fo:basic-link internal-destination="figure.live-variables"><fo:inline>Figure 1.18, “Live variables for flow graph in Figure 1.16, “Flow graph for various dataflow problems””</fo:inline></fo:basic-link>.</fo:block>

        <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="figure.live-variables" space-before.minimum="0.5em" space-before.optimum="1em" space-before.maximum="2em" space-after.minimum="0.5em" space-after.optimum="1em" space-after.maximum="2em" keep-together.within-column="always"><fo:block font-weight="bold" font-size="12pt" hyphenate="false" space-after.minimum="0.4em" space-after.optimum="0.6em" space-after.maximum="0.8em" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" keep-with-next.within-column="always">Figure 1.18. Live variables for flow graph in <fo:basic-link internal-destination="figure.dataflow-graph"><fo:inline>Figure 1.16, “Flow graph for various dataflow problems”</fo:inline></fo:basic-link></fo:block>
            

            <fo:block id="id1674089"><fo:external-graphic src="url(live.png)" width="auto" height="auto" content-width="40%" content-height="40%"/></fo:block>
          </fo:block></fo:block>
      </fo:block>
    </fo:block>

    <fo:block id="section.program-slicing"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Program Slicing</fo:marker><fo:block font-size="10pt">5.7. Program Slicing</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
      

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Program slicing is a technique proposed by Weiser [<fo:basic-link internal-destination="Weiser84">Wei84</fo:basic-link>] for automatically decomposing programs in parts by
      analyzing their data flow and control flow. Typically, a given statement
      in a program is selected as the <fo:inline font-style="italic">slicing criterion</fo:inline>
      and the original program is reduced to an independent subprogram, called
      a <fo:inline font-style="italic">slice</fo:inline>, that is guaranteed to represent faithfully
      the behavior of the original program at the slicing criterion. An
      example will illustrate this (we use line numbers for later
      reference):</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="programlisting.slice-example" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">[ 1] read(n)        [1] read(n)      [ 1] read(n)
[ 2] i := 1         [2] i := 1       [ 2] i := 1
[ 3] sum := 0       [3] sum := 0      
[ 4] product := 1                    [ 4] product := 1
[ 5] while i&lt;= n    [5] while i&lt;= n  [ 5] while i&lt;= n
     do                 do                do
     begin              begin             begin
[ 6]  sum :=        [6]  sum :=
          sum + i            sum + i
[ 7]  product :=                     [ 7]  product := 
        product * i                          product * i
[ 8]  i := i + 1    [8]  i := i + 1  [ 8]  i := i + 1
     end                 end              end
[ 9] write(sum)     [9] write(sum)
[10] write(product)                  [10] write(product)

<fo:inline font-weight="bold">(a)</fo:inline> Sample program  <fo:inline font-weight="bold">(b)</fo:inline> Slice for    <fo:inline font-weight="bold">(c)</fo:inline> Slice for
                        statement [9]    statement [10]</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The initial program is given as (a). The slice with statement [9]
      as slicing criterion is shown in (b): statements <fo:inline font-family="monospace">[4]</fo:inline>
      and <fo:inline font-family="monospace">[7]</fo:inline> are irrelevant for computing statement
      <fo:inline font-family="monospace">[9]</fo:inline> and do not occur in the slice. Similarly, (c)
      shows the slice with statement <fo:inline font-family="monospace">[10]</fo:inline> as slicing
      criterion. This particular form of slicing is called <fo:inline font-style="italic">backward
      slicing</fo:inline>. Slicing can be used for debugging and program
      understanding, optimization and more. An overview of slicing techniques
      and applications can be found in [<fo:basic-link internal-destination="Tip95">Tip95</fo:basic-link>]. Here we
      will explore a relational formulation of slicing adapted from a proposal
      in [<fo:basic-link internal-destination="JacksonRollins94">JR94</fo:basic-link>]. The basic ingredients of
      the approach are as follows:</fo:block>

      <fo:list-block id="id1674206" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1674209" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>We assume the relations <fo:inline font-family="monospace">PRED</fo:inline>,
          <fo:inline font-family="monospace">DEFS</fo:inline> and <fo:inline font-family="monospace">USES</fo:inline> as
          before.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674229" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>We assume an additional set
          <fo:inline font-family="monospace">CONTROL-STATEMENT</fo:inline> that defines which statements
          are control statements.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674240" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>To tie together dataflow and control flow, three auxiliary
          variables are introduced:</fo:block>

          <fo:list-block id="id1674248" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1674250" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>The variable <fo:inline font-family="monospace">TEST</fo:inline> represents the
              outcome of a specific test of some conditional statement. The
              conditional statement defines <fo:inline font-family="monospace">TEST</fo:inline> and all
              statements that are control dependent on this conditional
              statement will use <fo:inline font-family="monospace">TEST</fo:inline>.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674273" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>The variable <fo:inline font-family="monospace">EXEC</fo:inline> represents the
              potential execution dependence of a statement on some
              conditional statement. The dependent statement defines
              <fo:inline font-family="monospace">EXEC</fo:inline> and an explicit (control) dependence is
              made between <fo:inline font-family="monospace">EXEC</fo:inline> and the corresponding
              <fo:inline font-family="monospace">TEST</fo:inline>.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674298" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
              <fo:block>The variable <fo:inline font-family="monospace">CONST</fo:inline> represents an
              arbitrary constant.</fo:block>
            </fo:block></fo:list-item-body></fo:list-item></fo:list-block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">The calculation of a (backward) slice now proceeds in six
      steps:</fo:block>

      <fo:list-block id="id1674315" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1674319" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Compute the relation <fo:inline font-family="monospace">rel[use,def] use-def</fo:inline>
          that relates all uses to their corresponding definitions. The
          function <fo:inline font-family="monospace">reaching-definitions</fo:inline> as shown earlier in
          <fo:basic-link internal-destination="section.reaching-definitions"><fo:inline>Section 5.6.2, “Reaching Definitions”</fo:inline></fo:basic-link>does most of the
          work.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674339" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Compute the relation <fo:inline font-family="monospace">rel[def,use]
          def-use-per-stat</fo:inline> that relates the
          <fo:inline font-style="italic">internal</fo:inline> definitions and uses of a
          statement.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674352" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Compute the relation <fo:inline font-family="monospace">rel[def,use]
          control-dependence</fo:inline> that links all <fo:inline font-family="monospace">EXEC</fo:inline>s
          to the corresponding <fo:inline font-family="monospace">TEST</fo:inline>s.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674374" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>Compute the relation <fo:inline font-family="monospace">rel[use,def]
          use-control-def</fo:inline> combines use/def dependencies with control
          dependencies.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674384" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>After these preparations, compute the relation
          <fo:inline font-family="monospace">rel[use,use] USE-USE</fo:inline> that contains dependencies
          of uses on uses.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674393" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
          <fo:block>The backward slice for a given slicing criterion (a use) is
          now simply the projection of <fo:inline font-family="monospace">USE-USE</fo:inline> for the
          slicing criterion.</fo:block>
        </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">This informal description of backward slicing can now be expressed
      in Rascal:</fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1674410" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0">module demo::Slicing

import Set;
import Relation;
import demo::ReachingDefs;
import demo::Dominators;
import UnitTest;

set[use] BackwardSlice(set[stat] CONTROLSTATEMENT, 
                       rel[stat,stat] PRED,
                       rel[stat,var] USES,
                       rel[stat,var] DEFS,	
                       use Criterion) {

  rel[stat, def] REACH = reachingDefinitions(DEFS, PRED);

  // Compute the relation between each use and 
  // corresponding definitions: use_def

  rel[use,def] use_def =
  {&lt;&lt;S1,V&gt;, &lt;S2,V&gt;&gt; | &lt;stat S1, var V&gt; &lt;- USES, 
                      &lt;stat S2, V&gt; &lt;- REACH[S1]};

  // Internal dependencies per statement

  rel[def,use] def_use_per_stat  = 
       {&lt;&lt;S,V1&gt;, &lt;S,V2&gt;&gt; | &lt;stat S, var V1&gt; &lt;- DEFS, 
                           &lt;S, var V2&gt; &lt;- USES}
       +
       {&lt;&lt;S,V&gt;, &lt;S,"EXEC"&gt;&gt; | &lt;stat S, var V&gt; &lt;- DEFS}
       +
       {&lt;&lt;S,"TEST"&gt;,&lt;S,V&gt;&gt; | stat S &lt;- CONTROLSTATEMENT, 
                             &lt;S, var V&gt; &lt;- 
                                      domainR(USES, {S})};

  // Control dependence: control-dependence

  rel[stat, set[stat]] CONTROLDOMINATOR = 
  domainR(dominators(PRED, 1), CONTROLSTATEMENT);

  rel[def,use] control_dependence  =
  { &lt;&lt;S2, "EXEC"&gt;,&lt;S1,"TEST"&gt;&gt; 
    | &lt;stat S1, stat S2&gt; &lt;- CONTROLDOMINATOR};

  // Control and data dependence: use-control-def

  rel[use,def] use_control_def = 
               use_def + control_dependence;
  rel[use,use] USE_USE = 
               (use_control_def o def_use_per_stat)*;

  return USE_USE[Criterion];
}</fo:block></fo:block>

      <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Let's apply this to the example from the start of this section and
      assume the following:<fo:block id="id1674430" text-align="start" wrap-option="no-wrap" space-before.minimum="0.8em" space-before.optimum="1em" space-before.maximum="1.2em" space-after.minimum="0.8em" space-after.optimum="1em" space-after.maximum="1.2em" hyphenate="false" white-space-collapse="false" white-space-treatment="preserve" linefeed-treatment="preserve" font-family="monospace" background-color="#E0E0E0"><fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">import demo::Slicing;</fo:inline>
<fo:inline font-family="monospace">ok</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, 
                                &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,9&gt;, 
                                &lt;6,7&gt;, &lt;7,8&gt;, &lt;8,5&gt;, 
                                &lt;8,9&gt;, &lt;9,10&gt; };</fo:inline>
<fo:inline font-family="monospace">rel[stat,stat]: {&lt;1,2&gt;, ...</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">rel[stat,var] DEFS  = { &lt;1, "n"&gt;, &lt;2, "i"&gt;, 
                                &lt;3, "sum"&gt;, 
                                &lt;4,"product"&gt;, 
                                &lt;6, "sum"&gt;, 
                                &lt;7, "product"&gt;, 
                                &lt;8, "i"&gt; };</fo:inline>
<fo:inline font-family="monospace">rel[stat,var]: {&lt;1, "n"&gt;, ...</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">rel[stat,var] USES  = { &lt;5, "i"&gt;, &lt;5, "n"&gt;, 
                                &lt;6, "sum"&gt;, &lt;6,"i"&gt;, 
                                &lt;7, "product"&gt;, &lt;7, "i"&gt;, 
                                &lt;8, "i"&gt;, &lt;9, "sum"&gt;, 
                                &lt;10, "product"&gt;
                              };</fo:inline>
<fo:inline font-family="monospace">rel[stat,var]; { &lt;5, "i"&gt; ...</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">set[int] CONTROL-STATEMENT = { 5 };</fo:inline>
<fo:inline font-family="monospace">set[int]: {5}</fo:inline>

<fo:inline font-family="monospace">rascal&gt;</fo:inline> <fo:inline font-weight="bold" font-family="monospace">BackwardSlice(CONTROL-STATEMENT, 
                      PRED, USES, DEFS, &lt;9, "sum"&gt;);</fo:inline>
<fo:inline font-family="monospace">set[use]: { &lt;1, "EXEC"&gt;, &lt;2, "EXEC"&gt;,  &lt;3, "EXEC"&gt;, 
            &lt;5, "i"&gt;, &lt;5, "n"&gt;, &lt;6, "sum"&gt;, &lt;6, "i"&gt;, 
            &lt;6, "EXEC"&gt;, &lt;8, "i"&gt;, &lt;8, "EXEC"&gt;, 
            &lt;9, "sum"&gt; }</fo:inline></fo:block>Take the domain of
      this result and we get exactly the statements in (b) of the
      example.</fo:block>
    </fo:block>
  </fo:block>

  <fo:block id="id1674111"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Concluding Remarks</fo:marker><fo:block font-size="11pt">6. Concluding Remarks</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
    

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal and its IDE are in full development at the time of writing
    and a first prototype implementation is available for download. We have
    given here only a sketch of the language and its applications. The
    following topics have not been covered in this article:</fo:block>

    <fo:list-block id="id1674520" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em" space-after.optimum="1em" space-after.minimum="0.8em" space-after.maximum="1.2em" provisional-label-separation="0.2em" provisional-distance-between-starts="1.0em"><fo:list-item id="id1674523" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block>The use of SDF modules to parse source text.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674532" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block>The extensive Rascal library that supports many operations on
        the basic datatypes including shortest path, reachability and
        bisimulation on graphs. It also provides tools for drawing graphs and
        charts, for extracting data from Subversion repositories and
        more.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674542" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block>The Rascal Eclipse JDT library that provides direct access to
        facts that have been extracted from Java source code.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item><fo:list-item id="id1674552" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:list-item-label end-indent="label-end()"><fo:block>•</fo:block></fo:list-item-label><fo:list-item-body start-indent="body-start()"><fo:block>
        <fo:block>The Rascal IDE that is based on Eclipse and that provides, for
        instance, very good interactive debugging facilities and basic
        visualization tools.</fo:block>
      </fo:block></fo:list-item-body></fo:list-item></fo:list-block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">We refer the interested reader to <fo:basic-link external-destination="url(http://www.meta-environment.org/Meta-Environment/Rascal)"><fo:inline>http://www.meta-environment.org/Meta-Environment/Rascal</fo:inline></fo:basic-link>
    for a more complete and up-to-date overview and for downloading the latest
    version of Rascal.</fo:block>
  </fo:block>

  <fo:block id="id1674573"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Acknowledgements</fo:marker><fo:block font-size="11pt">7. Acknowledgements</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
    

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Rascal has been designed and implemented by the authors but they
    have received strong support, encouragement, and help from the following
    individuals. We are very grateful to them.</fo:block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Emilie Balland implemented the Rascal debugger in the Eclipse
    version of Rascal during her visit to CWI in the summer of 2009.</fo:block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Bas Basten provided useful feedback on the design and is developing
    a Rascal/Eclipse JDT interface that makes it easy to extract facts from
    Java source code. Joppe Kroon further improved the JDT interface.</fo:block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Bob Fuhrer's inspiring IMP project motivated us to build Rascal on
    top of IMP. The PDB was designed and implemented during Jurgen's visit to
    IBM Research in 2007-2008.</fo:block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Arnold Lankamp implemented a very efficient version of the Program
    Data Base (PDB), added a binary streaming format, implemented the SGLR
    invoker, and takes care of deployment issues.</fo:block>

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">Claus Brabrand, Karel Pieterson, Frank Tip and Yaroslav Usenko
    provided feedback on this manual and suggested several
    improvements.</fo:block>
  </fo:block>

  <fo:block id="section.bibliography"><fo:block><fo:block><fo:block margin-left="0pt" font-family="sans-serif,Symbol,ZapfDingbats" keep-together.within-column="always"><fo:block keep-with-next.within-column="always"><fo:block font-family="sans-serif" font-weight="bold" keep-with-next.within-column="always" space-before.minimum="0.8em" space-before.optimum="1.0em" space-before.maximum="1.2em" text-align="start" start-indent="0pt"><fo:marker marker-class-name="section.head.marker">Bibliography</fo:marker><fo:block font-size="11pt">8. Bibliography</fo:block></fo:block></fo:block></fo:block></fo:block></fo:block>
    

    <fo:block space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em"><fo:block id="id1674622" space-before.minimum="1em" space-before.optimum="1.5em" space-before.maximum="2em"><fo:block id="AhoSethiUllman86" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[ASU86] <fo:inline>A.V. Aho, R. Sethi, and J.D. Ullman. </fo:inline><fo:inline><fo:inline font-style="italic">Compilers: Principles, Techniques and Tools</fo:inline>. </fo:inline><fo:inline>Addison-Wesley</fo:inline><fo:inline>1986. </fo:inline></fo:block><fo:block id="ElanBKKMR-wrla98" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[BKK+98] <fo:inline><fo:inline>P. Borovansky, C. Kirchner, H. Kirchner, P.-E. Moreau, and C. Ringeissen. </fo:inline><fo:inline font-style="italic">An overview of ELAN</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Proceedings of the 2nd International Workshop on
  Rewriting Logic and its Applications (WRLA'98). </fo:inline> </fo:inline><fo:inline>C. Kirchner and H. Kirchner. </fo:inline><fo:inline>15. </fo:inline><fo:inline>1998. </fo:inline><fo:inline>55--70. </fo:inline><fo:inline>Electronic Notes in Theoretical Computer Science</fo:inline></fo:inline></fo:block><fo:block id="BallandBKMR-RTA2007" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[BBK+07] <fo:inline><fo:inline>E. Balland, P. Brauner, R. Kopetz, P.-E. Moreau, and A. Reilles. </fo:inline><fo:inline font-style="italic">Tom: Piggybacking rewriting on Java</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Proceedings of the 18th Conference on Rewriting
  Techniques and Applications (RTA'07). </fo:inline> </fo:inline><fo:inline>LNCS. </fo:inline><fo:inline>4533. </fo:inline><fo:inline>2007. </fo:inline><fo:inline>36--47. </fo:inline><fo:inline>Springer-Verlag</fo:inline></fo:inline></fo:block><fo:block id="DMS" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[BPM04] <fo:inline><fo:inline>I. Baxter, P. Pidgeon, and M. Mehlich. </fo:inline><fo:inline font-style="italic">DMS: Program transformations for practical scalable software
  evolution</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Proceedings of the International Conference on
  Software Engineering (ICSE'04). </fo:inline> </fo:inline><fo:inline>2004. </fo:inline><fo:inline>625--634. </fo:inline><fo:inline>IEEE</fo:inline></fo:inline></fo:block><fo:block id="BNL05" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[BNL05] <fo:inline><fo:inline>D. Beyer, A Noack, and C. Lewerentz. </fo:inline><fo:inline font-style="italic">Efficient relational calculation for software analysis</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">IEEE Trans Software Engineering</fo:inline>. <fo:inline>31. </fo:inline><fo:inline>2. </fo:inline><fo:inline>2005. </fo:inline></fo:inline><fo:inline>137--149. </fo:inline></fo:block><fo:block id="BDHJJKKMOSVVV01" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[BDH+01] <fo:inline><fo:inline>M.G.J. van
  den Brand, A.
  van Deursen, J. Heering, H.A.
  de Jong, M.
  de Jonge, T. Kuipers, P. Klint, L. Moonen, P.A. Olivier, J. Scheerder, J.J. Vinju, E. Visser, and J. Visser. </fo:inline><fo:inline font-style="italic">The ASF+SDF Meta-Environment: a Component-Based
  Language Development Environment</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Compiler Construction (CC
  '01). </fo:inline> </fo:inline><fo:inline>R. Wilhelm. </fo:inline><fo:inline>LNCS. </fo:inline><fo:inline>2027. </fo:inline><fo:inline>2001. </fo:inline><fo:inline>365--370. </fo:inline><fo:inline>Springer-Verlag</fo:inline></fo:inline></fo:block><fo:block id="BKV03" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[BKV03] <fo:inline><fo:inline>M.G.J. van
  den Brand, P. Klint, and J.J. Vinju. </fo:inline><fo:inline font-style="italic">Term rewriting with traversal functions</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">ACM Transactions on Software Engineering Methodology</fo:inline>. <fo:inline>12. </fo:inline><fo:inline>2. </fo:inline><fo:inline>2003. </fo:inline></fo:inline><fo:inline>152--190. </fo:inline></fo:block><fo:block id="BKVV08" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[BKVV08] <fo:inline><fo:inline>M. Bravenboer, K. Trygve Kalleberg, R. Vermaas, and E. Visser. </fo:inline><fo:inline font-style="italic">Stratego/XT 0.17. A language and toolset for program
  transformation</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">Science of Computer Programming</fo:inline>. <fo:inline>72. </fo:inline><fo:inline>1-2. </fo:inline><fo:inline>June 2008. </fo:inline></fo:inline><fo:inline>52--70. </fo:inline></fo:block><fo:block id="CordyTXL06" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[Cor06] <fo:inline><fo:inline>J. R. Cordy. </fo:inline><fo:inline font-style="italic">The TXL source transformation language</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">Science of Computer Programming</fo:inline>. <fo:inline>61. </fo:inline><fo:inline>3. </fo:inline><fo:inline>August 2006. </fo:inline></fo:inline><fo:inline>190--210. </fo:inline></fo:block><fo:block id="FeijsKrikhaarOmmering98" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[FKO98] <fo:inline><fo:inline>L.M.G. Feijs, R. Krikhaar, and R.C. Ommering. </fo:inline><fo:inline font-style="italic">A relational approach to support software architecture
  analysis</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">Software Practice and Experience</fo:inline>. <fo:inline>28. </fo:inline><fo:inline>4. </fo:inline><fo:inline>april 1998. </fo:inline></fo:inline><fo:inline>371--400. </fo:inline></fo:block><fo:block id="Grok" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[Hol08] <fo:inline><fo:inline>R. C. Holt. </fo:inline><fo:inline font-style="italic">Grokking software architecture</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Proceedings of the 15th Working Conference on
  Reverse Engineering (WCRE'08). </fo:inline> </fo:inline><fo:inline>2008. </fo:inline><fo:inline>5--14. </fo:inline><fo:inline>IEEE</fo:inline></fo:inline></fo:block><fo:block id="HedinMagnusson03" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[HM03] <fo:inline><fo:inline>G. Hedin and E. Magnusson. </fo:inline><fo:inline font-style="italic">The JastAdd system -- an aspect-oriented compiler construction
  system</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">Science of Computer Programming</fo:inline>. <fo:inline>2003. </fo:inline></fo:inline><fo:inline>37--58. </fo:inline></fo:block><fo:block id="JacksonRollins94" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[JR94] <fo:inline><fo:inline>D.J. Jackson and E.J. Rollins. </fo:inline><fo:inline font-style="italic">A new model of program dependences for reverse engineering</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Proceedings of the 2nd ACM SIGSOFT symposium on
  Foundations of software engineering. </fo:inline> </fo:inline><fo:inline>ACM SIGSOFT Software Engineering
  Notes. </fo:inline><fo:inline>19. </fo:inline><fo:inline>1994. </fo:inline><fo:inline>2--10. </fo:inline></fo:inline></fo:block><fo:block id="Klint93" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[Kli93] <fo:inline><fo:inline>P. Klint. </fo:inline><fo:inline font-style="italic">A meta-environment for generating programming environments</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">ACM Transactions on Software Engineering and Methodology</fo:inline>. <fo:inline>2. </fo:inline><fo:inline>2. </fo:inline><fo:inline>April 1993. </fo:inline></fo:inline><fo:inline>176--201. </fo:inline></fo:block><fo:block id="KlintIWPC03" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[Kli03] <fo:inline><fo:inline>P. Klint. </fo:inline><fo:inline font-style="italic">How understanding and restructuring differ from compiling---a
  rewriting perspective</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Proceedings of the 11th International Workshop on
  Program Comprehension (IWPC03). </fo:inline> </fo:inline><fo:inline>2003. </fo:inline><fo:inline>2--12. </fo:inline><fo:inline>IEEE Computer Society</fo:inline></fo:inline></fo:block><fo:block id="KlintRscript" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[Kli08] <fo:inline><fo:inline>P. Klint. </fo:inline><fo:inline font-style="italic">Using Rscript for software analysis</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Working Session on Query Technologies and
  Applications for Program Comprehension (QTAPC 2008). </fo:inline> </fo:inline><fo:inline>2008. </fo:inline></fo:inline></fo:block><fo:block id="KSV-SCAM09" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[KvdSV09] <fo:inline><fo:inline>P. Klint, T. van der
  Storm, and J.J. Vinju. </fo:inline><fo:inline font-style="italic">RASCAL: A domain specific language for source code analysis and
  manipulation</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>IEEE International Workshop on Source Code Analysis
  and Manipulation (SCAM'09). </fo:inline><fo:inline>Los Alamitos, CA,
  USA. </fo:inline> </fo:inline><fo:inline>2009. </fo:inline><fo:inline>168--177. </fo:inline><fo:inline>IEEE Computer Society</fo:inline></fo:inline></fo:block><fo:block id="Krikhaar99" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[Kri99] <fo:inline>R.L. Krikhaar. </fo:inline><fo:inline><fo:inline font-style="italic">Software Architecture Reconstruction</fo:inline>. </fo:inline><fo:inline>PhD thesis. </fo:inline><fo:inline>University of Amsterdam. </fo:inline><fo:inline>1999. </fo:inline></fo:block><fo:block id="McCabe76" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[McC76] <fo:inline><fo:inline>T.J. McCabe. </fo:inline><fo:inline font-style="italic">A complexity measure</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">IEEE Transactions on Software Engineering</fo:inline>. <fo:inline>SE-12. </fo:inline><fo:inline>3. </fo:inline><fo:inline>1976. </fo:inline></fo:inline><fo:inline>308--320. </fo:inline></fo:block><fo:block id="Semmle.QL" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[dMSV+08] <fo:inline><fo:inline>O. de Moor, D. Sereni, M. Verbaere, E. Hajiyev, P. Avgustinov, T. Ekman, N. Ongkingco, and J. Tibble. </fo:inline><fo:inline font-style="italic">.QL: Object-oriented queries made easy</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Generative and Transformational Techniques in
  Software Engineering II, International Summer School, GTTSE 2007, Braga,
  Portugal, July 2-7, 2007. Revised Papers. </fo:inline> </fo:inline><fo:inline>R. Lämmel, J. Visser, and J. Saraiva. </fo:inline><fo:inline>LNCS. </fo:inline><fo:inline>5235. </fo:inline><fo:inline>2008. </fo:inline><fo:inline>78--133. </fo:inline><fo:inline>Springer</fo:inline></fo:inline></fo:block><fo:block id="Mueller88" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[MK88] <fo:inline><fo:inline>H. Müller and K. Klashinsky. </fo:inline><fo:inline font-style="italic">Rigi -- a system for programming-in-the-large</fo:inline>. </fo:inline><fo:inline><fo:inline><fo:inline>Proceedings of the 10th International Conference on
  Software Engineering (ICSE 10). </fo:inline> </fo:inline><fo:inline>April 1988. </fo:inline><fo:inline>80--86. </fo:inline></fo:inline></fo:block><fo:block id="ANTLRBook" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[Par07] <fo:inline>T. Parr. </fo:inline><fo:inline><fo:inline font-style="italic">The Definitive ANTLR Reference: Building Domain-Specific
  Languages</fo:inline>. </fo:inline><fo:inline>Pragmatic Bookshelf, </fo:inline><fo:inline>2007. </fo:inline></fo:block><fo:block id="Tip95" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[Tip95] <fo:inline><fo:inline>F. Tip. </fo:inline><fo:inline font-style="italic">A survey of program slicing techniques</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">Journal of Programming Languages</fo:inline>. <fo:inline>3. </fo:inline><fo:inline>3. </fo:inline><fo:inline>1995. </fo:inline></fo:inline><fo:inline>121--189. </fo:inline></fo:block><fo:block id="Weiser84" start-indent="0.5in" text-indent="-0.5in" space-before.optimum="1em" space-before.minimum="0.8em" space-before.maximum="1.2em">[Wei84] <fo:inline><fo:inline>M. Weiser. </fo:inline><fo:inline font-style="italic">Program slicing</fo:inline>. </fo:inline><fo:inline><fo:inline font-style="italic">IEEE Transactions on Software Engineering</fo:inline>. <fo:inline>SE-10. </fo:inline><fo:inline>4. </fo:inline><fo:inline>July 1984. </fo:inline></fo:inline><fo:inline>352--357. </fo:inline></fo:block></fo:block></fo:block>
  </fo:block>

  
</fo:flow></fo:page-sequence></fo:root>
