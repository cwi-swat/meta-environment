<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
]>
<chapter version="5.0" xml:id="EASY-Meta-Programming-with-Rascal"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns6="http://www.w3.org/1999/xhtml"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>EASY Meta-Programming with Rascal</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint, Jurgen Vinju,
        Tijs van der Storm</surname></personname>
      </author>
    </authorgroup>
  </info>

  <blockquote>
    <para>Rascal is a new language for meta-programming and is intended to
    solve problems in the domain of source code analysis and transformation.
    In this article we give a high-level overview of the language and
    illustrate its use by many examples. Rascal is a work in progress both
    regarding implementation and documentation. More information is available
    at <link
    xlink:href="http://www.meta-environment.org/Meta-Environment/Rascal">http://www.meta-environment.org/Meta-Environment/Rascal</link>.</para>
  </blockquote>

  <section xml:id="section.why-a-new-language">
    <title>A New Language for Meta-Programming</title>

    <para><emphasis>Meta-programs</emphasis> are programs that analyze,
    transform or generate other programs. Ordinary programs work on data;
    meta-programs work on programs. The range of programs to which
    meta-programming can be applied is large: from programs in standard
    languages like C and Java to domain-specific languages for describing
    high-level system models or applications in specialized areas like gaming
    or finance. In some cases, even test results or performance data are used
    as input for meta-programs. Rascal is a new language for
    <emphasis>meta-programming</emphasis>, this is the activity of writing
    meta-programs.</para>

    <section xml:id="section.EASY-programming">
      <title>The EASY Paradigm</title>

      <para>Many meta-programming problems follow a fixed pattern. Starting
      with some input system (a black box that we usually call
      <emphasis>system-of-interest</emphasis>), first relevant information is
      extracted from it and stored in an internal representation. This
      internal representation is then analyzed and used to synthesize results.
      If the synthesis indicates this, these steps can be repeated over and
      over again. These steps are shown in <xref
      linkend="figure.extract-analyze-synthesize-paradigm" />.</para>

      <para>This is an abstract view on solving meta-programming problems, but
      is it uncommon? No, so let's illustrate it with a few examples.</para>

      <section>
        <title>Finding security breaches</title>

        <para><emphasis>Alice</emphasis> is system administrator of a large
        online marketplace and she is looking for security breaches in her
        system. The objects-of-interest are the system's log files. First
        relevant entries are extracted. This will include, for instance,
        messages from the SecureShell demon that reports failed login
        attempts. From each entry login name and originating IP address are
        extracted and put in a table (the internal representation in this
        example). These data are analyzed by detecting duplicates and counting
        frequencies. Finally results are synthesized by listing the most
        frequently used login names and IP addresses.</para>

        <figure xml:id="figure.extract-analyze-synthesize-paradigm">
          <title>EASY: the Extract-Analyze-Synthesize Paradigm</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="easy-workflow.png" scale="40"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>A Forensic DSL compiler</title>

        <para><emphasis>Bernd</emphasis> is a senior software engineer working
        at the Berlin headquarters of a forensic investigation lab of the
        German government. His daily work is to find common patterns in files
        stored on digital media that have been confiscated during criminal
        investigations. Text, audio and video files are stored in zillions of
        different data formats and each data format requires its own analysis
        technique. For each new investigation ad hoc combinations of tools are
        used. This makes the process very labour-intensive and error-prone.
        Bernd convinces his manager that designing a new domain-specific
        language (DSL) for forensic investigations may relieve the pressure on
        their lab. After designing the DSL---let's call it DERRICK---he makes
        an EASY implementation for it. Given a DERRICK program for a specific
        case under investigation, he first extracts relevant information from
        it and analyzes it: which media formats are relevant? Which patterns
        to look for? How should search results be combined? Given this new
        information, Java code is synthesized that uses the various existing
        tools and combines their results.</para>
      </section>

      <section>
        <title>Renovating Financial Software</title>

        <para><emphasis>Charlotte</emphasis> is software engineer at a large
        financial institution in Paris and she is looking for options to
        connect an old and dusty software system to a web interface. She will
        need to analyze the sources of that system to understand how it can be
        changed to meet the new requirements. The objects-of-interest are in
        this case the source files, documentation, test scripts and any other
        available information. They have to be parsed in some way in order to
        extract relevant information, say the calls between various parts of
        the system. The call information can be represented as a binary
        relation between caller and callee (the internal representation in
        this example). This relation with 1-step calls is analyzed and further
        extended with 2-step calls, 3-step calls and so on. In this way call
        chains of arbitrary length become available. With this new
        information, we can synthesize results by determining the entry points
        of the software system, i.e., the points where calls from the outside
        world enter the system. Having completed this first cycle, Charlotte
        may be interested in which procedures can be called from the entry
        points and so on and so forth. Results will be typically represented
        as pictures that display the relationships that were found. In the
        case of source code analysis, a variation of our workflow scheme is
        quite common. It is then called the extract-analyze-view paradigm and
        is shown in <xref
        linkend="figure.extract-analyze-view-paradigm" />.</para>

        <figure xml:id="figure.extract-analyze-view-paradigm">
          <title>The extract-analyze-view paradigm</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="extract-analyze-view-paradigm.png"
                         scale="40"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Finding Concurrency Errors</title>

        <para><emphasis>Daniel</emphasis> is concurrency researcher at one of
        the largest hardware manufacturers worldwide. He is working from an
        office in the Bay Area. Concurrency is the big issue for his company:
        it is becoming harder and harder to make CPUs faster, therefore more
        and more of them are bundled on a single chip. Programming these
        multi-core chips is difficult and many programs that worked fine on a
        single CPU contain hard to detect concurrency errors due to subtle
        differences in the order of execution that results from executing the
        code on more than one CPU. Here is where Daniel enters the picture. He
        is working on tools for finding concurrency errors. First he extracts
        facts from the code that are relevant for concurrency problems and
        have to do with calls, threads, shared variables and locks. Next, he
        analyzes these facts and synthesizes an abstract model that captures
        the essentials of the concurrency behaviour of the program. Finally he
        runs a third-party verification tool with this model as input to do
        the actual verification.</para>
      </section>

      <section>
        <title>Model-driven Engineering</title>

        <para><emphasis>Elisabeth</emphasis> is a software architect at a
        large airplane manufacturer and her concern is reliability and
        dependability of airplane control software. She and her team have
        designed a UML model of the control software and have extended it with
        annotations that describe the reliability of individual components.
        She will use this annotated model in two ways: (a) to extract relevant
        information from it to synthesize input for a statistical tool that
        will compute overall system reliability from the reliability of
        individual components; (b) to generate executable code that takes the
        reliability issues into account.</para>
      </section>
    </section>

    <section>
      <title>Rascal</title>

      <para>With these examples in mind, you have a pretty good picture how
      EASY applies in different use cases. All these cases involve a form of
      <emphasis>meta-programming</emphasis>: software programs (in a wide
      sense) are the objects-of-interest that are being analyzed, transformed
      or generated. The Rascal language you are about to learn is designed for
      meta-programming following the EASY paradigm. It can be applied in
      domains ranging from compiler construction and implementing
      domain-specific languages to constraint solving and software
      renovation.</para>

      <para>Since representation of information is central to the approach,
      Rascal provides a rich set of built-in data types. To support extraction
      and analysis, parsing and advanced pattern matching are provided.
      High-level control structures make analysis and synthesis of complex
      datastructures simple.</para>
    </section>

    <section>
      <title>Benefits of Rascal</title>

      <para>Before you spend your time on studying the Rascal language it may
      help to first hear our elevator pitch about the main benefits offered by
      the language:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Familiar</emphasis> <emphasis
          role="bold">syntax</emphasis> in a <emphasis>what-you-see
          is-what-you-get style</emphasis> is used even for sophisticated
          concepts and this makes the language easy to learn and easy to
          use.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Sophisticated built-in data
          types</emphasis> provide standard solutions for many
          meta-programming problems.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Safety</emphasis> is achieved by finding
          most errors before the program is executed and by making common
          errors like missing initializations or invalid pointers
          impossible.<remark> At the time of writing, this checking is done
          during execution.</remark></para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Local type inference</emphasis> makes
          local variable declarations redundant.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Pattern matching</emphasis> can be used
          to analyze all complex datastructures.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Syntax definitions</emphasis> make it
          possible to define new and existing languages and to write tools for
          them.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Visiting</emphasis> makes it easy to
          traverse datastructures and to extract information from them or to
          synthesize results.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Templates</emphasis> enable easy code
          generation.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Functions as values </emphasis>permit
          programming styles with high re-use.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Generic types</emphasis> allow writing
          functions that are applicable for many different types.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Eclipse integration</emphasis> makes
          Rascal programming a breeze. All familiar tools are at your
          fingertips.</para>
        </listitem>
      </itemizedlist>

      <para>Interested? Read on!</para>
    </section>

    <section>
      <title>Aim and Scope of this Article</title>

      <formalpara>
        <title>Aim</title>

        <para>The aim of this article is to give an easy to understand but
        comprehensive overview of the Rascal language and to offer problem
        solving strategies to handle realistic problems that require
        meta-programming. Problems may range from security analysis and model
        extraction to software renovation, domain-specific languages and code
        generation.</para>
      </formalpara>

      <formalpara>
        <title>Audience</title>

        <para>This article is intended for students, practitioners and
        researchers who want to solve meta-programming problems.</para>
      </formalpara>

      <formalpara>
        <title>Background</title>

        <para>Readers should have some background in computer science,
        software engineering or programming languages. Familiarity with
        several main stream programming languages and experience with larger
        software projects will make it easier to appreciate the relevance of
        the meta-programming domain that Rascal is addressing. Some
        familiarity with concepts like sets, relations and pattern matching is
        assumed.</para>
      </formalpara>

      <formalpara>
        <title>Scope</title>

        <para>The scope of this article is limited to the Rascal language and
        its applications but does not address implementation aspects of the
        language.</para>
      </formalpara>

      <formalpara>
        <title>Related Work</title>

        <para>Rascal owes a lot to other languages that aim at
        meta-programming, in particular the user-defined, modular, syntax and
        term rewriting of ASF+SDF <biblioref linkend="Klint93" />, <biblioref
        linkend="BDHJJKKMOSVVV01" />, the relational calculus as used in
        Rscript <biblioref linkend="KlintRscript" /> and pioneered by GROK
        <biblioref linkend="Grok" />, traversal functions as introduced in
        <biblioref linkend="BKV03" />, strategies as introduced in ELAN
        <biblioref linkend="ElanBKKMR-wrla98" /> and Stratego <biblioref
        linkend="BKVV08" />, and integration of term rewriting in Java as done
        in TOM <biblioref linkend="BallandBKMR-RTA2007" />. We also
        acknowledge less specific influences by systems like TXL <biblioref
        linkend="CordyTXL06" />, ANTLR <biblioref linkend="ANTLRBook" />,
        JastAdd <biblioref linkend="HedinMagnusson03" />, Semmle <biblioref
        linkend="Semmle.QL" />, DMS <biblioref linkend="DMS" />, and various
        others. A first application of Rascal in the domain of refactoring is
        described in <biblioref linkend="KSV-SCAM09" />.</para>
      </formalpara>
    </section>

    <section>
      <title>Downloading, Installing and Running Rascal</title>

      <para>See http://www.meta-environment.org/Meta-Environment/Rascal for
      information.</para>
    </section>

    <section>
      <title>Reading Guide</title>

      <para><figure xml:id="figure.structure-manual">
          <title>Structure of the Rascal Description</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="manual-structure.png" scale="40"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>The structure of the description of Rascal is shown in <xref
      linkend="figure.structure-manual" />. This article provides the first
      three parts:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Introduction</emphasis>: gives a
          high-level overview of Rascal and consists of <xref
          linkend="section.why-a-new-language" /> and <xref
          linkend="section.rascal-concepts" /> . It also presents some simple
          examples in <xref linkend="section.classical-examples" />.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Problem Solving</emphasis>: describes
          the major problem solving strategies in Rascal's application domain,
          see <xref linkend="section.problem-solving-strategies" />.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Examples</emphasis>: gives a collection
          of larger examples, see <xref
          linkend="section.more-examples" />.</para>
        </listitem>
      </itemizedlist>

      <para>The other parts can be found <link
      xlink:href="http://www.meta-environment.org/doc/books//analysis/rascal-manual/rascal-manual.pdf">online</link>:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Reference</emphasis>: gives a detailed
          description of the Rascal language, and all built-in operators and
          library functions.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Support</emphasis>: gives tables with
          operators and library functions, a bibliography and a glossary that
          explains many concepts that are used in the descriptions of Rascal
          and tries to make them self-contained.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Typographic Conventions</title>

      <para>Rascal code fragments are always shown as a listing like
      this:<programlisting>  .. here is some Rascal code ...</programlisting>Interactive
      sessions are show as a screen like this:<screen><prompt>rascal&gt;</prompt> <userinput><replaceable>Command</replaceable>;</userinput>
<computeroutput><replaceable>Type</replaceable>: <replaceable>Value</replaceable></computeroutput></screen>where:</para>

      <itemizedlist>
        <listitem>
          <para><prompt>rascal&gt;</prompt> is the prompt of the Rascal
          system.</para>
        </listitem>

        <listitem>
          <para><userinput>Command</userinput> is an arbitrary Rascal
          statement or declaration typed in by the user.</para>
        </listitem>

        <listitem>
          <para><computeroutput>Type: Value</computeroutput> is the type of
          the answer followed by the value of the answer as computed by
          Rascal. In some cases, the response will simply be
          <computeroutput>ok</computeroutput> when there is no other
          meaningful answer to give.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.rascal-concepts">
    <title>Rascal Concepts</title>

    <para>Before explaining the Rascal language in more detail, we detail our
    elevator pitch a bit and give you a general understanding of the concepts
    on which the language is based.</para>

    <section>
      <title>Values</title>

      <para>Values are the basic building blocks of a language and the type of
      values determines how they may be used.</para>

      <para>Rascal is a value-oriented language. This means that values are
      immutable and are always freshly constructed from existing parts and
      that sharing and aliasing problems are completely avoided. The language
      also provides variables. A value can be associated with a variable as
      the result of an explicit assignment statement: during the lifetime of a
      variable different (immutable) values may be assignment to it. Other
      ways to associate a value with a variable is by way of function calls
      (binding of formal parameters to actual values) and as the result of a
      successful pattern match.</para>
    </section>

    <section>
      <title>Data structures</title>

      <!--Kan dit nog iets beter?-->

      <para>Rascal provides a rich set of datatypes. From Booleans
      (<keysym>bool</keysym>), infinite precision integers
      (<keysym>int</keysym>) and reals (<keysym>real</keysym>) to strings
      (<keysym>str</keysym>) that can act as templates with embedded
      expressions and statements. From source code locations
      (<keysym>loc</keysym>) based on an extension of Universal Resource
      Identifiers (URI) that allow precise description of text areas in local
      and remote files to lists (<keysym>list</keysym>), optionally labelled
      tuples (<keysym>tuple</keysym>), sets (<keysym>set</keysym>), and
      optionally labelled maps (<keysym>map</keysym>) and relations
      (<keysym>rel</keysym>). From untyped tree structures
      (<keysym>node</keysym>) to fully typed datastructures. Syntax trees that
      are the result of parsing source files are represented as datatypes
      (<keysym>Tree</keysym>). There is a wealth of built-in operators and
      library functions available on the standard datatypes. The basic Rascal
      datatypes are illustrated in <xref linkend="table.types" />.</para>

      <para>These builtin datatypes are closely related to each other:</para>

      <itemizedlist>
        <listitem>
          <para>In a list all elements have the same static type and the order
          of elements matters. A list may contain the same value more than
          once.</para>
        </listitem>

        <listitem>
          <para>In a set all elements have the same static type and the order
          of elements does not matter. A set contains an element only once. In
          other words, duplicate elements are eliminated and no matter how
          many times an element is added to a set, it will occur in it only
          once.</para>
        </listitem>

        <listitem>
          <para>In a tuple alle elements (may) have a different static type.
          Each element of a tuple may have a label that can be used to select
          that element of the tuple.</para>
        </listitem>

        <listitem>
          <para>A relation is a set of tuples which all have the same static
          tuple type.</para>
        </listitem>

        <listitem>
          <para>A map is an asosciative table of (key, value) pairs. Key and
          value (may) have different static type and a key can only be
          associated with a value once</para>
        </listitem>
      </itemizedlist>

      <para>Untyped trees can be constructed with the builtin type <emphasis
      role="bold">node</emphasis>. User-defined algebraic datatypes allow the
      introduction of problem-specific types and are a subtype of <emphasis
      role="bold">node</emphasis>. A fragment of the abstract syntax for
      statements (assignment, if, while) in a programming language would look
      as follows:<programlisting>data STAT = asgStat(Id name, EXP exp)
          | ifStat(EXP exp,list[STAT] thenpart,
                           list[STAT] elsepart) 
          | whileStat(EXP exp, list[STAT] body)
          ;</programlisting><table xml:id="table.types">
          <title>Basic Rascal Types</title>

          <tgroup cols="2">
            <colspec align="left" colwidth="2*" />

            <colspec align="left" colwidth="5*" />

            <thead>
              <row>
                <entry align="left">Type </entry>

                <entry align="left">Examples </entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>bool</literal></entry>

                <entry><literal>true</literal>,
                <literal>false</literal></entry>
              </row>

              <row>
                <entry><literal>int</literal></entry>

                <entry><literal>1</literal>, <literal>0</literal>,
                <literal>-1</literal>, <literal>123456789</literal></entry>
              </row>

              <row>
                <entry><literal>real</literal></entry>

                <entry><literal>1.0</literal>,
                <literal>1.0232e20</literal>,<literal> -25.5</literal></entry>
              </row>

              <row>
                <entry><literal>str</literal></entry>

                <entry><literal>"abc"</literal>,
                <literal>"first\nnext"</literal>, <literal>"result:
                &lt;X&gt;"</literal></entry>
              </row>

              <row>
                <entry><literal>loc</literal></entry>

                <entry><literal>|file:///etc/passwd|</literal></entry>
              </row>

              <row>
                <entry><literal>tuple[<replaceable>T</replaceable><subscript>1</subscript>,...,<replaceable>T</replaceable><subscript>n</subscript>]</literal></entry>

                <entry><literal>&lt;1,2&gt;</literal>, <literal>&lt;"john",
                43, true&gt;</literal></entry>
              </row>

              <row>
                <entry><literal>list[<replaceable>T</replaceable>]</literal></entry>

                <entry><literal>[]</literal>, <literal>[1]</literal>,
                <literal>[1,2,3]</literal>, <literal>[true, 2,
                "abc"]</literal></entry>
              </row>

              <row>
                <entry><literal>set[<replaceable>T</replaceable>]</literal></entry>

                <entry><literal>{}</literal>,
                <literal>{1,2,3,5,7}</literal>,<literal> {"john",
                4.0}</literal></entry>
              </row>

              <row>
                <entry><literal>rel[</literal><literal><replaceable>T</replaceable></literal><subscript>1</subscript><literal>,...,</literal><replaceable>T</replaceable><subscript>n</subscript>]</entry>

                <entry><literal>{&lt;1,2&gt;,&lt;2,3&gt;,&lt;1,3&gt;}</literal>,
                <literal>{&lt;1,10,100&gt;,
                &lt;2,20,200&gt;}</literal></entry>
              </row>

              <row>
                <entry><literal>map[<replaceable>T</replaceable>,
                <replaceable>U</replaceable>]</literal></entry>

                <entry><literal>()</literal>, <literal>(1:true,
                2:false)</literal>, <literal>("a":1, "b":2)</literal></entry>
              </row>

              <row>
                <entry><literal>node</literal></entry>

                <entry><literal>f()</literal>, <literal>add(x,y)</literal>,
                <literal>g("abc", [2,3,4])</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>Pattern Matching</title>

      <para>Pattern matching determines whether a given pattern matches a
      given value. The outcome can be false (no match) or true (a match). A
      pattern match that succeeds may bind values to variables.</para>

      <para>Pattern matching is <emphasis>the</emphasis> mechanism for case
      distinction (<keysym>switch</keysym> statement) and search
      (<keysym>visit</keysym> statement) in Rascal. Patterns can also be used
      in an explicit match operator <literal>:=</literal> and can then be part
      of larger boolean expressions. Since a pattern match may have more than
      one solution, local backtracking over the alternatives of a match is
      provided. Patterns can also be used in enumerators and control
      structures like <keysym>for</keysym> and <keysym>while</keysym>
      statement.</para>

      <para>A very rich pattern language is provided that includes string
      matching based on regular expressions, matching of abstract patterns,
      and matching of concrete syntax patterns. Some of the features that are
      provided are list (associative) matching, set (associative, commutative,
      idempotent) matching, and deep matching of descendant patterns. All
      these forms of matching can be used in a single pattern and can be
      nested. Patterns may contain variables that are bound when the match is
      successful. Anonymous (don't care) positions are indicated by the
      underscore (<literal>_</literal>).</para>

      <para>Here is a <emphasis>regular expression</emphasis> that matches a
      line of text, finds the first alphanumeric word in it, and extracts the
      word itself as well as the before and after it (<literal>\W</literal>
      matches all non-word characters; <literal>\w</literal> matches all word
      characters):</para>

      <para><programlisting>/^&lt;before:\W*&gt;&lt;word:\w+&gt;&lt;after:.*$&gt;/</programlisting></para>

      <para>Regular expressions follow the Java regular expression syntax with
      one exception: instead of using numbered groups to refer to parts of the
      subject string that have been matched by a part of the regular
      expression we use the notation:<programlisting>&lt;<replaceable>Name</replaceable>:<replaceable>RegularExpression</replaceable>&gt;</programlisting></para>

      <para>If <replaceable>RegularExpression</replaceable> matches, the
      matched substring is assigned to string variable
      <replaceable>Name</replaceable>.</para>

      <!--Alternative names for abstract pattern: algebraic pattern, term pattern, ...-->

      <para>The following <emphasis>abstract pattern</emphasis> matches the
      abstract syntax of a while statement defined earlier: <programlisting>whileStat(EXP Exp, list[STAT] Stats)</programlisting></para>

      <para>Variables in a pattern are either explicitly declared in the
      pattern itself---as done in the example---or they may be declared in the
      context in which the pattern occurs. So-called
      <emphasis>multi-variables</emphasis> in list and set patterns are
      declared by a <literal>*</literal> suffix: <literal>X*</literal> is thus
      an abbreviation for <literal>list[...] X</literal> or <literal>set[...]
      X</literal>, where the precise element type depends on the context. The
      above pattern can then be written as</para>

      <para><programlisting>whileStat(EXP Exp, Stats*)</programlisting>or, if
      you are not interested in the actual value of the statements as</para>

      <para><programlisting>whileStat(EXP Exp, _*)</programlisting></para>

      <para>When there is a grammar for this example language (in the form of
      an imported SDF definition), we can also write <emphasis>concrete
      patterns</emphasis> as we will see below.</para>
    </section>

    <section>
      <title>Enumerators</title>

      <para>Enumerators enumerate the values in a given (finite) domain, be it
      the elements in a list, the substrings of a string, or all the nodes in
      a tree. Each value that is enumerated is first matched against a pattern
      before it can possibly contribute to the result of the enumerator.
      Examples are:</para>

      <para><programlisting>int x &lt;- { 1, 3, 5, 7, 11 }
int x &lt;- [ 1 .. 10 ]
/asgStat(Id name, _) &lt;- P</programlisting></para>

      <para>The first two produce the integer elements of a set of integers,
      respectively, a range of integers. Observe that the left-hand side of an
      enumerator is a pattern, of which <literal>int x</literal> is a specific
      instance. The use of more general patterns is illustrated by the third
      enumerator that does a deep traversal (as denoted by the descendant
      operator <literal>/</literal>) of the complete program
      <literal>P</literal> (that is assumed to have a
      <literal>PROGRAM</literal> as value) and only yields statements that
      match the assignment pattern (<literal>asgStat</literal>) we have seen
      earlier. Note the use of an anonymous variable at the
      <literal>EXP</literal> position in the pattern.</para>
    </section>

    <section>
      <title>Comprehensions</title>

      <para>Comprehensions are a notation inspired by mathematical set-builder
      notation that helps to write succinct definitions of lists and sets.
      They are also inspired by queries as found in a language like
      SQL.</para>

      <para>Rascal generalizes comprehensions in various ways. Comprehensions
      exist for lists, sets and maps. A comprehension consists of an
      expression that determines the successive elements to be included in the
      result and a list of enumerators and tests (boolean expressions). The
      enumerators produce values and the tests filter them. A standard example
      is</para>

      <para><programlisting>{ x * x | int x &lt;- [1 .. 10], x % 3 == 0 }</programlisting></para>

      <para>which returns the set <literal>{9, 36, 81}</literal>, i.e., the
      squares of the integers in the range <literal>[ 1 .. 10 ]</literal> that
      are divisible by 3. A more intriguing example is</para>

      <para><programlisting>{name | /asgStat(Id name, _) &lt;- P}</programlisting></para>

      <para>which traverses program <literal>P</literal> and constructs a set
      of all identifiers that occur on the left hand side of assignment
      statements in <literal>P</literal>.</para>
    </section>

    <section>
      <title>Control structures</title>

      <para>Control structures like <literal>if</literal> and
      <literal>while</literal> statement are driven by Boolean expressions,
      for instance<programlisting>if(N &lt;= 0)
     return 1; 
  else
     return N * fac(N - 1);</programlisting>Actually, combinations of
      generators and Boolean expressions can be used to drive the control
      structures. For instance,</para>

      <para><programlisting>
for(/asgStat(Id name, _) &lt;- P, size(name) &gt; 10){
    println(name);
}</programlisting></para>

      <para>prints all identifiers in assignment statements
      (<literal>asgStat</literal>) that consist of more than 10
      characters.</para>
    </section>

    <section>
      <title>Case Distinction</title>

      <!--Improve the analogy with transaction.-->

      <para>The switch statement as known from C and Java is generalized: the
      subject value to switch on may be an arbitrary value and the cases are
      arbitrary patterns followed by a statement. Each case is comparable to a
      <emphasis>transaction</emphasis>: when the pattern succeeds and the
      following statement is executed successfully, all changes to variables
      made by the statement are <emphasis>committed</emphasis> and thus become
      permanent. The variables bound by the pattern are always local to the
      statement associated with the case. When a match fails or when the
      associated statement fails, a <emphasis>rollback</emphasis> takes place
      and all side-effects are undone. External side-effects like I/O and
      side-effects in user-defined Java code are not undone. Here is an
      example where we take a program P and distinguish two cases for while
      and if statement:<programlisting>switch (P){
case whileStat(_, _):
     println("A while statement");
case ifStat(_, _, _):
     println("An if statement");
}</programlisting></para>
    </section>

    <section>
      <title>Visiting</title>

      <para>Visiting the elements of a datastructure is one of the most common
      operations in our domain and the visitor design pattern is a solution
      known to every software engineer. Given a tree-like datastructure we
      want to perform an operation on some (or all) nodes of the tree. The
      purpose of the visitor design pattern is to decouple the logistics of
      visiting each node from the actual operation on each node. In Rascal the
      logistics of visiting is completely automated.</para>

      <para>Visiting is achieved by way of visit expressions that resemble the
      switch statement. A visit expressions traverses an arbitrarily complex
      subject value and applies a number of cases to all its subtrees. All the
      elements of the subject are visited and when one of the cases matches
      the statements associated with that case are executed. These cases
      may:</para>

      <itemizedlist>
        <listitem>
          <para>cause some side effect, i.e., assign a value to local or
          global variables;</para>
        </listitem>

        <listitem>
          <para>execute an <literal>insert</literal> statement that replaces
          the current element;</para>
        </listitem>

        <listitem>
          <para>execute a <literal>fail</literal> statement that causes the
          match for the current case to fail (and undoing all side-effects due
          to the successful match itself and the execution of the statements
          so far).</para>
        </listitem>
      </itemizedlist>

      <para>The value of a visit expression is the original subject value with
      all replacements made as dictated by matching cases. The traversal order
      in a visit expressions can be explicitly defined by the programmer. An
      example of visiting is given below and in <xref
      linkend="section.colored-trees" />.</para>
    </section>

    <section>
      <title>Functions</title>

      <para>Functions allow the definition of frequently used operations. They
      have a name and formal parameters. They are explicitly declared and are
      fully typed. Here is an example of a function that counts the number of
      assignment statements in a program:</para>

      <para><programlisting>int countAssignments(PROGRAM P){
    int n = 0;
    visit (P){
    case asgStat(_, _):
         n += 1;
    }
    return n;
}</programlisting>Functions can also be used as values thus enabling
      higher-order functions. Consider the following
      declarations:<programlisting>int double(int x) { return 2 * x; }

int triple(int x) { return 3 * x; }

int f(int x, int (int) multi){ return multi(x); }</programlisting></para>

      <para>The functions double and triple simply multiply their argument
      with a constant. Function f is, however, more interesting. It takes an
      integer <literal>x</literal> and a function <literal>multi</literal>
      (with integer argument and integer result) as argument and applies
      <literal>multi</literal> to its own argument. <literal>f(5,
      triple)</literal> will hence return <literal>15</literal>. Function
      values can also be created anonymously as illustrated by the following,
      alternative, manner of writing this same call to f:</para>

      <para><programlisting>f(5, int (int y){return 3 * y;});</programlisting>Here
      the second argument of f is an anonymous function.</para>

      <para>Rascal is a higher-order language in which functions are
      first-class values.</para>
    </section>

    <section xml:id="section.syntax-defintion-and-parsing">
      <title>Syntax Definition and Parsing</title>

      <para>All source code analysis projects need to extract information
      directly from the source code. There are two main approaches to
      this:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Lexical information</emphasis>: Use regular
          expressions to extract useful, but somewhat superficial, flat,
          information. This can be achieved using regular expression
          patterns.</para>
        </listitem>

        <listitem>
          <para><emphasis>Structured information</emphasis>: Use syntax
          analysis to extract the complete, nested, structure of the source
          code in the form of a syntax tree.</para>
        </listitem>
      </itemizedlist>

      <para>In Rascal, we reuse the Syntax Definition Formalism (SDF) and its
      tooling. See <link
      xlink:href="http://www.meta-environment.org/Meta-Environment/Documentation">http://www.meta-environment.org/Meta-Environment/Documentation</link>
      for tutorials and manuals for SDF.</para>

      <para>SDF modules define grammars and these modules can be imported in a
      Rascal module. These grammar rules can be applied in writing concrete
      patterns to match parts of parsed source code. Here is an example of the
      same pattern we saw above, but now in concrete form:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>

      <para>Importing an SDF module has the following effects:</para>

      <itemizedlist>
        <listitem>
          <para>All non-terminals (<emphasis>sorts</emphasis> in SDF jargon)
          that are used in the imported grammar are implicitly declared as
          Rascal types. For each SDF sort <replaceable>S</replaceable> also
          composite symbols like
          <literal><replaceable>S</replaceable>*</literal>,
          <literal>{<replaceable>S</replaceable> ","}+</literal> also become
          available as type. This makes it possible to handle parse trees and
          parse tree fragments as fully typed values and assign them to
          variables, store them in larger datastructures or pass them as
          arguments to functions and use them in pattern matching.</para>
        </listitem>

        <listitem>
          <para>For all <emphasis>start symbols</emphasis> of the grammar
          <emphasis>parse functions</emphasis> are implicitly declared that
          can parse source files according to a specific start symbol.</para>
        </listitem>

        <listitem>
          <para>Concrete syntax patterns for that specific grammar can be
          used.</para>
        </listitem>

        <listitem>
          <para>Concrete syntax constructors can be used that allow the
          construction of new parse trees.</para>
        </listitem>
      </itemizedlist>

      <para>The following example parses a Java compilation unit from a text
      file and counts the number of method declarations:</para>

      <programlisting>module Count
import languages::java::syntax::Java;
import ParseTree;

public int countMethods(loc file){
  int n = 0;
  for(/MethodDeclaration md &lt;- parse(#CompilationUnit, 
                                     file))
      n += 1;
  return n;
}</programlisting>

      <para>First observe that importing the Java grammar has as effect that
      non-terminals like <literal>MethodDeclaration</literal> and
      <literal>CompilationUnit</literal> become available as type in the
      Rascal program.</para>

      <para>The implicitly declared function <literal>parse</literal> takes a
      reified type (<literal>#CompilationUnit</literal>) and a location as
      arguments and parses the contents of the location according to the given
      non-terminal. Next, a match for embedded
      <literal>MethodDeclaration</literal>s is done in the enumetrator of the
      <keysym>for</keysym> statement. This example ignores many potential
      error conditions but does illustrate some of Rascal's syntax and parsing
      features.</para>
    </section>

    <section>
      <title>Rewrite Rules</title>

      <para>A <emphasis>rewrite rule</emphasis> is a recipe on how to simplify
      values. Remember: <literal>(a + b)<superscript>2</superscript> =
      a<superscript>2</superscript> + 2ab +
      b<superscript>2</superscript></literal>? A rewrite rule has a pattern as
      left-hand side (here: <literal>(a +
      b)<superscript>2</superscript></literal>) and a replacement as
      right-hand side (here: <literal>a<superscript>2</superscript> + 2ab +
      b<superscript>2</superscript></literal>). Given a value and a set of
      rewrite rules the patterns are tried on every subpart of the value and
      replacements are made if a match is successful. This is repeated as long
      as some pattern matches.</para>

      <para>Rewrite rules are the only implicit control mechanism in the
      language and are used to maintain invariants during computations. For
      example, in a package for symbolic differentiation it is desirable to
      keep expressions in simplified form in order to avoid intermediate
      results like <literal>sum(product(num(1), x), product(num(0),
      y))</literal> that can be simplified to <literal>x</literal>. The
      following rules achieve this:<programlisting>rule simplify1 product(num(1), Expression e) =&gt; e;
rule simplify2 product(Expression e, num(1)) =&gt; e;
rule simplify3 product(num(0), Expression e) =&gt; num(0);
rule simplify4 product(Expression e, num(0)) =&gt; num(0);
rule simplify5 sum(num(0), Expression e)     =&gt; e;
rule simplify6 sum(Expression e, num(0))     =&gt; e;</programlisting>Whenever
      a new expression is constructed during symbolic differentiation, these
      rules are <emphasis>implicitly</emphasis> applied to that expression and
      all its subexpressions and when a pattern at the left-hand side of a
      rule applies the matching subexpression is replaced by the right-hand
      side of the rule. This is repeated as long as any rule can be
      applied.</para>

      <para>Since rewrite rules are activated automatically, one may always
      assume that expressions are in simplified form.</para>

      <para>Rewrite rules are <emphasis>Turing complete</emphasis>, in other
      words any computable function can be defined using rewrite rules,
      including functions that do not terminate. This is a point of attention
      when using rewrite rules.</para>
    </section>

    <section>
      <title>Equation Solving</title>

      <para>Many problems can be solved by forms of <emphasis>constraint
      solving</emphasis>. This is a declarative way of programming: specify
      the constraints that a problem solution should satisfy and how potential
      solutions can be generated. The actual solution (if any) is found by
      enumerating solutions and testing their compliance with the
      constraints.</para>

      <para>Rascal provides a <literal>solve</literal> statement that helps
      writing constraint solvers. A typical example is dataflow analysis where
      the propagation of values through a program can be described by a set of
      equations. Their solution can be found with the <literal>solve</literal>
      statement. See <xref linkend="section.dataflow" /> for examples.</para>
    </section>

    <section>
      <title>Other features</title>

      <para>All language features (including the ones just mentioned) are
      described in more detail later on in this article. Some features we have
      not yet mentioned are:</para>

      <itemizedlist>
        <listitem>
          <para>Rascal programs consist of modules that are organized in
          packages.</para>
        </listitem>

        <listitem>
          <para>Modules can import other modules. These can be Rascal modules
          or SDF modules (as shown above in <xref
          linkend="section.syntax-defintion-and-parsing" />).</para>
        </listitem>

        <listitem>
          <para>The visibility of entities declared in modules can be
          controlled using <keysym>public</keysym>/<keysym>private</keysym>
          modifiers.</para>
        </listitem>

        <listitem>
          <para>Datastructures may have annotations that can be explicitly
          used and modified.</para>
        </listitem>

        <listitem>
          <para>There is an extensive library for builtin datatypes,
          input/output, fact extraction from Java source code, visualization,
          and more.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Typechecking and Execution</title>

      <para>Rascal has a statically checked type system that prevents type
      errors and uninitialized variables at runtime. There are no runtime type
      casts as in Java and there are therefore less opportunities for run-time
      errors. The language provides <emphasis>higher-order, parametric
      polymorphism</emphasis>. A type aliasing mechanism allows documenting
      specific uses of a type. Built-in operators are heavily overloaded. For
      instance, the operator + is used for addition on integers and reals but
      also for list concatenation, set union etc.</para>

      <para>The flow of Rascal program execution is completely explicit.
      Boolean expressions determine choices that drive the control structures.
      Rewrite rules form the only exception to the explicit control flow
      principle. Only local backtracking is provided in the context of boolean
      expressions and pattern matching; side effects are undone in case of
      backtracking.</para>
    </section>
  </section>

  <section xml:id="section.classical-examples">
    <title>Some Classical Examples</title>

    <para>The following simple examples will help you to grasp the main
    features of Rascal quickly. You can also consult the online documentation
    at <link
    xlink:href="http://www.meta-environment.org/Meta-Environment/Rascal">http://www.meta-environment.org/Meta-Environment/Rascal</link>
    for details of the language or specific operators or functions.</para>

    <section>
      <title>Hello</title>

      <para>The ubiquitous hello world program looks in Rascal as
      follows:<screen><prompt>rascal&gt;</prompt> <userinput>import IO;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>println("Hello world, my first Rascal program");</userinput>
<computeroutput>Hello world, my first Rascal program
ok</computeroutput>
</screen>First, the library module IO is imported since hello world requires
      printing. Next, we call <literal>println</literal> and proudly observe
      our first Rascal output!</para>

      <para>A slightly more audacious approach is to wrap the print statement
      in a function and call it:</para>

      <para><screen><prompt>rascal&gt; </prompt><userinput>void hello() {
   println("Hello world, my first Rascal program");
}</userinput>
<computeroutput>void (): void hello();</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>hello();</userinput>
<computeroutput>Hello world, my first Rascal program
ok</computeroutput></screen>Don't get scared by the <computeroutput>void ():
      void hello();</computeroutput> that you get back when typing in the
      <literal>hello</literal> function. The first <computeroutput>void
      ()</computeroutput> part says the result is a function that returns
      nothing, and the second part <computeroutput>void
      hello()</computeroutput> summarizes its value (or would you prefer a hex
      dump?).</para>

      <!--[TODO item: de print out suggereert dat closures vergelijkbaar zijn

rascal>a = (int x) { x + 1; };
void (int): void (int);
rascal>b = (int x) { x + 1; };
void (int): void (int);
rascal>a == b;
bool: false

De waardes zijn verschillend, maar de print-out is gelijk; dat is niet
wysiwyg, ik denk dat we zoiets moeten doen als in Ruby/Common-Lisp:

#<void(int): 3423>

(dus een identity value erbij)
]-->

      <para>The summit of hello-engineering can be reached by placing all the
      above in a separate module:<programlisting>module demo::Hello
import IO;

public void hello() {
   println("Hello world, my first Rascal program");
}</programlisting>Note that we added a public modifier to the definition of
      hello, since we want it to be visible outside the Hello module. Using
      this Hello module is now simple:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Hello;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>hello();</userinput>
<computeroutput>Hello world, my first Rascal program
ok</computeroutput></screen></para>
    </section>

    <section>
      <title>Factorial</title>

      <para>Here is another classical example, computing the factorial
      function:<programlisting>module demo::Factorial

public int fac(int N)
{
  if(N &lt;= 0)
     return 1; 
  else
     return N * fac(N - 1);
}</programlisting></para>

      <para>It uses a conditional statement to distinguish cases and here is
      how to use it:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Factorial;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>fac(47);</userinput>
<computeroutput>int: 25862324151116818064296435515361197996919763238912000
0000000</computeroutput></screen></para>

      <para>Indeed, Rascal has arbitrary length integers.</para>
    </section>

    <section xml:id="section.colored-trees">
      <title>Colored Trees</title>

      <para>Suppose we have binary trees---trees with exactly two
      children--that have integers as their leaves. Also suppose that our
      trees can have red and black nodes. Such trees can be defined as
      follows:<programlisting>module demo::ColoredTrees

data ColoredTree = 
            leaf(int N) 
          | red(ColoredTree left, ColoredTree right) 
          | black(ColoredTree left, ColoredTree right);</programlisting></para>

      <para>We can use them as follows:</para>

      <para><screen><prompt>rascal&gt;</prompt> <userinput>import demo::ColoredTrees;</userinput>
<computeroutput>ok
</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>rb = red(black(leaf(1), red(leaf(2),leaf(3))), 
                 black(leaf(3), leaf(4)));</userinput>
<computeroutput>ColoredTree: red(black(leaf(1),red(leaf(2),leaf(3))),
                 black(leaf(3),leaf(4)))</computeroutput></screen>Observe that
      the type of variable <literal>rb</literal> was autimatically inferred to
      be <literal>ColoredTree</literal>.</para>

      <para>We define two operations on ColoredTrees, one to count the red
      nodes, and one to sum the values contained in all
      leaves:<programlisting>// continuing module demo::ColoredTrees

public int cntRed(ColoredTree t){
   int c = 0;
   visit(t) {
     case red(_,_): c = c + 1;<co xml:id="co.cntRed" />
   };
   return c;
}

public int addLeaves(ColoredTree t){
   int c = 0;
   visit(t) {
     case leaf(int N): c = c + N;<co xml:id="co.cntLeaves" />
   };
   return c;
}</programlisting><calloutlist>
          <callout arearefs="co.cntRed">
            <para>Visit all the nodes of the tree and increment the counter
            <literal>c</literal> for each red node.</para>
          </callout>

          <callout arearefs="co.cntLeaves">
            <para>Visit all nodes of the tree and add the integers in the leaf
            nodes.</para>
          </callout>
        </calloutlist></para>

      <para>This can be used as follows:</para>

      <para><screen><prompt>rascal&gt;</prompt> <userinput>cntRed(rb);</userinput>
<computeroutput>int: 2</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>addLeaves(rb);</userinput>
<computeroutput>int: 13</computeroutput></screen></para>

      <para>A final touch to this example is to introduce green nodes and to
      replace all red nodes by green ones:<programlisting>// continuing module demo::ColoredTrees

data ColoredTree = green(ColoredTree left, 
                         ColoredTree right);<co xml:id="co.Tree-green" />

public ColoredTree makeGreen(ColoredTree t){
   return visit(t) {
     case red(l, r) =&gt; green(l, r)      <co xml:id="co.makeGreen" />
   };
}</programlisting><calloutlist>
          <callout arearefs="co.Tree-green">
            <para>Extend the ColoredTree datatype with a new
            <literal>green</literal> constructor.</para>
          </callout>

          <callout arearefs="co.makeGreen">
            <para>Visit all nodes in the tree and replace red nodes by green
            ones. Note that the variables <literal>l</literal> and
            <literal>r</literal> are introduced here without a
            declaration.</para>
          </callout>
        </calloutlist></para>

      <para>This is used as follows:<screen><prompt>rascal&gt;</prompt> <userinput>makeGreen(rb);</userinput>
<computeroutput>ColoredTree: green(black(leaf(1),green(leaf(2),leaf(3))),
                   black(leaf(3),leaf(4)))</computeroutput></screen></para>
    </section>

    <section>
      <title>Word Replacement</title>

      <para>Suppose you are in the publishing business and are responsible for
      the systematic layout of publications. Authors do not systematically
      capitalize words in titles---"Word replacement" instead of Word
      Replacement"--- and you want to correct this. Here is one way to solve
      this problem:<programlisting>module demo::WordReplacement
import String;

public str capitalize(str word)
{
   if(/^&lt;letter:[a-z]&gt;&lt;rest:.*$&gt;/ := word) <co
            xml:id="co.capitalize-regexp" />
      return toUpperCase(letter) + rest;<co
            xml:id="co.capitalize-regexp-return1" />
   else
     return word;<co xml:id="co.capitalize-regexp-return2" />
}</programlisting><calloutlist>
          <callout arearefs="co.capitalize-regexp">
            <para>The function capitalize takes a string as input and
            capitalizes its first character if that is a letter. This is done
            using a regular expression match that anchors the match at the
            beginning (<literal>^</literal>), expects a single letter and
            assigns it to the variable letter
            (<literal>letter:[a-z]</literal>) followed by an arbitrary
            sequence of letters until the end of the string that is assigned
            to the variable rest (<literal>&lt;rest:.*$&gt;</literal>).</para>
          </callout>

          <callout arearefs="co.capitalize-regexp-return1">
            <para>If the regular expression matches we return a new string
            with the first letter capitalized.</para>
          </callout>

          <callout arearefs="co.capitalize-regexp-return2">
            <para>Otherwise we return the word unmodified.</para>
          </callout>
        </calloutlist></para>

      <para>The next challenge is how to capitalize all the words in a string.
      Here are two solutions:<programlisting>// continuing module demo::WordReplacement

public str capAll1(str S)
{
 result = "";
 while (/^&lt;before:\W*&gt;&lt;word:\w+&gt;&lt;after:.*$&gt;/ := S) { <co
            xml:id="co.capAll1-regexp" />
    result += before + capitalize(word);
    S = after;
  }
  return result;
}

public str capAll2(str S)
{
   return visit(S){<co xml:id="co.capAll2-visit" />
     case /&lt;word:\w+&gt;/i <co xml:id="co.capAll2-match" /> =&gt; capitalize(word)<co
            xml:id="co.capAll1-insert" />
   };
}</programlisting><calloutlist>
          <callout arearefs="co.capAll1-regexp">
            <para>In the first solution <literal>capAll1</literal> we just
            loop over all the words in the string and capitalize each word.
            The variable <literal>result</literal> is used to collect the
            successive capitalized words. Here we use <literal>\W</literal> do
            denote non-word characters and<literal>\w</literal> for word
            characters.</para>
          </callout>

          <callout arearefs="co.capAll2-visit">
            <para>In the second solution we use a visit expression to visit
            all the substrings of S. Each matching case advances the substring
            by the length of the pattern it matches and replaces that pattern
            by another string. If no case matches the next substring is
            tried.</para>
          </callout>

          <callout arearefs="co.capAll2-match">
            <para>The single case matches a word (note that
            <literal>\w</literal> matches a word character).</para>
          </callout>

          <callout arearefs="co.capAll1-insert">
            <para>When the case matches a word, it is replaced by a
            capitalized version. The modifier <literal>i</literal> at the end
            of the regular expressions denotes case-insensitive
            matching.</para>
          </callout>
        </calloutlist></para>

      <para>We can apply this all as follows:</para>

      <para><screen><prompt>rascal&gt;</prompt> <userinput>import demo::WordReplacement;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>capitalize("rascal");</userinput>
<computeroutput>str: "rascal"</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>capAll1("rascal is great");</userinput>
<computeroutput>str: "Rascal Is Great"</computeroutput></screen></para>
    </section>

    <section>
      <title>Template Programming</title>

      <para>Many websites and code generators use template-based code
      generation. They start from a text template that contains embedded
      variables and code. The template is "executed" by replacing the embedded
      variables and code by their string value. A language like PHP is popular
      for this feature. Let's see how we can do this in Rascal. Given a
      mapping from field names to their type, the task at hand is to generate
      a Java class that contains those fields and corresponding getters and
      setters. Given a mapping</para>

      <para><programlisting>public map[str, str] fields = (
   "name" : "String",
   "age" : "Integer",
   "address" : "String"
);</programlisting>we expect the call<programlisting>genClass("Person", fields)</programlisting>to
      produce the following output:<programlisting>    public class Person {

        private Integer age;
        public void setAge(Integer age) {
          this.age = age;
        }
        public Integer getAge() {
          return age;
        }

        private String name;
        public void setName(String name) {
          this.name = name;
        }
        public String getName() {
          return name;
        }

        private String address;
        public void setAddress(String address) {
          this.address = address;
        }
        public String getAddress() {
          return address;
        }

    }</programlisting>This is achieved by the following definition of
      <literal>genClass</literal>:</para>

      <para><programlisting>module demo::StringTemplate

import String;

public str capitalize(str s) {
  return toUpperCase(substring(s, 0, 1)) + 
         substring(s, 1);
}

public str genClass(str name, map[str,str] fields) {
 return "
   public class &lt;name &gt; {
     &lt;for (x &lt;- fields) {
       str t = fields[x];
       str n = capitalize(x);&gt;
       private &lt;t&gt; &lt;x&gt;;
       public void set&lt;n&gt;(&lt;t&gt; &lt;x&gt;) {
         this.&lt;x&gt; = &lt;x&gt;;
       }
       public &lt;t&gt; get&lt;n&gt;() {
         return &lt;x&gt;;
       }
     &lt;}&gt;
   }
";
}</programlisting>Observe how the <keysym>for</keysym> statement and
      expressions that access the map fields that are embedded in the string
      constant customize the given template for a Java class.</para>
    </section>

    <section>
      <title>A Domain-Specific Language for Finite State Machines</title>

      <para>Finite State Machines (FSMs) are a universal device in Computer
      Science and are used to model problems ranging from lexical tokens to
      concurent processes. An FSM consists of named states and labeled
      transitions between states. An example is shown in <xref
      linkend="figure.fsm-example" />. This example was suggested by Goerel
      Hedin at GTTSE09.<!--Umlaut!--><figure xml:id="figure.fsm-example">
          <title>Example of a Finite State Machine</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="fsm.png" scale="40"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>This same information can be represented in textual form as
      follows:<programlisting>finite-state machine
    state S1;
    state S2;
    state S3;
    trans a: S1 -&gt; S2;
    trans b: S2 -&gt; S1;
    trans a: S1 -&gt; S3</programlisting>and here is where the idea is born to
      design a Domain-Specific Language for finite state machines (aptly
      called FSM). This always proceeds in three steps:</para>

      <orderedlist>
        <listitem>
          <para><emphasis role="bold">Do domain analysis</emphasis>. Explore
          the domain and make an inventory of the relevant concepts and their
          interactions.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Define syntax</emphasis>. Design a
          textual syntax to represent these concepts and interactions.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Define operations</emphasis>. Define
          operations on DSL programs. This maybe, for example, be
          typechecking, validation, or execution.</para>
        </listitem>
      </orderedlist>

      <para>We will now apply these steps to the FSM domain.</para>

      <formalpara>
        <title>Do domain analysis</title>

        <para>We assume that the FSM domain is sufficiently known. The
        concepts are states and labeled transitions.</para>
      </formalpara>

      <formalpara>
        <title>Define syntax</title>

        <para>We define a textual syntax for FSMs. This syntax is written in
        the Syntax Definition Formalism SDF. See <link
        xlink:href="http://www.meta-environment.org/Meta-Environment/Documentation">http://www.meta-environment.org/Meta-Environment/Documentation</link>
        for tutorials and manuals for SDF. The syntax definition looks as
        follows:</para>
      </formalpara>

      <para><programlisting>module demo/StateMachine/Syntax

imports basic/Whitespace
imports basic/IdentifierCon

exports
  context-free start-symbols
    FSM
  
  sorts FSM Decl Trans State IdCon

  context-free syntax
    "state" IdCon                         -&gt; State
    "trans" IdCon ":" IdCon  "-&gt;" IdCon   -&gt; Trans
    State                                 -&gt; Decl
    Trans                                 -&gt; Decl
    "finite-state" "machine" {Decl ";"}+  -&gt; FSM
</programlisting></para>

      <para>Two standard modules for whitespace and identifiers are imported
      and next a fairly standard grammar for state machines is defined.
      Observe that in SDF rules are written in reverse order as compared to
      standard BNF notation.</para>

      <formalpara>
        <title><emphasis role="bold">Define Operations</emphasis>.</title>

        <para>There are various operations one could define on a FSM:
        executing it for given input tokens, reducing a non-deterministic
        automaton to a deterministic one, and so on. Here we select a
        reachability check on FSMs as example.</para>
      </formalpara>

      <para>We start with the usual imports and define a function
      getTransitions that extracts all transitions from an FSM:</para>

      <para><programlisting>module demo::StateMachine::CanReach

import demo::StateMachine::Syntax;
import Relation;
import Map;
import IO;

// Extract from a give FSM all transitions as a relation

public rel[str, str] getTransitions(FSM fsm){
   return
    {&lt;"&lt;from&gt;", "&lt;to&gt;"&gt; | 
     /`trans &lt;IdCon a&gt;: &lt;IdCon from&gt; -&gt; &lt;IdCon to&gt;` &lt;- fsm 
    };
}</programlisting>The function <literal>getTransitions</literal> illustrates
      several issues. Given a concrete fsm, a deep pattern match (/) is done
      searching for <literal>trans</literal> constructs. For each match three
      identifiers (<literal>IdCon</literal>) are extracted from it and
      assigned to the variables<literal> a</literal>, <literal>from</literal>,
      respectively, <literal>to</literal>. Next from and to are converted to a
      string (using the string interpolations "&lt;from&gt;" and "&lt;to&gt;")
      and finally they are placed in a tuple in the resulting relation. The
      net effect is that transitions encoded in the syntax tree of
      <literal>fsm</literal> are collected in a relation for further
      processing.</para>

      <para>Next, we compute all reachable states in the function
      <literal>canReach</literal>:<programlisting>// continuing module demo::StateMachine::CanReach

public map[str, set[str]] canReach(FSM fsm){
  transitions = getTransitions(fsm);
  return
    ( s: (transitions+)[s] | 
      str s &lt;- carrier(transitions) 
    );
}</programlisting>Here <literal>str s &lt;- carrier(transitions)</literal>
      enumerates all elements that occur in the relations that is extracted
      from <literal>fsm</literal>. A map comprehension is used to construct a
      map from each state to all states that can be reached it. Here
      <literal>transitions+</literal> is the transitive closure of the
      transition relation and <literal>(transitions+)[s]</literal> gives the
      image of that closure for a given state; in other words all states that
      can be reached from it.</para>

      <para>Finally, we declare an example FSM (observe that it uses FSM
      syntax in Rascal code!):</para>

      <para><programlisting>// continuing module demo::StateMachine::CanReach

public FSM example = 
       finite-state machine
          state S1;
          state S2;
          state S3;
          trans a: S1 -&gt; S2;
          trans b: S2 -&gt; S1;
          trans a: S1 -&gt; S3;</programlisting>Testing the above functions
      gives the following results:</para>

      <para><screen><prompt>rascal&gt;</prompt> <userinput>import demo::StateMachine::CanReach;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>getTransitions(example);</userinput>

<computeroutput>rel[str,str]: {&lt;"S1", "S2"&gt;, &lt;"S2", "S1"&gt;, &lt;"S1", "S3"&gt;}</computeroutput>
<prompt>rascal&gt;</prompt> <userinput>canReach(example);</userinput>

<computeroutput>map[str: set[str]: ("S1" : {"S1", "S2", "S3"}, 
                    "S2" : {"S1", "S2", "S3"},
                    "S3" : {})</computeroutput></screen></para>
    </section>
  </section>

  <section xml:id="section.problem-solving-strategies">
    <title>Problem Solving Strategies</title>

    <para>Before we study more complicated examples, it is useful to discuss
    some general problem solving strategies that are relevant in Rascal's
    application domain.</para>

    <para>To appreciate these general strategies, it is good to keep some
    specific problem areas in mind:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Documentation generation</emphasis>:
        extract facts from source code and use them to generate textual
        documentation. A typical example is generating web-based documentation
        for legacy languages like Cobol and PL/I.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Metrics calculation</emphasis>: extract
        facts from source code (and possibly other sources like test runs) and
        use them to calculate code metrics. Examples are cohesion and coupling
        of modules and test coverage.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Model extraction</emphasis>: extract facts
        from source code and use them to build an abstract model of the source
        code. An example is extracting lock and unlock calls from source code
        and to build an automaton that guarantees that lock/unlock occurs in
        pairs along every control flow path.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Model-based code generation</emphasis>:
        given a high-level model of a software system, described in UML or
        some other modelling language, transform this model into executable
        code. UML-to-Java code generation falls in this category.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Source-to-source
        transformation</emphasis>: large-scale, fully automated, source code
        transformation with certain objectives like removing deprecated
        language features, upgrading to newer APIs and the like.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Interactive refactoring</emphasis>: given
        known "code smells" a user can interactively indicate how these smells
        should be removed. The refactoring features in Eclipse and Visual
        Studio are examples.</para>
      </listitem>
    </itemizedlist>

    <para>With these examples in mind, we can study the overall problem
    solving workflow as shown in <xref linkend="figure.problem-solving" />. It
    consists of three optional phases:</para>

    <itemizedlist>
      <listitem>
        <para>Is <emphasis role="bold">extraction needed</emphasis> to solve
        the problem, then define the extraction phase, see <xref
        linkend="section.defining-extraction" />.</para>
      </listitem>

      <listitem>
        <para>Is <emphasis role="bold">analysis needed</emphasis>, then define
        the analysis phase, see <xref
        linkend="section.defining-analysis" />.</para>
      </listitem>

      <listitem>
        <para>Is <emphasis role="bold">synthesis needed</emphasis>, then
        define the synthesis phase, see <xref
        linkend="section.defining-synthesis" />.</para>
      </listitem>
    </itemizedlist>

    <para><figure xml:id="figure.problem-solving">
        <title>General 3-Phased Problem Solving Workflow</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="problem-solving.png" scale="40"></imagedata>
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Each phase is subject to a validation and improvement workflow as
    shown in <xref linkend="figure.validation" />. Each individual phase as
    well as the combination of phases may introduce errors and has thus to be
    carefully validated. In combination with the detailed strategies for each
    phase, this forms a complete approach for problem solving and validation
    using Rascal.<figure xml:id="figure.validation">
        <title>Validation and Improvement Workflow</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="validation.png" scale="40"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>A major question in every problem solving situation is how to
    determine the requirements for each phase of the solution. For instance,
    how do we know what to extract from the source code if we do not know what
    the desired end results of the project are? The standard solution is to
    use a workflow for requirements gathering that is the inverse of the
    phases needed to solve the complete problem. This is shown in <xref
    linkend="figure.requirements" /> and amounts to the phases:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Requirements of the synthesis
        phase</emphasis>. This amounts to making an inventory of the desired
        results of the whole project and may include generated source code,
        abstract models, or visualizations.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Requirements of the analysis
        phase</emphasis>. Once these results of the synthesis phase are known,
        it is possible to list the analysis results that are needed to
        synthesize desired results. Possible results of the analysis phase
        include type information, structural information of the original
        source.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Requirements of the extraction
        phase</emphasis>. As a last step, one can make an inventory of the
        facts that have to be extracted to form the starting point for the
        analysis phase. Typical facts include method calls, inheritance
        relations, control flow graphs, usage patterns of specific library
        functions or language constructs.</para>
      </listitem>
    </itemizedlist>

    <para><figure xml:id="figure.requirements">
        <title>Requirements Workflow</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="requirements.png" scale="40"></imagedata>
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>You will have no problem in identifying requirements for each phase
    when you apply them to a specific example from the list given
    earlier.</para>

    <para>When these requirements have been established, it becomes much
    easier to actually carry out the project using the three phases of <xref
    linkend="figure.problem-solving" />.</para>

    <section xml:id="section.defining-extraction">
      <title>Defining Extraction</title>

      <para>How can we extract facts from the <emphasis>System under
      Investigation</emphasis> (SUI) that we are interested in? The extraction
      workflow is shown in <xref linkend="figure.define-extraction" />and
      consists of the following steps:</para>

      <itemizedlist>
        <listitem>
          <para>First and foremost we have to determine which facts we need.
          This sounds trivial, but it is not. The problem is that we have to
          anticipate which facts will be needed in the next---not yet
          defined---analysis phase. A common approach is to use look-ahead and
          to sketch the queries that are likely to be used in the analysis
          phase and to determine which facts are needed for them. Start with
          extracting these facts and refine the extraction phase when the
          analysis phase is completely defined.</para>
        </listitem>

        <listitem>
          <para>If relevant facts are already available (and they are
          reliable!) then we are done. This may happen when you are working on
          a system that has already been analyzed by others.</para>
        </listitem>

        <listitem>
          <para>Otherwise you need the source code of the SUI. This
          requires:</para>

          <itemizedlist>
            <listitem>
              <para>Checking that all sources are available (and can be
              compiled by the host system on which they are usually compiled
              and executed). Due to missing or unreliable configuration
              management on the original system this may be a labour-intensive
              step that requires many iterations.</para>
            </listitem>

            <listitem>
              <para>Determining in which languages the sources are written. In
              larger systems it is common that three or more different
              languages are being used.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If there are reliable third-party extraction tools available
          for this language mix, then we only have to apply them and we are
          done. Here again, validation is needed that the extracted facts are
          as expected.</para>
        </listitem>

        <listitem>
          <para>The extraction may require syntax analysis. This is the case
          when more structural properties of the source code are needed such
          as the flow-of-control, nesting of declarations, and the like. There
          two approaches here:</para>

          <itemizedlist>
            <listitem>
              <para>Use a third-party parser, convert the source code to parse
              trees and do the further processing of these parse trees in
              Rascal. The advantage is that the parser can be re-used, the
              disadvantage is that data conversion is needed to adapt the
              generated parse tree to Rascal. Validate that the parser indeed
              accepts the language the SUI is written in, since you will not
              be the first who has been bitten by the language dialect monster
              when it turns out that the SUI uses a local variant that
              slightly deviates from a mainstream language.</para>
            </listitem>

            <listitem>
              <para>Use an existing SDF definition of the source language or
              write your own definition. In both cases you can profit from
              Rascal's seamless integration with SDF. Be aware, however, that
              writing a grammar for a non-trivial language is a major
              undertaking and may require weeks to month of work. Whatever
              approach you choose, validate that the result.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The extraction phase may only require lexical analysis. This
          happens when more superficial, textual, facts have to be extracted
          like procedure calls, counts of certain statements and the like. Use
          Rascal's full regular expression facilities to do the lexical
          analysis.</para>
        </listitem>
      </itemizedlist>

      <para>It may happen that the facts extracted from the source code are
      <emphasis>wrong</emphasis>. Typical error classes are:</para>

      <itemizedlist>
        <listitem>
          <para>Extracted facts are <emphasis>wrong</emphasis>: the extracted
          facts incorrectly state that procedure <literal>P</literal> calls
          procedure <literal>Q</literal> but this is contradicted by a source
          code inspection. This may happen when the fact extractor uses a
          conservative approximation when precise information is not
          statically available. In the language C, when procedure P performs
          an indirect call via a pointer variable, the approximation may be
          that P calls all procedures in the procedures.</para>
        </listitem>

        <listitem>
          <para>Extracted facts are <emphasis>incomplete</emphasis>: the
          inheritance between certain classes in Java code is missing.</para>
        </listitem>
      </itemizedlist>

      <para>The strategy to validate extracted facts differ per case but here
      are three strategies:</para>

      <itemizedlist>
        <listitem>
          <para>Post process the extracted facts (using Rascal, of course) to
          obtain trivial facts about the source code such as total lines of
          source code and number of procedures, classes, interfaces and the
          like. Next validate these trivial facts with tools like
          <literal>wc</literal> (word and line count), <literal>grep</literal>
          (regular expression matching) and others.</para>
        </listitem>

        <listitem>
          <para>Do a manual fact extraction on a small subset of the code and
          compare this with the automatically extracted facts.</para>
        </listitem>

        <listitem>
          <para>Use another tool on the same source and compare results
          whenever possible. A typical example is a comparison of a call
          relation extracted with different tools.</para>
        </listitem>
      </itemizedlist>

      <para><figure xml:id="figure.define-extraction">
          <title>Extraction Workflow</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="define-extraction.png" scale="40"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The Rascal features that are most frequently used for extraction
      are:</para>

      <itemizedlist>
        <listitem>
          <para>Regular expression patterns to extract textual facts from
          source code.</para>
        </listitem>

        <listitem>
          <para>Syntax definitions and concrete patterns to match syntactic
          structures in source code.</para>
        </listitem>

        <listitem>
          <para>Pattern matching (used in many Rascal statements).</para>
        </listitem>

        <listitem>
          <para>Visits to traverse syntax trees and to locally extract
          information.</para>
        </listitem>

        <listitem>
          <para>The repertoire of built-in datatypes (like lists, maps, sets
          and relations) to represent the extracted facts.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.defining-analysis">
      <title>Defining Analysis</title>

      <para>The analysis workflow is shown in <xref
      linkend="figure.define-analysis" /> and consists of two steps:</para>

      <itemizedlist>
        <listitem>
          <para>Determine the results that are needed for the synthesis
          phase.</para>
        </listitem>

        <listitem>
          <para>Write the Rascal code to perform the analysis. This may amount
          to:</para>

          <itemizedlist>
            <listitem>
              <para>Reordering extracted facts to make them more suitable for
              the synthesis phase.</para>
            </listitem>

            <listitem>
              <para>Enriching extracted facts. Examples are computing
              transitive closures of extracted facts (e.g., A may call B in
              one or more calls), or performing data reduction by abstracting
              aways details (i.e., reducing a program to a finite
              automaton).</para>
            </listitem>

            <listitem>
              <para>Combining enriched, extracted, facts to create new
              facts.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>As before, validate, validate and validate the results of
      analysis. Essentially the same approach can be used as for validating
      the facts. Manual checking of answers on random samples of the SUI may
      be mandatory. It also happens frequently that answers inspire new
      queries that lead to new answers, and so on.</para>

      <para><figure xml:id="figure.define-analysis">
          <title>Analysis Workflow</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="define-analysis.png" scale="40"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The Rascal features that are frequently used for analysis
      are:</para>

      <itemizedlist>
        <listitem>
          <para>List, set and map comprehensions.</para>
        </listitem>

        <listitem>
          <para>The built-in operators and library functions, in particular
          for lists, maps, sets and relations.</para>
        </listitem>

        <listitem>
          <para>Pattern matching (used in many Rascal statements).</para>
        </listitem>

        <listitem>
          <para>Visits and switches to further process extracted facts.</para>
        </listitem>

        <listitem>
          <para>The solve statement for constraint solving.</para>
        </listitem>

        <listitem>
          <para>Rewrite rules to simplify results and to enforce
          constraints.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.defining-synthesis">
      <title>Defining Synthesis</title>

      <para>Results are synthesized as shown in <xref
      linkend="figure.define-synthesis" />. This consists of the following
      steps:</para>

      <itemizedlist>
        <listitem>
          <para>Determine the results of the synthesis phase. Wide range of
          results is possible including:</para>

          <itemizedlist>
            <listitem>
              <para>Generated source code.</para>
            </listitem>

            <listitem>
              <para>Generated abstract representations, like finite automata
              or other formals models that capture properties of the
              SUI.</para>
            </listitem>

            <listitem>
              <para>Generated data for visualizations that will be used by
              visualization tools.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If source code is to be generated, there are various
          options.</para>

          <itemizedlist>
            <listitem>
              <para>Print strings with embedded variables.</para>
            </listitem>

            <listitem>
              <para>Convert abstract syntax trees to strings (perhaps using
              forms of pretty printing).</para>
            </listitem>

            <listitem>
              <para>Use a grammar of the target source language, also for code
              generation. Note that this approach guarantees the generation of
              syntactically correct source code as opposed to code generation
              using print statements or string templates.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If other output is needed (e.g., an automaton or other formal
          structure) write data declarations to represent that output.</para>
        </listitem>

        <listitem>
          <para>Finally, write functions and rewrite rules that generate the
          desired results.</para>
        </listitem>
      </itemizedlist>

      <para><figure xml:id="figure.define-synthesis">
          <title>Synthesis Workflow</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="define-synthesis.png" scale="40"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The Rascal features that are frequently used for synthesis
      are:</para>

      <itemizedlist>
        <listitem>
          <para>Syntax definitions or data declarations to define output
          formats.</para>
        </listitem>

        <listitem>
          <para>Pattern matching (used in many Rascal statements).</para>
        </listitem>

        <listitem>
          <para>Visits of datastructures and on-the-fly code
          generation.</para>
        </listitem>

        <listitem>
          <para>Rewrite rules.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.more-examples">
    <title>Larger Examples</title>

    <para>Now we will have a closer look at some larger applications of
    Rascal. We start with a call graph analysis in <xref
    linkend="section.motivating-example" /> and then continue with the
    analysis of the component structure of an application in <xref
    linkend="section.analyzing-components" /> and of Java systems in <xref
    linkend="section.analyzing-java" />. Next we move on to the detection of
    uninitialized variables in <xref
    linkend="section.unitialized-variables" />. As an example of computing
    code metrics, we describe the calculation of McCabe's cyclomatic
    complexity in <biblioref linkend="section.McCabe" />. Several examples of
    dataflow analysis follow in <xref linkend="section.dataflow" />. A
    description of program slicing concludes the chapter, see <xref
    linkend="section.program-slicing" />.</para>

    <section xml:id="section.motivating-example">
      <title>Call Graph Analysis</title>

      <para>Suppose a mystery box ends up on your desk. When you open it, it
      contains a huge software system with several questions attached to
      it:</para>

      <itemizedlist>
        <listitem>
          <para>How many procedure calls occur in this system?</para>
        </listitem>

        <listitem>
          <para>How many procedures does it contains?</para>
        </listitem>

        <listitem>
          <para>What are the entry points for this system, i.e., procedures
          that call others but are not called themselves?</para>
        </listitem>

        <listitem>
          <para>What are the leaves of this application, i.e., procedures that
          are called but do not make any calls themselves?</para>
        </listitem>

        <listitem>
          <para>Which procedures call each other indirectly?</para>
        </listitem>

        <listitem>
          <para>Which procedures are called directly or indirectly from each
          entry point?</para>
        </listitem>

        <listitem>
          <para>Which procedures are called from all entry points?</para>
        </listitem>
      </itemizedlist>

      <para>Let's see how these questions can be answered using Rascal.</para>

      <section>
        <title>Preparations</title>

        <para>To illustrate this process consider the workflow in <xref
        linkend="figure.calls-workflow" />. First we have to extract the calls
        from the source code. Rascal is very good at this, but to simplify
        this example we assume that this call graph has already been
        extracted. Also keep in mind that a real call graph of a real
        application will contain thousands and thousands of calls. Drawing it
        in the way we do later on in <xref linkend="figure.calls" /> makes no
        sense since we get a uniformly black picture due to all the call
        dependencies. After the extraction phase, we try to understand the
        extracted facts by writing queries to explore their properties. For
        instance, we may want to know <emphasis>how many calls</emphasis>
        there are, or <emphasis>how many procedures</emphasis>. We may also
        want to enrich these facts, for instance, by computing who calls who
        in more than one step. Finally, we produce a simple textual report
        giving answers to the questions we are interested in.<figure
            xml:id="figure.calls-workflow">
            <title>Workflow for analyzing mystery box</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="calls-workflow.png" scale="40"></imagedata>
              </imageobject>
            </mediaobject>

            <para>Now consider the call graph shown in <xref
            linkend="figure.calls" />. This section is intended to give you a
            first impression what can be done with Rascal.</para>
          </figure><figure xml:id="figure.calls">
            <title>Graphical representation of the <literal>calls</literal>
            relation</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="calls.png" scale="40"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>Rascal supports basic data types like integers and strings which
        are sufficient to formulate and answer the questions at hand. However,
        we can gain readability by introducing separately named types for the
        items we are describing. First, we introduce therefore a new type
        <literal>proc</literal> (an alias for strings) to denote
        procedures:</para>

        <screen>rascal&gt; <userinput>alias proc = str;</userinput>
<computeroutput>ok</computeroutput></screen>

        <para>Suppose that the following facts have been extracted from the
        source code and are represented by the relation
        <literal>Calls</literal>:</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>rel[proc, proc] Calls = 
   { &lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, &lt;"d", "c"&gt;, 
     &lt;"d","e"&gt;, &lt;"f", "e"&gt;, &lt;"f", "g"&gt;, &lt;"g", "e"&gt;
   };</userinput>
<computeroutput>rel[proc,proc]: { &lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, 
                  &lt;"d", "c"&gt;, &lt;"d","e"&gt;, &lt;"f", "e"&gt;, 
                  &lt;"f", "g"&gt;, &lt;"g", "e"&gt;}</computeroutput></screen>

        <para>This concludes the preparatory steps and now we move on to
        answer the questions.</para>
      </section>

      <section>
        <title>How many procedure calls occur in this system?</title>

        <para>To determine the numbers of calls, we simply determine the
        number of tuples in the <literal>Calls</literal> relation, as follows.
        First, we need the Relation library so we import it:<screen><prompt>rascal&gt;</prompt> <userinput>import Relation;</userinput>
<computeroutput>ok</computeroutput></screen>next we describe a new variable
        and calculate the number of tuples:</para>

        <para><screen><prompt>rascal&gt;</prompt> <userinput>nCalls = size(Calls);</userinput>
<computeroutput>int: 8</computeroutput></screen>The library function
        <literal>size</literal> determines the number of elements in a set or
        relation. In this example, <literal>nCalls</literal> will get the
        value <literal>8</literal>.</para>
      </section>

      <section>
        <title>How many procedures are contained in it?</title>

        <para>We get the number of procedures by determining which names occur
        in the tuples in the relation <literal>Calls</literal> and then
        determining the number of names:</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>procs = carrier(Calls);</userinput>
<computeroutput><literal>set[proc]: {"a", "b", "c", "d", "e", "f", "g"}</literal></computeroutput>

<prompt>rascal&gt;</prompt> <userinput>nprocs = size(procs);</userinput>
<computeroutput>int: 7</computeroutput></screen>

        <para>The built-in function <literal>carrier</literal> determines all
        the values that occur in the tuples of a relation. In this case,
        <literal>procs</literal> will get the value <literal>{"a", "b", "c",
        "d", "e", "f", "g"}</literal> and <literal>nprocs</literal> will thus
        get value <literal>7</literal>. A more concise way of expressing this
        would be to combine both steps:</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>nprocs = size(carrier(Calls));</userinput>
<computeroutput>int: 7</computeroutput></screen>
      </section>

      <section>
        <title>What are the entry points for this system?</title>

        <para>The next step in the analysis is to determine which
        <emphasis>entry points</emphasis> this application has, i.e.,
        procedures which call others but are not called themselves. Entry
        points are useful since they define the external interface of a system
        and may also be used as guidance to split a system in parts. The
        <literal>top</literal> of a relation contains those left-hand sides of
        tuples in a relation that do not occur in any right-hand side. When a
        relation is viewed as a graph, its top corresponds to the root nodes
        of that graph. Similarly, the <literal>bottom</literal> of a relation
        corresponds to the leaf nodes of the graph. Using this knowledge, the
        entry points can be computed by determining the top of the
        <literal>Calls</literal> relation:</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>import Graph;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>entryPoints = top(Calls);</userinput>
<computeroutput>set[proc]: {"a", "f"}</computeroutput></screen>

        <para>In this case, <literal>entryPoints</literal> is equal to
        <literal>{"a", "f"}</literal>. In other words, procedures
        <literal>"a"</literal> and <literal>"f"</literal> are the entry points
        of this application.</para>
      </section>

      <section>
        <title>What are the leaves of this application?</title>

        <para>In a similar spirit, we can determine the
        <emphasis>leaves</emphasis> of this application, i.e., procedures that
        are being called but do not make any calls themselves:</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>bottomCalls = bottom(Calls);</userinput>
<computeroutput>set[proc]: {"c", "e"}</computeroutput></screen>

        <para>In this case, <literal>bottomCalls</literal> is equal to
        <literal>{"c", "e"}</literal>.</para>
      </section>

      <section>
        <title>Which procedures call each other indirectly?</title>

        <para>We can also determine the <emphasis>indirect calls</emphasis>
        between procedures, by taking the transitive closure of the
        <literal>Calls</literal> relation, written as
        <literal>Calls+</literal>. Observe that the transitive closure will
        contain both the direct and the indirect calls.</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>closureCalls = Calls+;</userinput>
<computeroutput>rel[proc, proc]: {&lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, 
                  &lt;"d", "c"&gt;, &lt;"d","e"&gt;, &lt;"f", "e"&gt;, 
                  &lt;"f", "g"&gt;, &lt;"g", "e"&gt;, &lt;"a", "c"&gt;, 
                  &lt;"a", "d"&gt;, &lt;"b", "e"&gt;, &lt;"a", "e"&gt;}</computeroutput></screen>
      </section>

      <section>
        <title>Which procedures are called directly or indirectly from each
        entry point?</title>

        <para>We now know the entry points for this application (<literal>"a"
        </literal>and <literal>"f"</literal>) and the indirect call relations.
        Combining this information, we can determine which procedures are
        called from each entry point. This is done by indexing
        <literal>closureCalls</literal> with appropriate procedure name. The
        index operator yields all right-hand sides of tuples that have a given
        value as left-hand side. This gives the following:</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>calledFromA = closureCalls["a"];</userinput>
<computeroutput>set[proc]: {"b", "c", "d", "e"}</computeroutput></screen>

        <para>and</para>

        <screen><prompt>rascal&gt;</prompt> <userinput>calledFromF = closureCalls["f"];</userinput>
<computeroutput>set[proc]: {"e", "g"}</computeroutput></screen>
      </section>

      <section>
        <title>Which procedures are called from all entry points?</title>

        <para>Finally, we can determine which procedures are called from both
        entry points by taking the intersection of the two sets
        <literal>calledFromA</literal> and
        <literal>calledFromF:</literal></para>

        <para><screen><prompt>rascal&gt;</prompt> <userinput>commonProcs = calledFromA &amp; calledFromF;</userinput>
<computeroutput>set[proc]: {"e"}</computeroutput></screen></para>

        <para>In other words, the procedures called from both entry points are
        mostly disjoint except for the common procedure
        <literal>"e"</literal>.</para>
      </section>

      <section>
        <title>Wrap-up</title>

        <para>These findings can be verified by inspecting a graph view of the
        calls relation as shown in <xref linkend="figure.calls" />. Such a
        visual inspection does <emphasis>not</emphasis> scale very well to
        large graphs and this makes the above form of analysis particularly
        suited for studying large systems.</para>
      </section>
    </section>

    <section xml:id="section.analyzing-components">
      <title>Analyzing the Component Structure of an Application</title>

      <para>A frequently occurring problem is that we know the call relation
      of a system but that we want to understand it at the component level
      rather than at the procedure level. If it is known to which component
      each procedure belongs, it is possible to <emphasis>lift</emphasis> the
      call relation to the component level as proposed in <biblioref
      linkend="Krikhaar99" />. Actual lifting amounts to translating each call
      between procedures by a call between components. This is described in
      the following module:<programlisting>module demo::Lift

alias proc = str;
alias comp = str;

public rel[comp,comp] lift(rel[proc,proc] aCalls, 
                           rel[proc,comp] aPartOf){
   return 
      { &lt;C1, C2&gt; | &lt;proc P1, proc P2&gt; &lt;- aCalls, 
                   &lt;comp C1, comp C2&gt; &lt;- aPartOf[P1] * 
                                         aPartOf[P2]
      };
}</programlisting></para>

      <para>For each pair <literal>&lt;P1,P2&gt;</literal> in the Calls
      relation we compose the corresponding parts
      <literal>aPartOf[P1]</literal> and <literal>aPartOf[P2]</literal> (each
      yielding a set of components) into a new relation of calls between
      components. This relation is added pair by pair to the result.</para>

      <para>Let's now apply this. First import the above module, and define a
      call relation and a partof relation:</para>

      <para><screen><prompt>rascal&gt;</prompt> <userinput>import demo::Lift;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>Calls = {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, 
                 &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, &lt;"b", "d"&gt;
                };</userinput>
<computeroutput>rel[str,str] : {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, 
                &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, &lt;"b", "d"&gt;
               }</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>Components = {"Appl", "DB", "Lib"};</userinput>
<computeroutput>set[str] : {"Appl", "DB", "Lib"}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>PartOf = {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, 
                  &lt;"b", "DB"&gt;, &lt;"c", "Lib"&gt;, 
                  &lt;"d", "Lib"&gt;};</userinput>
<computeroutput>rel[str,str] : {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, 
                &lt;"b", "DB"&gt;, &lt;"c", "Lib"&gt;, 
                &lt;"d", "Lib"&gt;}</computeroutput></screen>The lifted call
      relation between components is now obtained by:<screen><prompt>rascal&gt; </prompt><userinput>ComponentCalls = lift(Calls, PartOf);</userinput>
<computeroutput>rel[str,str] : {&lt;"DB", "Lib"&gt;, &lt;"Appl", "Lib"&gt;, 
                &lt;"Appl", "DB"&gt;, &lt;"Appl", "Appl"&gt;}</computeroutput></screen>The
      relevant relations for this example are shown in <xref
      linkend="figure.parts" />.</para>

      <figure xml:id="figure.parts">
        <title>(a) <literal>Calls</literal>; (b) <literal>PartOf</literal>;
        (c) <literal>ComponentCalls</literal>.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="parts.png" scale="40"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="section.analyzing-java">
      <title>Analyzing the Structure of Java Systems</title>

      <para>Now we consider the analysis of Java systems (inspired by
      <biblioref linkend="BNL05" />). Suppose that the type
      <literal>class</literal> is defined as follows<programlisting>alias class = str;</programlisting>and
      that the following relations are available about a Java
      application:</para>

      <itemizedlist>
        <listitem>
          <para><literal>rel[class,class] CALL</literal>: If
          <literal>&lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt;</literal>
          is an element of <literal>CALL</literal>, then some method of
          <replaceable>C</replaceable><subscript>2</subscript> is called from
          <replaceable>C</replaceable><subscript>1</subscript>.</para>
        </listitem>

        <listitem>
          <para><literal>rel[class,class] INHERITANCE</literal>: If
          <literal>&lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt;</literal>
          is an element of <literal>INHERITANCE</literal>, then class
          <replaceable>C</replaceable><subscript>1</subscript> either extends
          class <replaceable>C</replaceable><subscript>2</subscript> or
          <replaceable>C</replaceable><subscript>1</subscript> implements
          interface
          <replaceable>C</replaceable><subscript>2</subscript>.</para>
        </listitem>

        <listitem>
          <para><literal>rel[class,class] CONTAINMENT</literal>: If
          &lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt; is an
          element of <literal>CONTAINMENT</literal>, then one of the fields of
          class <replaceable>C</replaceable><subscript>1</subscript> is of
          type <replaceable>C</replaceable><subscript>2</subscript>.</para>
        </listitem>
      </itemizedlist>

      <para>To make this more explicit, consider the class
      <literal>LocatorHandle</literal> from the JHotDraw application (version
      5.2) as shown here:</para>

      <para><programlisting>package CH.ifa.draw.standard;

import java.awt.Point;
import CH.ifa.draw.framework.*;
/**
 * A LocatorHandle implements a Handle by delegating the 
 * location requests to a Locator object.
 */
public class LocatorHandle extends AbstractHandle {
    private Locator       fLocator;
    /**
     * Initializes the LocatorHandle with the 
     * given Locator.
     */
    public LocatorHandle(Figure owner, Locator l) {
        super(owner);
        fLocator = l;
    }
    /**
     * Locates the handle on the figure by forwarding 
     * the request to its figure.
     */
    public Point locate() {
        return fLocator.locate(owner());
    }
}</programlisting></para>

      <para>It leads to the addition to the above relations of the following
      tuples:</para>

      <itemizedlist>
        <listitem>
          <para>To <literal>CALL</literal> the pairs
          <literal>&lt;"LocatorHandle", "AbstractHandle"&gt;</literal> and
          <literal>&lt;"LocatorHandle", "Locator"&gt;</literal> will be
          added.</para>
        </listitem>

        <listitem>
          <para>To <literal>INHERITANCE</literal> the pair
          <literal>&lt;"LocatorHandle", "AbstractHandle"&gt;</literal> will be
          added.</para>
        </listitem>

        <listitem>
          <para>To <literal>CONTAINMENT</literal> the pair
          <literal>&lt;"LocatorHandle", "Locator"&gt;</literal> will be
          added.</para>
        </listitem>
      </itemizedlist>

      <para>Cyclic structures in object-oriented systems makes understanding
      hard. Therefore it is interesting to spot classes that occur as part of
      a cyclic dependency. Here we determine cyclic uses of classes that
      include calls, inheritance and containment. This is achieved as
      follows:<programlisting>rel[class,class] USE = CALL + CONTAINMENT + INHERITANCE;
set[str] ClassesInCycle =
   {C1 | &lt;class C1, class C2&gt; &lt;- USE+, C1 == C2};</programlisting>First,
      we define the <literal>USE</literal> relation as the union of the three
      available relations <literal>CALL</literal>,
      <literal>CONTAINMENT</literal> and <literal>INHERITANCE</literal>. Next,
      we consider all pairs
      &lt;<replaceable>C</replaceable><subscript>1</subscript>,
      <replaceable>C</replaceable><subscript>2</subscript>&gt; in the
      transitive closure of the <literal>USE</literal> relation such that
      <replaceable>C</replaceable><subscript>1</subscript> and
      <replaceable>C</replaceable><subscript>2</subscript> are equal. Those
      are precisely the cases of a class with a cyclic dependency on itself.
      Probably, we do not only want to know which classes occur in a cyclic
      dependency, but we also want to know which classes are involved in such
      a cycle. In other words, we want to associate with each class a set of
      classes that are responsible for the cyclic dependency. This can be done
      as follows.<programlisting>rel[class,class] USE = CALL + CONTAINMENT + INHERITANCE;
set[class] CLASSES = carrier(USE);
rel[class,class] USETRANS = USE+;
rel[class,set[class]] ClassCycles = 
   {&lt;C, USETRANS[C]&gt; | class C &lt;- CLASSES, 
                       &lt;C, C&gt; in USETRANS };</programlisting>First, we
      introduce two new shorthands: <literal>CLASSES</literal> and
      <literal>USETRANS</literal>. Next, we consider all classes
      <literal>C</literal> with a cyclic dependency and add the pair
      <literal>&lt;C, USETRANS[C]&gt;</literal> to the relation
      <literal>ClassCycles</literal>. Note that <literal>USETRANS[C]</literal>
      is the right image of the relation <literal>USETRANS</literal> for
      element <literal>C</literal>, i.e., all classes that can be called
      transitively from class <literal>C</literal>.</para>
    </section>

    <section xml:id="section.unitialized-variables">
      <title>Finding Uninitialized and Unused Variables in a Program</title>

      <para>Consider the following program in the toy language Pico: (This is
      an extended version of the example presented earlier in <biblioref
      linkend="KlintIWPC03" />.)<programlisting>[ 1] begin declare x : natural, y : natural,
[ 2]              z : natural, p : natural;
[ 3]  x := 3;
[ 4]  p := 4;
[ 5]  if q then
[ 6]        z := y + x
[ 7]  else
[ 8]        x := 4
[ 9]  fi;
[10]  y := z
[11] end</programlisting>Inspection of this program learns that some of the
      variables are being used before they have been initialized. The
      variables in question are <literal>q</literal> (line 5),
      <literal>y</literal> (line 6), and <literal>z</literal> (line 10). It is
      also clear that variable <literal>p</literal> is initialized (line 4),
      but is never used. How can we automate these kinds of analysis? Recall
      from <xref linkend="section.EASY-programming" /> that we follow the
      Extract-Analyze-SYnthesize paradigm to approach such a problem. The
      first step is to determine which elementary facts we need about the
      program. For this and many other kinds of program analysis, we need at
      least the following:</para>

      <itemizedlist>
        <listitem>
          <para>The <emphasis>control flow graph</emphasis> of the program. We
          represent it by a graph <literal>PRED</literal> (for predecessor)
          which relates each statement with its predecessors.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>definitions</emphasis> of each variable, i.e.,
          the program statements where a value is assigned to the variable. It
          is represented by the relation <literal>DEFS</literal>.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>uses</emphasis> of each variable, i.e., the
          program statements where the value of the variable is used. It is
          represented by the relation <literal>USES</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>In this example, we will use line numbers to identify the
      statements in the program. Assuming that there is a tool to extract the
      above information from a program text, we get the following for the
      above example:<programlisting>module demo::Uninit
import Relation;
import Graph;

alias expr = int;
alias varname = str;

public expr ROOT = 1;

public graph[expr] PRED = { &lt;1,3&gt;, &lt;3,4&gt;, &lt;4,5&gt;, &lt;5,6&gt;, 
                            &lt;5,8&gt;, &lt;6,10&gt;, &lt;8,10&gt; };

public rel[varname,expr] DEFS = { &lt;"x", 3&gt;, &lt;"p", 4&gt;, 
                                  &lt;"z", 6&gt;, &lt;"x", 8&gt;, 
                                  &lt;"y", 10&gt; };

public rel[varname, expr] USES = { &lt;"q", 5&gt;, &lt;"y", 6&gt;, 
                                   &lt;"x", 6&gt;, &lt;"z", 10&gt; };
</programlisting>This concludes the extraction phase. Next, we have to enrich
      these basic facts to obtain the initialized variables in the program.
      So, when is a variable <replaceable>V</replaceable> in some statement
      <replaceable>S</replaceable> initialized? If we execute the program
      (starting in <literal>ROOT</literal>), there may be several possible
      execution paths that can reach statement <replaceable>S</replaceable>.
      All is well if <emphasis>all</emphasis> these execution path contain a
      definition of <replaceable>V</replaceable>. However, if one or more of
      these path do <emphasis>not</emphasis> contain a definition of
      <replaceable>V</replaceable>, then <replaceable>V</replaceable> may be
      uninitialized in statement <replaceable>S</replaceable>. This can be
      formalized as follows:<programlisting>// module demo::Unit continued
public rel[varname,expr] UNINIT = 
   { &lt;V,E&gt; | &lt;varname V, expr E&gt; &lt;- USES, 
              E in reachX(PRED, {ROOT}, DEFS[V])
   };</programlisting></para>

      <para>We analyze this definition in detail:</para>

      <itemizedlist>
        <listitem>
          <para><literal>&lt;varname V, expr E&gt; : USES</literal> enumerates
          all tuples in the <literal>USES</literal> relation. In other words,
          we consider the use of each variable in turn.</para>
        </listitem>

        <listitem>
          <para><literal>E in reachX(PRED, {ROOT}, DEFS[V]) </literal>is a
          test that determines whether expression <replaceable>E</replaceable>
          is reachable from the <literal>ROOT</literal> without encountering a
          definition of variable <replaceable>V</replaceable>.</para>

          <itemizedlist>
            <listitem>
              <para><literal>{ROOT}</literal> represents the initial set of
              nodes from which all path should start.</para>
            </listitem>

            <listitem>
              <para><literal>DEFS[V]</literal> yields the set of all
              statements in which a definition of variable
              <literal>V</literal> occurs. These nodes form the exclusion set
              for <literal>reachX</literal>: no path will be extended beyond
              an element in this set.</para>
            </listitem>

            <listitem>
              <para><literal>PRED</literal> is the relation for which the
              reachability has to be determined.</para>
            </listitem>

            <listitem>
              <para>The result of <literal>reachX(PRED, {ROOT}, DEFS[V])
              </literal>is a set that contains all nodes that are reachable
              from the <literal>ROOT</literal> (as well as all intermediate
              nodes on each path).</para>
            </listitem>

            <listitem>
              <para>Finally, <literal>E in reachX(PRED, {ROOT}, DEFS[V])
              </literal>tests whether expression <literal>E</literal> can be
              reached from the <literal>ROOT</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The net effect is that <literal>UNINIT</literal> will only
          contain pairs that satisfy the test just described.</para>
        </listitem>
      </itemizedlist>

      <para>When we execute the resulting Rascal code (i.e., the declarations
      of <literal>ROOT</literal>, <literal>PRED</literal>,
      <literal>DEFS</literal>, <literal>USES</literal> and
      <literal>UNINIT</literal>), we get as value for
      <literal>UNINIT</literal>:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Uninit;</userinput>
ok

<prompt>rascal&gt;</prompt> <userinput>UNINIT;</userinput>
<computeroutput>rel[varname,expr]: {&lt;"q", 5&gt;, &lt;"y", 6&gt;, &lt;"z", 10&gt;}</computeroutput></screen>and
      this is in concordance with the informal analysis given at the beginning
      of this example.</para>

      <para>As a bonus, we can also determine the <emphasis>unused</emphasis>
      variables in a program, i.e., variables that are defined but are used
      nowhere. This is done as follows:<programlisting>// module demo::Unit continued

public set[varname] UNUSED = domain(DEFS) - domain(USES);</programlisting>Taking
      the domain of the relations <literal>DEFS</literal> and
      <literal>USES</literal> yields the variables that are defined,
      respectively, used in the program. The difference of these two sets
      yields the unused variables, in this case
      <literal>{"p"}</literal>.</para>
    </section>

    <section xml:id="section.McCabe">
      <title>McCabe Cyclomatic Complexity</title>

      <para>The <emphasis>cyclomatic complexity</emphasis> of a program is
      defined as <replaceable>e</replaceable> - <replaceable>n</replaceable> +
      2, where <replaceable>e</replaceable> and <replaceable>n</replaceable>
      are the number of edges and nodes in the control flow graph,
      respectively. It was proposed by McCabe <biblioref linkend="McCabe76" />
      as a measure of program complexity. Experiments have shown that programs
      with a higher cyclomatic complexity are more difficult to understand and
      test and have more errors. It is generally accepted that a program,
      module or procedure with a cyclomatic complexity larger than 15 is
      <emphasis>too complex</emphasis>. Essentially, cyclomatic complexity
      measures the number of decision points in a program and can be computed
      by counting all if statement, case branches in switch statements and the
      number of conditional loops. Given a control flow in the form of a
      predecessor graph <literal>Graph[&amp;T] PRED</literal> between elements
      of arbitrary type <literal>&amp;T</literal>, the cyclomatic complexity
      can be computed in Rascal as follows: <programlisting>module demo::McCabe
import Graph;

public int cyclomaticComplexity(Graph[&amp;T] PRED){
    return size(PRED) - size(carrier(PRED)) + 2;
}</programlisting>The number of edges <replaceable>e</replaceable> is equal to
      the number of tuples in <literal>PRED</literal>. The number of nodes
      <replaceable>n</replaceable> is equal to the number of elements in the
      carrier of PRED, i.e., all elements that occur in a tuple in
      <literal>PRED</literal>.</para>
    </section>

    <section xml:id="section.dataflow">
      <title>Dataflow Analysis</title>

      <para><emphasis>Dataflow analysis</emphasis> is a program analysis
      technique that forms the basis for many compiler optimizations. It is
      described in any text book on compiler construction, e.g. <biblioref
      linkend="AhoSethiUllman86" />. The goal of dataflow analysis is to
      determine the effect of statements on their surroundings. Typical
      examples are:</para>

      <itemizedlist>
        <listitem>
          <para>Dominators (<xref linkend="section.dominators" />): which
          nodes in the flow dominate the execution of other nodes?</para>
        </listitem>

        <listitem>
          <para>Reaching definitions (<xref
          linkend="section.reaching-definitions" />): which definitions of
          variables are still valid at each statement?</para>
        </listitem>

        <listitem>
          <para>Live variables (<xref linkend="section.live-variables" />): of
          which variables will the values be used by successors of a
          statement?</para>
        </listitem>

        <listitem>
          <para>Available expressions: an expression is available if it is
          computed along each path from the start of the program to the
          current statement.</para>
        </listitem>
      </itemizedlist>

      <section xml:id="section.dominators">
        <title>Dominators</title>

        <para>A node <replaceable>d</replaceable> of a flow graph
        <emphasis>dominates</emphasis> a node <replaceable>n</replaceable>, if
        every path from the initial node of the flow graph to
        <replaceable>n</replaceable> goes through <replaceable>d</replaceable>
        <biblioref linkend="AhoSethiUllman86" /> (Section 10.4). Dominators
        play a role in the analysis of conditional statements and loops. The
        function <literal>dominators</literal> that computes the dominators
        for a given flow graph <literal>PRED</literal> and an entry node
        <literal>ROOT</literal> is defined as follows:</para>

        <para><programlisting>module demo::Dominators
import Set;
import Relation;
import Graph;

public rel[&amp;T, set[&amp;T]] dominators(rel[&amp;T,&amp;T] PRED, 
                                   &amp;T ROOT)
{
  set[&amp;T] VERTICES = carrier(PRED);
  return  { &lt;V,  (VERTICES - {V, ROOT}) - 
                 reachX(PRED,{ROOT},{V})&gt; 
            |  &amp;T V &lt;- VERTICES
          };
}</programlisting></para>

        <para>First, the auxiliary set <literal>VERTICES</literal> (all the
        statements) is computed. The relation <literal>DOMINATES</literal>
        consists of all pairs <literal>&lt;<replaceable>S</replaceable>,
        {<replaceable>S</replaceable><subscript>1</subscript>,...,<replaceable>S</replaceable><subscript><replaceable>n</replaceable></subscript>}&gt;</literal>
        such that</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>S</replaceable><subscript><replaceable>i</replaceable></subscript>
            is not an initial node or equal to
            <replaceable>S</replaceable>.</para>
          </listitem>

          <listitem>
            <para><replaceable>S</replaceable><subscript><replaceable>i</replaceable></subscript>
            cannot be reached from the initial node without going through
            <replaceable>S</replaceable>.</para>
          </listitem>
        </itemizedlist>

        <para>First import the above module and consider the sample flow graph
        PRED:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Dominators;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[int,int] PRED = {
&lt;1,2&gt;, &lt;1,3&gt;,
&lt;2,3&gt;,
&lt;3,4&gt;,
&lt;4,3&gt;,&lt;4,5&gt;, &lt;4,6&gt;,
&lt;5,7&gt;,
&lt;6,7&gt;,
&lt;7,4&gt;,&lt;7,8&gt;,
&lt;8,9&gt;,&lt;8,10&gt;,&lt;8,3&gt;,
&lt;9,1&gt;,
&lt;10,7&gt;
};</userinput>

<computeroutput>rel[int,int]: { &lt;1,2&gt;, &lt;1,3&gt;, ...</computeroutput></screen>It
        is illustrated in<xref linkend="figure.flow-graph" /><figure
            xml:id="figure.flow-graph">
            <title>Flow graph</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="dominators.png" scale="40"></imagedata>
              </imageobject>
            </mediaobject>
          </figure>The result of applying <literal>dominators</literal> to it
        is as follows:<screen><prompt>rascal&gt;</prompt> <userinput>dominators(PRED);</userinput>
<computeroutput>rel[int,int]: {&lt;1, {2, 3, 4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;2, {}&gt;, 
&lt;3, {4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;4, {5, 6, 7, 8, 9, 10}&gt;, 
&lt;5, {}&gt;, 
&lt;6, {}&gt;, 
&lt;7, {8, 9, 10}&gt;, 
&lt;8, {9, 10}&gt;, 
&lt;9, {}&gt;, 
&lt;10, {}&gt;}</computeroutput></screen>The resulting <emphasis>dominator
        tree</emphasis> is shown in <xref linkend="figure.dominator-tree" />.
        The dominator tree has the initial node as root and each node
        <replaceable>d</replaceable> in the tree only dominates its
        descendants in the tree.</para>

        <para><figure xml:id="figure.dominator-tree">
            <title>Dominator tree</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="dominator-tree.png" scale="40"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section xml:id="section.reaching-definitions">
        <title>Reaching Definitions</title>

        <para>We illustrate the calculation of reaching definitions using the
        example in <xref linkend="figure.dataflow-graph" /> which was inspired
        by <biblioref linkend="AhoSethiUllman86" /> (Example 10.15).</para>

        <para><figure xml:id="figure.dataflow-graph">
            <title>Flow graph for various dataflow problems</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="df-graph.png" scale="40"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>We assume the following basic definitions to represent
        information about the program:<programlisting>module demo::ReachingDefs

import Relation;
import Graph;
import IO;

public alias stat = int;
public alias var = str;
public alias def  = tuple[stat, var];
public alias use = tuple[stat,var];

public rel[stat,def] definition(rel[stat,var] DEFS){
  return {&lt;S,&lt;S,V&gt;&gt; | &lt;stat S, var V&gt; &lt;- DEFS};
}

public rel[stat,def] use(rel[stat, var] USES){
  return {&lt;S, &lt;S, V&gt;&gt; | &lt;stat S, var V&gt; &lt;- USES};
}
</programlisting></para>

        <para>Let's use the following values to represent our example:</para>

        <para><screen><prompt>rascal&gt;</prompt> <userinput>rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, 
                                &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,7&gt;, 
                                &lt;6,7&gt;, &lt;7,4&gt; };</userinput>
<computeroutput>rel[stat,stat]: { &lt;1,2&gt;, &lt;2,3&gt;, ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat, var] DEFS = { &lt;1, "i"&gt;, &lt;2, "j"&gt;, 
                                &lt;3, "a"&gt;, &lt;4, "i"&gt;, 
                                &lt;5, "j"&gt;, &lt;6, "a"&gt;, 
                                &lt;7, "i"&gt; };</userinput>
<computeroutput>rel[stat,var]: { &lt;1, "i"&gt;, &lt;2, "j"&gt;, ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat,var] USES = { &lt;1, "m"&gt;, &lt;2, "n"&gt;, 
                               &lt;3, "u1"&gt;, &lt;4, "i"&gt;, 
                               &lt;5, "j"&gt;, &lt;6, "u2"&gt;, 
                               &lt;7, "u3"&gt; };</userinput>
<computeroutput>rel[stat,var]: { &lt;1, "m"&gt;, &lt;2, "n"&gt;,...</computeroutput></screen></para>

        <para>For convenience, we have introduced above a notion
        <literal>def</literal> that describes that a certain statement defines
        some variable and we revamp the basic relations into a more convenient
        format using this new type and the auxiliary functions
        <literal>definition</literal> and <literal>use</literal>:<screen><prompt>rascal&gt;</prompt> <userinput>definition(DEFS);</userinput>
<computeroutput>rel[stat,def]: { &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, 
                 &lt;3, &lt;3, "a"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
                 &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, 
                 &lt;7, &lt;7, "i"&gt;&gt; }</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>use(USES);</userinput>
<computeroutput>rel[stat,def]: { &lt;1, &lt;1, "m"&gt;&gt;, &lt;2, &lt;2, "n"&gt;&gt;, 
                 &lt;3, &lt;3, "u1"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
                 &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "u2"&gt;&gt;, 
                 &lt;7, &lt;7, "u3"&gt;&gt; }</computeroutput></screen></para>

        <para>Now we are ready to define an important new relation
        <literal>KILL</literal>. <literal>KILL</literal> defines which
        variable definitions are undone (killed) at each statement and is
        defined by the following function
        <literal>kill</literal>:<programlisting>// continuing module demo::ReachingDefs

public rel[stat,def] kill(rel[stat,var] DEFS) { 
  return {&lt;S1, &lt;S2, V&gt;&gt; | &lt;stat S1, var V&gt; &lt;- DEFS, 
                          &lt;stat S2, V&gt; &lt;- DEFS, 
                          S1 != S2};
}</programlisting>In this definition, all variable definitions are compared
        with each other, and for each variable definition all
        <emphasis>other</emphasis> definitions of the same variable are placed
        in its kill set. In the example, <literal>KILL</literal> gets the
        value <screen><prompt>rascal&gt;</prompt> <userinput>kill(DEFS);</userinput>
<computeroutput>rel[stat,def]: 
{ &lt;1, &lt;4, "i"&gt;&gt;, &lt;1, &lt;7, "i"&gt;&gt;, &lt;2, &lt;5, "j"&gt;&gt;, 
  &lt;3, &lt;6, "a"&gt;&gt;, &lt;4, &lt;1, "i"&gt;&gt;, &lt;4, &lt;7, "i"&gt;&gt;, 
  &lt;5, &lt;2, "j"&gt;&gt;, &lt;6, &lt;3, "a"&gt;&gt;, &lt;7, &lt;1, "i"&gt;&gt;, 
  &lt;7, &lt;4, "i"&gt;&gt;
}</computeroutput></screen>and, for instance, the definition of variable
        <literal>i</literal> in statement <literal>1</literal> kills the
        definitions of <literal>i</literal> in statements <literal>4</literal>
        and <literal>7</literal>.</para>

        <para>After these preparations, we are ready to formulate the reaching
        definitions problem in terms of two relations <literal>IN</literal>
        and <literal>OUT</literal>. <literal>IN</literal> captures all the
        variable definitions that are valid at the entry of each statement and
        <literal>OUT</literal> captures the definitions that are still valid
        after execution of each statement. Intuitively, for each statement
        <literal>S</literal>, <literal>IN[S]</literal> is equal to the union
        of the <literal>OUT</literal> of all the predecessors of
        <literal>S</literal>. <literal>OUT[S]</literal>, on the other hand, is
        equal to the definitions generated by <literal>S</literal> to which we
        add <literal>IN[S]</literal> minus the definitions that are killed in
        <literal>S</literal>. Mathematically, the following set of equations
        captures this idea for each statement:</para>

        <para>IN[S] = UNION<subscript>P in predecessors of S</subscript>
        OUT[P]</para>

        <para>OUT[S] = DEF[S] + (IN[S] - KILL[S])</para>

        <para>This idea can be expressed in Rascal quite
        literally:<programlisting>public rel[stat, def] reachingDefinitions(
                            rel[stat,var] DEFS, 
                            rel[stat,stat] PRED){
  set[stat] STATEMENT = carrier(PRED);
  rel[stat,def] DEF  = definition(DEFS);
  rel[stat,def] KILL = kill(DEFS);

  // The set of mutually recursive dataflow equations 
  // that has to be solved:
  
  rel[stat,def] IN = {};
  rel[stat,def] OUT = DEF;

  solve (IN, OUT) {
    IN  = {&lt;S, D&gt; | int S &lt;- STATEMENT, 
                    stat P &lt;- predecessors(PRED,S), 
                    def D &lt;- OUT[P]};
    OUT = {&lt;S, D&gt; | int S &lt;- STATEMENT, 
                    def D &lt;- DEF[S] + (IN[S] - KILL[S])};
  };
  return IN;
}</programlisting>First, the relations <literal>IN</literal> and
        <literal>OUT</literal> are declared and initialized. Next follows a
        <keysym>solve</keysym> statement that uses <literal>IN</literal> and
        <literal>OUT</literal> as variables and contains two equations that
        resemble the mathematical equations given above. Note the use of the
        library function <literal>predecessors</literal> to obtain the
        predecessors of a statement for a given control flow graph.</para>

        <para><figure xml:id="figure.reaching-definitions">
            <title>Reaching definitions for flow graph in <xref
            linkend="figure.dataflow-graph" /></title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="reach.png" scale="40"></imagedata>
              </imageobject>
            </mediaobject>
          </figure> For our running example (<xref
        linkend="figure.reaching-definitions" />) the results are as follows
        (see <xref linkend="figure.reaching-definitions" />). Relation
        <literal>IN</literal> has as value:<programlisting>{ &lt;2, &lt;1, "i"&gt;&gt;, &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, 
  &lt;4, &lt;3, "a"&gt;&gt;, &lt;4, &lt;2, "j"&gt;&gt;, &lt;4, &lt;1, "i"&gt;&gt;, 
  &lt;4, &lt;7, "i"&gt;&gt;, &lt;4, &lt;5, "j"&gt;&gt;, &lt;4, &lt;6, "a"&gt;&gt;, 
  &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;2, "j"&gt;&gt;, 
  &lt;5, &lt;5, "j"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, &lt;6, &lt;5, "j"&gt;&gt;, 
  &lt;6, &lt;4, "i"&gt;&gt;, &lt;6, &lt;3, "a"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, 
  &lt;7, &lt;5, "j"&gt;&gt;, &lt;7, &lt;4, "i"&gt;&gt;, &lt;7, &lt;3, "a"&gt;&gt;, 
  &lt;7, &lt;6, "a"&gt;&gt;
}</programlisting></para>

        <para>If we consider statement <literal>3</literal>, then the
        definitions of variables <literal>i</literal> and <literal>j</literal>
        from the preceding two statements are still valid. A more interesting
        case are the definitions that can reach statement
        <literal>4</literal>:</para>

        <itemizedlist>
          <listitem>
            <para>The definitions of variables <literal>a</literal>,
            <literal>j</literal> and <literal>i</literal> from, respectively,
            statements <literal>3</literal>, <literal>2</literal> and
            <literal>1</literal>.</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>i</literal> from
            statement <literal>7</literal> (via the backward control flow path
            from <literal>7</literal> to <literal>4</literal>).</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>j</literal> from
            statement <literal>5</literal> (via the path <literal>5</literal>,
            <literal>7</literal>, <literal>4</literal>).</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>a</literal> from
            statement <literal>6</literal> (via the path <literal>6</literal>,
            <literal>7</literal>, <literal>4</literal>).</para>
          </listitem>
        </itemizedlist>

        <para>Relation <literal>OUT</literal> has as value:<programlisting>{ &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, &lt;2, &lt;1, "i"&gt;&gt;, 
  &lt;3, &lt;3, "a"&gt;&gt;, &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, 
  &lt;4, &lt;4, "i"&gt;&gt;, &lt;4, &lt;3, "a"&gt;&gt;, &lt;4, &lt;2, "j"&gt;&gt;, 
  &lt;4, &lt;5, "j"&gt;&gt;, &lt;4, &lt;6, "a"&gt;&gt;, &lt;5, &lt;5, "j"&gt;&gt;, 
  &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, 
  &lt;6, &lt;6, "a"&gt;&gt;, &lt;6, &lt;5, "j"&gt;&gt;, &lt;6, &lt;4, "i"&gt;&gt;, 
  &lt;7, &lt;7, "i"&gt;&gt;, &lt;7, &lt;5, "j"&gt;&gt;, &lt;7, &lt;3, "a"&gt;&gt;, 
  &lt;7, &lt;6, "a"&gt;&gt;
}</programlisting>Observe, again for statement <literal>4</literal>, that all
        definitions of variable <literal>i</literal> are missing in
        <literal>OUT[4]</literal> since they are killed by the definition of
        <literal>i</literal> in statement <literal>4</literal> itself.
        Definitions for <literal>a</literal> and <literal>j</literal> are,
        however, contained in <literal>OUT[4]</literal>. The result of
        reaching definitions computation is illustrated in <xref
        linkend="figure.reaching-definitions" />. We will use the function
        <literal>reachingDefinitions</literal> later on in <xref
        linkend="section.program-slicing" /> when defining program
        slicing.</para>
      </section>

      <section xml:id="section.live-variables">
        <title>Live Variables</title>

        <para>The live variables of a statement are those variables whose
        value will be used by the current statement or some successor of it.
        The mathematical formulation of this problem is as follows:</para>

        <para>IN[S] =USE[S] + (OUT[S] - DEF[S])</para>

        <para>OUT[S] = UNION<subscript>S' in successors of S</subscript>
        IN[S']</para>

        <para>The first equation says that a variable is live coming into a
        statement if either it is used before redefinition in that statement
        or it is live coming out of the statement and is not redefined in it.
        The second equation says that a variable is live coming out of a
        statement if and only if it is live coming into one of its
        successors.</para>

        <para>This can be expressed in Rascal as follows:<programlisting>public rel[stat,def] liveVariables(rel[stat, var] DEFS, 
                                   rel[stat, var] USES, 
                                   rel[stat,stat] PRED){
  set[stat] STATEMENT = carrier(PRED);
  rel[stat,def] DEF  = definition(DEFS);
  rel[stat,def] USE = use(USES);
 
  rel[stat,def] LIN = {};
  rel[stat,def] LOUT = DEF;

  solve(LIN, LOUT) {
    LIN  = { &lt;S, D&gt; | stat S &lt;- STATEMENT,  
                      def D &lt;- USE[S] + 
                               (LOUT[S] - (DEF[S]))};
    LOUT = { &lt;S, D&gt; | stat S &lt;- STATEMENT,  
                      stat Succ &lt;- successors(PRED,S), 
                      def D &lt;- LIN[Succ] };
  }
  return LIN;
}</programlisting>The results of live variable analysis for our running
        example are illustrated in <xref
        linkend="figure.live-variables" />.</para>

        <para><figure xml:id="figure.live-variables">
            <title>Live variables for flow graph in <xref
            linkend="figure.dataflow-graph" /></title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="live.png" scale="40"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>
    </section>

    <section xml:id="section.program-slicing">
      <title>Program Slicing</title>

      <para>Program slicing is a technique proposed by Weiser <biblioref
      linkend="Weiser84" /> for automatically decomposing programs in parts by
      analyzing their data flow and control flow. Typically, a given statement
      in a program is selected as the <emphasis>slicing criterion</emphasis>
      and the original program is reduced to an independent subprogram, called
      a <emphasis>slice</emphasis>, that is guaranteed to represent faithfully
      the behavior of the original program at the slicing criterion. An
      example will illustrate this (we use line numbers for later
      reference):</para>

      <para><programlisting xml:id="programlisting.slice-example">[ 1] read(n)        [1] read(n)      [ 1] read(n)
[ 2] i := 1         [2] i := 1       [ 2] i := 1
[ 3] sum := 0       [3] sum := 0      
[ 4] product := 1                    [ 4] product := 1
[ 5] while i&lt;= n    [5] while i&lt;= n  [ 5] while i&lt;= n
     do                 do                do
     begin              begin             begin
[ 6]  sum :=        [6]  sum :=
          sum + i            sum + i
[ 7]  product :=                     [ 7]  product := 
        product * i                          product * i
[ 8]  i := i + 1    [8]  i := i + 1  [ 8]  i := i + 1
     end                 end              end
[ 9] write(sum)     [9] write(sum)
[10] write(product)                  [10] write(product)

<emphasis role="bold">(a)</emphasis> Sample program  <emphasis role="bold">(b)</emphasis> Slice for    <emphasis
            role="bold">(c)</emphasis> Slice for
                        statement [9]    statement [10]</programlisting></para>

      <para>The initial program is given as (a). The slice with statement [9]
      as slicing criterion is shown in (b): statements <literal>[4]</literal>
      and <literal>[7]</literal> are irrelevant for computing statement
      <literal>[9]</literal> and do not occur in the slice. Similarly, (c)
      shows the slice with statement <literal>[10]</literal> as slicing
      criterion. This particular form of slicing is called <emphasis>backward
      slicing</emphasis>. Slicing can be used for debugging and program
      understanding, optimization and more. An overview of slicing techniques
      and applications can be found in <biblioref linkend="Tip95" />. Here we
      will explore a relational formulation of slicing adapted from a proposal
      in <biblioref linkend="JacksonRollins94" />. The basic ingredients of
      the approach are as follows:</para>

      <itemizedlist>
        <listitem>
          <para>We assume the relations <literal>PRED</literal>,
          <literal>DEFS</literal> and <literal>USES</literal> as
          before.</para>
        </listitem>

        <listitem>
          <para>We assume an additional set
          <literal>CONTROL-STATEMENT</literal> that defines which statements
          are control statements.</para>
        </listitem>

        <listitem>
          <para>To tie together dataflow and control flow, three auxiliary
          variables are introduced:</para>

          <itemizedlist>
            <listitem>
              <para>The variable <literal>TEST</literal> represents the
              outcome of a specific test of some conditional statement. The
              conditional statement defines <literal>TEST</literal> and all
              statements that are control dependent on this conditional
              statement will use <literal>TEST</literal>.</para>
            </listitem>

            <listitem>
              <para>The variable <literal>EXEC</literal> represents the
              potential execution dependence of a statement on some
              conditional statement. The dependent statement defines
              <literal>EXEC</literal> and an explicit (control) dependence is
              made between <literal>EXEC</literal> and the corresponding
              <literal>TEST</literal>.</para>
            </listitem>

            <listitem>
              <para>The variable <literal>CONST</literal> represents an
              arbitrary constant.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>The calculation of a (backward) slice now proceeds in six
      steps:</para>

      <itemizedlist>
        <listitem>
          <para>Compute the relation <literal>rel[use,def] use-def</literal>
          that relates all uses to their corresponding definitions. The
          function <literal>reaching-definitions</literal> as shown earlier in
          <xref linkend="section.reaching-definitions" />does most of the
          work.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[def,use]
          def-use-per-stat</literal> that relates the
          <emphasis>internal</emphasis> definitions and uses of a
          statement.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[def,use]
          control-dependence</literal> that links all <literal>EXEC</literal>s
          to the corresponding <literal>TEST</literal>s.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[use,def]
          use-control-def</literal> combines use/def dependencies with control
          dependencies.</para>
        </listitem>

        <listitem>
          <para>After these preparations, compute the relation
          <literal>rel[use,use] USE-USE</literal> that contains dependencies
          of uses on uses.</para>
        </listitem>

        <listitem>
          <para>The backward slice for a given slicing criterion (a use) is
          now simply the projection of <literal>USE-USE</literal> for the
          slicing criterion.</para>
        </listitem>
      </itemizedlist>

      <para>This informal description of backward slicing can now be expressed
      in Rascal:</para>

      <para><programlisting>module demo::Slicing

import Set;
import Relation;
import demo::ReachingDefs;
import demo::Dominators;
import UnitTest;

set[use] BackwardSlice(set[stat] CONTROLSTATEMENT, 
                       rel[stat,stat] PRED,
                       rel[stat,var] USES,
                       rel[stat,var] DEFS,	
                       use Criterion) {

  rel[stat, def] REACH = reachingDefinitions(DEFS, PRED);

  // Compute the relation between each use and 
  // corresponding definitions: use_def

  rel[use,def] use_def =
  {&lt;&lt;S1,V&gt;, &lt;S2,V&gt;&gt; | &lt;stat S1, var V&gt; &lt;- USES, 
                      &lt;stat S2, V&gt; &lt;- REACH[S1]};

  // Internal dependencies per statement

  rel[def,use] def_use_per_stat  = 
       {&lt;&lt;S,V1&gt;, &lt;S,V2&gt;&gt; | &lt;stat S, var V1&gt; &lt;- DEFS, 
                           &lt;S, var V2&gt; &lt;- USES}
       +
       {&lt;&lt;S,V&gt;, &lt;S,"EXEC"&gt;&gt; | &lt;stat S, var V&gt; &lt;- DEFS}
       +
       {&lt;&lt;S,"TEST"&gt;,&lt;S,V&gt;&gt; | stat S &lt;- CONTROLSTATEMENT, 
                             &lt;S, var V&gt; &lt;- 
                                      domainR(USES, {S})};

  // Control dependence: control-dependence

  rel[stat, set[stat]] CONTROLDOMINATOR = 
  domainR(dominators(PRED, 1), CONTROLSTATEMENT);

  rel[def,use] control_dependence  =
  { &lt;&lt;S2, "EXEC"&gt;,&lt;S1,"TEST"&gt;&gt; 
    | &lt;stat S1, stat S2&gt; &lt;- CONTROLDOMINATOR};

  // Control and data dependence: use-control-def

  rel[use,def] use_control_def = 
               use_def + control_dependence;
  rel[use,use] USE_USE = 
               (use_control_def o def_use_per_stat)*;

  return USE_USE[Criterion];
}</programlisting></para>

      <para>Let's apply this to the example from the start of this section and
      assume the following:<screen><prompt>rascal&gt;</prompt> <userinput>import demo::Slicing;</userinput>
<computeroutput>ok</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, 
                                &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,9&gt;, 
                                &lt;6,7&gt;, &lt;7,8&gt;, &lt;8,5&gt;, 
                                &lt;8,9&gt;, &lt;9,10&gt; };</userinput>
<computeroutput>rel[stat,stat]: {&lt;1,2&gt;, ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat,var] DEFS  = { &lt;1, "n"&gt;, &lt;2, "i"&gt;, 
                                &lt;3, "sum"&gt;, 
                                &lt;4,"product"&gt;, 
                                &lt;6, "sum"&gt;, 
                                &lt;7, "product"&gt;, 
                                &lt;8, "i"&gt; };</userinput>
<computeroutput>rel[stat,var]: {&lt;1, "n"&gt;, ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>rel[stat,var] USES  = { &lt;5, "i"&gt;, &lt;5, "n"&gt;, 
                                &lt;6, "sum"&gt;, &lt;6,"i"&gt;, 
                                &lt;7, "product"&gt;, &lt;7, "i"&gt;, 
                                &lt;8, "i"&gt;, &lt;9, "sum"&gt;, 
                                &lt;10, "product"&gt;
                              };</userinput>
<computeroutput>rel[stat,var]; { &lt;5, "i"&gt; ...</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>set[int] CONTROL-STATEMENT = { 5 };</userinput>
<computeroutput>set[int]: {5}</computeroutput>

<prompt>rascal&gt;</prompt> <userinput>BackwardSlice(CONTROL-STATEMENT, 
                      PRED, USES, DEFS, &lt;9, "sum"&gt;);</userinput>
<computeroutput>set[use]: { &lt;1, "EXEC"&gt;, &lt;2, "EXEC"&gt;,  &lt;3, "EXEC"&gt;, 
            &lt;5, "i"&gt;, &lt;5, "n"&gt;, &lt;6, "sum"&gt;, &lt;6, "i"&gt;, 
            &lt;6, "EXEC"&gt;, &lt;8, "i"&gt;, &lt;8, "EXEC"&gt;, 
            &lt;9, "sum"&gt; }</computeroutput></screen>Take the domain of
      this result and we get exactly the statements in (b) of the
      example.</para>
    </section>
  </section>

  <section>
    <title>Concluding Remarks</title>

    <para>Rascal and its IDE are in full development at the time of writing
    and a first prototype implementation is available for download. We have
    given here only a sketch of the language and its applications. The
    following topics have not been covered in this article:</para>

    <itemizedlist>
      <listitem>
        <para>The use of SDF modules to parse source text.</para>
      </listitem>

      <listitem>
        <para>The extensive Rascal library that supports many operations on
        the basic datatypes including shortest path, reachability and
        bisimulation on graphs. It also provides tools for drawing graphs and
        charts, for extracting data from Subversion repositories and
        more.</para>
      </listitem>

      <listitem>
        <para>The Rascal Eclipse JDT library that provides direct access to
        facts that have been extracted from Java source code.</para>
      </listitem>

      <listitem>
        <para>The Rascal IDE that is based on Eclipse and that provides, for
        instance, very good interactive debugging facilities and basic
        visualization tools.</para>
      </listitem>
    </itemizedlist>

    <para>We refer the interested reader to <link
    xlink:href="http://www.meta-environment.org/Meta-Environment/Rascal">http://www.meta-environment.org/Meta-Environment/Rascal</link>
    for a more complete and up-to-date overview and for downloading the latest
    version of Rascal.</para>
  </section>

  <section>
    <title>Acknowledgements</title>

    <para>Rascal has been designed and implemented by the authors but they
    have received strong support, encouragement, and help from the following
    individuals. We are very grateful to them.</para>

    <para>Emilie Balland implemented the Rascal debugger in the Eclipse
    version of Rascal during her visit to CWI in the summer of 2009.</para>

    <para>Bas Basten provided useful feedback on the design and is developing
    a Rascal/Eclipse JDT interface that makes it easy to extract facts from
    Java source code. Joppe Kroon further improved the JDT interface.</para>

    <para>Bob Fuhrer's inspiring IMP project motivated us to build Rascal on
    top of IMP. The PDB was designed and implemented during Jurgen's visit to
    IBM Research in 2007-2008.</para>

    <para>Arnold Lankamp implemented a very efficient version of the Program
    Data Base (PDB), added a binary streaming format, implemented the SGLR
    invoker, and takes care of deployment issues.</para>

    <para>Karel Pieterson used Rascal as topic for a usability study in his
    Master's thesis. The results will be included in the final version of this
    document.</para>

    <para>Claus Brabrand, Frank Tip and Yaroslav Usenko provided feedback on
    this manual and suggested several improvements.</para>
  </section>

  <section xml:id="section.bibliography">
    <title>Bibliography</title>

    <para><bibliolist>
        <bibliomixed xml:id="AhoSethiUllman86"></bibliomixed>

        <bibliomixed xml:id="ElanBKKMR-wrla98"></bibliomixed>

        <bibliomixed xml:id="BallandBKMR-RTA2007"></bibliomixed>

        <bibliomixed xml:id="DMS"></bibliomixed>

        <bibliomixed xml:id="BNL05"></bibliomixed>

        <bibliomixed xml:id="BDHJJKKMOSVVV01"></bibliomixed>

        <bibliomixed xml:id="BKV03"></bibliomixed>

        <bibliomixed xml:id="BKVV08"></bibliomixed>

        <bibliomixed xml:id="CordyTXL06"></bibliomixed>

        <bibliomixed xml:id="Dot96"></bibliomixed>

        <bibliomixed xml:id="FeijsKrikhaarOmmering98"></bibliomixed>

        <bibliomixed xml:id="Grok"></bibliomixed>

        <bibliomixed xml:id="HedinMagnusson03"></bibliomixed>

        <bibliomixed xml:id="JacksonRollins94"></bibliomixed>

        <bibliomixed xml:id="Klint93"></bibliomixed>

        <bibliomixed xml:id="KlintIWPC03"></bibliomixed>

        <bibliomixed xml:id="KlintRscript"></bibliomixed>

        <bibliomixed xml:id="KSV-SCAM09"></bibliomixed>

        <bibliomixed xml:id="Krikhaar99"></bibliomixed>

        <bibliomixed xml:id="McCabe76"></bibliomixed>

        <bibliomixed xml:id="Semmle.QL"></bibliomixed>

        <bibliomixed xml:id="Mueller88"></bibliomixed>

        <bibliomixed xml:id="ANTLRBook"></bibliomixed>

        <bibliomixed xml:id="Tip95"></bibliomixed>

        <bibliomixed xml:id="Weiser84"></bibliomixed>
      </bibliolist></para>
  </section>

  <!--

%% \newpage
\section*{Acknowledgments}
Thanks to Tijs van der Storm for many useful discussions and experiments.
Thanks to Murat Ahat, Jan van Eijck, Taeke Kooiker, Tijs van der Storm, Ivan Vankov,
and Jurgen Vinju for comments on this tutorial.

\section*{Illustrations}

Most illustrations used in this tutorial concern physical instruments for
  measurement or observation and are taken from H. van de Stadt, \emph{Beknopt
  Leerboek der Natuurkunde} (Concise Text-book of Physics) Tjeenk Willink,
  Zwolle, 1902.
On the front page appears a windlass that amplifies manual power and is used in
water wells, drilling devices, and wind mills.
Page~\pageref{FIG:balloon}  shows a hot air balloon combined with a parachute
(circa 1900).
On page~\pageref{FIG:microscope} appears a composite microscope as proposed by
Drebbel (1621).
On page~\pageref{FIG:declinatorium} appears a \emph{declinatorium} used to
measure the difference between the magnetic and geographic north pole.
On page~\pageref{FIG:vuurtoren} the cross section is shown of a lighthouse as used along
the Dutch cost.
The spectroscope on page~\pageref{FIG:spektroskoop} is a design using four
prisms by Steinheil
and is used for the improved dispersion and analysis of the light emitted by
sodium vapor.
On page~\pageref{FIG:ruhmkorff} appears Ruhmkorff's induction-coil (1851) used
to create high-Voltage electric currents. 
Page \pageref{FIG:camera-obscura} shows a variation of the \emph{camera obscura} as
used for producing realistic drawings of a landscape.
Lassell's telescope (1863) appears on page~\pageref{FIG:teleskoop}.

 The photograph on page~\pageref{FIG:caruso} is the ``Caruso'' loudspeaker and
  appeared in an advertisement in J. Corver, \emph{Het Draadloos
  Amateurstation} (The Wireless Amateur (Radio) Station), Veenstra, 's
  Gravenhage, 1928.
The sign alphabet on page~\pageref{FIG:signalpha} has been taken from
\url{ www.inquiry.net/outdoor/skills/b-p/signaling.htm}
\bibliographystyle{plain} \bibliography{iwpc,tutorial}
-->
</chapter>
