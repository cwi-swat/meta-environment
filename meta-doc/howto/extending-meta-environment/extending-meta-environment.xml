<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY euro "&#8364;">
<!ENTITY % dbcent PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/dbcentx.mod">
%dbcent;
]>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>The Extension Points of The Meta-Environment</title>

  <info>
    <pubdate>$Rev: 20719$ by $Author: paulk$ at $2006-12-13 22:16:02 +0100
    (Wed, 13 Dec 2006)$</pubdate>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <warning>
    <para>This is work in progress; this document has not yet been reviewed
    and approved.</para>
  </warning>

  <section>
    <title>Introduction</title>

    <para>How can the The Meta-Environment be adjusted or extended? This
    document describes what the extension points of The Meta-Environment are
    and how they are used in typical applications. Each type of extension
    points may have several goals. </para>

    <section xml:id="GoalsExtensions">
      <title>Goals of Extensions</title>

      <para>Extensions may have different goals (from less to more
      ambitious):</para>

      <para><itemizedlist>
          <listitem>
            <para>Temporarily extending The Meta-Environment with user-defined
            menu options:</para>

            <itemizedlist>
              <listitem>
                <para>Constructing a prototype of an IDE for a domain specific
                language.</para>
              </listitem>

              <listitem>
                <para>Automating repetitive or otherwise cumbersome GUI
                interaction for large software analysis or transformation
                projects.</para>
              </listitem>

              <listitem>
                <para>Connecting third-party command line tools.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Permanently extending (or expanding) The Meta-Environment
            with language independent tools:</para>

            <itemizedlist>
              <listitem>
                <para>Adding version management support.</para>
              </listitem>

              <listitem>
                <para>Adding generic visualizations.</para>
              </listitem>

              <listitem>
                <para>Adding ...</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Permanently extending (or building on top of) the
            Meta-Environment with language specific tools:</para>

            <itemizedlist>
              <listitem>
                <para>Instantiating an IDE for a domain specific
                language.</para>
              </listitem>

              <listitem>
                <para>Building an extension to the SDF
                Meta-Environment.</para>
              </listitem>

              <listitem>
                <para>Building an extension to the ASF+SDF
                Meta-Environment.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist></para>

      <para>Some of these goals can be achieved by adding some configuration
      information and some scripting, others require full-fledged software
      development.</para>
    </section>

    <section xml:id="TypesExtensions">
      <title>Types of Extensions</title>

      <para>There are various types of extension points to achieve these
      goals. For some of these goals, more than one type of extension point
      should be considered. We distinguish:<itemizedlist>
          <listitem>
            <para>New (extension) packages:</para>

            <itemizedlist>
              <listitem>
                <para>Depend on other (Meta-Environment) packages.</para>
              </listitem>

              <listitem>
                <para>Use C and Java libraries and ToolBus scripts from the
                other packages.</para>
              </listitem>

              <listitem>
                <para>Are separately compilable and distributable.</para>
              </listitem>

              <listitem>
                <para>Preferably, the share the configuration, build and
                install interface of other Meta-Environment packages.</para>
              </listitem>

              <listitem>
                <para>Introduce a start-up shell script for loading the
                Meta-Environment and the new extensions.</para>
              </listitem>

              <listitem>
                <para>Contain implementations of the following extension
                points. <remark>Explain this better:
                following?</remark></para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Configuration scripts (i.e., files with the
            <literal>.actions</literal> extension):</para>

            <itemizedlist>
              <listitem>
                <para>Can add menu options to MetaStudio.</para>
              </listitem>

              <listitem>
                <para>Can load other configuration scripts.</para>
              </listitem>

              <listitem>
                <para>Can load additional ToolBus scripts.</para>
              </listitem>

              <listitem>
                <para>Can add syntactic categories for syntax
                highlighting.</para>
              </listitem>

              <listitem>
                <para>Can add workspace locations and library locations to the
                file dialog plugins of MetaStudio.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>ToolBus scripts (i.e., files with the <literal>.tb</literal>
            extension):</para>

            <itemizedlist>
              <listitem>
                <para>Can use any existing ToolBus scripts that make generic
                tools of The Meta-Environment available.</para>
              </listitem>

              <listitem>
                <para>Can connect any tool to the ToolBus.</para>
              </listitem>

              <listitem>
                <para>Can implement the behavior for new menu options.</para>
              </listitem>

              <listitem>
                <para>Can instantiate language specific, syntax highlighting,
                text editors.</para>
              </listitem>

              <listitem>
                <para>Can instantiate a language specific module manager and
                module browser.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Any new tools (optional):</para>

            <itemizedlist>
              <listitem>
                <para>Are written in languages that we provide a stable
                ToolBus adapter for (C, Java, ASF+SDF), or</para>
              </listitem>

              <listitem>
                <para>Provide their own ToolBus adapter.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>MetaStudio plugins written in Java (optional):</para>

            <itemizedlist>
              <listitem>
                <para>Can (dynamically) load new jars into the virtual machine
                of the MetaStudio GUI.</para>
              </listitem>

              <listitem>
                <para>Can add and coordinate new tabs to the collection of
                viewable windows in MetaStudio.</para>
              </listitem>

              <listitem>
                <para>Can add new menu options to MetaStudio.</para>
              </listitem>

              <listitem>
                <para>Can send events and receive evaluation requests from
                ToolBus scripts.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>TIDE adapters (optional)</para>

            <itemizedlist>
              <listitem>
                <para>Can instantiate a language specific debugger with source
                browser and stack viewer.</para>
              </listitem>

              <listitem>
                <para>Can add new visualizations to TIDE (written as
                MetaStudio plugins with a more specialized interface).</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="StepByStep">
      <title>Step-by-Step Guide</title>

      <para>Firstly, the source code for a particular extension needs to be
      organized in a new <emphasis>package</emphasis>. Secondly, this new
      package needs a <emphasis>configuration script</emphasis>. Then, we need
      new ToolBus scripts, new tools and new MetaStudio GUI plugins that
      implement the extension and coordinate its behavior with the rest of the
      system. Finally, if the extension represents an executable language, a
      debugging adapter may be included.</para>

      <para>To make the above a bit more explicit, we describe the steps that
      are needed to build an IDE for a domain specific language on top of the
      Meta-Environment:</para>

      <para><orderedlist>
          <listitem>
            <para>Create a new package with a GNU style build environment
            (<command>make</command>, <command>configure</command>,
            etc):</para>

            <itemizedlist>
              <listitem>
                <para>The package should at least depend on the
                <literal>meta</literal> package.</para>
              </listitem>

              <listitem>
                <para>The package usually also depends on the
                <literal>aterm</literal> package or the
                <literal>aterm-java</literal> package.</para>
              </listitem>

              <listitem>
                <para>Make directories for the source code new tools, ToolBus
                scripts, Configuration Files, GUI Plugins, and the
                like.</para>
              </listitem>

              <listitem>
                <para>The implementation of a single extension may be spread
                over several packages (i.e., for separating data
                representation, coordination, computation and user-interaction
                from each other).</para>
              </listitem>
            </itemizedlist>

            <para>See <link linkend="NewPackage">Adding a new
            package.</link></para>
          </listitem>

          <listitem>
            <para>Add a configuration script:</para>

            <itemizedlist>
              <listitem>
                <para>Import the standard <filename>meta.actions</filename>
                configuration script.</para>
              </listitem>

              <listitem>
                <para>Add menu options with the names of ToolBus processes to
                be executed when the button is pressed, i.e.,
                <guimenuitem>Compile program</guimenuitem>, <guimenuitem>Run
                program</guimenuitem>, etc.</para>
              </listitem>
            </itemizedlist>

            <para>See <link linkend="NewConfigurationScript">Adding a
            configuration script</link> .</para>
          </listitem>

          <listitem>
            <para>Add ToolBus scripts:</para>

            <itemizedlist>
              <listitem>
                <para>For each menu option there needs to be at least one
                ToolBus process to handle it (i.e.,
                <literal>CompileAction</literal>,
                <literal>RunAction</literal>).</para>
              </listitem>

              <listitem>
                <para>Dispatch the work to other ToolBus processes that
                already exist from the <literal>meta</literal> package (i.e.,
                <literal>ShowFileDialog</literal>)</para>
              </listitem>

              <listitem>
                <para>Or, write new ToolBus processes that call possibly new
                tools (i.e., <command>CompileDSLFile</command>).</para>
              </listitem>

              <listitem>
                <para>For each new kind of file that can be edited by the IDE,
                a ToolBus script must be added that binds a language specific
                parse-table to the file extension, and binds editor specific
                actions to editor events (file saving, editing, menu
                options).</para>
              </listitem>

              <listitem>
                <para>If you are building an IDE for a modular language, you
                should instantiate the module manager by initializing it, and
                registering module event note listeners.</para>
              </listitem>
            </itemizedlist>

            <para>See <link linkend="NewToolBusScripts">Adding ToolBus
            scripts</link> .</para>
          </listitem>

          <listitem>
            <para>Implement (or generate) new tools:</para>

            <itemizedlist>
              <listitem>
                <para>Write the tool in C, Java or ASF+SDF (i.e., a DSL
                compiler).</para>
              </listitem>

              <listitem>
                <para>Write a ToolBus process as an API for the tool.</para>
              </listitem>
            </itemizedlist>

            <para>See <link linkend="NewToolBusScripts">Adding ToolBus
            scripts</link>.</para>
          </listitem>

          <listitem>
            <para>Implement (in Java) the GUI extensions:</para>

            <itemizedlist>
              <listitem>
                <para>Implement the <literal>StudioPlugin</literal>
                interface.</para>
              </listitem>

              <listitem>
                <para>Implement several <literal>StudioComponent</literal>
                interfaces (windows).</para>
              </listitem>

              <listitem>
                <para>Write a ToolBus process for dynamically loading the jar
                into the MetaStudio.</para>
              </listitem>
            </itemizedlist>

            <para>See <link linkend="NewGuiExtensions">Adding GUI
            extensions</link>.</para>
          </listitem>

          <listitem>
            <para>Implement a small shell script for starting the ToolBus with
            the appropriate scripts.</para>

            <para>See <link linkend="NewStartUpScript">Adding a start-up
            script</link> .</para>
          </listitem>
        </orderedlist>For some extensions not all of the above steps are
      necessary. The IDE construction goal is the most demanding extension,
      while the other goals will require less effort.</para>
    </section>

    <section>
      <title>Disclaimer</title>

      <para>The Meta-Environment has many extension points, and some of them
      are still in flux. Still, this document provides an overview of the more
      stable extension points, and a brief explanation of how to use them. It
      is a first attempt at making these APIs more widely usable (meaning
      outside of the Meta-Environment development team).</para>

      <para>When this document does not provide you with enough detailed
      information, please refer to the following ToolBus scripts:<itemizedlist>
          <listitem>
            <para>meta/tbscripts/*.tb</para>
          </listitem>

          <listitem>
            <para>sdf-meta/tbscripts/*.tb</para>
          </listitem>

          <listitem>
            <para>asfsdf-meta/tbscripts/*.tb</para>
          </listitem>

          <listitem>
            <para>any .idef files as found by the following command:
            <command>find . -name "*.idef.src"</command></para>
          </listitem>
        </itemizedlist>These files implement or directly control all extension
      points of the Meta-Environment, since they control all features of The
      Meta-Environment.</para>
    </section>
  </section>

  <section xml:id="NewPackage">
    <title>Adding a new Package</title>

    <para>Extensions are to be separated from the rest of the
    Meta-Environment. This promotes configurability, maintainability,
    understandability, and independence of the extensions. All
    Meta-Environment packages have a similar package structure. For
    extensions, we advise to reuse this design. This will enable easy
    integration and deployment of your extension. For details regarding the
    build tools for Meta-Environment package see the "Build environment for
    the Meta-Environment" document. <remark>(add link)</remark></para>

    <para>Every package corresponds to a module in a version control system,
    and contains at least the following files.</para>

    <itemizedlist>
      <listitem>
        <para><link linkend="reconf">reconf</link></para>
      </listitem>

      <listitem>
        <para><link linkend="configure.ac">configure.ac</link></para>
      </listitem>

      <listitem>
        <para><filename><link
        linkend="packagename.pc.in">&lt;packagename&gt;.pc.in</link></filename></para>
      </listitem>

      <listitem>
        <para><link linkend="StandardDirectories">Standard directories</link>:
        <filename>src</filename>, <filename>lib</filename>,
        <filename>tbscripts</filename>, <filename>spec</filename>,
        <filename>utils</filename>, <filename>scripts</filename></para>
      </listitem>

      <listitem>
        <para><link linkend="Makefile.am">Makefile.am</link></para>
      </listitem>

      <listitem>
        <para><link linkend="ChangeLog">ChangeLog</link></para>
      </listitem>

      <listitem>
        <para><link linkend="StandardFiles">Standard files</link>:
        <filename>COPYING</filename>, <filename>AUTHORS</filename>,
        <filename>README</filename>, <filename>NEWS</filename></para>
      </listitem>
    </itemizedlist>

    <section xml:id="reconf">
      <title>Setting-up the Build Environment with
      <filename>reconf</filename></title>

      <para>For each new package you have to set-up the build environment.
      This is done as follows in the <filename>./reconf</filename>
      file:</para>

      <para><programlisting>#! /bin/sh

meta-build || ("Please make sure meta-build is in your PATH" &amp;&amp; false)</programlisting>This
      file bootstraps the build environment of a package. Make
      <command>reconf</command> executable and run the command
      <command>./reconf</command>, and the <command>meta-build</command>
      command runs the appropriate tools like <command>automake</command>,
      <command>libtool</command>, <command>aclocal</command>, and
      <command>autoconf</command> to set up the package's configure script and
      makefiles. These tools generate files, and create several soft links in
      the working directory for later use.</para>
    </section>

    <section xml:id="configure.ac">
      <title>Configuring the Build Environment with
      <filename>configure.ac</filename></title>

      <para>A major issue in software development is how to configure the
      software to compile and run on as many computing platforms as possible.
      Typical issues are: Where is the C compiler? Which command line options
      does it accept? How do I run the Java compiler? How do I build
      libraries? Where should the binaries or documentation be installed? And
      so on and so forth. We use an extended version of the
      <command>autoconf</command> system to achieve this. Consider the
      following example of <filename>configure.ac</filename>:</para>

      <para><programlisting>AC_INIT
META_SETUP
META_C_SETUP
META_JAVA_SETUP
AC_PROG_LIBTOOL
AC_OUTPUT</programlisting>This file is used by autoconf to generate a
      configure script. The example file here prepares the package for C and
      Java code. The C code will use dynamically linked libraries.
      <filename>Configure.ac</filename> must at least contain (in this order):
      <literal>AC_INIT</literal>, <literal>META_SETUP</literal>, and
      <literal>AC_OUTPUT</literal>. It may contain
      <literal>META_C_SETUP</literal>, or <literal>META_JAVA_SETUP</literal>,
      or both. Furthermore, any autoconf macros are allowed if your package
      needs more detailed configuration. Please read the <link
      xlink:href="http://www.gnu.org/software/autoconf/manual/autoconf-2.57/autoconf.html">autoconf
      manual</link> for details.</para>

      <para>Note that the macros with the prefix <literal>META_</literal> take
      care of inter-package dependencies, see the <link
      linkend="packagename.pc.in">&lt;packagename&gt;.pc.in</link>
      file.</para>
    </section>

    <section xml:id="packagename.pc.in">
      <title>Defining the Package with
      <filename>&lt;packagename&gt;.pc.in</filename></title>

      <para>Having set-up the build environment, it is now time to define the
      properties of the new package such as its name, version, required
      packages and the like. Here is a skeleton that also contains some
      example information:</para>

      <para><programlisting>prefix=@prefix@
Maintainers=jurgenv@cwi.nl,economop@cwi.nl
Name: &lt;packagename&gt;
Version: &lt;packageversion&gt;
Description: &lt;packagedescription&gt;
Requires: &lt;dependency1&gt;,&lt;dependency2&gt;,&lt;...&gt;
Cflags: -I${prefix}/include
Libs: -L${prefix}/lib -l&lt;libraryname1&gt; -l&lt;libraryname2&gt; &lt;...&gt;
#uninstalled Libs: -L@abs_top_builddir@/lib -l&lt;libraryname1&gt; \
 -l&lt;libraryname2&gt; &lt;...&gt;
#uninstalled Cflags: -I@abs_top_builddir@/lib 
ToolBusFlags=-I${prefix}/share/&lt;packagename&gt;
JarFile=&lt;packagename&gt;.jar
Jars=${prefix}/share/${JarFile} 
#uninstalled UninstalledJars=@abs_top_srcdir@/${JarFile}
Packages=&lt;javapackagenames&gt;
TestClass=&lt;toptestclassname&gt;</programlisting>For a package with name
      <literal>&lt;packagename&gt;</literal> the package description file has
      the name <filename>&lt;packagename&gt;.pc.in</filename> after, of
      course, replacing <literal>&lt;packagename&gt;</literal> by the actual
      name, e.g., <filename>sglr.pc.in</filename> or
      <filename>meta.pc.in</filename>. This file declares all there is to know
      about a package. This information is typically used by the
      <command>reconf</command> script, by continuous integration toolkits, by
      package managers, and other deployment and product composition
      tools.</para>

      <para>Before using the package definition file, it is instantiated by
      substituting all variables like <literal>@prefix@</literal>,
      <literal>@abs_top_builddir@</literal> by their actual,
      installation-dependent, values. The first line regarding the
      <literal>prefix</literal> variable is an obligatory implementation
      detail. The <literal>#uninstalled</literal> variables are used for
      compiling compositions of packages before they are installed (packages
      may refer to the source locations instead of the installed locations
      using this information). </para>

      <para>The <literal>Requires</literal> field is very important. It
      declares the dependencies on other packages. The package definition file
      given above supports three different programming languages (C, Java and
      ToolBus scripts). If a package contains any of these, the associated
      variables are needed, otherwise not.</para>

      <para>C packages that export libraries use <literal>Cflags</literal>,
      <literal>Libs</literal> and their uninstalled variants. This information
      is used by the makefiles of other packages. Namely, for each package
      they depend on those variables will be made available. Example: If your
      package depends on the <literal>aterm</literal> package, then you will
      have <literal>ATERM_CFLAGS</literal>, and <literal>ATERM_LIBS</literal>
      at your disposal in the makefiles.</para>

      <para>Java packages export jar files, and have a test interface. From
      this information a full <command>ant</command> build configuration is
      created. This assumes that the source code is located in the
      subdirectory <filename>src</filename>. The other variables explain where
      the jar file should be installed and which packages should be
      included.</para>

      <para>Packages containing ToolBus scripts explain where the scripts are
      installed such that dependent packages may set their search paths
      automatically.</para>

      <para>Note that the implementation of the semantics of the .pc.in file
      can be found in the package <filename>meta-build-env</filename>. This
      package contains extension to <command>automake</command> and
      <command>autoconf</command>, written as shell scripts and m4 macros.
      Understanding, writing or changing <filename>meta-build-env</filename>
      is considered to be a black art, but it does allow us to remove a lot of
      code duplication, and improve consistency, in the infra-structure of
      packages.</para>
    </section>

    <section xml:id="StandardDirectories">
      <title>Standard Directories: src, lib, tbscripts, spec, utils,
      scripts</title>

      <para>The following naming conventions are used for source code
      subdirectories:</para>

      <itemizedlist>
        <listitem>
          <para><filename>src</filename> contains Java source code
          packages.</para>
        </listitem>

        <listitem>
          <para><filename>lib</filename> contains source code for C
          libraries.</para>
        </listitem>

        <listitem>
          <para><filename>tbscript</filename> contains ToolBus scripts.</para>
        </listitem>

        <listitem>
          <para><filename>spec</filename> contains ASF+SDF
          specifications.</para>
        </listitem>

        <listitem>
          <para><filename>utils</filename> contains C programs with a main
          that link the libraries in lib.</para>
        </listitem>

        <listitem>
          <para><filename>scripts</filename> contain shell scripts.</para>
        </listitem>
      </itemizedlist>

      <para>Each of these directories, except for <filename>src</filename>,
      has a <filename>Makefile.am</filename> file. Most (but not all)
      Meta-Environment packages follow this convention.</para>
    </section>

    <section xml:id="Makefile.am">
      <title>Defining the Build Process with Makefile.am</title>

      <para>Now we have reached the level of actual source files and their
      build instructions. We use automatically generated
      <filename>Makefile</filename>s that have been tailored with
      installation-dependent information. The recipe for generating each
      <filename>Makefile</filename> is given in an
      <filename>Makefile.am</filename> file. The suffix <literal>.am</literal>
      refers to the tool <command>automake</command> that is used to do the
      actual <filename>Makefile</filename> generation. The entire tool chain
      of <command>automake</command>, <command>autoconf</command>,
      <command>aclocal</command>, <command>configure</command>, etc. starts
      with the <filename>Makefile.am</filename> file. Here is an
      example:</para>

      <para><programlisting>include $(top_srcdir)/Makefile.top.meta

SUBDIRS = &lt;subdirs&gt;

ACLOCAL_AMFLAGS = -I .</programlisting>Makefiles are notoriously sensitive to
      spaces. For instance, the exact number of spaces as given on the line
      <literal>ACLOCAL_AMFLAGS</literal> should be used (this is also due to
      tools such as <command>autoreconf</command> that scan the contents of
      Makefile.am files using rather brittle regular expressions).</para>

      <para>The example above is relevant the top level directory of each
      package. For C packages and ToolBus packages there are additional
      <filename>Makefile.am</filename> files. For these kinds of packages,
      each subdirectory should contain its own
      <filename>Makefile.am</filename>. Please read the automake manual on how
      to write <filename>Makefile.am</filename> files for compiling C
      libraries and C programs. Each <filename>Makefile.am</filename> may
      include <filename>Makefile.meta</filename>, such that make rules and
      other utilities become available and can be reused. You are advised to
      look at the <filename>Makefile.am</filename> files of existing packages
      for inspiration. Inclusion of the <filename>Makefile.meta</filename>
      file is not obligatory however. <remark>What do we illustrate with the
      following:</remark><programlisting>include $(top_srcdir)/Makefile.meta</programlisting></para>

      <para>There is an exception, in case of a Java package. The
      <emphasis>toplevel</emphasis> Makefile.am should look like
      this:<programlisting>include $(top_srcdir)/Makefile.java.meta

ACLOCAL_AMFLAGS = -I .</programlisting></para>

      <para>Java packages should have all their code in a subdirectory called
      <filename>src</filename>. This subdirectory may contain packages, but
      the corresponding directories do not need copies of a Makefile.am file.
      Note that by including <filename>Makefile.java.meta</filename> the
      package will use <command>ant</command> to compile your source code
      using the information from
      <filename>&lt;package&gt;.pc.in.</filename></para>
    </section>

    <section xml:id="ChangeLog">
      <title>Maintaining Change Information in
      <filename>ChangeLog</filename></title>

      <para>It helps other developers to describe the changes you have made to
      source files. The file <filename>ChangeLog</filename> is the place for
      collecting this information. Usually, it contains verbatim copies of the
      entries in the version management system. Here is an example:</para>

      <para><programlisting>Fri Jun 30 21:43:04 CEST 2006 &lt;jurgenv@cwi.nl&gt;
 * libmept/MEPT-utils.[ch]: reorganized this long file into a number 
   of smaller files that each deal with a specific topic.
 * libmept/*.c: added much documentation.
 * libmept/*.h: fixed bug #774
 * pt-support.pc.in: Bumped version to 0.1231</programlisting><filename>ChangeLog</filename>
      contains remarks on all changes to the source code of a package, in
      reverse order of date. Maintaining this information in this file makes
      it independent of a version management system. It should contain
      references to bug numbers when bugs are fixed. The
      <filename>ChangeLog</filename> file has a fixed format. Editors such as
      <command>gvim</command> and <command>emacs</command> have plugins for
      its syntax. <filename>ChangeLog</filename> files are maintained very
      well in Meta-Environment packages.</para>
    </section>

    <section xml:id="StandardFiles">
      <title>Adding Standard Files: <filename>COPYING</filename>,
      <filename>AUTHORS</filename>, <filename>README</filename>,
      <filename>NEWS</filename></title>

      <para>The <filename>COPYING</filename> file contains the license for the
      source code located in this package. This is usually the LGPL license
      for Meta-Environment packages. The <filename>AUTHORS</filename> file
      lists the authors email addresses. The <filename>README</filename> file
      should contain a brief description of the package. The
      <filename>NEWS</filename> file should list remarks on the evolution of
      the package on a high level of abstraction. Note that
      <filename>README</filename> and <filename>NEWS</filename> files are
      usually not maintained too well in Meta-Environment packages.</para>
    </section>
  </section>

  <section xml:id="NewConfigurationScript">
    <title>Adding a Configuration Script</title>

    <para>Each instance of a Meta-Environment IDE has one toplevel
    configuration script. This script may import other scripts. At startup
    time, the configuration script is used to initialize the ToolBus with the
    right scripts, then after the ToolBus is started, the same script is used
    to initialize the configuration manager tool. At run-time this tool
    provides tools and scripts with configuration information
    on-demand.</para>

    <para>This is the syntax of a configuration file, as found in
    <filename>sdf-library/library/basic/Configuration.sdf</filename>. Note
    that currently the set of configuration options is fixed. Obviously, for
    real extensibility, this set needs to be opened. For now, this is what is
    offered to configure the existing generic components of The
    Meta-Environment.</para>

    <para><programlisting>sorts Configuration
context-free syntax
  "configuration" "(" "[" list:{Property ","}* "]" ")" 
                             -&gt; Configuration {cons("configuration")} 

sorts Property
context-free syntax
  %% imports another configuration file:
  "import" "(" path:StrCon ")"           -&gt; Property {cons("import")}

  %% loads another ToolBus script into the ToolBus:
  "load-script" "(" path:StrCon ")"      -&gt; Property {cons("script")}

  %% extends the script path of the ToolBus:
  "script-path" "(" path:StrCon ")" -&gt; Property {cons("script-path")}

  %% Registers an action with the selection of a certain 
  %%user-interface element:
  "action" "(" "[" list:{ActionDescription ","}* "]" "," 
                       action:StrCon ")" -&gt; Property {cons("action")}

  %% Couples a language name (SDF module name), 
  %% with a file extension for use in file browsers:
  "extension" "(" language:StrCon "," extension:StrCon ")" 
                                      -&gt; Property {cons("extension")}

  %% Extends the list of workspaces with a new path:
  "library-path" "(" label:StrCon "," path:StrCon ")" 
                                    -&gt; Property {cons("library-path")}

  %% Extends the list of workspaces with a new path, 
  %% takes precedence over library paths when searching:
  "module-path" "(" label:StrCon "," path:StrCon ")" 
                                     -&gt; Property {cons("module-path")}

  %% Registers the font properties of a certain text category name, 
  %% for use with syntax highlighting: 
  "text-category" "(" category:TextCategoryName ","
        "[" map:{TextAttribute ","}* "]" ")" 
                                   -&gt; Property {cons("text-category")}

sorts ActionDescription
context-free syntax
  %% describes a GUI element. The context is the name of the element,
  %% the event is may happen to it.
  "description" "(" context:TermCon "," event:Event ")" 
                            -&gt; ActionDescription {cons("description")}

sorts Event
context-free syntax
  %% here is a list of things that may happen to a GUI element, 
  %% these are used for construction of the
  %% GUI, as well as identifying which process is called finally:
  "popup"                                     -&gt; Event {cons("popup")}
  "click" "(" "[" list:{KeyModifier ","}* "]" "," 
      button:VirtualButton ")"                -&gt; Event {cons("click")}

  "icon" "(" title:StrCon "," path:StrCon ")"  -&gt; Event {cons("icon")}
  "menu" "(" "[" labels:{Item ","}* "]" ")"    -&gt; Event {cons("menu")}
  "menu-shortcut" "(" "[" labels:{Item ","}* "]" "," 
     shortcut:ShortCut ")"            -&gt; Event {cons("menu-shortcut")}

sorts Item
context-free syntax
  %% describe paths in menu's:
  "label" "(" name:StrCon ")" -&gt; Item {cons("label")}

sorts TextCategoryName
context-free syntax
  %% There are three built-int text categories, 
  %% and we can add our own:
  "focus"                      -&gt; TextCategoryName {cons("focus")}
  "selection"                  -&gt; TextCategoryName {cons("selection")}
  "normal"                     -&gt; TextCategoryName {cons("normal")}
  "extern" "(" name:StrCon ")" -&gt; TextCategoryName {cons("extern")}

sorts TextAttribute
context-free syntax
  "foreground-color" "(" color:Color ")" 
                           -&gt; TextAttribute {cons("foreground-color")}
  "background-color" "(" color:Color ")" 
                           -&gt; TextAttribute {cons("background-color")}
  "style" "(" style:TextStyle ")"     -&gt; TextAttribute {cons("style")}
  "font" "(" name:StrCon ")"           -&gt; TextAttribute {cons("font")}
  "size" "(" point:NatCon ")"          -&gt; TextAttribute {cons("size")}

sorts ShortCut
context-free syntax
  %% The shortcut syntax is based on the Java virtual key interface
  "shortcut" "(" "[" list:{KeyModifier ","}* "]" "," 
     key:VirtualKey ")"                 -&gt; ShortCut {cons("shortcut")}

sorts TextStyle
context-free syntax
  "bold"       -&gt; TextStyle {cons("bold")}
  "italics"    -&gt; TextStyle {cons("italics")}
  "underlined" -&gt; TextStyle {cons("underlined")}</programlisting> Here is a
    part of an example configuration file called
    <filename>standard.sdf.actions</filename>:</para>

    <programlisting>configuration([
  import("__META__/share/meta/meta.actions"),
  script-path("__SDFMETA__/share/sdf-meta"),
  load-script("__SDFMETA__/share/sdf-meta/init-sdf.tb"),
  library-path("SDF Grammar Library","__SDF_LIBRARY__"),
  library-path("ASF+SDF Library","__ASF_LIBRARY__"),
  action([description(tree-panel, click)], "ShowAreaAction"),
  action([
    description(
      studio-menubar, 
      menu([label("File"), label("Exit")]))], 
      "ExitAction"),
  action([
    description(
      studio-menubar, 
      menu-shortcut([label("Module"), label("New...")], 
                    shortcut([M_ALT,M_SHIFT],VK_N))),
    description(
      studio-toolbar, 
      icon("New Module", "New24.gif"))], 
      "NewModuleAction"),
  action([
    description(
      term-editor, 
      menu-shortcut([label("Term"),label("Add Brackets")], 
                    shortcut([M_ALT,M_CTRL],VK_B)))], 
      "AddBracketsAction"),
  action([
    description(
      syntax-editor, 
      menu-shortcut([label("Module"), label("Edit"), label("Term")],
                    shortcut([M_CTRL,M_SHIFT],VK_T)))], 
      "EditorEditTermAction"),
  action([description(syntax-editor, popup)], "EditorPopup"),
  action([description(equations-editor, popup)], "EditorPopup"),
  action([description(term-editor, popup)], "EditorPopup"),

  action([
    description(
      module-popup, 
      menu([label("Close...")]))], 
    "CloseModuleAction"),

  text-category(normal,[foreground-color(rgb(0,0,0)), 
                        background-color(rgb(255,255,255)), 
                        font("Monospaced"), 
                        size(14)]),
  text-category(focus,    [foreground-color(rgb(0,0,0)),
                           background-color(rgb(255,250,148))]),
  text-category(selection,[foreground-color(rgb(255,255,255)),
                           background-color(rgb(65,101,172))]),
  text-category(extern("MetaKeyword"),
                [style(bold),foreground-color(rgb(123,0,82))]),
  text-category(extern("MetaVariable"),
                [style(italics),foreground-color(rgb(0,0,255))]),
  text-category(extern("MetaAmbiguity"),
                [style(bold),foreground-color(rgb(186,29,29))]),
  text-category(extern("Todo"),
                [style(bold),background-color(rgb(255,255,255)),
                 foreground-color(rgb(123,157,198))]),
  text-category(extern("Comment"),
                [style(italics),foreground-color(rgb(82,141,115))]),
  text-category(extern("Constant"),
                [style(italics),foreground-color(rgb(139,0,139))]),
  text-category(extern("Variable"),
                [foreground-color(rgb(144,238,144))]),
  text-category(extern("Identifier"),
                [foreground-color(rgb(255,69,0))]),
  text-category(extern("Type"),
                [foreground-color(rgb(255,127,36))]),
  text-category(extern("Error"),
                [style(bold),foreground-color(rgb(255,0,0))]),
  text-category(extern("Warning"),
                [style(bold),foreground-color(rgb(0,0,255))]),
  text-category(extern("Info"),
                [style(bold),foreground-color(rgb(0,255,0))]),
  text-category(extern("Fatal"),
                [style(bold),background-color(rgb(255,0,0))])
])</programlisting>

    <para>Note that the configuration file contains names of ToolBus processes
    like <literal>ShowAreaAction</literal>, <literal>ExitAction</literal>, and
    others. These are described <link
    linkend="StandardToolBusActions">below</link>.</para>

    <para>Once a configuration file is constructed it will be used by the
    <link linkend="NewStartUpScript">start-up script</link>, and by an <link
    linkend="NewToolBusScripts">initial ToolBus process</link> .</para>
  </section>

  <section xml:id="NewToolBusScripts">
    <title>Adding new ToolBus Scripts</title>

    <itemizedlist>
      <listitem>
        <para>relation between configuration scripts and ToolBus scripts (menu
        calls processes)</para>
      </listitem>

      <listitem>
        <para>explain all available processes from meta package, and
        rec-msgs</para>
      </listitem>

      <listitem>
        <para>explain coding conventions for ToolBus scripts (small
        scripts)</para>
      </listitem>

      <listitem>
        <para>explain instantiation of language specific editors (connecting
        parser/parsetable)</para>
      </listitem>

      <listitem>
        <para>explain connection between text-categories in configuration
        script, and syntax highlighter</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>The relation between configuration scripts and ToolBus
      scripts</title>

      <para>Recall that the configuration manager provides a ToolBus API for
      the configuration parameters that have been loaded from the
      configuration scripts. This information is used by a number of generic
      tools in the Meta-Environment:</para>

      <itemizedlist>
        <listitem>
          <para>MetaStudio: uses it to construct the menu bar and all of its
          contents.</para>
        </listitem>

        <listitem>
          <para>editor-plugin: uses it to construct editor specific additions
          to the menubar in MetaStudio, and for (language specific) popup
          menus in the editors, and for selecting font properties for syntax
          highlighting.</para>
        </listitem>

        <listitem>
          <para>navigator-gui: uses it to construct navigator specific
          additions to the menubar in MetaStudio, and for popup menus on the
          navigator tree.</para>
        </listitem>

        <listitem>
          <para>graph-gui: uses it to construct graph display specific
          additions to the menubar in MetaStudio, and for popup menus on graph
          nodes.</para>
        </listitem>

        <listitem>
          <para>error-gui: registers listeners for clicking on errors.</para>
        </listitem>

        <listitem>
          <para>... in principle, this list is extensible with any tool
          interested in configuration information.</para>
        </listitem>
      </itemizedlist>

      <para>Let's focus on 'action' configuration parameters. Each action
      identifies for which component it is relevent, which menu option or
      other user-interface component it should be associated with, and which
      ToolBus process should be called when the action is activated (see <link
      linkend="NewConfigurationScript">configuration scripts</link>).</para>

      <para>The above named tools use the configuration information to build
      up menu's and register listeners to GUI events. They translate the
      events to ToolBus events, and then <emphasis>inside the ToolBus
      script</emphasis> such an event is used to call the specific ToolBus
      process. Each component may pass different parameters to the configured
      process name. </para>

      <para>For example, the editor-plugin provides an
      <varname>EditorId</varname>. Suppose there is a menu option called
      CompileDSL configured for a certain editor:</para>

      <programlisting>action([
    description(
      term-editor, 
      menu-shortcut([label("DSL"),label("Compile")], 
                    shortcut([M_ALT,M_CTRL],VK_C)))], 
      "CompileDSL"),</programlisting>

      <para>Which means that the process CompileDSL will be called when
      somebody clicks DSL-&gt;Compile, or types ALT+CTRL+C. Then, we need to
      implement the following ToolBus script:</para>

      <programlisting>process CompileDSL(EditorId : term) is
let
  ...
in
  ...
endlet</programlisting>

      <para>The EditorId term can be used to look up information about the
      editor, such as filename (see <link linkend="StandardToolBusActions">the
      standard ToolBus actions</link> ).</para>

      <para>These are currently the ways processes are called from each
      component:</para>

      <table>
        <title>Process call interface per configured component</title>

        <tgroup cols="4">
          <tbody>
            <row>
              <entry><emphasis role="bold">Component name</emphasis></entry>

              <entry><emphasis role="bold">Process definition (first
              alternative)</emphasis></entry>

              <entry><emphasis role="bold">Process definition (second
              alternative)</emphasis></entry>

              <entry><emphasis role="bold">Reference to source
              code</emphasis></entry>
            </row>

            <row>
              <entry>MetaStudio</entry>

              <entry>process &lt;name&gt; is ...</entry>

              <entry> </entry>

              <entry>meta/tbscripts/gui-utils.tb</entry>
            </row>

            <row>
              <entry>editor-plugin</entry>

              <entry>process &lt;name&gt;(EditorId : term) is ...</entry>

              <entry>process &lt;name&gt;(EditorId : term, EditorType: term,
              Sort : str)</entry>

              <entry>meta/tbscripts/editing.tb</entry>
            </row>

            <row>
              <entry>navigator-gui</entry>

              <entry>process &lt;name&gt;(ModuleId : term) is ...</entry>

              <entry> </entry>

              <entry>sdf-meta/tbscripts/sdf-module-actions.tb</entry>
            </row>

            <row>
              <entry>error-gui</entry>

              <entry>process &lt;name&gt;(Location : term) is ...</entry>

              <entry> </entry>

              <entry>meta/tbscripts/gui-utils.tb</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The above information is enough for anybody implementing actions
      for existing components.</para>

      <para>When you implement a completely new component, you should
      instantiate a connection between defined actions in a configuration
      script, and the way a ToolBus process is called. The basic design
      pattern for this is as follows. We provide it here because the
      referenced source code is more complex. The real source code introduces
      one more layer of abstraction, by not letting a tool interface
      communicate directly with the configuration manager. This is also
      advised for any new components you develop, but we have left this out in
      the following example for clarity:</para>

      <programlisting>tool exampleTool is { ... }
process ExampleToolInterface is
let 
  T : exampleTool,
  Id: term,
  Event : term,
  Events : list,
  Action : str
in
  rec-connect(T?)                                                               /* a tool initiates a connection, for example a MetaStudio plugin */
  . snd-msg(cm-get-events(example-tool-identifier))                             /* retrieve the appropriate menus from the configuration manager, */
  . rec-msg(cm-events(Events?))                                                 /* the 'example-tool-identifier' will occur in configuration scripts! */
  . snd-do(T, register-events(Events))                                          /* Use the menus to initialize the tool, the tool should store the Events information somewhere */
  .
  (                                                                             /* After initialization, the tool goes into a processing loop */
    rec-event(T, event(Event?))                                                 /* An event is send back by the tool, (this is one of elements of the original Events list) */
    . snd-msg(cm-get-action(example-tool-identifier, Event))                    /* Lookup the related process name from the configuration manager */
    . rec-msg(cm-action(Action?))
    .
    (
      printf("Warning: process not found: %s\n", Action)
    +&gt;
      Action()                                                                  /* The process is called dynamically, if it is not found, the printf above is executed */
    )
  +
    ...                                                                         /* The process will have rec-msg's and snd-do's for implementing the rest of the tool API */
  )*
  rec-disconnect(T) /* This process terminates when the tool disconnects */
endlet</programlisting>

      <para>The above skeleton can be extended by calling
      <varname>Action</varname> with different parameters, by adding more
      kinds of events, by adding different 'example-tool-identifiers' in the
      same tool, etc. Of course, any tool interface will probably have more
      snd-do's and snd-evals than is shown in the above skeleton.</para>
    </section>

    <section xml:id="StandardToolBusActions">
      <title>The standard ToolBus Actions</title>

      <para>The ToolBus scripts that implement The Meta-Environment already
      provide a wealth of functionality that you can reuse in configuration
      scripts. This functionality is separated in three layers: meta, sdf-meta
      and asfsdf-meta. The meta layer contains only language independent
      processes. The sdf-meta layer introduces SDF specific scripts. The
      asfsdf-meta layer introduces ASF specific scripts. Note that the
      sdf-meta layer depends on the meta layer, and the asfsdf-meta layer
      depends on the sdf-meta layer. To load them use any or all of the
      following include statements:</para>

      <programlisting>#include &lt;meta.tb&gt;
#include &lt;sdf-meta.tb&gt;
#include &lt;asfsdf-meta.tb&gt;</programlisting>

      <para>Including these files makes a number of things readily
      available:<itemizedlist>
          <listitem>
            <para><emphasis>tools</emphasis> (such as in-output) with an
            interface that can be accessed via snd-msg/rec-msg.</para>

            <para>These interfaces are found in files that have the
            <filename>.idef</filename> extension.</para>
          </listitem>

          <listitem>
            <para><emphasis>processes</emphasis> that translate the
            snd-msg/rec-msg interface of selected tools to process definitions
            for your convenience.</para>

            <para>These interfaces are found in files that have the
            <filename>.tb</filename> extension.</para>
          </listitem>

          <listitem>
            <para><emphasis>aggregrated processes</emphasis> that implement
            specific reusable scenarios using the above two interfaces.</para>

            <para>These interfaces are found in files that end with
            <filename>-utils.tb</filename>.</para>
          </listitem>

          <listitem>
            <para><emphasis>specific processes</emphasis> that are already
            tied to specific menu's or user actions.</para>

            <para>These processes are found in files that end with
            <filename>-actions.tb</filename>.</para>
          </listitem>
        </itemizedlist>So, for implementing a certain Action, you should start
      looking for functionality in -utils.tb files, if not found you should
      fall back to .tb files, if still not found, there is a chance of finding
      things in the .idef files of specific tools. Note that the -actions.tb
      files are usually too specific for reuse, but in some very simple cases
      they may come in handy.<table xml:id="Table.StandardToolBusActions">
          <title>Standard ToolBus actions available for configuration
          scripts.</title>

          <tgroup cols="3">
            <tbody>
              <row>
                <entry><emphasis role="bold">Layer</emphasis></entry>

                <entry><emphasis role="bold">Action</emphasis></entry>

                <entry><emphasis role="bold">Purpose</emphasis></entry>
              </row>

              <row>
                <entry>meta</entry>

                <entry>ActionAddPosInfo(EditorId : term, Tree : term,
                ResultTree : term?)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ActionEvent(EditorId: term, ActionEvent: term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>AddBracketsAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>AddImportAction(Modulename: str)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>AsfSdfApiGenAction(ModuleId: term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ChangeWorkspaceAction</entry>

                <entry></entry>
              </row>

              <row>
                <entry>CloseAllAction</entry>

                <entry></entry>
              </row>

              <row>
                <entry>CloseModuleAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>CompileModuleAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>CopyModuleAction(Modulename : str)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>DebugReduceAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>DebugRunAsfTestsAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>DefaultAction(Arg:term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>DeleteModuleAction(Modulename : str)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>DumpEquationsAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>DumpEquationsParseTableAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>DumpParseTableAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>DumpSdfDefinitionAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>EditEquationsAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>EditSyntaxAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>EditTermAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>EditorDumpEquationsParseTableAction(EditorId :
                term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>EditorDumpParseTableAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>EditorEditEquationsAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>EditorEditSyntaxAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>EditorEditTermAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>EditorRunAsfTestsAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ExitAction</entry>

                <entry></entry>
              </row>

              <row>
                <entry>MoveCursorDownAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>MoveCursorLeftAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>MoveCursorRightAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>MoveCursorUpAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>NewModuleAction</entry>

                <entry></entry>
              </row>

              <row>
                <entry>OpenModuleAction</entry>

                <entry></entry>
              </row>

              <row>
                <entry>PrettyPrintAction(EditorId : term, EditorType : term,
                Sort: str)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>PrintModuleAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ReduceAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>RemoveImportAction(Modulename: str)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>RenameModuleAction(Modulename : str)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>RunAsfTestsAction(ModuleId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>SetEditActions(Sid: term, Type: term, Name:
                str)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ShowAreaAction(Message : str, Location : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ShowFullTreeAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ShowFullTreeWithoutLayoutAction(EditorId :
                term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ShowOriginAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ShowSharedTreeAction(EditorId : term)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>ShowTreeAction(EditorId : term)</entry>

                <entry></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>
  </section>

  <section xml:id="NewTools">
    <title>Implementing new Tools</title>

    <itemizedlist>
      <listitem>
        <para>refer to ToolBus manuals, and ATerm manuals</para>
      </listitem>

      <listitem>
        <para>refer to -t flag of asfc compiler</para>
      </listitem>

      <listitem>
        <para>refer to generic adapter (does it still work?)</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="NewGuiExtensions">
    <title>Implementing GUI Extensions</title>

    <para>Explain the StudioPlugin interface, and the StudioComponent
    interface.</para>

    <itemizedlist>
      <listitem>
        <para>How to implement the StudioPlugin interface</para>
      </listitem>

      <listitem>
        <para>How to implement the StudioComponent interface</para>
      </listitem>

      <listitem>
        <para>How to load the jarfile into the MetaStudio</para>
      </listitem>

      <listitem>
        <para>How to add menu options via the MetaStudio interface</para>
      </listitem>

      <listitem>
        <para>How to load StudioComponents at certain tab positions using the
        MetaStudio interface</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="NewStartUpScript">
    <title>Implementing a Start-up Shell Script</title>

    <para>The startup shell script of a Meta-Environment based IDE looks like
    this:</para>

    <programlisting>#! /bin/sh

__TOOLBUS__/bin/toolbus \
  `__CONFIG_MANAGER__/bin/configmanager -I -i __PACKAGEPREFIX__/share/&lt;configfile&gt;.actions` \
  `__CONFIG_MANAGER__/bin/configmanager -s -i __PACKAGEPREFIX__/share/&lt;configfile&gt;.actions`</programlisting>

    <para>This script needs to be instantiated with the correct paths at
    installation time. Use a <filename>Makefile.am</filename> rule for this
    for example. The script simply starts the ToolBus and uses the
    <command>configmanager</command> tool (wrapped in backquotes for inline
    substitution) to generate the necessary command line options to the
    ToolBus. The following is the usage information from this command line
    tool:</para>

    <para><programlisting>usage: configmanager -[Is] -i &lt;config-file&gt;
        -I print ToolBus include path
        -s print ToolBus main scripts
        -i input configuration file [multiple]</programlisting>See the ToolBus
    manual and ToolBus usage information for more information on ToolBus
    command line parameters.</para>
  </section>
</article>