<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY euro "&#8364;">
<!ENTITY % dbcent PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/dbcentx.mod">
%dbcent;
]>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>The extension points of The Meta-Environment</title>

  <info>
    <pubdate>$Rev: 20719$ by $Author: paulk$ at $2006-12-13 22:16:02 +0100
    (Wed, 13 Dec 2006)$</pubdate>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <warning>
    <para>This is work in progress; this document has not yet been reviewed
    and approved.</para>
  </warning>

  <section>
    <title>Introduction</title>

    <para>This document describes what the extension points of The
    Meta-Environment are, and how they are used by prototypical extensions.
    The Meta-Environment has several types of extension points. Each type of
    extension points may have several goals.</para>

    <section>
      <title>Goals of extensions</title>

      <para>The goals of extending it are for example:</para>

      <para><itemizedlist>
          <listitem>
            <para>Permanently extending (or building on top of) the
            Meta-Environment with language specific tools:</para>

            <itemizedlist>
              <listitem>
                <para>Instantiating an IDE for any domain specific
                language</para>
              </listitem>

              <listitem>
                <para>Building an extension to the SDF Meta-Environment</para>
              </listitem>

              <listitem>
                <para>Building an extension to the ASF+SDF
                Meta-Environment</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Permanently extending (or expanding) The Meta-Environment
            with language independent tools:</para>

            <itemizedlist>
              <listitem>
                <para>Adding version management support</para>
              </listitem>

              <listitem>
                <para>Adding generic vizualizations</para>
              </listitem>

              <listitem>
                <para>Adding ...</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Temporarily extending The Meta-Environment with user-defined
            menu options:</para>

            <itemizedlist>
              <listitem>
                <para>Constructing a prototype of an IDE for a domain specific
                language.</para>
              </listitem>

              <listitem>
                <para>Automating repetitive or otherwise cumbersome GUI
                interaction for large software analysis or transformation
                projects.</para>
              </listitem>

              <listitem>
                <para>Connecting third-party commandline tools.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Types of extensions</title>

      <para>The types of extension points to fulfill these goals are listed in
      this section. For some extension goals, several of the extension points
      should be considered. Firstly, the source code for a particular
      extension needs to be organized in a new <emphasis>package</emphasis>.
      Secondly, this new package needs a <emphasis>configuration
      script</emphasis>. Then, we need new ToolBus scripts, new tools and new
      MetaStudio GUI plugins that implement the extension and coordinate its
      behavior with the rest of the system. Finally, if the extension
      represents an executable language, a debugging adapter may be included.
      <itemizedlist>
          <listitem>
            <para>Package infra-structure. An extension package:</para>

            <itemizedlist>
              <listitem>
                <para>Depends on other (Meta-Environment) packages</para>
              </listitem>

              <listitem>
                <para>Uses C and Java libraries and ToolBus scripts from the
                other packages</para>
              </listitem>

              <listitem>
                <para>Is separately compilable and distributable</para>
              </listitem>

              <listitem>
                <para>Preferably, but not necessarily, shares the
                configuration, build and install interface of other
                Meta-Environment packages</para>
              </listitem>

              <listitem>
                <para>Introduces a start-up shell script for loading the
                Meta-Environment and the new extensions</para>
              </listitem>

              <listitem>
                <para>Contains implementations of the following extension
                points</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Configuration scripts (i.e. ".actions" files)</para>

            <itemizedlist>
              <listitem>
                <para>Can add menu options to the MetaStudio</para>
              </listitem>

              <listitem>
                <para>Can load other configuration scripts</para>
              </listitem>

              <listitem>
                <para>Can load additional ToolBus scripts</para>
              </listitem>

              <listitem>
                <para>Can add syntactic categories for syntax
                highlighting</para>
              </listitem>

              <listitem>
                <para>Can add workspace locations and library locations to the
                file dialog plugins</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>ToolBus scripts (.tb) files</para>

            <itemizedlist>
              <listitem>
                <para>Can use any existing ToolBus scripts that make generic
                tools of The Meta-Environment available.</para>
              </listitem>

              <listitem>
                <para>Can connect any tool to the ToolBus</para>
              </listitem>

              <listitem>
                <para>Can implement the behavior for new menu options</para>
              </listitem>

              <listitem>
                <para>Can instantiate language specific, syntax highlighting,
                text editors.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Any tools (optional)</para>

            <itemizedlist>
              <listitem>
                <para>Written in languages that we provide a stable ToolBus
                adapter for (C, Java, ASF+SDF)</para>
              </listitem>

              <listitem>
                <para>Having their own ToolBus adapter included</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>MetaStudio plugins written in Java (optional):</para>

            <itemizedlist>
              <listitem>
                <para>Can (dynamically) load new jars into the virtual machine
                of the MetaStudio GUI</para>
              </listitem>

              <listitem>
                <para>Can add and coordinate new tabs to the collection of
                viewable windows in the MetaStudio.</para>
              </listitem>

              <listitem>
                <para>Can add new menu options to the MetaStudio</para>
              </listitem>

              <listitem>
                <para>Can send events and receive evaluation requests from
                ToolBus scripts</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>TIDE adapters (optional)</para>

            <itemizedlist>
              <listitem>
                <para>Can instantiate a language specific debugger with source
                browser and stack viewer.</para>
              </listitem>

              <listitem>
                <para>Can add new visualizations to TIDE (written as
                MetaStudio plugins with a more specialized interface).</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Step-by-step example (high level of abstraction)</title>

      <para>To make the above a bit more concrete we give an example. When we
      build an IDE for a domain specific language on top of the
      Meta-Environment, we will execute the following tasks:<orderedlist>
          <listitem>
            <para>Create a new package with a GNU style build environment
            (make, configure, etc)</para>

            <itemizedlist>
              <listitem>
                <para>The package at least depends on the 'meta'
                package.</para>
              </listitem>

              <listitem>
                <para>The package usually also depends on the 'aterm' package
                or the 'aterm-java' package.</para>
              </listitem>

              <listitem>
                <para>Make directories for the source code new tools, ToolBus
                scripts, Configuration Files, GUI Plugins</para>
              </listitem>

              <listitem>
                <para>A single extension may be spread over several packages
                (i.e. for separating data representation, coordination,
                computation and user-interaction from each other)</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Add a configuration script</para>

            <itemizedlist>
              <listitem>
                <para>Import the standard meta.actions configuration
                script</para>
              </listitem>

              <listitem>
                <para>Add menu options with the names of ToolBus processes to
                be executed when the button is pressed. I.e. Compile program.,
                Run program., etc.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Add ToolBus scripts</para>

            <itemizedlist>
              <listitem>
                <para>For each menu option there needs to be at least one
                ToolBus process to handle it (i.e. CompileAction,
                RunAction).</para>
              </listitem>

              <listitem>
                <para>Dispatch the work to other ToolBus processes that
                already exist from the 'meta' package (i.e.
                ShowFileDialog)</para>
              </listitem>

              <listitem>
                <para>Or, write new ToolBus processes that call possibly new
                tools (i.e. CompileDSLFile)</para>
              </listitem>

              <listitem>
                <para>For each new kind of file that can be edited by the IDE,
                a ToolBus script must be added that binds a language specific
                parse-table to the file extension, and binds editor specific
                actions to editor events (file saving, editing, menu
                options).</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Implement (or generate) new tools</para>

            <itemizedlist>
              <listitem>
                <para>Write the tool in C, Java or ASF+SDF (i.e. a DSL
                compiler)</para>
              </listitem>

              <listitem>
                <para>Write a ToolBus process as an API for the tool</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Implement (in Java) the GUI extensions</para>

            <itemizedlist>
              <listitem>
                <para>Implement the StudioPlugin interface</para>
              </listitem>

              <listitem>
                <para>Implement several StudioComponent interfaces
                (windows)</para>
              </listitem>

              <listitem>
                <para>Write a ToolBus process for dynamically loading the jar
                into the MetaStudio</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Implement a small shell script for starting the ToolBus with
            the apropriate scripts</para>
          </listitem>
        </orderedlist>For some extensions not all of the above steps are
      necessary. The IDE construction goal is the most demanding extension,
      while the other goals will be less of an effort. The rest of this
      document highlights each extension point and how to use it in more
      detail.</para>
    </section>
  </section>

  <section>
    <title>Creating a new package</title>

    <para>Extensions are to be separated from the rest of the
    Meta-Environment. This promotes quality aspects like configurability,
    maintainability, understandability, and independence. All Meta-Environment
    packages have a similar package structure. For extensions, we advise to
    reuse this design. This will improve easy integration and deployment of
    your extension. For details regarding the build tools for Meta-Environment
    package see the "Build environment for the Meta-Environment"
    document.</para>

    <para>Every package corresponds to a module in a version control system,
    and contains at least the following files. For each file we explain what
    it is, and what should be at least in it.</para>

    <section>
      <title>reconf</title>

      <para><programlisting>#! /bin/sh

meta-build || ("Please make sure meta-build is in your PATH" &amp;&amp; false)</programlisting>This
      file bootstraps the build environment of a package. The use runs
      <command>./reconf</command>, and the <command>meta-build</command>
      command runs the appropriate tools like automake, libtool, aclocal, and
      autoconf to set up the package's configure script and makefiles. These
      tools generate files, and create several softlinks in the working
      directory for later use.</para>
    </section>

    <section>
      <title>configure.ac</title>

      <para><programlisting>AC_INIT
META_SETUP
META_C_SETUP
META_JAVA_SETUP
AC_PROG_LIBTOOL
AC_OUTPUT</programlisting>This file is used by autoconf to generate a
      configure script. The example file here prepares the package for C and
      Java code. The C code will use dynamically linked libraries.
      Configure.ac must contain AC_INIT, META_SETUP, and AC_OUTPUT. It may
      contain META_C_SETUP, or META_JAVA_SETUP, or both. Furthermore, any
      autoconf macros are allowed if your package needs more detailed
      configuration. Please read the autoconf manual for details. </para>

      <para>Note that the META_ macros take care of inter-package dependencies
      (see the &lt;packagename&gt;.pc.in file).</para>
    </section>

    <section>
      <title>&lt;packagename&gt;.pc.in</title>

      <para><programlisting>prefix=@prefix@
Maintainers=jurgenv@cwi.nl,economop@cwi.nl
Name: &lt;packagename&gt;
Version: &lt;packageversion&gt;
Description: &lt;packagedescription&gt;
Requires: &lt;dependency1&gt;,&lt;dependency2&gt;,&lt;...&gt;
Cflags: -I${prefix}/include
Libs: -L${prefix}/lib -l&lt;libraryname1&gt; -l&lt;libraryname2&gt; &lt;...&gt;
#uninstalled Libs: -L@abs_top_builddir@/lib -l&lt;libraryname1&gt; -l&lt;libraryname2&gt; &lt;...&gt;
#uninstalled Cflags: -I@abs_top_builddir@/lib 
ToolBusFlags=-I${prefix}/share/&lt;packagename&gt;
JarFile=&lt;packagename&gt;.jar
Jars=${prefix}/share/${JarFile} 
#uninstalled UninstalledJars=@abs_top_srcdir@/${JarFile}
Packages=&lt;javapackagenames&gt;
TestClass=&lt;toptestclassname&gt;</programlisting>This is the defining file
      for a package. The file declares all there is to know about a package.
      This information is typically used by the <command>reconf</command>
      script, by continous integration toolkits, by package managers, and
      other deployment and product composition tools.</para>

      <para>The prefix variable is an obligatory implementation detail. The
      #uninstalled variables are used for compiling compositions of packages
      before they are installed (packages may refer to the source locations
      instead of the installed locations using this information). The Requires
      field is most important. It declares the dependencies on other packages.
      The pc.in file currently supports three kinds of programming languages.
      If a package contains any of these, the associated variables are needed,
      otherwise not. </para>

      <para>C packages that export libraries use Cflags, Libs and their
      uninstalled variants. This information is used by the makefiles of other
      packages. Namely, for each package they depend on variables will be made
      available. Example: If your package depends on the aterm package, then
      you will have ATERM_CFLAGS, and ATERM_LIBS at your disposal in the
      makefiles. </para>

      <para>Java packages export jar files, and have a test interface. From
      this information a full <command>ant</command> build configuration is
      instantiated. This assumes that the source code is located in the
      subdirectory <emphasis>src.</emphasis> The other variables explain where
      the jar file should be installed and which packages should be included.
      </para>

      <para>Packages containing ToolBus scripts explain where the scripts are
      installed such that dependent packages may set their search paths
      automatically.</para>

      <para>Note that the implementation of the semantics of the .pc.in file
      is located in the package <emphasis>meta-build-env</emphasis>. This
      package contains extension to automake and autoconf, written as shell
      scripts and m4 macros. Writing such a package is considered a black art,
      but it does allow us to remove a lot of code duplication, and improve
      consistency, in the infra-structure of packages.</para>
    </section>

    <section>
      <title>COPYING, AUTHORS, README, NEWS</title>

      <para>The COPYING file contains the license for the source code located
      in this package. This is usually the LGPL license for Meta-Environment
      packages. The AUTHORS file lists the authors email addresses. The README
      file should contain a brief description of the package. The NEWS file
      should list remarks on the evolution of the package on a high level of
      abstraction. Note that README and NEWS files are usually not maintained
      too well in Meta-Environment packages.</para>
    </section>

    <section>
      <title>ChangeLog</title>

      <para><programlisting>Fri Jun 30 21:43:04 CEST 2006 &lt;jurgenv@cwi.nl&gt;
 * libmept/MEPT-utils.[ch]: reorganized this long file into a number of smaller files that each deal with a specific topic.
 * libmept/*.c: added much documentation.
 * libmept/*.h: fixed bug #774
 * pt-support.pc.in: Bumped version to 0.1231</programlisting>This is a
      snippet of an existing ChangeLog file. This file contains remarks on all
      changes to the source code of a package, in reverse order of date.
      Maintaining this information in this file makes it independent of a
      version management system. It should contain references to bug numbers
      when bugs are fixed. The ChangeLog file has a fixed format. Editors such
      as gvim and emacs have plugins for its syntax. ChangeLog files are
      maintained very well in Meta-Environment packages.</para>
    </section>

    <section>
      <title>Makefile.am</title>

      <para><programlisting>include $(top_srcdir)/Makefile.top.meta

SUBDIRS = &lt;subdirs&gt;

ACLOCAL_AMFLAGS = -I .</programlisting>This very important file in the
      toplevel of the package is used to generate a Makefile. The entire tool
      chain of automake, autoconf, aclocal, configure, etc. starts here. Note
      that the exact number of spaces on the line ACLOCAL_AMFLAGS should be
      copied. </para>

      <para>The example above is relevant for ToolBus and C packages. For
      these kinds of packages, each subdirectory should contain its own
      Makefile.am. Please read the automake manual on how to write Makefile.am
      files for compiling C libraries and C programs. Each Makefile.am may
      include Makefile.meta, such that reusable make rules and other utilities
      become available. You are advised to look at the Makefile.am files of
      existing packages for inspiration. Inclusion of the Makefile.meta file
      is not obligatory however.<programlisting>include $(top_srcdir)/Makefile.meta</programlisting></para>

      <para>In case of a Java package. The toplevel Makefile.am should look
      like this:<programlisting>include $(top_srcdir)/Makefile.java.meta

ACLOCAL_AMFLAGS = -I .</programlisting></para>

      <para>Java packages should have all their code in a subdirectory called
      src. This subdirectory may contain packages, but the corresponding
      directories do not need copies of a Makefile.am file.</para>
    </section>

    <section>
      <title>src, lib, tbscripts, spec, utils, scripts</title>

      <para>These are standard subdirectory names. Src contains Java source
      code packages. Lib contains source code for C libraries. Tbscript
      contains ToolBus scripts. Spec contains ASF+SDF specifications. Utils
      contains C programs with a main that link the libraries in lib. Scripts
      contain shell scripts. Each of these directories, except for src, has a
      Makefile.am file.</para>

      <para>The above directory names are not obliged, and are not used
      consistently by the existing Meta-Environment packages either.</para>
    </section>
  </section>

  <section>
    <title>Adding a configuration script</title>

    <programlisting>configuration([
  library-path("SDF Grammar Library","__SDF_LIBRARY__"),
  library-path("ASF+SDF Library","__ASF_LIBRARY__"),
  action([description(tree-panel, click)],
         "ShowAreaAction"),
  action([description(feedback-list, click)],
         "ShowFeedbackLocation"),
  action([description(studio-menubar, menu([label("File"), label("Exit")]))],
         "ExitAction"),
  action([description(studio-menubar, menu([label("File"), label("Change Workspace...")]))],
         "ChangeWorkspaceAction"),
  action([description(studio-menubar, menu-shortcut([label("Module"), label("New...")], shortcut([M_ALT,M_SHIFT],VK_N))),
           description(studio-toolbar, icon("New Module", "New24.gif"))],
         "NewModuleAction"),
  action([description(studio-menubar, menu([label("Module"), label("Open...")])),
           description(studio-toolbar, icon("Open Module", "Open24.gif"))],
         "OpenModuleAction"),
  action([description(studio-menubar, menu([label("Module"), label("Close All")]))],
         "CloseAllAction"),
  action([description(term-editor, menu-shortcut([label("Term"),label("Add Brackets")], shortcut([M_ALT,M_CTRL],VK_B)))],
         "AddBracketsAction"),
  action([description(term-editor, menu-shortcut([label("Structure"), label("View"),label("Tree")], shortcut([M_ALT,M_CTRL],VK_V)))],
         "ShowTreeAction"),
  action([description(term-editor, menu-shortcut([label("Structure"), label("View"), label("Full Tree")], shortcut([M_ALT,M_CTRL],VK_F)))],
         "ShowFullTreeAction"),
  action([description(term-editor, menu-shortcut([label("Structure"), label("View"), label("Full Tree w/o Layout")], shortcut([M_ALT,M_CTRL],VK_L)))],
         "ShowFullTreeWithoutLayoutAction"),
  action([description(term-editor, menu-shortcut([label("Structure"), label("View"), label("Shared Tree")], shortcut([M_ALT,M_CTRL],VK_S)))],
         "ShowSharedTreeAction"),
  action([description(term-editor, menu-shortcut([label("Module"),label("Edit"), label("Syntax")], shortcut([M_CTRL,M_SHIFT],VK_S)))],
         "EditorEditSyntaxAction"),
  action([description(term-editor, menu-shortcut([label("Module"), label("Edit"),label("Term")], shortcut([M_CTRL,M_SHIFT],VK_T)))],
         "EditorEditTermAction"),
  action([description(syntax-editor, menu-shortcut([label("Module"), label("Edit"), label("Term")], shortcut([M_CTRL,M_SHIFT],VK_T)))],
         "EditorEditTermAction"),
  action([description(syntax-editor, menu-shortcut([label("Structure"), label("Move"), label("Left")],shortcut([M_ALT,M_CTRL],VK_LEFT))),
          description(term-editor, menu-shortcut([label("Structure"), label("Move"), label("Left")],shortcut([M_ALT,M_CTRL],VK_LEFT)))],
         "MoveCursorLeftAction"),
  action([description(syntax-editor, menu-shortcut([label("Structure"), label("Move"), label("Right")],shortcut([M_ALT,M_CTRL],VK_RIGHT))),
          description(term-editor, menu-shortcut([label("Structure"), label("Move"), label("Right")],shortcut([M_ALT,M_CTRL],VK_RIGHT)))],
         "MoveCursorRightAction"),
  action([description(syntax-editor, menu-shortcut([label("Structure"), label("Move"), label("Up")], shortcut([M_ALT,M_CTRL],VK_UP))),
          description(term-editor, menu-shortcut([label("Structure"), label("Move"), label("Up")],shortcut([M_ALT,M_CTRL],VK_UP)))],
         "MoveCursorUpAction"),
  action([description(syntax-editor, menu-shortcut([label("Structure"), label("Move"), label("Down")],shortcut([M_ALT,M_CTRL],VK_DOWN))),
          description(term-editor, menu-shortcut([label("Structure"), label("Move"), label("Down")], shortcut([M_ALT,M_CTRL],VK_DOWN)))],
         "MoveCursorDownAction"),
  action([description(syntax-editor, popup)], "EditorPopup"),
  action([description(equations-editor, popup)], "EditorPopup"),
  action([description(term-editor, popup)], "EditorPopup"),

  action([description(module-popup, menu([label("Close...")]))],
         "CloseModuleAction"),
  action([description(module-popup, menu([label("Edit"), label("Syntax")]))],
         "EditSyntaxAction"),
  action([description(module-popup, menu([label("Edit"), label("Term...")]))],
         "EditTermAction"),
  action([description(module-popup, menu([label("Export"),label("SDF Definition...")]))],
         "DumpSdfDefinitionAction"),
  action([description(module-popup, menu([label("Export"),label("Term ParseTable...")]))],
         "DumpParseTableAction"),
  action([description(new-module-popup, menu([label("Create this module")]))],
         "create-module"),
  action([description(new-module-popup, menu([label("Delete this module")]))],
         "delete-module"),


   text-category(normal,[foreground-color(rgb(0,0,0)),
                         background-color(rgb(255,255,255)),
                         font("Monospaced"),
                         size(14)]),
   text-category(focus,    [foreground-color(rgb(0,0,0)),background-color(rgb(255,250,148))]),
   text-category(selection,[foreground-color(rgb(255,255,255)),background-color(rgb(65,101,172))]),
   text-category(extern("MetaKeyword"),[style(bold),foreground-color(rgb(123,0,82))]),
   text-category(extern("MetaVariable"),[style(italics),foreground-color(rgb(0,0,255))]),
   text-category(extern("MetaAmbiguity"),[style(bold),foreground-color(rgb(186,29,29))]),
   text-category(extern("Todo"),[style(bold),background-color(rgb(255,255,255)),foreground-color(rgb(123,157,198))]),
   text-category(extern("Comment"),[style(italics),foreground-color(rgb(82,141,115))]),
   text-category(extern("Constant"),[style(italics),foreground-color(rgb(139,0,139))]),
   text-category(extern("Variable"),[foreground-color(rgb(144,238,144))]),
   text-category(extern("Identifier"),[foreground-color(rgb(255,69,0))]),
   text-category(extern("Type"),[foreground-color(rgb(255,127,36))]),
   text-category(extern("Error"),[style(bold),foreground-color(rgb(255,0,0))]),
   text-category(extern("Warning"),[style(bold),foreground-color(rgb(0,0,255))]),
   text-category(extern("Info"),[style(bold),foreground-color(rgb(0,255,0))]),
   text-category(extern("Fatal"),[style(bold),background-color(rgb(255,0,0))])
])</programlisting>

    <itemizedlist>
      <listitem>
        <para>elements of .action files: syntax and semantics</para>
      </listitem>

      <listitem>
        <para>importing other action files</para>
      </listitem>

      <listitem>
        <para>the ./meta.actions file</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Adding new ToolBus scripts</title>

    <itemizedlist>
      <listitem>
        <para>relation between configuration scripts and ToolBus scripts (menu
        calls processes)</para>
      </listitem>

      <listitem>
        <para>explain all available processes from meta package, and
        rec-msgs</para>
      </listitem>

      <listitem>
        <para>explain coding conventions for ToolBus scripts (small
        scripts)</para>
      </listitem>

      <listitem>
        <para>explain instantiation of language specific editors (connecting
        parser/parsetable)</para>
      </listitem>

      <listitem>
        <para>explain connection between text-categories in configuration
        script, and syntax highlighter</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Implementing new tools</title>

    <itemizedlist>
      <listitem>
        <para>refer to ToolBus manuals, and ATerm manuals</para>
      </listitem>

      <listitem>
        <para>refer to -t flag of asfc compiler</para>
      </listitem>

      <listitem>
        <para>refer to generic adapter (does it still work?)</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Implementing GUI extensions</title>

    <para>Explain the StudioPlugin interface, and the StudioComponent
    interface.</para>

    <itemizedlist>
      <listitem>
        <para>How to implement the StudioPlugin interface</para>
      </listitem>

      <listitem>
        <para>How to implement the StudioComponent interface</para>
      </listitem>

      <listitem>
        <para>How to load the jarfile into the MetaStudio</para>
      </listitem>

      <listitem>
        <para>How to add menu options via the MetaStudio interface</para>
      </listitem>

      <listitem>
        <para>How to load StudioComponents at certain tab positions using the
        MetaStudio interface</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Implementing a start-up shell script</title>

    <para>Explain the commandline parameters of the ToolBus. Explain the usage
    of config-manager tool for computing the commandline parameters for the
    ToolBus from a .actions configuration file.</para>

    <itemizedlist>
      <listitem>
        <para>Explain commandline parameters of the ToolBus interpreter</para>
      </listitem>

      <listitem>
        <para>Explain the usage of the commandline interface of the
        config-manager tool for generating instantiations of ToolBus
        commandline parameters from configurations files</para>
      </listitem>
    </itemizedlist>
  </section>
</article>