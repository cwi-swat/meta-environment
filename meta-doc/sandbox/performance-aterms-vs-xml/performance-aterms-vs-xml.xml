<?xml version="1.0" encoding="UTF-8"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Performance of ATerms compared with XML</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Arnold</firstname><surname>Lankamp</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is under development. See <xref
    linkend="section.to-do" />.</para>
  </note>

  <section>
    <title>Introduction</title>

    <para>ATerms are the ubiquitous data exchange format used in The
    Meta-Environment. ATerms were designed with a specific application domain
    in mind: exchanging parse tables, parse trees and other source code
    related data that emerges in the context of Interactive Development
    Environments and tools for source code analysis and transformation.</para>

    <para>World-wide, XML is the defacto standard for data exchange in many
    application domains and an obvious question to ask is how ATerms and XML
    compare regarding</para>

    <itemizedlist>
      <listitem>
        <para>speed (efficiency of reading and writing data), and</para>
      </listitem>

      <listitem>
        <para>size (the size of the intermediate data).</para>
      </listitem>
    </itemizedlist>

    <para>In addition we will also take a look at the binary encoding of
    ATerms (SAF) and how it compares to the ATerm ASCII format.</para>

    <para>This document describes experiments to make this comparison. Our
    findings can be summarized as follows:</para>

    <itemizedlist>
      <listitem>
        <para>Writing ATerm ASCII and XML is about as fast.</para>
      </listitem>

      <listitem>
        <para>Parsing ATerm ASCII is both significantly slower and scales
        worse then XML.</para>
      </listitem>

      <listitem>
        <para>The ATerm ASCII representation is more compact.</para>
      </listitem>

      <listitem>
        <para>ATerm SAF is useful for reading and writing documents with a
        'large' percentage of shared nodes.</para>
      </listitem>
    </itemizedlist>

    <para>In <xref linkend="section.considerations" /> we sketch the general
    considerations to be taken into account when performing such a comparions
    and in <xref linkend="section.experimental-setting" /> we describe the
    experimental setting. Results are presented in <xref
    linkend="section.results" /> and our overall conclusions can be found in
    <xref linkend="section.conclusions" />.</para>
  </section>

  <section xml:id="section.considerations">
    <title>Considerations</title>

    <para>There are various considerations that influence a fair comparison of
    ATerms and XML.</para>

    <section>
      <title>ATerms versus XML</title>

      <para>There are various differences between ATerms and XML that may
      affect a comparison:</para>

      <itemizedlist>
        <listitem>
          <para>ATerms may have annotations attached to each node; these
          annotations may contain arbitrary ATerms; XML elements may have
          attributes but these may only contain a single value.</para>
        </listitem>

        <listitem>
          <para>The implementation of ATerms supports the notion of maximal
          subterm sharing; XML has no counterpart for this.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Potential influences on measurements</title>

      <itemizedlist>
        <listitem>
          <para>Although we would prefer to compare the concepts underlying
          ATerms and XML, it is unavoidable that we can only measure specific
          implementations of these concepts. The implementation and
          optimization effort invested in XML implementations is uncomparable
          to the effort invested in the ATerm implementation.</para>
        </listitem>

        <listitem>
          <para>ATerms only support US-ASCII characters, while XML supports
          Unicode.</para>
        </listitem>

        <listitem>
          <para>The following properties of test data may influence the
          result:</para>

          <itemizedlist>
            <listitem>
              <para>The size of the data.</para>
            </listitem>

            <listitem>
              <para>The amount of sharing.</para>
            </listitem>

            <listitem>
              <para>The number of different function symbols/tags that is
              used.</para>
            </listitem>

            <listitem>
              <para>The width and depth of the data.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>We will compare Java implementations of ATerms and XML and the
          unpredictable effects of the HotSpot compiler have to be taken into
          account.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.experimental-setting">
    <title>Experimental Setting</title>

    <para></para>

    <section>
      <title>The test data generator</title>

      <para>Due to the functional differences between ATerms and XML, we
      decided to create a synthetic benchmark that creates test data in both
      formats. The test data generator has the following parameters that are
      used to characterize the generated trees:</para>

      <itemizedlist>
        <listitem>
          <para>Number of nodes in the tree.</para>
        </listitem>

        <listitem>
          <para>Depth of the tree.</para>
        </listitem>

        <listitem>
          <para>Average arity of a node.</para>
        </listitem>

        <listitem>
          <para>Percentual chance any given node in the tree is shared.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Software versions</title>

      <para>For the benchmarks the following software was used:</para>

      <itemizedlist>
        <listitem>
          <para>Sun JDK 1.5.0_12</para>
        </listitem>

        <listitem>
          <para>ATerm-Java, version 1.7pre.24750.52534.</para>
        </listitem>

        <listitem>
          <para>Xerces-J, version 2.6.2 (incorperated in JDK 1.5.0_12).</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Hardware configuration</title>

      <para>The benchmark was executed on a machine with the following
      specifications:</para>

      <itemizedlist>
        <listitem>
          <para>Intel E6420 Core 2 Duo processor (2.13Ghz).</para>
        </listitem>

        <listitem>
          <para>2GB DDR2-800 memory.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Measurement procedure</title>

      <para>The results that are summarized in the chapter below have been
      acquired in the following manner:<itemizedlist>
          <listitem>
            <para>For every benchmark a seperate function was created which
            measured the absolute elapsed time that was required to run a
            certain operation one hunderd times.</para>
          </listitem>

          <listitem>
            <para>Before starting a benchmark the code was 'warmed-up' first,
            so it was (fully) compiled before executing the actual test. This
            prevents compilation overhead from being included in the
            results.</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>

  <section xml:id="section.results">
    <title>Results</title>

    <para>In this chapter we will take a look at the results that were
    produced by executing the different benchmarks. </para>

    <section>
      <title>XML vs ATerm ASCII</title>

      <para></para>

      <section>
        <title>Speed comparison</title>

        <para>The graph below illustrates the way ATerm ASCII and XML scale in
        terms of transformation speed. Both formats are able to write their
        object model to a String in about the same time. The time it takes
        seems to scale liniarly with the number of nodes in the tree.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="ATerm_vs_XML_writing.png"></imagedata>
          </imageobject>

          <caption>
            <para>The time it takes (in ms) to serialize a document with a
            certain number of nodes.</para>
          </caption>
        </mediaobject>

        <para>In terms of parsing performance XML is well ahead. This is to be
        exepected, since the ATerm library needs to handle the sharing of the
        parsed data as well; which takes a significant amount of time. The
        relative overhead associated with this also seems to increase with the
        size of the document.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="ATerm_vs_XML_reading.png"></imagedata>
          </imageobject>

          <caption>
            <para>The time it takes (in ms) to parse a document with a certain
            number of nodes.</para>
          </caption>
        </mediaobject>
      </section>

      <section>
        <title>Size comparison</title>

        <para>In terms of size the ATerm ASCII format is the clear winner. The
        major reason for this is that the ATerm ASCII format doesn't have
        close tags, like XML does, but instead uses a single token (')') for
        this purpose. The number of nodes in the document doesn't seem to have
        any impact of the relative difference in size; it stays about the
        same.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="ATerm_vs_XML_size.png"></imagedata>
          </imageobject>

          <caption>
            <para>The size of the serialized representation of a document with
            a certain number of nodes (in bytes).</para>
          </caption>
        </mediaobject>
      </section>
    </section>

    <section>
      <title>ATerm ASCII vs SAF</title>

      <para>For smaller documents the text representation of ATerms is
      sufficient. However when it comes to reading and writing large documents
      it is clearly unsuitable. For this purpose several other ATerm formats
      were developed; SAF (semi-Streamable ATerm Format) is the latest
      addition. Here we will take a look at how they compare.</para>

      <section>
        <title>Speed comparison</title>

        <para>Writing ATerms in the SAF format ranges from clearly worse to
        significantly better, wholey dependant on the amount of sharing in the
        document. This can be explained be the fact that the SAF writer
        implementation needs to keep track of sharing for compression
        purposes; is there is nothing to compress, it did extra work that
        didn't result in any gain.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="ASCII_vs_SAF_writing.png"></imagedata>
          </imageobject>

          <caption>
            <para>The time it takes to serialize a document with 50000 nodes,
            given a certain percentage of sharing.</para>
          </caption>
        </mediaobject>

        <para>In terms for parsing performance, SAF does a lot better; ATerm
        ASCII is only faster in the case of complete absence of sharing. This
        can be explained by the difference in document size; the SAF parser
        needs to read more characters in this specific case.</para>

        <para>Note that ATerm ASCII also becomes faster as a result of
        sharing. This is an implementation artifact. The factory that keeps
        track of the shared ATerm objects uses weak-references to refer to
        them. Since a weak-reference needs to be checked by the VM at every
        garbage collection invokation (both major and minor) it incurs a
        certain performance overhead. If there is more sharing there are less
        objects in the factory and thus less overhead.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="ASCII_vs_SAF_reading.png"></imagedata>
          </imageobject>

          <caption>
            <para>The time it takes to parse a document with 50000 nodes,
            given a certain percentage of sharing.</para>
          </caption>
        </mediaobject>
      </section>

      <section>
        <title>Size comparison</title>

        <para>The graph below looks fairly similair to the one in the previous
        section, which compared parser speed. The more sharing the smaller the
        document and consequently the faster it can be parsed.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="ASCII_vs_SAF_size.png"></imagedata>
          </imageobject>

          <caption>
            <para>The size of the serialized representation of a document with
            50000 nodes, given a certain percentage of sharing.</para>
          </caption>
        </mediaobject>
      </section>
    </section>
  </section>

  <section xml:id="section.conclusions">
    <title>Conclusions</title>

    <para>TODO</para>

    <para><itemizedlist>
        <listitem>
          <para>Writing ATerm ASCII and XML is about as fast.</para>
        </listitem>

        <listitem>
          <para>Parsing ATerm ASCII is both significantly slower and scales
          worse then XML (partially because of the sharing).</para>
        </listitem>

        <listitem>
          <para>ATerm ASCII is more compact (because we don't have close
          tags).</para>
        </listitem>

        <listitem>
          <para>ATerm SAF is useful for reading and writing large documents
          with lots of sharing.</para>
        </listitem>
      </itemizedlist></para>

    <para>TODO</para>
  </section>

  <section>
    <title xml:id="section.to-do">To Do</title>

    <itemizedlist>
      <listitem>
        <para>Write something useful in the conclusion chapter.</para>
      </listitem>

      <listitem>
        <para>Fill the 'holes' in the document.</para>
      </listitem>
    </itemizedlist>
  </section>
</article>