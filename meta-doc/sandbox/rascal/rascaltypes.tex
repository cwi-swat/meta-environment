\documentclass{article}
\usepackage{amsmath}

\newcommand{\rmf}[1]{\textbf{NOTE:} #1}

\begin{document}

\section{Type System}
\label{sec:typeSystem}

\newcounter{rule}
\newcounter{subtyperule}

\newcommand{\ifthenRule}[3]{[#1] & $ \frac{#2}{#3} $\\}

\newcommand{\typeRule}[3]{[#1] & $ \frac{#2}{#3} $\\}

%%\newcommand{\typeRule}[3]{
%%  \refstepcounter{rule}
%%  \ifthenRule{#1}{#2}{#3}\\
%%}
\newcommand{\subTypeRule}[3]{
  \refstepcounter{subtyperule}
  [#1] & $#2 \leq #3$\\
}
\newcommand{\iffTypeRule}[3]{
  \refstepcounter{subtyperule}
  [#1] & $#2 \Leftrightarrow #3$\\
}
\newcommand{\eqTypeRule}[3]{
  \refstepcounter{subtyperule}
  [#1] & $#2\: \equiv\: #3$ \\
}
\newcommand{\judgment}[1]{\Gamma \models #1}
\newcommand{\hasType}[2]{#1\,:\,#2}
\newcommand{\scalar}[1]{<\negthickspace#1\negthickspace>}
\newcommand{\produces}{::=}
\newcommand{\termDef}[2]{[#1] & \;$T\,\produces\,#2$\\}
\newcommand{\typeDef}[1]{$\tau\,\produces\,#1$\\}

\newcommand{\tupleOfVal}[1]{<#1>}
\newcommand{\setOfVal}[1]{\{#1\}}
\newcommand{\relOfVal}[1]{\{#1\}}
\newcommand{\mapOfVal}[1]{\{#1\}}
\newcommand{\listOfVal}[1]{[#1]}

\newcommand{\kw}[1]{\texttt{#1}}

\newcommand{\tupleOf}[1]{\texttt{tuple[}#1\texttt{]}}
\newcommand{\setOf}[1]{\texttt{set[}#1\texttt{]}}
\newcommand{\relOf}[1]{\texttt{rel[}#1\texttt{]}}
\newcommand{\mapOf}[1]{\texttt{map[}#1\texttt{]}}
\newcommand{\listOf}[1]{\texttt{list[}#1\texttt{]}}

\newcommand{\ident}{<\negthickspace id\negthickspace>}

\newcommand{\kwbool}[0]{\kw{bool}}
\newcommand{\kwint}[0]{\kw{int}}
\newcommand{\kwdouble}[0]{\kw{double}}
\newcommand{\kwstr}[0]{\kw{str}}
\newcommand{\kwloc}[0]{\kw{loc}}
\newcommand{\kwvalue}[0]{\kw{value}}
\newcommand{\kwtree}[0]{\kw{tree}}
\newcommand{\kwvoid}[0]{\kw{void}}
\newcommand{\kwtuple}[0]{\kw{tuple}}
\newcommand{\kwlist}[0]{\kw{list}}

\newcommand{\kwset}[0]{\kw{set}}
\newcommand{\kwmap}[0]{\kw{map}}
\newcommand{\kwrel}[0]{\kw{rel}}
\newcommand{\kwnamedtype}[0]{\kw{namedtype}}


\begin{figure*}
\begin{tabular}{rl}
\termDef{Scalars}{\scalar{bool} | \scalar{int} | \scalar{double} | \scalar{str} | \scalar{loc}}
\termDef{Tuples}{\tupleOfVal{T*}}
\termDef{Sets}{\setOfVal{T*}}
\termDef{Relations}{\relOfVal{T*}}
\termDef{Lists}{\listOfVal{T*}}
\termDef{Maps}{\setOfVal{\tupleOfVal{T,T}*}}
\termDef{Identifiers}{\ident}
\termDef{Projection}{T[\ident*]}
\end{tabular}
\caption{Basic Rascal Terms}
\label{fig:basicTerms}
\end{figure*}

\begin{figure*}
\typeDef{\kwbool \mid \kwint \mid \kwdouble \mid \kwstr \mid \kwloc \mid \kwvalue \mid \kwtree \mid \kwvoid}
\typeDef{\kwtuple[\iota_1:\tau_1,\ldots,\iota_n:\tau_n]}
\typeDef{\kwset[\tau] \mid \kwlist[\tau] \mid \kwmap[\tau_1,\tau_2] \mid \kwrel[\iota_1:\tau_1,\ldots,\iota_n:\tau_n]}
\typeDef{\kwnamedtype[\iota,\tau]}
\caption{Basic Rascal Types}
\label{fig:basicTypes}
\end{figure*}

\begin{figure*}
\begin{tabular}{rl}
\end{tabular}
\end{figure*}

\begin{figure*}
\begin{tabular}{rl}
\termDef{Field selection}{T.\ident}
\termDef{Projection}{T[\ident*]}
\termDef{Binary ops}{T (\cap,\cup,\setminus) T}
\termDef{Composition}{T \circ T}
\termDef{Closure}{T+}
\termDef{Lookup}{T.get(T)}
\termDef{Map update}{T.set(T,T)}
\termDef{Sizeof}{\sharp T}
\termDef{Product}{T \times T}
\termDef{Inverse}{inv(T)}
\termDef{Carrier}{carrier(T)}
\termDef{Vardecl}{\tau \ident = T}
\termDef{NamedType}{type \ident extends\; \tau}
\end{tabular}
\caption{Rascal Operators}
\label{fig:operators}
\end{figure*}

\begin{figure*}
\begin{tabular}{rl}
\eqTypeRule{EQ1}{\setOf{\tupleOf{\tau_1,\ldots,\tau_n}}}{\relOf{\tau_1,\ldots,\tau_n}}
\eqTypeRule{EQ2}{\tupleOf{\iota_1:\tau_1,\ldots,\iota_n:\tau_n}}{\tupleOf{\tau_1,\ldots,\tau_n}}
\subTypeRule{VOID}{void}{\tau}
\subTypeRule{VALUE}{\tau}{value}
\subTypeRule{IDENT}{\tau}{\tau} 
\subTypeRule{NAMEDTYPE1} {namedtype[\iota,\tau]}{\tau}
\iffTypeRule{NAMEDSTYPE2}{namedtype[\iota_1,\tau_1] \leq namedtype[\iota_2,\tau_2]}
{\tau_1 = \tau_2 \& \iota_1 = \iota_2}\\
\ifthenRule{TUPLE}{\tau_1 \leq \tau_1' \& \ldots \& \tau_n \leq \tau_n'}{\tupleOf{\tau_1,\ldots,\tau_n} \leq \tupleOf{\tau_1',\ldots,\tau_n'}}\\

\ifthenRule{SET}{\tau \leq \tau'}{\setOf{\tau} \leq \setOf{\tau'}}\\
\ifthenRule{LIST}{\tau \leq \tau'}
{\listOf{\tau} \leq \listOf{\tau'}}\\

\ifthenRule{MAPREL}{\tau_1 \leq \tau_1' \& \tau_2 \leq \tau_2'}
{\mapOf{\tau_1,\tau_2} \leq \relOf{\tau_1',\tau_2'}} \\


\ifthenRule{MAPMAP}{\tau_1 \leq \tau_1' \& \tau_2 \leq \tau_2'}
{\mapOf{\tau_1,\tau_2} \leq \mapOf{\tau_1',\tau_2'}}\\

\ifthenRule{FUNCTION}{\tau \leq \tau' \& \tau_1 \leq \tau_1', \ldots ,\tau_n \leq \tau_n'}
{\tau N (\tau_1, \ldots ,\tau_n ) \leq \tau' N ( \tau_1', \ldots ,\tau_n' )}\\
\end{tabular}

\caption{Subtyping rules}
\label{fig:subtyping}
\end{figure*}

\begin{figure*}
\begin{tabular}{rl}

\typeRule{SELECT}{\judgment{\hasType{v}{\tupleOf{\iota_1:\tau_1,\ldots,\iota_n:\tau_n},1\leq k\leq n}}}
       {\judgment{\hasType{v.\iota_k}{\tau_k}}}\\

\typeRule{TUPLE}{\judgment{\hasType{T_1}{\tau_1},\ldots,\hasType{T_n}{\tau_n}}}
       {\judgment{\hasType{\tupleOf{T_1,\ldots,T_n}}{\tupleOf{\tau_1,\ldots,\tau_n}}}}\\

\typeRule{SET}{\judgment{\hasType{T_1}{\tau_1},\ldots,\hasType{T_n}{\tau_n} \& \tau = lub(\tau_1,\ldots,\tau_n)}}
       {\judgment{\hasType{\setOf{T_1,\ldots,T_n}}{\tau}}}\\

%%\rmf{The following two rules should use $\top$ rather than existential types}\\\\
\typeRule{X}{}
       {\judgment{\hasType{\mid \; \mid}{\exists \tau_1,\tau_2: \mapOf{\tau_1,\tau_2}}}}\\

\typeRule{X}{}
       {\judgment{\hasType{\{ \; \}}{\exists \tau: \setOf{\tau}}}}\\

\typeRule{PRODUCT}{\judgment{\hasType{T_1}{\relOf{\tau_1,\ldots,\tau_n}}, \hasType{T_2}{\relOf{\tau_{n+1},\ldots,\tau_{n+m}}}}}
       {\judgment{\hasType{T_1 \times T_2}{\relOf{\tau_1,\ldots,\tau_n,\tau_{n+1},\ldots,\tau_{n+m}}}}}\\


\typeRule{UNION}{\judgment{\hasType{T_1}{\tau_1}, \hasType{T_2}{\tau_2}, \tau = lub(\tau_1,\tau_2)}}
       {\judgment{\hasType{T_1 \cup T_2}{\tau}}}\\

\typeRule{MAPGET}{\judgment{\hasType{T_1}{\mapOf{\tau_1,\tau_2}},\hasType{T_2}{\tau},\tau \leq \tau_1}}
       {\judgment{\hasType{T_1.get(T_2)}{\tau_2}}}\\


\typeRule{MAPSET}{\judgment{\hasType{T}{\mapOf{\tau_1,\tau_2}},\hasType{T_1}{\tau_1'\leq\tau_1},\hasType{T_2}{\tau_2'\leq\tau_2}}}
       {\judgment{\hasType{T.set(T_1,T_2)}{\mapOf{\tau_1,\tau_2}}}}\\

\typeRule{COMPOSE}{\judgment{\hasType{T_1}{\relOf{\tau_1,\tau_2}},\hasType{T_2}{\relOf{\tau_3,\tau_4}},(\tau_2\leq\tau_3\vee\tau_3\leq\tau_2)}}
       {\judgment{\hasType{T_1 \circ T_2}{\relOf{\tau_1,\tau_4}}}}\\

\typeRule{CLOSURE}{\judgment{\hasType{T}{\relOf{\tau_1,\tau_2}},(\tau_1\leq\tau_2\vee\tau_2\leq\tau_1)}}
       {\judgment{\hasType{T+}{\relOf{lub(\tau_1,\tau_2)}}}}\\

\typeRule{PROJECT}{\judgment{\hasType{T}{\setOf{\tupleOf{\iota_1:\tau_1,\ldots,\iota_n:\tau_n}}},
                  1\leq i\leq k \leq n, \exists j_i: id_i = \iota_{j_i}}}
       {\judgment{\hasType{T[id_1,\ldots,id_k]}{\setOf{\tupleOf{\iota_{j_1}:\tau_{j_1},\ldots,\iota_{j_k}:\tau_{j_k}}}}}}\\

\typeRule{VAR1}{P \textrm{ has declaration } \tau \ id \texttt{ = } T \ \wedge \ \judgment{\hasType{T}{\tau'},\tau'\leq\tau}}
       {\judgment{\hasType{id}{\tau}}}\\
\typeRule{VAR2}{P \textrm{ has declaration } \texttt{type } id \texttt{ extends } \tau}
       {\judgment{id \leq \tau}}\\
\end{tabular}
\caption{Typing rules for Rascal Expressions}
\label{fig:typingRules}
\end{figure*}
\end{document}
