<?xml version="1.0" encoding="UTF-8"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Design of ASF2</title>

  <info>
    <author>
      <personname>Jurgen Vinju</personname>
    </author>

    <author>
      <personname>Paul Klint</personname>
    </author>

    <author>
      <personname>Tijs van der Storm</personname>
    </author>
  </info>

  <section>
    <title>Introduction</title>

    <para>This document describes a work-in-progress. The design of a
    follow-up of ASF has been in discussion for two years. We intend to
    collect and summarize our discussions here, as a starting point for more
    detailed design and eventually implementation.</para>

    <section>
      <title>Vision</title>

      <para>On the one hand, ASF has a number of succesfull features for
      source code analysis and manipulation, and is also still lacking in
      several ways. On the other hand RScript fills a certain gap in source
      code analysis and manipulation. Bridging ASF and RScript is doable, but
      the formalisms and their intended use seems too close to make a case for
      a real separation-of-concerns. ASF2 is to improve on ASF by better error
      messaging, better syntax for common analysis and manipulation tasks,
      better reusability and simplicity.</para>

      <para>The real starting point is thus that analysis and manipulation of
      source code are closely related and interdependent. ASF2 will be a
      domain specific language that covers both domains equally well,
      seemlessly integrates them and implements them efficiently.</para>
    </section>

    <section>
      <title>Name</title>

      <para>ASF2 will be closely tied to SDF, but not in the same way as
      ASF+SDF was. It needs a new name.</para>

      <itemizedlist>
        <listitem>
          <para>Rascal - Relational Algebraic Source Code Analysis
          Language</para>
        </listitem>

        <listitem>
          <para>ASF2</para>
        </listitem>

        <listitem>
          <para>ASFNG</para>
        </listitem>

        <listitem>
          <para>Sympl - Syntactic Manipulation of Programming Languages</para>
        </listitem>

        <listitem>
          <para>SCAMSCRIPT - Source code analysis and manipulation</para>
        </listitem>

        <listitem>
          <para>MASC - manipulation and analysis of source code</para>
        </listitem>

        <listitem>
          <para>Scream - Source Code Relations Analysis and
          Manipulation</para>
        </listitem>

        <listitem>
          <para>Cream - Code Relations Analysis and Manipulation</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Applications</title>

      <para></para>

      <itemizedlist>
        <listitem>
          <para>Compilers</para>

          <itemizedlist>
            <listitem>
              <para>Control flow graphs</para>
            </listitem>

            <listitem>
              <para>Data dependency graphs</para>
            </listitem>

            <listitem>
              <para>Staged compilation</para>
            </listitem>

            <listitem>
              <para>Intermediate representations</para>
            </listitem>

            <listitem>
              <para>Data flow analyses</para>
            </listitem>

            <listitem>
              <para>Optimization</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Source-to-source</para>

          <itemizedlist>
            <listitem>
              <para>Pretty printing</para>
            </listitem>

            <listitem>
              <para>Comment analysis</para>
            </listitem>

            <listitem>
              <para>Comment preservation</para>
            </listitem>

            <listitem>
              <para>Cross language</para>
            </listitem>

            <listitem>
              <para>Within language</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Documentation generators</para>
        </listitem>

        <listitem>
          <para>Code generators</para>

          <itemizedlist>
            <listitem>
              <para>Forward</para>
            </listitem>

            <listitem>
              <para>Backward (template based)</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Reverse engineering</para>

          <itemizedlist>
            <listitem>
              <para>Slicing</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Static analysis</para>

          <itemizedlist>
            <listitem>
              <para>State machines</para>
            </listitem>

            <listitem>
              <para>Model checking</para>
            </listitem>

            <listitem>
              <para>Satisfiability</para>
            </listitem>

            <listitem>
              <para>Abstract interpretation</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Dynamic analysis</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Requirements</title>

    <para>This section enumerates the requirements that ASF2 should fulfill
    from the user/programmer perspective.</para>

    <itemizedlist>
      <listitem>
        <para>Simple- the design should remain as simple as possible
        <emphasis>for the user</emphasis></para>
      </listitem>

      <listitem>
        <para>Homogeneous - all operations should preferably have a semantics
        on all data-types</para>
      </listitem>

      <listitem>
        <para>Concise</para>
      </listitem>

      <listitem>
        <para>Readable</para>
      </listitem>

      <listitem>
        <para>Testable</para>
      </listitem>

      <listitem>
        <para>Modular</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Concepts</title>

    <para>This section associates a number of concepts that will find their
    role in the new design.</para>

    <itemizedlist>
      <listitem>
        <para>Data</para>

        <itemizedlist>
          <listitem>
            <para>Parse forests</para>

            <itemizedlist>
              <listitem>
                <para>Concrete syntax</para>
              </listitem>

              <listitem>
                <para>High Fidelity</para>
              </listitem>

              <listitem>
                <para>Tree constructors</para>
              </listitem>

              <listitem>
                <para>Lexical and context-free syntax</para>
              </listitem>

              <listitem>
                <para>Ambiguity constructors</para>
              </listitem>

              <listitem>
                <para>First order signatures</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Bags, sets and relations</para>

            <itemizedlist>
              <listitem>
                <para>Nested</para>
              </listitem>

              <listitem>
                <para>Polymorphic</para>
              </listitem>

              <listitem>
                <para>User-definedRe</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Representation</para>

            <itemizedlist>
              <listitem>
                <para>ATerms</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Computation</para>

        <itemizedlist>
          <listitem>
            <para>Term Rewriting</para>

            <itemizedlist>
              <listitem>
                <para>First order Pattern matching</para>
              </listitem>

              <listitem>
                <para>List matching</para>
              </listitem>

              <listitem>
                <para>Rewrite rules</para>
              </listitem>

              <listitem>
                <para>Backtracking</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Functional programming</para>

            <itemizedlist>
              <listitem>
                <para>Implicit parameters / globals</para>
              </listitem>

              <listitem>
                <para>Subtyping</para>
              </listitem>

              <listitem>
                <para>Functions</para>
              </listitem>

              <listitem>
                <para>Functions as parameters (higher-order)</para>
              </listitem>

              <listitem>
                <para>Polymorpism</para>
              </listitem>

              <listitem>
                <para>User-defined types</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Relational calculus</para>

            <itemizedlist>
              <listitem>
                <para>Comprehensions</para>
              </listitem>

              <listitem>
                <para>Set manipulation</para>
              </listitem>

              <listitem>
                <para>Closures</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Side-effects</para>

            <itemizedlist>
              <listitem>
                <para>ToolBus integration</para>
              </listitem>

              <listitem>
                <para>File I/O, pipes</para>
              </listitem>

              <listitem>
                <para>SOAP, XML/RPC</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Composition</para>

        <itemizedlist>
          <listitem>
            <para>Data and computation hiding</para>
          </listitem>

          <listitem>
            <para>Modular compilation?</para>
          </listitem>

          <listitem>
            <para>Invasive? Aspects?</para>
          </listitem>

          <listitem>
            <para>Renaming</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Anti-concepts</title>

    <para>Things we do not want in our design.</para>

    <itemizedlist>
      <listitem>
        <para>Monads</para>
      </listitem>

      <listitem>
        <para>Reflection</para>
      </listitem>

      <listitem>
        <para>Strategies as separate concern from functions (because
        strategies are functions)</para>
      </listitem>

      <listitem>
        <para>Concrete syntax for functions</para>
      </listitem>

      <listitem>
        <para>Builtin primitive data-types (such as integers)</para>
      </listitem>

      <listitem>
        <para>Doorway to implementation level</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Implementation fundamentals</title>

    <para></para>
  </section>

  <section>
    <title>Examples</title>

    <para>Let's collect illustrative examples of code here.</para>
  </section>
</article>