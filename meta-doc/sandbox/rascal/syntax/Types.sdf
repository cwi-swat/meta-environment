module Types

imports basic/Whitespace
        languages/sdf2/syntax/Regular
        languages/sdf2/syntax/Sorts
        languages/sdf2/syntax/Literals
        Variables

hiddens
  context-free start-symbols
        Type

exports
  sorts TypeName Type OptNamedType OptNamedTypes TypeVar 
        BasicType StructuredType FunctionType AbstractType

  lexical syntax
    head:[a-z]                                          -> TypeName {cons("one-char")}
    head:[a-z] middle:[A-Za-z0-9\-]* last:[A-Za-z0-9]   -> TypeName {cons("more-chars")} 
  lexical restrictions
    TypeName -/- [A-Za-z0-9]

  context-free syntax

    "bool"                                              -> BasicType {cons("bool-type")} 
    "int"                                               -> BasicType {cons("int-type")} 
    "str"                                               -> BasicType {cons("str-type")} 
    "loc"                                               -> BasicType {cons("loc-type")}
    "value"                                             -> BasicType {cons("any-type")}
    "term"                                              -> BasicType {cons("term-type")}
    "void"                                              -> BasicType {cons("void-type")}
 
    Type Variable?                                      -> OptNamedType  
    {OptNamedType ","}+                                 -> OptNamedTypes
    "list" "[" Type "]"                                 -> StructuredType {cons("list-type")} 
    "set" "[" Type "]"                                  -> StructuredType {cons("set-type")}
    "map" "[" OptNamedType "," OptNamedType "]"         -> StructuredType {cons("map-type")}
%% We could also add the multi-map type:
%%   "mmap" "[" OptNamedType "," OptNamedType "]"       -> StructuredType {cons("mmap-type")}
    "rel" "[" OptNamedTypes "]"                         -> StructuredType {cons("rel-type")}
    "tuple" "[" OptNamedType "," OptNamedTypes "]"      -> StructuredType {cons("tuple-type")}

    "fun" Type Variable "(" OptNamedTypes? ")"          -> FunctionType {cons("function-type")}

    "&" Variable                                        -> TypeVar

    Symbol                                              -> Type {cons("symbol-type")}

    TypeName                                            -> AbstractType
    TypeVar                                             -> AbstractType
    TypeName "(" {OptNamedType ","}* ")"                -> AbstractType

    TypeVar | BasicType | StructuredType | 
    FunctionType | AbstractType                         -> Type

%% Define reserved words
   "bool" | "int" | "str" | "loc" | "value" | "term" | 
   "void" | "list" | "set" | "map" | "rel" | "tuple" |
   "fun"                                                -> TypeName {reject}
 

  

