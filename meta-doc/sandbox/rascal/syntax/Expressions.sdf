module Expressions

imports 
	basic/IdentifierCon
         basic/BoolCon
         basic/StrCon
         basic/IntCon
         basic/Areas
         Variables
	Types
         Patterns
         Declarations

hiddens
context-free start-symbols 
	Expression

exports
sorts Expression ExpressionOrPattern LeftHandSide Predicate SimpleGenerator Generator
      Strategy Signature Statement Rule Block Assignment

context-free syntax
         "(" Expression ")"                                      -> Expression {bracket}
         BoolCon                                                 -> Expression {cons("boolcon-exp")}
         IntCon                                                  -> Expression {cons("intcon-exp")}
         StrCon                                                  -> Expression {cons("strcon-exp")}
         Area                                                    -> Expression {cons("areacon-exp")}
	IdCon "(" {Expression ","}* ")"                         -> Expression {cons("fun-call")}
	Variable                                                -> Expression {cons("variable")}

%% A hack to get rid of manu ambiguities
           "true" | "false"                                        -> Variable {reject}
%%         "bool" | "int" | "str" | "loc" | "any" | "term"         -> Variable {reject}

%% Lists, sets and tuples
	"[" {Expression ","}* "]"                               -> Expression {cons("list")}
	"{" {Expression ","}* "}"                               -> Expression {cons("set")}
	"<" {Expression ","}+ ">"                               -> Expression {cons("tuple")}

context-free priorities

%% Closure operators
       {
         Expression "*"                                          -> Expression {cons("trans0")}
         Expression "+"                                          -> Expression {cons("trans1")}
       } >

         Expression "." Variable                                 -> Expression {cons("field")} > 
         Expression "o" Expression                               -> Expression {cons("comp"), left} >
         Expression "x" Expression                               -> Expression {cons("prod"), left} >

%% Set operators
         Expression "inter" Expression                           -> Expression {cons("inter"), left} >
         Expression "union" Expression                           -> Expression {cons("union"), left} >
         Expression "\\" Expression                              -> Expression {cons("diff"), left} >
        "#" Expression                                           -> Expression {cons("size")} >

%% Arithmetic operators

        Expression "*" Expression                                -> Expression {cons("mul"), left} >
        Expression "/" Expression                                -> Expression {cons("div"), left} >
        { Expression "+" Expression                              -> Expression {cons("add"), left}
          Expression "-" Expression                              -> Expression {cons("sub"), left}
        } >
 
%% Relational operators
         {
         Expression "<" Expression                               -> Predicate {cons("less")}
         Expression "<=" Expression                              -> Predicate {cons("less-equal")}
         Expression ">" Expression                               -> Predicate {cons("greater")}
         Expression ">=" Expression                              -> Predicate {cons("greater-equal")}
	Expression "in" Expression                              -> Predicate {cons("element-of")}
	Expression "notin" Expression                           -> Predicate {cons("not-element-of")}
	Expression "==" Expression                              -> Predicate {cons("equal")}
	Expression "!=" Expression                              -> Predicate {cons("not-equal")}
         } >

	"not" Predicate                                         -> Predicate {cons("not")} >
	Predicate "&&" Predicate                                -> Predicate {cons("and")} >
	Predicate "||" Predicate                                -> Predicate {cons("or")} >
         Predicate "==>" Predicate                               -> Predicate {cons("implies")}

context-free syntax
	LeftHandSide ":=" Expression                            -> Predicate {cons("match")}
	LeftHandSide "!:=" Expression                           -> Predicate {cons("not-match")}
         LeftHandSide "<-" Expression                            -> Predicate {cons("assign")}

context-free syntax
%% Image operators 
         Expression "[" Expression "]"                           -> Expression {cons("limage")}
         Expression "[" Expression "," "-" "]"                   -> Expression {cons("limage2")}
         Expression "[-," Expression "]"                         -> Expression {cons("rimage")}

%% Generators
         ("first" | "all")? ("td" | "bu")?                       -> Strategy
	LeftHandSide ":" Strategy Expression                    -> SimpleGenerator {cons("generator")}
	Type Variable                                           -> Signature
	"<" {Signature ","}+ ">"                                -> Signature
         "{" {Signature ","}+ "}"                                -> Signature
         (Signature | QuotedCPattern | APattern)                 -> LeftHandSide
         SimpleGenerator                                         -> Generator
         Predicate                                               -> Generator

%% Comprehensions
	"{" Expression "|" {Generator ","}+ "}"                 -> Expression {cons("set-comprehension")}
	"[" Expression "|" {Generator ","}+ "]"                 -> Expression {cons("list-comprehension")}
         "exists" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("exists")}
         "forall" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("forall")}

	 IdCon "(" {Expression","}* ")"                         -> Predicate {cons("pred-fun-call")}

	"(" Predicate ")"                                       -> Predicate {bracket}

context-free syntax
%% Switch and visit and solve
         Expression | QuotedCPattern | APattern                  -> ExpressionOrPattern

         "case" Pattern ":" Block                                -> Rule
         "default" ":" Block                                     -> Rule
         "case" Pattern "=>" Expression                          -> Rule
%%         Pattern "==>" Pattern                                   -> Rule

 	"switch" Expression "{" Rule+ "}"                       -> Statement
   	"visit" "repeat"? Strategy Expression "{" Rule+ "}"     -> Statement
         "solve" "{" { Assignment ";"}+ "}"                      -> Statement
         "for" "(" {Generator ","}+ ")" Block                    -> Statement

         "if" "(" Predicate ")" Block "else" Block               -> Statement
         "if" "(" Predicate ")" Block                            -> Statement
%% Do we want elseif etc.?

context-free syntax
         Variable "=" ExpressionOrPattern                        -> Assignment {cons("assign")}
         Assignment                                              -> Statement
         Type Variable "=" ExpressionOrPattern                   -> Statement
        "return" Expression                                      -> Statement {cons("return")}
        "return-pat" Pattern                                     -> Statement {cons("return-pat")}
        "yield" Expression                                       -> Statement {cons("yield")}
        "yield-pat" Pattern                                      -> Statement {cons("yield-pat")}
        "assert" StrCon ":" Predicate                            -> Statement {cons("assert")}

        Statement ";"?                                           -> Block
        "{" {Statement ";"}+ ";"? "}"                            -> Block
