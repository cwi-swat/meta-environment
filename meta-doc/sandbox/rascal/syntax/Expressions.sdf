module Expressions

imports  basic/Areas
         Names
         DeclAnnos
	Types
         Patterns
         languages/java/syntax/Lexical [ Identifier => JavaIdentifier
                                         Name       => JavaName
                                       ]
hiddens
context-free start-symbols 
	Expression

exports
sorts Expression Binder Predicate SimpleGenerator Generator Call Assignable
      Strategy Statement Block Rule ARule Case CaseAction Assignment IncrAssignOp Value
      Catch Finally Increment Range FunctionClosure VariableDeclaration Scope OneVarDecl
      Throws ThrowDecl FunctionDeclaration

context-free syntax
%% Basic values
         BooleanLiteral                                          -> Value {cons("boollit")}
         IntegerLiteral                                          -> Value {cons("intlit")}
         FloatingPointLiteral                                    -> Value {cons("floatlit")}
         StringLiteral                                           -> Value {cons("strlit")}
         FunctionClosure                                         -> Value {cons("fun-closure")}
%% TODO include proper locations here
         Area                                                    -> Value {cons("areacon")}

%% Function call
	QualName "(" {Expression ","}* ")"                      -> Call       {con("call")}

%% Expressions
        "(" Expression ")"                                       -> Expression {bracket}

         Value                                                   -> Expression {cons("exp-value")}
	QualName                                                -> Expression {cons("exp-qual-variable")}
         StandardOperator                                        -> Expression {cons("exp-std-op")}
         Call                                                    -> Expression {cons("exp-call")}
         "fun" AnonymousFunctionType Block                       -> Expression {cons("exp-anon-fun")}

%% Lists, sets and tuples
	"[" {Expression ","}* "]"                               -> Expression {cons("exp-list")}
	"{" {Expression ","}* "}"                               -> Expression {cons("exp-set")}
	"<" {Expression ","}+ ">"                               -> Expression {cons("exp-tuple")}

context-free priorities
%% Indexing
         Expression "[" Expression  "]"                          -> Expression {cons("exp-index")} >
%% Field selection
         Expression "." Name                                     -> Expression {cons("exp-field")} >
%% Closure operators
       {
         Expression "*"                                          -> Expression {cons("trans0")}
         Expression "+"                                          -> Expression {cons("trans1")}
       } >

%% Standard operators
   %% multiplication/product
        Expression "*" Expression                                -> Expression {cons("exp-mul"), left} >
   %% intersection
        Expression "&" Expression                                -> Expression {cons("exp-inter"), left} >     
   %% division
        Expression "/" Expression                                -> Expression {cons("exp-div"), left} >
   %% addition/union/concatenation (of tuples, lists and strings)
        { Expression "+" Expression                              -> Expression {cons("exp-add"), left}
   %% subtraction, difference
          Expression "-" Expression                              -> Expression {cons("exp-sub"), left}
        } >
   %% get value of annotation
        Expression "@" Expression                                -> Expression {cons("exp-get-anno"), left} >
 
%% Relational operators
         {
         Expression "<" Expression                               -> Predicate {cons("pred-less")}
         Expression "<=" Expression                              -> Predicate {cons("pred-less-equal")}
         Expression ">" Expression                               -> Predicate {cons("pred-greater")}
         Expression ">=" Expression                              -> Predicate {cons("pred-greater-equal")}
	Expression "in" Expression                              -> Predicate {cons("pred-element-of")}
%%	Expression "notin" Expression                           -> Predicate {cons("pred-not-element-of")}
	Expression "==" Expression                              -> Predicate {cons("pred-equal")}
	Expression "!=" Expression                              -> Predicate {cons("pred-not-equal")}
         Expression "?"  Expression                              -> Predicate {cons("pred-has-anno")}
         } >

	"!" Predicate                                           -> Predicate {cons("pred-not")} >
	Predicate "&&" Predicate                                -> Predicate {left,cons("pred-and")} >
	Predicate "||" Predicate                                -> Predicate {left,cons("pred-or")}

context-free syntax
	Pattern ":=" Expression                                 -> Predicate {cons("pred-match")}
	Pattern "!:=" Expression                                -> Predicate {cons("pred-not-match")}
         Expression                                              -> Predicate {cons("pred-exp")}
	"(" Predicate ")"                                       -> Predicate {bracket}

%% Add , as alternative for &&

context-free syntax
%% Generators
%%         Type Name                                               -> Declarator {cons("decl-type-name")}
%%         StructuredType                                          -> Declarator {cons("decl-struct-type")}
%%         QuotedSynPattern                                        -> Declarator {cons("decl-quotedsynpat")}
%%         AbsPattern                                              -> Declarator {cons("decl-abspat")}
%%         RegPattern                                              -> Declarator {cons("decl-regpat")}

           Pattern                                               -> Binder
           NamedType                                             -> Binder
           "<" {(NamedType | Name) ","}+ ">"                     -> Binder

         ("top-down" | "top-down-break" | 
          "bottom-up" | "bottom-up-break" |
          "outermost" | "innermost")?                            -> Strategy    {cons("strategy")}

         "," Expression ","                                      -> Increment   {cons("increment")}
         "[" Expression Increment? ".." Expression "]"           -> Range       {cons("range")}

	Strategy Binder ":" (Expression | Range)                -> SimpleGenerator {cons("generator")}

         SimpleGenerator                                         -> Generator
         Predicate                                               -> Generator

%% Comprehensions
	"{" Expression "|" {Generator ","}+ "}"                 -> Expression {cons("set-comprehension")}
	"[" Expression "|" {Generator ","}+ "]"                 -> Expression {cons("list-comprehension")}
         "exists" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("exp-exists")}
         "forall" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("exp-forall")}

context-free syntax
%% Conditional Expression
          Predicate "?" Expression ":" Expression                -> Expression {cons("exp-cond")}
%% Cases and Rules
         QuotedSynPattern                                        -> Expression {cons("exp-qpat")}

         "=>" Expression                                         -> CaseAction {cons("case-action-1")}
         ":" Statement                                           -> CaseAction {cons("case-action-2")}

         "case" SynPattern "=>" SynPattern                       -> Case       {cons("case1")}
         "case" SynPattern ":" Statement                         -> Case       {cons("case2")}
         "case" RegPattern CaseAction                            -> Case       {cons("rcase")}
         "acase" AbsPattern CaseAction                           -> Case       {cons("acase")}

          SynPattern "=>" SynPattern                             -> Rule       {cons("rule1")}
          SynPattern ":" Statement                               -> Rule       {cons("rule2")}
          AbsPattern CaseAction                                  -> ARule      {cons("arule")}

         "default" ":" Statement                                 -> Case       {cond("default-case")}

%% Switch, visit, solve, for, if and call statement
 	"switch" "(" Expression ")" "{" Case+ "}"               -> Statement  {cons("stat-switch")}
   	Strategy "visit"  "(" Expression ")" "{" Case+ "}"      -> Statement  {cons("stat-visit")}
         "solve" "{" { Assignment ";"}+ "}"                      -> Statement  {cons("stat-solve")}
         "for" "(" {Generator ","}+ ")" Block                    -> Statement  {cons("stat-for")}
         "while" "(" Predicate ")" Block                         -> Statement  {cons("stat-while")}
         "if" "(" Predicate ")" Block "else" Block               -> Statement  {cons("stat-if-else")}
         "if" "(" Predicate ")" Block                            -> Statement  {cons("stat-if-then")}
         Call  ";"                                               -> Statement  {cons("stat-call")}
         "assert" StringLiteral ":" Predicate ";"                -> Statement  {cons("stat-assert")}

%% Assignment statement
         QualName                                                -> Assignable {cons("asg-qname")}
         QualName "[" Expression "]"                             -> Assignable {cons("asg-index")}
         QualName "." Name                                       -> Assignable {cons("asg-field")}

         "="  | "+=" | "-=" | "*=" | "/="  | "&=" | "|="         -> IncrAssignOp {cons("incr-assignop")}

         Assignable IncrAssignOp Expression                      -> Assignment  {cons("assign")}
         Assignable "@" Expression IncrAssignOp Expression       -> Assignment  {cons("assign-anno")}

         Assignment  ";"                                         -> Statement   {cons("stat-assign")}


         VariableDeclaration                                     -> Statement  {cons("stat-decl-var")}

context-free syntax
%% Return, insert, fail
         "return" Predicate? ";"                                 -> Statement   {cons("stat-return")}
         "insert" Expression ";"                                 -> Statement    {cons("stat-insert")}
         "fail" ";"                                              -> Statement   {cons("stat-fail")}

%% Exception statements
         "throw" Expression ";"                                  -> Statement   {cons("stat-throw")}
         "catch" Pattern? ":" Statement                          -> Catch       {cons("catch")}
         "finally" ":" Statement                                 -> Finally     {cons("finally")}
         "try" Statement Catch* Finally?                         -> Statement   {cons("stat-try")}

%% Statement sequencing and blocks
         "{" Statement* "}"                                      -> Block       {cons("block")}
         Block                                                   -> Statement   {cons("stat-block")}

%% Variable Declaration
         ("global" | "dynamic")?                                 -> Scope
         Name DeclAnnos ("=" Expression)?                        -> OneVarDecl
         Scope Type {OneVarDecl ","}+ ";"                        -> VariableDeclaration {cons("decl-var")}

%% Function Declaration
         ("throws" ThrowDecl)*                                   -> Throws
         Name "(" OptNamedTypes ")"                              -> ThrowDecl
         FunctionType Throws DeclAnnos Block?                    -> FunctionDeclaration {cons("function-decl")}

%% Define reserved words:
         "true" | "false" | "global" | "dynamic" |
         "case" | "acase" | "default" | "switch" | 
         "visit" | "try" | "catch" | "finally" | "solve"  |
         "for" | "while" | "if" | "else" | "return" | "throw" | 
         "throws" | "insert" | "fail" | "assert"                 -> Reserved
