module Expressions

imports 
	basic/IdentifierCon
         basic/BoolCon
         basic/StrCon
         basic/IntCon
         Variables
	Types
         Patterns
         Declarations

hiddens
context-free start-symbols
	Expression

exports
sorts Expression ExpressionOrPattern LeftHandSide Predicate Strategy Signature RewriteCase RewriteCases

context-free syntax
         BoolCon                                                 -> Expression {cons("boolcon-exp")}
         IntCon                                                  -> Expression {cons("intcon-exp")}
         StrCon                                                  -> Expression {cons("strcon-exp")}
	IdCon "(" {ExpressionOrPattern ","}* ")"                -> Expression {cons("fun-call")}
	Variable                                                -> Expression {cons("variable")}
         "#" Expression                                          -> Expression {cons("size-op")}
         Expression "union" Expression                           -> Expression {cons("union-op"), left}
         Expression "\\" Expression                              -> Expression {cons("diff-op")}
         Expression "+" Expression                               -> Expression {cons("add-op"), left}
         Expression "*" Expression                               -> Expression {cons("mul-op")}
         Expression "x" Expression                               -> Expression {cons("prod-op")}
         Expression "[" Expression "]"                           -> Expression {cons("limage-op")}
         Expression "[-," Expression "]"                         -> Expression {cons("rimage-op")}
         Expression "." Variable                                 -> Expression {cons("field-op")}

         "(" Expression ")"                                      -> Expression {bracket}
         %% and all other operators ...

context-free syntax
	"[" {Expression ","}* "]"                               -> Expression {cons("list")}
	"{" {Expression ","}* "}"                               -> Expression {cons("set")}
	"<" {Expression ","}+ ">"                               -> Expression {cons("tuple")}

context-free syntax
        ("first" | "all")? ("td" | "bu")?                        -> Strategy
	Strategy LeftHandSide ":" Expression                    -> Predicate {cons("generator")}
	Type? Variable                                          -> Signature
	"<" {Signature ","}+ ">"                                -> Signature
         "{" {Signature ","}+ "}"                                -> Signature
         (Signature | Pattern)                                   -> LeftHandSide

context-free syntax
	"{" Expression "|" {Predicate ","}+ "}"                 -> Expression {cons("set-comprehension")}
	"[" Expression "|" {Predicate ","}+ "]"                 -> Expression {cons("list-comprehension")}
         Expression                                              -> Predicate
	Expression "==" Expression                              -> Predicate {cons("equal")}
	Expression "!=" Expression                              -> Predicate {cons("non-equal")}
	LeftHandSide ":=" Expression                            -> Predicate {cons("match")}
	LeftHandSide "!:=" Expression                           -> Predicate {cons("non-match")}
         LeftHandSide "<-" Expression                            -> Predicate {cons("assign")}
	Expression "in" Expression                              -> Predicate {cons("element-of")}
	Expression "notin" Expression                           -> Predicate {cons("not-element-of")}

         Expression ">" Expression                               -> Predicate {cons("greater")}

	"(" Predicate ")"                                       -> Predicate {bracket}

context-free priorities
	"not" Predicate                                         -> Predicate {cons("not")} >
	Predicate "&" Predicate                                 -> Predicate {cons("and")} >
	Predicate "|" Predicate                                 -> Predicate {cons("or")}

context-free syntax
         "if" Predicate "then" Expression "else" Expression "fi" -> Expression
%% Do we want elseif etc.?

context-free syntax
        Expression | Pattern                                     -> ExpressionOrPattern

   	Pattern "=>" ExpressionOrPattern ("when" {Predicate ","}+ )?      -> RewriteCase
   	"{" RewriteCase+ "}"                                     -> RewriteCases

   	"switch" Expression RewriteCases                         -> Expression
   	"replace" Expression Strategy RewriteCases               -> Expression
