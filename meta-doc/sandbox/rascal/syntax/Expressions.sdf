module Expressions

imports  basic/Areas
         Names
         DeclarationAnnotations
	Types
         Patterns
         languages/java/syntax/Lexical [ Identifier => JavaIdentifier
                                         Name       => JavaName
                                       ]
exports
  sorts BasicExpression Expression Predicate ValueProducer Generator Call Assignable Selector
      Strategy Statement Block Rule Case Assignment AssignmentOperator Value TypeConstraint
      Catch Finally FunctionClosure VariableDeclaration Scope SingleVariableDeclaration
      Throws ThrowDeclaration FunctionDeclaration RuleDeclaration Upperbound

  context-free syntax
%% Basic values
    BooleanLiteral                                    -> Value {cons("BooleanValue")}
    IntegerLiteral                                    -> Value {cons("IntegerValue")}
    FloatingPointLiteral                              -> Value {cons("DoubleValue")}

    "#" Name                                          -> StringLiteral {cons("HashQuotedStringLiteral")}
    StringLiteral                                     -> Value {cons("StringLiteral")}

    FunctionClosure                                   -> Value {cons("FunctionClosureValue")}
%% TODO include proper locations here
    Area                                              -> Value {cons("AreaValue")}
    "fun" AnonymousFunctionType Block                 -> Value {cons("AnonymousFunctionValue")}

    Value                                             -> Expression {cons("ValueExpression")}

%% Lists, sets and tuples
    "[" {Expression ","}* "]"                         -> Expression {cons("ListExpression")}
    "[" Expression ".." Expression "]"                -> Expression {cons("Range1Expression")}
    "[" Expression "," Expression ",.." Expression "]"-> Expression {cons("Range2Expression")}

    "{" {Expression ","}* "}"                         -> Expression {cons("SetExpression")}
    "<" {Expression ","}+ ">"                         -> Expression {cons("TupleExpression")}

    "<" Expression "->" Expression ">"                -> Expression {cons("MapTupleExpression")}


%% Selectors and assignable expressions
    "." Name                                          -> Selector        {cons("FieldSelector")}
    "[" Expression "]"                                -> Selector        {cons("IndexSelector")}

    QualName Selector*  ("?" Expression)?             -> Assignable      {cons("Assignable")}

    QualName                                          -> BasicExpression {cons("QNameBasicExpression")}
    StandardOperator                                  -> BasicExpression {cons("StandardOperatorBasicExpression")}
    BasicExpression Selector                          -> BasicExpression {cons("SelectBasicExpression")}

%% Function call
    BasicExpression "(" {Expression ","}* ")"         -> Call            {con("Call")}
    Call                                              -> BasicExpression {cons("CallBasicExpression")}

    BasicExpression                                   -> Expression      {cons("BasicExpressionExpression")}
 
%% Expressions
       
    "(" Expression ")"                                -> Expression {bracket}

  context-free priorities

%% Closure operators
  {
    Expression "*"                                    -> Expression {cons("Closure0Expression")}
    Expression "+"                                    -> Expression {cons("Closure1Expression")}
  } >

%% Standard operators
    Expression "*" Expression                         -> Expression {cons("MultiplicationExpression"), left} >
    Expression "&" Expression                         -> Expression {cons("IntersectionExpression"), left} >     
    Expression "/" Expression                         -> Expression {cons("DivideExpression"), left} >
    { 
    Expression "|" Expression                         -> Expression {cons("UnionExpression"), left}
    Expression "+" Expression                         -> Expression {cons("AddExpression"), left}
    Expression "-" Expression                         -> Expression {cons("SubtractExpression"), left}
    } >

    Expression "@" Name                               -> Expression {cons("GetAnnnotationExpression")} >
 
%% Relational operators
    {
    Expression "<" Expression                         -> Predicate {cons("LessPredicate")}
    Expression "<=" Expression                        -> Predicate {cons("LessEqualPredicate")}
    Expression ">" Expression                         -> Predicate {cons("GreaterPredicate")}
    Expression ">=" Expression                        -> Predicate {cons("GreaterEqualPredicate")}
    Expression "in" Expression                        -> Predicate {cons("ElementOfPredicate")}
    Expression "notin" Expression                     -> Predicate {cons("NotElementOfPredicate")}
    Expression "==" Expression                        -> Predicate {cons("EqualPredicate")}
    Expression "!=" Expression                        -> Predicate {cons("NotEqualPredicate")}
    } >

    "!" Predicate                                     -> Predicate {cons("NotPredicate")} >
    Predicate "&&" Predicate                          -> Predicate {left,cons("AndPredicate")} >
    Predicate "||" Predicate                          -> Predicate {left,cons("OrPredicate")}

  context-free syntax
    Pattern "~~" Expression                           -> Predicate {cons("MatchPredicate")}
    Pattern "!~" Expression                           -> Predicate {cons("NoMatchPredicate")}
    Expression                                        -> Predicate {cons("ExpressionPredicate")}
    "(" Predicate ")"                                 -> Predicate {bracket}

%% TODO: Add , as alternative for &&

  context-free syntax
%% Generators

    ("top-down"  | "top-down-break"  | 
     "bottom-up" | "bottom-up-break" |
     "outermost" | "innermost"       )?               -> Strategy      {cons("Strategy")}

    Strategy Pattern ":" Expression                   -> ValueProducer {cons("ValueProducer")}

    ValueProducer                                     -> Generator {cons("ValueProducerGenerator")}
    Predicate                                         -> Generator {cons("PredicateGenerator")}

%% Comprehensions
    "{" Expression "|" {Generator ","}+ "}"           -> Expression {cons("SetComprehension")}
    "[" Expression "|" {Generator ","}+ "]"           -> Expression {cons("ListComprehension")}
    "exists" "(" ValueProducer "|" Predicate ")"      -> Expression {cons("ExistsExpression")}
    "forall" "(" ValueProducer "|" Predicate ")"      -> Expression {cons("ForallExpression")}

  context-free syntax
%% Conditional Expression
    Predicate "?" Expression ":" Expression           -> Expression {cons("ConditionalExpression")}
%% Cases and Rules
    QuotedSyntaxPattern                               -> Expression {cons("QuotedSyntaxExpression")}

    SyntaxPattern   "=>" SyntaxPattern                -> Rule       {cons("SyntaxRule")}
    AbstractPattern "=>" (AbstractPattern | 
                          PatternVariable)            -> Rule       {cons("AbstractRule")}
    RegExpPattern   "=>" (StringLiteral |
                          PatternVariable)            -> Rule       {cons("RexExpRule")}
    Pattern ":" Statement                             -> Rule       {cons("PatternRule")}

    "[" Type "]"                                      -> TypeConstraint
                                                                    {cons("TypeConstraint")}

    "case" TypeConstraint? Rule                       -> Case       {cons("Case")}
    "default" ":" Statement                           -> Case       {cond("DefaultCase")}

    Strategy "visit" "(" Expression ")" "{" Case+ "}" -> Expression  {cons("VisitExpression")}

%% Statements
    Expression  ";"                                   -> Statement  {cons("ExpressionStatement")}

%% Switch, solve, for, if and call statement
    "switch" "(" Expression ")" "{" Case+ "}"         -> Statement  {cons("SwitchStatement")}

    "(" Expression ")"                                -> Upperbound
    "solve" Upperbound? "{" { Assignment ";"}+ "}"    -> Statement  {cons("SolveStatement")}
    "for" "(" {Generator ","}+ ")" Block              -> Statement  {cons("ForStatement")}
    "while" "(" Predicate ")" Block                   -> Statement  {cons("WhileStatement")}
    "if" "(" Predicate ")" Block "else" Block         -> Statement  {cons("IfElseStatement")}
    "if" "(" Predicate ")" Block                      -> Statement  {cons("IfThenStatement")}
 
    "assert" StringLiteral ":" Predicate ";"          -> Statement  {cons("AssertStatement")}

%% Assignment statement

    "="  | "+=" | "-=" | "*=" | "/="  | "&=" | "|="   -> AssignmentOperator {cons("AssignmentOperator")}

    {Assignable ","}+ AssignmentOperator 
                      {Expression ","}+               -> Assignment  {cons("Assignment")} 
    Assignable "@" Expression AssignmentOperator 
                      Expression                      -> Assignment  {cons("AnnotationAssignment")}

    Assignment  ";"                                   -> Statement   {cons("AssignmentStatement")}

    VariableDeclaration ";"                           -> Statement   {cons("VariableDeclarationStatement")}

%% Return, insert, fail
    "return" Predicate? ";"                           -> Statement   {cons("ReturnStatement")}
    "insert" Expression ";"                           -> Statement   {cons("InsertStatement")}
    "fail" ";"                                        -> Statement   {cons("FailStatement")}

%% Exception statements
    "throw" Expression ";"                            -> Statement   {cons("ThrowStatement")}
    "catch" Pattern? ":" Statement                    -> Catch       {cons("Catch")}
    "finally" ":" Statement                           -> Finally     {cons("Finally")}
    "try" Statement Catch* Finally?                   -> Statement   {cons("TryStatement")}

%% Statement sequencing and blocks
    "{" Statement* "}"                                -> Block       {cons("Block")}
    Block                                             -> Statement   {cons("BlockStatement")}

%% Expression-related declarations
%% Variable Declaration
    ("global" | "dynamic")?                           -> Scope       {cons("Scope")}
         
    Name DeclarationAnnotations ("=" Expression)?     -> SingleVariableDeclaration
                                                                             {cons("SingleVariableDeclaration")}
    Scope Type {SingleVariableDeclaration ","}+       -> VariableDeclaration {cons("VariableDeclaration")}

%% Function Declaration
    ("throws" ThrowDeclaration)*                      -> Throws              {cons("Throws")}
    Name "(" OptNamedTypes ")"                        -> ThrowDeclaration    {cons("ThrowDeclaration")}

    FunctionType Throws DeclarationAnnotations Block? -> FunctionDeclaration {cons("FunctionDeclaration")}

%% Rule Declarations 
    "rule" TypeConstraint? Name 
           DeclarationAnnotations Rule                -> RuleDeclaration     {cons("RuleDeclaration")}

%% Reserved words:
    "true"   | "false"   | "global"  | "dynamic" |
    "case"   | "default" | "switch"  | "in"      |
    "notin"  |
    "visit"  | "try"     | "catch"   | "finally" | 
    "solve"  | "for"     | "while"   | "if"      | 
    "else"   | "return"  | "throw"   | "throws"  |
    "insert" | "fail"    | "assert"  | "rule"         -> Reserved
