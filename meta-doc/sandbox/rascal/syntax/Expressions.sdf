module Expressions

imports 
	basic/IdentifierCon
         basic/BoolCon
         basic/StrCon
         basic/IntCon
         basic/Areas
         Variables
	Types
         Patterns
         Declarations

hiddens
context-free start-symbols 
	Expression

exports
sorts Expression LeftHandSide Predicate SimpleGenerator Generator FieldSelection Callable Call
      Strategy Signature Statement Rule Assignment AssignOp Value AbstractValue
      Catch Finally

context-free syntax
%% Basic values
         BoolCon                                                 -> Value {cons("boolcon-exp")}
         IntCon                                                  -> Value {cons("intcon-exp")}
         StrCon                                                  -> Value {cons("strcon-exp")}
         Area                                                    -> Value {cons("areacon-exp")}

%% Abstract values used for datatypes
         Value                                                   -> AbstractValue
         Variable                                                -> AbstractValue
         Variable "(" {AbstractValue ","}* ")"                   -> AbstractValue
         "[" {AbstractValue ","}* "]"                            -> AbstractValue
         "{" {AbstractValue ","}* "}"                            -> AbstractValue
         "<" {AbstractValue ","}+ ">"                            -> AbstractValue

%% Expressions
         Value                                                   -> Expression
        "(" Expression ")"                                       -> Expression {bracket}
	Variable                                                -> Expression {cons("variable")}

         Variable ("." Variable)+                                -> FieldSelection
         FieldSelection                                          -> Expression

         Variable | FieldSelection                               -> Callable

	Callable "(" {Expression ","}* ")"                      -> Call {cons("fun-or-map-call")}
         Callable "{" Expression  "}"                            -> Call {cons("multi-map-call")}
         Call                                                    -> Expression

%% Lists, sets and tuples
	"[" {Expression ","}* "]"                               -> Expression {cons("list")}
	"{" {Expression ","}* "}"                               -> Expression {cons("set")}
	"<" {Expression ","}+ ">"                               -> Expression {cons("tuple")}

context-free priorities

%% Closure operators
       {
         Expression "*"                                          -> Expression {cons("trans0")}
         Expression "+"                                          -> Expression {cons("trans1")}
       } >

%%         Expression "." Variable                                 -> Expression {cons("field")} > 
         Expression "o" Expression                               -> Expression {cons("comp"), left} >
         Expression "x" Expression                               -> Expression {cons("prod"), left} >

%% Set operators
        "#" Expression                                           -> Expression {cons("size")} >

%% Arithmetic operators
   %% multiplication/intersection
        Expression "*" Expression                                -> Expression {cons("mul"), left} >
   %% division
        Expression "/" Expression                                -> Expression {cons("div"), left} >
   %% addition/union/concatenation
        { Expression "+" Expression                              -> Expression {cons("add"), left}
   %% subtraction/difference
          Expression "-" Expression                              -> Expression {cons("sub"), left}
        } >
 
%% Relational operators
         {
         Expression "<" Expression                               -> Predicate {cons("less")}
         Expression "<=" Expression                              -> Predicate {cons("less-equal")}
         Expression ">" Expression                               -> Predicate {cons("greater")}
         Expression ">=" Expression                              -> Predicate {cons("greater-equal")}
	Expression "in" Expression                              -> Predicate {cons("element-of")}
	Expression "notin" Expression                           -> Predicate {cons("not-element-of")}
	Expression "==" Expression                              -> Predicate {cons("equal")}
	Expression "!=" Expression                              -> Predicate {cons("not-equal")}
         } >

	"not" Predicate                                         -> Predicate {cons("not")} >
	Predicate "and" Predicate                               -> Predicate {left,cons("and")} >
	Predicate "or" Predicate                                -> Predicate {left,cons("or")} >
         Predicate "implies" Predicate                           -> Predicate {cons("implies")}

context-free syntax
	LeftHandSide ":=" Expression                            -> Predicate {cons("match")}
	LeftHandSide "!:=" Expression                           -> Predicate {cons("not-match")}
%%         LeftHandSide "<-" Expression                            -> Predicate {cons("match-assign")}
	IdCon "(" {Expression","}* ")"                          -> Predicate {cons("pred-fun-call")}
	"(" Predicate ")"                                       -> Predicate {bracket}

context-free syntax
%% Generators
         ("top-down" | "top-down-break" | 
          "bottom-up" | "bottom-up-break" |
          "outermost" | "innermost")?                            -> Strategy
	LeftHandSide ":" Strategy Expression                    -> SimpleGenerator {cons("generator")}
	Type Variable                                           -> Signature
	"<" {Signature ","}+ ">"                                -> Signature
         "{" {Signature ","}+ "}"                                -> Signature
         Signature | SynPattern | AbsPattern |RegPattern         -> LeftHandSide
         
         SimpleGenerator                                         -> Generator
         Predicate                                               -> Generator

%% Comprehensions
	"{" Expression "|" {Generator ","}+ "}"                 -> Expression {cons("set-comprehension")}
	"[" Expression "|" {Generator ","}+ "]"                 -> Expression {cons("list-comprehension")}
         "exists" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("exists")}
         "forall" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("forall")}

context-free syntax
%% Rules, Switch, visit and solve
          QuotedSynPattern                                       -> Expression
         "make" Pattern                                          -> Expression

         "case" Pattern ":" Statement                            -> Rule
         "default" ":" Statement                                 -> Rule
         "case" Pattern "=>" Expression                          -> Rule

 	"switch" Expression "{" Rule+ "}"                       -> Statement
   	"visit" "repeat"? Strategy Expression "{" Rule+ "}"     -> Statement
         "solve" "{" { Assignment ";"}+ "}"                      -> Statement
         "for" "(" {Generator ","}+ ")" Statement                -> Statement

         "if" "(" Predicate ")" Statement "else" Statement       -> Statement
         "if" "(" Predicate ")" Statement                        -> Statement
%% Do we want elseif etc.?

          "=" | "+=" | "-=" | "*=" | "/="                        -> AssignOp

         Expression                                              -> Statement
         (Variable | Call) AssignOp Expression                   -> Assignment {cons("assign")}
         LeftHandSide "=" Expression                             -> Statement
         "global" Type Variable ("=" Expression)?                -> Statement
         "return" Expression?                                    -> Statement {cons("return")}
         "yield" Expression                                      -> Statement {cons("yield")}
         "fail"                                                  -> Statement {cons("fail")}
         "throw" Expression                                      -> Statement {cons("throw")}
         "assert" StrCon ":" Predicate                           -> Statement {cons("assert")}

         "try" Statement Catch* Finally?                        -> Statement
         "catch" Pattern ":" Statement                          -> Catch
         "finally" ":" Statement                                -> Finally

         "{" {Statement ";"}+ ";"? "}"                           -> Statement

%% Define reserved words:
%%         "o" | "x" | 
         "true" | "false" |
         "and" | "or" | "implies" | "global" | 
         "make" | "case" | "default" | "switch" | "visit" | 
         "try" | "catch" | "finally" |
         "solve"  | "for" | "if" | "else" | "return" | "throw" |
         "yield" | "fail" | "assert"                             -> Variable {reject}
