module Expressions

imports  basic/Areas
         Names
         DeclarationAnnotations
	Types
         Patterns
         languages/java/syntax/Lexical [ Identifier => JavaIdentifier
                                         Name       => JavaName
                                       ]
exports
  sorts BasicExpression Expression Binder Predicate SimpleGenerator Generator Call Assignable Selector
      Strategy Statement Block Rule Case Assignment IncrAssignOp Value TypeConstraint
      Catch Finally FunctionClosure VariableDeclaration Scope SingleVariableDeclaration
      Throws ThrowDeclaration FunctionDeclaration RuleDeclaration Upperbound

  context-free syntax
%% Basic values
    BooleanLiteral                                    -> Value {cons("boollit")}
    IntegerLiteral                                    -> Value {cons("intlit")}
    FloatingPointLiteral                              -> Value {cons("floatlit")}

    "#" Name                                          -> StringLiteral {cons("hash-quoted-strlit")}
    StringLiteral                                     -> Value {cons("strlit")}

    FunctionClosure                                   -> Value {cons("fun-closure")}
%% TODO include proper locations here
    Area                                              -> Value {cons("areacon")}
    "fun" AnonymousFunctionType Block                 -> Value {cons("anon-fun")}

    Value                                             -> Expression {cons("exp-value")}

%% Lists, sets and tuples
    "[" {Expression ","}* "]"                         -> Expression {cons("exp-list")}
    "[" Expression ".." Expression "]"                -> Expression {cons("exp-range1")}
    "[" Expression "," Expression ",.." Expression "]"-> Expression {cons("exp-range2")}

    "{" {Expression ","}* "}"                         -> Expression {cons("exp-set")}
    "<" {Expression ","}+ ">"                         -> Expression {cons("exp-tuple")}

    "<" Expression "->" Expression ">"                -> Expression {cons("exp-mtuple")}


%% Selectors and assignable expressions
    "." Name                                          -> Selector        {cons("sel-field")}
    "[" Expression "]"                                -> Selector        {cons("sel-index")}

    QualName Selector*                                -> Assignable      {cons("asg-select")}
    "<" {Assignable ","}+ ">"                         -> Assignable      {cons("asg-tuple")}

    QualName                                          -> BasicExpression {cons("bexp-qname")}
    StandardOperator                                  -> BasicExpression {cons("bexp-std-op")}
    BasicExpression Selector                          -> BasicExpression {cons("bexp-select")}

%% Function call
    BasicExpression "(" {Expression ","}* ")"         -> Call            {con("call")}
    Call                                              -> BasicExpression {cons("exp-call")}

    BasicExpression                                   -> Expression
 
%% Expressions
       
    "(" Expression ")"                                -> Expression {bracket}

  context-free priorities

%% Closure operators
  {
    Expression "*"                                    -> Expression {cons("closure0")}
    Expression "+"                                    -> Expression {cons("closure1")}
  } >

%% Standard operators
   %% multiplication/product
    Expression "*" Expression                         -> Expression {cons("exp-mul"), left} >
   %% intersection
    Expression "&" Expression                         -> Expression {cons("exp-inter"), left} >     
   %% division
    Expression "/" Expression                         -> Expression {cons("exp-div"), left} >
   %% addition/union/concatenation (of tuples, lists and strings)
    { 
    Expression "|" Expression                         -> Expression {cons("exp-union"), left}
    Expression "+" Expression                         -> Expression {cons("exp-add"), left}
   %% subtraction, difference
    Expression "-" Expression                         -> Expression {cons("exp-sub"), left}
    } >
   %% get value of annotation
    Expression "@" Name                               -> Expression {cons("exp-get-anno")} >
 
%% Relational operators
    {
    Expression "<" Expression                         -> Predicate {cons("pred-less")}
    Expression "<=" Expression                        -> Predicate {cons("pred-less-equal")}
    Expression ">" Expression                         -> Predicate {cons("pred-greater")}
    Expression ">=" Expression                        -> Predicate {cons("pred-greater-equal")}
    Expression "in" Expression                        -> Predicate {cons("pred-element-of")}
    Expression "notin" Expression                     -> Predicate {cons("pred-not-element-of")}
    Expression "==" Expression                        -> Predicate {cons("pred-equal")}
    Expression "!=" Expression                        -> Predicate {cons("pred-not-equal")}
    } >

    "!" Predicate                                     -> Predicate {cons("pred-not")} >
    Predicate "&&" Predicate                          -> Predicate {left,cons("pred-and")} >
    Predicate "||" Predicate                          -> Predicate {left,cons("pred-or")}

  context-free syntax
    Binder ":=" Expression                            -> Predicate {cons("pred-match")}
    Binder "!:=" Expression                           -> Predicate {cons("pred-not-match")}
    Expression                                        -> Predicate {cons("pred-exp")}
    "(" Predicate ")"                                 -> Predicate {bracket}

%% TODO: Add , as alternative for &&

  context-free syntax
%% Generators
    Pattern                                           -> Binder
    NamedType                                         -> Binder
    "<" {(NamedType | Name) ","}+ ">"                 -> Binder

    ("top-down"  | "top-down-break"  | 
     "bottom-up" | "bottom-up-break" |
     "outermost" | "innermost"       )?               -> Strategy    {cons("strategy")}

    Strategy Binder ":" Expression                    -> SimpleGenerator {cons("generator")}

    SimpleGenerator                                   -> Generator
    Predicate                                         -> Generator

%% Comprehensions
    "{" Expression "|" {Generator ","}+ "}"           -> Expression {cons("set-comprehension")}
    "[" Expression "|" {Generator ","}+ "]"           -> Expression {cons("list-comprehension")}
    "exists" "(" SimpleGenerator "|" Predicate ")"    -> Expression {cons("exp-exists")}
    "forall" "(" SimpleGenerator "|" Predicate ")"    -> Expression {cons("exp-forall")}

  context-free syntax
%% Conditional Expression
    Predicate "?" Expression ":" Expression           -> Expression {cons("exp-cond")}
%% Cases and Rules
    QuotedSyntaxPattern                               -> Expression {cons("exp-qpat")}

    SyntaxPattern   "=>" SyntaxPattern                -> Rule       {cons("conrule")}
    AbstractPattern "=>" (AbstractPattern | 
                          PatternVariable)            -> Rule       {cons("absrule")}
    RegExpPattern   "=>" (StringLiteral |
                          PatternVariable)            -> Rule       {cons("regrule")}
    Pattern ":" Statement                             -> Rule       {cons("patrule")}

    "[" Type "]"                                      -> TypeConstraint
                                                                    {cons("type-constraint")}

    "case" TypeConstraint? Rule                       -> Case       {cons("case")}
    "default" ":" Statement                           -> Case       {cond("default-case")}

    Strategy "visit" "(" Expression ")" "{" Case+ "}" -> Expression  {cons("stat-visit")}

%% Statements
    Expression  ";"                                   -> Statement  {cons("stat-exp")}

%% Switch, solve, for, if and call statement
    "switch" "(" Expression ")" "{" Case+ "}"         -> Statement  {cons("stat-switch")}

    "(" Expression ")"                                -> Upperbound
    "solve" Upperbound? "{" { Assignment ";"}+ "}"    -> Statement  {cons("stat-solve")}
    "for" "(" {Generator ","}+ ")" Block              -> Statement  {cons("stat-for")}
    "while" "(" Predicate ")" Block                   -> Statement  {cons("stat-while")}
    "if" "(" Predicate ")" Block "else" Block         -> Statement  {cons("stat-if-else")}
    "if" "(" Predicate ")" Block                      -> Statement  {cons("stat-if-then")}
 
    "assert" StringLiteral ":" Predicate ";"          -> Statement  {cons("stat-assert")}

%% Assignment statement

    "="  | "+=" | "-=" | "*=" | "/="  | "&=" | "|="   -> IncrAssignOp {cons("incr-assignop")}

    Assignable IncrAssignOp Expression                -> Assignment  {cons("assign")}
    Assignable "@" Expression IncrAssignOp Expression -> Assignment  {cons("assign-anno")}

    Assignment  ";"                                   -> Statement   {cons("stat-assign")}

    VariableDeclaration ";"                           -> Statement   {cons("stat-decl-var")}

%% Return, insert, fail
    "return" Predicate? ";"                           -> Statement   {cons("stat-return")}
    "insert" Expression ";"                           -> Statement   {cons("stat-insert")}
    "fail" ";"                                        -> Statement   {cons("stat-fail")}

%% Exception statements
    "throw" Expression ";"                            -> Statement   {cons("stat-throw")}
    "catch" Pattern? ":" Statement                    -> Catch       {cons("catch")}
    "finally" ":" Statement                           -> Finally     {cons("finally")}
    "try" Statement Catch* Finally?                   -> Statement   {cons("stat-try")}

%% Statement sequencing and blocks
    "{" Statement* "}"                                -> Block       {cons("block")}
    Block                                             -> Statement   {cons("stat-block")}

%% Expression-related declarations
%% Variable Declaration
    ("global" | "dynamic")?                           -> Scope       {cons("scope")}
         
    Name DeclarationAnnotations ("=" Expression)?     -> SingleVariableDeclaration
                                                                             {cons("single-vardecl")}
    Scope Type {SingleVariableDeclaration ","}+       -> VariableDeclaration {cons("vardecl")}

%% Function Declaration
    ("throws" ThrowDeclaration)*                      -> Throws              {cons("throws")}
    Name "(" OptNamedTypes ")"                        -> ThrowDeclaration    {cons("throwdecl")}

    FunctionType Throws DeclarationAnnotations Block? -> FunctionDeclaration {cons("function-decl")}

%% Rule Declarations 
    "rule" TypeConstraint? Name 
           DeclarationAnnotations Rule                -> RuleDeclaration     {cons("rule-decl")}

%% Reserved words:
    "true"   | "false"   | "global"  | "dynamic" |
    "case"   | "default" | "switch"  | "in"      |
    "notin"  |
    "visit"  | "try"     | "catch"   | "finally" | 
    "solve"  | "for"     | "while"   | "if"      | 
    "else"   | "return"  | "throw"   | "throws"  |
    "insert" | "fail"    | "assert"  | "rule"         -> Reserved
