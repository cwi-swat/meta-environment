module Expressions

imports  basic/Areas
         Names
	Types
         Patterns
         languages/java/syntax/Lexical [ Identifier => JavaIdentifier
                                         Name       => JavaName
                                       ]
hiddens
context-free start-symbols 
	Expression

exports
sorts Expression Declarator Predicate SimpleGenerator Generator Call Assignable
      Strategy Statement Block Rule ARule Case CaseAction Assignment IncrAssignOp Value
      Catch Finally Increment Range FunctionClosure

context-free syntax
%% Basic values
         BooleanLiteral                                          -> Value {cons("boollit")}
         IntegerLiteral                                          -> Value {cons("intlit")}
         FloatingPointLiteral                                    -> Value {cons("floatlit")}
         StringLiteral                                           -> Value {cons("strlit")}
         FunctionClosure                                         -> Value {cons("fun-closure")}
%% TODO include proper locations here
         Area                                                    -> Value {cons("areacon")}

%% Function call
	QualName "(" {Expression ","}* ")"                      -> Call       {con("call")}

%% Expressions
        "(" Expression ")"                                       -> Expression {bracket}

         Value                                                   -> Expression {cons("exp-value")}
	QualName                                                -> Expression {cons("exp-qual-variable")}
         StandardOperator                                        -> Expression {cons("exp-std-op")}
         Call                                                    -> Expression {cons("exp-call")}
         "fun" AnonymousFunctionType Block                       -> Expression {cons("exp-anon-fun")}

%% Lists, sets and tuples
	"[" {Expression ","}* "]"                               -> Expression {cons("exp-list")}
	"{" {Expression ","}* "}"                               -> Expression {cons("exp-set")}
	"<" {Expression ","}+ ">"                               -> Expression {cons("exp-tuple")}

context-free priorities
%% Indexing
         Expression "[" Expression  "]"                          -> Expression {cons("exp-index")} >
%% Field selection
         Expression "." Name                                     -> Expression {cons("exp-field")} >
%% Closure operators
       {
         Expression "*"                                          -> Expression {cons("trans0")}
         Expression "+"                                          -> Expression {cons("trans1")}
       } >

%% Standard operators
   %% multiplication/product
        Expression "*" Expression                                -> Expression {cons("exp-mul"), left} >
   %% intersection
        Expression "&" Expression                                -> Expression {cons("exp-inter"), left} >     
   %% division
        Expression "/" Expression                                -> Expression {cons("exp-div"), left} >
   %% addition/union/concatenation (of tuples, lists and strings)
        { Expression "+" Expression                              -> Expression {cons("exp-add"), left}
   %% subtraction, difference
          Expression "-" Expression                              -> Expression {cons("exp-sub"), left}
        } >
   %% get value of annotation
        Expression "@" Expression                                -> Expression {cons("exp-get-anno"), left} >
 
%% Relational operators
         {
         Expression "<" Expression                               -> Predicate {cons("pred-less")}
         Expression "<=" Expression                              -> Predicate {cons("pred-less-equal")}
         Expression ">" Expression                               -> Predicate {cons("pred-greater")}
         Expression ">=" Expression                              -> Predicate {cons("pred-greater-equal")}
	Expression "in" Expression                              -> Predicate {cons("pred-element-of")}
	Expression "notin" Expression                           -> Predicate {cons("pred-not-element-of")}
	Expression "==" Expression                              -> Predicate {cons("pred-equal")}
	Expression "!=" Expression                              -> Predicate {cons("pred-not-equal")}
         Expression "?"  Expression                              -> Predicate {cons("pred-has-anno")}
         } >

	"!" Predicate                                           -> Predicate {cons("pred-not")} >
	Predicate "&&" Predicate                                -> Predicate {left,cons("pred-and")} >
	Predicate "||" Predicate                                -> Predicate {left,cons("pred-or")}
%%         Predicate "->" Predicate                                -> Predicate {cons("pred-implies")}

context-free syntax
	Declarator ":=" Expression                              -> Predicate {cons("pred-match")}
	Declarator "!:=" Expression                             -> Predicate {cons("pred-not-match")}
         Expression                                              -> Predicate {cons("pred-exp")}
	"(" Predicate ")"                                       -> Predicate {bracket}

context-free syntax
%% Generators
         Type Name                                               -> Declarator {cons("decl-type-name")}
         StructuredType                                          -> Declarator {cons("decl-struct-type")}
         SynPattern                                              -> Declarator {cons("decl-synpat")}
         RegPattern                                              -> Declarator {cons("decl-regpat")}

         ("top-down" | "top-down-break" | 
          "bottom-up" | "bottom-up-break" |
          "outermost" | "innermost")?                            -> Strategy    {cons("strategy")}

         "," Expression ","                                      -> Increment   {cons("increment")}
         "[" Expression Increment? ".." Expression "]"           -> Range       {cons("range")}

	Declarator ":" Strategy (Expression | Range)            -> SimpleGenerator {cons("generator")}

         SimpleGenerator                                         -> Generator
         Predicate                                               -> Generator

%% Comprehensions
	"{" Expression "|" {Generator ","}+ "}"                 -> Expression {cons("set-comprehension")}
	"[" Expression "|" {Generator ","}+ "]"                 -> Expression {cons("list-comprehension")}
         "exists" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("exp-exists")}
         "forall" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("exp-forall")}

context-free syntax
%% Conditional Expression
          Predicate "?" Expression ":" Expression                -> Expression {cons("exp-cond")}
%% Cases and Rules
         QuotedSynPattern                                        -> Expression {cons("exp-qpat")}

         "=>" Expression                                         -> CaseAction {cons("case-action-1")}
         ":" Statement                                           -> CaseAction {cons("case-action-2")}

         "case" SynPattern "=>" SynPattern                       -> Case       {cons("case1")}
         "case" SynPattern ":" Statement                         -> Case       {cons("case2")}
         "case" RegPattern CaseAction                            -> Case       {cons("rcase")}
         "acase" AbsPattern CaseAction                           -> Case       {cons("acase")}

          SynPattern "=>" SynPattern                             -> Rule       {cons("rule1")}
          SynPattern ":" Statement                               -> Rule       {cons("rule2")}
          AbsPattern CaseAction                                  -> ARule      {cons("arule")}

         "default" ":" Statement                                 -> Case       {cond("default-case")}

%% Switch, visit, solve, for, if and call statement
 	"switch" Expression "{" Case+ "}"                       -> Statement  {cons("stat-switch")}
   	"visit" Strategy Expression "{" Case+ "}"               -> Statement  {cons("stat-visit")}
         "solve" "{" { Assignment ";"}+ "}"                      -> Statement  {cons("stat-solve")}
         "for" "(" {Generator ","}+ ")" Block                    -> Statement  {cons("stat-for")}
         "while" "(" Predicate ")" Block                         -> Statement  {cons("stat-while")}
         "if" "(" Predicate ")" Block "else" Block               -> Statement  {cons("stat-if-else")}
         "if" "(" Predicate ")" Block                            -> Statement  {cons("stat-if-then")}
         Call  ";"                                               -> Statement  {cons("stat-call")}
         "assert" StringLiteral ":" Predicate ";"                -> Statement  {cons("stat-assert")}

%% Assignment statement
         QualName                                                -> Assignable {cons("asg-qname")}
         QualName "[" Expression "]"                             -> Assignable {cons("asg-index")}
         QualName "." Name                                       -> Assignable {cons("asg-field")}

         "="  | "+=" | "-=" | "*=" | "/="  | "&="                -> IncrAssignOp {cons("incr-assignop")}

         Assignable IncrAssignOp Expression                      -> Assignment  {cons("assign")}
         Assignable "@" Expression IncrAssignOp Expression       -> Assignment  {cons("assign-anno")}

         Assignment  ";"                                         -> Statement   {cons("stat-assign")}

%% Declaration statements
         Declarator  "=" Expression ";"                          -> Statement   {cons("varinit")}
         "global" Type Name ("=" Expression)? ";"                -> Statement   {cons("-stat-global")}

%% Return, replace-by, fail
         "return" Predicate? ";"                                 -> Statement   {cons("stat-return")}
         "replace-by" Expression ";"                             -> Statement   {cons("stat-replace-by")}
         "fail" ";"                                              -> Statement   {cons("stat-fail")}

%% Exception statements
         "throw" Expression ";"                                  -> Statement   {cons("stat-throw")}
         "catch" Pattern? ":" Statement                          -> Catch       {cons("catch")}
         "finally" ":" Statement                                 -> Finally     {cons("finally")}
         "try" Statement Catch* Finally?                         -> Statement   {cons("stat-try")}

%% Statement sequencing and blocks
         "{" Statement* "}"                                      -> Block       {cons("block")}
         Block                                                   -> Statement   {cons("stat-block")}

%% Define reserved words:
         "true" | "false" |
         "not" | "and" | "or" | "implies" | "global" | 
         "case" | "acase" | "rcase" | "default" | "switch" | 
         "visit" | "try" | "catch" | "finally" | "solve"  |
         "for" | "while" | "if" | "else" | "return" | "throw" |
         "replace-by" | "fail" | "assert"                       -> Name {reject}
