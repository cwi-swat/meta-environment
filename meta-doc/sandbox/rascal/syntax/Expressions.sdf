module Expressions

imports 
	basic/IdentifierCon
         basic/BoolCon
         basic/StrCon
         basic/IntCon
         basic/Areas
         Variables
	Types
         Patterns
         Declarations

hiddens
context-free start-symbols 
	Expression

exports
sorts Expression LeftHandSide Predicate SimpleGenerator Generator
      Strategy Signature Statement Rule Assignment AssignOp

context-free syntax
         "(" Expression ")"                                      -> Expression {bracket}
         BoolCon                                                 -> Expression {cons("boolcon-exp")}
         IntCon                                                  -> Expression {cons("intcon-exp")}
         StrCon                                                  -> Expression {cons("strcon-exp")}
         Area                                                    -> Expression {cons("areacon-exp")}
	Variable "(" {Expression ","}* ")"                      -> Expression {cons("fun-map-call")}
         Variable "{" Expression "}"                             -> Expression {cons("multi-map-call")}
	Variable                                                -> Expression {cons("variable")}

%% Lists, sets and tuples
	"[" {Expression ","}* "]"                               -> Expression {cons("list")}
	"{" {Expression ","}* "}"                               -> Expression {cons("set")}
	"<" {Expression ","}+ ">"                               -> Expression {cons("tuple")}

context-free priorities

%% Closure operators
       {
         Expression "*"                                          -> Expression {cons("trans0")}
         Expression "+"                                          -> Expression {cons("trans1")}
       } >

         Expression "." Variable                                 -> Expression {cons("field")} > 
         Expression "o" Expression                               -> Expression {cons("comp"), left} >
         Expression "x" Expression                               -> Expression {cons("prod"), left} >

%% Set operators
%%         Expression "inter" Expression                           -> Expression {cons("inter"), left} >
%%         Expression "union" Expression                           -> Expression {cons("union"), left} >
%%         Expression "\\" Expression                              -> Expression {cons("diff"), left} >
        "#" Expression                                           -> Expression {cons("size")} >

%% Arithmetic operators
   %% multiplication/intersection
        Expression "*" Expression                                -> Expression {cons("mul"), left} >
   %% division
        Expression "/" Expression                                -> Expression {cons("div"), left} >
   %% addition/union/concatenation
        { Expression "+" Expression                              -> Expression {cons("add"), left}
   %% subtraction/difference
          Expression "-" Expression                              -> Expression {cons("sub"), left}
        } >
 
%% Relational operators
         {
         Expression "<" Expression                               -> Predicate {cons("less")}
         Expression "<=" Expression                              -> Predicate {cons("less-equal")}
         Expression ">" Expression                               -> Predicate {cons("greater")}
         Expression ">=" Expression                              -> Predicate {cons("greater-equal")}
	Expression "in" Expression                              -> Predicate {cons("element-of")}
	Expression "notin" Expression                           -> Predicate {cons("not-element-of")}
	Expression "==" Expression                              -> Predicate {cons("equal")}
	Expression "!=" Expression                              -> Predicate {cons("not-equal")}
         } >

	"not" Predicate                                         -> Predicate {cons("not")} >
	Predicate "and" Predicate                               -> Predicate {left,cons("and")} >
	Predicate "or" Predicate                                -> Predicate {left,cons("or")} >
         Predicate "implies" Predicate                           -> Predicate {cons("implies")}

context-free syntax
	LeftHandSide ":=" Expression                            -> Predicate {cons("match")}
	LeftHandSide "!:=" Expression                           -> Predicate {cons("not-match")}
         LeftHandSide "<-" Expression                            -> Predicate {cons("match-assign")}

context-free syntax
%% Image operators 
         Expression "[" Expression "]"                           -> Expression {cons("limage")}
         Expression "[" Expression "," "-" "]"                   -> Expression {cons("limage2")}
         Expression "[-," Expression "]"                         -> Expression {cons("rimage")}

%% Generators
         ("first" | "all")? ("td" | "bu")?                       -> Strategy
	LeftHandSide ":" Strategy Expression                    -> SimpleGenerator {cons("generator")}
	Type Variable                                           -> Signature
	"<" {Signature ","}+ ">"                                -> Signature
         "{" {Signature ","}+ "}"                                -> Signature
         Signature | CPattern | APattern                         -> LeftHandSide
         
         SimpleGenerator                                         -> Generator
         Predicate                                               -> Generator

%% Comprehensions
	"{" Expression "|" {Generator ","}+ "}"                 -> Expression {cons("set-comprehension")}
	"[" Expression "|" {Generator ","}+ "]"                 -> Expression {cons("list-comprehension")}
         "exists" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("exists")}
         "forall" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("forall")}

	 IdCon "(" {Expression","}* ")"                         -> Predicate {cons("pred-fun-call")}

	"(" Predicate ")"                                       -> Predicate {bracket}

context-free syntax
%% Switch and visit and solve
          QuotedCPattern                                         -> Expression
         "make" CPattern                                         -> Expression
         "make" APattern                                         -> Expression

         "case" Pattern ":" Statement                            -> Rule
         "default" ":" Statement                                 -> Rule
         "case" Pattern "=>" Expression                          -> Rule

 	"switch" Expression "{" Rule+ "}"                       -> Statement
   	"visit" "repeat"? Strategy Expression "{" Rule+ "}"     -> Statement
         "solve" "{" { Assignment ";"}+ "}"                      -> Statement
         "for" "(" {Generator ","}+ ")" Statement                -> Statement

         "if" "(" Predicate ")" Statement "else" Statement       -> Statement
         "if" "(" Predicate ")" Statement                        -> Statement
%% Do we want elseif etc.?
          "=" | "+=" | "-=" | "*=" | "/="                        -> AssignOp

         Expression                                              -> Statement
         Variable AssignOp Expression                            -> Assignment {cons("assign")}
         LeftHandSide "=" Expression                             -> Statement
         "global" Type Variable ("=" Expression)?                -> Statement
         "return" Expression?                                    -> Statement {cons("return")}
         "yield" Expression                                      -> Statement {cons("yield")}
         "fail"                                                  -> Statement {cons("fail")}
         "assert" StrCon ":" Predicate                           -> Statement {cons("assert")}

         "{" {Statement ";"}+ ";"? "}"                           -> Statement

%% Define reserved words:
%%         "o" | "x" | 
         "true" | "false" |
         "and" | "or" | "implies" | "global" | 
         "make" | "case" | "default" | "switch" | "visit" | 
         "solve"  | "for" | "if" | "else" | "return" |
         "yield" | "fail" | "assert"                             -> Variable {reject}
