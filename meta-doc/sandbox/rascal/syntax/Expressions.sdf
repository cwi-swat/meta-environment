module Expressions

imports  basic/Areas
         Names
	Types
         Patterns
         languages/java/syntax/Lexical [ Identifier => JavaIdentifier
                                         Name       => JavaName
                                       ]
hiddens
context-free start-symbols 
	Expression

exports
sorts Expression Declarator Predicate SimpleGenerator Generator Call Callable
      Strategy Statement Rule ARule Case CaseAction Assignment IncrAssignOp Value
      Catch Finally

context-free syntax
%% Basic values
         BooleanLiteral                                          -> Value {cons("boollit-exp")}
         IntegerLiteral                                          -> Value {cons("intlit-exp")}
         FloatingPointLiteral                                    -> Value {cons("floatlit-exp")}
         StringLiteral                                           -> Value {cons("strlit-exp")}
         Area                                                    -> Value {cons("areacon-exp")}

%% Expressions
         Value                                                   -> Expression
         "(" Expression ")"                                      -> Expression {bracket}

	QualName                                                -> Expression {cons("qual-variable")}
         StandardOperator                                        -> Expression {cons("std-op")}

         QualName | Call                                         -> Callable

	Callable "(" {Expression ","}* ")"                      -> Call {cons("fun-or-map-call")}
         Callable "[" Expression  "]"                            -> Call {cons("index-call")}
         Call                                                    -> Expression
         Call "." Name                                           -> Expression

         AnonymousFunctionType Statement                         -> Expression

%% Lists, sets and tuples
	"[" {Expression ","}* "]"                               -> Expression {cons("list")}
	"{" {Expression ","}* "}"                               -> Expression {cons("set")}
	"<" {Expression ","}+ ">"                               -> Expression {cons("tuple")}

context-free priorities

%% Closure operators
       {
         Expression "*"                                          -> Expression {cons("trans0")}
         Expression "+"                                          -> Expression {cons("trans1")}
       } >

%% Arithmetic operators
   %% multiplication/intersection
        Expression "*" Expression                                -> Expression {cons("mul"), left} >
   %% division
        Expression "/" Expression                                -> Expression {cons("div"), left} >
   %% addition/union/concatenation (of tuples, lists and strings)
        { Expression "+" Expression                              -> Expression {cons("add"), left}
   %% subtraction/difference
          Expression "-" Expression                              -> Expression {cons("sub"), left}
        } >
 
%% Relational operators
         {
         Expression "<" Expression                               -> Predicate {cons("less")}
         Expression "<=" Expression                              -> Predicate {cons("less-equal")}
         Expression ">" Expression                               -> Predicate {cons("greater")}
         Expression ">=" Expression                              -> Predicate {cons("greater-equal")}
	Expression "in" Expression                              -> Predicate {cons("element-of")}
	Expression "notin" Expression                           -> Predicate {cons("not-element-of")}
	Expression "==" Expression                              -> Predicate {cons("equal")}
	Expression "!=" Expression                              -> Predicate {cons("not-equal")}
         } >

	"not" Predicate                                         -> Predicate {cons("not")} >
	Predicate "and" Predicate                               -> Predicate {left,cons("and")} >
	Predicate "or" Predicate                                -> Predicate {left,cons("or")} >
         Predicate "implies" Predicate                           -> Predicate {cons("implies")}

context-free syntax
	Declarator ":=" Expression                              -> Predicate {cons("match")}
	Declarator "!:=" Expression                             -> Predicate {cons("not-match")}
         Call                                                    -> Predicate
	"(" Predicate ")"                                       -> Predicate {bracket}

context-free syntax
%% Generators
         Type Name                                               -> Declarator
         StructuredType                                          -> Declarator
         "@" AbstractType                                        -> Declarator
         SynPattern                                              -> Declarator
         (Name "~=")? RegPattern                                 -> Declarator

         ("top-down" | "top-down-break" | 
          "bottom-up" | "bottom-up-break" |
          "outermost" | "innermost")?                            -> Strategy

	Declarator ":" Strategy Expression                      -> SimpleGenerator {cons("generator")}

         SimpleGenerator                                         -> Generator
         Predicate                                               -> Generator

%% Comprehensions
	"{" Expression "|" {Generator ","}+ "}"                 -> Expression {cons("set-comprehension")}
	"[" Expression "|" {Generator ","}+ "]"                 -> Expression {cons("list-comprehension")}
         "exists" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("exists")}
         "forall" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("forall")}

context-free syntax
%% Rules, Switch, visit and solve
         QuotedSynPattern                                        -> Expression

         "=>" Expression                                         -> CaseAction
         ":" Statement                                           -> CaseAction

         "case"  SynPattern "=>" SynPattern                      -> Case       {cons("case1")}
         "case" SynPattern ":" Statement                         -> Case       {cons("case2")}
         "acase" AbsPattern CaseAction                           -> Case       {cons("acase")}
         "rcase" (Name "~=")? RegPattern CaseAction              -> Case       {cons("rcase")}

          SynPattern "=>" SynPattern                             -> Rule       {cons("rule1")}
          SynPattern ":" Statement                               -> Rule       {cons("rule2")}
          AbsPattern CaseAction                                  -> ARule       {cons("arule")}

         "default" ":" Statement                                 -> Case       {cond("default-case")}

 	"switch" Expression "{" Case+ "}"                       -> Statement  {cons("switch")}
   	"visit" Strategy Expression "{" Case+ "}"               -> Statement  {cons("visit")}
         "solve" "{" { Assignment ";"}+ "}"                      -> Statement  {cons("solve")}
         "for" "(" {Generator ","}+ ")" Statement                -> Statement  {cons("for")}

         "if" "(" Predicate ")" Statement "else" Statement       -> Statement  {cons("if-else")}
         "if" "(" Predicate ")" Statement                        -> Statement  {cons("if-then")}
%% Do we want elseif etc.?

         "="  | "+=" | "-=" | "*=" | "/="                        -> IncrAssignOp {cons("incr-assignop")}

         Expression                                              -> Statement

         Callable IncrAssignOp Expression                        -> Assignment {cons("assign")}
         Assignment                                              -> Statement

         Declarator  "=" Expression                              -> Statement  {cons("varinit")}
         "global" Type Name "=" Expression                       -> Statement  {cons("global")}
         "return" Expression?                                    -> Statement  {cons("return-exp")}
         "return" Predicate                                      -> Statement  {avoid, cons("return-pred")}
         "yield" Expression                                      -> Statement  {cons("yield")}
         "fail"                                                  -> Statement  {cons("fail")}
         "throw" Expression                                      -> Statement  {cons("throw")}
         "assert" StringLiteral ":" Predicate                    -> Statement  {cons("assert")}

         "try" Statement Catch* Finally?                         -> Statement  {cons("try")}
         "catch" Pattern ":" Statement                           -> Catch      {cons("catch")}
         "finally" ":" Statement                                 -> Finally    {cons("finally")}

         "{" {Statement ";"}+ ";"? "}"                           -> Statement  {cons("block")}

%% Define reserved words:
         "true" | "false" |
         "not" | "and" | "or" | "implies" | "global" | 
         "case" | "acase" | "rcase" | "default" | "switch" | 
         "visit" | "try" | "catch" | "finally" | "solve"  |
         "for" | "if" | "else" | "return" | "throw" |
         "yield" | "fail" | "assert"                             -> Name {reject}
