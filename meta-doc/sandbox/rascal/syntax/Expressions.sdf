module Expressions

imports 
	basic/IdentifierCon
         basic/BoolCon
         basic/StrCon
         basic/IntCon
         basic/Areas
         Variables
	Types
         Patterns
         Declarations

hiddens
context-free start-symbols 
	Expression

exports
sorts Expression DeclLeftHandSide Predicate SimpleGenerator Generator FieldSelection Callable Call
      Strategy Statement Rule Case Assignment IncrAssignOp Value AbstractValue
      Catch Finally

context-free syntax
%% Basic values
         BoolCon                                                 -> Value {cons("boolcon-exp")}
         IntCon                                                  -> Value {cons("intcon-exp")}
         StrCon                                                  -> Value {cons("strcon-exp")}
         Area                                                    -> Value {cons("areacon-exp")}

%% Abstract values used for datatypes
         Value                                                   -> AbstractValue
         PatternVar                                              -> AbstractValue
         Variable                                                -> AbstractValue
         Variable "(" {AbstractValue ","}* ")"                   -> AbstractValue
         "[" {AbstractValue ","}* "]"                            -> AbstractValue
         "{" {AbstractValue ","}* "}"                            -> AbstractValue
         "<" {AbstractValue ","}+ ">"                            -> AbstractValue

%% Expressions
         Value                                                   -> Expression
        "(" Expression ")"                                       -> Expression {bracket}
	Variable                                                -> Expression {cons("variable")}

         Callable ("." Variable)+                                -> FieldSelection
         FieldSelection                                          -> Expression

         Variable | FieldSelection | Call                        -> Callable

	Callable "(" {Expression ","}* ")"                      -> Call {cons("fun-or-map-call")}
         Callable "{" Expression  "}"                            -> Call {cons("multi-map-call")}
         Call                                                    -> Expression

%% Lists, sets and tuples
	"[" {Expression ","}* "]"                               -> Expression {cons("list")}
	"{" {Expression ","}* "}"                               -> Expression {cons("set")}
	"<" {Expression ","}+ ">"                               -> Expression {cons("tuple")}

context-free priorities

%% Closure operators
       {
         Expression "*"                                          -> Expression {cons("trans0")}
         Expression "+"                                          -> Expression {cons("trans1")}
       } >

%%         Expression "." Variable                               -> Expression {cons("field")} > 
         Expression "o" Expression                               -> Expression {cons("comp"), left} >
         Expression "x" Expression                               -> Expression {cons("prod"), left} >

%% Set operators
        "#" Expression                                           -> Expression {cons("size")} >

%% Arithmetic operators
   %% multiplication/intersection
        Expression "*" Expression                                -> Expression {cons("mul"), left} >
   %% division
        Expression "/" Expression                                -> Expression {cons("div"), left} >
   %% addition/union/concatenation
        { Expression "+" Expression                              -> Expression {cons("add"), left}
   %% subtraction/difference
          Expression "-" Expression                              -> Expression {cons("sub"), left}
        } >
 
%% Relational operators
         {
         Expression "<" Expression                               -> Predicate {cons("less")}
         Expression "<=" Expression                              -> Predicate {cons("less-equal")}
         Expression ">" Expression                               -> Predicate {cons("greater")}
         Expression ">=" Expression                              -> Predicate {cons("greater-equal")}
	Expression "in" Expression                              -> Predicate {cons("element-of")}
	Expression "notin" Expression                           -> Predicate {cons("not-element-of")}
	Expression "==" Expression                              -> Predicate {cons("equal")}
	Expression "!=" Expression                              -> Predicate {cons("not-equal")}
         } >

	"not" Predicate                                         -> Predicate {cons("not")} >
	Predicate "and" Predicate                               -> Predicate {left,cons("and")} >
	Predicate "or" Predicate                                -> Predicate {left,cons("or")} >
         Predicate "implies" Predicate                           -> Predicate {cons("implies")}

context-free syntax
	DeclLeftHandSide ":=" Expression                        -> Predicate {cons("match")}
	DeclLeftHandSide "!:=" Expression                       -> Predicate {cons("not-match")}
%%       DeclLeftHandSide "<-" Expression                        -> Predicate {cons("match-assign")}
	IdCon "(" {Expression","}* ")"                          -> Predicate {cons("pred-fun-call")}
	"(" Predicate ")"                                       -> Predicate {bracket}

context-free syntax
%% Generators
         ("top-down" | "top-down-break" | 
          "bottom-up" | "bottom-up-break" |
          "outermost" | "innermost")?                            -> Strategy
	DeclLeftHandSide ":" Strategy Expression                -> SimpleGenerator {cons("generator")}
         Type Variable                                           -> DeclLeftHandSide
         StructuredType                                          -> DeclLeftHandSide
         AbstractType                                            -> DeclLeftHandSide
         SynPattern                                              -> DeclLeftHandSide
         AbsPattern                                              -> DeclLeftHandSide
         RegPattern                                              -> DeclLeftHandSide
         
         SimpleGenerator                                         -> Generator
         Predicate                                               -> Generator

%% Comprehensions
	"{" Expression "|" {Generator ","}+ "}"                 -> Expression {cons("set-comprehension")}
	"[" Expression "|" {Generator ","}+ "]"                 -> Expression {cons("list-comprehension")}
         "exists" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("exists")}
         "forall" "(" SimpleGenerator "|" Predicate ")"          -> Expression {cons("forall")}

context-free syntax
%% Rules, Switch, visit and solve
          QuotedSynPattern                                       -> Expression
         "make" Pattern                                          -> Expression

          Pattern "=>" Expression                                -> Rule       {cons("rule1")}
          Pattern ":" Statement                                  -> Rule       {cons("rule1")}
          
         "case" Rule                                             -> Case       {cons("case")}
         "default" ":" Statement                                 -> Case       {cond("default-case")}

 	"switch" Expression "{" Case+ "}"                       -> Statement  {cons("switch")}
   	"visit" Strategy Expression "{" Case+ "}"               -> Statement  {cons("visit")}
         "solve" "{" { Assignment ";"}+ "}"                      -> Statement  {cons("solve")}
         "for" "(" {Generator ","}+ ")" Statement                -> Statement  {cons("for")}

         "if" "(" Predicate ")" Statement "else" Statement       -> Statement  {cons("if-else")}
         "if" "(" Predicate ")" Statement                        -> Statement  {cons("if-then")}
%% Do we want elseif etc.?

         "+=" | "-=" | "*=" | "/="                               -> IncrAssignOp {cons("incr-assignop")}

         Expression                                              -> Statement
         (Variable | Call) IncrAssignOp Expression               -> Assignment {cons("assign")}
         (DeclLeftHandSide | Variable | Call) "=" Expression     -> Statement  {cons("assignment")}
         "global" Type Variable ("=" Expression)?                -> Statement  {cons("global")}
         "return" Expression?                                    -> Statement  {cons("return")}
         "yield" Expression                                      -> Statement  {cons("yield")}
         "fail"                                                  -> Statement  {cons("fail")}
         "throw" Expression                                      -> Statement  {cons("throw")}
         "assert" StrCon ":" Predicate                           -> Statement  {cons("assert")}

         "try" Statement Catch* Finally?                         -> Statement  {cons("try")}
         "catch" Pattern ":" Statement                           -> Catch      {cons("catch")}
         "finally" ":" Statement                                 -> Finally    {cons("finally")}

         "{" {Statement ";"}+ ";"? "}"                           -> Statement  {cons("block")}

%% Define reserved words:
%%         "o" | "x" | 
         "true" | "false" |
         "and" | "or" | "implies" | "global" | 
         "make" | "case" | "default" | "switch" | "visit" | 
         "try" | "catch" | "finally" |
         "solve"  | "for" | "if" | "else" | "return" | "throw" |
         "yield" | "fail" | "assert"                             -> Variable {reject}
