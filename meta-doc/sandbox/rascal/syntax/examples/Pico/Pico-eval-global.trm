module Pico-eval

import-syntax pico/syntax/Pico;

type int PICO_VALUE;
type str PICO_VALUE;

type map[PICO_ID, PICO_VALUE] VEnv;

fun void evalProgram(PROGRAM P){
    switch P {
      case begin <DECLS Decls> <{STATEMENT ";"}* Series> end: {
          evalDecls(Decls);
          evalStatements(Series);
      }
   }
};

fun void assign(PICO_ID Id, PICO_VALUE V){
  global Venv Env;
  Env(Id) = V;
  return;
}

fun PICO_VALUE valueOf(PICO_ID Id){
  global Venv Env;
  return Env(Id); 
}

fun VEnv evalDecls(DECLS Decls){
    global VEnv Env = {};
    visit Decls {
      case <PICO-ID Id> : string:  assign(Id, "")
      case <PICO-ID Id> : natural: assign(Id, 0)
    }
}

fun void evalStatements({STATEMENT ";"}* Series){
    global VEnv Env;
    switch Series {
      case <STATEMENT Stat>; <{STATEMENT ";"}* Series2>: {
        evalStatement(Stat);
        evalStatements(Series2);
        return
      }
      case [| |]: return
    }
}

fun void evalStatement(STATEMENT Stat){
    global VEnv Env;
    switch Stat {
      case [| <PICO_ID Id> = <EXP Exp> |]: {
        PICO_VALUE Val = evalExp(Exp);
        assign(Id, Val);
        return
      }

      case if <EXP Exp> then <{STATEMENT ";"}* Stats1> 
                   else <{STATEMENT ";"}* Stats1> fi:{
        PICO_VALUE Val = evalExp(Exp);
        if(Val != 0) {
          evalStatements(Stats1);
          return
        } else {
          evalStatements(Stats2);
          return
        }
      }

      case while <EXP Exp> do <{STATEMENT ";"}* Stats1> od:{
        PICO_VALUE Val = evalExp(Exp);
        if(Val != 0)
          return
        else {
          evalStatements(Stats1);
          evalStatement(Stat);
          return
        }
      }
    };
};

fun PICO_VALUE evalExp(Exp exp) {
    global VEnv Env;
    switch exp {
      case <NatCon N>: return N

      case <StrCon S>: return S

      case <PICO-ID Id>: return valueOf(Id)

      case <EXP exp1> + <EXP exp2>: {
           Natural nat1 = evalExp(exp1);
           Natural nat2 = evalExp(exp2);
           return nat1 + nat2;
      }
      case <EXP exp1> - <EXP exp2>: {
           Natural nat1 = evalExp(exp1);
           Natural nat2 = evalExp(exp2);
           return nat1 + nat2;
      }
      case <EXP exp1> || <EXP exp2>: {
           StrCon str1 = evalExp(exp1);
           StrCon str2 = evalExp(exp2);
           return concat(str1, str2);
      }
   } 
}
