module Pico-reaching-defs

type tuple[Stat theStat, Var theVar] Def;
type tuple[Stat theStat, Var theVar] Use;

fun set[Stat] predecessor(rel[Stat,Stat] P, Stat S) { 
    return invert(P)(S)
}

fun set[Stat] successor(rel[Stat,Stat] P, Stat S) { 
    return P(S)
}

fun rel[Stat, Def] reaching-definitions(rel[Stat,Var] DEFS, 
                                        rel[Stat,Stat] PRED) {

    set[Stat] STATEMENT = carrier(PRED);

    rel[Stat,Def] DEF  = {<S,<S,V>> | tuple[Stat S, Var V]: DEFS};

    rel[Stat,Def] KILL = 
        {<S1, <S2, V>> | tuple[Stat S1, Var V] : DEFS, 
                         tuple[Stat S2, V] : DEFS, 
                         S1 != S2
        };

     rel[Stat,Def] IN = {};
     rel[Stat,Def] OUT = DEF;

     solve {
           IN  =  {<S, D> | int S : STATEMENT, 
                            Stat P : predecessor(PRED,S), 
                            Def D : OUT{P}};
           OUT =  {<S, D> | int S : STATEMENT, 
                            Def D : DEF{S} +  (IN{S} - KILL{S})}
    };
    return IN;
}