module Typecheck

imports Pico-syntax
imports Errors

type Env = rel[PICO-ID,TYPE];

fun list[Error] tcp(PROGRAM P) {
    switch P {
      begin <DECLS Decls> <{STATEMENT ";"}* Series> end: {
        Env Env = {<Id, Type> | <PICO-ID Id> : <TYPE Type> : Decls};
        return [ tcst(S, Env) | Stat S : Series ]     %% list comprehension
      }
    };
}

fun list[Error] tcst(Stat Stat, Env Env) {
    switch Stat {
      [| <PICO-ID Id> = <EXP Exp> |]: {
        {<Id, Type>} = Env[Id];
        return type-of(Exp, Type, Env);
      }

      if <EXP Exp> then <{STATEMENT ";"}* Stats1> 
                   else <{STATEMENT ";"}* Stats1> fi:
        return type-of(Exp, natural, Env) + 
               tcs(Stats1, Env) + tcs(Stats2, Env);

      while <EXP Exp> do <{STATEMENT ";"}* Stats1> od: 
        yield type-of(Exp, natural, Env) + tcs(Stats, Env);
    };
}

fun list[Error] type-of(Exp E, TYPE Type, Env Env) {
    switch E {
      <NatCon N>: if(Type == natural){ return []; }

      <StrCon S>: if(Type == string) { return []; }

      <PICO-ID Id>: {
        {<Id,Type2>} = Env[Id];
        if(Type2 == Type) { return []; }
      }

      <EXP E1> + <EXP E2>:
        if(Type == natural){
           return type-of(E1, natural, Env) + 
                  type-of(E1, natural, Env);
        }

      <EXP E1> + <EXP E2>:
        if(Type == natural){
           return type-of(E1, natural, Env) + 
                  type-of(E1, natural, Env);
        }

      <EXP E1> || <EXP E2> => 
        if(Type == string){
          return type-of(E1, string, Env) + 
                 type-of(E1, string, Env)
        }
    
      <EXP Exp>: return [error("Incorrect type")];
    };
}