module Typecheck

imports Pico-syntax
imports Errors

type Env = rel[PICO-ID,TYPE];

fun list[Error] tcp(PROGRAM P) {
    switch P {
    begin <DECLS Decls> <{STATEMENT ";"}* Series> end =>
           [ tcst(S, Env) | Stat S : Series ]     %% list comprehension
       when Env Env := {<Id, Type> | 
                        <PICO-ID Id> : <TYPE Type> : Decls}
    };
}

fun list[Error] tcst(Stat Stat, Env Env) {
    switch Stat {
    <PICO-ID Id> := <EXP Exp> => type-of(Exp, Type, Env)
       when {<Id, Type>} := Env[Id]

    if <EXP Exp> then <{STATEMENT ";"}* Stats1> 
                 else <{STATEMENT ";"}* Stats1> fi =>
           type-of(Exp, natural, Env) + 
           tcs(Stats1, Env) + tcs(Stats2, Env)

    while <EXP Exp> do <{STATEMENT ";"}* Stats1> od =>
           type-of(Exp, natural, Env) + tcs(Stats, Env)
    };
}

fun list[Error] type-of(Exp E, TYPE Type, Env Env) {
    switch E {
    <NatCon N> => []
       when Type == natural

    <StrCon S> => []
       when Type == string

    <PICO-ID Id> => [] 
       when {<Id,Type2>} := Env[Id],
            Type2 == Type

    <EXP E1> + <EXP E2>  => type-of(E1, natural, Env) + 
                            type-of(E1, natural, Env)
       when Type == natural

    <EXP E1> + <EXP E2>  => type-of(E1, natural, Env) + 
                            type-of(E1, natural, Env)
       when Type == natural

    <EXP E1> || <EXP E2> => type-of(E1, string, Env) + 
                            type-of(E1, string, Env)
       when Type == string
    
    <EXP Exp> => [error("Incorrect type")]
    };
}