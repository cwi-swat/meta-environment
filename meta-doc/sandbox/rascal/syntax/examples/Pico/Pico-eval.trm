module Pico-eval
import-syntax pico/syntax/Pico;

type int PICO_VALUE;
type str PICO_VALUE;

type map[PICO_ID, PICO_VALUE] VEnv;

fun VEnv evalProgram(PROGRAM P){
    switch P {
      case begin <DECLS Decls> <{STATEMENT ";"}* Series> end: {
          VEnv Env = evalDecls(Decls);
          return evalStatements(Series, Env);
      }
   }
};

fun VEnv assign(VEnv Env, PICO_ID Id, PICO_VALUE V){
  Env(Id) = V;
  return Env
}

fun PICO_VALUE valueOf(VEnv Env, PICO_ID Id){
  return Env(Id);
}

fun VEnv evalDecls(DECLS Decls){
    VEnv Env = {};
    visit Decls {
      case <PICO_ID Id> : string:  Env = assign(Env, Id, "")
      case <PICO_ID Id> : natural: Env = assign(Env, Id, 0)
    }
}

fun VEnv evalStatements({STATEMENT ";"}* Series, VEnv Env){
    switch Series {
      case <STATEMENT Stat>; <{STATEMENT ";"}* Series2>: {
        Env Env2 = evalStatement(Stat, Env);
        return evalStatements(Series2, Env2);
      }
      case [| |]: return Env
    }
}

fun VEnv evalStatement(STATEMENT Stat, VEnv Env){
    switch Stat {
      case [| <PICO_ID Id> = <EXP Exp> |]: {
        PICO_VALUE Val = evalExp(Exp, Env);
        return assign(Env, Id, Val)
      }

      case if <EXP Exp> then <{STATEMENT ";"}* Stats1> 
                   else <{STATEMENT ";"}* Stats1> fi:{
        PICO_VALUE Val = evalExp(Exp, Env);
        if(Val != 0)
          return evalStatments(Stats1, Env)
        else 
          return evalStatements(Stats2, Env)

      }

      case while <EXP Exp> do <{STATEMENT ";"}* Stats1> od:{
        PICO_VALUE Val = evalExp(Exp, Env);
        if(Val != 0)
          return Env
        else {
          VEnv Env2 = evalStatements(Stats1, Env);
          return evalStatement(Stat, Env2)
        }
      }
    };
};

fun PICO_VALUE evalExp(Exp exp, VEnv Env) {
    switch exp {
      case <NatCon N>: return N

      case <StrCon S>: return S

      case <PICO-ID Id>: return valueOf(Env, Id)

      case <EXP exp1> + <EXP exp2>: {
           Natural nat1 = evalExp(exp1, Env);
           Natural nat2 = evalExp(exp2, Env);
           return nat1 + nat2;
      }
      case <EXP exp1> - <EXP exp2>: {
           Natural nat1 = evalExp(exp1, Env);
           Natural nat2 = evalExp(exp2, Env);
           return nat1 + nat2;
      }
      case <EXP exp1> || <EXP exp2>: {
           StrCon str1 = evalExp(exp1, Env);
           StrCon str2 = evalExp(exp2, Env);
           return concat(str1, str2);
      }
   } 
}
