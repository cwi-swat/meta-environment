module AsFix

datatype ParseTree parsetree(Tree top, int amb-cnt);

datatype Tree appl(Production prod, Args args);
datatype Tree cycle(Symbol symbol, int cycle-length);
datatype Tree amb(Args args);

%% constructor(Tree, char, <character(int)>), %%??
subtype Tree int;

subtype Args list[Tree];

datatype Production prod(Symbols lhs, Symbol rhs, Attributes attributes);
 
%% constructor(Production, List, list(<rhs(Symbol)>)), 
subtype Production list(Symbol rhs);

datatype Attributes no-attrs;
datatype Attributes attrs(Attrs attrs);

subtype Attrs list[Attr];

datatype Attr assoc(Associativity assoc) | %% term(term term) |
             id(str module-name) | bracket | reject | prefer | avoid;

datatype Associativity left | right | assoc | non-assoc;

datatype Symbol lit(str string);
datatype Symbol cilit(str string);
datatype Symbol cf(Symbol symbol);
datatype Symbol lex(Symbol symbol);
datatype Symbol empty;
datatype Symbol seq(Symbols symbols);
datatype Symbol opt(Symbol symbol);
datatype Symbol alt(Symbol lhs, Symbol rhs);
datatype Symbol tuple(Symbol head, Symbols rest);
datatype Symbol sort (str string); 
datatype Symbol iter-plus(Symbol symbol); 
datatype Symbol iter-star(Symbol symbol); 
datatype Symbol iter-plus-sep(Symbol symbol, Symbol separator); 
datatype Symbol iter-start-sep(Symbol symbol, Symbol separator); 
datatype Symbol iter-n(Symbol symbol, int number); 
datatype Symbol iter-sep-n(Symbol symbol, Symbol separator, int number); 
datatype Symbol func(Symbols symbols, Symbol symbol); 
datatype Symbol parameterized-sort(str sort, Symbols parameters); 
datatype Symbol strategy(Symbol lhs, Symbol rhs);
datatype Symbol var-sym(Symbol symbol);
datatype Symbol layout; 
datatype Symbol char-class(CharRanges ranges);

subtype Symbols list[Symbol];

%% constructor(CharRange, character, <start(int)>), 
subtype CharRange int;
datatype CharRange range(int start, int end);

datatype CharRanges list(CharRange);

fun str join(list[&T] lst, fun str tostring (&T arg), str asep){ 
    str res = "";
    str sep = "";
    for(&T t : lst){
         res = sep + tostring(t);
         sep = asep;
      };
     return res;
}

fun str yieldTree(Tree T) {
  switch T {
  case appl(Production prod, Args args): {
     str res = "";
     visit prod.lhs {
       case lit(str s): {
         res = res + s.string;
       }
       case cf(Symbol sym): {
         res = res + yieldTree(head(args)); args = rest(args);
         res = res + yieldTree(head(args)); args = rest(args);
       }
       %% ...
     };
     if(args != [])
        res = res + yieldTree(head(args));
     assert "args should be empty": args == [];
     return res;
   }
   case amb(Args args): {
     return "<<<" + join(args, yieldTree, ",") + ">>>";
 
   }
   case <int n>: return n;
   
   case cycle(Symbol symbol, int cycle-length): return "";
   
 }
}

