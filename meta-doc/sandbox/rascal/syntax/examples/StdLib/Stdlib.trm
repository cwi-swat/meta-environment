module RascalStandardLibrary

%%tag function primitive QualName;
%%tag function memo void;
%%tag function java CompilationUnit;
%%tag all doc str;

%% Here is a flat list of library functions that will
%% structured in to coherent submodules.

%% --- Comparison operators ----------------------------------
%% Each type defines == and <. The following
%% functions extend them.

public bool !=(&T A, &T B){
  return !(A == B);
}

public bool <=(&T A, &T B){
  return A < B || A == B;
}

public bool >(&T A, &T B){
  return B < A && A != B;
}

public bool >=(&T A, &T B){
  return B < A;
}

public &T min(&T A, &T B){
  return (A < B) ? A : B;
}

public &T max(&T A, &T B){
  return (A < B) ? B : A;
}

%% --- Boolean (bool) ----------------------------------------

public bool ==(bool B1, bool B2)
  @doc{Equality on Booleans}
  @primitive{"Bool.equal"}

public bool <(bool B1, bool B2)
  @primitive{"Bool.less"}
 
public bool &&(bool B1, bool B2)
  @primitive{"Bool.and"}

public bool ||(bool B1, bool B2)
  @primitive{"Bool.or"}

public bool !(bool B){
  return B ? false : true;
}

public int arb()
  @primitive{"Bool.arb"}

public int toInt(bool B)
  @primitive{"Bool.toInt"}

public double toDouble(bool B)
  @primitive{"Bool.toDouble"}

public str toString(bool B)
  @primitive{"Bool.toString"}

%% --- Integer (int)------------------------------------------

public bool ==(int I1, int I2)
  @primitive{"Int.equal"}
  
public bool <(int I1, int I2)
  @primitive{"Int.less"}

public int +(int I1, int I2) 
  @primitive{"Int.add"}

public int -(int I1, int I2)  
  @primitive{"Int.sub"}

public int *(int I1, int I2)
@primitive{"Int.mul}
 
public int /(int I1, int I2)
  throws divide_by_zero(str msg)
  @primitive{"Int.div"}

public int arb(int bgn, int end)
throws illegal_argument(str msg) %% if(end - bgn <= 0)
  @primitive{"Int.arb"} 

public double toDouble(int I)
  @primitive{"Int.toDouble"}

public str toString(int I)  
  @primitive{"toStringInt"}

%% --- Double (double) ---------------------------------------

public bool ==(double D1, double D2)
  @primitive{"Double.equal"} 

public bool ==(double D, int I){
  return D == toDouble(I);
}

public bool ==(int I, double D){
  return toDouble(I) == D;
}

public bool <(double D1, double D2)
  @primitive{"Double.less"}

public bool <(double D, int I){
  return D < toDouble(I);
}

public bool <(int I, double D){
  return toDouble(I) < D;
}

public double +(double D1, double D2)
  @primitive{"Double.add"}
  
public bool +(double D, int I){
  return D + toDouble(I);
}

public bool +(int I, double D){
  return toDouble(I) + D;
}

public double -(double D1, double D2)
  @primitive{"Double.sub"}
 
public bool -(double D, int I){
  return D - toDouble(I);
}

public bool -(int I, double D){
  return toDouble(I) - D;
}

public double *(double D1, double D2)
  @primitive{"Double.mul"} 

public bool *(double D, int I){
  return D * toDouble(I);
}

public bool *(int I, double D){
  return toDouble(I) * D;
}

public double /(double D1, double D2)
throws divide_by_zero(str msg)
  @primitive{"Double.div"}
  
public bool /(double D, int I){
  return D / toDouble(I);
}

public bool /(int I, double D){
  return toDouble(I) / D;
}

public double arb(double bgn, double end)
throws illegal_argument(str msg) %% if(end - bgn <= 0)
  @primitive{"Double.arb"}

public int toInt(double D)
  @primitive{"Double.toInt"}
 
public str toString(double D)
  @primitive{"Double.toString"}

%% --- Strings (str) -----------------------------------------

public bool ==(str S1, str S2)
  @primitive{"String.equal"}

public bool <(str S1, str S2)
  @primitive{"String.less"}

public str +(str S1, str S2)
  @doc{Concatenate two strings}
  @primitive{"String.concat"}

public int size(str S)
  @primitive{"String.size"}

public int get(str S, int N)
  throws out_of_range(str msg){
  return charAt(S, N);
}

%% get and charAt (as provided by java) are synonyms

public int charAt(str S, int N)
  throws out_of_range(str msg)
  @primitive{"String.charAt"}

public int toInt(str S)
  throws cannot_convert_to_int(str msg)
  @primitive{"String.toInt"}

public int toDouble(str S)
  throws cannot_convert_to_double(str msg)
  @primitive{"String.toDouble"}

public list[int] toList(str S)
  throws cannot_convert_int_to_char(str msg)
  @primitive{"String.toList"}
 
public set[int] toSet(str S)
  @primitive{"String.toSet"}

public str reverse(str S)
  @primitive{"String.reverse"}

public list[str] split(str S, str Regex)
  @primitive{"String.split"}

public bool startsWith(str S, str Prefix)
  @primitive{"String.startsWith"}

public bool endsWith(str S, str Suffix)
  @primitive{"String.endsWith"}

public str toLowerCase(str S)
  @primitive{"String.toLowerCase"}

public str toUpperCase(str S)
  @primitive{"String.toUpperCase"}


%% The above is a selection of methods from Java's String class.
%% Others will be added on demand.

%% --- Locations ---------------------------------------------
   
%% The location datatype
data location location(str filename,
                       int beginline,
                       int endline,
                       int begincol,
                       int endcol,
                       int offset,
                       int length);

anno tree posinfo loc;

public bool ==(loc L1, loc L2)
  @primitive{"Location.equal"} 

public bool <(loc L1, loc L2)
  @primitive{"Location.less"}

public str toString(loc L)
  @primitive{"Location.toString"}

public loc get_location(&T Subject)
  throws location_missing(str msg)
  @primitive{"Location.get_location"}

public &T set_location(&T Subject, loc L)
  @primitive{"Location.set_location"}

%% --- Lists -------------------------------------------------

public bool ==(list[&T] L1, list[&T] L2)
  @primitive{"List.equal"}

public bool <(list[&T] L1, list[&T] L2)
  @primitive{"List.less"}

public list[&T] +(list[&T] L1, list[&T] L2)
  @primitive{"List.concat"}

public list[&T] +(list[&T] L, &T E){
  return L + [E];
}

public list[&T] +(&T E, list[&T] L){
  return [E] + L;
}

public int size(list[&T] L)
  @primitive{"List.size"}
 
public &T get(list[&T] L, int N)
  throws out_of_range(str msg)
  @doc{Get list element: get}
  @primitive{"List.get"}

public &T arb(list[&T] L)
  throws empty_list(str msg)
  @primitive{"List.arb"}

public str toString(list[&T] L)
  @primitive{"List.toString"}


public set[&T] toSet(list[&T] L)
  @primitive{"List.toSet"}

public map[&T, &U] toMap(list[tuple[&T, &U]] L)
  throws domain_not_unique(str msg)
  @primitive{"List.toMap"}
 
public rel[&T] toRel(list[&T] L)
  @primitive{"List.toRel"}

public list[&T] reverse(list[&T] L)
  @primitive{"List.reverse"}

public &T reducer(list[&T] L, &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : L){
    result = F(result, E);
  }
  return result;
}

public list[&T] mapper(list[&T] L, &T F (&T,&T)){
  return [F(E) | &T E : L];
}

public &T min(list[&T] L)
@doc{Minimum element of a list: min}
{
  &T result = arb(L);
  for(&T E : L){
   if(less(E, result)){
      result = min(result, E);
   }
  }
  return result;
}

public &T max(list[&T] L)
@doc{Maximum element of a list: max}
{
  &T result = arb(L);
  for(&T E : L){
   if(less(result, E)){
      result = max(result, E);
   }
  }
  return result;
}

public &T sum(list[&T] L, &T zero)
@doc{Add elements of a List: sum}
{
  return reducer(L, +, zero);
}

public &T multiply(set[&T] R, &T unity)
@doc{Multiply elements of a list: multiply}
{
  return reducer(L, *, unity);
}

public &T average(list[&T] L, &T zero)
@doc{Average of elements of a list: average}
{
  return sum(L, zero)/size(L);
}

public &T first(list[&T] L)
  throws empty_list(str msg)
  @doc{First element of list: first}
  @primitive{"List.first"}

public &T rest(list[&T] L)
  throws empty_list(str msg)
  @doc{Remaining elements of list: rest}
  @primitive{"List.rest"}

public str makeString(list[int] L)
  throws cannot_convert_int_to_char(str msg)
  @primitive{"List.makeString"}

public list[&T] sort(list[&T] L, bool less(&T, &T))
  @doc{Sort elements of list: sort}
  @primitive{"list.sort"}
 
%% --- Tuples ------------------------------------------------

public bool ==(tuple[&T] R, tuple[&T] S)
  @primitive{"Tuple.equal"}
 
public bool <(tuple[&T] R, tuple[&T] S)
  @primitive{"Tuple.less"}
 
public tuple[&T + &U] +(tuple[&T] R, tuple[&U] S)
  @primitive{"Tuple.conc"}

public tuple[&T + &U] +(tuple[&T] R, &U E){
  return R + <E>;
}

public tuple[&T + &U] +(&T E, tuple[&U] R){
  return <E> + R;
}

public int size(tuple[&T] R)
  @primitive{"Tuple.size"}

public value get(tuple[&T] R, int N)
  throws out_of_range(str msg)
  @primitive{"Tuple.get"}

public str toString(tuple[&T] R)
  @primitive{"Tuple.toString"}

%% --- Sets  -------------------------------------------------

public bool ==(set[&T] R, set[&T] S)
  @primitive{"Set.equal"}

public bool <(set[&T] R, set[&T] S)
  @primitive{"Set.less"}

public set[&T] |(set[&T] R, set[&T] S)
  @doc{Union of two sets}
  @primitive{"Set.union"}
  
public set[&T] |(set[&T] S, &T E){
  return S + {E};
}

public set[&T] |(&T E, set[&T] S){
  return {E} + S;
}

public set[&T] -(set[&T] R, set[&T] S)
  @doc{Difference of two sets}
  @primitive{"Set.diff"}

public set[&T] -(set[&T] S, &T E){
  return S - {E};
}

public set[&T] -(&T E, set[&T] S){
  return {E} - S;
}

public set[&T] &(set[&T] R, set[&T] S)
  @doc{Intersection of two sets}
  @primitive{"Set.intersection"}

public set[&T] &(set[&T] S, &T E){
  return S & {E};
}

public set[&T] &(&T E, set[&T] S){
  return {E} & S;
}

public int size(set[&T] S)
  @primitive{"Set.size"}

public &T arb(set[&T] S)
throws empty_set(str msg)
  @primitive{"Set.arb"}
  
public str toString(set[&T] S)
  @primitive{"Set.toString"}

public list[&T] toList(set[&T] S)  
  @primitive{"List.toList"}
  
public map[&T, &U] toMap(set[tuple[&T, &U]] S)
  throws non_unique_domain(str msg)
  @primitive{"Set.toMap"}

public rel[&T] toRel(set[&T] S)
   @primitive{"Set.toRel"}

public &T reducer(set[&T] S, &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : S){
    result = F(result, E);
  }
  return result;
}

public set[&T] mapper(set[&T] S, &T F (&T,&T)){
  return {F(E) | &T E : S};
}

public &T min(set[&T] S)
  @doc{Minimum of a set}
{
  &T result = arb(S);
  for(&T E : S){
    result = min(result, E);
  }
  return result;
}

public &T max(set[&T] R)
  @doc{Maximum of a set}
{
  &T result = arb(R);
  for(&T E : R){
    result = max(result, E);
  }
  return result;
}

public &T sum(set[&T] S, &T zero)
  @doc{Sum elements of a Set: sum}
{
  return reducer(S, +, zero);
}

public &T multiply(set[&T] S, &T unity)
  @doc{Multiply elements of a Set}
{
  return reducer(S, *, unity);
}

public &T average(set[&T] S, &T zero)
  @doc{Average of elements of a set}
{
  return sum(S, zero)/size(R);
}

%% TODO

%% Powerset: power0
%%public set[set[&T]] power0(set[&T] R)
%% throw unimplemented("power0")

%% Powerset: power1
%%public set[set[&T]] power1(set[&T] R)
%%  throw unimplemented("power0")

%% --- Maps --------------------------------------------------

public bool ==(map[&T, &U] M1, map[&T, &U] M2)
  @primitive{"Map.equal"}
  
public bool <(map[&T, &U] M1, map[&T, &U] M2)
  @primitive{"Map.less"}
  
public map[&T] |(map[&T] R, map[&T] S)
  @primitive{"Map.union"}
  
public map[&T] |(map[&T] S, &T E){
  return S | {E};
}

public map[&T] |(&T E, map[&T] S){
  return {E} | S;
}

public map[&T] -(map[&T] R, map[&T] S)
  @doc{Difference of two maps}
  @primitive{"Map.diff"}
 
public map[&T] -(map[&T] S, &T E){
  return S - {E};
}

public map[&T] -(&T E, map[&T] S){
  return {E} - S;
}

public map[&T] &(map[&T] R, map[&T] S)
  @primitive{"Map.mul"}
  @doc{Intersection of two maps: operator &}

public map[&T] &(map[&T] S, &T E){
  return S & {E};
}

public map[&T] &(&T E, map[&T] S){
  return {E} & S;
}

public int size(map[&T] M)
  @primitive{"Map.size"}

public &T arb(map[&T] M)
throws empty_map(str msg)
  @primitive{"Map.arb"}
  
public str toString(map[&T] R)
  @primitive{"Map.toString"}
  
public list[tuple[&T, &U]] toList(map[&T, &U] M)
  @primitive{"Map.toList"}

public set[tuple[&T, &U]] toSet(map[&T, &U] M)
  @primitive{"Map.toSet"}

public rel[tuple[&T, &U]] toRel(map[&T, &U] M)
  @primitive{"Map.toRel"}

public map[&T] mapper(map[&T] M, &T F (&T,&T)){
  return {F(E) | &T E : M};
}

%% --- Relations ---------------------------------------------

public bool ==(rel[&T] R, rel[&T] S)
  @primitive{"Rel.equal"}
  
public bool <(rel[&T] R, rel[&T] S)
  @primitive{"Rel.less"}
  
public rel[&T] |(rel[&T] R1, rel[&T] R2)
  @doc{Union of two relations}
  @primitive{"Rel.union"}

public rel[&T] |(&T E, rel[&T] R){
  return toRel({E}) | R;
}

public rel[&T] |(rel[&T] R, &T E){
  return R | toRel({E});
}

public rel[&T] -(rel[&T] R1, rel[&T] R2)
  @doc{Difference of two relations}
  @primitive{"Rel.diff"}
  
public rel[&T] &(rel[&T] R1, rel[&T] R1)
  @doc{Intersection of two relations}
  @primitive{"Rel.intersection"}

public int size(rel[&T] R)
  @primitive{"Rel.size"}
  
public &T arb(rel[&T] R)
throws empty_relation(str msg)
  @primitive{"Rel.arb"}

public str toString(rel[&T] R)
  @primitive{"Rel.toString"}

%% Note: in rel[&T], the type variable &T refers 
%% to the tuple type of the relation.

public list[&T] toList(rel[&T] R)
  @primitive{"Rel.toList"}
  
public set[&T] toSet(rel[&T] R)
  @primitive{"Rel.toSet"}

public map[&T] toMap(rel[tuple[&T]] S)
  throws non_unique_domain(str msg)
  @primitive{"Ret.toMap"}

public rel[&T] mapper(rel[&T] R, &T F (&T,&T)){
  return {F(E) | &T E : R};
}

public rel[&T1, &T2] *(set[&T1] R, set[&T2] S)
  @doc{Carthesian product of two sets}
{
  return {<X, Y> | &T1 X : R, &T2 Y : S};
}

public rel[&T1, &T3] compose(rel[&T1, &T2] R,
                                 rel[&T2, &T3] S)
  @doc{Compose two relations}
{
   return {<X, Z> | <&T1 X, &T2 Y1>: R, 
                    <&T2 Y2, &T3 Z>: S, Y1 == Y2};
}

public rel[&T, &T] id(set[&T] S)
  @doc{Identity relation}
{
  return { <X, X> | &T X : S};
}

public rel[&T2, &T1] invert (rel[&T1, &T2] R)
  @doc{Inverse of relation}
{
  return { <Y, X> | <&T1 X, &T2 Y> : R };
}


public rel[&T1, &T2] complement(rel[&T1, &T2] R)
  @doc{Complement of relation}
{
  return (domain(R) * range(R)) - R;
}

public set[&T1] domain (rel[&T1,&T2] R)
  @doc{Domain of relation}
{
  return { X | <&T1 X, &T2 Y> : R };
}

public set[&T1] range (rel[&T1,&T2] R)
  @doc{Range of relation}
{
  return { Y | <&T1 X, &T2 Y> : R };
}

public set[&T]  carrier (rel[&T,&T] R)
  @doc{Carrier of relation}
{
  return domain(R) + range(R);
}

public rel[&T1,&T2] domainR (rel[&T1,&T2] R, set[&T1] S)
  @doc{Domain Restriction of a relation}
{
  return { <X, Y> | <&T1 X, &T2 Y> : R, X in S };
}

public rel[&T1,&T2] rangeR (rel[&T1,&T2] R, set[&T2] S)
  @doc{range Restriction of a relation}
{
  return { <X, Y> | <&T1 X, &T2 Y> : R, Y in S };
}

public rel[&T,&T] carrierR (rel[&T,&T] R, set[&T] S)
  @doc{Carrier restriction of a relation}
{
  return { <X, Y> | <&T X, &T Y> : R, X in S, Y in S };
}

public rel[&T1,&T2] domainX (rel[&T1,&T2] R, set[&T1] S)
  @doc{Domain exclusion of a relation}
{
  return { <X, Y> | <&T1 X, &T2 Y> : R, X notin S };
}

public rel[&T1,&T2] rangeX (rel[&T1,&T2] R, set[&T2] S)
  @doc{Range exclusion of a relation}
{
  return { <X, Y> | <&T1 X, &T2 Y> : R, Y notin S };
}

public rel[&T,&T] carrierX (rel[&T,&T] R, set[&T] S)
  @doc{Carrier exclusion of a relation}
{
  return { <X, Y> | <&T1 X, &T2 Y> : R, 
                    !(X in S), !(Y in S) };
}

%% Relations viewed as graphs

type rel[&T,&T] graph[&T];

public set[&T] top(graph[&T] G)
  @doc{Top of a Graph}
{
  return domain(G) - range(G);
}

public set[&T] bottom(graph[&T] G)
  @doc{Bottom of a Graph}
{
  return range(G) - domain(G);
}

public set[&T] reachR(set[&T] Start, set[&T] Restr,
                          graph[&T] G)
  @doc{Reachability with restriction}
{
  return range(compose(domainR(G, Start), 
                       carrierR(G, Restr)+));
}

public set[&T] reachX(set[&T] Start, set[&T] Excl, 
                          graph[&T] G)
  @doc{Reachability with exclusion}
{
  return range(compose(domainR(G, Start), 
                       carrierX(G, Excl)+));
}

public list[&T] shortestPathPair(&T From, &T To, graph[&T] G)
  @doc{Shortest path between pair of nodes}
  @primitive{"Graph.shortestPathPair"}

public set[list[&T]] shortestPathFrom(&T From, graph[&T] G)
  @doc{Shortest path between one node and all others}
  @primitive{"Graph.shortestPathFrom"}

public set[list[&T]] shortestPathAll(graph[&T] G)
  @doc{Shortest path between all nodes}
  @primitive{"Graph.shortestPathAll"}

%% TO DO

public rel[&T, &T] closure(rel[&T, &T])
  @primitive{"Rel.closure"}

%% --- Annotations -------------------------------------------

public bool has_annotation(&T Subject, str Name)
  @doc{Test whether a named annotation exists.
       A synonym for the ? operator.}
  @primitive{"Annotation.has_annotation"}

public value get_annotation(&T Subject, str Name)
  throws missing_annotation(str msg)
  @doc{Get the value of a named annotation.
       A synonym for the @ operator.}
  @primitive{"Annotation.get_annotation"}

public map[str,value] get_annotations(&T Subject)
  @doc{Get all annotations}
  @primitive{"Annotation.get_annotations"}
 
public &T set_annotation(&T Subject, 
                             str Name, value AValue)
  @doc{Set the value of a named annotation.
       A synonym for: Var @ Anno = Exp}
  @primitive{"Annotation.set_annotation"}

public &T set_annotations(&T Subject, 
                              map[str, value] Annos)
  @doc{Set all annotations}
  @primitive{"Annotation.set_annotations"}

%% --- Parsing and Unparsing -------------------------------------

public tree parseFile(str filename)
  throws file_does_not_exist(str msg)
  @primitive{"Parse.parseFile"}

public tree parseString(str source)
  @primitive{"Parse.parseString"}
  
public str unparseToString(tree Subject)
  @primitive{"Parse.unparseToString"}
  
public str unparseToFile(tree Subject, str filename)
  throws cannot_create(str msg) 
  throws write_error(str msg) 
  @primitive{"Parse.unparseToFile"}

%% --- trees -------------------------------------------------

public int toInt(tree Subject)
  throws cannot_convert(str msg)
  @primitive{"Tree.toInt"}

public int toDouble(tree Subject)
  throws cannot_convert(str msg)
  @primitive{"Tree.toDouble"}

public int toString(tree Subject)
  throws cannot_convert(str msg)
  @primitive{"Tree.toString"}

public bool elementOf(tree S1, tree S2)
  @primitive{"Tree.elementOf"}


%% --- io ----------------------------------------------------

public str readFile(str filename)
  throws does_not_exist(str msg)            
  throws read_error(str msg)
  @primitive{"IO.read"}


public &T readTerm(str filename) 
  throws does_not_exist(str msg)  
  throws read_error(str msg)
  throws term_error(str msg, loc l)
  @primitive{"IO.readTerm"}


public void write(str filename, &T Subject) 
  throws cannot_create(str msg)  
  throws write_error(str msg)
  @primitive{"IO.write"}

public void print(list[value] V...)
  @primitive{"IO.print"}

public void println(list[value] V...)
  @primitive{"IO.println"}
 
%% --- Interface with the Program Database -------------------
%% The following function provide a bare minimum and will
%% have to compared with the current PDB interface.
%% We assume one active PDB that can be opened and closed.
%% Values can be written to and read from the PDB.

%% Idea: it would be nice to model the PDB as a value
%% of type map[str, value] and to access it that way!

public void openPDB(str name) 
  throws cannot_open(str msg)
  @primitive{"PDB.open"}

public void closePDB()
  throws cannot_close(str msg)
  @primitive{"PDB.close"}

public void writePDB(str name, &T val)
  throws cannot_write(str msg)
  @primitive{"PDB.write"}

public &T readPDB(str name)
  throws cannot_read(str msg)
  @primitive{"PDB.readPDB"}

%% If name is of type set[&T], then the set incr
%% is added to it. Similar for a rel[&T]

public void addSetPDB(str name, set[&T] incr)
  throws does_not_exist(str msg)
  @primitive{"PDB.addSet"}

public void addRelPDB(str name, rel[&T] incr)
  throws does_not_exist(str msg)
  @primitive{"PDB.addRel"}
