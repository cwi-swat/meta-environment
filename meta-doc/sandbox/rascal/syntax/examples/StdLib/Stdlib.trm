module RascalStandardLibrary

%% Here is a flat list of library functions that will
%% structured in to coherent submodules.

%% --- Comparison operators ----------------------
%% Each type defines equal and less. The following
%% functions extend them.

%% Operator <=
public fun bool less_equal(&T A, &T B){ 
  return less(A, B) or equal(A, B);
}

%% Operator >
public fun bool greater(&T A, &T B){
  return less(B, A) and not equal(A, B);
}

%% Operator >=
public fun bool greater_equal(&T A, &T B){
  return less(B, A);
}

public fun &T min(&T A, &T B){
  if(less(A, B))
    return A
  else
    return B;
}

public fun &T max(&T A, &T B){
  if(less(A, B))
    return B
  else
    return A;
}

%% --- Booleans ----------------------------------

public fun bool equal(bool B1, bool B2)
  throw unimplemented("equal of bool")

public fun bool less(bool B1, bool B2)
  throw unimplemented("less of bool")

public fun bool add(bool B1, bool B2)
  throw unimplemented("add on bool")

public fun bool sub(bool B1, bool B2)
  throw unimplemented("sub on bool")

public fun bool mul(bool B1, bool B2)
  throw unimplemented("mul on bool")

public fun bool div(bool B1, bool B2)
  throw unimplemented("div on bool")

%% Arbitrary boolean: arb
public fun int arb(){
  throw unimplemented("bool arb");
}

%% --- Integer ------------------------------------

public fun bool equal(int I1, int I2)
  throw unimplemented("equal of int")

public fun bool less(int I1, int I2)
  throw unimplemented("less of int")

public fun int add(int I1, int I2)
  throw unimplemented("add on int")

public fun int sub(int I1, int I2)
  throw unimplemented("sub on int")

public fun int mul(int I1, int I2)
  throw unimplemented("mul on int")

public fun int div(int I1, int I2)
  throw unimplemented("div on int")

%% Arbitrary integer: arb
public fun int arb(int bgn, int end){
  throw unimplemented("int arb");
  if(end - bgn <= 0)
     throw illegal_argument("int arb");
}


%% --- Double -------------------------------------

public fun bool equal(double D1, double D2)
  throw unimplemented("equal of double")

public fun bool less(double D1, double D2)
  throw unimplemented("less of double")

public fun double add(double D1, double D2)
  throw unimplemented("add on double")

public fun double sub(double D1, double D2)
  throw unimplemented("sub on double")

public fun double mul(double D1, double D2)
  throw unimplemented("mul on double")

public fun double div(double D1, double D2)
  throw unimplemented("div on double")

%% Arbitrary double: arb
public fun double arb(double bgn, double end){
  throw unimplemented("double arb");
  if(end - bgn <= 0)
     throw illegal_argument("double arb");
}

%% --- Strings ------------------------------------

public fun bool equal(str S1, str S2)
  throw unimplemented("equal of string")

public fun bool less(str S1, str S2)
  throw unimplemented("less of string")

public fun str add(str S1, str S2)
  throw unimplemented("add on str")

public fun int size(str S)
  throw unimplemented("size of string")

public fun list[int] toList(str S){
  list[int] result = [];
  for(int E : S){
    result += E
  };
  return result;
}

public fun str reverse(str S)
  throw unimplemented("reverse of string")



%% Add functions for other methods of Java's String class

%% --- Lists ---------------------------------------

public fun bool equal(list[&T] L1, list[&T] L2){
  throw unimplemented("equal on list")
}

public fun bool less(list[&T] L1, list[&T] L2){
  throw unimplemented("less on list")
}

public fun list[&T] add(list[&T] L1, list[&T] L2)
  throw unimplemented("add on list")

public fun list[&T] add(list[&T] L, &T E)
  return L + [E];

public fun list[&T] add(&T E, list[&T] L)
  return [E] + L;

%% Size of list: size
public fun int size(list[&T] L){
  int N = 0;
  for(&T E : L)
    N += 1;
  return N;
}

%% Arbitrary element of list: arb
public fun &T arb(list[&T] L) {
  int N = arb(0, size(L));
  return L[N];
}

public fun list[&T] reverse(list[&T] L){
  list[&T] result = [];
  for(&T E : L)
    result = [E] + result;
  return result;
}

public fun str toString(list[int] L)
  throw unimplemented("toString on list[int]")

public fun set[&T] toSet(list[&T] L){
  set[&T] result = {};
  for(&T E : L){
    result += E
  };
  return result;
}

public fun map[&T, &U] toMap(list[tuple[&T, &U]] L){
  map[&T, &U] result = {};
  for(tuple[&T, &U] Tup : L)
    result += Tup;
  return result
}

public fun rel[&T] toRel(list[&T] L){
  rel[&T] result = {};
  for(&T Tup : L)
    result += Tup;
  return result
}

public fun &T reduce(list[&T] L, fun &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : L){
    result = F(result, E)
  };
  return result
}

%% Maximum element of a list: max
public fun &T max(list[&T] L){
  &T result = arb(L);
  for(&T E : L)
   if(less(result, E))
      result = max(result, E);
  return result
}

%% Minimum element of a list: min
public fun &T min(list[&T] L){
  &T result = arb(L);
  for(&T E : L)
   if(less(E, result))
      result = min(result, E);
  return result
}

%% Add elements of a List: sum
public fun &T sum(list[&T] L, &T zero){
  return reduce(L, add, zero);
}

%% Multiply elements of a list: product
public fun &T product(set[&T] R, &T one){
  return reduce(L, mul, zero);
}

%% Average of elements of a list: average
public fun &T prod(list[&T] L, &T zero)
  return sum(L, zero)/size(L)



%% --- Tuples --------------------------------------


%% --- Sets  ---------------------------------------

%% equal

public fun bool equal(set[&T] R, set[&T] S)
  throw unimplemented("equal set");

%% less
public fun bool less(set[&T] R, set[&T] S)
  throw unimplemented("less set");

%% Add two sets (set union): add (operator +)
public fun set[&T] add(set[&T] R, set[&T] S){
  throw unimplemented("add set");
}

public fun set[&T] add(set[&T] S, &T E){
 return S + {E};
}

public fun set[&T] add(&T E, set[&T] S){
 return {E} + S;
}

%% Substract two sets (set difference): sub (operator -)
public fun set[&T] sub(set[&T] R, set[&T] S){
   throw unimplemented("sub set");
}

public fun set[&T] sub(set[&T] S, &T E){
   return S - {E};
}

public fun set[&T] sub(&T E, set[&T] S){
   return {E} - S;
}

%% Multiply two sets (set intersection): mul (operator *)
public fun set[&T] mul(set[&T] R, set[&T] S){
   throw unimplemented("mul set");
}

public fun set[&T] mul(set[&T] S, &T E){
  return S * {E};
}

public fun set[&T] mul(&T E, set[&T] S){
  return {E} * S;
}

%% Size of set: size
public fun int size(set[&T] R){
  int N = 0;
  for(&T E : R)
    N += 1;
  return N;
}

%% Arbitrary element of set: arb
public fun &T arb(set[&T] S) {
  int N = arb(0, size(S));
  return S[N];
}

public fun list[&T] toList(set[&T] S){
  list[&T] result = [];
  for(&T E : S){
    result += E
  };
  return result;
}

public fun map[&T, &U] toMap(set[tuple[&T, &U]] S){
  map[&T, &U] result = {};
  for(tuple[&T, &U] Tup : S)
    result += Tup;
  return result
}

public fun rel[&T] toRel(set[&T] S){
  rel[&T] result = {};
  for(&T E : S){
    result += E
  };
  return result;
}

public fun &T reduce(set[&T] S, fun &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : S){
    result = F(result, E)
  };
  return result
}

%% Minimum of a set: min
public fun &T min(set[&T] S){
  &T result = arb(S);
  for(&T E : S)
    result = min(result, E);
  return result
}

%% Maximum of a set: max
public fun &T max(set[&T] R){
  &T result = arb(R);
  for(&T E : R)
    result = max(result, E);
  return result
}

%% Sum elements of a Set: sum
public fun &T sum(set[&T] S, &T zero){
  return reduce(S, add, zero);
}

%% Multiply elements of a Set: multiply
public fun &T multiply(set[&T] S, &T one){
  return reduce(S, mul, zero);
}

%% Average of elements of a set; average
public fun &T average(set[&T] S, &T zero)
  return add(S, zero)/size(R)

%% Powerset: power0
public fun set[set[&T]] power0(set[&T] R)
 throw unimplemented("power0")

%% Powerset: power1
public fun set[set[&T]] power1(set[&T] R)
  throw unimplemented("power0")

%% --- Maps

public fun bool equal(map[&T, &U] M1, map[&T, &U] M2){
  throw unimplemented("equal map")
} 

public fun bool less(map[&T, &U] M1, map[&T, &U] M2){
  throw unimplemented("less map")
} 

public fun map[&T] add(map[&T] R, map[&T] S){
  throw unimplemented("add map");
}

public fun map[&T] add(map[&T] S, &T E){
 return S + {E};
}

public fun map[&T] add(&T E, map[&T] S){
 return {E} + S;
}

%% Substract two maps (set difference): sub (operator -)
public fun map[&T] sub(map[&T] R, map[&T] S){
   throw unimplemented("sub map");
}

public fun map[&T] sub(map[&T] S, &T E){
   return S - {E};
}

public fun map[&T] sub(&T E, map[&T] S){
   return {E} - S;
}

%% Multiply two maps (set intersection): mul (operator *)
public fun map[&T] mul(map[&T] R, map[&T] S){
   throw unimplemented("mul map");
}

public fun map[&T] mul(map[&T] S, &T E){
  return S * {E};
}

public fun map[&T] mul(&T E, map[&T] S){
  return {E} * S;
}

public fun int size(map[&T] M)
  return size(toList(M));

public fun &T arb(map[&T] M)
  return(arb(toList(M)));

public fun list[tuple[&T, &U]] toList(map[&T, &U] M){
  list[tuple[&T, &U]] result = [];
  for(tuple[&T, &U] Tup : M)
    result += Tup;
  return result
}

public fun rel[tuple[&T, &U]] toSet(map[&T, &U] M){
  set[tuple[&T, &U]] result = {};
  for(tuple[&T, &U] Tup : M)
    result += Tup;
  return result
}

public fun rel[tuple[&T, &U]] toRel(map[&T, &U] M){
  rel[tuple[&T, &U]] result = {};
  for(&T Tup : R)
    result += Tup;
  return result
}

%% Is this meaningfull?
public fun &T reduce(map[&T] S, fun &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : S){
    result = F(result, E)
  };
  return result
}

%% --- Relations

public fun bool equal(rel[&T] R, rel[&T] S)
  throw unimplemented("equal rel");

public fun bool less(rel[&T] R, rel[&T] S)
  throw unimplemented("less rel");


%% Add two relations (union): add (operator +)
public fun rel[&T] add(rel[&T] R1, rel[&T] R2){
  return toRel(toSet(R1) + toSet(R2))
}

public fun rel[&T] add(&T E, rel[&T] R){
  return toRel(E + toSet(R))
}

public fun rel[&T] add(rel[&T] R, &T E){
  return toRel(toSet(R) + E)
}

%% Substract two relations (difference): sub (operator -)
public fun rel[&T] sub(rel[&T] R1, rel[&T] R2){
  return toRel(toSet(R1) - toSet(R2))
}

%% Multiply two relations (intersection): mul (operator *)
public fun rel[&T] mul(rel[&T] R1, rel[&T] R1){
  return toRel(toSet(R1) * toSet(R2))
}

%% Size of relation: size
public fun int size(rel[&T] R){
  return size(toSet(R))
}

public fun &T arb(rel[&T] R)
  return arb(toList(R));

%% Note: in rel[&T], the type variable &T refers to the tuple type of the relation.

public fun list[&T] toList(rel[&T] R){
  list[&T] result = [];
  for(&T Tup : R)
    result += Tup;
  return result
}

public fun set[&T] toSet(rel[&T] R){
  set[&T] result = {};
  for(&T Tup : R)
    result += Tup;
  return result
}

public fun rel[&T] toRel(set[&T] S){
  rel[&T] result = {};
  for(&T Tup : R)
    result += Tup;
  return result
}

%% Carthesian product of two sets: product (was: x)
public fun rel[&T1, &T2] product(rel[&T1] R, rel[&T2] S)
  return {<X, Y> | &T1 X : R, &T2 Y : S}

%% Compose two relations: compose (was: o)
public fun rel[&T1, &T3] compose(rel[&T1, &T2] R, rel[&T2, &T3] S)
   return {<X, Z> | tuple[&T1 X, &T2 Y1]: R, tuple[&T2 Y2, &T3 Z]: S, Y1 == Y2}

%% Identity relation: id
public fun rel[&T, &T] id(set[&T] S)
  return { <X, X> | &T X : S}

%% Inverse relation: invert (was: inv)
public fun rel[&T2, &T1] invert (rel[&T1, &T2] R)
  return { <Y, X> | tuple[&T1 X, &T2 Y] : R }

%% Complement of relation: complement (was: compl)
public fun rel[&T1, &T2] complement(rel[&T1, &T2] R)
  return product(domain(R), range(R)) - R

%% Domain of relation: domain
public fun set[&T1] domain (rel[&T1,&T2] R)
  return { X | tuple[&T1 X, &T2 Y] : R }

%% Range of relation: range
public fun set[&T1] range (rel[&T1,&T2] R)
  return { Y | tuple[&T1 X, &T2 Y] : R }

%% Carrier of relation: carrier
public fun set[&T]  carrier (rel[&T,&T] R) 
  return domain(R) + range(R)

%% Domain Restriction of a Relation: domainR
public fun rel[&T1,&T2] domainR (rel[&T1,&T2] R, set[&T1] S)
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, X in S }

%% Range Restriction of a Relation: rangeR
public fun rel[&T1,&T2] rangeR (rel[&T1,&T2] R, set[&T2] S)
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, Y in S }

%% Carrier Restriction of a Relation: carrierR
public fun rel[&T,&T] carrierR (rel[&T,&T] R, set[&T] S)
  return { <X, Y> | tuple[&T X, &T Y] : R, X in S, Y in S }

%% Domain Exclusion of a Relation: domainX
public fun rel[&T1,&T2] domainX (rel[&T1,&T2] R, set[&T1] S)
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, X notin S }

%% Range Exclusion of a Relation: rangeX
public fun rel[&T1,&T2] rangeX (rel[&T1,&T2] R, set[&T2] S)
   { <X, Y> | tuple[&T1 X, &T2 Y] : R, Y notin S }

%% Carrier Exclusion of a Relation: carrierX
public fun rel[&T,&T] carrierX (rel[&T,&T] R, set[&T] S)
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, X notin S, Y notin S }

%% Relations viewed as graphs

%% Top of a Relation: top
public fun set[&T] top(rel[&T, &T] R)
  return domain(R) - range(R)

%% Bottom of a Relation: bottom
public fun set[&T] bottom(rel[&T,&T] R)
  return range(R) - domain(R)

%% Reachability with Restriction: reachR
public fun set[&T] reachR( set[&T] Start, set[&T] Restr, rel[&T,&T] Rel)
  return range(compose(domainR(Rel, Start), carrierR(Rel, Restr)+))

%% Reachability with Exclusion: reachX
public fun set[&T] reachX( set[&T] Start, set[&T] Excl, rel[&T,&T] Rel)
  return range(compose(domainR(Rel, Start), carrierX(Rel, Excl)+))

%% --- Locations ---------------------------------

%% The location datatype
data location location(str filename,
                       int beginline,
                       int endline,
                       int begincol,
                       int endcol,
                       int offset,
                       int length);

public fun loc get_location(&T Subject)
  throw unimplemented("get_location")

public fun &T set_location(&T Subject, loc L)
  throw unimplemented("set_location")

public fun bool equal(loc L1, loc L2)
  throw unimplemented("equal loc")

public fun bool less(loc L1, loc L2)
  throw unimplemented("less loc")


%% --- Annotations --------------------------------

%% Test whether a named annotation exists.
public fun bool has_annotation(&T Subject)
   throw unimplemented("has_annotation");

%% Get the value of a named annotation
public fun value get_annotation(&T Subject, str Name){
  if(not has_annotation(Subject))
    throw argument_error("get_annotation", Subject);
  throw unimplemented("get_annotation");
}

%% Get all annotations
public fun map[str,value] get_annotations(&T Subject)
  throw unimplemented("get_annotations");

%% Set the value of a named annotation
public fun &T set_annotation(&T Subject, str Name, value AValue)
  throw unimplemented("set_annotation");

%% Set all annotations
public fun &T set_annotations(&T Subject, map[str, value] Annos)
  throw unimplemented("set_annotation");

%% --- Parsing/Unparsing --------------------------

public fun &T parseFile(str filename){
  throw unimplemented("parseFile");
  throw file_error;
  throw syntax_error;
}

public fun &T parseString(str source){
  throw unimplemented("parseString");
  throw file_error;
  throw syntax_error;
}

public fun str unparseToString(&T Subject){
  throw unimplemented("unparseToString");
}

public fun str unparseToFile(&T Subject, str filename){
  throw unimplemented("unparseToFile");
}

%% --- io ------------------------------------------

public fun str readFile(str filename){
  throw unimplemented("read");
  throw file_error;
}

public fun &T readTerm(str filename){
  throw unimplemented("readTerm");
  throw file_error;
}

public fun void write(str filename, &T Subject){
  throw unimplemented("write");
  throw file_error;
}