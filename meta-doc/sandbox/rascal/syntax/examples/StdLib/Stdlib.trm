module RascalStandardLibrary

@rascal-anno function primitive string
@rascal-anno function memo void
@rascal-anno function java CompilationUnit

@rascal-anno all doc string

%% Here is a flat list of library functions that will
%% structured in to coherent submodules.

%% --- Comparison operators ----------------------------------
%% Each type defines == and <. The following
%% functions extend them.

public bool <=(&T A, &T B){
  return A < B or A == B
}

public bool >(&T A, &T B){
  return B < A and not A == B
}

public bool >=(&T A, &T B){
  return B < A
}

public &T min(&T A, &T B){
  if(A < B)
    return A
  else
    return B;
}

public &T max(&T A, &T B){
  if(A < B)
    return B
  else
    return A;
}

%% --- Boolean (bool) ----------------------------------------

public bool ==(bool B1, bool B2)
 @primitive{Bool.equal}

public bool <(bool B1, bool B2)
  @primitive{Bool.less}

public bool +(bool B1, bool B2)
  @primitive{Bool.add}

public bool -(bool B1, bool B2)
 @primitive{Bool.sub}

public bool *(bool B1, bool B2)
  @primitive{Bool.mul}

%% Arbitrary boolean: arb
public int arb()
 @primitive{Bool.arb}

public str toString(bool B)
 @primitive{Bool.toString}

public int toInt(bool B)
 @primitive{Bool.toInt}

public double toDouble(bool B)
 @primitive{Bool.toDouble}

%% --- Integer (int)------------------------------------------

public bool ==(int I1, int I2)
 @primitive{Int.equal}

public bool <(int I1, int I2)
  @primitive{Int.less}

public int +(int I1, int I2)
 @primitive{Int.add}

public int -(int I1, int I2)
  @primitive{-Int}

public int *(int I1, int I2)
  @primitive{Int.mul}

public int /(int I1, int I2)
  throws divide_by_zero(str msg)
  @primitive{Int.div}

%% Arbitrary integer: arb
public int arb(int bgn, int end)
       throws illegal_argument(str msg) %% if(end - bgn <= 0)
 @primitive{Int.arb} 

public double toDouble(int I)
 @primitive{Int.toDouble}

public str toString(int I)
 @primitive{toStringInt}

%% --- Double (double) ---------------------------------------

public bool ==(double D1, double D2)
  @primitive{Double.equal}

public bool ==(double D, int I){
  return D == toDouble(I)
}

public bool ==(int I, double D){
  return toDouble(I) == D
}

public bool <(double D1, double D2)
  @primitive{Double.less}

public bool <(double D, int I){
  return D < toDouble(I)
}

public bool <(int I, double D){
  return toDouble(I) < D
}

public double +(double D1, double D2)
  @primitive{Double.add}

public bool +(double D, int I){
  return D + toDouble(I)
}

public bool +(int I, double D){
  return toDouble(I) + D
}

public double -(double D1, double D2)
  @primitive{Double.sub}

public bool -(double D, int I){
  return D - toDouble(I)
}

public bool -(int I, double D){
  return toDouble(I) - D
}

public double *(double D1, double D2)
  @primitive{Double.mul}

public bool *(double D, int I){
  return D * toDouble(I)
}

public bool *(int I, double D){
  return toDouble(I) * D
}
public double /(double D1, double D2)
  throws divide_by_zero(str msg)
  @primitive{Double.div}

public bool /(double D, int I){
  return D / toDouble(I)
}

public bool /(int I, double D){
  return toDouble(I) / D
}

%% Arbitrary double: arb
public double arb(double bgn, double end)
       throws illegal_argument(str msg) %% if(end - bgn <= 0)
 @primitive{Double.arb}

public int toInt(double D)
  @primitive{Double.toInt}

public str toString(double D)
  @primitive{Double.toString}

%% --- Strings (str) -----------------------------------------

public bool ==(str S1, str S2)
  @primitive{String.equal}

public bool <(str S1, str S2)
 @primitive{String.less}

public str +(str S1, str S2)
  @primitive{String.add}

public int size(str S)
  @primitive{String.size}

public int get(str S, int N)
       throws out_of_range(str msg)
 @primitive{String.get}

public int toInt(str S)
       throws cannot_convert_to_int(str msg)
  @primitive{String.toInt}

public int toDouble(str S)
       throws cannot_convert_to_double(str msg)
  @primitive{String.toDouble}
   
public list[int] toList(str S)
       throws cannot_convert_int_to_char(str msg)
  @primitive{String.toList}
 
public set[int] toSet(str S)
  @primitive{String.toSet}

public str reverse(str S)
  @primitive{String.reverse}

%% Add functions for other methods of Java's String class

%% --- Locations ---------------------------------------------

%% The location datatype
data location location(str filename,
                       int beginline,
                       int endline,
                       int begincol,
                       int endcol,
                       int offset,
                       int length);

public bool ==(loc L1, loc L2)
  @primitive{Location.equal} 

public bool <(loc L1, loc L2)
  @primitive{Location.less}

public str toString(loc L)
  @primitive{Location.toString}

public loc get_location(&T Subject)
       throws location_missing(str msg)
 @primitive{Location.get_location}

public &T set_location(&T Subject, loc L)
   @primitive{Location.set_location}

%% --- Lists -------------------------------------------------

public bool ==(list[&T] L1, list[&T] L2)
  @primitive{List.equal}

public bool <(list[&T] L1, list[&T] L2)
  @primitive{List.less}

public list[&T] +(list[&T] L1, list[&T] L2)
   @primitive{List.add}

public list[&T] +(list[&T] L, &T E)
  return L + [E];

public list[&T] +(&T E, list[&T] L)
  return [E] + L;

%% Size of list: size
public int size(list[&T] L)
  @primitive{List.size}

%% Get list element: get
public &T get(list[&T] L, int N)
       throws out_of_range(str msg)
  @primitive{List.get}

%% Arbitrary element of list: arb
public &T arb(list[&T] L)
  @primitive{List.arb}

public str toString(list[&T] L)
  @primitive{List.toString}

public str makeString(list[int] L)
       throws cannot_convert_int_to_char(str msg)
  @primitive{List.makeString}

public set[&T] toSet(list[&T] L)
  @primitive{List.toSet}

public map[&T, &U] toMap(list[tuple[&T, &U]] L)
       throws domain_not_unique(str msg)
  @primitive{List.toMap}

public rel[&T] toRel(list[&T] L)
  @primitive{List.toRel}

public list[&T] reverse(list[&T] L)
  @primitive{List.reverse}

public &T reducer(list[&T] L, &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : L){
    result = F(result, E)
  };
  return result
}

public list[&T] mapper(list[&T] L, &T F (&T,&T))
  return [F(E) | &T E : L];

%% Minimum element of a list: min
public &T min(list[&T] L){
  &T result = arb(L);
  for(&T E : L)
   if(less(E, result))
      result = min(result, E);
  return result
}

%% Maximum element of a list: max
public &T max(list[&T] L){
  &T result = arb(L);
  for(&T E : L)
   if(less(result, E))
      result = max(result, E);
  return result
}

%% Add elements of a List: sum
public &T sum(list[&T] L, &T zero){
  return reducer(L, +, zero);
}

%% Multiply elements of a list: multiply
public &T multiply(set[&T] R, &T one){
  return reducer(L, *, one);
}

%% Average of elements of a list: average
public &T average(list[&T] L, &T zero){
  return sum(L, zero)/size(L)
}

%% First element of list; first
public &T first(list[&T] L)
       throws empty_list(str msg)
  @primitive{List.first}

%% Remaining elements of list: rest
public &T rest(list[&T] L)
      throws empty_list(str msg)
  @primitive{List.rest}

%% Sort elements of list: sort
public list[&T] sort(list[&T] L, bool less(&T, &T))
   @primitive{list.sort}

%% --- Tuples ------------------------------------------------

public bool ==(tuple[&T] R, tuple[&T] S)
  @primitive{Tuple.equal}

%% less
public bool <(tuple[&T] R, tuple[&T] S)
  @primitive{Tuple.less}

%% Note the use of + on types to concatenate the types
%% of tuple elements

public tuple[&T + &U] +(tuple[&T] R, tuple[&U] S)
  @primitive{Tuple.add}

public tuple[&T + &U] +(tuple[&T] R, &U E){
  return R + <E>;
}

public tuple[&T + &U] +(&T E, tuple[&U] R){
  return <E> + R;
}

public int size(tuple[&T] R)
  @primitive{Tuple.size}

public value get(tuple[&T] R, int N)
       throws out_of_range(str msg)
  @primitive{Tuple.get}

public str toString(tuple[&T] R)
  @primitive{Tuple.toString}

%% --- Sets  -------------------------------------------------

%% ==

public bool ==(set[&T] R, set[&T] S)
  @primitive{Set.equal}
%% <
public bool <(set[&T] R, set[&T] S)
  @primitive{Set.less}

%% Add two sets (set union): operator +
public set[&T] +(set[&T] R, set[&T] S)
  @primitive{Set.add}

public set[&T] +(set[&T] S, &T E){
  return S + {E}
}

public set[&T] +(&T E, set[&T] S){
  return {E} + S
}

%% Substract two sets (set difference): operator -
public set[&T] -(set[&T] R, set[&T] S)
  @primitive{Set.sub}

public set[&T] -(set[&T] S, &T E){
  return S - {E};
}

public set[&T] -(&T E, set[&T] S){
  return {E} - S;
}

%% Intersection of two sets: operator &
public set[&T] &(set[&T] R, set[&T] S)
  @primitive{Set.intersection}

public set[&T] &(set[&T] S, &T E){
  return S * {E}
}

public set[&T] &(&T E, set[&T] S){
  return {E} * S;
}

%% Size of set: size
public int size(set[&T] R)
  @primitive{Set.size}

%% Arbitrary element of set: arb
public &T arb(set[&T] S)
  @primitive{Set.arb}

public str toString(set[&T] R)
  @primitive{Set.toString}

public list[&T] toList(set[&T] S)
  @primitive{List.toList}

public map[&T, &U] toMap(set[tuple[&T, &U]] S)
       throws non_unique_domain(str msg)
  @primitive{Set.toMap}

public rel[&T] toRel(set[&T] S)
  @primitive{Set.toRel}

public &T reducer(set[&T] S, &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : S){
    result = F(result, E)
  };
  return result
}

public set[&T] mapper(set[&T] S, &T F (&T,&T)){
  return {F(E) | &T E : S};
}

%% Minimum of a set: min
public &T min(set[&T] S){
  &T result = arb(S);
  for(&T E : S)
    result = min(result, E);
  return result
}

%% Maximum of a set: max
public &T max(set[&T] R){
  &T result = arb(R);
  for(&T E : R)
    result = max(result, E);
  return result
}

%% Sum elements of a Set: sum
public &T sum(set[&T] S, &T zero){
  return reducer(S, +, zero);
}

%% Multiply elements of a Set: multiply
public &T multiply(set[&T] S, &T one){
  return reducer(S, *, one);
}

%% Average of elements of a set; average
public &T average(set[&T] S, &T zero){
  return sum(S, zero)/size(R)
}

%% Powerset: power0
public set[set[&T]] power0(set[&T] R)
 throw unimplemented("power0}

%% Powerset: power1
public set[set[&T]] power1(set[&T] R)
  throw unimplemented("power0}

%% --- Maps --------------------------------------------------

public bool ==(map[&T, &U] M1, map[&T, &U] M2)
  @primitive{Map.equal}

public bool <(map[&T, &U] M1, map[&T, &U] M2)
  @primitive{Map.less}

public map[&T] +(map[&T] R, map[&T] S)
  @primitive{Map.add}

public map[&T] +(map[&T] S, &T E){
  return S + {E};
}

public map[&T] +(&T E, map[&T] S){
  return {E} + S
}

%% Substract two maps (set difference): operator -
public map[&T] -(map[&T] R, map[&T] S)
   @primitive{Map.sub}

public map[&T] -(map[&T] S, &T E){
  return S - {E}
}

public map[&T] -(&T E, map[&T] S){
  return {E} - S
}

%% Intersection of two maps: operator &
public map[&T] &(map[&T] R, map[&T] S)
  @primitive{Map.mul}

public map[&T] &(map[&T] S, &T E){
  return S * {E}
}

public map[&T] &(&T E, map[&T] S){
  return {E} * S
}

public int size(map[&T] M)
  @primitive{Map.size}

public &T arb(map[&T] M)
  @primitive{Map.arb}

public str toString(map[&T] R)
  @primitive{Map.toString}

public list[tuple[&T, &U]] toList(map[&T, &U] M)
  @primitive{Map.toList}

public rel[tuple[&T, &U]] toSet(map[&T, &U] M)
  @primitive{Map.toSet}

public rel[tuple[&T, &U]] toRel(map[&T, &U] M)
  @primitive{Map.toRel}

%% Is this meaningfull?
public &T reducer(map[&T] S, &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : S){
    result = F(result, E)
  };
  return result
}

public map[&T] mapper(map[&T] M, &T F (&T,&T)){
  return {F(E) | &T E : M};
}

%% --- Relations ---------------------------------------------

public bool ==(rel[&T] R, rel[&T] S)
  @primitive{Rel.equal}

public bool <(rel[&T] R, rel[&T] S)
  @primitive{Rel.less}

%% Add two relations (union): operator +
public rel[&T] +(rel[&T] R1, rel[&T] R2)
  @primitive{Rel.add}

public rel[&T] +(&T E, rel[&T] R){
  return toRel({E}) + R
}

public rel[&T] +(rel[&T] R, &T E){
  return R + toRel({E})
}

%% Substract two relations (difference): operator -
public rel[&T] -(rel[&T] R1, rel[&T] R2)
  @primitive{Rel.sub}

%% Intersection of two relations: operator &
public rel[&T] *(rel[&T] R1, rel[&T] R1)
  @primitive{Rel.mull}

%% Size of relation: size
public int size(rel[&T] R)
  @primitive{Rel.size}

public &T arb(rel[&T] R)
  @primitive{Rel.arb}

public str toString(rel[&T] R)
  @primitive{Rel.toString}

%% Note: in rel[&T], the type variable &T refers 
%% to the tuple type of the relation.

public list[&T] toList(rel[&T] R)
  @primitive{Rel.toList}

public set[&T] toSet(rel[&T] R)
  @primitive{Rel.toSet}

public rel[&T] toRel(set[&T] S)
  @primitive{Set.toRel}

public rel[&T] mapper(rel[&T] R, &T F (&T,&T)){
  return {F(E) | &T E : R};
}

%% Carthesian product of two sets: product (was: x)
public rel[&T1, &T2] product(rel[&T1] R, rel[&T2] S){
  return {<X, Y> | &T1 X : R, &T2 Y : S}
}

%% Compose two relations: compose (was: o)
public rel[&T1, &T3] compose(rel[&T1, &T2] R,
                                 rel[&T2, &T3] S){
   return {<X, Z> | tuple[&T1 X, &T2 Y1]: R, 
                    tuple[&T2 Y2, &T3 Z]: S, Y1 == Y2}
}

%% Identity relation: id
public rel[&T, &T] id(set[&T] S){
  return { <X, X> | &T X : S}
}

%% Inverse relation: invert (was: inv)
public rel[&T2, &T1] invert (rel[&T1, &T2] R){
  return { <Y, X> | tuple[&T1 X, &T2 Y] : R }
}

%% Complement of relation: complement (was: compl)
public rel[&T1, &T2] complement(rel[&T1, &T2] R){
  return product(domain(R), range(R)) - R
}

%% Domain of relation: domain
public set[&T1] domain (rel[&T1,&T2] R){
  return { X | tuple[&T1 X, &T2 Y] : R }
}

%% Range of relation: range
public set[&T1] range (rel[&T1,&T2] R){
  return { Y | tuple[&T1 X, &T2 Y] : R }
}

%% Carrier of relation: carrier
public set[&T]  carrier (rel[&T,&T] R) {
  return domain(R) + range(R)
}

%% Domain Restriction of a Relation: domainR
public rel[&T1,&T2] domainR (rel[&T1,&T2] R, set[&T1] S){
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, X in S }
}

%% Range Restriction of a Relation: rangeR
public rel[&T1,&T2] rangeR (rel[&T1,&T2] R, set[&T2] S){
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, Y in S }
}

%% Carrier Restriction of a Relation: carrierR
public rel[&T,&T] carrierR (rel[&T,&T] R, set[&T] S){
  return { <X, Y> | tuple[&T X, &T Y] : R, X in S, Y in S }
}

%% Domain Exclusion of a Relation: domainX
public rel[&T1,&T2] domainX (rel[&T1,&T2] R, set[&T1] S){
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, X notin S }
}

%% Range Exclusion of a Relation: rangeX
public rel[&T1,&T2] rangeX (rel[&T1,&T2] R, set[&T2] S){
   { <X, Y> | tuple[&T1 X, &T2 Y] : R, Y notin S }
}

%% Carrier Exclusion of a Relation: carrierX
public rel[&T,&T] carrierX (rel[&T,&T] R, set[&T] S){
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, 
                    X notin S, Y notin S }
}

%% Relations viewed as graphs

type rel[&T,&T] graph[&T];

%% Top of a Graph: top
public set[&T] top(graph[&T] G){
  return domain(G) - range(G)
}

%% Bottom of a Graph: bottom
public set[&T] bottom(graph[&T] G){
  return range(G) - domain(G)
}

%% Reachability with Restriction: reachR
public set[&T] reachR(set[&T] Start, set[&T] Restr,
                          graph[&T] G){
  return range(compose(domainR(G, Start), 
                       carrierR(G, Restr)+))
}

%% Reachability with Exclusion: reachX
public set[&T] reachX(set[&T] Start, set[&T] Excl, 
                          graph[&T] G){
  return range(compose(domainR(G, Start), 
                       carrierX(G, Excl)+))
}

%% Shortest path between pair of nodes
public list[&T] shortestPathPair(&T From, &T To, graph[&T] G)
   @primitive{Graph.shortestPathPair}

%% Shortest path between one node and all others
public set[list[&T]] shortestPathFrom(&T From, graph[&T] G)
   @primitive{Graph.shortestPathFrom}

%% Shortest path between all nodes
public set[list[&T]] shortestPathAll(graph[&T] G)
   @primitive{Graph.shortestPathAll}

%% TO DO

public rel[&T, &T] closure(rel[&T, &T])
  @primitive{Rel.closure}

%% --- Annotations -------------------------------------------

%% Test whether a named annotation exists.
public bool has_annotation(&T Subject)
  @primitive{Annotation.has_annotation};

%% Get the value of a named annotation
public value get_annotation(&T Subject, str Name)
       throws missing_annotation(str msg)
  @primitive{Annotation.get_annotation}

%% Get all annotations
public map[str,value] get_annotations(&T Subject)
  @primitive{Annotation.get_annotation}

%% Set the value of a named annotation
public &T set_annotation(&T Subject, 
                             str Name, value AValue)
  @primitive{Annotation.set_annotation}

%% Set all annotations
public &T set_annotations(&T Subject, 
                              map[str, value] Annos)
  @primitive{Annotation.set_annotations}


%% --- Parsing and Unparsing -------------------------------------

public tree parseFile(str filename)
       throws file_does_not_exist(str msg)
  @primitive{Parse.parseFile}

public tree parseString(str source)
  @primitive{Parse.parseString}

public str unparseToString(tree Subject)
  @primitive{Parse.unparseToString}

public str unparseToFile(tree Subject, str filename)
       throws cannot_create(str msg) 
       throws write_error(str msg) 
  @primitive{Parse.unparseToFile}

%% --- io ----------------------------------------------------

public str readFile(str filename)
       throws does_not_exist(str msg)            
       throws read_error(str msg)
  @primitive{IO.read}

public &T readTerm(str filename) 
       throws does_not_exist(str msg)  
       throws read_error(str msg)
       throws term_error(str msg, loc l)
  @primitive{IO.readTerm}

public void write(str filename, &T Subject) 
       throws cannot_create(str msg)  
       throws write_error(str msg)
  @primitive{IO.write}

public void print(list[value] V...)
  @primitive{IO.print}

public void println(list[value] V...)
  @primitive{IO.println}

%% --- Interface with the Program Database -------------------
%% The following function provide a bare minimum and will
%% have to compared with the current PDB interface.
%% We assume one active PDB that can be opened and closed.
%% Values can be written to and read from the PDB.

%% Idea: it would be nice to model the PDB as a value
%% of type map[str, value] and to access it that way!

public void openPDB(str name) 
       throws cannot_open(str msg)
 @primitive{PDB.open}

public void closePDB()
       throws cannot_close(str msg)
  @primitive{PDB.close}

public void writePDB(str name, &T val)
       throws cannot_write(str msg)
  @primitive{PDB.write}

public &T readPDB(str name)
       throws cannot_read(str msg)
  @primitive{PDB.readPDB}

%% If name is of type set[&T], then the set incr
%% is added to it. Similar for a rel[&T]

public void addSetPDB(str name, set[&T] incr)
       throws does_not_exist(str msg)
  @primitive{PDB.addSet}

public void addRelPDB(str name, rel[&T] incr)
       throws does_not_exist(str msg)
  @primitive{PDB.addRel}

