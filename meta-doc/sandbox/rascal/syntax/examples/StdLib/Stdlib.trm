module RascalStandardLibrary

%% Here is a flat list of library functions that will
%% structured in to coherent submodules.

%% --- Comparison operators ----------------------------------
%% Each type defines == and <. The following
%% functions extend them.

public fun bool <=(&T A, &T B)
  return A < B or A == B

public fun bool >(&T A, &T B)
  return B < A and not A == B

public fun bool >=(&T A, &T B)
  return B < A

public fun &T min(&T A, &T B){
  if(A < B)
    return A
  else
    return B;
}

public fun &T max(&T A, &T B){
  if(A < B)
    return B
  else
    return A;
}

%% --- Boolean (bool) ----------------------------------------

public fun bool ==(bool B1, bool B2)
 primitive("Bool.equal")

public fun bool <(bool B1, bool B2)
  primitive("Bool.less")

public fun bool +(bool B1, bool B2)
  primitive("Bool.add")

public fun bool -(bool B1, bool B2)
 primitive("Bool.sub")

public fun bool *(bool B1, bool B2)
  primitive("Bool.mul")

%% Arbitrary boolean: arb
public fun int arb()
 primitive("Bool.arb")

public fun str toString(bool B)
 primitive("Bool.toString")

%% --- Integer (int)------------------------------------------

public fun bool ==(int I1, int I2)
 primitive("Int.equal")

public fun bool <(int I1, int I2)
  primitive("Int.less")

public fun int +(int I1, int I2)
 primitive("Int.add")

public fun int -(int I1, int I2)
  primitive("-Int")

public fun int *(int I1, int I2)
  primitive("Int.mul")

%% Arbitrary integer: arb
public fun int arb(int bgn, int end)
       throws illegal_argument(str msg) %% if(end - bgn <= 0)
 primitive("Int.arb") 

public fun str toString(int I)
 primitive("toStringInt")

%% --- Double (double) ---------------------------------------

public fun bool ==(double D1, double D2)
  primitive("Double.equal")

public fun bool <(double D1, double D2)
  primitive("Double.less")

public fun double +(double D1, double D2)
  primitive("Double.add")

public fun double -(double D1, double D2)
  primitive("Double.sub")

public fun double *(double D1, double D2)
  primitive("Double.mul")

public fun double /(double D1, double D2)
  primitive("Double.div")

%% Arbitrary double: arb
public fun double arb(double bgn, double end)
       throws illegal_argument(str msg) %% if(end - bgn <= 0)
 primitive("Double.arb")

public fun str toString(double D)
  primitive("Double.toString")

%% --- Strings (str) -----------------------------------------

public fun bool ==(str S1, str S2)
  primitive("String.equal")

public fun bool <(str S1, str S2)
 primitive("String.less")

public fun str +(str S1, str S2)
  primitive("String.add")

public fun int size(str S)
  primitive("String.size")

public fun int get(str S, int N)
       throws out_of_range(str msg)
 primitive("String.get")

public fun list[int] toList(str S)
       throws cannot_convert_int_to_char(str msg)
  primitive("String.toList")
 
public fun set[int] toSet(str S)
  primitive("String.toSet")

public fun str reverse(str S)
  primitive("String.reverse")

%% Add functions for other methods of Java's String class

%% --- Locations ---------------------------------------------

%% The location datatype
data location location(str filename,
                       int beginline,
                       int endline,
                       int begincol,
                       int endcol,
                       int offset,
                       int length);

public fun bool ==(loc L1, loc L2)
  primitive("Location.equal")

public fun bool <(loc L1, loc L2)
  primitive("Location.less")

public fun str toString(loc L)
  primitive("Location.toString")

public fun loc get_location(&T Subject)
       throws location_missing(str msg)
 primitive("Location.get_location")

public fun &T set_location(&T Subject, loc L)
   primitive("Location.set_location")

%% --- Lists -------------------------------------------------

public fun bool ==(list[&T] L1, list[&T] L2)
  primitive("List.equal")

public fun bool <(list[&T] L1, list[&T] L2)
  primitive("List.less")

public fun list[&T] +(list[&T] L1, list[&T] L2)
   primitive("List.add")

public fun list[&T] +(list[&T] L, &T E)
  return L + [E];

public fun list[&T] +(&T E, list[&T] L)
  return [E] + L;

%% Size of list: size
public fun int size(list[&T] L)
  primitive("List.size")

%% Get list element: get
public fun &T get(list[&T] L, int N)
       throws out_of_range(str msg)
  primitive("List.get")

%% Arbitrary element of list: arb
public fun &T arb(list[&T] L)
  primitive("List.arb")

public fun str toString(list[&T] L)
  primitive("List.toString")

public fun str makeString(list[int] L)
       throws cannot_convert_int_to_char(str msg)
  primitive("List.makeString")

public fun set[&T] toSet(list[&T] L)
  primitive("List.toSet")

public fun map[&T, &U] toMap(list[tuple[&T, &U]] L)
       throws domain_not_unique(str msg)
  primitive("List.toMap")

public fun rel[&T] toRel(list[&T] L)
  primitive("List.toRel")

public fun list[&T] reverse(list[&T] L)
  primitive("List.reverse")

public fun &T reduce(list[&T] L, fun &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : L){
    result = F(result, E)
  };
  return result
}

public fun list[&T] mapper(list[&T] L, fun &T F (&T,&T))
  return [F(E) | &T E : L];

%% Minimum element of a list: min
public fun &T min(list[&T] L){
  &T result = arb(L);
  for(&T E : L)
   if(less(E, result))
      result = min(result, E);
  return result
}

%% Maximum element of a list: max
public fun &T max(list[&T] L){
  &T result = arb(L);
  for(&T E : L)
   if(less(result, E))
      result = max(result, E);
  return result
}

%% Add elements of a List: sum
public fun &T sum(list[&T] L, &T zero){
  return reduce(L, +, zero);
}

%% Multiply elements of a list: multiply
public fun &T multiply(set[&T] R, &T one){
  return reduce(L, *, one);
}

%% Average of elements of a list: average
public fun &T average(list[&T] L, &T zero)
  return sum(L, zero)/size(L)

%% First element of list; first
public fun &T first(list[&T] L)
       throws empty_list(str msg)
  primitive("List.first")

%% Remaining elements of list: rest
public fun &T rest(list[&T] L)
      throws empty_list(str msg)
  primitive("List.rest")

%% --- Tuples ------------------------------------------------

public fun bool ==(tuple[&T] R, tuple[&T] S)
  primitive("Tuple.equal")

%% less
public fun bool <(tuple[&T] R, tuple[&T] S)
  primitive("Tuple.less")

%% Note the use of + on types to concatenate the types
%% of tuple elements

public fun tuple[&T + &U] +(tuple[&T] R, tuple[&U] S)
  primitive("Tuple.add")

public fun tuple[&T + &U] +(tuple[&T] R, &U E){
  return R + <E>;
}

public fun tuple[&T + &U] +(&T E, tuple[&U] R){
  return <E> + R;
}

public fun int size(tuple[&T] R)
  primitive("Tuple.size")

public fun value get(tuple[&T] R, int N)
       throws out_of_range(str msg)
  primitive("Tuple.get")

public fun str toString(tuple[&T] R)
  primitive("Tuple.toString")

%% --- Sets  -------------------------------------------------

%% ==

public fun bool ==(set[&T] R, set[&T] S)
  primitive("Set.equal")
%% <
public fun bool <(set[&T] R, set[&T] S)
  primitive("Set.less")

%% Add two sets (set union): add (operator +)
public fun set[&T] +(set[&T] R, set[&T] S)
  primitive("Set.add")

public fun set[&T] +(set[&T] S, &T E)
  return S + {E}

public fun set[&T] +(&T E, set[&T] S)
  return {E} + S

%% Substract two sets (set difference): sub (operator -)
public fun set[&T] -(set[&T] R, set[&T] S)
  primitive("Set.sub")

public fun set[&T] -(set[&T] S, &T E)
  return S - {E};

public fun set[&T] -(&T E, set[&T] S)
  return {E} - S;

%% Multiply two sets (set intersection): mul (operator *)
public fun set[&T] *(set[&T] R, set[&T] S)
  primitive("Set.mul")

public fun set[&T] *(set[&T] S, &T E)
  return S * {E}

public fun set[&T] *(&T E, set[&T] S)
  return {E} * S;

%% Size of set: size
public fun int size(set[&T] R)
  primitive("Set.size")

%% Arbitrary element of set: arb
public fun &T arb(set[&T] S)
  primitive("Set.arb")

public fun str toString(set[&T] R)
  primitive("Set.toString")

public fun list[&T] toList(set[&T] S)
  primitive("List.toList")

public fun map[&T, &U] toMap(set[tuple[&T, &U]] S)
       throws non_unique_domain(str msg)
  primitive("Set.toMap")

public fun rel[&T] toRel(set[&T] S)
  primitive("Set.toRel")

public fun &T reduce(set[&T] S, fun &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : S){
    result = F(result, E)
  };
  return result
}

public fun set[&T] mapper(set[&T] S, fun &T F (&T,&T))
  return {F(E) | &T E : S};

%% Minimum of a set: min
public fun &T min(set[&T] S){
  &T result = arb(S);
  for(&T E : S)
    result = min(result, E);
  return result
}

%% Maximum of a set: max
public fun &T max(set[&T] R){
  &T result = arb(R);
  for(&T E : R)
    result = max(result, E);
  return result
}

%% Sum elements of a Set: sum
public fun &T sum(set[&T] S, &T zero){
  return reduce(S, +, zero);
}

%% Multiply elements of a Set: multiply
public fun &T multiply(set[&T] S, &T one){
  return reduce(S, *, one);
}

%% Average of elements of a set; average
public fun &T average(set[&T] S, &T zero)
  return sum(S, zero)/size(R)

%% Powerset: power0
public fun set[set[&T]] power0(set[&T] R)
 throw unimplemented("power0")

%% Powerset: power1
public fun set[set[&T]] power1(set[&T] R)
  throw unimplemented("power0")

%% --- Maps --------------------------------------------------

public fun bool ==(map[&T, &U] M1, map[&T, &U] M2)
  primitive("Map.equal")

public fun bool <(map[&T, &U] M1, map[&T, &U] M2)
  primitive("Map.less")

public fun map[&T] +(map[&T] R, map[&T] S)
  primitive("Map.add")

public fun map[&T] +(map[&T] S, &T E)
  return S + {E};

public fun map[&T] +(&T E, map[&T] S)
  return {E} + S

%% Substract two maps (set difference): sub (operator -)
public fun map[&T] -(map[&T] R, map[&T] S)
   primitive("Map.sub")

public fun map[&T] -(map[&T] S, &T E)
  return S - {E}

public fun map[&T] -(&T E, map[&T] S)
  return {E} - S

%% Multiply two maps (set intersection): mul (operator *)
public fun map[&T] *(map[&T] R, map[&T] S)
  primitive("Map.mul")

public fun map[&T] *(map[&T] S, &T E)
  return S * {E}

public fun map[&T] *(&T E, map[&T] S)
  return {E} * S

public fun int size(map[&T] M)
  primitive("Map.size")

public fun &T arb(map[&T] M)
  primitive("Map.arb")

public fun str toString(map[&T] R)
  primitive("Map.toString")

public fun list[tuple[&T, &U]] toList(map[&T, &U] M)
  primitive("Map.toList")

public fun rel[tuple[&T, &U]] toSet(map[&T, &U] M)
  primitive("Map.toSet")

public fun rel[tuple[&T, &U]] toRel(map[&T, &U] M)
  primitive("Map.toRel")

%% Is this meaningfull?
public fun &T reduce(map[&T] S, fun &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : S){
    result = F(result, E)
  };
  return result
}

public fun map[&T] mapper(map[&T] M, fun &T F (&T,&T))
  return {F(E) | &T E : M};

%% --- Relations ---------------------------------------------

public fun bool ==(rel[&T] R, rel[&T] S)
  primitive("Rel.equal")

public fun bool <(rel[&T] R, rel[&T] S)
  primitive("Rel.less")

%% Add two relations (union): add (operator +)
public fun rel[&T] +(rel[&T] R1, rel[&T] R2)
  primitive("Rel.add")

public fun rel[&T] +(&T E, rel[&T] R)
  return toRel({E}) + R

public fun rel[&T] +(rel[&T] R, &T E)
  return R + toRel({E})

%% Substract two relations (difference): sub (operator -)
public fun rel[&T] -(rel[&T] R1, rel[&T] R2)
  primitive("Rel.sub")

%% Multiply two relations (intersection): mul (operator *)
public fun rel[&T] *(rel[&T] R1, rel[&T] R1)
  primitive("Rel.mull")

%% Size of relation: size
public fun int size(rel[&T] R)
  primitive("Rel.size")

public fun &T arb(rel[&T] R)
  primitive("Rel.arb")

public fun str toString(rel[&T] R)
  primitive("Rel.toString")

%% Note: in rel[&T], the type variable &T refers 
%% to the tuple type of the relation.

public fun list[&T] toList(rel[&T] R)
  primitive("Rel.toList")

public fun set[&T] toSet(rel[&T] R)
  primitive("Rel.toSet")

public fun rel[&T] toRel(set[&T] S)
  primitive("Set.toRel")

public fun rel[&T] mapper(rel[&T] R, fun &T F (&T,&T))
  return {F(E) | &T E : R};

%% Carthesian product of two sets: product (was: x)
public fun rel[&T1, &T2] product(rel[&T1] R, rel[&T2] S)
  return {<X, Y> | &T1 X : R, &T2 Y : S}

%% Compose two relations: compose (was: o)
public fun rel[&T1, &T3] compose(rel[&T1, &T2] R,
                                 rel[&T2, &T3] S)
   return {<X, Z> | tuple[&T1 X, &T2 Y1]: R, 
                    tuple[&T2 Y2, &T3 Z]: S, Y1 == Y2}

%% Identity relation: id
public fun rel[&T, &T] id(set[&T] S)
  return { <X, X> | &T X : S}

%% Inverse relation: invert (was: inv)
public fun rel[&T2, &T1] invert (rel[&T1, &T2] R)
  return { <Y, X> | tuple[&T1 X, &T2 Y] : R }

%% Complement of relation: complement (was: compl)
public fun rel[&T1, &T2] complement(rel[&T1, &T2] R)
  return product(domain(R), range(R)) - R

%% Domain of relation: domain
public fun set[&T1] domain (rel[&T1,&T2] R)
  return { X | tuple[&T1 X, &T2 Y] : R }

%% Range of relation: range
public fun set[&T1] range (rel[&T1,&T2] R)
  return { Y | tuple[&T1 X, &T2 Y] : R }

%% Carrier of relation: carrier
public fun set[&T]  carrier (rel[&T,&T] R) 
  return domain(R) + range(R)

%% Domain Restriction of a Relation: domainR
public fun rel[&T1,&T2] domainR (rel[&T1,&T2] R, set[&T1] S)
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, X in S }

%% Range Restriction of a Relation: rangeR
public fun rel[&T1,&T2] rangeR (rel[&T1,&T2] R, set[&T2] S)
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, Y in S }

%% Carrier Restriction of a Relation: carrierR
public fun rel[&T,&T] carrierR (rel[&T,&T] R, set[&T] S)
  return { <X, Y> | tuple[&T X, &T Y] : R, X in S, Y in S }

%% Domain Exclusion of a Relation: domainX
public fun rel[&T1,&T2] domainX (rel[&T1,&T2] R, set[&T1] S)
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, X notin S }

%% Range Exclusion of a Relation: rangeX
public fun rel[&T1,&T2] rangeX (rel[&T1,&T2] R, set[&T2] S)
   { <X, Y> | tuple[&T1 X, &T2 Y] : R, Y notin S }

%% Carrier Exclusion of a Relation: carrierX
public fun rel[&T,&T] carrierX (rel[&T,&T] R, set[&T] S)
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, 
                    X notin S, Y notin S }

%% Relations viewed as graphs

%% Top of a Relation: top
public fun set[&T] top(rel[&T, &T] R)
  return domain(R) - range(R)

%% Bottom of a Relation: bottom
public fun set[&T] bottom(rel[&T,&T] R)
  return range(R) - domain(R)

%% Reachability with Restriction: reachR
public fun set[&T] reachR(set[&T] Start, set[&T] Restr,
                          rel[&T,&T] Rel)
  return range(compose(domainR(Rel, Start), 
                       carrierR(Rel, Restr)+))

%% Reachability with Exclusion: reachX
public fun set[&T] reachX(set[&T] Start, set[&T] Excl, 
                          rel[&T,&T] Rel)
  return range(compose(domainR(Rel, Start), 
                       carrierX(Rel, Excl)+))

%% TO DO

public fun rel[&T, &T] closure(rel[&T, &T])
  primitive("Rel.closure")

%% --- Annotations -------------------------------------------

%% Test whether a named annotation exists.
public fun bool has_annotation(&T Subject)
  primitive("Annotation.has_annotation");

%% Get the value of a named annotation
public fun value get_annotation(&T Subject, str Name)
       throws missing_annotation(str msg)
  primitive("Annotation.get_annotation")

%% Get all annotations
public fun map[str,value] get_annotations(&T Subject)
  primitive("Annotation.get_annotation")

%% Set the value of a named annotation
public fun &T set_annotation(&T Subject, 
                             str Name, value AValue)
  primitive("Annotation.set_annotation")

%% Set all annotations
public fun &T set_annotations(&T Subject, 
                              map[str, value] Annos)
  primitive("Annotation.set_annotations")


%% --- Parsing/Unparsing -------------------------------------

public fun &T parseFile(str filename)
       throws file_does_not_exist(str msg)
  primitive("Parse.parseFile")

%% TODO
public fun &T parseString(str source)
  primitive("Parse.parseString")

%% TODO
public fun str unparseToString(&T Subject)
  primitive("Parse.unparseToString")

public fun str unparseToFile(&T Subject, str filename)
       throws cannot_create(str msg) 
       throws write_error(str msg) 
  primitive("Parse.unparseToFile")

%% --- io ----------------------------------------------------

public fun str readFile(str filename)
       throws does_not_exist(str msg)            
       throws read_error(str msg)
  primitive("IO.read")

public fun &T readTerm(str filename) 
       throws does_not_exist(str msg)  
       throws read_error(str msg)
       throws term_error(str msg, loc l)
  primitive("IO.readTerm")

public fun void write(str filename, &T Subject) 
       throws cannot_create(str msg)  
       throws write_error(str msg)
  primitive("IO.write")

%% --- Interface with the Program Database -------------------
%% The following function provide a bare minimum and will
%% have to compared with the current PDB interface.
%% We assume one active PDB that can be opened and closed.
%% Values can be written to and read from the PDB.

%% Idea: it would be nice to model the PDB as a value
%% of type map[str, value] and to access it that way!

public fun void openPDB(str name) 
       throws cannot_open(str msg)
 primitive("PDB.open")

public fun void closePDB()
       throws cannot_close(str msg)
  primitive("PDB.close")

public fun void writePDB(str name, &T val)
       throws cannot_write(str msg)
  primitive("PDB.write")

public fun &T readPDB(str name)
       throws cannot_read(str msg)
  primitive("PDB.readPDB")

%% If name is of type set[&T], then the set incr
%% is added to it. Similar for a rel[&T]

public fun void addSetPDB(str name, set[&T] incr)
       throws does_not_exist(str msg)
  primitive("PDB.addSet")

public fun void addRelPDB(str name, rel[&T] incr)
       throws does_not_exist(str msg)
  primitive("PDB.addRel")
