module RascalStandardLibrary

decl-anno function primitive string
decl-anno function memo void
decl-anno function java CompilationUnit

decl-anno all doc string

%% Here is a flat list of library functions that will
%% structured in to coherent submodules.

%% --- Comparison operators ----------------------------------
%% Each type defines == and <. The following
%% functions extend them.

public bool <=(&T A, &T B){
  return A < B or A == B
}

public bool >(&T A, &T B){
  return B < A and not A == B
}

public bool >=(&T A, &T B){
  return B < A
}

public &T min(&T A, &T B){
  if(A < B)
    return A
  else
    return B;
}

public &T max(&T A, &T B){
  if(A < B)
    return B
  else
    return A;
}

%% --- Boolean (bool) ----------------------------------------

@doc{Equality on Booleans}
@primitive{Bool.equal}
  public bool ==(bool B1, bool B2)
 
@primitive{Bool.less}
  public bool <(bool B1, bool B2)

@primitive{Bool.add}
  public bool +(bool B1, bool B2)

@primitive{Bool.sub}
  public bool -(bool B1, bool B2)

@primitive{Bool.mul}
  public bool *(bool B1, bool B2)
 
@primitive{Bool.arb}
  public int arb()

@primitive{Bool.toString}
  public str toString(bool B)

@primitive{Bool.toInt}
  public int toInt(bool B)

@primitive{Bool.toDouble}
  public double toDouble(bool B)

%% --- Integer (int)------------------------------------------

@primitive{Int.equal}
  public bool ==(int I1, int I2)

@primitive{Int.less}
  public bool <(int I1, int I2)

@primitive{Int.add}
  public int +(int I1, int I2)

@primitive{Int.sub}
  public int -(int I1, int I2)

@primitive{Int.mul}
  public int *(int I1, int I2)
 
@primitive{Int.div}
  public int /(int I1, int I2)
  throws divide_by_zero(str msg)

@primitive{Int.arb} 
  public int arb(int bgn, int end)
  throws illegal_argument(str msg) %% if(end - bgn <= 0)

@primitive{Int.toDouble}
  public double toDouble(int I)

@primitive{toStringInt}
  public str toString(int I)

%% --- Double (double) ---------------------------------------

@primitive{Double.equal}
  public bool ==(double D1, double D2)

public bool ==(double D, int I){
  return D == toDouble(I)
}

public bool ==(int I, double D){
  return toDouble(I) == D
}

@primitive{Double.less}
  public bool <(double D1, double D2)

public bool <(double D, int I){
  return D < toDouble(I)
}

public bool <(int I, double D){
  return toDouble(I) < D
}

@primitive{Double.add}
  public double +(double D1, double D2)

public bool +(double D, int I){
  return D + toDouble(I)
}

public bool +(int I, double D){
  return toDouble(I) + D
}

@primitive{Double.sub}
  public double -(double D1, double D2)

public bool -(double D, int I){
  return D - toDouble(I)
}

public bool -(int I, double D){
  return toDouble(I) - D
}

@primitive{Double.mul}
  public double *(double D1, double D2)

public bool *(double D, int I){
  return D * toDouble(I)
}

public bool *(int I, double D){
  return toDouble(I) * D
}

@primitive{Double.div}
  public double /(double D1, double D2)
  throws divide_by_zero(str msg)
 
public bool /(double D, int I){
  return D / toDouble(I)
}

public bool /(int I, double D){
  return toDouble(I) / D
}

@primitive{Double.arb}
  public double arb(double bgn, double end)
  throws illegal_argument(str msg) %% if(end - bgn <= 0)

@primitive{Double.toInt}
  public int toInt(double D)
 
@primitive{Double.toString}
  public str toString(double D)

%% --- Strings (str) -----------------------------------------

@primitive{String.equal}
  public bool ==(str S1, str S2)

@primitive{String.less}
  public bool <(str S1, str S2)

@primitive{String.add}
  public str +(str S1, str S2)

@primitive{String.size}
  public int size(str S)

@primitive{String.get}
  public int get(str S, int N)
  throws out_of_range(str msg)

@primitive{String.toInt}
  public int toInt(str S)
  throws cannot_convert_to_int(str msg)

@primitive{String.toDouble}
  public int toDouble(str S)
  throws cannot_convert_to_double(str msg)

@primitive{String.toList}
  public list[int] toList(str S)
  throws cannot_convert_int_to_char(str msg)
 
@primitive{String.toSet}
  public set[int] toSet(str S)

@primitive{String.reverse}
  public str reverse(str S)

%% Add functions for other methods of Java's String class

%% --- Locations ---------------------------------------------

%% The location datatype
data location location(str filename,
                       int beginline,
                       int endline,
                       int begincol,
                       int endcol,
                       int offset,
                       int length);

@primitive{Location.equal} 
  public bool ==(loc L1, loc L2)

@primitive{Location.less}
  public bool <(loc L1, loc L2)

@primitive{Location.toString}
  public str toString(loc L)

@primitive{Location.get_location}
  public loc get_location(&T Subject)
  throws location_missing(str msg)

@primitive{Location.set_location}
  public &T set_location(&T Subject, loc L)

%% --- Lists -------------------------------------------------

@primitive{List.equal}
  public bool ==(list[&T] L1, list[&T] L2)

@primitive{List.less}
  public bool <(list[&T] L1, list[&T] L2)

@primitive{List.add}
  public list[&T] +(list[&T] L1, list[&T] L2)

public list[&T] +(list[&T] L, &T E){
  return L + [E];
}

public list[&T] +(&T E, list[&T] L){
  return [E] + L;
}

@primitive{List.size}
  public int size(list[&T] L)
 
@primitive{List.get}
@doc{Get list element: get}
  public &T get(list[&T] L, int N)
  throws out_of_range(str msg)

@primitive{List.arb}
  public &T arb(list[&T] L)

@primitive{List.toString}
  public str toString(list[&T] L)

@primitive{List.makeString}
  public str makeString(list[int] L)
  throws cannot_convert_int_to_char(str msg)


@primitive{List.toSet}
  
 public set[&T] toSet(list[&T] L)

@primitive{List.toMap}
  public map[&T, &U] toMap(list[tuple[&T, &U]] L)
  throws domain_not_unique(str msg)
 
@primitive{List.toRel}
  public rel[&T] toRel(list[&T] L)

@primitive{List.reverse}
  public list[&T] reverse(list[&T] L)

public &T reducer(list[&T] L, &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : L){
    result = F(result, E)
  };
  return result
}

public list[&T] mapper(list[&T] L, &T F (&T,&T)){
  return [F(E) | &T E : L];


@doc{Minimum element of a list: min}
public &T min(list[&T] L){
  &T result = arb(L);
  for(&T E : L)
   if(less(E, result))
      result = min(result, E);
  return result
}

@doc{Maximum element of a list: max}
public &T max(list[&T] L){
  &T result = arb(L);
  for(&T E : L)
   if(less(result, E))
      result = max(result, E);
  return result
}

@doc{Add elements of a List: sum}
public &T sum(list[&T] L, &T zero){
  return reducer(L, +, zero);
}

@doc{Multiply elements of a list: multiply}
public &T multiply(set[&T] R, &T one){
  return reducer(L, *, one);
}

@doc{Average of elements of a list: average}
public &T average(list[&T] L, &T zero){
  return sum(L, zero)+size(L)
}

@primitive{List.first}
@doc{First element of list: first}
  public &T first(list[&T] L)
  throws empty_list(str msg)
 
@primitive{List.rest}
@doc{Remaining elements of list: rest}
  public &T rest(list[&T] L)
  throws empty_list(str msg)

@primitive{list.sort}
@doc{Sort elements of list: sort}
  public list[&T] sort(list[&T] L, bool less(&T, &T))
 
%% --- Tuples ------------------------------------------------

@primitive{Tuple.equal}
  public bool ==(tuple[&T] R, tuple[&T] S)
 
@primitive{Tuple.less}
  public bool <(tuple[&T] R, tuple[&T] S)
 
@primitive{Tuple.add}
  public tuple[&T + &U] +(tuple[&T] R, tuple[&U] S)

public tuple[&T + &U] +(tuple[&T] R, &U E){
  return R + <E>;
}

public tuple[&T + &U] +(&T E, tuple[&U] R){
  return <E> + R;
}

@primitive{Tuple.size}
  public int size(tuple[&T] R)

@primitive{Tuple.get}
  public value get(tuple[&T] R, int N)
  throws out_of_range(str msg)

@primitive{Tuple.toString}
  public str toString(tuple[&T] R)

%% --- Sets  -------------------------------------------------

@primitive{Set.equal}
  public bool ==(set[&T] R, set[&T] S)

@primitive{Set.less}
  public bool <(set[&T] R, set[&T] S)

@primitive{Set.add}
@doc{Add two sets (set union): operator +}
  public set[&T] +(set[&T] R, set[&T] S)

public set[&T] +(set[&T] S, &T E){
  return S + {E}
}

public set[&T] +(&T E, set[&T] S){
  return {E} + S
}

@primitive{Set.sub}
@doc{Substract two sets (set difference): operator -}
  public set[&T] -(set[&T] R, set[&T] S)

public set[&T] -(set[&T] S, &T E){
  return S - {E};
}

public set[&T] -(&T E, set[&T] S){
  return {E} - S;
}

@primitive{Set.intersection}
@doc{Intersection of two sets: operator &}
  public set[&T] &(set[&T] R, set[&T] S)

public set[&T] &(set[&T] S, &T E){
  return S & {E}
}

public set[&T] &(&T E, set[&T] S){
  return {E} & S;
}

@primitive{Set.size}
  public int size(set[&T] S)

@primitive{Set.arb}
  public &T arb(set[&T] S)

@primitive{Set.toString}
  public str toString(set[&T] S)

@primitive{List.toList}
  public list[&T] toList(set[&T] S)

@primitive{Set.toMap}
  public map[&T, &U] toMap(set[tuple[&T, &U]] S)
  throws non_unique_domain(str msg)

@primitive{Set.toRel}
  public rel[&T] toRel(set[&T] S)

public &T reducer(set[&T] S, &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : S){
    result = F(result, E)
  };
  return result
}

public set[&T] mapper(set[&T] S, &T F (&T,&T)){
  return {F(E) | &T E : S};
}

@doc{Minimum of a set: min}
public &T min(set[&T] S){
  &T result = arb(S);
  for(&T E : S)
    result = min(result, E);
  return result
}

@doc{Maximum of a set: max}
public &T max(set[&T] R){
  &T result = arb(R);
  for(&T E : R)
    result = max(result, E);
  return result
}

@doc{Sum elements of a Set: sum}
public &T sum(set[&T] S, &T zero){
  return reducer(S, +, zero);
}

@doc{Multiply elements of a Set: multiply}
public &T multiply(set[&T] S, &T one){
  return reducer(S, *, one);
}

@doc{Average of elements of a set: average}
public &T average(set[&T] S, &T zero){
  return sum(S, zero)+size(R)
}

%% Powerset: power0
public set[set[&T]] power0(set[&T] R)
 throw unimplemented("power0}

%% Powerset: power1
public set[set[&T]] power1(set[&T] R)
  throw unimplemented("power0}

%% --- Maps --------------------------------------------------

@primitive{Map.equal}
  public bool ==(map[&T, &U] M1, map[&T, &U] M2)

@primitive{Map.less}
  public bool <(map[&T, &U] M1, map[&T, &U] M2)
  
@primitive{Map.add}
  public map[&T] +(map[&T] R, map[&T] S)

public map[&T] +(map[&T] S, &T E){
  return S + {E};
}

public map[&T] +(&T E, map[&T] S){
  return {E} + S
}

@primitive{Map.sub}
@doc{Substract two maps (set difference): operator -}
  public map[&T] -(map[&T] R, map[&T] S)

public map[&T] -(map[&T] S, &T E){
  return S - {E}
}

public map[&T] -(&T E, map[&T] S){
  return {E} - S
}

@primitive{Map.mul}
@doc{Intersection of two maps: operator &}
  public map[&T] &(map[&T] R, map[&T] S)

public map[&T] &(map[&T] S, &T E){
  return S & {E}
}

public map[&T] &(&T E, map[&T] S){
  return {E} & S
}

@primitive{Map.size}
  public int size(map[&T] M)

@primitive{Map.arb}
  public &T arb(map[&T] M)

@primitive{Map.toString}
  public str toString(map[&T] R)

@primitive{Map.toList}
  public list[tuple[&T, &U]] toList(map[&T, &U] M)

@primitive{Map.toSet}
  public rel[tuple[&T, &U]] toSet(map[&T, &U] M)

@primitive{Map.toRel}
  public rel[tuple[&T, &U]] toRel(map[&T, &U] M)

%% Is this meaningfull?
public &T reducer(map[&T] S, &T F (&T,&T), &T unit){
  &T result = unit;
  for(&T E : S){
    result = F(result, E)
  };
  return result
}

public map[&T] mapper(map[&T] M, &T F (&T,&T)){
  return {F(E) | &T E : M};
}

%% --- Relations ---------------------------------------------

@primitive{Rel.equal}
  public bool ==(rel[&T] R, rel[&T] S)

@primitive{Rel.less}
  public bool <(rel[&T] R, rel[&T] S)

@primitive{Rel.add}
@doc{Add two relations (union): operator +}
  public rel[&T] +(rel[&T] R1, rel[&T] R2)

public rel[&T] +(&T E, rel[&T] R){
  return toRel({E}) + R
}

public rel[&T] +(rel[&T] R, &T E){
  return R + toRel({E})
}

@primitive{Rel.sub}
@doc{Substract two relations (difference): operator -}
  public rel[&T] -(rel[&T] R1, rel[&T] R2)

@doc{Intersection of two relations: operator &}
@primitive{Rel.inter}
  public rel[&T] &(rel[&T] R1, rel[&T] R1)

@primitive{Rel.size}
  public int size(rel[&T] R)

@primitive{Rel.arb}
  public &T arb(rel[&T] R)

public str toString(rel[&T] R)
  @primitive{Rel.toString}

%% Note: in rel[&T], the type variable &T refers 
%% to the tuple type of the relation.

@primitive{Rel.toList}
  public list[&T] toList(rel[&T] R)

@primitive{Rel.toSet}
  public set[&T] toSet(rel[&T] R)
 
@primitive{Set.toRel}
  public rel[&T] toRel(set[&T] S)

public rel[&T] mapper(rel[&T] R, &T F (&T,&T)){
  return {F(E) | &T E : R};
}

%% Carthesian product of two sets: product (was: x)
public rel[&T1, &T2] product(rel[&T1] R, rel[&T2] S){
  return {<X, Y> | &T1 X : R, &T2 Y : S}
}

%% Compose two relations: compose (was: o)
public rel[&T1, &T3] compose(rel[&T1, &T2] R,
                                 rel[&T2, &T3] S){
   return {<X, Z> | tuple[&T1 X, &T2 Y1]: R, 
                    tuple[&T2 Y2, &T3 Z]: S, Y1 == Y2}
}

%% Identity relation: id
public rel[&T, &T] id(set[&T] S){
  return { <X, X> | &T X : S}
}

%% Inverse relation: invert (was: inv)
public rel[&T2, &T1] invert (rel[&T1, &T2] R){
  return { <Y, X> | tuple[&T1 X, &T2 Y] : R }
}

%% Complement of relation: complement (was: compl)
public rel[&T1, &T2] complement(rel[&T1, &T2] R){
  return product(domain(R), range(R)) - R
}

%% Domain of relation: domain
public set[&T1] domain (rel[&T1,&T2] R){
  return { X | tuple[&T1 X, &T2 Y] : R }
}

%% Range of relation: range
public set[&T1] range (rel[&T1,&T2] R){
  return { Y | tuple[&T1 X, &T2 Y] : R }
}

%% Carrier of relation: carrier
public set[&T]  carrier (rel[&T,&T] R) {
  return domain(R) + range(R)
}

%% Domain Restriction of a Relation: domainR
public rel[&T1,&T2] domainR (rel[&T1,&T2] R, set[&T1] S){
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, X in S }
}

%% Range Restriction of a Relation: rangeR
public rel[&T1,&T2] rangeR (rel[&T1,&T2] R, set[&T2] S){
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, Y in S }
}

%% Carrier Restriction of a Relation: carrierR
public rel[&T,&T] carrierR (rel[&T,&T] R, set[&T] S){
  return { <X, Y> | tuple[&T X, &T Y] : R, X in S, Y in S }
}

%% Domain Exclusion of a Relation: domainX
public rel[&T1,&T2] domainX (rel[&T1,&T2] R, set[&T1] S){
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, X notin S }
}

%% Range Exclusion of a Relation: rangeX
public rel[&T1,&T2] rangeX (rel[&T1,&T2] R, set[&T2] S){
   { <X, Y> | tuple[&T1 X, &T2 Y] : R, Y notin S }
}

%% Carrier Exclusion of a Relation: carrierX
public rel[&T,&T] carrierX (rel[&T,&T] R, set[&T] S){
  return { <X, Y> | tuple[&T1 X, &T2 Y] : R, 
                    X notin S, Y notin S }
}

%% Relations viewed as graphs

type rel[&T,&T] graph[&T];

%% Top of a Graph: top
public set[&T] top(graph[&T] G){
  return domain(G) - range(G)
}

%% Bottom of a Graph: bottom
public set[&T] bottom(graph[&T] G){
  return range(G) - domain(G)
}

%% Reachability with Restriction: reachR
public set[&T] reachR(set[&T] Start, set[&T] Restr,
                          graph[&T] G){
  return range(compose(domainR(G, Start), 
                       carrierR(G, Restr)+))
}

%% Reachability with Exclusion: reachX
public set[&T] reachX(set[&T] Start, set[&T] Excl, 
                          graph[&T] G){
  return range(compose(domainR(G, Start), 
                       carrierX(G, Excl)+))
}

@primitive{Graph.shortestPathPair}
@doc{Shortest path between pair of nodes}
  public list[&T] shortestPathPair(&T From, &T To, graph[&T] G)
 
@primitive{Graph.shortestPathFrom}
@doc{Shortest path between one node and all others}
  public set[list[&T]] shortestPathFrom(&T From, graph[&T] G)

@primitive{Graph.shortestPathAll}
@doc{Shortest path between all nodes}
  public set[list[&T]] shortestPathAll(graph[&T] G)

%% TO DO

@primitive{Rel.closure}
  public rel[&T, &T] closure(rel[&T, &T])
 

%% --- Annotations -------------------------------------------

@primitive{Annotation.has_annotation};
@doc{Test whether a named annotation exists}
  public bool has_annotation(&T Subject, str Name)

@primitive{Annotation.get_annotation}
@doc{Get the value of a named annotation}
  public value get_annotation(&T Subject, str Name)
  throws missing_annotation(str msg)

@primitive{Annotation.get_annotations}
@doc{Get all annotations}
  public map[str,value] get_annotations(&T Subject)
 
@primitive{Annotation.set_annotation}
@doc{Set the value of a named annotation}
  public &T set_annotation(&T Subject, 
                             str Name, value AValue)

@primitive{Annotation.set_annotations}
@doc{Set all annotations}
public &T set_annotations(&T Subject, 
                              map[str, value] Annos)

%% --- Parsing and Unparsing -------------------------------------

@primitive{Parse.parseFile}
  public tree parseFile(str filename)
  throws file_does_not_exist(str msg)

@primitive{Parse.parseString}
  public tree parseString(str source)
 
@primitive{Parse.unparseToString}
  public str unparseToString(tree Subject)

@primitive{Parse.unparseToFile}
  public str unparseToFile(tree Subject, str filename)
       throws cannot_create(str msg) 
       throws write_error(str msg) 

%% --- io ----------------------------------------------------

@primitive{IO.read}
  public str readFile(str filename)
       throws does_not_exist(str msg)            
       throws read_error(str msg)

@primitive{IO.readTerm}
  public &T readTerm(str filename) 
       throws does_not_exist(str msg)  
       throws read_error(str msg)
       throws term_error(str msg, loc l)

@primitive{IO.write}
  public void write(str filename, &T Subject) 
       throws cannot_create(str msg)  
       throws write_error(str msg)

@primitive{IO.print}
  public void print(list[value] V...)

@primitive{IO.println}
  public void println(list[value] V...)
 
%% --- Interface with the Program Database -------------------
%% The following function provide a bare minimum and will
%% have to compared with the current PDB interface.
%% We assume one active PDB that can be opened and closed.
%% Values can be written to and read from the PDB.

%% Idea: it would be nice to model the PDB as a value
%% of type map[str, value] and to access it that way!

@primitive{PDB.open}
  public void openPDB(str name) 
       throws cannot_open(str msg)

@primitive{PDB.close}
  public void closePDB()
       throws cannot_close(str msg)

@primitive{PDB.write}
  public void writePDB(str name, &T val)
       throws cannot_write(str msg)

@primitive{PDB.readPDB}
  public &T readPDB(str name)
       throws cannot_read(str msg)

%% If name is of type set[&T], then the set incr
%% is added to it. Similar for a rel[&T]

@primitive{PDB.addSet}
  public void addSetPDB(str name, set[&T] incr)
       throws does_not_exist(str msg)

@primitive{PDB.addRel}
  public void addRelPDB(str name, rel[&T] incr)
       throws does_not_exist(str msg)