// Simple Boolean constraints based on Section 6.3 of
// K.R. Apt, Principles of Constraint Programming

module BoolConstraints

data Bool btrue;
data Bool bfalse;
data Bool band(Bool L, Bool R);
data Bool bor(Bool L, Bool R);
data Bool beq(Bool L, Bool R);
data Bool var(str N);

bool isVar(Bool X){
  return var(str S) := X;
}

int symCounter = 0;

Bool newVar(str prefix) {
   symCounter += 1;
   return var(prefix + toString(symCounter));
}

// One preprocessing pass over the constraints

set[Bool] preprocess1(set[Bool] constraints){
   set[Bool] result = {};

   for(Bool C : constraints){
   switch(C){
 
   case beq(not(<Bool S>), <Bool T>) =>
        if(!isVar(S)){
           Bool X = newVar("V");
           result += {beq(not(X), T), beq(S, X)};
        }
   // ...
   default:
        result += C;
   }
   return result;
}

// Preprocess as long as possible

set[Bool] preprocess(set[Bool] constraints){

   solve(constraints){
     constraints = preprocess1(constraints);
   }
   return constraints;
}

// Reduce a set of constraints

set[Bool] reduce(set[Bool] constraints){

   innermost visit (constraints){

   case { beq(<Bool X>, <Bool Y>),  beq(<Bool X>, btrue), <set[Bool] R>}
        =>
        {beq(Y, btrue), R};

        // In this rule we use set matching that takes care of commutative and associative
        // variants of the above pattern

   // ...
   }
}

set[Bool] solveBool(set[Bool] constraints){

   return reduce(preprocess(constraints));

}
