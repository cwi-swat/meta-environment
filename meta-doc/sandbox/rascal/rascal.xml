<?xml version="1.0" encoding="US-ASCII"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Rascal Requirements and Design Document</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Tijs</firstname><surname>van der
        Storm</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is a braindump of ideas that is slowly converging to a
    coherent design. See <xref linkend="section.issues" /> for the issues that
    have to be resolved.</para>
  </note>

  <section>
    <title>Introduction</title>

    <para>We have identified the need for better language support for
    specifying and implementing software analysis and transformation tools. In
    this document we embark on the design of a domain-specific language that
    is intended to provide a comprehensive and easy to use set of concepts for
    that domain. The goals of the envisaged language (with working name
    Rascal) are:</para>

    <itemizedlist>
      <listitem>
        <para>Providing a successor of ASF+SDF that has of all its benefits
        and fixes all of its shortcomings.</para>
      </listitem>

      <listitem>
        <para>Separating pure syntax definitions (SDF) from function
        definitions.</para>
      </listitem>

      <listitem>
        <para>Easy syntax-directed analysis of programming languages.</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction.</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning.</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation.</para>
      </listitem>

      <listitem>
        <para>Efficient and scalable implementation.</para>
      </listitem>

      <listitem>
        <para>Unsurprising concepts, syntax and semantics for a wide audience.
        Where possible we will stay close to C and Java notation.</para>
      </listitem>
    </itemizedlist>

    <para>Many of the above goals are to a certain extent already met in the
    current design of ASF+SDF, and the current design of RScript. What is
    missing is the connection (and to be honest: an efficient implementation
    of relational operators). Alas, any bridge between the two languages is
    both complex to manage and an efficiency bottleneck. This work is an
    attempt to consolidate this engineering trade-off. This basically means
    that we include most features of the RScript language into ASF+SDF.
    Although we take these languages as conceptual starting point, Rascal is a
    completely new design that has an imperative semantics at it's core rather
    than a functional semantics. As a whole, Rascal is a simpler but more
    expressive language.</para>
  </section>

  <section>
    <title>Rascal for various audiences</title>

    <para>In this section we enumerate numerous facts about Rascal that
    advertise it to different audiences</para>

    <section>
      <title>Generic arguments</title>

      <para>What is good about Rascal in a few words?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is a DSL for source code analysis and transformation.
          It provides a pletora of high level statements and expressions,
          taking away the boilerplate of implementing and debugging tools that
          manipulate programs.</para>
        </listitem>

        <listitem>
          <para>Rascal combines the best features of imperative programming
          with the best features of functional programming and term rewriting.
          <itemizedlist>
              <listitem>
                <para>Simple structured statements for control flow and
                variable assignments for data flow are powerful and simple
                features of the imperative programming paradigm. They allow
                control flow and data flow to be understandable and
                traceable.</para>
              </listitem>

              <listitem>
                <para>From functional programming we borrow that all values
                are immutable and non-null. Issues with aliasing and
                referential integrity, such as frequently occur in imperative
                and OO programming therefore do not exist in Rascal.</para>
              </listitem>

              <listitem>
                <para>The Rascal type system is as powerful as most functional
                languages (higher-order polymorphic functions), however to
                make the language debuggable and understandable it, in
                principle, does not provide type inference.</para>
              </listitem>

              <listitem>
                <para>From term rewriting we inherit powerful pattern matching
                facilities, integration with context-free parsing and concrete
                syntax.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>

        <listitem>
          <para>Rascal supports both a scripting experience, and a compiled
          program experience.</para>
        </listitem>

        <listitem>
          <para>Rascal is type safe, but flexible. It's type system prevents
          common programming errors, but still allows ample opportunity for
          reusable code. The reasons are that we allow co-variance in the
          sub-typing relationship, high-order polymorphic functions and
          parameterized data-types.</para>
        </listitem>

        <listitem>
          <para>Rascal allows different styles of programming. From extremely
          high level specification, down to straight imperative
          programming.</para>
        </listitem>

        <listitem>
          <para>Rascal was inspired by and borrows from several other DSL's
          for program analysis and transformation in academia and industry,
          namely ASF+SDF, Rscript, TXL, TOM, DMS, Stratego, Elan, Maude, Grok,
          Haskell, ML and SETL.</para>
        </listitem>

        <listitem>
          <para>Rascal integrates seemlessly with Eclipse IMP and The
          Meta-Environment.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for ASF+SDF programmers</title>

      <para>Rascal is the successor of ASF+SDF. What's the difference? What's
      the same?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal has roughly all the high level features of ASF+SDF and
          some more. Old ASF+SDF specifications can be transformed to Rascal
          programs using a conversion tool.</para>
        </listitem>

        <listitem>
          <para>Rascal still uses SDF for syntax definition and parser
          generation.</para>
        </listitem>

        <listitem>
          <para>Rascal has a module system that is independent of SDF. Rascal
          modules introduce a namespace scope for variables and functions,
          which can be either private or public. Rewrite rules are global as
          in ASF+SDF. Modules can have type parameters as in SDF, which are
          instantiated by import statements.</para>
        </listitem>

        <listitem>
          <para>In Rascal, patterns and variables in concrete syntax may
          optionally be quoted and escaped, and support explicit declaration
          of the top non-terminal to solve ambiguity.<caution>
              <para>How?</para>
            </caution></para>
        </listitem>

        <listitem>
          <para>Rascal rules read in the order of execution instead of first
          the left-hand side, then the conditions, and then the right-hand
          side of ASF+SDF equations</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive and efficient implementations for sets,
          relations and maps</para>
        </listitem>

        <listitem>
          <para>Rascal can be used without SDF, supporting for example regular
          expressions and abstract data types (pure ATerms)</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive support for functions, which have a fixed
          syntax, always return a value and have a body consisting of
          imperative control flow statements. Adding a function will not
          trigger the need for regenerating parse tables as is the case in the
          current ASF+SDF implementation. Function types can be polymorphic in
          their parameters and also allow functions as arguments to implement
          reusable algorithms.</para>
        </listitem>

        <listitem>
          <para>The imperative nature of Rascal allows you to factor out
          common code and nest conditionals, unlike in ASF+SDF where
          alternative control flow paths have to be encoded by enumerating
          equations with non-overlapping conditions.</para>
        </listitem>

        <listitem>
          <para>Rascal is an imperative language, which natively supports I/O
          and other side-effects without work-arounds. When backtracking
          occurs, for example during list matching, Rascal makes sure that
          most side-effects are undone, and that I/O is delayed until no more
          backtracking can occur. Even rewrite rules support side-effects in
          Rascal.</para>
        </listitem>

        <listitem>
          <para>Rascal has native support for traversals, instead of the
          add-on it used to be in ASF+SDF. The visit statement is comparable
          to a traversal function, and is as type-safe as the previous, and
          more programmeable.</para>
        </listitem>

        <listitem>
          <para>Instead of accumulator values of traversal functions in
          ASF+SDF, Rascal simply supports lexically scoped variables that can
          be updated using assignments.</para>
        </listitem>

        <listitem>
          <para>Rascal adds specific expressions for relational calculus, all
          borrowed directly from RScript.</para>
        </listitem>

        <listitem>
          <para>When programming using Rascal functions, instead of rules, the
          control flow of a program becomes easily traceable and debuggable.
          It is simply like stepping through well structured code.</para>
        </listitem>

        <listitem>
          <para>Rascal is based on a Java interpreter, or a Java run-time when
          compiled. So the code is more portable.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for imperative and object-oriented programmers</title>

      <para>Rascal is an imperative DSL with high level statements and
      expressions specifically targeted at the domain of analysis and
      transformation of source code:</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is safe: there are no null values, and all values are
          immutable. Source code and abstract syntax trees, and the facts
          extracted from them are immutable. The Rascal interpreter and
          compiler make sure this is implemented efficiently. Without
          mutability it is easy to combine stages of your programs that
          analyse or annotate with stages that transform. Sharing a value does
          not introduce a coupling like in OO, simply because changes are only
          visible to the code that changes the values.</para>
        </listitem>

        <listitem>
          <para>Rascal is extra safe: it has a type system that prevents
          casting exceptions and other run-time failures. Still the type
          system specifically allows many kinds of combinations. For example,
          unlike in Java a set of integers is a subtype of a set of numbers
          (co-variance), which allows you to reuse algorithm for sets of
          numbers on sets of integers. It also provides true polymorphic and
          functions (no erasure), and functions can safely be parameters to
          other functions.</para>
        </listitem>

        <listitem>
          <para>Rascal provides high level statements and expressions
          for:</para>

          <itemizedlist>
            <listitem>
              <para>Visitors in all kinds of orders, expressed very concisely,
              and type safe.</para>
            </listitem>

            <listitem>
              <para>Pattern matching and construction (with concrete
              syntax!)</para>
            </listitem>

            <listitem>
              <para>Equation/constraint solving</para>
            </listitem>

            <listitem>
              <para>Relational calculus</para>
            </listitem>

            <listitem>
              <para>Rewrite rules for normalization/canonicalization of any
              kind of data-structure</para>
            </listitem>

            <listitem>
              <para>Support for parsing using context-free grammars (via
              importing modules from the SDF language).</para>
            </listitem>

            <listitem>
              <para>(de)Serialization of values</para>
            </listitem>

            <listitem>
              <para>Communication with databases</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Rascal provides typed data constructors for common
          mathematical structures, such as:</para>

          <itemizedlist>
            <listitem>
              <para>terms (a.k.a. abstract data types, tree nodes)</para>
            </listitem>

            <listitem>
              <para>parse trees (derivations of context-free grammars, for
              concrete syntax and direct manipulation of source code)</para>
            </listitem>

            <listitem>
              <para>relations</para>
            </listitem>

            <listitem>
              <para>sets</para>
            </listitem>

            <listitem>
              <para>maps</para>
            </listitem>

            <listitem>
              <para>graphs</para>
            </listitem>

            <listitem>
              <para>tuples</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>In Rascal you can implement high-fidelity source-to-source
          transformations. Without too much overhead, programs can do
          extensive rewriting of the source code without the loss of
          particular layout standards or source code comments.</para>
        </listitem>

        <listitem>
          <para>Rascal is syntax-safe. When you use Rascal to generate or
          transform source code, it statically detects whether the resulting
          source code is syntactically correct.</para>
        </listitem>

        <listitem>
          <para>Rascal is executed by an interpreter written in Java, or it
          can be compiled to Java classes.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Old ASF+SDF programs are translatable to Rascal.</para>
        </listitem>

        <listitem>
          <para>R3: Edit Rascal and SDF and compile complex programs within a
          few minutes maximally (parsetable generation is a major bottleneck
          in current ASF+SDF. This needs to be fixed.)</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability and easy parsing of a
          wide range of source languages.</para>
        </listitem>

        <listitem>
          <para>R5: File I/O (contradicts R5).</para>
        </listitem>

        <listitem>
          <para>R6: Easily accessible fact storage (similar to a heap, but
          remember R5 and the details of backtracking).</para>
        </listitem>

        <listitem>
          <para>R7: List matching (because of R2, influences R7, but also very
          handy for manipulating lists in concrete syntax).</para>
        </listitem>

        <listitem>
          <para>R8: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as scoping),
          allowing to factor out common code.</para>
        </listitem>

        <listitem>
          <para>R9: Syntax trees can be elements of the builtin
          data-structures (but not vice versa).</para>
        </listitem>

        <listitem>
          <para>R10: Try to keep features orthogonal: try to keep the number
          of ways to write down a program minimal, this is not a law since
          other requirements take precedence</para>
        </listitem>

        <listitem>
          <para>R11: Minimize possible syntactic ambiguities; resolve them by
          type checking.</para>
        </listitem>

        <listitem>
          <para>R12: Integrates well with refactoring infra-structure (i.e.
          can provide appropriate interfaces with pre-condition checking,
          previews and commits as found in interactive refactoring
          contexts)</para>
        </listitem>

        <listitem>
          <para>R13: no 'null' values, preventing common programming
          errors</para>
        </listitem>

        <listitem>
          <para>R14: all values immutable, preventing common programming
          errors and allowing for certain kinds of optimizations</para>
        </listitem>

        <listitem>
          <para>R15: should be able to match and construct strings using
          regular expressions (for making the simpler things simple, if you
          can do without a grammar, why not?)</para>
        </listitem>

        <listitem>
          <para>R16: can get/set data from databases, such as the pdb from
          Eclipse IMP, but possibly also from ODBC/JDBC data sources.</para>
        </listitem>

        <listitem>
          <para>R17: type safe, but flexible. We want a type system that
          prevents common programming errors, but still allows ample
          opportunity for reuse.</para>
        </listitem>

        <listitem>
          <para>R18: syntax safe, programmers should not be allowed to
          construct programs that are syntactically incorrect w.r.t a certain
          context-free grammar.</para>
        </listitem>

        <listitem>
          <para>R19: backtracking safe, programmers should not have to deal
          with the mind boggling feature interactions between side-effects and
          backtracking.</para>
        </listitem>

        <listitem>
          <para>R20: traceable/debuggable, programmers should be able to
          easily trace through the execution of a Rascal program using the
          simplest of debugging tools, like printf statements, and the use of
          a simple debugging interface which allows to step through the source
          code and inspect values in a transparent fashion.</para>
        </listitem>

        <listitem>
          <para>R21: minimize the use of type inference, such that the
          programmer must always declare her intentions by providing types for
          functions, data-types and variables. This makes debugging easier and
          providing clear error messages too. When variables are implicitly
          bound by pattern matching or related functionality, exceptions to
          this requirement might be made in favor of conciseness.</para>
        </listitem>

        <listitem>
          <para>R22: allow the implementation of reusable modules and
          functions (i.e. parametric polymorphism and or functions as
          parameters).</para>
        </listitem>

        <listitem>
          <para>R23: we need something like rewrite rules for implementing
          data-types that are always canonicalized/normalized. For some
          analysis algorithms this allows the programmer to implement domain
          specific optimizations over plain relational calculus or tree
          visiting that actually needed for scalability.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Rascal at a glance</title>

    <para>Rascal consists of the following elements:</para>

    <itemizedlist>
      <listitem>
        <para>Modules to group definitions, proving scopes and visibility
        constructs</para>
      </listitem>

      <listitem>
        <para>A type system and corresponding values, providing parameterized
        types, polymorphic functions and higher-order parameters.</para>
      </listitem>

      <listitem>
        <para>Variables to associate a name with a value in some scope.</para>
      </listitem>

      <listitem>
        <para>Parameterized functions.</para>
      </listitem>

      <listitem>
        <para>Abstract, regular expression and syntax patterns to deconstruct
        (match) values and to construct (make) them.</para>
      </listitem>

      <listitem>
        <para>Expressions provide the elementary computations on
        values.</para>
      </listitem>

      <listitem>
        <para>Statements for providing structured control flow and more
        advanced control flow in computations, such as visitors and fixed
        point computations</para>
      </listitem>
    </itemizedlist>

    <para>These elements are summarized in the following subsections.</para>

    <section>
      <title>Modules</title>

      <para>Modules are the organizational unit of Rascal. They may:</para>

      <itemizedlist>
        <listitem>
          <para>Import another Rascal module (suffix: <literal>.ras</literal>)
          using <literal>import</literal>. Imports are not transitive. We do
          allow circular imports.</para>
        </listitem>

        <listitem>
          <para>Import SDF modules (suffix: <literal>.sdf</literal>) using
          <literal>import</literal>.</para>
        </listitem>

        <listitem>
          <para>Import Java modules (for the benefit of functions written in
          Java, suffix <literal>.java</literal>) using
          <literal>import</literal>.</para>
        </listitem>

        <listitem>
          <para>Extend another Rascal module using <literal>extend</literal>.
          This includes a verbatim copy (similar to
          <literal>#include</literal>) of the-module-to-be-extended in the
          current module. We allow redefinitions of declared names. We do not
          allow circular extension.</para>
        </listitem>

        <listitem>
          <para>Define datatypes, subtypes, or rules and functions.</para>
        </listitem>

        <listitem>
          <para>Be parameterized with the names of formal types that are
          instantiated with an actual type when the module is imported.</para>
        </listitem>

        <listitem>
          <para>Contain a main function that is the starting point of
          execution. We allow several flavours of main
          function:<programlisting>public void main() { ... }</programlisting>does
          not give access to program arguments while<programlisting>public void main(list[str] argv) { ... }</programlisting></para>

          <para>gives access to all program arguments. We may add extra types
          that help in parsing command line arguments.</para>
        </listitem>
      </itemizedlist>

      <para>Functions, subtypes and datatypes may be either private to a
      module or public to all modules that import the current module. Rules
      are always public and are globally applied.</para>

      <para>Modules introduce a namespace and qualified names (using the
      <literal>::</literal> operator) may be used to uniquely identify
      elements of a module from the outside. Inside the module, this
      qualification is implicit. The qualified name consist of two parts: a
      directory name (a list of names separated by <literal>/</literal>) and a
      module name.</para>

      <para>Rascal modules are located in a file with the name of the module,
      with suffix <literal>.ras</literal>. They should be located in a
      directory corresponding to the directory part of the module name. From
      other modules,
      <literal><replaceable>M</replaceable>::<replaceable>F</replaceable></literal>
      denotes function <replaceable>F</replaceable> from module
      <replaceable>M</replaceable>.</para>
    </section>

    <section>
      <title>Names</title>

      <para>Rascal aims at seamless integration with Java and its names adhere
      to the following conventions:</para>

      <itemizedlist>
        <listitem>
          <para>A Rascal Name is identical to a Java Indentifier except that
          we <emphasis>do</emphasis> allow dashes (<literal>-</literal>) but
          do <emphasis>not</emphasis> allow the dollar sign
          (<literal>$</literal>) in names. All reserved words in both Java and
          Rascal cannot be used as a Name. <remark>For better syntax errors it
          is probably better to warn for Java keywords later
          on.</remark></para>
        </listitem>

        <listitem>
          <para>Sorts and Symbols are inherited from SDF but we extend sort
          (that may only start with an uppercase letter in SDF) to be a more
          liberal, and allow Names instead.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Types and Subtypes</title>

      <section>
        <title>Types</title>

        <para>The type system (and notation) are mostly similar to that of
        Rscript, but</para>

        <itemizedlist>
          <listitem>
            <para>We have a type hierarchy that defines a partial order on
            types.</para>
          </listitem>

          <listitem>
            <para>There is a single top for this type hierarchy, it is called
            "<literal>value</literal>" and a single bottom that is called
            "<literal>void</literal>".</para>
          </listitem>

          <listitem>
            <para>There are built-in types (<literal>bool</literal>,
            <literal>int</literal>, <literal>double</literal>,
            <literal>str</literal>, <literal>loc</literal>).</para>
          </listitem>

          <listitem>
            <para>Symbols (as defined by an SDF module) are also types.<note>
                <para>The currently supported subset of SDF symbols contains:
                single and double quoted literal, character class, sort name,
                lists with and without separator, alternative, and option.
                This subset will be extended on demand.</para>
              </note><note>
                <para>There is no automatic mapping between the built-in types
                and types generated by an SDF module. The programmer is
                responsible for conversion. Typical library functions that are
                helpfull are:</para>

                <itemizedlist>
                  <listitem>
                    <para><literal>unparseToString</literal> converts any
                    value of an SDF type to a string.</para>
                  </listitem>

                  <listitem>
                    <para><literal>toInt</literal> converts strings to
                    integers.</para>
                  </listitem>

                  <listitem>
                    <para><literal>toDouble</literal> converts strings to
                    doubles.</para>
                  </listitem>
                </itemizedlist>
              </note></para>
          </listitem>

          <listitem>
            <para>All syntactic types are a subtype of the type
            <literal>tree</literal> that corresponds to UPTR. Up casts from a
            subtype to an enclosing type are automatic. The type
            <literal>tree</literal> is "special" in the following
            sense:</para>

            <itemizedlist>
              <listitem>
                <para>Parsers generate values of type
                <literal>tree</literal>.</para>
              </listitem>

              <listitem>
                <para>Although the type <literal>tree</literal> can be defined
                in Rascal, its definition is built-in in order to preserve the
                consistency with the parser.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Types for sets, maps, relations and tuples can be formed
            from types; Maps, relations and tuples can have optional column
            names.</para>
          </listitem>

          <listitem>
            <para>Functions can be polymorphic in their parameters as well as
            in their return type.</para>
          </listitem>

          <listitem>
            <para>Function parameters can be function types, meaning that the
            name of a properly typed function or a locally defined anonymous
            function can be passed as a parameter.</para>
          </listitem>

          <listitem>
            <para>The last argument of a function may be of the form
            <literal>list[<replaceable>T</replaceable>]
            <replaceable>Name</replaceable>...</literal> and indicates a
            variable list of remaining arguments of type
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para>Data declarations may introduce new structured types and
            have the form<programlisting>data N Pat1 | Pat2 | ...</programlisting>where
            N is the name of the datatype and Pat1, Pat2, are prefix patterns
            describing the variants of the datatype.<note>
                <para>We assume that all constructors for a datatype lead to a
                corresponding function to construct a term of that datatype.
                This eliminates the need to quote abstract terms in
                statements.</para>
              </note><caution>
                <para>Constructors can also generate types.</para>
              </caution></para>

            <note>
              <para>Constructor names of datatypes may be quoted in order to
              avoid clashes with reserved words or illegal names.</para>
            </note>
          </listitem>

          <listitem>
            <para>We have <emphasis>views</emphasis> on data types that define
            templates or overlays over an existing type. The form
            is:<programlisting>view Bool &lt;: tree and appl(...) | or appl(...)</programlisting></para>

            <para>This defines the type <literal>Bool</literal> as a view on
            trees with two alternatives named <literal>and</literal> and
            <literal>or</literal>. Each view should be of type
            <literal>tree</literal>. Views for the same type are
            exclusive.</para>
          </listitem>

          <listitem>
            <para>Types may include type variables like
            <literal>&amp;<replaceable>T</replaceable></literal> as in Rscript
            with the following refinement:</para>

            <itemizedlist>
              <listitem>
                <para>In the type
                <literal>rel[&amp;<replaceable>*T</replaceable>]</literal>,
                the type variable
                <literal>&amp;<replaceable>T</replaceable></literal> is bound
                to the tuple type of the relation, i.e. an actual type
                <literal>rel[int,str]</literal> will bind
                &amp;<replaceable>*T</replaceable> to the type
                <literal>tuple[int,str]</literal>.</para>
              </listitem>

              <listitem>
                <para>Composition is only allowed in the result type.</para>
              </listitem>

              <listitem>
                <para>In a similar fashion, in
                <literal>map[&amp;<replaceable>*T</replaceable>]</literal>,
                the type variable
                <literal>&amp;<replaceable>*T</replaceable></literal> is bound
                to the tuple type of the map.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>A type declaration introduces a name for a new type that is
            a subtype of a given type, e.g.,<programlisting>type rel[node,node] Graph</programlisting>introduces
            the type <literal>Graph</literal> as a subtype of
            <literal>rel[node,node]</literal>. There are no built-in
            subtypes.</para>
          </listitem>

          <listitem>
            <para>The name that is introduced by a type declaration may even
            be parameterized with one or more type variables,
            e.g.,<programlisting>type rel[&amp;Node, &amp;Node] Graph[&amp;Node]</programlisting></para>

            <para>Of course, the type variables that are used in the type in
            the left part should occur as parameters in the right part of the
            definition and vice versa.</para>
          </listitem>

          <listitem>
            <para>Types may be declared only once and are mutually
            exclusive.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Subtypes</title>

        <para>The type hierarchy leads to a subtype relation &lt;: that can be
        defined (in ASF+SDF) as follows:<programlisting>%% Subtyping rules (&lt;:) on Types

[let00] void &lt;: T                          = true

[let01] T &lt;: value                         = true

[let02] T &lt;: T                             = true

[let03] T &lt;: &amp; N                           = true

[let04] T &lt;: &amp;N &lt;: T'                      = T &lt;: T'

[let05] N[&amp;T] &lt;: N[&amp;U]                     = true

[let06] list[T] &lt;: list[T']                = T &lt;: T'

[let07] set[T] &lt;: set[T']                  = T &lt;: T'

[let08] tuple[ONTs] &lt;: tuple[ONTs']        = ONTs &lt;: ONTs'

[let09] map[T1, T2] &lt;: map[T1', T2']       = T1 &lt;: T1' &amp;  T2 &lt;: T2'

[let10] map[T1, T2] &lt;: rel[T1', T2']       = T1 &lt;: T1' &amp;  T2 &lt;: T2'

[let11] rel[ONTs] &lt;: rel[ONTs']            = ONTs &lt;: ONTs'

[let12] rel[ONTs] &lt;: set[tuple[ONTs']]     = ONTs &lt;: ONTs'

[let13] set[tuple[ONTs]] &lt;: rel[ONTs']     = ONTs &lt;: ONTs'

[let14] T &lt;: T' == true,        %% covariant
        ONTs' &lt;: ONTs == true   %% contravariant
        =========================================
        fun T N (ONTs) &lt;: fun T' N (ONTs') = true
[default-let]
        T &lt;: T'                            = false
</programlisting></para>

        <para>Here T, T1, T2, T' etc represent types, and ONTs, ONTs' etc
        represented lists of OptionallyNamedTypes, e.g., a type that
        optionally followed by a named. We omit the definition of &lt;= on
        OptionallyNamedTypes. The above rules also describe certain
        equivalences between types, e.g., a map can be compared with a
        relation, a relation can be compared with a set of tuples, and the
        like.</para>

        <para>We throw the names in types away in the subtype relation.</para>

        <para>The subtyping relation for function types is tricky and treats
        result type and argument types differently. We have, for instance,
        that</para>

        <para><programlisting>set[int] f(int i) &lt;: fun set[&amp;T] f(int i)  %% since int &lt; &amp;T

int f(number x) &lt;: fun number f (int x)    %% assuming int &lt;: number</programlisting>but
        <emphasis>not</emphasis> that</para>

        <para><programlisting>number f(int x) &lt;: fun number f (number x) %% assuming int &lt;: number</programlisting></para>

        <para>In addition to the above rules for subtyping, each type
        definition introduces an additional subtype relation, e.g., the
        previous definition for Graph, <programlisting>type rel[node,node] Graph</programlisting></para>

        <para>introduces the following subtype relation:<programlisting>Graph &lt;: rel[node,node]</programlisting></para>
      </section>
    </section>

    <section>
      <title>Type Equivalence</title>

      <para>Types are compatible if they occur on the same path from void to
      value in the type lattice. This is a middle road between structural and
      nominal type equivalence, we call it <emphasis>intensional structural
      type equivalence</emphasis>. An example can illustrate this. Assume we
      have the following definitions for general graphs, control flow graphs
      and data flow graphs:<programlisting>type rel[node,node] Graph
type Graph CFGraph
type Graph DFGraph</programlisting></para>

      <para><literal>CFGraph</literal> and <literal>Graph</literal> are
      compatible, and the same holds for <literal>DFGraph</literal> and
      <literal>Graph</literal>. This implies that the types
      <literal>CFGraph</literal> and <literal>Graph</literal> (resp.
      <literal>DFGraph</literal> and <literal>Graph</literal>) can be freely
      passed as parameter, assigned, returned and value. This is, however, not
      true for CFGraph and DFGraph since they are incompatible. Passing a
      value from the one to the other type can only be done via the common
      type <literal>Graph</literal>. This uncomventional type scheme allows
      flexible conversion between subtypes (without casting or runtime checks)
      while preserving the opaqueness of disjoint subtypes of the same
      ancestor type.</para>
    </section>

    <section>
      <title>Attributes</title>

      <para>Attributes are adornments of data and programs and come in two
      flavours:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>value annotations</emphasis> that allow associating
          one or more named values to another value.</para>
        </listitem>

        <listitem>
          <para><emphasis>declaration tags</emphasis> that allow associating
          one or more named values to a declaration in a Rascal
          program.</para>
        </listitem>
      </itemizedlist>

      <para>The former are intended to attach application data to values, like
      adding position information or control flow information to source code
      or adding visualization information to a relation. The latter are
      intended to add metadata to a Rascal program and allow to influence the
      execution of the Rascal program, for instance, by adding memoization
      hints or database mappings for relations.</para>

      <section>
        <title>Value annotations</title>

        <para>Annotations may be associated with any value and are represented
        by a mapping of type <literal>map[str,value]</literal>, i.e.,
        annotation names are strings and annotation values are arbitrary
        values of type <literal>value</literal>. The folllowing three
        operators are provided for handling annotations:</para>

        <itemizedlist>
          <listitem>
            <para><literal><replaceable>Val</replaceable> ?
            <replaceable>Anno</replaceable></literal>: tests whether
            <replaceable>Val</replaceable> has an annotation with name
            <replaceable>Anno</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal><replaceable>Val</replaceable> @
            <replaceable>Anno</replaceable></literal>: retrieves the value of
            annotation <replaceable>Anno</replaceable> of value
            <replaceable>Val</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal><replaceable>Var</replaceable> @
            <replaceable>Anno</replaceable> =
            <replaceable>Val</replaceable></literal>: set the value of
            annotation <replaceable>Anno</replaceable> of the value of
            variable <replaceable>Var</replaceable> to
            <replaceable>Val</replaceable>.</para>
          </listitem>
        </itemizedlist>

        <para><caution>
            <para>Do we want a symbol type? Paul: no.</para>
          </caution>Any value of any named type can be annotated and the type
        of these annotations can be declared more precisely. For instance, the
        graph datatype introduced earlier, could be annotated with an
        indication which graph layout algorithm to apply to a particular
        graph, e.g.,<programlisting>anno Graph LayoutStrategy "dot" | "tree" | "force" | "hierarchy" | "fisheye"</programlisting>In
        a similar way, certain syntactic constructs of programs could be
        annotated with location information:<programlisting>anno STATEMENT posinfo loc</programlisting>or
        location information could be added for all syntax
        trees:<programlisting>anno tree posinfo loc</programlisting></para>
      </section>

      <section>
        <title>Declaration tags</title>

        <para>All declarations in a Rascal program may contain (in fixed
        positions depending on the declaration type) one or more declaration
        tags (<literal>tag</literal>). A tag is defined by declaring its name,
        the declaration type to which it can be attached, and the name and
        type of the annotation. The declaration type <literal>all</literal>,
        makes the declaration tag applicable for all possible declaration
        types. All declaration tags have the generic format
        <literal>@<replaceable>Name</replaceable>{ ... }</literal>, with
        arbitrary text between the brackets that is further constrained by the
        declared type. Here is an example of a license tag:<programlisting>tag module license str</programlisting>This
        will allow to write things like:<programlisting>module Booleans
@license{This module is distributed under the GPL}
...</programlisting>Other examples of declaration tags are:<programlisting>tag all todo str             %% a todo note for all declaration types
tag function deprecated void %% marks a deprecated function
tag function memo int        %% bounded memoization of 
                             %% function calls
tag all doc str              %% documentation string
tag function primitive str   %% a primitive, built-in, function</programlisting>Here
        are two examples from the standard library:<programlisting>public &amp;T first(list[&amp;T] L)
  throws empty_list(str msg)
  @doc{First element of list: first}
  @primitive{"List.first"}

public &amp;T max(set[&amp;T] R)
  @doc{Maximum of a set: max}
{
  &amp;T result = arb(R);
  for(&amp;T E : R){
    result = max(result, E);
  }
  return result;
}</programlisting></para>
      </section>
    </section>

    <section>
      <title>Variables</title>

      <para>Variables are names that have an associated scope and in that
      scope they have a value. A variable declaration consists of a type
      followed by the variable name and---depending on the syntactic
      position---they are followed by an initialization. There are no null
      values, which implies that all variables must be initialized at
      declaration time. Also, this implies that all expressions must return a
      value. Especially for functions, this means that all execution paths of
      a function must have a return statement.</para>

      <para>Variables may be introduced at the following syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para>As formal parameters of a function. Their scope is the
          function and they get their initial value when the function is
          called.</para>
        </listitem>

        <listitem>
          <para>Local variables in a function body are declared and
          initialized. Their scope is the function body.</para>
        </listitem>

        <listitem>
          <para>Variables in patterns. For patterns in match positions,
          <emphasis>declared</emphasis> variables are initialized during the
          match and their scope is the rule in which they occur. For
          <emphasis>used</emphasis> variables, their value is substituted
          during the match.</para>
        </listitem>

        <listitem>
          <para>For variables introduced by pattern matching in conditional
          statements (if-then, and while), if the condition succeeds, the
          scope of the variables are the block of code that is executed
          conditionally.</para>
        </listitem>

        <listitem>
          <para>Variables in anti-patterns are never visible, but nevertheless
          their names are reserved in the scope that they would have had when
          the pattern was a normal positive matching pattern.</para>
        </listitem>

        <listitem>
          <para>Variables that are introduced by generators in comprehensions
          or for statement, have the comprehension, respectively, for
          statement as scope.</para>
        </listitem>

        <listitem>
          <para>Global variables are declared and ALWAYS initialized at the
          top level of each module and <emphasis role="bold">these
          initialization may not contain circular calls.</emphasis></para>
        </listitem>

        <listitem>
          <para>Functions that use a global variable have to be explicitly
          declare it as well. The value of a global variable can be used and
          replaced by all functions that have locally declared it.</para>
        </listitem>
      </itemizedlist>

      <para>We will see below that there are certain contexts in which
      assignments to variables are undone in the case of failure.</para>
    </section>

    <section>
      <title>Functions</title>

      <section>
        <title>Overview</title>

        <para>A function declaration consists of a visibility declaration,
        result type, a function name, typed arguments and a function body.
        Functions without a result type have type
        <literal>void</literal>.</para>

        <para>A visibility declaration is one of the keywords
        <literal>public</literal> or <literal>private</literal>
        (default).</para>

        <para>A function body is a list of statements, each terminated by a
        semi-colon. Each unique control flow path through a function must have
        a return statement, such that each function always returns a proper
        value.</para>

        <para>Functions can raise exceptions and these may -- for
        documentation purposes -- optionally be declared as part of the
        function signature (i.e., we have unchecked exceptions in contrast
        with checked exceptions in Java).</para>

        <para>Functions with the tag "<literal>java</literal>" have a body
        written in Java. They have the following properties:</para>

        <itemizedlist>
          <listitem>
            <para>Arguments and result are pure Rascal values.</para>
          </listitem>

          <listitem>
            <para>Java functions cannot acces the global state of the Rascal
            program. Their only interface is via input parameters and a result
            value. They cannot access Rascal global variables.</para>
          </listitem>

          <listitem>
            <para>Side effects caused by Java functions in the Java state, are
            not undone in the case of backtracking.</para>
          </listitem>
        </itemizedlist>

        <note>
          <para>These Java functions are primarily intended for implementing
          library functions and for interfacing with Eclipse.</para>
        </note>

        <para>Functions with the tag <literal>@memo</literal> are memo
        functions that cache previous arguments/result combinations.</para>
      </section>

      <section>
        <title>Overloading</title>

        <para>Functions may be <emphasis>overloaded</emphasis>, i.e.,
        functions with the same name but with different argument and result
        types can be declared. Overloading is subject to the restriction that
        if several versions of a function are declared with the same name,
        then one or more of the following conditions should hold:</para>

        <itemizedlist>
          <listitem>
            <para>the number of arguments differs;</para>
          </listitem>

          <listitem>
            <para>there is at least one argument position with incomparable
            types w.r.t. the type hierarchy, i.e., not (A &lt;: B) and not
            (B&lt;:A).</para>
          </listitem>
        </itemizedlist>

        <para>Here are some examples.</para>

        <para>Here are, after all the warnings, the original examples:</para>

        <para><programlisting>%% OK, since int and double are incomparable 

int +(int a, int b) { ... }
double +(double a, double b) { ... }

%% KO, since int is comparable to value 
%% (int is -- like all types -- a subtype of value)

int +(value a, value b) { ... }
int +(int a, int b) { ... }

%% OK since for every two definitions selected from this
%% set there is at least one parameter position different;
%% in this example the overloading on result types will never 
%% be used to select the function

int    +(int a, int b)
double +(int a, double b)
double +(double a, int b)
double +(double a, double b)

%% KO, since arguments cannot be resolved.

int randomValue()
str randomValue()</programlisting></para>

        <para>How should overloading be resolved in the presence of type
        parameters? Our approach is simple but effective: a type parameter
        <literal>&amp;<replaceable><replaceable>T</replaceable></replaceable></literal>
        is taken to be of type <literal>value</literal>, unless it is
        explicitly constrained to be smaller than (or smaller than or equal
        to) another type U by writing
        <literal>&amp;<replaceable>T</replaceable> &lt;:
        <replaceable>U</replaceable></literal>. For the sake of overloading
        resolution, a constrained type parameter will be considered to have
        the type of the constraint, i.e., in <literal>fun
        F(&amp;<replaceable>T</replaceable> &lt; U)</literal> we assume the
        <literal>&amp;<replaceable>T</replaceable></literal> to be of type
        <literal>U</literal>.</para>

        <para>Here are more examples:</para>

        <para><programlisting>%% KO, because &amp;T might be any type (i.e. value),
%% which is comparable to int

str f(int x)
str f(&amp;T x)

%% KO, since both T's may bind to comparable types and
%% value and int are comparable

int f(&amp;T x, value y)
int f(&amp;T y, int x)

%% OK, since the second arguments have incomparable types

int f(&amp;T x, int y)
int f(&amp;T y, double x)</programlisting></para>
      </section>

      <section>
        <title>Formal description of overloading</title>

        <para>Given the subtype relation <literal>&lt;=:</literal> defined
        earlier, we can easily formalize overloading resolution by defining
        two predicates: <literal>incomparable</literal> describes when two
        lists of OptionallyNamedTypes can be compared and
        <literal>may-overload</literal> describes when two function types
        satisfy the overloading restrictions:<programlisting>%% Incomparable

[com1] incomparable(ONTs, ONTs') = 
       not((ONTs &lt;: ONTs') | (ONTs' &lt;: ONTs))

%% May-overload

[mo-1] may-overload(fun T N (ONTs), fun T' N' (ONTs')) = 
       not(N == N') | 
       incomparable(ONTs, ONTs')</programlisting></para>
      </section>

      <section>
        <title>Anonymous Functions</title>

        <para>We also allow <emphasis>anonymous functions</emphasis>, i.e.,
        functions that are declared locally and can be passed as argument to
        another function, be returned as value of a function, or even be
        stored as value in a set or relation. <caution>
            <para>Causes aliasing; How doe this interfere with backtracking?
            We may forbid write access to globals outside the current
            context.</para>
          </caution>When such functions are called they are called in the
        lexical scope in which they were defined. For instance, the Rascal
        standard Library defines a <literal>mapper</literal> function that
        applies a function to a list or set. An anonymous function can be used
        to define such function arguments. Here is a function
        <literal>addOne</literal>, that adds 1 to each element of its argument
        list:<programlisting>list[int] addOne(list[int] L)
    return mapper(L, fun int (int N) { return N +1 })</programlisting><code></code></para>

        <programlisting>fun fun(int) -&gt; int makeAdder(int n)
    return fun int (int x) { return x + 1 }</programlisting>
      </section>
    </section>

    <section>
      <title>Patterns</title>

      <para>We distinguish four kinds of patterns:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Abstract</emphasis> patterns: prefix dataterms that
          are generated by a signature.</para>
        </listitem>

        <listitem>
          <para><emphasis>Regular expression</emphasis> patterns: conventional
          regular expressions</para>
        </listitem>

        <listitem>
          <para><emphasis>Syntax</emphasis> patterns: textual fragments that
          are generated by a context-free grammar.</para>
        </listitem>

        <listitem>
          <para><emphasis>Lexical</emphasis> patterns: a special case of
          syntax patterns dealing with lexical notions like identifiers,
          numeric constants, and the like.</para>
        </listitem>
      </itemizedlist>

      <para>Patterns may contain variables and can occur in two syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Match</emphasis> positions where the patterns is
          matched against another term and the variables in the pattern are
          bound when the match is successfull. Examples of match positions
          are:</para>

          <itemizedlist>
            <listitem>
              <para>In a case construct, immediately after the
              <literal>case</literal>, <literal>acase</literal> or
              <literal>rcase</literal> keyword.</para>
            </listitem>

            <listitem>
              <para>The left-hand side of a <literal>rules</literal> or
              <literal>arules</literal> statement.</para>
            </listitem>

            <listitem>
              <para>In a generator, where generated values are matched against
              the pattern.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis>Make</emphasis> positions where the pattern is used
          to construct a new term (after replacing any variables in the
          pattern by their values. Examples of make positions are:</para>

          <itemizedlist>
            <listitem>
              <para>In a case construct, immediately after the
              <literal>=&gt;</literal> operator.</para>
            </listitem>

            <listitem>
              <para>The right-hand side of a <literal>rules</literal> or
              <literal>arules</literal> statement.</para>
            </listitem>

            <listitem>
              <para>As an ordinary expression in the form of a quoted syntax
              pattern, or a call to a constructor for a dataterm.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>In make positions, patterns may also contain function calls
      (written between <literal>&lt;</literal> and <literal>&gt;</literal>)
      that are replaced by their value during the construction of the pattern.
      Example:<programlisting>&lt;subst(V1, E1, Ea)&gt;</programlisting></para>

      <para><note>
          <para>To avoid syntactic complications, we currently refrain from
          allowing arbitrary expressions inside patterns, e.g., using notation
          like <literal>#{ ... }</literal>. However, since function arguments
          can be arbitrary expressions, this is hardly a restriction.</para>
        </note>A pattern may be turned into an
      <emphasis>anti-pattern</emphasis> by prefixing it with the symbol
      <literal>!</literal>. An anti-pattern matches in all cases where the
      original pattern does not match. A match of an anti-pattern cannot bind
      any variables but these variables are nonetheless reserved in the
      corresponding scope.</para>

      <section>
        <title>Abstract Patterns</title>

        <para>Datatype declarations introduce a signature of abstract
        terms.These terms (possibly including typed variables as introduced
        for concrete patterns) may be used as abstract patterns at the same
        position where concrete patterns are allowed. Type declarations define
        an inclusion relation between types.</para>
      </section>

      <section>
        <title>Regular Expression Patterns</title>

        <para>Regular expression patterns are ordinary regular expressions
        that are used to match a string value and to decompose it in parts and
        also to compose new strings. Regular expression patterns bind
        variables of type <literal>str</literal> when the match succeeds,
        otherwise they do not bind anything. Their syntax and semantics
        parallels abstract and concrete syntax patterns as much as possible.
        This means that they can occur in cases of <literal>visit</literal>
        and <literal>switch</literal> statements, on the left-hand side of the
        match operator (<literal>:=</literal>) and as declarator in
        generators.<caution>
            <para>The following proposal differs slightly from what we
            discussed earlier.</para>
          </caution></para>

        <para>We use a regular expression language that extends the lexical
        syntax rules found in SDF towards Java regex with the following
        exceptions:</para>

        <itemizedlist>
          <listitem>
            <para>Regular expression are delimited by / and / optionally
            followed by a modifier (see below).</para>
          </listitem>

          <listitem>
            <para>Character classes are written in the SDF way.</para>
          </listitem>

          <listitem>
            <para>Java regular expressions might have optional groups, which
            may introduce null bindings. Since null pointers are not allowed
            in Rascal, we have to limit the kinds of expressions people can
            write here.</para>
          </listitem>

          <listitem>
            <para>We allow named groups, syntax
            <literal>&lt;<replaceable>Name</replaceable>:<replaceable>Regex</replaceable>&gt;</literal>,
            which introduce a variable of type <literal>str</literal> named
            <replaceable>Name</replaceable>.</para>
          </listitem>

          <listitem>
            <para>We allow name use in a regular expression:
            <literal>&lt;<replaceable>Name</replaceable>&gt;</literal> which
            inserts the string value of <replaceable>Name</replaceable> in the
            pattern.</para>
          </listitem>

          <listitem>
            <para>We allow function calls inside a regular expression:
            <literal>&lt;<replaceable>F</replaceable>(...)&gt;</literal> which
            inserts the string value of the function call in the regular
            expression.</para>
          </listitem>

          <listitem>
            <para>We do not allow nesting of named groups.</para>
          </listitem>

          <listitem>
            <para>Named groups have to outermost, such that they can only bind
            in one way.</para>
          </listitem>

          <listitem>
            <para>Unlike Perl, Java uses the notation
            <literal>(?<replaceable>Option</replaceable>)</literal> inside the
            regular expression to set options like multi-line matching
            <literal>(?m)</literal>, case-insensitive matching
            <literal>(?i)</literal> etc. We let these options follow te
            regular expression.</para>
          </listitem>

          <listitem>
            <para>We omit some more esoteric features of Java regex like
            (octal and hex constants, look ahead and look behind) but these
            can always be added.</para>
          </listitem>

          <listitem>
            <para>We have an explicit grammar for the regular expression
            language that facilitates translation to Java regex.</para>
          </listitem>
        </itemizedlist>

        <para>Here are some examples of regular patterns.<programlisting>/\brascal\b/i</programlisting>does
        a case-insensitive match (<literal>i</literal>) of the word rascal
        between word boundaries (<literal>\b</literal>). And<programlisting>/^.*?&lt;word:\w+&gt;&lt;rest:.*$&gt;/m</programlisting>does
        a multi-line match (<literal>m</literal>), matches the first
        consecutive word characters (<literal>\w</literal>) and assigns them
        to the variable <literal>word</literal>. The remainder of the string
        is assigned to the variable <literal>rest</literal>.</para>
      </section>

      <section xml:id="section.patterns">
        <title>Syntax Patterns</title>

        <para>There is a notation of a <emphasis>syntax pattern</emphasis>: a
        (possibly quoted) concrete syntax fragment that may contain variables.
        We want to cover the whole spectrum from maximally quoted patterns
        that can unambiguously describe <emphasis role="bold">any</emphasis>
        syntax fragment to minimally quoted patterns as we are used to in
        ASF+SDF. Therefore we support the following mechanisms:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>pattern variable declaration</emphasis>, written
            as <literal>&lt;<replaceable>TYPE</replaceable>
            <replaceable>NAME</replaceable>&gt;</literal> declares a new
            variable with a scope determined by the syntactic context of the
            pattern.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>pattern variable use</emphasis>, written as
            <literal>&lt;<replaceable>NAME</replaceable>&gt;</literal>, uses
            the value of an already declared variabele during the use of the
            pattern.</para>
          </listitem>

          <listitem>
            <para>Quoted patterns enclosed between <literal>[|</literal> and
            <literal>|]</literal>. Inside a fully quoted string, the
            characters <literal>&lt;</literal>, <literal>&gt;</literal> and
            <literal>|</literal> can be escaped as <literal>\&lt;</literal>,
            <literal>\&gt;</literal>, <literal>\|</literal>. Fully quoted
            patterns may contain pattern variable declarations and pattern
            variable uses.</para>
          </listitem>

          <listitem>
            <para>A quoted pattern may be optionally preceeded by an SDF
            symbol to define its desired syntactic type.</para>
          </listitem>

          <listitem>
            <para>Unquoted patterns are (unquoted) syntax fragments that may
            contain pattern variable declarations and pattern variable
            uses.</para>
          </listitem>

          <listitem>
            <para>Inside syntax patterns, layout is ignored.</para>
          </listitem>
        </itemizedlist>

        <para>Quoted and unquoted patterns form the syntax patterns that are
        supported in Rascal.</para>

        <para>Examples are:</para>

        <itemizedlist>
          <listitem>
            <para>Quoted syntax pattern with two pattern variable
            declarations:<programlisting>[| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Quoted syntax pattern with two pattern variable
            uses:<programlisting>[| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Identical to the previous example, but with a declaration of
            the desired syntactic type:<programlisting>STATEMENT [| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with two pattern variable
            declarations:<programlisting>while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with two pattern variable
            uses:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>
          </listitem>
        </itemizedlist>

        <para>Obviously, with less quoting and type information, the
        probability of ambiguities increases. Our assumption is that a type
        checker can resolve them.</para>

        <note>
          <para>Implementation hint (used to check the examples in this
          document). For every sort S in the syntax definition add the
          following rules:</para>

          <programlisting><replaceable>S</replaceable>                   -&gt; Pattern
"&lt;<replaceable>" "S</replaceable>"? Name "&gt;"   -&gt; <replaceable>S</replaceable>      </programlisting>
        </note>
      </section>

      <section>
        <title>Lexical Patterns</title>

        <para>A special case of syntax patterns, are lexical patterns that
        describe lexical notions such as identifiers, numeric constants and
        the like. Lexical patterns can appear as part of a concrete syntax
        pattern. Our solution is a middle road between the original solution
        used in ASF+SDF (simple but not type safe) and the current solution in
        ASF+SDF (complex but type safe). The key idea is that a constructor
        function is implicitly created for every lexical definition, i.e.,
        when the SDF definition defines the lexical sort
        <literal>LS</literal>, then the following lexical constructor function
        <literal>ls</literal> (the sort name in lower case) is implicitly
        defined:<programlisting>    ls( LEXARGS ) -&gt; LS</programlisting></para>

        <para><literal>LEXARGS</literal> consist of zero or more:</para>

        <itemizedlist>
          <listitem>
            <para>String constants.</para>
          </listitem>

          <listitem>
            <para>Typed Variables enclosed in angle brackets (as used in other
            patterns).</para>
          </listitem>
        </itemizedlist>

        <para>The <literal>LEXARGS</literal> argument combined should form a
        strings of sort <literal>LS</literal>.<note>
            <para>The current solution in ASF+SDF requires that all
            intermediate lexical constructors are explicitly written in the
            pattern. Here we relax this requirement.</para>
          </note></para>

        <para>For instance, given a lexical syntax for numbers (part of an SDF
        definition):<programlisting>sorts DIGIT NAT-CON
lexical syntax
   [0-9]    -&gt; DIGIT
   DIGIT+   -&gt; NAT-CON</programlisting></para>

        <para>A rule that would remove leading zeros looks like
        this:<programlisting>  natcon("0" &lt;DIGIT+ Ds&gt;) =&gt; natcon(&lt;Ds&gt;)</programlisting><note>
            <para>Unlike the ASF+SDF solution, it is not necessary to make a
            distinction between ordinary variables, lexical variables, and
            layout variables. Here, all variables are treated equal and their
            syntactic position determines how they are used.</para>
          </note>We also allow arbitrary character classes as type in a
        pattern variable, e.g., one could also write:<programlisting>  natcon("0" &lt;[0-9]+ Ds&gt;) =&gt; natcon(&lt;Ds&gt;)</programlisting></para>
      </section>
    </section>

    <section>
      <title>Expressions</title>

      <para>Expressions correspond roughly to Rscript expressions with some
      extensions:<itemizedlist>
          <listitem>
            <para>There are lists, sets, maps and relations together with
            comprehensions for these types.</para>
          </listitem>

          <listitem>
            <para>Generators in comprehensions may range over syntax
            trees.</para>
          </listitem>

          <listitem>
            <para>Generators in comprehension may range over integer ranges of
            the form
            <literal>[<replaceable>B</replaceable>..<replaceable>E</replaceable>]</literal>
            or
            <literal>[<replaceable>B</replaceable>,<replaceable>I</replaceable>,..<replaceable>E</replaceable>]</literal>,
            where <replaceable>B</replaceable> indicates the begin value,
            <replaceable>E</replaceable> the end value, and
            <replaceable>I</replaceable> the optional increment between
            values.</para>
          </listitem>

          <listitem>
            <para>Generators may have a strategy option to indicate:</para>

            <itemizedlist>
              <listitem>
                <para><literal>top-down</literal></para>
              </listitem>

              <listitem>
                <para><literal>top-down-break</literal></para>
              </listitem>

              <listitem>
                <para><literal>bottom-up</literal> (this is the
                default)</para>
              </listitem>

              <listitem>
                <para><literal>bottom-up-break</literal></para>
              </listitem>
            </itemizedlist>

            <para>The two other strategy options (<literal>innermost</literal>
            and <literal>outermost</literal>) are only meaningfull in the
            context of a <literal>visit</literal> statement.</para>
          </listitem>

          <listitem>
            <para>The complete repertoire of operators in Rscript is available
            but we have applied some rationalization. Note that with each
            operator, we also associate a named function that can be used as
            function argument.</para>

            <itemizedlist>
              <listitem>
                <para><literal>+</literal> is used for addition, union (|) and
                concatenation (++)<caution>
                    <para>Paul: I want to rediscuss this since using + for all
                    these operations is also nice.</para>
                  </caution></para>
              </listitem>

              <listitem>
                <para><literal>-</literal> is used for substraction,
                difference (\)<caution>
                    <para>Ditto.</para>
                  </caution></para>
              </listitem>

              <listitem>
                <para><literal>*</literal> is used for multiplication, and
                product (of relations)</para>
              </listitem>

              <listitem>
                <para><literal>/</literal> is used for integer and double
                division.</para>
              </listitem>

              <listitem>
                <para><literal>&amp;</literal> is used for
                intersection.</para>
              </listitem>

              <listitem>
                <para>There are assignment operators +=, -=, *=,
                <literal>&amp;=</literal>.<caution>
                    <para>Do we want /=, @=</para>
                  </caution></para>
              </listitem>

              <listitem>
                <para>The relational operators <literal>==</literal> (equal)
                and <literal>&lt;</literal> (less) are available for values of
                all types. They are used to define <literal>&lt;=</literal>
                (less or equal), <literal>&gt;</literal> (greater) and
                <literal>&gt;=</literal> (greater or equal) as well as the
                functions <literal>min</literal> and
                <literal>max</literal>.</para>
              </listitem>

              <listitem>
                <para>The Boolean predicates are <literal>&amp;&amp;</literal>
                (and) and <literal>||</literal> (or).<caution>
                    <para>Let's drop implies and replace by a conditional
                    expression.</para>
                  </caution></para>
              </listitem>

              <listitem>
                <para>For a binary relation <replaceable>R</replaceable> that
                is a map (i.e., it associates a single value with each domain
                element)
                <replaceable>R</replaceable>[<replaceable>N</replaceable>],
                returns the single image value corresponding with
                <replaceable>N</replaceable>. This expression may also occur
                as left-hand side of an assignment:<programlisting><replaceable>R</replaceable>[<replaceable>N</replaceable>] = <replaceable>V</replaceable></programlisting>first
                removes from <replaceable>R</replaceable> the tuple with
                domain value <replaceable>N</replaceable> and then adds the
                tuple &lt;<replaceable>N</replaceable>,
                <replaceable>V</replaceable>&gt;. The net effect is that a new
                map value is assigned to <replaceable>R</replaceable>.</para>
              </listitem>

              <listitem>
                <para>An index operator
                <literal><replaceable>R</replaceable>[<replaceable>N</replaceable>]</literal>
                can be applied to values of types list, tuple, string and
                returns the <replaceable>N</replaceable>-th element. It thows
                the exception <literal>out_of_range(str msg)</literal> when
                the index value if out of range.</para>
              </listitem>

              <listitem>
                <para>The Rscript image notation <literal>R[-,n]</literal> is
                discontinued.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Statements</title>

      <para>Rascal has the following statement types, which can be nested and
      composed in the usual structured manner:</para>

      <itemizedlist>
        <listitem>
          <para>Variable declaration with initialization.</para>
        </listitem>

        <listitem>
          <para>An assignment statement assigns a value to a variable.</para>
        </listitem>

        <listitem>
          <para>If-then statement and if-then-else statement.</para>
        </listitem>

        <listitem>
          <para>A <literal>return</literal> statement returns a value from a
          function, or just returns (for functions with result type void).
          Note that return jumps out of an entire function, even if it is
          nested in a complicated control flow statement such as visit.</para>
        </listitem>

        <listitem>
          <para>A <literal>raplace</literal> statement that delivers a
          replacement value during a traversal initiated by a visit statement,
          or a switch statement.</para>
        </listitem>

        <listitem>
          <para>A <literal>fail</literal> statement which jumps to the deepest
          nested choice point (i.e. a switch or a visit) and tries the next
          option available. Both yield and fail should occur in the lexical
          context of a choice point.</para>
        </listitem>

        <listitem>
          <para>A throw statement can raise an exception.</para>
        </listitem>

        <listitem>
          <para>A <literal>switch</literal> statement is similar to a switch
          statement in C or Java and for a given subject term, it corresponds
          to the matching provided by the left-hand sides of a set of rewrite
          rules. However, it provides <emphasis role="bold">only</emphasis>
          matching at the top level of the subject term and does not traverse
          it. The type of each pattern must be identical to the type of the
          subject term (or be a subtype of it). It is an error if no case
          matches.</para>
        </listitem>

        <listitem>
          <para>A rewrite rule (not a top-level statement, but a child of
          switch and visit) consists of a Pattern followed by : and a
          statement that returns the replacement value:<programlisting>case <replaceable>Pattern</replaceable> : <replaceable>Statement</replaceable></programlisting></para>

          <para>A statement may consist of declarations and statements and is
          implicitly extended with a <literal>fail</literal> statement. The
          statement must therefore replace or return a value or the case as a
          whole will fail. To maintain some resemblance with rewrite rules, we
          also support the form</para>

          <programlisting>case <replaceable>Pattern</replaceable> =&gt; <replaceable>Replacement</replaceable></programlisting>

          <para>which is an abbreviation for<programlisting>case <replaceable>Pattern</replaceable> : replace-by <replaceable>Replacement</replaceable></programlisting>Depending
          on the kind of pattern we use a different keyword:</para>

          <itemizedlist>
            <listitem>
              <para><literal>case</literal> for (concrete) syntax
              patterns.</para>
            </listitem>

            <listitem>
              <para><literal>acase</literal> for abstract patterns.</para>
            </listitem>

            <listitem>
              <para><literal>rcase</literal> for regular patterns.<note>
                  <para>These three different keywords are not very elegant
                  but they help to remove disambiguities.</para>
                </note></para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>A <literal>visit</literal> statement corresponds to a
          traversal function from ASF+SDF. Given a subject term and a list of
          rewrite rules it traverses the term. Depending on the precise rules
          it may perform replacement (mimicking a transformer), update local
          variables (mimicking an accumulator) or a combination of these two.
          The visit statement may contain the same strategy options as a
          generator and also:</para>

          <itemizedlist>
            <listitem>
              <para><literal>innermost</literal> = compute a fixed-point:
              repeat a bottom-up traversal as long as the traversal function
              changes values.</para>
            </listitem>

            <listitem>
              <para><literal>outermost</literal> = compute a fixed-point:
              repeat a traversal traversal as long as the traversal function
              changes values.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>A <literal>for</literal> statement to repeat a block of
          code.</para>
        </listitem>

        <listitem>
          <para>A <literal>solve</literal> statement to solve a set of linear
          equations.</para>
        </listitem>

        <listitem>
          <para>A <literal>try</literal> statement can be used to execute a
          statement and to catch any exception raised by that
          statement.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rules</title>

      <para>Rules are the closest to rewrite rules as we will get in Rascal.
      Unlike functions that are always called explicitly wehen needed, rules
      are always applied implicitly, i.e., whenever a value of some type is
      created and there are rules defined for that type, they are immediately
      applied. In principle, rules can be used to define arbitrary
      computations. In practice, they are mostly used to guarantee that
      certain constraints are satisfied whenever a value of some type is
      created.</para>

      <para>Rules come in two flavours: concrete rules that describe rewriting
      of concrete syntax patterns and abstract rules that describe rewriting
      of abstract patterns. Concrete rules start with the keyword
      <literal>rule</literal>, a name for identification, a concrete syntax
      pattern, an arrow (<literal>=&gt;</literal>) and another syntax pattern
      that describes the desired replacement. Here is an example:</para>

      <para><programlisting>rule a1 true &amp; &lt;Bool B2&gt;   =&gt; &lt;B2&gt;</programlisting>The
      replacement part may also have the form colon (<literal>:</literal>)
      followed by an arbitrary statement.</para>

      <para>Abstract rules have the same structure, execept that abstract
      patterns are used, for example:<programlisting>arule a1 band(btrue, &lt;Bool B2&gt;)  =&gt; &lt;B2&gt; </programlisting></para>

      <para>During execution of rules the following applies:</para>

      <itemizedlist>
        <listitem>
          <para>Rules are applied non-deterministically, and in any order of
          matching.</para>
        </listitem>

        <listitem>
          <para>The right hand side of rules can contain fail statements,
          which cause backtracking over the alternative rules for a certain
          constructor.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Failure and side-effects</title>

      <para>There are two contexts in which side-effects, i.e., assignment to
      variables, have to be undone in case of failure. These contexts are a
      rewrite rule in a switch or visit statement. If the pattern on the
      left-handside of the rule matches there are various
      possibilities:</para>

      <itemizedlist>
        <listitem>
          <para>All control flow path through the right-hand side of the rule
          end in a return statement. In this case, the rule can not fail and
          all side-effects caused by the execution of the right-hand side are
          committed.</para>
        </listitem>

        <listitem>
          <para>One or more control path can fail. This can be caused by an
          explicit fail statement or an if-then statement with missing
          else-branch. In the case of failure all side-effects (of local and
          global variables) are undone.</para>
        </listitem>

        <listitem>
          <para>If a rule fails there are two possibilities:</para>

          <itemizedlist>
            <listitem>
              <para>the left-hand side contains a list pattern that has more
              matching options; the next option is tried.</para>
            </listitem>

            <listitem>
              <para>the left-hand side contains a list patterns that has no
              more matching options or it contains no list pattern at all; the
              next rule is tried.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The possible choice points are:</para>

          <itemizedlist>
            <listitem>
              <para>case in a switch, visit statement.</para>
            </listitem>

            <listitem>
              <para>match of left-hand side of rule, arule.</para>
            </listitem>

            <listitem>
              <para>Selection of a binding of list variables during list
              matching, except if there is one possibility left.</para>
            </listitem>

            <listitem>
              <para>Selection of an element by a generator.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The possible failure points are:</para>

          <itemizedlist>
            <listitem>
              <para>fail statement</para>
            </listitem>

            <listitem>
              <para>a predicate used as generator in a comprehension.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The possible success points are:</para>

          <itemizedlist>
            <listitem>
              <para><literal>return</literal> (jumps out of function scope and
              pops all choice points).</para>
            </listitem>

            <listitem>
              <para><literal>replace-by</literal> (jumps to enclosing switch
              or visit or rule choice)</para>
            </listitem>

            <listitem>
              <para>true predicate in comprehension (jumos to next assignment
              of generator).</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>On failure, the currently active choice point is used to undo
          side-effects and to continue execution.</para>
        </listitem>

        <listitem>
          <para>Side effects caused by built-in functions (like file i/o,
          sockhet communication, etc.) are <emphasis
          role="bold">not</emphasis> undone.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>Here we list experimental examples of Rascal code to try out
    features.</para>

    <section>
      <title>Hello world</title>

      <para>The ritual first example:<programlisting>module Hello

public void main() {
   println("Hello, this is my first Rascal program");
}</programlisting></para>
    </section>

    <section>
      <title>Table of squares</title>

      <para>Another ritual example, printing a table of
      squares:<programlisting>module Squares

public void main(list[str] argv){
  int N = toInt(argv[0]);
  map[int,int] squares = {};
  for(int I : [1 .. N]){
     squares[I] = I * I;
  }
  println("Table of squares from 1 to ", N);
  println(squares);
}</programlisting><caution>
          <para>We need a mechanism to insert values in strings,
          e.g.<programlisting> println("Table of squares from 1 to &lt;N&gt;");</programlisting></para>
        </caution><caution>
          <para>What is the syntax of a map value: { x=&gt;y } or { x : y}
          ??</para>
        </caution><caution>
          <para>Map comprehensions should also be possible as in { int x : int
          y | x : {1,2,3}, y : {1,2,3} }</para>
        </caution><caution>
          <para>Maps should also be generators, but notice the overloading of
          :. { &lt;int x, int y&gt; | x:y : { 1:2 } } or { &lt;int x, int
          y&gt; | x=&gt;y : { 1=&gt;2 } }</para>
        </caution></para>
    </section>

    <section>
      <title>Table of word counts per file</title>

      <para><programlisting>module WordCount
 
public void main(list[str] argv){
  map[str, int] counts = {};
  for(str fileName : argv){
    try {
      counts[fileName] = wordCount(readFile(fileName));
    }
    catch: println("Skipping file &lt;fileName&gt;");
  }

  println("In total &lt;sum(range(counts))&gt; words in all files");
  println("Word counts per file: &lt;counts&gt;");
}

int wordCount(str S){
  int count = 0;
  %% the m-option enables multi-line matching
  for(/[a-zA-Z0-9]+/m: S){
       count += 1;
  }
  return count;
}

%% Here is an alternative declaration:
int wordCount2(str S){
  int count = 0;
  %% \w matches any word character
  %% &lt;...&gt; are groups and should appear at the top level.
  %% m turns on multi-line matching
  while (/^.*?&lt;word:\w+&gt;&lt;rest:.*$&gt;/m := S) { 
    count += 1; 
    S = rest; 
  }
  return count;
}</programlisting></para>
    </section>

    <section>
      <title>Word replacement </title>

      <para>Here are two versions of a word replacement function:</para>

      <para><programlisting>module WordReplacement

str capitalize1(str S){
    visit S {
      %% \b matches a word boundary
      %% i turns on case-independent matching
      case /\brascal\b/i =&gt; "Rascal"
    }
    return S;
}

str capitalize2(str S, str Pat, str Repl){
    visit S {
      case /\b&lt;Pat&gt;\b/i =&gt; Repl
    }
    return S;
}</programlisting>The function <literal>capitalize1</literal>, replaces all
      occurrences of <literal>rascal</literal> (in all possible cases) by the
      standard spelling <literal>Rascal</literal>. The function
      <literal>capitalize2</literal> is a generalization of
      <literal>capitalize1</literal>: it takes a subject string, a pattern
      string and a replacement string. Observe how the argument
      <literal>Pat</literal> is inserted in the regular expression.</para>

      <para>The call <literal>capitalize2(Subject, "rascal",
      "Rascal")</literal> will have the same effect as
      <literal>capitalize1(Subject)</literal>.</para>
    </section>

    <section>
      <title>Finding date-related variables</title>

      <para>In year 2000 conversions, the starting point for analysis could be
      variables with a date-related name. Here is how to find
      them:<programlisting>module DateVars

set[Var] getDateVars(Program P){
   return {V | Var V : P, /.*(date|dt|year|yr).*$/i := V};
}</programlisting></para>
    </section>

    <section>
      <title>Booleans</title>

      <para>It seems that every language specification effort has to produce a
      specification of the Booleans at some moment, so let's try it now. We
      try several variations.</para>

      <para>We use the following common syntax:<programlisting>module Booleans-syntax
exports 
  sorts Bool

  context-free syntax
    "true"        -&gt; Bool
    "false"       -&gt; Bool
    Bool "&amp;" Bool -&gt; Bool {left}
    Bool "|" Bool -&gt; Bool {right}</programlisting></para>

      <section xml:id="section.booleans-with-visit">
        <title>Concrete Booleans defined with visit</title>

        <para>Using the visit construct that we have described above, we can
        write the definitions for the functions <literal>&amp;</literal> and
        <literal>|</literal> as follows:<programlisting>module Bool-examples1

import languages/Booleans/syntax;

Bool reduce(Bool B) {
    visit bottom-up B {
      case true &amp; &lt;Bool B2&gt;   =&gt; &lt;B2&gt;
      case false &amp; &lt;Bool B2&gt;  =&gt; false

      case true | true        =&gt; true
      case true | false       =&gt; true
      case false | true       =&gt; true
      case false | false      =&gt; false
    }
}</programlisting></para>

        <para>Observe that there are two styles:</para>

        <itemizedlist>
          <listitem>
            <para>In the definition for <literal>&amp;</literal>, we use
            variables on the left-hand side: the visit is needed to fully
            normalize the result.</para>
          </listitem>

          <listitem>
            <para>In the definition of <literal>|</literal>, we use a truth
            table.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Abstract Booleans defined with visit</title>

        <para>In the above example we used concrete syntax for Booleans
        expressions. It also possible to define Booleans as abstract
        terms.<programlisting>module Bool-abstract

data Bool btrue;
data Bool bfalse;
data Bool band(Bool L, Bool R);
data Bool bor(Bool L, Bool R); 

Bool reduce(Bool B) {
    visit bottom-up B {
      acase band(btrue, &lt;Bool B2&gt;)   =&gt; &lt;B2&gt;     %% Use Variables
      acase band(bfalse, &lt;Bool B2&gt;)  =&gt; bfalse

      acase bor(btrue, btrue)        =&gt; Bool-abstract::btrue  %% Use a truth table
      acase bor(btrue, bfalse)       =&gt; btrue
      acase bor(bfalse, btrue)       =&gt; btrue
      acase bor(bfalse, bfalse)      =&gt; bfalse
    }
}</programlisting></para>

        <para>First, type declarations are used to define the abstract syntax
        of the type Bool. Next, a similar reduce function is defined as
        before, but now we use abstract patterns.</para>
      </section>

      <section>
        <title>Abstract Booleans defined with arules</title>

        <para>In ASF, values are always reduced to a normal form before they
        are created. For some applications this normalization or
        canonicalization feature is very handy. We introduce the following
        syntax, which can also help in the transformation of old ASF+SDF
        programs to Rascal:</para>

        <para><programlisting>module Bool-rules

data Bool btrue;
data Bool bfalse;
data Bool band(Bool L, Bool R);
data Bool bor(Bool L, Bool R);  

arule a1 band(btrue, &lt;Bool B2&gt;)  =&gt; &lt;B2&gt; 
arule a2 band(bfalse, &lt;Bool B2&gt;) =&gt; bfalse

arule o1 bor(btrue, btrue)       =&gt; btrue
arule o2 bor(btrue, bfalse)      =&gt; btrue
arule o3 bor(bfalse, btrue)      =&gt; btrue
arule o4 bor(bfalse, bfalse)     =&gt; bfalse</programlisting>These rules are
        applied on every Bool that is constructed. Like in ASF+SDF it is the
        responsibility of the programmer to make sure the rules are confluent
        and terminating. The body of a rules definition has the same syntax
        and semantics as the switch construct, allowing backtracking,
        side-effects and checking of conditions.</para>

        <para>There are some issues here:</para>

        <itemizedlist>
          <listitem>
            <para>It should be dissallowed to have private rules on public
            constructors; normalization is a global effect on public
            data-structures. On the other hand, constructors that are local to
            a module may have some private rules applied to them; but public
            rules on private constructors are dissallowed too.</para>
          </listitem>

          <listitem>
            <para>We previously had other ideas about this feature. We
            introduced a reduce keyword that would call a certain named
            function at the construction of every Bool. The problem with that
            feature is that the operational semantics (in the eyes of the
            Rascal programmer) really looks like first some term is to be
            created, and then a function will be applied to normalize it. In
            reality though, we want to normalize the terms in an innermost
            fashion, and at construction time, so that the terms on the
            left-hand side of the rules are never actually created or
            allocated.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Concrete Booleans defined with rules</title>

        <para>In a similar fashion, the concrete syntax version of Booleans
        can be defined using rules:<programlisting>module Bool-conc-rules

import languages/Booleans/syntax;

rule a1 true &amp; &lt;Bool B2&gt;   =&gt; &lt;B2&gt;
rule a2 false &amp; &lt;Bool B2&gt;  =&gt; false

rule o1 true | true        =&gt; true
rule o2 true | false       =&gt; true
rule o3 false | true       =&gt; true
rule o4 false | false      =&gt; false</programlisting></para>
      </section>
    </section>

    <section>
      <title>Abstract Graph datatype</title>

      <para>In the Meta-Environment we use an abstract data type to exchange
      data representing graphs. It can be defined as follows.<programlisting>module Graph

data Graph graph(NodeList nodes, 
                 EdgeList edges, 
                 AttributeList attributes);

type list[Node] Nodelist;

data Node node(NodeId id, 
               AttributeList attributes);

data Node subgraph(NodeId id, 
                   NodeList nodes, 
                   EdgeList edges, 
                   AttributeList attributes);

data NodeId id(term id);

type list[Attribute] AttributeList;

data Attribute bounding-box(Point first, Point second);
data Attribute color(Color color);
data Attribute curve-points(Polygon points);
data Attribute direction(Direction direction);
data Attribute fill-color(Color color);
data Attribute info(str key, value value);
data Attribute label(str label);
data Attribute tooltip(str tooltip);
data Attribute location(int x, int y);
data Attribute shape(Shape shape);
data Attribute size(int width, int height);
data Attribute style(Style style);
data Attribute level(str level);
data Attribute file(File file);
data Attribute file(value file);

data Color rgb(int red, int green, int blue);

data Style bold | dashed | dotted | filled | invisible | solid;

data Shape box | circle | diamond | egg | elipse | hexagon | 
           house | octagon | parallelogram | plaintext | 
           trapezium | triangle;

data Direction forward | back | both | none;

type list[Edge] Edgelist;

data Edge edge(NodeId from, 
               NodeId to, 
               AttributeList attributes);

type list[Point] Polygon;

data Point point(int x, int y);</programlisting></para>
    </section>

    <section>
      <title>Tree traversal</title>

      <para>Here is the binary tree example that we use in explaining
      traversal functions in ASF+SDF.<programlisting>module BTree-syntax
imports basic/Integers

exports 
  sorts BTREE
  context-free syntax
    Integer         -&gt; BTREE
    f(BTREE,BTREE)  -&gt; BTREE
    g(BTREE,BTREE)  -&gt; BTREE
    h(BTREE,BTREE)  -&gt; BTREE
    i(BTREE,BTREE)  -&gt; BTREE</programlisting><programlisting>module BTree-Examples
import BTree-syntax; 

%% Ex1: Count leaves in a BTREE
%% Idea: int N : T generates alle Integer leaves in the tree
%% Observe that there is no need to touch the contents of each Integer
%% since we only count them.

int cnt(BTREE T) {
    return size({N | Integer N : T});
}

%% Ex1: alternative solution using a visit statement

int cnt(BTREE T) {
    int C = 0;
    visit T {
      case &lt;Integer N&gt; : C = C+1;
    }
    return C;
}
 
%% Ex2: Sum all leaves in a BTREE
%% NB sum is a built-in that adds all elements in a set or list.
%% Here we see immediately the need to convert between
%% - the syntactic sort "Integer"
%% - the built-in sort "int"
%% We use the toInt function that attempts convert any tree
%% to an int.

int sumtree(BTREE T) {
    return sum({toInt(N) | Integer N : T});
}

%% Ex2: using visit statement

int cnt(BTREE T) {
    int C = 0;
    visit T {
      case &lt;Integer N&gt; : C = C+toInt(N);
    }
    return C;
}

%% Ex3: Increment all leaves in a BTREE
%% Idea: using the visit statement visit all leaves in
%% the tree T that match an integer and replace each N in T by N+1.
%% The expression as a whole returns the modified tree
%% Note that two conversions are needed here:
%% - from Integer to int (using toInt)
%% - from int back to Integer (using parseString)

BTREE inc(BTREE T) {
    visit T {
      case &lt;Integer N&gt;: replace-by parseString(toInt(N)+1);
    }
}

%% Ex4: full replacement of g by i
%% The whole repertoire of ASF+SDF traversal functions is available:
%% - visit bottom-up T { ... }
%% - visit bottom-up-break  T { ... }
%% - etc.
%% A nice touch is that these properties are not tied to the
%% declaration of a travesal function (as in ASF+SDF) but to 
%% its use.

BTREE frepl(BTREE T) {
    visit bottom-up T {
      case g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) =&gt;
           i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    }
}

%% Ex5: Deep replacement of g by i

BTREE frepl(BTREE T) {
    visit bottom-up-break T {
      case g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) =&gt;
           i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    }
}

%% Ex6: shallow replacement of g by i (i.e. only outermost 
%% g's are replaced); 

BTREE srepl(BTREE T) {
    visit top-down-break T {
      case g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) =&gt; 
           i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    }
}

%% Ex7: We can also add the top-down-break directive to the generator
%% to get only outermost nodes.

set[BTREE] find_outer_gs(BTREE T) {
    return
    { S | STATEMENT S : top-down-break T, 
          g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) := S };
}
 
%% Ex8: accumulating transformer that increments leaves with 
%% amount D and counts them
tuple[int, BTREE] count_and_inc(BTREE T, int D) {
    int C = 0;
    
    visit T {
      case &lt;Integer N&gt;: { C = C + 1; 
                          int N1 = toInt(N) + D; 
                          replace-by parse(unparseToString(N1));
                        }
     }
     return &lt;C, T&gt;;
}
</programlisting></para>
    </section>

    <section>
      <title>Substitution in Lambda</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.</para>

      <programlisting>module examples/Lambda/Lambda-syntax

exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+               -&gt; Var
context-free syntax
     "prime" "(" Var ")"  -&gt; Var  %% generate unique name
     Var                  -&gt; Exp  %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp  %% function abstraction
     Exp Exp              -&gt; Exp  %% function application
</programlisting>

      <para>Examples:</para>

      <para><programlisting>module Lambda-Examples

import Lambda-syntax;

set[Var] allVars(Exp E) {
    return {V | Var V : E};
}

set[Var] boundVars(Exp E) {
    return {V | fn &lt;Var V&gt; =&gt; &lt;Exp E1&gt; : E};
} 

set[Var] freeVars(Exp E) {
    return allVars(E) - boundVars(E);
}

%% Generate a fresh variable if V does not occur in 
%% given set of variables.

Var fresh(Var V, set[Var] S) {
    if (V in S){ return prime(V); } else {return V;}
}

%% Substitution: replace all occurrences of V in E2 by E1

Exp subst(Var V1, Exp E1, Exp E2) {

    switch E2 {
      case &lt;Var V2&gt;: replace-by (V1==V2) ? E1 : V2;

      case &lt;Exp Ea&gt; &lt;Exp Eb&gt;:
        return [| &lt;subst(V, E, Ea)&gt; &lt;subst(V, E, Eb)&gt; |];

      case fn &lt;Var V2&gt; =&gt; &lt;Var Ea&gt;:
        if (V1 == V2) { replace-by [| fn &lt;V2&gt; =\&gt; &lt;Ea&gt; |]; }

      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;:
        if(V1 != V2 &amp;&amp; !(V1 in freeVars(E2) &amp;&amp; 
           V2 in freeVars(E1))){
           replace-by [| fn &lt;V2&gt; =\&gt; &lt;subst(V1, E1, Ea)&gt; |];
        }              
 
      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;: 
        if(V1 != V2 &amp;&amp; V1 in freeVars(Ea) &amp;&amp;
           V2 in freeVars(E1)){
           Var V3 = fresh(V2, freeVars(Ea) + freeVars(E1));
           Exp EaS = subst(V1, E1, subst(V2, V3, E2));
           replace-by [| fn &lt;V3&gt; =\&gt; &lt;EaS&gt; |];
        }
    }
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let</title>

      <para><programlisting>module Let-syntax
exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+                           -&gt; Var
context-free syntax
     Var                              -&gt; Exp
     "let" Var "=" Exp "in" Exp "end" -&gt; Exp </programlisting>Examples:<programlisting>module Let-Example

import Let;

%% Rename all bound variables in an Exp
%% Version 1: purely functional
%% Exp: given expression to be renamed
%% rel[Var,Var]: renaming table
%% Int: counter to generate unique variables

Exp rename(Exp E, rel[Var,Var] Rn, Int Cnt) {
    switch E {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end: {
         return [| let &lt;parseString("x" + toString(Cnt))&gt; = 
                       &lt;rename(E1, Rn, Cnt)&gt;
                   in 
                      &lt;rename(E2, {&lt;V, Y&gt;} + Rn, Cnt+1)&gt;
                   end
                |];
          }

    case &lt;Var V&gt;: return Rn(V);

    default: return E;
    }
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let using globals</title>

      <para>Here is the same renaming function now using two global
      variables.<programlisting>module Let-Example

import Let;

%% Rename all bound variables in an Exp
%% Version 2: using global variables
%% Cnt: global counter to generate fresh variables
%% rel[Var,Var]: global renaming table

global int Cnt = 0;
global rel[Var,Var] Rn = {};

Var newVar() {
    global int Cnt;  
    Cnt = Cnt + 1;
    return parseString("x" + toString(Cnt));
}

Exp rename(Exp E) {
    global int Cnt;
    global rel[Var,Var] Rn;
    switch E {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end: {
         Var Y = newVar();
         Rn = {&lt;V, Y&gt;} + Rn;
         return [| let &lt;Y&gt;= &lt;rename(E1)&gt;
                   in 
                      &lt;rename(E2)&gt;
                   end 
                |];
          }

    case &lt;Var V&gt;: return Rn(V);

    default: return E;
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico Typechecker</title>

      <para>The following example shows the tight integration ASF with
      comprehensions.<programlisting>module Typecheck

import Pico-syntax;
import Errors;

type map[PICO-ID,TYPE] Env;

list[Error] tcp(PROGRAM P) {
    switch P {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
           Env Env = {&lt;Id, Type&gt; | 
                      [| &lt;PICO-ID Id&gt; : &lt;TYPE Type&gt; |] : Decls};
           return [ tcst(S, Env) | Stat S : Series ];
      }
    }
}

list[Error] tcst(Stat Stat, Env Env) {
    switch Stat {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt;|]: {
        TYPE Type = Env[Id];
        return type_of(Exp, Type, Env);
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:
        return type_of(Exp, natural, Env) + 
               tcs(Stats1, Env) + tcs(Stats2, Env);

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od: 
        return type_of(Exp, natural, Env) + tcs(Stats, Env);
    }
}

list[Error] type_of(Exp E, TYPE Type, Env Env) {
    switch E {
      case &lt;NatCon N&gt;: if(Type == natural){ return []; }

      case &lt;StrCon S&gt;: if(Type == string) { return []; }

      case &lt;PICO-ID Id&gt;: {
         TYPE Type2 = Env(Id);
         if(Type2 == Type) { return []; }
      }

      case &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type_of(E1, natural, Env) + 
                  type_of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type_of(E1, natural, Env) + 
                  type_of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; || &lt;EXP E2&gt;: 
        if(Type == string){
          return type_of(E1, string, Env) + 
                 type_of(E1, string, Env);
        }
    
      default: return [error("Incorrect type")];
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator</title>

      <para><programlisting>module Pico-eval
import pico/syntax/Pico;
 
data PICO_VALUE int ival | str sval;

type map[PICO-ID, PICO_VALUE] VEnv;

VEnv evalProgram(PROGRAM P){
    switch P {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          VEnv Env = evalDecls(Decls);
          return evalStatements(Series, Env);
      }
   }
}

VEnv evalDecls(DECLS Decls){
    VEnv Env = {};
    visit Decls {
      case &lt;PICO-ID Id&gt; : string:  { Env[Id] = ""; return Env;}
      case &lt;PICO-ID Id&gt; : natural: { Env[Id] = 0;  return Env;}
    }
}

VEnv evalStatements({STATEMENT ";"}* Series, VEnv Env){
    switch Series {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        Env Env2 = evalStatement(Stat, Env);
        return evalStatements(Series2, Env2);
      }
      case [| |]: return Env;
    }
}

VEnv evalStatement(STATEMENT Stat, VEnv Env){
    switch Stat {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        Env[Id] = evalExp(Exp, Env);
        return Env;
      }

      case STATEMENT[| if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                       else &lt;{STATEMENT ";"}* Stats1&gt; fi |]:{
        PICO_VALUE Val = evalExp(Exp, Env);
        if(Val.ival != 0){
          return evalStatments(Stats1, Env);
        } else {
          return evalStatements(Stats2, Env);
        }
      }

      case STATEMENT[| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od|]: {
        PICO_VALUE Val = evalExp(Exp, Env);
        if(Val.ival != 0){
          return Env;
        } else {
          VEnv Env2 = evalStatements(Stats1, Env);
          return evalStatement(Stat, Env2);
        }
      }
    }
}

PICO_VALUE evalExp(Exp exp, VEnv Env) {
    switch exp {
      case NatCon[| &lt;NatCon N&gt; |]: 
           return toInt(unparseToString(N));

      case StrCon[| &lt;StrCon S&gt; |]: 
           return unparseToString(S);

      case PICO-ID[| &lt;PICO-ID Id&gt; |]: 
           return Env[Id];

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;:
           return evalExp(exp1, Env).ival +
                  evalExp(exp2, Env).ival;
      
      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;:
           return evalExp(exp1, Env).ival -
                  evalExp(exp2, Env).ival;
      
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;:
           return evalExp(exp1, Env).sval +
                  evalExp(exp2, Env).sval;
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator with globals</title>

      <para>Here is the same evaluator but now using a global variable to
      represent the value environment.<programlisting>module Pico-eval

import pico/syntax/Pico;

data PICO_VALUE int ival | str sval;

type map[PICO-ID, PICO_VALUE] VEnv;

global VEnv Env = {};

void evalProgram(PROGRAM P){
    switch P {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          evalDecls(Decls);
          evalStatements(Series);
      }
   }
}

VEnv evalDecls(DECLS Decls){
    global Venv Env;
    visit Decls {
      case &lt;PICO-ID Id&gt; : string:  Env[Id] = "";
      case &lt;PICO-ID Id&gt; : natural: Env[Id] = 0;
    }
}

void evalStatements({STATEMENT ";"}* Series){
    switch Series {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        evalStatement(Stat);
        evalStatements(Series2);
        return;
      }
      case [| |]: return;
    }
}

void evalStatement(STATEMENT Stat){
    global Venv Env;
    switch Stat {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        Env[Id] = evalExp(Exp);
        return;
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:{
        PICO_VALUE Val = evalExp(Exp);
        if(Val.ival != 0) {
          evalStatements(Stats1);
          return;
        } else {
          evalStatements(Stats2);
          return;
        }
      }

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od:{
        PICO_VALUE Val = evalExp(Exp);
        if(Val.ival != 0){
          return;
        } else {
          evalStatements(Stats1);
          evalStatement(Stat);
          return;
        }
      }
    }
};

PICO_VALUE evalExp(Exp exp) {
    global Venv Env;
    switch exp {
      case &lt;NatCon N&gt;: toInt(unparseToString(N));

      case &lt;StrCon S&gt;: return unparseToString(S);

      case &lt;PICO-ID Id&gt;: return Env[Id];

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;:
           return evalExp(exp1, Env).ival +
                  evalExp(exp2, Env).ival;

      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;:
           return evalExp(exp1, Env).ival -
                  evalExp(exp2, Env).ival;
   
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;:
          return evalExp(exp1, Env).sval +
                  evalExp(exp2, Env).sval;
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico control flow extraction</title>

      <programlisting>module Pico-controlflow
 
import pico/syntax/Pico;

data CP EXP exp | STATEMENT stat;

type tuple[set[CP] entry, 
           rel[CP,CP] graph, 
           set[CP] exit] CFSEGMENT;

CFSEGMENT cflow({STATEMENT ";"}* Stats){ 
    switch Stats {
      case &lt;STATEMENT Stat&gt; ; &lt;{STATEMENT ";"}* Stats2&gt;: { 
           CFSEGMENT CF1 = cflow(Stat);
           CFSEGMENT CF2 = cflow(Stats2);
           return &lt;CF1.entry, 
                   CF1.graph + CF2.graph + (CF1.exit * CF2.entry), 
                   CF2.exit&gt;;
      }

      case [| |]: return &lt;{}, {}, {}&gt;;
    }
}

CFSEGMENT cflow(STATEMENT Stat){
    switch Stat {
      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od : {
           CFSEGMENT CF = cflow(Stats);
           return &lt;{Exp}, ({Exp} * CF.entry) + CF.graph + 
                          (CF.exit * {Exp}),
                   {Exp}&gt;;
      }
                
      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats2&gt; fi: {
           CFSEGMENT CF1 = cflow(Stats1);
           CFSEGMENT CF2 = cflow(Stats2);
           return &lt; {Exp}, 
                    ({Exp} * CF1.entry) + 
                    ({Exp} * CF2.entry) + CF1.graph + CF2.graph,
                    CF1.exit + CF2.exit
                  &gt;;
      }
         
      case &lt;STATEMENT Stat&gt;: return &lt;{Stat}, {}, {Stat}&gt;;
    }
}
</programlisting>

      <para></para>
    </section>

    <section>
      <title>Pico use def extraction</title>

      <programlisting>module Pico-use-def

import pico/syntax/Pico;

rel[PICO-ID, EXP] uses(PROGRAM P) {
  return {&lt;Id, E&gt; | EXP E : P, PICO-ID Id := E};
}

rel[PICO-ID, STATEMENT] defs(PROGRAM P) { 
  return {&lt;Id, S&gt; | STATEMENT S : P, 
                    [| &lt;PICO-ID Id&gt; := &lt;EXP Exp&gt; |] := S};
}</programlisting>

      <para>The above uses a "matching condition" to decompose
      <literal>S</literal>. The problem solved is that we want to have a name
      for the whole assignment <emphasis>and</emphasis> for the lhs
      identifier. Also note that, compared to older definitions of these
      functions, the iudentifier is placed as first element in each
      tuple.</para>
    </section>

    <section>
      <title>Pico uninitialized variables</title>

      <para><programlisting>module Pico-uninit

import pico/syntax/Pico;

import Pico-controlflow;
import Pico-use-def;

set[PICO-ID] uninit(PROGRAM P) {
    rel[EXP,PICO-ID] Uses = uses(P);
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    CFSEGMENT CFLOW = cflow(P);
    set[CP] Root = CFLOW.entry;
    rel[CP,CP] Pred = CFLOW.graph; 

    return {Id | tuple[EXP E, PICO-ID Id] : Uses,
                 E in reachX(Root, Defs[Id], Pred)
    };
}
</programlisting></para>
    </section>

    <section>
      <title>Pico common subsexpression elimination</title>

      <para><programlisting>module Pico-common-subexpression

import pico/syntax/Pico;
import Pico-controlflow;
import Pico-use-def;

PROGRAM cse(PROGRAM P) {
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;
    map[EXP, PICO-ID] replacements = 
       {&lt;E2, Id&gt; | STATEMENT S : P,
                   [| &lt;PICO-ID Id&gt; := &lt;EXP E&gt; |] := S,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[Id], Pred)
       };
  
    visit P {
      case &lt;EXP E&gt;: if(PICO-ID Id := replacements(E)){
                       replace-by Id;
                    }
    }
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions E2 by Id, such
      that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>Id does not occur in E,</para>
        </listitem>

        <listitem>
          <para>E2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and E2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico constant propagation</title>

      <para><programlisting>module Pico-constant-propagation

import  pico/syntax/Pico;
import  Pico-controlflow;
import  Pico-use-def;

Boolean is_constant(EXP E) {
   switch E {
     case &lt;NatCon N&gt; =&gt; true

     case &lt;StrCon S&gt; =&gt; true

     case &lt;EXP E&gt;    =&gt; false
   }
}

PROGRAM cp(PROGRAM P) {
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;

    map[PICO-ID, EXP] replacements = 
      {&lt;Id2, E&gt; | STATEMENT S : P,
                  [| &lt;PICO-ID Id&gt; := &lt;EXP E&gt; |] := S,
                  is_constant(E),
                  PICO-ID Id2 : reachX({S},Defs[Id],Pred),
                  Id2 == Id 
      };  
 
    visit P {
     case &lt;PICO-ID Id&gt;: if(EXP E := replacements[Id]){
                           replace-by E;
                        }
    }
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions Id2 by the constant E,
      such that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>E is constant,</para>
        </listitem>

        <listitem>
          <para>Id2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>Id2 is equal to Id,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and Id2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico Reaching definitions</title>

      <para>Recall the equations construct as used, for example, in the
      reaching definitions example in the Rscript guide. It computes the
      values of a set of variables until none of them changes any longer. The
      "solve" statement achives the same effect.<programlisting>module Pico-reaching-defs

type tuple[Stat theStat, Var theVar] Def;
type tuple[Stat theStat, Var theVar] Use;

set[Stat] predecessor(rel[Stat,Stat] P, Stat S) { 
    return invert(P)[S];
}

set[Stat] successor(rel[Stat,Stat] P, Stat S) { 
    return P(S);
}

rel[Stat, Def] reaching_definitions(rel[Stat,Var] DEFS, 
                                        rel[Stat,Stat] PRED) {

    set[Stat] STATEMENT = carrier(PRED);

    rel[Stat,Def] DEF  = {&lt;S,&lt;S,V&gt;&gt; | tuple[Stat S, Var V]: DEFS};

    rel[Stat,Def] KILL = 
        {&lt;S1, &lt;S2, V&gt;&gt; | tuple[Stat S1, Var V] : DEFS, 
                         tuple[Stat S2, V] : DEFS, 
                         S1 != S2
        };

     rel[Stat,Def] IN = {};
     rel[Stat,Def] OUT = DEF;

     solve {
           IN  =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Stat P : predecessor(PRED,S), 
                            Def D : OUT[P]};
           OUT =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Def D : DEF[S] + (IN[S] - KILL[S])}
    }
    return IN;
}</programlisting></para>
    </section>

    <section>
      <title>Structured lexicals: numbers</title>

      <para>Given the SDF definition:<programlisting>sorts Digit Number Real  
lexical syntax
   [0-9]             -&gt; Digit
   Digit+            -&gt; Number
   Number "." Number -&gt; Real</programlisting>we can write normalization
      rules for <literal>Number</literal> that remove leading
      zeros:<programlisting>rules(Number){
   number("0" &lt;Digit+ Ds&gt;) =&gt; number(&lt;Ds&gt;)
}</programlisting></para>

      <para>Note that a character class can be used instead of the sort
      <literal>Digit</literal>:<programlisting>rules(Number){
   number("0" &lt;[0-9]+ Ds&gt;) =&gt; number(&lt;Ds&gt;)
}</programlisting></para>

      <para>A truncation function on <literal>Real</literal> can replace the
      mantissa by 0:</para>

      <para><programlisting>Real truncate(Real R){
    switch R {
       case real(&lt;Number Num&gt; "." &lt;Digit+ Ds&gt;) =&gt; real(&lt;Num&gt; "." "0")
    }
}</programlisting></para>
    </section>

    <section>
      <title>Structured Lexicals: strings</title>

      <para>Given the SDF definition:<programlisting>sorts String NQChar
lexical syntax
   ~[\"]             -&gt; NQChar
   [\"] NQChar* [\"] -&gt; String</programlisting>A function that removes the
      <emphasis>first</emphasis> newline from a string can be written
      as:<programlisting>String removeFirstNL(String S){
    switch S {
      case string("\"" &lt;NQChar* Chars1&gt; "\n" &lt;NQChar* Chars2&gt; "\"") =&gt;
           string("\"" &lt;Chars1&gt; &lt;Chars2&gt; "\"")
    }
}</programlisting></para>

      <para>A function that removes all newline from a string:<programlisting>String removeAllNL(String S){
    visit S {
      case string("\"" &lt;NQChar* Chars1&gt; "\n" &lt;NQChar* Chars2&gt; "\"") =&gt;
           string("\"" &lt;Chars1&gt; &lt;Chars2&gt; "\"")
    }
}</programlisting></para>
    </section>

    <section>
      <title>Symbol table with scopes</title>

      <para>Here is a (probably naive) implementation of a symbol table that
      maintains a list of numbered scopes as well as a (Name, Value) mapping
      in each scope. Note that we introduce parameterized modules to do this
      right.<programlisting>module SymTable[&amp;Name, &amp;Value]

%% A scope-oriented symbol table.
%% Each scope consists of a map from names to values. 
%% This is more intended to explore whether this can be expressed
%% *at all* than that the datatype is well designed.

type rel[&amp;Name, &amp;Value] ScopeMap;
type int ScopeId;
data STable[&amp;Name, &amp;Value] stable(ScopeId scope, 
                                  rel[int, ScopeMap] scopes); 

%%Create a new, empty,  table
fun STable[&amp;Name, &amp;Value] new_table(){
  return stable(0, {&lt;0, {}&gt;});
}

%% Create a new, non-empty, table
fun STable[&amp;Name, &amp;Value] new_table(ScopeId scope, 
                              rel[int, ScopeMap] scopes){
  return stable(scope, scopes);
} 

%% Update, in a given scope, the value of a variable
fun STable[&amp;Name, &amp;Value] update(STable[&amp;Name, &amp;Value] ST, 
                                 ScopeId scope, 
                                 &amp;Name N, 
                                 &amp;Value V){
  ST.scopes(scope) = V;
  return new_table(scope, ST.scopes)
}

%% Get, in a given scope, the value of a variable
fun STable[&amp;Name, &amp;Value] value_of(STable[&amp;Name, &amp;Value] ST, 
                                ScopeId scope, 
                                &amp;Name N){
  return ST.scopes(scope)(N)
}

%% update, in the current scope, the value of a variable
fun STable[&amp;Name, &amp;Value] update(STable[&amp;Name, &amp;Value] ST, 
                                 &amp;Name N, 
                                 &amp;Value V){
%%  ST.scopes(scope)(N)= V;
  return new_table(scope, ST.scopes)
}

%% Get, in the current scope, the value of a variable
fun STable value_of(STable[&amp;Name, &amp;Value] ST, 
                 &amp;Name N){
  return ST.scopes(ST.scope)(N)
}

%% add a new scope and make it the current scope
fun STable[&amp;Name, &amp;Value] new_scope(STable[&amp;Name, &amp;Value] ST){
  ScopeId scope = ST.scope + 1;
  return new_table(scope, ST.scopes);
}

%% switch to another scope
fun STable[&amp;Name, &amp;Value] switch_scope(STable[&amp;Name, &amp;Value] ST, 
                                       ScopeId scope){
  return new_table(scope, ST.scopes);
}

</programlisting></para>
    </section>

    <section>
      <title>Innerproduct</title>

      <para>[Example taken from TXL documentation]</para>

      <para>Define nnerproduct on vectors of integers, e.g. (1 2 3).(3 2 1)
      =&gt; 10.<programlisting>module examples/Vectors/Vector-syntax

exports
  imports basic/Integers
sorts Vector

context-free syntax
   "(" Integer* ")"    -&gt; Vector
   Vector "." Vector   -&gt; Integer</programlisting></para>

      <programlisting>module Innerproduct

import Vector-syntax;

int innerProduct(Vector V1, V2){
    if ( &lt;Integer N1&gt; &lt;Integer* Rest1&gt; := V1 and
         &lt;Integer N2&gt; &lt;Integer* Rest2&gt; := V2 
       )
       return (N1*N2) + innerProduct( [| (&lt;Rest1&gt;) |], [| (&lt;Rest2&gt;) |] )
    else
       return 0
}</programlisting>
    </section>

    <section>
      <title>Bubble sort</title>

      <para>[Example taken from TXL documentation]</para>

      <programlisting>module Bubble

import Vector-syntax;

Integer* sort(Integer* Numbers){
    visit Numbers {
      case &lt;Integer* Rest1&gt; 
              &lt;Integer N1&gt; &lt;Integer N2&gt; 
           &lt;Integer* Rest2&gt;:
           if(N1 &gt; N2){
              return sort( [| &lt;Integer* Rest1&gt; 
                                  &lt;Integer N2&gt; &lt;Integer N1&gt; 
                               &lt;Integer* Rest&gt;
                           |] );
           }
    };
    return Numbers
}</programlisting>

      <para>Another way to write this is:</para>

      <programlisting>module Bubble

Integer* sort(Integer* Numbers){
    visit Numbers {
      case &lt;Integer N1&gt; &lt;Integer N2&gt;:
        if( N1 &gt; N2 ) 
            yield [| &lt;Integer N2&gt; &lt;Integer N1&gt; |]
    };
    return Numbers
}</programlisting>

      <para>The visit will replace all adjacent pairs that are in the wrong
      order in the current list. This is repeated until no more changes are
      possible.<caution>
          <para>In the two above examples it is not elegant that the pattern
          following the case needs no quoting, and that the pattern following
          the <literal>return</literal>/<literal>replace</literal> has to be
          quoted.</para>
        </caution></para>
    </section>

    <section>
      <title>Generic Bubble sort</title>

      <para><caution>
          <para>The current syntax does not yet allow type variables in
          patterns. What are the implications for the implementation? Do we
          want this generality? Proposal: no since the ramifications are
          unclear.</para>
        </caution>Here is a generic bubble sort wich uses type parameters
      (&amp;ELEM) and a function parameter.<programlisting>module Bubble-Gen

fun &amp;Elem* sort(&amp;Elem* Elements, 
                fun bool GreaterThan(&amp;Elem, &amp;Elem)){
   
  visit repeat Elements {
      case &lt;&amp;Elem E1&gt; &lt;&amp;Elem E2&gt;: 
        if(GreaterThan(E1, E2)) 
           yield &lt;&amp;Elem E2&gt; &lt;&amp;Elem E1&gt;

     }
}</programlisting></para>

      <para>Of course, we can write a generic sort on arbitrary lists.</para>
    </section>

    <section>
      <title>Read-Eval-Print Loop (REPR) [Needs further discussion]</title>

      <para>For the scripting of application it is important to have a command
      language and read-eval-print loop. Here is an attempt. The command
      prompt is "&gt;".<programlisting>&gt; import lang.java.syntax.Main as Java
&gt; str source := read("program.java");
&gt; CU program := Java.CU.parse(source);

&gt; int count(CU P) {
    int cnt := 0;
&gt;   visit P {
&gt;     Java.Statements.IF =&gt; cnt++;
&gt;   }
    return cnt
&gt; }

&gt; count(program)
17</programlisting>There are several innovations here:</para>

      <itemizedlist>
        <listitem>
          <para>The import associates a name with the imported module.<caution>
              <para>Work out the details.</para>
            </caution><note>
              <para>This means that "grammar" and "rule" become notions that
              can be manipulated.</para>
            </note></para>
        </listitem>

        <listitem>
          <para>There is a read functions that reads a text file into a
          string.<caution>
              <para>We need an io library that reads/writes strings and data
              values. The current version is not yet ok.</para>
            </caution></para>
        </listitem>

        <listitem>
          <para>We associate a parse function with every non-terminal in a
          grammar.</para>
        </listitem>

        <listitem>
          <para>The notation <literal>Java.Statements.IF</literal> consists of
          three parts:</para>

          <itemizedlist>
            <listitem>
              <para>Language name</para>
            </listitem>

            <listitem>
              <para>Sort name</para>
            </listitem>

            <listitem>
              <para>Rule name (currently implemented with the "cons"
              attribute).</para>
            </listitem>
          </itemizedlist>

          <para>It can be used as pattern. Other potential uses are as
          generator:<programlisting>{S | Java.Statements.IF S : P}</programlisting>It
          generates all if statements in P.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>The Rascal standard library</title>

    <para>In this section we summarize the (over 300!) functions in the Rascal
    Standard Library.</para>

    <section>
      <title>Main functions</title>

      <para>The main functions of the library are listed in the following
      table.</para>

      <table>
        <title>Main functions and operators in Rascal Standard Library</title>

        <tgroup cols="11">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center">&#160;</entry>

              <entry align="center">bool</entry>

              <entry align="center">int</entry>

              <entry align="center">double</entry>

              <entry align="center">str&#160;</entry>

              <entry align="center">loc</entry>

              <entry align="center">list</entry>

              <entry align="center">set</entry>

              <entry align="center">map</entry>

              <entry align="center">rel</entry>

              <entry align="center">tuple_</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>_==_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>_&lt;_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>_+_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>_-_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>_*_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>_/_</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>_&amp;_</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>size</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>get</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>arb</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>toInt</entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>toDouble</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>toString</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>toList</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>toSet</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>toMap</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>toRel</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry></entry>
            </row>

            <row>
              <entry>reverse</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>reducer</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>mapper</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>min</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>max</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>sum</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>multiply</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>average</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>get_location</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>set_location</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Notes:</para>

      <itemizedlist>
        <listitem>
          <para>Operator <literal>==</literal> implements equality on all
          types. It is extended for data types using structural
          equality.</para>
        </listitem>

        <listitem>
          <para>Operator <literal>&lt;</literal> implements less-than on all
          types.</para>
        </listitem>

        <listitem>
          <para>Operators +, -, *, / implement these operators for most types.
          For structured types these operatords exist in three flavours:
          structured value op struct, structured value op element, and element
          op structured value.</para>
        </listitem>

        <listitem>
          <para><literal>size</literal> gives the number of elements of many
          types.</para>
        </listitem>

        <listitem>
          <para><literal>get</literal> (corresponds to the indexing notation
          R[N]) gives the N-th element of a structure.</para>
        </listitem>

        <listitem>
          <para><literal>arb</literal> generates an arbitrary element from a
          structured value.</para>
        </listitem>

        <listitem>
          <para><literal>toString</literal> converts all values to a string
          representation.</para>
        </listitem>

        <listitem>
          <para><literal>toList</literal>, <literal>toSet</literal>,
          <literal>toMap</literal>, <literal>toRel</literal> provide
          conversions between structured types. They may be implemented as
          just a type conversion (and not a data conversion).</para>
        </listitem>

        <listitem>
          <para><literal>reverse</literal> reverses the elements of ordered
          structured types.</para>
        </listitem>

        <listitem>
          <para><literal>reduce</literal>r and <literal>mapper</literal> take
          a function as argument and traverse a structured value.<note>
              <para>Due to a name class with the type constructor
              <literal>map</literal>, we use the name
              <literal>mapper</literal> for a function that is ussually called
              <literal>map</literal>. The usual function
              <literal>reduce</literal> is therefore called
              <literal>reducer</literal>.</para>
            </note></para>
        </listitem>

        <listitem>
          <para><literal>min</literal> and <literal>max</literal> compute the
          smallest (largest) of two basic values or all elements of structured
          values.</para>
        </listitem>

        <listitem>
          <para><literal>average</literal> computes the average value of
          structured values that contain integers or doubles.</para>
        </listitem>

        <listitem>
          <para>get_location and set_location are access functions for values
          of type <literal>loc</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Additional functions on lists sets, maps and relations</title>

      <para>Additional functions on lists, sets maps and relations are listed
      in the following table.<table>
          <title>Additional functions on lists, sets, maps and
          relations</title>

          <tgroup cols="6">
            <colspec align="center" />

            <thead>
              <row>
                <entry align="center">&#160;</entry>

                <entry align="center">list</entry>

                <entry align="center">set</entry>

                <entry align="center">map</entry>

                <entry align="center">rel</entry>

                <entry align="center">graph</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>first</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>rest</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>makeString</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>sort</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>id</entry>

                <entry></entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>power</entry>

                <entry></entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>product</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>compose</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>invert</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>complement</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>domain</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>range</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>carrier</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>domainR</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>rangeR</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>carrierR</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>domainX</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>rangeX</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>carrierX</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>top</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>bottom</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>reachR</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>reachX</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>
            </tbody>
          </tgroup>
        </table>Notes:</para>

      <itemizedlist>
        <listitem>
          <para>These functions are borrowed from the Rscript library.</para>
        </listitem>
      </itemizedlist>

      <caution>
        <para>closure is missing</para>
      </caution>
    </section>

    <section>
      <title>Other functions</title>

      <para>The remaining functions take care of annotations, input/output and
      communication with the global database with program facts, the Program
      Database (PDB).</para>
    </section>

    <section>
      <title>Source code</title>

      <para>This is a very first draft of the library. When the structure is
      stable we will split it in modules.<caution>
          <para>The following code is maintained externally and then copied
          :-( to this document, so be carefull with changes.</para>
        </caution><programlisting>module RascalStandardLibrary

tag function primitive str;
tag function memo void;
tag function java CompilationUnit;
tag all doc str;

%% Here is a flat list of library functions that will
%% structured in to coherent submodules.

%% --- Comparison operators ----------------------------------
%% Each type defines == and &lt;. The following
%% functions extend them.

public bool &lt;=(&amp;T A, &amp;T B){
  return A &lt; B or A == B;
}

public bool &gt;(&amp;T A, &amp;T B){
  return B &lt; A and not A == B;
}

public bool &gt;=(&amp;T A, &amp;T B){
  return B &lt; A;
}

public &amp;T min(&amp;T A, &amp;T B){
  if(A &lt; B){
    return A;
  } else {
    return B;
  }
}

public &amp;T max(&amp;T A, &amp;T B){
  if(A &lt; B){
    return B;
  } else {
    return A;
  }
}

%% --- Boolean (bool) ----------------------------------------

public bool ==(bool B1, bool B2)
  @doc{Equality on Booleans}
  @primitive{Bool.equal}

public bool &lt;(bool B1, bool B2)
  @primitive{Bool.less}
 
public bool +(bool B1, bool B2)
  @primitive{Bool.add}

public bool -(bool B1, bool B2)
  @primitive{Bool.sub}

public bool *(bool B1, bool B2)
  @primitive{Bool.mul}

public int arb()
  @primitive{Bool.arb}

public str toString(bool B)
  @primitive{Bool.toString}

public int toInt(bool B)
  @primitive{Bool.toInt}
  
public double toDouble(bool B)
  @primitive{Bool.toDouble}

%% --- Integer (int)------------------------------------------

public bool ==(int I1, int I2)
  @primitive{Int.equal}
  
public bool &lt;(int I1, int I2)
  @primitive{Int.less}

public int +(int I1, int I2) 
  @primitive{Int.add}

public int -(int I1, int I2)  
  @primitive{Int.sub}
  

@primitive{Int.mul}
  public int *(int I1, int I2)
 
public int /(int I1, int I2)
  throws divide_by_zero(str msg)
  @primitive{Int.div}

public int arb(int bgn, int end)
throws illegal_argument(str msg) %% if(end - bgn &lt;= 0)
  @primitive{Int.arb} 

public double toDouble(int I)
  @primitive{Int.toDouble}

public str toString(int I)  
  @primitive{toStringInt}

%% --- Double (double) ---------------------------------------

public bool ==(double D1, double D2)
  @primitive{Double.equal} 

public bool ==(double D, int I){
  return D == toDouble(I);
}

public bool ==(int I, double D){
  return toDouble(I) == D;
}

public bool &lt;(double D1, double D2)
  @primitive{Double.less}

public bool &lt;(double D, int I){
  return D &lt; toDouble(I);
}

public bool &lt;(int I, double D){
  return toDouble(I) &lt; D;
}

public double +(double D1, double D2)
  @primitive{Double.add}
  
public bool +(double D, int I){
  return D + toDouble(I);
}

public bool +(int I, double D){
  return toDouble(I) + D;
}

public double -(double D1, double D2)
  @primitive{Double.sub}
 
public bool -(double D, int I){
  return D - toDouble(I);
}

public bool -(int I, double D){
  return toDouble(I) - D;
}

public double *(double D1, double D2)
  @primitive{Double.mul} 

public bool *(double D, int I){
  return D * toDouble(I);
}

public bool *(int I, double D){
  return toDouble(I) * D;
}

public double /(double D1, double D2)
throws divide_by_zero(str msg)
  @primitive{Double.div}
 
public bool /(double D, int I){
  return D / toDouble(I);
}

public bool /(int I, double D){
  return toDouble(I) / D;
}

public double arb(double bgn, double end)
throws illegal_argument(str msg) %% if(end - bgn &lt;= 0)
  @primitive{Double.arb}

public int toInt(double D)
  @primitive{Double.toInt}
 
public str toString(double D)
  @primitive{Double.toString}

%% --- Strings (str) -----------------------------------------

public bool ==(str S1, str S2)
  @primitive{String.equal}

public bool &lt;(str S1, str S2)
  @primitive{String.less}

public str +(str S1, str S2)
  @primitive{String.add}

public int size(str S)
  @primitive{String.size}

public int get(str S, int N)
  throws out_of_range(str msg)
  @primitive{String.get}

public int toInt(str S)
  throws cannot_convert_to_int(str msg)
  @primitive{String.toInt}

public int toDouble(str S)
  throws cannot_convert_to_double(str msg)
  @primitive{String.toDouble}

public list[int] toList(str S)
  throws cannot_convert_int_to_char(str msg)
  @primitive{String.toList}
 
public set[int] toSet(str S)
  @primitive{String.toSet}

public str reverse(str S)
  @primitive{String.reverse}

%% Add functions for other methods of Java's String class

%% --- Locations ---------------------------------------------
   
%% The location datatype
data location location(str filename,
                       int beginline,
                       int endline,
                       int begincol,
                       int endcol,
                       int offset,
                       int length);

anno tree posinfo loc;

public bool ==(loc L1, loc L2)
  @primitive{Location.equal} 

public bool &lt;(loc L1, loc L2)
  @primitive{Location.less}

public str toString(loc L)
  @primitive{Location.toString}

public loc get_location(&amp;T Subject)
  throws location_missing(str msg)
  @primitive{Location.get_location}

public &amp;T set_location(&amp;T Subject, loc L)
  @primitive{Location.set_location}

%% --- Lists -------------------------------------------------

public bool ==(list[&amp;T] L1, list[&amp;T] L2)
  @primitive{List.equal}

public bool &lt;(list[&amp;T] L1, list[&amp;T] L2)
  @primitive{List.less}

public list[&amp;T] +(list[&amp;T] L1, list[&amp;T] L2)
  @primitive{List.add}

public list[&amp;T] +(list[&amp;T] L, &amp;T E){
  return L + [E];
}

public list[&amp;T] +(&amp;T E, list[&amp;T] L){
  return [E] + L;
}

public int size(list[&amp;T] L)
  @primitive{List.size}
 
public &amp;T get(list[&amp;T] L, int N)
  throws out_of_range(str msg)
  @doc{Get list element: get}
  @primitive{List.get}

public &amp;T arb(list[&amp;T] L)
  @primitive{List.arb}

public str toString(list[&amp;T] L)
  @primitive{List.toString}

public str makeString(list[int] L)
  throws cannot_convert_int_to_char(str msg)
  @primitive{List.makeString}

public set[&amp;T] toSet(list[&amp;T] L)
  @primitive{List.toSet}


public map[&amp;T, &amp;U] toMap(list[tuple[&amp;T, &amp;U]] L)
  throws domain_not_unique(str msg)
  @primitive{List.toMap}
 
public rel[&amp;T] toRel(list[&amp;T] L)
  @primitive{List.toRel}

public list[&amp;T] reverse(list[&amp;T] L)
  @primitive{List.reverse}

public &amp;T reducer(list[&amp;T] L, &amp;T F (&amp;T,&amp;T), &amp;T unit){
  &amp;T result = unit;
  for(&amp;T E : L){
    result = F(result, E);
  }
  return result;
}

public list[&amp;T] mapper(list[&amp;T] L, &amp;T F (&amp;T,&amp;T)){
  return [F(E) | &amp;T E : L];
}

public &amp;T min(list[&amp;T] L)
@doc{Minimum element of a list: min}
{
  &amp;T result = arb(L);
  for(&amp;T E : L){
   if(less(E, result)){
      result = min(result, E);
   }
  }
  return result;
}

public &amp;T max(list[&amp;T] L)
@doc{Maximum element of a list: max}
{
  &amp;T result = arb(L);
  for(&amp;T E : L){
   if(less(result, E)){
      result = max(result, E);
   }
  }
  return result;
}

public &amp;T sum(list[&amp;T] L, &amp;T zero)
@doc{Add elements of a List: sum}
{
  return reducer(L, +, zero);
}

public &amp;T multiply(set[&amp;T] R, &amp;T one)
@doc{Multiply elements of a list: multiply}
{
  return reducer(L, *, one);
}

public &amp;T average(list[&amp;T] L, &amp;T zero)
@doc{Average of elements of a list: average}
{
  return sum(L, zero)/size(L);
}

public &amp;T first(list[&amp;T] L)
  throws empty_list(str msg)
  @doc{First element of list: first}
  @primitive{List.first}

@primitive{List.rest}
@doc{Remaining elements of list: rest}
  public &amp;T rest(list[&amp;T] L)
  throws empty_list(str msg)

public list[&amp;T] sort(list[&amp;T] L, bool less(&amp;T, &amp;T))
  @doc{Sort elements of list: sort}
  @primitive{list.sort}
 
%% --- Tuples ------------------------------------------------

public bool ==(tuple[&amp;T] R, tuple[&amp;T] S)
  @primitive{Tuple.equal}
 
public bool &lt;(tuple[&amp;T] R, tuple[&amp;T] S)
  @primitive{Tuple.less}
 
public tuple[&amp;T + &amp;U] +(tuple[&amp;T] R, tuple[&amp;U] S)
  @primitive{Tuple.add}

public tuple[&amp;T + &amp;U] +(tuple[&amp;T] R, &amp;U E){
  return R + &lt;E&gt;;
}

public tuple[&amp;T + &amp;U] +(&amp;T E, tuple[&amp;U] R){
  return &lt;E&gt; + R;
}

public int size(tuple[&amp;T] R)
  @primitive{Tuple.size}

public value get(tuple[&amp;T] R, int N)
  throws out_of_range(str msg)
  @primitive{Tuple.get}

public str toString(tuple[&amp;T] R)
  @primitive{Tuple.toString}

%% --- Sets  -------------------------------------------------

public bool ==(set[&amp;T] R, set[&amp;T] S)
  @primitive{Set.equal}

public bool &lt;(set[&amp;T] R, set[&amp;T] S)
  @primitive{Set.less}

public set[&amp;T] +(set[&amp;T] R, set[&amp;T] S)
  @doc{Add two sets (set union): operator +}
  @primitive{Set.add}
  
public set[&amp;T] +(set[&amp;T] S, &amp;T E){
  return S + {E};
}

public set[&amp;T] +(&amp;T E, set[&amp;T] S){
  return {E} + S;
}

public set[&amp;T] -(set[&amp;T] R, set[&amp;T] S)
  @doc{Substract two sets (set difference): operator -}
  @primitive{Set.sub}

public set[&amp;T] -(set[&amp;T] S, &amp;T E){
  return S - {E};
}

public set[&amp;T] -(&amp;T E, set[&amp;T] S){
  return {E} - S;
}

public set[&amp;T] &amp;(set[&amp;T] R, set[&amp;T] S)
  @doc{Intersection of two sets: operator &amp;}
  @primitive{Set.intersection}

public set[&amp;T] &amp;(set[&amp;T] S, &amp;T E){
  return S &amp; {E};
}

public set[&amp;T] &amp;(&amp;T E, set[&amp;T] S){
  return {E} &amp; S;
}

public int size(set[&amp;T] S)
  @primitive{Set.size}

public &amp;T arb(set[&amp;T] S)
  @primitive{Set.arb}
  
public str toString(set[&amp;T] S)
  @primitive{Set.toString}

public list[&amp;T] toList(set[&amp;T] S)  
  @primitive{List.toList}
  
public map[&amp;T, &amp;U] toMap(set[tuple[&amp;T, &amp;U]] S)
  throws non_unique_domain(str msg)
  @primitive{Set.toMap}

public rel[&amp;T] toRel(set[&amp;T] S)
   @primitive{Set.toRel}

public &amp;T reducer(set[&amp;T] S, &amp;T F (&amp;T,&amp;T), &amp;T unit){
  &amp;T result = unit;
  for(&amp;T E : S){
    result = F(result, E);
  }
  return result;
}

public set[&amp;T] mapper(set[&amp;T] S, &amp;T F (&amp;T,&amp;T)){
  return {F(E) | &amp;T E : S};
}

public &amp;T min(set[&amp;T] S)
  @doc{Minimum of a set: min}
{
  &amp;T result = arb(S);
  for(&amp;T E : S){
    result = min(result, E);
  }
  return result;
}

public &amp;T max(set[&amp;T] R)
  @doc{Maximum of a set: max}
{
  &amp;T result = arb(R);
  for(&amp;T E : R){
    result = max(result, E);
  }
  return result;
}

public &amp;T sum(set[&amp;T] S, &amp;T zero)
  @doc{Sum elements of a Set: sum}
{
  return reducer(S, +, zero);
}

public &amp;T multiply(set[&amp;T] S, &amp;T one)
  @doc{Multiply elements of a Set: multiply}
{
  return reducer(S, *, one);
}

public &amp;T average(set[&amp;T] S, &amp;T zero)
  @doc{Average of elements of a set: average}
{
  return sum(S, zero)/size(R);
}

%% TODO

%% Powerset: power0
%%public set[set[&amp;T]] power0(set[&amp;T] R)
%% throw unimplemented("power0")

%% Powerset: power1
%%public set[set[&amp;T]] power1(set[&amp;T] R)
%%  throw unimplemented("power0")

%% --- Maps --------------------------------------------------

public bool ==(map[&amp;T, &amp;U] M1, map[&amp;T, &amp;U] M2)
  @primitive{Map.equal}
  
public bool &lt;(map[&amp;T, &amp;U] M1, map[&amp;T, &amp;U] M2)
  @primitive{Map.less}
  
public map[&amp;T] +(map[&amp;T] R, map[&amp;T] S)
  @primitive{Map.add}
  
public map[&amp;T] +(map[&amp;T] S, &amp;T E){
  return S + {E};
}

public map[&amp;T] +(&amp;T E, map[&amp;T] S){
  return {E} + S;
}

public map[&amp;T] -(map[&amp;T] R, map[&amp;T] S)
  @primitive{Map.sub}
  @doc{Substract two maps (set difference): operator -}

public map[&amp;T] -(map[&amp;T] S, &amp;T E){
  return S - {E};
}

public map[&amp;T] -(&amp;T E, map[&amp;T] S){
  return {E} - S;
}

public map[&amp;T] &amp;(map[&amp;T] R, map[&amp;T] S)
  @primitive{Map.mul}
  @doc{Intersection of two maps: operator &amp;}

public map[&amp;T] &amp;(map[&amp;T] S, &amp;T E){
  return S &amp; {E};
}

public map[&amp;T] &amp;(&amp;T E, map[&amp;T] S){
  return {E} &amp; S;
}

public int size(map[&amp;T] M)
  @primitive{Map.size}

public &amp;T arb(map[&amp;T] M)
  @primitive{Map.arb}
  
public str toString(map[&amp;T] R)
  @primitive{Map.toString}
  
public list[tuple[&amp;T, &amp;U]] toList(map[&amp;T, &amp;U] M)
  @primitive{Map.toList}

public rel[tuple[&amp;T, &amp;U]] toSet(map[&amp;T, &amp;U] M)
  @primitive{Map.toSet}

public rel[tuple[&amp;T, &amp;U]] toRel(map[&amp;T, &amp;U] M)
  @primitive{Map.toRel}

%% Is this meaningfull?
public &amp;T reducer(map[&amp;T] S, &amp;T F (&amp;T,&amp;T), &amp;T unit){
  &amp;T result = unit;
  for(&amp;T E : S){
    result = F(result, E);
  }
  return result;
}

public map[&amp;T] mapper(map[&amp;T] M, &amp;T F (&amp;T,&amp;T)){
  return {F(E) | &amp;T E : M};
}

%% --- Relations ---------------------------------------------

public bool ==(rel[&amp;T] R, rel[&amp;T] S)
  @primitive{Rel.equal}
  
public bool &lt;(rel[&amp;T] R, rel[&amp;T] S)
  @primitive{Rel.less}
  
public rel[&amp;T] +(rel[&amp;T] R1, rel[&amp;T] R2)
  @doc{Add two relations (union): operator +}
  @primitive{Rel.add}

public rel[&amp;T] +(&amp;T E, rel[&amp;T] R){
  return toRel({E}) + R;
}

public rel[&amp;T] +(rel[&amp;T] R, &amp;T E){
  return R + toRel({E});
}

public rel[&amp;T] -(rel[&amp;T] R1, rel[&amp;T] R2)
  @doc{Substract two relations (difference): operator -}
  @primitive{Rel.sub}
  
public rel[&amp;T] &amp;(rel[&amp;T] R1, rel[&amp;T] R1)
  @doc{Intersection of two relations: operator &amp;}
  @primitive{Rel.inter}

public int size(rel[&amp;T] R)
  @primitive{Rel.size}
  
public &amp;T arb(rel[&amp;T] R)
  @primitive{Rel.arb}

public str toString(rel[&amp;T] R)
  @primitive{Rel.toString}

%% Note: in rel[&amp;T], the type variable &amp;T refers 
%% to the tuple type of the relation.

public list[&amp;T] toList(rel[&amp;T] R)
  @primitive{Rel.toList}
  
public set[&amp;T] toSet(rel[&amp;T] R)
  @primitive{Rel.toSet}
  
public rel[&amp;T] toRel(set[&amp;T] S)
  @primitive{Set.toRel}
  
public rel[&amp;T] mapper(rel[&amp;T] R, &amp;T F (&amp;T,&amp;T)){
  return {F(E) | &amp;T E : R};
}

%% Carthesian product of two sets: product (was: x)
public rel[&amp;T1, &amp;T2] product(rel[&amp;T1] R, rel[&amp;T2] S){
  return {&lt;X, Y&gt; | &amp;T1 X : R, &amp;T2 Y : S};
}

%% Compose two relations: compose (was: o)
public rel[&amp;T1, &amp;T3] compose(rel[&amp;T1, &amp;T2] R,
                                 rel[&amp;T2, &amp;T3] S){
   return {&lt;X, Z&gt; | tuple[&amp;T1 X, &amp;T2 Y1]: R, 
                    tuple[&amp;T2 Y2, &amp;T3 Z]: S, Y1 == Y2};
}

%% Identity relation: id
public rel[&amp;T, &amp;T] id(set[&amp;T] S){
  return { &lt;X, X&gt; | &amp;T X : S};
}

%% Inverse relation: invert (was: inv)
public rel[&amp;T2, &amp;T1] invert (rel[&amp;T1, &amp;T2] R){
  return { &lt;Y, X&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R };
}

%% Complement of relation: complement (was: compl)
public rel[&amp;T1, &amp;T2] complement(rel[&amp;T1, &amp;T2] R){
  return product(domain(R), range(R)) - R;
}

%% Domain of relation: domain
public set[&amp;T1] domain (rel[&amp;T1,&amp;T2] R){
  return { X | tuple[&amp;T1 X, &amp;T2 Y] : R };
}

%% Range of relation: range
public set[&amp;T1] range (rel[&amp;T1,&amp;T2] R){
  return { Y | tuple[&amp;T1 X, &amp;T2 Y] : R };
}

%% Carrier of relation: carrier
public set[&amp;T]  carrier (rel[&amp;T,&amp;T] R) {
  return domain(R) + range(R);
}

%% Domain Restriction of a Relation: domainR
public rel[&amp;T1,&amp;T2] domainR (rel[&amp;T1,&amp;T2] R, set[&amp;T1] S){
  return { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, X in S };
}

%% Range Restriction of a Relation: rangeR
public rel[&amp;T1,&amp;T2] rangeR (rel[&amp;T1,&amp;T2] R, set[&amp;T2] S){
  return { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, Y in S };
}

%% Carrier Restriction of a Relation: carrierR
public rel[&amp;T,&amp;T] carrierR (rel[&amp;T,&amp;T] R, set[&amp;T] S){
  return { &lt;X, Y&gt; | tuple[&amp;T X, &amp;T Y] : R, X in S, Y in S };
}

%% Domain Exclusion of a Relation: domainX
public rel[&amp;T1,&amp;T2] domainX (rel[&amp;T1,&amp;T2] R, set[&amp;T1] S){
  return { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, X notin S };
}

%% Range Exclusion of a Relation: rangeX
public rel[&amp;T1,&amp;T2] rangeX (rel[&amp;T1,&amp;T2] R, set[&amp;T2] S){
  return { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, Y notin S };
}

%% Carrier Exclusion of a Relation: carrierX
public rel[&amp;T,&amp;T] carrierX (rel[&amp;T,&amp;T] R, set[&amp;T] S){
  return { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, 
                    X notin S, Y notin S };
}

%% Relations viewed as graphs

type rel[&amp;T,&amp;T] graph[&amp;T];

%% Top of a Graph: top
public set[&amp;T] top(graph[&amp;T] G){
  return domain(G) - range(G);
}

%% Bottom of a Graph: bottom
public set[&amp;T] bottom(graph[&amp;T] G){
  return range(G) - domain(G);
}

%% Reachability with Restriction: reachR
public set[&amp;T] reachR(set[&amp;T] Start, set[&amp;T] Restr,
                          graph[&amp;T] G){
  return range(compose(domainR(G, Start), 
                       carrierR(G, Restr)+));
}

%% Reachability with Exclusion: reachX
public set[&amp;T] reachX(set[&amp;T] Start, set[&amp;T] Excl, 
                          graph[&amp;T] G){
  return range(compose(domainR(G, Start), 
                       carrierX(G, Excl)+));
}

public list[&amp;T] shortestPathPair(&amp;T From, &amp;T To, graph[&amp;T] G)
  @doc{Shortest path between pair of nodes}
  @primitive{Graph.shortestPathPair}

public set[list[&amp;T]] shortestPathFrom(&amp;T From, graph[&amp;T] G)
  @doc{Shortest path between one node and all others}
  @primitive{Graph.shortestPathFrom}

public set[list[&amp;T]] shortestPathAll(graph[&amp;T] G)
  @doc{Shortest path between all nodes}
  @primitive{Graph.shortestPathAll}

%% TO DO

public rel[&amp;T, &amp;T] closure(rel[&amp;T, &amp;T])
  @primitive{Rel.closure}

%% --- Annotations -------------------------------------------

%% TODO: Sync this with new annotation operators!

public bool has_annotation(&amp;T Subject, str Name)
  @doc{Test whether a named annotation exists}
  @primitive{Annotation.has_annotation}

public value get_annotation(&amp;T Subject, str Name)
  throws missing_annotation(str msg)
  @doc{Get the value of a named annotation}
  @primitive{Annotation.get_annotation}

public map[str,value] get_annotations(&amp;T Subject)
  @doc{Get all annotations}
  @primitive{Annotation.get_annotations}
 
public &amp;T set_annotation(&amp;T Subject, 
                             str Name, value AValue)
  @doc{Set the value of a named annotation}
  @primitive{Annotation.set_annotation}


public &amp;T set_annotations(&amp;T Subject, 
                              map[str, value] Annos)
  @doc{Set all annotations}
  @primitive{Annotation.set_annotations}

%% --- Parsing and Unparsing -------------------------------------

public tree parseFile(str filename)
  throws file_does_not_exist(str msg)
  @primitive{Parse.parseFile}

public tree parseString(str source)
  @primitive{Parse.parseString}
  
public str unparseToString(tree Subject)
  @primitive{Parse.unparseToString}
  
public str unparseToFile(tree Subject, str filename)
  throws cannot_create(str msg) 
  throws write_error(str msg) 
  @primitive{Parse.unparseToFile}

%% --- trees -------------------------------------------------

public int toInt(tree Subject)
  throws cannot_convert(str msg)
  @primitive{Tree.toInt}

public int toDouble(tree Subject)
  throws cannot_convert(str msg)
  @primitive{Tree.toDouble}

public int toString(tree Subject)
  throws cannot_convert(str msg)
  @primitive{Tree.toString}

%% --- io ----------------------------------------------------

public str readFile(str filename)
  throws does_not_exist(str msg)            
  throws read_error(str msg)
  @primitive{IO.read}


public &amp;T readTerm(str filename) 
  throws does_not_exist(str msg)  
  throws read_error(str msg)
  throws term_error(str msg, loc l)
  @primitive{IO.readTerm}


public void write(str filename, &amp;T Subject) 
  throws cannot_create(str msg)  
  throws write_error(str msg)
  @primitive{IO.write}

public void print(list[value] V...)
  @primitive{IO.print}

public void println(list[value] V...)
  @primitive{IO.println}
 
%% --- Interface with the Program Database -------------------
%% The following function provide a bare minimum and will
%% have to compared with the current PDB interface.
%% We assume one active PDB that can be opened and closed.
%% Values can be written to and read from the PDB.

%% Idea: it would be nice to model the PDB as a value
%% of type map[str, value] and to access it that way!

public void openPDB(str name) 
  throws cannot_open(str msg)
  @primitive{PDB.open}

public void closePDB()
  throws cannot_close(str msg)
  @primitive{PDB.close}

public void writePDB(str name, &amp;T val)
  throws cannot_write(str msg)
  @primitive{PDB.write}

public &amp;T readPDB(str name)
  throws cannot_read(str msg)
  @primitive{PDB.readPDB}

%% If name is of type set[&amp;T], then the set incr
%% is added to it. Similar for a rel[&amp;T]

public void addSetPDB(str name, set[&amp;T] incr)
  throws does_not_exist(str msg)
  @primitive{PDB.addSet}

public void addRelPDB(str name, rel[&amp;T] incr)
  throws does_not_exist(str msg)
  @primitive{PDB.addRel}</programlisting></para>
    </section>
  </section>

  <section>
    <title>Syntax Definition</title>

    <para>See separate SDF definition.</para>
  </section>

  <section>
    <title>Protyping/implementation of Rascal</title>

    <para>Every prototype will have to address the following issues:</para>

    <itemizedlist>
      <listitem>
        <para>Parsing/typechecking/evaluating Rascal.</para>
      </listitem>

      <listitem>
        <para>How to implement the relational operations.</para>
      </listitem>

      <listitem>
        <para>How to implement matching.</para>
      </listitem>

      <listitem>
        <para>How to implement replacement.</para>
      </listitem>

      <listitem>
        <para>How to implement traversals.</para>
      </listitem>
    </itemizedlist>

    <para>The following options should be considered:</para>

    <itemizedlist>
      <listitem>
        <para>Implementation of a typechecker in ASF+SDF:</para>

        <itemizedlist>
          <listitem>
            <para>Gives good insight in the type system and is comparable in
            complexity to the Rscript typechecker.</para>
          </listitem>

          <listitem>
            <para>Work: 2 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            ASF+SDF.</para>
          </listitem>

          <listitem>
            <para>Bound to be very slow.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of a typechecker in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Interesting exercise to asses Rascal.</para>
          </listitem>

          <listitem>
            <para>Not so easy to do without working Rascal
            implementation.</para>
          </listitem>

          <listitem>
            <para>Not so easy when Rascal is still in flux.</para>
          </listitem>

          <listitem>
            <para>Effort: 1 week</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Ditto.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Extending the current ASF+SDF interpreter.</para>

        <itemizedlist>
          <listitem>
            <para>This is a viable options. It requires extensions of
            UPTR.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Translation of Rascal to ASF+SDF in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Unclear whether this has longer term merit.</para>
          </listitem>

          <listitem>
            <para>Allows easy experimentation and reuse of current ASF+SDF
            implementation.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an interpreter in Java.</para>

        <itemizedlist>
          <listitem>
            <para>A future proof and efficient solution.</para>
          </listitem>

          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            Java.</para>
          </listitem>

          <listitem>
            <para>Effort: 8 weeks.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Rascal implementation ideas</title>

    <para>Rascal needs to support both a scripting experience as an optimized
    compiled language experience. Also, it needs to integrate fully with
    Meta-Environment and Eclipse IMP. Therefore, we have both a simple and
    unoptimized interpreter in mind, as well as a compiler that aggressively,
    but correctly, optimizes Rascal programs. The run-time of compiled
    programs and the interpreter will share the implementation of
    data-structures.</para>

    <section>
      <title>Data structures</title>

      <para>Both the compiled code and the interpreter will run on the same
      data-structures which are defined by the IMP PDB project.</para>

      <itemizedlist>
        <listitem>
          <para>We could start with the simple implementation that is now in
          IMP already which is based on the Java library and use the clone
          method to implement immutability. This will prove to be slow, but
          its an easy start.</para>
        </listitem>

        <listitem>
          <para>Integration with the ATerms; extend the ATerm library with all
          the features of the PDB, such that it becomes an implementation of
          the PDB's interfaces.</para>

          <itemizedlist>
            <listitem>
              <para>PDB's terms are typed, while ATerms are not.</para>
            </listitem>

            <listitem>
              <para>ATerms demand canonicalization/sharing, which may prove to
              be hard to implement for maps, sets and relations.</para>
            </listitem>

            <listitem>
              <para>PDB does not yet have any story for serialization.</para>
            </listitem>

            <listitem>
              <para>ATerms will need to "implement" the PDB's interfaces which
              will add a dependency and seriously break other peoples code if
              we are not careful</para>
            </listitem>

            <listitem>
              <para>ATerms need to be typed in order to implement correct
              visiting behavior when AFun's are overloaded.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The C story is harder</para>

          <itemizedlist>
            <listitem>
              <para>Extension of C ATerms is hard due to the nature of C, the
              ATerm garbage collector, the ATerm header implementation and the
              amount of users of the ATerm library</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>It may be a good idea to generate Rascal data-types from SDF
          definitions as an intermediate step, however, Rascal should still
          implement special code for UPTR trees for performance reasons
          (unlike Apigen which does not know anything about UPTR).</para>
        </listitem>

        <listitem>
          <para>The current PDB implementation does type checking at run-time.
          After implementing a type-checker for Rascal, we can easily add an
          implementation which does not do type checking at run-time in order
          to improve performance.</para>
        </listitem>

        <listitem>
          <para>The immutability feature of Rascal data is implemented in the
          data-structures and not by the compiler or the interpeter.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Interpreter</title>

      <para>We just enumerate the thoughts that pop up once in a while:</para>

      <itemizedlist>
        <listitem>
          <para>Write the interpreter in Java, and use it later to bootstrap
          the compiler which will be written in Rascal.</para>
        </listitem>

        <listitem>
          <para>Provide a REPL prompt such that experimenting can be done
          on-the-fly, both on the commandline, and in an Eclipse view.</para>
        </listitem>

        <listitem>
          <para>"fail" can be implemented using a Java exception, the catch
          will be at the choice points (switch).</para>
        </listitem>

        <listitem>
          <para>"return" can also be implemented using a Java exception;
          remember return can jump out of the context of a visitor that could
          be nested deeply in the structure of a term or a tree.</para>
        </listitem>

        <listitem>
          <para>List matching, and especially the kind of backtracking it
          requires will be implemented using exceptions instead of using
          continuations.</para>
        </listitem>

        <listitem>
          <para>Pattern matching needs to be implemented separately for both
          builtin data-types, abstract data types and concrete parse trees.
          Possibly using three "adapters" we can factor out the
          algorithm.</para>
        </listitem>

        <listitem>
          <para>We use apigen to bootstrap the interpreter. The interpreter
          will traverse the apigen object trees to implement it's
          functionality using separate classes.</para>
        </listitem>

        <listitem>
          <para>When the compiler is finished and bootstrapped on the
          interpreter, it may be worthwhile to reimplement/bootstrap the
          interpreter on the compiler again.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Compiler</title>

      <para>The compiler will mainly follow the design of Mark's ASF+SDF
      compiler, which has proven to generate the fastest code in the world for
      these kinds of applications. Furthermore, these ideas have popped
      up:</para>

      <itemizedlist>
        <listitem>
          <para>Bootstrap the compiler using the interpreter.</para>
        </listitem>

        <listitem>
          <para>Generate as readable function names as possible, mainly taking
          hints from the Rascal programs and of course from the SDF
          definitions.</para>
        </listitem>

        <listitem>
          <para>Generate Java code, one class per module.</para>
        </listitem>

        <listitem>
          <para>There is an issue with the globality of rewrite rules, they
          probably need to be collected and merged into a single factory per
          application. Rules apparently break modular compilation, especially
          if you want to optimize matching automatons</para>
        </listitem>

        <listitem>
          <para>For visitors we could first generate a tree node type
          reachability graph, and use it to generate a full traversal for a
          certain visitor. The generated visitor would not recurse into
          subtrees that will not be visited.</para>
        </listitem>

        <listitem>
          <para>After generating the visitors, non-recursive visits (i.e. the
          backbone of the grammar) can be inlined as much as possible to
          prevent using the stack for visiting trees.</para>
        </listitem>

        <listitem>
          <para>Inlining in general should be done very aggressively. This
          will allow other kinds of optimizations, like preventing superfluous
          condition checking. The ASF+SDF compiler does not do this yet, and
          it could mean a serious performance improvement. The cost is
          compilation time obviously, since the Java compiler is going to have
          to compile a lot more code.</para>
        </listitem>

        <listitem>
          <para>The simple control flow constructs of Rascal almost map
          one-to-one to Java</para>
        </listitem>

        <listitem>
          <para>"fail" is always in the current context/frame, so we need no
          exception implementation for fail.</para>
        </listitem>

        <listitem>
          <para>Like in Mark's compiler, list matching is to be implemented
          using nested while loops.</para>
        </listitem>

        <listitem>
          <para>"return" can be mapped to normal return statement in Java,
          except in the context of a visitor, where it should be an exception
          that is caught by the containing function of the visit, which
          immediately returns the result in the catch block that surrounds the
          call to the generated function that implements the visitor.</para>
        </listitem>

        <listitem>
          <para>Important optimizations:</para>

          <itemizedlist>
            <listitem>
              <para>Matching automaton:</para>

              <itemizedlist>
                <listitem>
                  <para>Sharing prefixes (note that we can not reorder cases
                  of a switch, or the rules?!?)</para>
                </listitem>

                <listitem>
                  <para>Common subexpression elimination</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Constant detection and propagation</para>
            </listitem>

            <listitem>
              <para>Aggressive inlining (where to stop?)</para>
            </listitem>

            <listitem>
              <para>Specialization and instantiation of visitors using
              grammars and data-type definitions</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Rascal functions with a Java body need the following:</para>

          <itemizedlist>
            <listitem>
              <para>Generate for each argument an Java argument with
              appropirtae Java type.</para>
            </listitem>

            <listitem>
              <para>For each return statement, check the type of the resulting
              value against the return type in the function header.</para>
            </listitem>

            <listitem>
              <para>Catch any exceptions raised by the Java code, convert them
              to string and rethrow as Rascal exception.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.issues">
    <title xml:id="Issues">Issues</title>

    <itemizedlist>
      <listitem>
        <para>Which comment convention will we use? <remark>Let's use Java
        style comments.</remark></para>
      </listitem>

      <listitem>
        <para>Extensibility of functions. <remark>Proposal: let's not provide
        facilities for this.</remark></para>
      </listitem>

      <listitem>
        <para>How do we identify built-in sorts (bool, int, etc) with their
        syntactic counterparts?</para>
      </listitem>

      <listitem>
        <para>In a list comprehension: do list values splice into the list
        result?</para>
      </listitem>

      <listitem>
        <para>Ditto for set comprehensions.</para>
      </listitem>

      <listitem>
        <para>Unexplored idea: add (possibly lazy) generators for all types;
        this allows to generate, for instance, all statements in a
        program.</para>
      </listitem>

      <listitem>
        <para>Shopping list of ideas in Tom:</para>

        <itemizedlist>
          <listitem>
            <para>Named patterns to avoid building a term, i.e. w@[| while
            $Exp do $stat od |].</para>
          </listitem>

          <listitem>
            <para>Anonymous variables a la Prolog: [| while $_ do $stat od
            |].</para>
          </listitem>

          <listitem>
            <para>String matching in patterns.</para>
          </listitem>

          <listitem>
            <para>Tom uses the notation %[ ... ]% for quoted strings with
            embedded @...@ constructs that are evaluated. It also has a
            backquote construct.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Shopping list of ideas from TXL:</para>

        <itemizedlist>
          <listitem>
            <para>"redefine" allows modification of an imported
            grammar.</para>
          </listitem>

          <listitem>
            <para>An "any" sort that matches anything.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Graveyard</title>

    <para>Don't read the following sections; they are leftovers from earlier
    versions of this document but may still contain material that can be
    reused.</para>
  </section>

  <section>
    <title>Mapping features to datatypes</title>

    <para><note>
        <para>This section has played a role during initial design; it is now
        outdated.</para>
      </note>Emphasized cells indicate a new datatype/feature combination that
    needs to be thought out.</para>

    <table xml:id="table.features">
      <title>Features vs datatypes</title>

      <tgroup cols="9">
        <colspec align="left" colname="col1" colnum="1" colwidth="2*" />

        <colspec align="center" colname="col2" colnum="2" colwidth="1*" />

        <colspec align="center" colname="col3" colnum="3" colwidth="1*" />

        <colspec align="center" colname="col4" colnum="4" colwidth="1*" />

        <colspec align="center" colname="col5" colnum="5" colwidth="1*" />

        <colspec align="center" colname="col6" colnum="6" colwidth="1*" />

        <colspec align="center" colname="col7" colnum="7" colwidth="1*" />

        <colspec align="center" colname="col8" colnum="8" colwidth="1*" />

        <colspec align="center" colname="col9" colnum="9" colwidth="1*" />

        <thead>
          <row>
            <entry>Which features work on which datatypes?</entry>

            <entry>CF syntax trees</entry>

            <entry>CF syntax lists</entry>

            <entry>Lexical syntax trees</entry>

            <entry>Lexical syntax lists</entry>

            <entry>Lists</entry>

            <entry>Sets</entry>

            <entry>Relations</entry>

            <entry>Tuples</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Pattern matching</entry>

            <entry>Y (CS)</entry>

            <entry>Y, CS, LM</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS, LM</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Pattern construction</entry>

            <entry>Y, CS</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS</entry>

            <entry>Y</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Generator/ Comprehension</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>LC</entry>

            <entry>SC</entry>

            <entry>SC</entry>

            <entry>N</entry>
          </row>

          <row>
            <entry>Complete Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Equations</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Polymorphism</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Serialization</entry>

            <entry>UPTR</entry>

            <entry>UPTR</entry>

            <entry>UPTR</entry>

            <entry>UPTR</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Traversal Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Subtyping</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N, except character class inclusion</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <itemizedlist>
      <listitem>
        <para>BC = Backward Compatible with ASF</para>
      </listitem>

      <listitem>
        <para>CS = Concrete Syntax</para>
      </listitem>

      <listitem>
        <para>HT= head/tail matching</para>
      </listitem>

      <listitem>
        <para>LC = List comprehension</para>
      </listitem>

      <listitem>
        <para>LM = List Matching</para>
      </listitem>

      <listitem>
        <para>N = No</para>
      </listitem>

      <listitem>
        <para>PS = Prefic Syntax</para>
      </listitem>

      <listitem>
        <para>SC = Set Comprehension</para>
      </listitem>

      <listitem>
        <para>Y = Yes</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Visitor definitions (UNDECIDED and INCOMPLETE)</title>

    <para>Visitor definitions are a new idea that borrow the programmability
    of Systems S's single level traversals and add them to Rascal. The idea is
    to be able to define the strategy annotations of visit statements and
    generators using a simple expression language. A definition takes as
    formal argument the code block of the visit statement (s), which is what
    needs to be done at every node (the visitor).</para>

    <para><programlisting>%% first recurse to the arguments, then try v, 
%% which if it fails returns the original structure.
<emphasis role="bold">visitor</emphasis> bottom-up(v) = <emphasis role="bold">all</emphasis>(bottom-up(v)) ; (v <emphasis
          role="bold">&lt;+</emphasis> <emphasis role="bold">id</emphasis>)

<emphasis role="bold">visitor</emphasis> innermost(t,v) = <emphasis
          role="bold">all</emphasis>(innermost(t,v)) ; <emphasis role="bold">repeat</emphasis>(v &lt;+ id) 
    </programlisting>We demand that all visitors are infallible, which means
    that when the v block fails, they must return a default result of the
    correct type. In most cases, this would be the identity (id).</para>

    <para>We can also try to give these definitions a more imperative look, as
    if they are patterns for generating code for the visitors, as in:</para>

    <para><programlisting><emphasis role="bold">visitor</emphasis> bottom-up(v) {
  <emphasis role="bold">all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {             %% try is the '&lt;+' of System S, 
                    %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    <emphasis role="bold">yield</emphasis> t;
  } 
}

%% innermost goes down and only returns after 
%% nothing changes anymore

<emphasis role="bold">visitor</emphasis> innermost(v) {
  <emphasis role="bold">all</emphasis> {
    innermost(v);     %% apply this to all children first.
  }
  <emphasis role="bold">while (true) {</emphasis> {    %% then until kingdom come, apply this block:
    <emphasis role="bold">try</emphasis> {
      v;              %% if v succeeds, it has a yield or a return
                      %% statement that updates the current node. 
    } <emphasis role="bold">catch fail</emphasis>(t) { %% if v fails after all, we obtain a reference
                      %% to the current node visited which we can 
                      %% return;
      <emphasis role="bold">yield</emphasis> t;
    } 
  }
}   

visitor bottom-up-dbg(v) {  <emphasis role="bold">
  all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {              %% try is the '&lt;+' of System S,
                     %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    printf("DBG: bottom-up visitor failed on: " + t);
    <emphasis role="bold">yield</emphasis> t;
  } 
}</programlisting>After such definitions, most of which would be in the
    standard library of Rascal, we can use them to program actual
    visits:</para>

    <para><programlisting>visit bottom-up (t) {
  pattern =&gt; pattern
  pattern2 : { effect; }
}</programlisting></para>
  </section>

  <section>
    <title>Outdated examples</title>

    <section>
      <title>Generating Graph files in Dot format</title>

      <para>This example illustrates the use of a comprehension on the
      right-hand side of an equation.<programlisting>module Dot-generation

imports Dot-syntax

fun Dot gen-dot(rel[ID, ID] Rel) {
    [| digraph example {
                        $([ node(Tup) | &lt;ID,ID&gt; Tup : Rel ])
                       }
    |]
}

fun DotElem* gen-node(&lt;ID Id1, ID Id2&gt;) {
    [| node $Id1; node $Id2; $Id1 -&gt; $Id2 |}}
}</programlisting></para>
    </section>
  </section>

  <section xml:id="section.integration-tscript">
    <title>Integration with Tscripts (Outdated)</title>

    <note>
      <para>It is not yet clear whether we will also include Tscript in the
      integration effort. For the time being, this section is considered
      outdated.</para>
    </note>

    <section>
      <title>Introduction</title>

      <para>It is possible to speculate on an even further integration of
      formalisms and combining the above amalgan of ASF+SDF and Rscript with
      Tscripts.</para>
    </section>

    <section>
      <title>Requirements</title>

      <itemizedlist>
        <listitem>
          <para>R12: The resulting language uses a single type system. This
          means that relational types (possible including syntactic objects)
          can be used in Tscripts.</para>
        </listitem>

        <listitem>
          <para>R13: The current "expressions" in Tscript (terms that occur at
          the rhs of an assignment) are replaced by calls to ASF+SDF or
          Rscript functions.</para>
        </listitem>

        <listitem>
          <para>R14: There is minimal duplication in functionality between
          ASF+SDF/Rscript/Tscript.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Different styles of Type Declarations</title>

      <para>We have at the moment, unfortunately, a proliferation of
      declaration styles for types.</para>

      <para>Functions are declared in ASF+SDF as:</para>

      <programlisting>typecheck(PROGRAM) -&gt; Boolean</programlisting>

      <para>Observe that only the type of the parameter is given but that it
      does not have a name.</para>

      <para>In Rscript we have:</para>

      <programlisting>int sum(set[int] SI) = ...</programlisting>

      <para>while in Tscript processes are declared as</para>

      <programlisting>process mkWave(N : int) is ...</programlisting>

      <para>For variables a similar story applies. Variables are declared in
      ASF+SDF as:</para>

      <programlisting>"X" [0-9]+    -&gt; INT</programlisting>

      <para>In Rscript we have:</para>

      <programlisting>int X

int X : S   (in comprehensions)</programlisting>

      <para>and in Tscript we have:</para>

      <programlisting>X : int</programlisting>

      <para>In order to unify these styles, we might do the following:</para>

      <itemizedlist>
        <listitem>
          <para>The type of an entity is always written before the entity
          itself.</para>
        </listitem>

        <listitem>
          <para>Formal parameters have a name.</para>
        </listitem>
      </itemizedlist>

      <para>In essence, this amounts to using the declaration style as used in
      Rscript. So we get:</para>

      <programlisting>Boolean typecheck(PROGRAM P) is ...

process mkWave(int N) is ...</programlisting>

      <para>Or do we want things like:</para>

      <programlisting>function typecheck(P : PROGRAM) -&gt; Boolean is ...

var X -&gt; int

process mkWave(int N) is ...</programlisting>

      <para>Advantages are:</para>

      <itemizedlist>
        <listitem>
          <para>The category of the entity is immediately clear (function,
          var, process, tool, ...).</para>
        </listitem>

        <listitem>
          <para>It is readable to further qualify the category, i.e.,
          traversal function, hidden var, restartable tool)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Global Flow of Control</title>

      <para>We have to settle the possible flow of control between the three
      entities ASF+SDF, Rscript and Tscript. Since Tscript imposes the notion
      of an atomic action it would be problematic to have completely
      unrestricted flow of control. Therefore it is logical to use Tscript for
      the top-level control and to limit the use of ASF+SDF and Rscript to
      computations within atomic actions. There is no reason to restrict the
      flow of control between ASF+SDF and Rscript.</para>

      <para>What are the consequences of the above choice? Let's analyze two
      cases:</para>

      <itemizedlist>
        <listitem>
          <para>Parse a file from within an ASF+SDF specification. This (and
          similar built-ins) that use the operating system are removed from
          ASF+SDF. Their effect has to be achieved at the Tscript-level which
          is the natural place for such primitives.</para>
        </listitem>

        <listitem>
          <para>Describe I/O for a defined language. Consider Pico extended
          with a read statement. Here the situation is more complicated. We
          cannot argue that the flow of control in the Pico program (as
          determined by an interpreter written in ASF+SDF) should be moved to
          the Tscript level since Tscript simply does not have the primitives
          to express this. On the other hand, we have to interrupt the flow of
          control of the Pico interpreter when we need to execute a read
          statement. The obvious way to achieve this is</para>

          <itemizedlist>
            <listitem>
              <para>At the Tscript level, a loop repeatedly calls the Pico
              interpreter until it is done.</para>
            </listitem>

            <listitem>
              <para>After each call the Pico interpreter returns with
              either:</para>

              <itemizedlist>
                <listitem>
                  <para>An indication that the eecution is complete (and
                  possibly a final state and/or final value).</para>
                </listitem>

                <listitem>
                  <para>An indication that an external action has to be
                  executed, for instance the read statement. This indication
                  should also contain the intermediate state of the
                  interpreter. When the external action has been executed, the
                  Pico interpreter can be restarted with as arguments the
                  value of the external action and the intermediate
                  state.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Experimentation will have to show whether such a framework is
      acceptable.</para>
    </section>

    <section>
      <title>Modularization</title>

      <para>Rscript and Tscript have no, respectively, very limited mechanisms
      for modularization. ASF+SDF, however, provides a module mechanism with
      imports, hiding, parameters and renaming. This mechanism was originally
      included in ASF, was taken over by SDF and is now reused in ASF+SDF.
      Currently, there are not yet sufficiently large Rscripts to feel the
      need for modules. In Tscript, there is a strong need for restricted name
      spaces and for imposing limitations on name visibility in order to limit
      the possible interactions of a process with its surroundings and to make
      it possible to create nested process definitions. What are the design
      options we have to explore?</para>

      <para>First, we can design a new module system that is more suited for
      our current requirements. The advantage is that we can create an optimal
      solution, the disadvantage is that there are high costs involved
      regarding implementation effort and migrations of existing ASF+SDF
      specifications to the new module scheme.</para>

      <para>Second, we can design an add-on to the ASF+SDF module system that
      addresses our current needs.</para>

      <para>Third, we can try to reuse the current ASF+SDF module
      system.</para>

      <para>As a general note, parameterized modules, polymorphics types and
      renamings are competing features. We should understand what we want. It
      is likely that we do not need all of them.</para>

      <para>Before delving into one of the above alternative approaches, let's
      list our requirements first.</para>

      <itemizedlist>
        <listitem>
          <para>We need grammar modules that allow the following operations:
          import, renaming, deletion (currently not supported but important to
          have a fixed base grammar on many variations on it).
          Parameterization and export/hidden: unclear.</para>
        </listitem>

        <listitem>
          <para>We need function modules (ASF+SDF and Rscript) that provide:
          import, maybe parametrization, and export/hidden.</para>
        </listitem>

        <listitem>
          <para>We need process modules (Tscript) that provide: import,
          export, hiding.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
</article>