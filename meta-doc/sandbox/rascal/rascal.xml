<?xml version="1.0" encoding="US-ASCII"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Rascal Requirements and Design Document</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Tijs</firstname><surname>van der
        Storm</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is a braindump of ideas that is slowly converging to a
    coherent design. See <xref linkend="section.issues" /> for the issues that
    have to be resolved.</para>
  </note>

  <section>
    <title>Rationale</title>

    <para>In the domain of software analysis and transformation, there exists
    a phletora of domain-specific languages for defining grammars, rewrite
    rules, software analysis and the like. So why embark on the design of yet
    another DSL in this area? We see the following arguments for this:</para>

    <itemizedlist>
      <listitem>
        <para>Many existing DSLs are based on more or less exotic concepts
        that do excite researchers but are frightening for users without an
        appropriate research background.</para>
      </listitem>

      <listitem>
        <para>The notation used in many DSLs is uninviting to say the
        least.</para>
      </listitem>

      <listitem>
        <para>The scope of DSLs is usually narrow (this is where the word
        "domain-specific" kicks in). The tasks involved in carrying out a code
        analysis or renovation project require several DSLs. Integration
        between these DSLs is insufficient.</para>
      </listitem>

      <listitem>
        <para>As designers of various DSLs (ASF+SDF, Tscript, Rscript, ...) we
        have seen the positive as well as the negative side of DSLs. We
        certainly know howto implement DSLs in this area.</para>
      </listitem>

      <listitem>
        <para>We see an opportunity for a user-friendly, conceptually
        high-level, and rich DSL for all tasks related to software analysis
        and transformation.</para>
      </listitem>
    </itemizedlist>

    <para>With this background and an essential dose of optimism, we embark on
    this trip ... .</para>
  </section>

  <section>
    <title>Introduction</title>

    <para>The goals of the envisaged language (with working name Rascal)
    are:</para>

    <itemizedlist>
      <listitem>
        <para>Providing a successor of ASF+SDF that has of all its benefits
        and fixes all of its shortcomings.</para>
      </listitem>

      <listitem>
        <para>Separating pure syntax definitions (SDF) from function
        definitions.</para>
      </listitem>

      <listitem>
        <para>Easy syntax-directed analysis of programming languages.</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction.</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning.</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation.</para>
      </listitem>

      <listitem>
        <para>Efficient and scalable implementation.</para>
      </listitem>

      <listitem>
        <para>Unsurprising concepts, syntax and semantics for a wide audience.
        Where possible we will stay close to C and Java notation.</para>
      </listitem>
    </itemizedlist>

    <para>Many of the above goals are to a certain extent already met in the
    current design of ASF+SDF, and the current design of RScript. What is
    missing is the connection (and to be honest: an efficient implementation
    of relational operators). Alas, any bridge between the two languages is
    both complex to manage and an efficiency bottleneck. This work is an
    attempt to consolidate this engineering trade-off. This basically means
    that we include most features of the RScript language into ASF+SDF.
    Although we take these languages as conceptual starting point, Rascal is a
    completely new design that has an imperative semantics at it's core rather
    than a functional semantics. As a whole, Rascal is a simpler but more
    expressive language.</para>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Old ASF+SDF programs are translatable to Rascal.</para>
        </listitem>

        <listitem>
          <para>R3: Parsing and compilation speed needs to be faster than
          ASF+SDF, comparable to the speed of the Java compiler. Parsetable
          generation is a major bottleneck in current ASF+SDF.</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability and easy parsing of a
          wide range of source languages.</para>
        </listitem>

        <listitem>
          <para>R5: (<emphasis role="bold">dropped</emphasis>) Functional (no
          side-effects), dropped due to incompatibility with R7, R6</para>
        </listitem>

        <listitem>
          <para>R6: File I/O (contradicts R5).</para>
        </listitem>

        <listitem>
          <para>R7: Easily accessible fact storage (similar to a heap, but
          remember R5 and the details of backtracking).</para>
        </listitem>

        <listitem>
          <para>R8: List matching (because of R2, influences R7, but also very
          handy for manipulating lists in concrete syntax).</para>
        </listitem>

        <listitem>
          <para>R9: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as scoping),
          allowing to factor out common code.</para>
        </listitem>

        <listitem>
          <para>R10: Syntax trees can be elements of the builtin
          data-structures (but not vice versa).</para>
        </listitem>

        <listitem>
          <para>R11: Try to keep features orthogonal: try to keep the number
          of ways to write down a program minimal, this is not a law since
          other requirements take precedence</para>
        </listitem>

        <listitem>
          <para>R12 (<emphasis role="bold">new</emphasis>): Minimize possible
          syntactic ambiguities; resolve them by type checking.</para>
        </listitem>

        <listitem>
          <para>R13 (<emphasis role="bold">new</emphasis>): Can integrate with
          Eclipse analysis and refactoring infra-structure, such as providing
          synopsis and previews of source-to-source transformations.</para>
        </listitem>

        <listitem>
          <para>R14 (<emphasis role="bold">new</emphasis>): no 'null' values,
          preventing common programming errors</para>
        </listitem>

        <listitem>
          <para>R15 (<emphasis role="bold">new</emphasis>): all values
          immutable, preventing common programming errors and allowing for
          certain kinds of optimizations</para>
        </listitem>

        <listitem>
          <para>R16 (<emphasis role="bold">new</emphasis>): should be able to
          match and construct strings using regular expressions (for making
          the simpler things simple, if you can do without a grammar, why
          not?)</para>
        </listitem>

        <listitem>
          <para>R17 (<emphasis role="bold">new</emphasis>): can get/set data
          from databases, such as the pdb from Eclipse IMP, but possibly also
          from ODBC/JDBC data sources.</para>
        </listitem>

        <listitem>
          <para>R18 (<emphasis role="bold">new</emphasis>): type safe, but
          flexible. We want a type system that prevents common programming
          errors, but still allows ample opportunity for reuse.</para>
        </listitem>

        <listitem>
          <para>R19 (<emphasis role="bold">new</emphasis>): syntax safe,
          programmers should not be allowed to construct programs that are
          syntactically incorrect w.r.t a certain context-free grammar.</para>
        </listitem>

        <listitem>
          <para>R20 (<emphasis role="bold">new</emphasis>): backtracking safe,
          programmers should not have to deal with the mind boggling feature
          interactions between side-effects and backtracking.</para>
        </listitem>

        <listitem>
          <para>R21 (<emphasis role="bold">new</emphasis>):
          traceable/debuggable, programmers should be able to easily trace
          through the execution of a Rascal program using the simplest of
          debugging tools, like printf statements, and the use of a simple
          debugging interface which allows to step through the source code and
          inspect values in a transparent fashion.</para>
        </listitem>

        <listitem>
          <para>R22 (<emphasis role="bold">new</emphasis>): minimize the use
          of type inference, such that the programmer must always declare her
          intentions by providing types for functions, data-types and
          variables. This makes debugging easier and providing clear error
          messages too. When variables are implicitly bound by pattern
          matching or related functionality, exceptions to this requirement
          might be made in favor of conciseness.</para>
        </listitem>

        <listitem>
          <para>R23 (<emphasis role="bold">new</emphasis>): allow the
          implementation of reusable modules and functions (i.e. parametric
          polymorphism and or functions as parameters).</para>
        </listitem>

        <listitem>
          <para>R24 (<emphasis role="bold">new</emphasis>): we need something
          like rewrite rules for implementing data-types that are always
          canonicalized/normalized. For some analysis algorithms this allows
          the programmer to implement domain specific optimizations over plain
          relational calculus or tree visiting that actually needed for
          scalability.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Rascal at a glance</title>

    <para>Rascal consists of the following elements:</para>

    <itemizedlist>
      <listitem>
        <para>Modules to group definitions, proving scopes and visibility
        constructs</para>
      </listitem>

      <listitem>
        <para>A type system and corresponding values, providing parameterized
        types, polymorphic functions and higher-order parameters.</para>
      </listitem>

      <listitem>
        <para>Variables to associate a name with a value in some scope.</para>
      </listitem>

      <listitem>
        <para>Parameterized functions.</para>
      </listitem>

      <listitem>
        <para>Abstract, regular expression and syntax patterns to deconstruct
        (match) values and to construct (make) them.</para>
      </listitem>

      <listitem>
        <para>Expressions provide the elementary computations on
        values.</para>
      </listitem>

      <listitem>
        <para>Statements for providing structured control flow and more
        advanced control flow in computations, such as visitors and fixed
        point computations</para>
      </listitem>
    </itemizedlist>

    <para>These elements are summarized in the following subsections.</para>

    <section>
      <title>Modules</title>

      <para>Modules are the organizational unit of Rascal. They may:</para>

      <itemizedlist>
        <listitem>
          <para>Import other modules (either Rascal modules or SDF modules)
          using <literal>import</literal>.</para>
        </listitem>

        <listitem>
          <para>Import Java modules (for the benefit of functions written in
          Java) using <literal>java-import</literal>.</para>
        </listitem>

        <listitem>
          <para>Define datatypes, subtypes, or rules and functions.</para>
        </listitem>

        <listitem>
          <para>Be parameterized with the names of formal types that are
          instantiated with an actual type when the module is imported.</para>
        </listitem>

        <listitem>
          <para>Contain a main function that is the starting point of
          execution:<programlisting>public int main(list[str] argv) { ... }</programlisting></para>
        </listitem>
      </itemizedlist>

      <para>Functions, subtypes and datatypes may be either private to a
      module or public to all modules that import the current module. Rules
      are always public and globally applied.</para>

      <para>Modules introduce a namespace and qualified names may be used to
      uniquely identify elements of a module from the outside. Inside the
      module, this qualification is implicit.</para>
    </section>

    <section>
      <title>Types and Values</title>

      <para>The type system (and notation) are mostly similar to that of
      Rscript, but</para>

      <itemizedlist>
        <listitem>
          <para>Symbols (as defined by an SDF module) are also types.</para>
        </listitem>

        <listitem>
          <para>There are built-in types (<literal>bool</literal>,
          <literal>int</literal>, <literal>str</literal>,
          <literal>loc</literal>) that have corresponding values.</para>
        </listitem>

        <listitem>
          <para>There is a single root to the type hierarchy, everything is a
          "<literal>value</literal>".</para>
        </listitem>

        <listitem>
          <para>Relations and tuples can have optional column names.</para>
        </listitem>

        <listitem>
          <para>There is subtyping (as opposed to aliasing of types in
          Rscript)</para>
        </listitem>

        <listitem>
          <para>All syntactic types are a subtype of the type
          <literal>tree</literal> that corresponds to AsFix. Up casts from a
          subtype to an enclosing type are automatic; Down casts require a
          run-time check.</para>
        </listitem>

        <listitem>
          <para>Datatype declarations may introduce new structured
          types.</para>
        </listitem>

        <listitem>
          <para>Types may include type variables like
          <literal>&amp;<replaceable>T</replaceable></literal> as in
          Rscript.</para>
        </listitem>
      </itemizedlist>

      <para>As a design strategy we try to offer the option to leave out as
      many type indications as possible.</para>

      <para>The root of the type system is the type named
      "<literal>value</literal>". It has the following subtypes:</para>

      <itemizedlist>
        <listitem>
          <para><literal>bool</literal></para>
        </listitem>

        <listitem>
          <para><literal>int</literal></para>
        </listitem>

        <listitem>
          <para><literal>str</literal></para>
        </listitem>

        <listitem>
          <para><literal>loc</literal></para>
        </listitem>

        <listitem>
          <para><literal>void</literal></para>
        </listitem>

        <listitem>
          <para>lists, sets, tuples, maps (single valued binary brelations)
          and relations of values.</para>
        </listitem>

        <listitem>
          <para>all structures defined with a datatype definition. One of the
          subtypes is called "<literal>tree</literal>".</para>

          <itemizedlist>
            <listitem>
              <para>Type <literal>tree</literal> is the type that corresponds
              with concrete syntax trees (AsFix in the case of the
              Meta-Environment). Type <literal>tree</literal> has as subtype
              all types that are derived from SDF definitions, i.e., all
              notions that are defined using a grammar.</para>
            </listitem>

            <listitem>
              <para>The type <literal>tree</literal> is "special" in the
              following sense:</para>

              <itemizedlist>
                <listitem>
                  <para>Parsers generate values of type
                  <literal>tree</literal>.</para>
                </listitem>

                <listitem>
                  <para>Although the type <literal>tree</literal> can be
                  defined in Rascal, its definition is built-in in order to
                  preserve the consistency with the parser.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Annotations</title>

      <para>Annotations may be associated with any value and are represented
      by a mapping of type <literal>map[str,value]</literal>, i.e., annotation
      names are strings and annotation values are arbitrary values of type
      <literal>value</literal>. The following library functions handle
      annotations:<programlisting>%% Test whether a named annotation exists.
public bool has-annotation(&amp;T Subject);

%% Get the value of a named annotation
%% Note: get-annotation throws an exception when the named 
%% annotation does not exist.
public value get-annotation(&amp;T Subject, str Name);

%% Get all annotations
public map[str,value] get-annotations(&amp;T Subject);

%% Set the value of a named annotation
public &amp;T set-annotation(&amp;T Subject, str Name, value AValue);

%% Set all annotations
public &amp;T set-annotations(&amp;T Subject, map[str, value] Annos);</programlisting></para>
    </section>

    <section>
      <title>Variables</title>

      <para>Variables are names that have an associated scope and in that
      scope they have a value. A variable declaration consists of a type
      followed by the variable name and---depending on the syntactic
      position---they are followed by an initialization. There are no null
      values, which implies that all variables must be initialized at
      declaration time. Also, this implies that all expressions must return a
      value. Especially for functions, this means that all execution paths of
      a function must have a return statement.</para>

      <para>Variables may be introduced at the following syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para>As formal parameters of a function. Their scope is the
          function and they get their initial value when the function is
          called.</para>
        </listitem>

        <listitem>
          <para>Local variables in a function body are declared and
          initialized. Their scope is the function body.</para>
        </listitem>

        <listitem>
          <para>Variables in patterns. For patterns in match positions,
          variables are initialized during the match and their scope is the
          rule in which they occur. For patterns in make positions, the values
          of variables are taken from the local scope.</para>
        </listitem>

        <listitem>
          <para>For variables ntroduced by pattern matching in conditional
          statements (if-then, and while), if the condition succeeds, the
          scope of the variables are the block of code that is executed
          conditionally.</para>
        </listitem>

        <listitem>
          <para>Variables in anti-patterns are never visible, but nevertheless
          their names are reserved in the scope that they would have had when
          the pattern was a normal positive matching pattern.</para>
        </listitem>

        <listitem>
          <para>Variables that are introduced by generators in comprehensions
          or for statement, have the comprehension, respectively, for
          statement as scope.</para>
        </listitem>

        <listitem>
          <para>Global variables are declared and ALWAYS initialized
          (<emphasis role="bold">new</emphasis>) at the top level of each
          module. Functions that use a global variable have to be explicitly
          declare it as well. The value of a global variable can be used and
          replaced by all functions that have locally declared it.</para>
        </listitem>
      </itemizedlist>

      <para>We will see below that there are certain contexts in which
      assignments to variables are undone in the case of failure.</para>
    </section>

    <section>
      <title>Functions</title>

      <para>A function declaration consists of a visibility declaration, the
      keyword <literal>fun</literal>, result type, a function name, typed
      arguments and a function body. Functions without a result type have type
      <literal>void</literal>.</para>

      <para>A visibility declaration is one of the keywords
      <literal>public</literal> or <literal>private</literal>
      (default).</para>

      <para>A function body is a list of statements, optionally separated by
      semi-colons. Each unique control flow path through a function must have
      a return statement, such that each function always returns a proper
      value.</para>

      <para>Functions can raise exceptions but these are not declared as part
      of the function signature.</para>

      <para>Functions can later be extended [STILL UNDER DISCUSSION]</para>

      <itemizedlist>
        <listitem>
          <para>The keyword <literal>extend</literal> before a function
          declaration extends a previously defined function with the same
          signature.</para>
        </listitem>

        <listitem>
          <para>Local declarations in the extension function are added to the
          original function.</para>
        </listitem>

        <listitem>
          <para>If both bodies consist of a <literal>switch</literal> or
          <literal>visit</literal> construct, the cases are merged.</para>
        </listitem>

        <listitem>
          <para>Other cases may be considered: switch + expr, expr + switch,
          visit + expr, and expr + visit.</para>
        </listitem>

        <listitem>
          <para>No other extensions are allowed.</para>
        </listitem>
      </itemizedlist>

      <para>Functions preceeded by the keyword "<literal>java</literal>" have
      a body written in Java. They have the following properties:</para>

      <itemizedlist>
        <listitem>
          <para>Arguments and result are pure Rascal values.</para>
        </listitem>

        <listitem>
          <para>Inside the body variables may be declared both with a Java
          Type or with a Rascal type. The latter will be converted by the
          Rascal compiler to appropriate implementation types.</para>
        </listitem>

        <listitem>
          <para>Java functions cannot acces the global state of the Rascal
          program.</para>
        </listitem>

        <listitem>
          <para>Side effects cause by Java functions in the Java state, are
          not undone in the case of backtracking.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Patterns</title>

      <para>We distinguish three kinds of patterns:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Abstract</emphasis> patterns: prefix dataterms that
          are generated by a signature.</para>
        </listitem>

        <listitem>
          <para><emphasis>Regular expression</emphasis> patterns: conventional
          regular expressions</para>
        </listitem>

        <listitem>
          <para><emphasis>Syntax</emphasis> patterns: textual fragments that
          are generated by a context-free grammar.</para>
        </listitem>
      </itemizedlist>

      <para>Patterns may contain variables and can occur in two syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Match</emphasis> positions where the patterns is
          matched against another term and the variables in the pattern are
          bound when the match is successfull. Examples of match positions
          are:</para>

          <itemizedlist>
            <listitem>
              <para>After a <literal>case</literal> keyword in
              <literal>switch</literal> or <literal>visit</literal>
              statement.</para>
            </listitem>

            <listitem>
              <para>In a generator, where generated values are matched against
              the pattern.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis>Make</emphasis> positions where the pattern is used
          to construct a new term (after replacing any variables in the
          pattern by their values. Examples of make positions are:</para>

          <itemizedlist>
            <listitem>
              <para>If the pattern is preceeded by the keyword
              <literal>make</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <section>
        <title>Abstract Patterns</title>

        <para>Datatype declarations introduce a signature of abstract
        terms.These terms (possibly including typed variables as introduced
        for concrete patterns) may be used as abstract patterns at the same
        position where concrete patterns are allowed. Subtype declarations
        define an inclusion relation between types.</para>
      </section>

      <section>
        <title>Regular Expression Patterns</title>

        <para>Regular expression patterns are ordinary regular expressions
        that are used to match a string value and to decompose it in parts and
        also to compose new strings. In a match position, a regular expression
        is followed by a newly declared variable (always of type
        <literal>list[str]</literal>) that contains the matches obtained by
        the regular expression.</para>
      </section>

      <section xml:id="section.patterns">
        <title>Syntax Patterns</title>

        <para>There is a notation of a <emphasis>syntax pattern</emphasis>: a
        (possibly quoted) concrete syntax fragment that may contain variables.
        We want to cover the whole spectrum from maximally quoted patterns
        that can unambiguously describe <emphasis role="bold">any</emphasis>
        syntax fragment to minimally quoted patterns as we are used to in
        ASF+SDF. Therefore we support the following mechanisms:</para>

        <itemizedlist>
          <listitem>
            <para>Optionally typed variables, written as
            <literal>&lt;<replaceable>TYPE</replaceable>
            <replaceable>NAME</replaceable>&gt;</literal> or
            <literal>&lt;<replaceable>NAME</replaceable>&gt;</literal>.</para>
          </listitem>

          <listitem>
            <para>Quoted patterns enclosed between <literal>[|</literal> and
            <literal>|]</literal>. Inside a fully quoted string, the
            characters <literal>&lt;</literal>, <literal>&gt;</literal> and
            <literal>|</literal> can be escaped as <literal>\&lt;</literal>,
            <literal>\&gt;</literal>, <literal>\|</literal>. Fully quoted
            patterns may contain variables.</para>
          </listitem>

          <listitem>
            <para>Unquoted patterns are an (unquoted) syntax fragment that may
            contain variables.</para>
          </listitem>
        </itemizedlist>

        <para>Quoted and unquoted patterns form the
        <emphasis>patterns</emphasis> that are supported in Rascal.</para>

        <para>Examples are:</para>

        <itemizedlist>
          <listitem>
            <para>Quoted pattern with typed variables:<programlisting>[| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Quoted pattern with untyped variables:<programlisting>[| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted pattern with typed variables:<programlisting>while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted pattern with untyped variables:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>
          </listitem>
        </itemizedlist>

        <para>Obviously, with less quoting and type information, the
        probability of ambiguities increases. Our assumption is that a type
        checker can resolve them.</para>

        <para>Implementation hint. For every sort S in the syntax definition
        add the following rules:</para>

        <programlisting><replaceable>S</replaceable>                     -&gt; Pattern
"&lt;<replaceable>" "S</replaceable>"? Variable "&gt;" -&gt; <replaceable>S</replaceable>      </programlisting>
      </section>
    </section>

    <section>
      <title>Expressions</title>

      <para>Expressions correspond roughly to Rscript expressions with some
      extensions:<itemizedlist>
          <listitem>
            <para>There are lists, sets and relations together with
            comprehensions for these types.</para>
          </listitem>

          <listitem>
            <para>Generators in comprehensions may range over syntax
            trees.</para>
          </listitem>

          <listitem>
            <para>Generators may have a strategy option to indicate:</para>

            <itemizedlist>
              <listitem>
                <para><literal>top-down</literal></para>
              </listitem>

              <listitem>
                <para><literal>top-down-break</literal></para>
              </listitem>

              <listitem>
                <para><literal>bottom-up</literal> (this is the
                default)</para>
              </listitem>

              <listitem>
                <para><literal>bottom-up-break</literal></para>
              </listitem>
            </itemizedlist>

            <para>The two other strategy option (<literal>innermost</literal>
            and <literal>outermost</literal>) are only meaningfull in the
            context of a <literal>visit</literal> statement.</para>
          </listitem>

          <listitem>
            <para>The complete repertoire of operators in Rscript is available
            but we have applied some rationalization:</para>

            <itemizedlist>
              <listitem>
                <para>+ is now used for addition, union and concatenation (the
                operator <literal>union</literal> is gone).</para>
              </listitem>

              <listitem>
                <para>- is now used for substraction, difference (the operator
                <literal>\</literal> is gone)</para>
              </listitem>

              <listitem>
                <para>* is now used for multiplication and intersection (the
                operator <literal>inter</literal> is gone).</para>
              </listitem>

              <listitem>
                <para>There are new assignment operators +=, -=, *=.</para>
              </listitem>

              <listitem>
                <para>For a binary relation <replaceable>R</replaceable> that
                is a map (i.e. it associates a single value with each domain
                element)
                <replaceable>R</replaceable>(<replaceable>N</replaceable>),
                returns the single image value corresponding with
                <replaceable>N</replaceable>. This expression may also occur
                as left-hand side of an assignment:<programlisting><replaceable>R</replaceable>(<replaceable>N</replaceable>) = <replaceable>V</replaceable></programlisting>first
                removes from <replaceable>R</replaceable> the tuple with
                domain value <replaceable>N</replaceable> and then adds the
                tuple &lt;<replaceable>N</replaceable>,
                <replaceable>V</replaceable>&gt;. The net effect is that a new
                map value is assigned to <replaceable>R</replaceable>.</para>
              </listitem>

              <listitem>
                <para>For an arbitrary binary relation,
                <replaceable>R</replaceable>{<replaceable>N</replaceable>}
                returns a set of corresponding image elements. This expression
                may also occur as left-hand side of an
                assignment:<programlisting><replaceable>R</replaceable>{<replaceable>N</replaceable>} = <replaceable>V</replaceable></programlisting>first
                removes all tuples with domain value
                <replaceable>N</replaceable> and then adds the tuple
                &lt;<replaceable>N</replaceable>,
                <replaceable>V</replaceable>&gt;. When the right-hand side is
                a set, new tuples are added for each element in the
                set:</para>

                <programlisting><replaceable>R</replaceable>{<replaceable>N</replaceable>} = {<replaceable>V1</replaceable>, ..., <replaceable>Vn</replaceable>}</programlisting>

                <para>first removes all tuples with domain value
                <replaceable>N</replaceable> and then adds the tuples
                &lt;<replaceable>N</replaceable>,
                <replaceable>V1</replaceable>&gt;, ...,
                &lt;<replaceable>N</replaceable>,
                <replaceable>Vn</replaceable>&gt;.<note>
                    <para>Consider to replace the above by standard array
                    notation.</para>
                  </note></para>
              </listitem>

              <listitem>
                <para>The Rscript image notation R[n] and R[-,n] are
                discontinued.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Statements</title>

      <para>Rascal has the following statement types, which can be nested and
      composed in the usual structured manner:</para>

      <itemizedlist>
        <listitem>
          <para>Variable declaration with initialization.</para>
        </listitem>

        <listitem>
          <para>An assignment statement assigns a value to a variable.</para>
        </listitem>

        <listitem>
          <para>If-then statement and if-then-else statement.</para>
        </listitem>

        <listitem>
          <para>A <literal>return</literal> statement returns a value from a
          function, or just returns (for functions with result type void).
          Note that return jumps out of an entire function, even if it is
          nested in a complicated control flow statement such as visit.</para>
        </listitem>

        <listitem>
          <para>A <literal>yield</literal> statement that delivers a
          replacement value during a traversal initiated by a visit statement,
          or a switch statement.</para>
        </listitem>

        <listitem>
          <para>A <literal>fail</literal> statement which jumps to the deepest
          nested choice point (i.e. a switch or a visit) and tries the next
          option available. Fail is the dual of return/yield.</para>
        </listitem>

        <listitem>
          <para>A throw statement can raise an exception.</para>
        </listitem>

        <listitem>
          <para>A <literal>switch</literal> statement is similar to a switch
          statement in C or Java and for a given subject term, it corresponds
          to the matching provided by the left-hand sides of a set of rewrite
          rules. However, it provides <emphasis role="bold">only</emphasis>
          matching at the top level of the subject term and does not traverse
          it. The type of each pattern must be identical to the type of the
          subject term (or be a subtype of it). It is an error if no case
          matches.</para>
        </listitem>

        <listitem>
          <para>A rewrite rule (not a top-level statement, but a child of
          switch and visit) consists of a Pattern followed by : and a
          statement that returns the replacement value:<programlisting>case <replaceable>Pattern</replaceable> : <replaceable>Statement</replaceable></programlisting></para>

          <para>A statement may consist of declarations and statements and is
          implicitly extended with a <literal>fail</literal> statement. The
          statement must therefore yield or return a value or the case as a
          whole will fail. To maintain some resemblance with rewrite rules, we
          also support the form</para>

          <programlisting>case <replaceable>Pattern</replaceable> =&gt; <replaceable>Replacement</replaceable></programlisting>

          <para>which is an abbreviation for<programlisting>case <replaceable>Pattern</replaceable> : yield <replaceable>Replacement</replaceable></programlisting></para>
        </listitem>

        <listitem>
          <para>A <literal>visit</literal> statement corresponds to a
          traversal function from ASF+SDF. Given a subject term and a list of
          rewrite rules it traverses the term. Depending on the precise rules
          it may perform replacement (mimicking a transformer), update local
          variables (mimicking an accumulator) or a combination of these two.
          The visit statement may contain the same strategy options as a
          generator and also:</para>

          <itemizedlist>
            <listitem>
              <para><literal>innermost</literal> = compute a fixed-point:
              repeat a bottom-up traversal as long as the traversal function
              changes values.</para>
            </listitem>

            <listitem>
              <para><literal>outermost</literal> = compute a fixed-point:
              repeat a traversal traversal as long as the traversal function
              changes values.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>A <literal>for</literal> statement to repeat a block of
          code.</para>
        </listitem>

        <listitem>
          <para>A <literal>solve</literal> statement to solve a set of linear
          equations.</para>
        </listitem>

        <listitem>
          <para>A <literal>try</literal> statement can be used to execute a
          statement and to catch any exeception raised by that
          statement.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Visitor definitions (UNDECIDED and INCOMPLETE)</title>

      <para>Visitor definitions are a new idea that borrow the programmability
      of Systems S's single level traversals and add them to Rascal. The idea
      is to be able to define the strategy annotations of visit statements and
      generators using a simple expression language. A definition takes as
      formal argument the code block of the visit statement (s), which is what
      needs to be done at every node (the visitor).</para>

      <para><programlisting>%% first recurse to the arguments, then try v, 
%% which if it fails returns the original structure.
<emphasis role="bold">visitor</emphasis> bottom-up(v) = <emphasis role="bold">all</emphasis>(bottom-up(v)) ; (v <emphasis
            role="bold">&lt;+</emphasis> <emphasis role="bold">id</emphasis>)

<emphasis role="bold">visitor</emphasis> innermost(t,v) = <emphasis
            role="bold">all</emphasis>(innermost(t,v)) ; <emphasis role="bold">repeat</emphasis>(v &lt;+ id) 
    </programlisting>We demand that all visitors are infallible, which means
      that when the v block fails, they must return a default result of the
      correct type. In most cases, this would be the identity (id).</para>

      <para>We can also try to give these definitions a more imperative look,
      as if they are patterns for generating code for the visitors, as
      in:</para>

      <para><programlisting><emphasis role="bold">visitor</emphasis> bottom-up(v) {
  <emphasis role="bold">all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {             %% try is the '&lt;+' of System S, 
                    %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    <emphasis role="bold">yield</emphasis> t;
  } 
}

%% innermost goes down and only returns after 
%% nothing changes anymore

<emphasis role="bold">visitor</emphasis> innermost(v) {
  <emphasis role="bold">all</emphasis> {
    innermost(v);     %% apply this to all children first.
  }
  <emphasis role="bold">while (true) {</emphasis> {    %% then until kingdom come, apply this block:
    <emphasis role="bold">try</emphasis> {
      v;              %% if v succeeds, it has a yield or a return
                      %% statement that updates the current node. 
    } <emphasis role="bold">catch fail</emphasis>(t) { %% if v fails after all, we obtain a reference
                      %% to the current node visited which we can 
                      %% return;
      <emphasis role="bold">yield</emphasis> t;
    } 
  }
}   

visitor bottom-up-dbg(v) {  <emphasis role="bold">
  all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {              %% try is the '&lt;+' of System S,
                     %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    printf("DBG: bottom-up visitor failed on: " + t);
    <emphasis role="bold">yield</emphasis> t;
  } 
}</programlisting>After such definitions, most of which would be in the
      standard library of Rascal, we can use them to program actual
      visits:</para>

      <para><programlisting>visit bottom-up (t) {
  pattern =&gt; pattern
  pattern2 : { effect; }
}</programlisting></para>
    </section>

    <section>
      <title>Failure and side-effects</title>

      <para>There are two contexts in which side-effects, i.e., assignment to
      variables, have to be undone in case of failure. These contexts are a
      rewrite rule in a switch or visit statement. If the pattern on the
      left-handside of the rule matches there are various
      possibilities:</para>

      <itemizedlist>
        <listitem>
          <para>All control flow path through the right-hand side of the rule
          end in a return statement. In this case, the rule can not fail and
          all side-effects caused by the execution of the right-hand side are
          committed.</para>
        </listitem>

        <listitem>
          <para>One or more control path can fail. This can be caused by an
          explicit fail statement or an if-then statement with missing
          else-branch. In the case of failure all side-effects are
          undone.<note>
              <para>Will we undo all side-effects or only the side-effects on
              global variables?</para>
            </note></para>
        </listitem>

        <listitem>
          <para>If a rule fails there are two possibilities:</para>

          <itemizedlist>
            <listitem>
              <para>the left-hand side contains a list pattern that has more
              matching options; the next option is tried.</para>
            </listitem>

            <listitem>
              <para>the left-hand side contains a list patterns that has no
              more matching options or it contains no list pattern at all; the
              next rule is tried.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>Here we list experimental examples of Rascal code to try out
    features.</para>

    <section>
      <title>Booleans</title>

      <para>It seems that every language specification effort has to produce a
      specification of the Booleans at some moment, so let's try it now. We
      try the following versions:</para>

      <itemizedlist>
        <listitem>
          <para>A version using visit, see <xref
          linkend="section.booleans-with-visit" />.</para>
        </listitem>

        <listitem>
          <para>A version using an implicit reduction function</para>
        </listitem>
      </itemizedlist>

      <para>We use the following common syntax:<programlisting>module Booleans-syntax
exports 
  sorts Bool

  context-free syntax
    "true"        -&gt; Bool
    "false"       -&gt; Bool
    Bool "&amp;" Bool -&gt; Bool {left}
    Bool "|" Bool -&gt; Bool {right}</programlisting></para>

      <section xml:id="section.booleans-with-visit">
        <title>Booleans using visit</title>

        <para>A simple solution exists using the visit construct that we have
        encountered in the above examples.<programlisting>module Bool-examples1

imports Booleans-syntax;

fun Bool reduce(Bool B) {
    visit bottom-up B {
      case true &amp; &lt;Bool B2&gt;   =&gt; B2
      case false &amp; &lt;Bool B2&gt;  =&gt; false

      case true | &lt;Bool B2&gt;   =&gt; true
      case false | &lt;Bool B2&gt;  =&gt; B2
    }
}</programlisting></para>

        <para>Observe that there are two styles:</para>

        <itemizedlist>
          <listitem>
            <para>Using variables on the left-hand side: the visit is needed
            to fully normalize the result.</para>
          </listitem>

          <listitem>
            <para>A truth table: this is sufficient as is.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Abstract Booleans</title>

        <para>In the above example we used concrete syntax for Booleans
        expressions. It also possible to define Booleans as abstract
        terms.<programlisting>module Bool-abstract

data Bool btrue;
data Bool bfalse;
data Bool band(Bool, Bool);
data Bool bor(Bool, Bool); 

fun Bool reduce(Bool B) {
    visit bottom-up B {
      case band(btrue, &lt;Bool B2&gt;)   =&gt; B2  %% Style 1: Use Variables
      case band(bfalse, &lt;Bool B2&gt;)  =&gt; bfalse

      case bor(btrue, btrue)        =&gt; btrue %% Style 2: Use a truth table
      case bor(btrue, bfalse)       =&gt; btrue
      case bor(bfalse, btrue)       =&gt; btrue
      case bor(bfalse, bfalse)      =&gt; bfalse
    }
}</programlisting></para>

        <para>First, type declarations are used to define the abstract syntax
        of the type Bool. Next, a similar reduce function is defined as
        before, but now we use abstract patterns.</para>
      </section>

      <section>
        <title>Booleans with implicit reduce (NOT YET DECIDED)</title>

        <para>In ASF, values are always reduced to a normal form before they
        are created. For some applications this normalization or
        canonicalization feature is very handy. We introduce the following
        syntax, which can also help in the transformation of old ASF+SDF
        programs to Rascal:</para>

        <para><programlisting>rules (Bool) {
  and(true, &lt;Bool B2&gt;) =&gt; B2
  and(false, Bool) =&gt; false
}
%% or
rules (Bool) { 
  and(true, &lt;Bool B2&gt;) : { yield B2 }
  and(false, Bool) : { yield false }
}</programlisting>These rules are applied on every Bool that is constructed.
        Like in ASF+SDF it is the responsibility of the programmer to make
        sure the rules are confluent and terminating. The body of a rules
        definition has the same syntax and semantics as the switch construct,
        allowing backtracking, side-effects and checking of conditions.</para>

        <para>There are some issues here:</para>

        <itemizedlist>
          <listitem>
            <para>It should be dissallowed to have private rules on public
            constructors; normalization is a global effect on public
            data-structures. On the other hand, constructors that are local to
            a module may have some private rules applied to them; but public
            rules on private constructors are dissallowed too.</para>
          </listitem>

          <listitem>
            <para>We previously had other ideas about this feature. We
            introduced a reduce keyword that would call a certain named
            function at the construction of every Bool. The problem with that
            feature is that the operational semantics (in the eyes of the
            Rascal programmer) really looks like first some term is to be
            created, and then a function will be applied to normalize it. In
            reality though, we want to normalize the terms in an innermost
            fashion, and at construction time, so that the terms on the
            left-hand side of the rules are never actually created or
            allocated.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Abstract Graph datatype</title>

      <para>In the Meta-Environment we use an abstract data type to exchange
      data representing graphs. It can be defined as follows.<programlisting>module Graph

data Graph graph(NodeList nodes, EdgeList edges, AttributeList attributes);

type list[Node] Nodelist;

data Node node(NodeId id, AttributeList attributes);
data Node subgraph(NodeId id, NodeList nodes, EdgeList edges, AttributeList attributes);

data NodeId id(term id);

type list[Attribute] AttributeList;

data Attribute bounding-box(Point first, Point second);
data Attribute color(Color color);
data Attribute curve-points(Polygon points);
data Attribute direction(Direction direction);
data Attribute fill-color(Color color);
data Attribute info(str key, term value);
data Attribute label(str label);
data Attribute tooltip(str tooltip);
data Attribute location(int x, int y);
data Attribute shape(Shape shape);
data Attribute size(int width, int height);
data Attribute style(Style style);
data Attribute level(str level);
data Attribute file(File file);
data Attribute file(term file);

data Color rgb(int red, int green, int blue);

data Style bold | dashed | dotted | filled | invisible | solid;

data Shape box | circle | diamond | egg | elipse | hexagon | house | 
           octagon | parallelogram | plaintext | trapezium | triangle;

data Direction forward | back | both | none;

type list[Edge] Edgelist;

data Edge edge(NodeId from, NodeId to, AttributeList attributes);

type list[Point] Polygon;

data Point point(int x, int y);</programlisting></para>
    </section>

    <section>
      <title>Tree traversal</title>

      <para>Here is the binary tree example that we use in explaining
      traversal functions in ASF+SDF.<programlisting>module BTree-syntax
imports basic/Integers

exports 
  sorts BTREE
  context-free syntax
    Integer         -&gt; BTREE
    f(BTREE,BTREE)  -&gt; BTREE
    g(BTREE,BTREE)  -&gt; BTREE
    h(BTREE,BTREE)  -&gt; BTREE
    i(BTREE,BTREE)  -&gt; BTREE</programlisting><programlisting>module BTree-Examples
imports BTree-syntax; 

%% Ex1: Count leaves in a BTREE
%% Idea: int N : T generates alle Integer leaves in the tree
%% # is the built-in length-of operator

fun int cnt(BTREE T) {
    return #{N | int N : T}
}

%% Ex1: an equivalent,  more purist, version of the same function:
fun int cnt(BTREE T) {
    return #{N | &lt;Integer N&gt; : T}
}

%% Ex1: alternative solution using trafo functions:

fun int cnt(BTREE T) {
    int C = 0;
    visit T {
      case &lt;Integer N&gt; : C = C+1
    };
    return C;
}

%% Ex2: Sum all leaves in a BTREE
%% NB sum is a built-in that adds all elements in a set or list.
%% Here we see immediately the need to identify
%% - the built-in sort "int"
%% - the syntactic sort "Integer"

fun int sumtree(BTREE T) {
    return sum({N | int N : T});
}

%% Ex2: using accumulator

fun int cnt(BTREE T) {
    int C = 0;
    visit T {
      case &lt;Integer N&gt; : C = C+N
    };
    return C;
}

%% Ex3: Increment all leaves in a BTREE
%% Idea: using the construct "visit T { ... }" visit all leaves in
%% thetree T that match an integer and replace each N in T by N+1.
%% The expression as a whole returns the modified term.
%% Note that two conversions are needed here:
%% - from int to NAT to match subterms
%% - from int to NAT to convert the result of addition into 
%%   a NAT tree

fun BTREE inc(BTREE T) {
    visit T {
      case &lt;Integer N&gt;: yield (N + 1)
    };
}

%% Ex4: full replacement of g by i
%% The whole repertoire of traversal functions is available:
%% - visit bottom-up T { ... }
%% - visit bottom-up-break  T { ... }
%% - etc.
%% A nice touch is that these properties are not tied to the
%% declaration of a travesal function (as in ASF+SDF) but to 
%% its use.

fun BTREE frepl(BTREE T) {
    visit bottom-up T {
      case g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) =&gt;
           make i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    };
}

%% Ex5: Deep replacement of g by i

fun BTREE frepl(BTREE T) {
    visit bottom-up-break T {
      case g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) =&gt;
           make i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    };
}

%% Ex6: shallow replacement of g by i (i.e. only outermost 
%% g's are replaced); 

fun BTREE srepl(BTREE T) {
    visit top-down-break T {
      case g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) =&gt; 
           make i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    };
}

%% Ex7: We can also add the first/td directives to all generators 
%% (where "all td" would be the default):

fun set[BTREE] find-outer-gs(BTREE T) {
    return
    { S | STATEMENT S : top-down-break T, 
          g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) := S };
}
 
%% Ex8: accumulating transformer that increments leaves with 
%% amount D and counts them
fun tuple[int, BTREE] count-and-inc(BTREE T, int C, int D) {
    int C = 0;
    
    visit T {
      case &lt;Integer N&gt;: { C = C + 1; yield N+D }
     };
     return &lt;C, T&gt;;
}
</programlisting></para>
    </section>

    <section>
      <title>Substitution in Lambda</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.</para>

      <programlisting>module examples/Lambda/Lambda-syntax

exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+               -&gt; Var
context-free syntax
     "prime" "(" Var ")"  -&gt; Var  %% generate unique name
     Var                  -&gt; Exp  %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp  %% function abstraction
     Exp Exp              -&gt; Exp  %% function application
</programlisting>

      <para>Examples:</para>

      <para><programlisting>module Lambda-Examples
imports Lambda-syntax;

fun set[Var] allVars(Exp E) {
    return {V | Var V : E}
}

fun set[Var] boundVars(Exp E) {
    return {V | fn &lt;Var V&gt; =&gt; &lt;Exp E1&gt; : E};
} 

fun set[Var] freeVars(Exp E) {
    return allVars(E) - boundVars(E);
}

%% Generate a fresh variable if V does not occur in 
%% given set of variables.

fun Var fresh(Var V, set[Var] S) {
    if (V in S){ return prime(V); } else {return V;};
}

%% Substitution: replace all occurrences of V in E2 by E1

fun Exp subst(Var V1, Exp E1, Exp E2) {

    switch E2 {
      case &lt;Var V2&gt;: if(V1 != V2){ yield V2; }

      case &lt;Var V2&gt;: if(V1 == V2){ yield E1; }

      case &lt;Exp Ea&gt; &lt;Exp Eb&gt;: {
        Exp EaS = subst(V, E, Ea);
        Exp EbS = subst(V, E, Eb);
        return make &lt;Exp EaS&gt; &lt;Exp EbS&gt;;
      } 

      case fn &lt;Var V2&gt; =&gt; &lt;Var Ea&gt;:
        if (V1 == V2) { yield make fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt; }

      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;:
        if(V1 != V2 and not(V1 in freeVars(E2) and 
           V2 in freeVars(E1))){
           Exp E1S = subst(V1, E1, Ea);
           yield make fn &lt;Var V2&gt; =&gt; &lt;Exp E1S&gt;;
        }              
 
      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;: 
        if(V1 != V2 and V1 in freeVars(Ea) and 
           V2 in freeVars(E1)){
           Var V3 = fresh(V2, freeVars(Ea) + freeVars(E1));
           Exp EaS = subst(V1, E1, subst(V2, V3, E2));
           yield make fn &lt;Var V3&gt; =&gt; &lt;Exp EaS&gt;;
        }
    };
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let</title>

      <para><programlisting>module Let-syntax
exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+                           -&gt; Var
context-free syntax
     Var                              -&gt; Exp
     "let" Var "=" Exp "in" Exp "end" -&gt; Exp </programlisting>Examples:<programlisting>module Let-Example
imports Let;

%% Rename all bound variables in an Exp
%% Version 1: purely functional
%% Exp: given expression to be renamed
%% rel[Var,Var]: renaming table
%% Int: counter to generate global variables

fun Exp rename(Exp E, rel[Var,Var] Rn, Int Cnt) {
    switch E {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end: {
         Var Y = "x" + Cnt;  %% this + operator concatenates 
                             %% (after converting the int to str)
         int Cnt1 = Cnt + 1;
         Exp E1R = rename(E1, Rn, Cnt);
         Exp E2R = rename(E2, {&lt;V, Y&gt;} + Rn, Cnt1);
         return make let &lt;Var Y &gt;= &lt;Exp E1R&gt;
                     in 
                        &lt;Exp E2R&gt;
                     end;
          }

    case &lt;Var V&gt;: return Rn[V]

    default: return E
    };
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let using globals</title>

      <para>Here is the same renaming function now using two global
      variables.<programlisting>module Let-Example
imports Let;

%% Rename all bound variables in an Exp
%% Version 2: using global variables
%% Cnt: global counter to generate fresh variables
%% rel[Var,Var]: global renaming table

global int Cnt = 0;
global rel[Var,Var] Rn = {};

fun Var newVar() {
    global int Cnt;  
    Cnt = Cnt + 1;
    return "x" + Cnt
}

fun Exp rename(Exp E) {
    global int Cnt;
    global rel[Var,Var] Rn;
    switch E {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end: {
         Var Y = newVar();
         Rn = {&lt;V, Y&gt;} + Rn;
         Exp E1R = rename(E1);
         Exp E2R = rename(E2);
         return make let &lt;Var Y &gt;= &lt;Exp E1R&gt;
                     in 
                        &lt;Exp E2R&gt;
                     end;
          }

    case &lt;Var V&gt;: return Rn(V)

    default: return E
    };
}</programlisting></para>
    </section>

    <section>
      <title>Concise Pico Typechecker</title>

      <para>The following example shows the tight integration ASF with
      comprehensions.<programlisting>module Typecheck

imports Pico-syntax;
imports Errors;

subtype Env rel[PICO-ID,TYPE];

fun list[Error] tcp(PROGRAM P) {
    switch P {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
           Env Env = {&lt;Id, Type&gt; | 
                      [| &lt;PICO-ID Id&gt; : &lt;TYPE Type&gt; |] : Decls};
           return [ tcst(S, Env) | Stat S : Series ] 
      }
    };
}

fun list[Error] tcst(Stat Stat, Env Env) {
    switch Stat {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt;|]: {
        TYPE Type = Env(Id);
        return type-of(Exp, Type, Env);
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:
        return type-of(Exp, natural, Env) + 
               tcs(Stats1, Env) + tcs(Stats2, Env)

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od: 
        yield type-of(Exp, natural, Env) + tcs(Stats, Env)
    };
}

fun list[Error] type-of(Exp E, TYPE Type, Env Env) {
    switch E {
      case &lt;NatCon N&gt;: if(Type == natural){ return []; }

      case &lt;StrCon S&gt;: if(Type == string) { return []; }

      case &lt;PICO-ID Id&gt;: {
         TYPE Type2 = Env(Id);
         if(Type2 == Type) { return []; }
      }

      case &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type-of(E1, natural, Env) + 
                  type-of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type-of(E1, natural, Env) + 
                  type-of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; || &lt;EXP E2&gt;: 
        if(Type == string){
          return type-of(E1, string, Env) + 
                 type-of(E1, string, Env)
        }
    
      default: return [error("Incorrect type")]
    };
}</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator</title>

      <para><programlisting>module Pico-eval
imports pico/syntax/Pico;

subtype PICO-VALUE int;
subtype PICO-VALUE str;

subtype VEnv rel[PICO-ID, PICO-VALUE];

fun VEnv evalProgram(PROGRAM P){
    switch P {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          VEnv Env = evalDecls(Decls);
          return evalStatements(Series, Env);
      }
   }
};

fun VEnv assign(VEnv Env, PICO-ID Id, PICO-VALUE V){
  return Env +&gt; {&lt;Id, V&gt;}  
  %% we need a nice tuple replacement operator here
}

fun PICO-VALUE valueOf(VEnv Env, PICO-ID Id){
  return Env(Id);
}

fun VEnv evalDecls(DECLS Decls){
    VEnv Env = {};
    visit Decls {
      case &lt;PICO-ID Id&gt; : string:  Env = assign(Env, Id, "")
      case &lt;PICO-ID Id&gt; : natural: Env = assign(Env, Id, 0)
    }
}

fun VEnv evalStatements({STATEMENT ";"}* Series, VEnv Env){
    switch Series {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        Env Env2 = evalStatement(Stat, Env);
        return evalStatements(Series2, Env2);
      }
      case [| |]: return Env
    }
}

fun VEnv evalStatement(STATEMENT Stat, VEnv Env){
    switch Stat {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        PICO-VALUE Val = evalExp(Exp, Env);
        return assign(Env, Id, Val)
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:{
        PICO-VALUE Val = evalExp(Exp, Env);
        if(Val != 0)
          return evalStatments(Stats1, Env)
        else 
          return evalStatements(Stats2, Env)

      }

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od:{
        PICO-VALUE Val = evalExp(Exp, Env);
        if(Val != 0)
          return Env
        else {
          VEnv Env2 = evalStatements(Stats1, Env);
          return evalStatement(Stat, Env2)
        }
      }
    };
};

fun PICO-VALUE evalExp(Exp exp, VEnv Env) {
    switch exp {
      case &lt;NatCon N&gt;: return N

      case &lt;StrCon S&gt;: return S

      case &lt;PICO-ID Id&gt;: return valueOf(Env, Id)

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;: {
           Natural nat1 = evalExp(exp1, Env);
           Natural nat2 = evalExp(exp2, Env);
           return nat1 + nat2;
      }
      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;: {
           Natural nat1 = evalExp(exp1, Env);
           Natural nat2 = evalExp(exp2, Env);
           return nat1 + nat2;
      }
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;: {
           StrCon str1 = evalExp(exp1, Env);
           StrCon str2 = evalExp(exp2, Env);
           return concat(str1, str2);
      }
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator with globals</title>

      <para>Here is the same evaluator but now using a global variable to
      represent the value environment.<programlisting>module Pico-eval
imports pico/syntax/Pico;

subtype PICO-VALUE int;
subtype PICO-VALUE str;

subtype VEnv rel[PICO-ID, PICO-VALUE];

fun void evalProgram(PROGRAM P){
    switch P {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          evalDecls(Decls);
          evalStatements(Series);
      }
   }
};

fun void assign(PICO-ID Id, PICO-VALUE V){
  global Venv Env;
 Env = Env +&gt; {&lt;Id, V&gt;}
  return;
}

fun PICO-VALUE valueOf(PICO-ID Id){
  global Venv Env;
  return Env(Id); 
}

fun VEnv evalDecls(DECLS Decls){
    global VEnv Env = {};
    visit Decls {
      case &lt;PICO-ID Id&gt; : string:  assign(Id, "")
      case &lt;PICO-ID Id&gt; : natural: assign(Id, 0)
    }
}

fun void evalStatements({STATEMENT ";"}* Series){
    global VEnv Env;
    switch Series {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        evalStatement(Stat);
        evalStatements(Series2);
        return
      }
      case [| |]: return
    }
}

fun void evalStatement(STATEMENT Stat){
    global VEnv Env;
    switch Stat {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        PICO-VALUE Val = evalExp(Exp);
        assign(Id, Val);
        return
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:{
        PICO-VALUE Val = evalExp(Exp);
        if(Val != 0) {
          evalStatements(Stats1);
          return
        } else {
          evalStatements(Stats2);
          return
        }
      }

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od:{
        PICO-VALUE Val = evalExp(Exp);
        if(Val != 0)
          return
        else {
          evalStatements(Stats1);
          evalStatement(Stat);
          return
        }
      }
    };
};

fun PICO-VALUE evalExp(Exp exp) {
    global VEnv Env;
    switch exp {
      case &lt;NatCon N&gt;: return N

      case &lt;StrCon S&gt;: return S

      case &lt;PICO-ID Id&gt;: return valueOf(Id)

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;: {
           Natural nat1 = evalExp(exp1);
           Natural nat2 = evalExp(exp2);
           return nat1 + nat2;
      }
      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;: {
           Natural nat1 = evalExp(exp1);
           Natural nat2 = evalExp(exp2);
           return nat1 + nat2;
      }
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;: {
           StrCon str1 = evalExp(exp1);
           StrCon str2 = evalExp(exp2);
           return concat(str1, str2);
      }
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico control flow extraction</title>

      <programlisting>module Pico-controlflow
imports pico/syntax/Pico;

subtype CP EXP;         %% A Code Point, union of two types
subtype CP STATEMENT;

subtype CFSEGMENT tuple(set[CP] entry, 
                        rel[CP,CP] graph, 
                        set[CP] exit);

fun CFSEGMENT cflow({STATEMENT ";"}* Stats){ 
    switch Stats {
      case &lt;STATEMENT Stat&gt; ; &lt;{STATEMENT ";"}* Stats2&gt;: { 
           &lt;set[CP] En1, rel[CP,CP] R1, set[CP] Ex1&gt; = cflow(Stat);
           &lt;set[CP] En2, rel[CP,CP] R2, set[CP] Ex2&gt; = 
                                                     cflow(Stats2);
           return &lt;En1, R1 + R2 + (Ex1 x En2), Ex2&gt;
      }

      case [| |]: return &lt;{}, {}, {}&gt;
    }
}; 

fun CFSEGMENT cflow(STATEMENT Stat){
    switch Stat {
      case [| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od |] : {
           &lt;set[CP] En,  rel[CP,CP] R,  set[CP] Ex&gt; = cflow(Stats);
           return &lt;{Exp}, ({Exp} x En) + R + (Ex x {Exp}),{Exp}&gt;;
      }
                
      case [| if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats2&gt; fi |]: {
           &lt;set[CP] En1, rel[CP,CP] R1, set[CP] Ex1&gt; = 
                                                     cflow(Stats1);
           &lt;set[CP] En2, rel[CP,CP] R2, set[CP] Ex2&gt; = 
                                                     cflow(Stats2);
           return &lt; {Exp}, 
                    ({Exp} x En1) + ({Exp} x En2) + R1 + R2,
                    Ex1 + Ex2 
                  &gt;;
      }
         
      case [| &lt;STATEMENT Stat&gt; |]: return &lt;{Stat}, {}, {Stat}&gt;
    };
}
</programlisting>

      <para></para>
    </section>

    <section>
      <title>Pico use def extraction</title>

      <programlisting>module Pico-use-def

imports pico/syntax/Pico;


fun rel[PICO-ID, EXP] uses(PROGRAM P) {
  return {&lt;Id, E&gt; | EXP E : P, PICO-ID Id := E}
}

fun rel[PICO-ID, STATEMENT] defs(PROGRAM P) { 
  return {&lt;Id, S&gt; | STATEMENT S : P, 
                    [| &lt;PICO-ID Id&gt; := &lt;EXP Exp&gt; |] := S}
}</programlisting>

      <para>The above uses a "matching condition" to decompose
      <literal>S</literal>. The problem solved is that we want to have a name
      for the whole assignment <emphasis>and</emphasis> for the lhs
      identifier. Also note that, compared to older definitions of these
      functions, the iudentifier is placed as first element in each
      tuple.</para>
    </section>

    <section>
      <title>Pico uninitialized variables</title>

      <para><programlisting>module Pico-uninit
imports pico/syntax/Pico 
        Pico-controlflow 
        Pico-use-def;

fun set[PICO-ID] uninit(PROGRAM P) {
    rel[EXP,PICO-ID] Uses = uses(P);
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    CFSEGMENT CFLOW = cflow(P);
    set[CP] Root = CFLOW.entry;
    rel[CP,CP] Pred = CFLOW.graph;

    return {Id | tuple(EXP E, PICO-ID Id) : Uses,
                 E in reachX(Root, Defs{Id}, Pred)
    };
}</programlisting></para>
    </section>

    <section>
      <title>Pico common subsexpression elimination</title>

      <para><programlisting>module Pico-common-subexpression

imports pico/syntax/Pico 
        Pico-controlflow 
        Pico-use-def;

fun PROGRAM cse(PROGRAM P) {
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;
    rel[EXP, PICO-ID] replacements = 
       {&lt;E2, Id&gt; | STATEMENT S : P,
                   [| &lt;PICO-ID Id&gt; := &lt;EXP E&gt; |] := S,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs{Id}, Pred)
       };
 
    visit P {
      case &lt;EXP E&gt;: if({ PICO-ID Id } := replacements{E}) yield Id
    };
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions E2 by Id, such
      that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>Id does not occur in E,</para>
        </listitem>

        <listitem>
          <para>E2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and E2.</para>
        </listitem>
      </itemizedlist>

      <para>Note that a slight abbreviation is possible if we introduce
      labelled patterns (here S): [UNDER DISCUSSION]</para>

      <programlisting> rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | &lt;PICO-ID Id&gt; := &lt;EXP E&gt; S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs(Id), Pred)
       };</programlisting>

      <para>Also note that we could factor out the assignment pattern to make
      cse more generic if we introduce patterns as first class
      citizens:</para>

      <programlisting>fun PROGRAM cse(PROGRAM P, 
                pat STATEMENT Assign(PICO-ID Id, EXP E)) {
 ...
    rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | Assign S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs(Id), Pred)
       };
 
 ...
}</programlisting>

      <para>Example invocations (Pico style)</para>

      <programlisting>cse(P, &lt;PICO-ID Id&gt; := &lt;EXP E&gt;)</programlisting>

      <para>or (Cobol style):</para>

      <programlisting>cse(P, move &lt;EXP E&gt; to &lt;PICO-ID Id&gt;)</programlisting>

      <para>Note that the order of variables in the pattern and its
      declaration may differ.</para>

      <para>It is to be determined how the instantiation of a pattern looks,
      e.g.</para>

      <programlisting>Assign([|x|], [| y = 1 |])</programlisting>
    </section>

    <section>
      <title>Pico constant propagation</title>

      <para><programlisting>module Pico-constant-propagation

imports pico/syntax/Pico 
        Pico-controlflow 
        Pico-use-def;

fun Boolean is-constant(EXP E) {
   switch E {
     case &lt;NatCon N&gt; =&gt; true

     case &lt;StrCon S&gt; =&gt; true

     case &lt;EXP E&gt; =&gt; false
   }
}

fun PROGRAM cp(PROGRAM P) {
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;

    rel[PICO-ID, EXP] replacements = 
      {&lt;Id2, E&gt; | STATEMENT S : P,
                  [| &lt;PICO-ID Id&gt; := &lt;EXP E&gt; |] := S,
                  is-constant(E),
                  PICO-ID Id2 : reachX({S},Defs{Id},Pred),
                  Id2 == Id 
      };  
 
    visit P {
     case &lt;PICO-ID Id&gt;: if({ EXP E } := replacements{Id}) yield E
    };  
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions Id2 by the constant E,
      such that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>E is constant,</para>
        </listitem>

        <listitem>
          <para>Id2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>Id2 is equal to Id,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and Id2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico Reaching definitions</title>

      <para>Recall the equations construct as used, for example, in the
      reaching definitions example in the Rscript guide. It computes the
      values of a set of variables until none of them changes any longer. The
      "solve" statement achives the same effect.<programlisting>module Pico-reaching-defs

subtype Def  tuple(Stat theStat, Var theVar);
subtype Use  tuple(Stat theStat, Var theVar);

fun set[Stat] predecessor(rel[Stat,Stat] P, Stat S) { 
    return P[-,S] %% outdated image operator
}

fun set[Stat] successor(rel[Stat,Stat] P, Stat S) { 
    return P[S,-]
}

fun rel[Stat, Def] reaching-definitions(rel[Stat,Var] DEFS, 
                                        rel[Stat,Stat] PRED) {

    set[Stat] STATEMENT = carrier(PRED);

    rel[Stat,Def] DEF  = {&lt;S,&lt;S,V&gt;&gt; | &lt;Stat S, Var V&gt; : DEFS};

    rel[Stat,Def] KILL = 
        {&lt;S1, &lt;S2, V&gt;&gt; | &lt;Stat S1, Var V&gt; : DEFS, 
                         tuple(Stat S2, V) : DEFS, 
                         S1 != S2
        };

     rel[Stat,Def] IN = {};
     rel[Stat,Def] OUT = DEF;

     solve {
           IN  =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Stat P : predecessor(PRED,S), 
                            Def D : OUT{P}};
           OUT = {&lt;S, D&gt; |  int S : STATEMENT, 
                            Def D : DEF{S} +  (IN{S} - KILL{S})}
    };
    return IN;
}</programlisting></para>
    </section>

    <section>
      <title>Symbol table with scopes</title>

      <para>Here is a (probably naive) implementation of a symbol table that
      maintains a list of numbered scopes as well as a (Name, Value) mapping
      in each scope. Note that we introduce parameterized modules to do this
      right.<programlisting>module SymTable[Name, Value]

%% A scope-oriented symbol table.
%% Each scope consists of a map from names to values. 
%% THis more intended to explore whether this can be expressed
%% *at all* than that the datatype is well designed.

subtype ScopeMap rel[Name, Value];
subtype ScopeId  int
datatype STable  stable(ScopeId scope, rel[int, ScopeMap] scopes); 

%% Create a new, empty,  table
fun STable new(){
  return make stable(0, {&lt;0, {}&gt;});
}

%% Create a new, non-empty, table
fun STable new(ScopeId scope, rel[int, ScopeMap] scopes){
  return make stable(scope, scopes);
} 

%% Update, in a given scope, the value of a variable
fun STable update(STable ST, ScopeId scope, Name N, Value V){
  X = ST.scopes(scope) + {&lt;N, V&gt;};
  return new(scope, ST.scopes + (ST.scopes(scope) + {&lt;N, V&gt;}));
}

%% Get, in a given scope, the value of a variable
fun STable value(STable ST, ScopeId scope, Name N){
  ScopeMap smap = ST.scopes(scope);
  return smap(N);
}

%% update, in the current scope, the value of a variable
fun STable update(STable ST, Name N, Value V){
  ScopeId scope = ST.scope;
  ScopeMap smap = ST.scopes(scope) + {&lt;N,V&gt;};
  return new(scope, ST.scopes + 
                    (ST.scopes(scope) + {&lt;scope, smap&gt;}));
}

%% Get, in the current scope, the value of a variable
fun STable value(STable ST, Name N){
  ScopeMap smap = ST.scopes(ST.scope);
  return smap(N);
}

%% add a new scope and make it the current scope
fun STable new-scope(STable ST){
  ScopeId scope = ST.scope + 1;
  return new(scope, ST.scopes + {&lt;scope, {}&gt;});
}

%% switch to another scope
fun STable switch-scope(STable ST, ScopeId scope){
  return new(scope, ST.scopes);
}

</programlisting></para>
    </section>

    <section>
      <title>Innerproduct</title>

      <para>[Example taken from TXL documentation]</para>

      <para>Define nnerproduct on vectors of integers, e.g. (1 2 3).(3 2 1)
      =&gt; 10.<programlisting>module examples/Vectors/Vector-syntax

exports
  imports basic/Integers
sorts Vector

context-free syntax
   "(" Integer* ")"    -&gt; Vector
   Vector "." Vector   -&gt; Integer</programlisting></para>

      <programlisting>module Innerproduct

imports Vector-syntax

fun int innerProduct(Vector V1, V2){
    if ( ( &lt;Integer N1&gt; &lt;Integer* Rest1&gt; ) := V1 &amp;&amp;
         ( &lt;Integer N2&gt; &lt;Integer* Rest2&gt; ) := V2 
       )
       return (N1*N2) + innerProduct( (&lt;Rest1&gt;), (&lt;Rest2&gt;) )
    else 
       return 0;
}</programlisting>
    </section>

    <section>
      <title>Bubble sort</title>

      <para>[Example taken from TXL documentation]</para>

      <programlisting>module Bubble

fun Integer* sort(Integer* Numbers){
    visit Numbers {
      case &lt;Integer* Rest1&gt; 
              &lt;Integer N1&gt; &lt;Integer N2&gt; 
           &lt;Integer* Rest2&gt;:
           if(N1 &gt; N2){
              return sort(make &lt;Integer* Rest1&gt; 
                                  &lt;Integer N2&gt; &lt;Integer N1&gt; 
                               &lt;Integer* Rest&gt;);
           }
    };
    return Numbers
}</programlisting>

      <para>This example raises a number of issues about the execution of
      visit.</para>

      <para>Another way to write this is:</para>

      <programlisting>module Bubble2

fun Integer* sort(Integer* Numbers){
    visit repeat Numbers {
      case &lt;Integer N1&gt; &lt;Integer N2&gt;:
        if( N1 &gt; N2) 
            yield make &lt;Integer N2&gt; &lt;Integer N1&gt;
    };
    return Numbers
}</programlisting>

      <para>The visit will replace all adjacent pairs that are in the wrong
      order in the current list. This is repeated (fixed point operator) until
      no more changes are possible.</para>
    </section>

    <section>
      <title>Generic Bubble sort [under discussion]</title>

      <para>Here is a generic bubble sort wich uses type parameters
      (&amp;ELEM) and a function parameter.<programlisting>module Bubble-Gen

fun &amp;Elem* sort(&amp;Elem* Elements, 
                fun bool GreaterThan(&amp;Elem, &amp;Elem)){
   
  visit repeat Elements {
      case &lt;Elem E1&gt; &lt;Elem E2&gt;: 
        if(GreaterThan(E1, E2)) 
           yield make &lt;Elem E2&gt; &lt;Elem E1&gt;

     }
}</programlisting>Do we want this generality? What are the implications for
      the implementation? The current syntax does not yet allow type variables
      in patterns.</para>
    </section>

    <section>
      <title>Read-Eval-Print Loop (REPR)</title>

      <para>For the scripting of application it is important to have a command
      language and read-eval-print loop. Here is an attempt. The command
      prompt is "&gt;".<programlisting>&gt; import lang.java.syntax.Main as Java
&gt; str source := read("program.java");
&gt; CU program := Java.CU.parse(source);

&gt; accu int count(CU P, int cnt) {
&gt;   switch P {
&gt;     Java.Statements.IF =&gt; cnt++;
&gt;   }
&gt; }

&gt; count(program)
17</programlisting>There are several innovations here:</para>

      <itemizedlist>
        <listitem>
          <para>The import associates a name with the imported module.<note>
              <para>This means that "grammar" and "rule" become notions that
              can be manipulated.</para>
            </note></para>
        </listitem>

        <listitem>
          <para>There is a read functions that reads a text file into a
          string.<note>
              <para>We need an io library that reads/writes strings and data
              values.</para>
            </note></para>
        </listitem>

        <listitem>
          <para>We associate a parse function with every non-terminal in a
          grammar.</para>
        </listitem>

        <listitem>
          <para>The notation <literal>Java.Statements.IF</literal> consists of
          three parts:</para>

          <itemizedlist>
            <listitem>
              <para>Language name</para>
            </listitem>

            <listitem>
              <para>Sort name</para>
            </listitem>

            <listitem>
              <para>Rule name (currently implemented with the "cons"
              attribute).</para>
            </listitem>
          </itemizedlist>

          <para>It can be used as pattern. Other potential uses are as
          generator:<programlisting>{S | Java.Statements.IF S : P}</programlisting>It
          generates all if statements in P.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Syntax Definition</title>

    <para>See separate SDF definition.</para>
  </section>

  <section>
    <title>Protyping/implementation of Rascal</title>

    <para>Every prototype will have to address the following issues:</para>

    <itemizedlist>
      <listitem>
        <para>Parsing/typechecking/evaluating Rascal.</para>
      </listitem>

      <listitem>
        <para>How to implement the relational operations.</para>
      </listitem>

      <listitem>
        <para>How to implement matching.</para>
      </listitem>

      <listitem>
        <para>How to implement replacement.</para>
      </listitem>

      <listitem>
        <para>How to implement traversals.</para>
      </listitem>
    </itemizedlist>

    <para>The following options should be considered:</para>

    <itemizedlist>
      <listitem>
        <para>Implementation of a typechecker in ASF+SDF:</para>

        <itemizedlist>
          <listitem>
            <para>Gives good insight in the type system and is comparable in
            complexity to the Rscript typechecker.</para>
          </listitem>

          <listitem>
            <para>Work: 2 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            ASF+SDF.</para>
          </listitem>

          <listitem>
            <para>Bound to be very slow.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of a typechecker in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Interesting exercise to asses Rascal.</para>
          </listitem>

          <listitem>
            <para>Not so easy to do without working Rascal
            implementation.</para>
          </listitem>

          <listitem>
            <para>Not so easy when Rascal is still in flux.</para>
          </listitem>

          <listitem>
            <para>Effort: 1 week</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Ditto.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Extending the current ASF+SDF interpreter.</para>

        <itemizedlist>
          <listitem>
            <para>This is a viable options. It requires extensions of
            AsFix.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Translation of Rascal to ASF+SDF in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Unclear whether this has longer term merit.</para>
          </listitem>

          <listitem>
            <para>Allows easy experimentation and reuse of current ASF+SDF
            implementation.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an interpreter in Java.</para>

        <itemizedlist>
          <listitem>
            <para>A future proof and efficient solution.</para>
          </listitem>

          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            Java.</para>
          </listitem>

          <listitem>
            <para>Effort: 8 weeks.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Rascal advertisements</title>

    <para>In this section we enumerate numerous facts about Rascal that
    advertise it to different audiences</para>

    <section>
      <title>Generic arguments</title>

      <para>What is good about Rascal in a few words?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is a DSL for source code analysis and transformation.
          It provides a pletora of high level statements and expressions,
          taking away the boilerplate of implementing and debugging tools that
          manipulate programs.</para>
        </listitem>

        <listitem>
          <para>Rascal combines the best features of imperative programming
          with the best features of functional programming and term rewriting.
          <itemizedlist>
              <listitem>
                <para>Simple structured statements for control flow and
                variable assignments for data flow are powerful and simple
                features of the imperative programming paradigm. They allow
                control flow and data flow to be understandable and
                traceable.</para>
              </listitem>

              <listitem>
                <para>From functional programming we borrow that all values
                are immutable and non-null. Issues with aliasing and
                referential integrity, such as frequently occur in imperative
                and OO programming therefore do not exist in Rascal.</para>
              </listitem>

              <listitem>
                <para>The Rascal type system is as powerful as most functional
                languages (higher-order polymorphic functions), however to
                make the language debuggable and understandable it, in
                principle, does not provide type inference.</para>
              </listitem>

              <listitem>
                <para>From term rewriting we inherit powerful pattern matching
                facilities, integration with context-free parsing and concrete
                syntax.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>

        <listitem>
          <para>Rascal supports both a scripting experience, and a compiled
          program experience.</para>
        </listitem>

        <listitem>
          <para>Rascal is type safe, but flexible. It's type system prevents
          common programming errors, but still allows ample opportunity for
          reusable code. The reasons are the we allow co-variance in the
          sub-typing relationship, high-order polymorphic functions and
          parameterized data-types.</para>
        </listitem>

        <listitem>
          <para>Rascal allows different styles of programming. From extremely
          high level specification, down to straight imperative
          programming.</para>
        </listitem>

        <listitem>
          <para>Rascal was inspired by and borrows from several other DSL's
          for program analysis and transformation in academia and industry,
          namely ASF+SDF, Rscript, TXL, TOM, DMS, Stratego, Elan, Maude, Grok,
          Haskell, ML and Setl.</para>
        </listitem>

        <listitem>
          <para>Rascal integrates seemlessly with Eclipse IMP and The
          Meta-Environment.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for ASF+SDF programmers</title>

      <para>Rascal is the successor of ASF+SDF. What's the difference? What's
      the same?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal has roughly all the high level features of ASF+SDF and
          some more. Old ASF+SDF specifications can be transformed to Rascal
          programs using a conversion tool.</para>
        </listitem>

        <listitem>
          <para>Rascal still uses SDF for syntax definition and parser
          generation.</para>
        </listitem>

        <listitem>
          <para>Rascal has a module system that is independent of SDF. Rascal
          modules introduce a namespace scope for variables and functions,
          which can be either private or public. Rewrite rules are global as
          in ASF+SDF. Modules can have type parameters as in SDF, which are
          instantiated by import statements.</para>
        </listitem>

        <listitem>
          <para>In Rascal, patterns and variables in concrete syntax may
          optionally be quoted and escaped, and support explicit declaration
          of the top non-terminal to solve ambiguity.</para>
        </listitem>

        <listitem>
          <para>Rascal rules read in the order of execution instead of first
          the left-hand side, then the conditions, and then the right-hand
          side of ASF+SDF equations</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive and efficient implementations for sets,
          relations and maps</para>
        </listitem>

        <listitem>
          <para>Rascal can be used without SDF, supporting for example regular
          expressions and abstract data types (pure ATerms)</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive support for functions, which have a fixed
          syntax, always return a value and have imperative control flow
          statements. Adding a function will not trigger the need for
          regenerating parse tables. Function types can be polymorphic in
          their parameters and also allow functions as arguments to implement
          reusable algorithms.</para>
        </listitem>

        <listitem>
          <para>The imperative nature of Rascal allows you to factor out
          common code and nest conditionals, unlike in ASF+SDF where
          alternative control flow paths had to be encoded by enumerating
          equations with non-overlapping conditions.</para>
        </listitem>

        <listitem>
          <para>Rascal is an imperative language, which natively supports I/O
          and other side-effects without work-arounds. When backtracking
          occurs, for example over list matching, Rascal makes sure that most
          side-effects are undone, and that I/O is delayed until no more
          backtracking can occur. Even rewrite rules support side-effects in
          Rascal.</para>
        </listitem>

        <listitem>
          <para>Rascal has native support for traversals, instead of the
          add-on it used to be in ASF+SDF. The visit statement is comparable
          to a traversal function, and is as type-safe as the previous, and
          more programmeable.</para>
        </listitem>

        <listitem>
          <para>Instead of accumulator values of traversal functions in
          ASF+SDF, Rascal simply supports lexically scoped variables that can
          be updated using assignments.</para>
        </listitem>

        <listitem>
          <para>Rascal adds specific expressions for relational calculus, all
          borrowed directly from RScript.</para>
        </listitem>

        <listitem>
          <para>When programming using Rascal functions, instead of rules, the
          control flow of a program becomes easily traceable and debuggable.
          It is simply like stepping through well structured code.</para>
        </listitem>

        <listitem>
          <para>Rascal is based on a Java interpreter, or a Java run-time when
          compiled. So the code is more portable.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for imperative and object-oriented programmers</title>

      <para>Rascal is an imperative DSL with high level statements and
      expressions specifically targeted at the domain of analysis and
      transformation of source code:</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is safe: there are no null values, and all values are
          immutable. Source code and abstract syntax trees, and the facts
          extracted from them are immutable. The Rascal interpreter and
          compiler make sure this is implemented efficiently. Without
          mutability it is easy to combine stages of your programs that
          analyse or annotate with stages that transform. Sharing a value does
          not introduce a coupling like in OO, simply because changes are only
          visible to the code that changes the values.</para>
        </listitem>

        <listitem>
          <para>Rascal is extra safe: it has a type system that prevents
          casting exceptions and other run-time failures. Still the type
          system specifically allows many kinds of combinations. For example,
          unlike in Java a set of integers is a subtype of a set of numbers
          (co-variance), which allows you to reuse algorithm for sets of
          numbers on sets of integers. It also provides true polymorphic and
          functions (no erasure), and functions can safely be parameters to
          other functions.</para>
        </listitem>

        <listitem>
          <para>Rascal provides high level statements and expressions
          for:</para>

          <itemizedlist>
            <listitem>
              <para>Visitors in all kinds of orders, expressed very concisely,
              and type safe.</para>
            </listitem>

            <listitem>
              <para>Pattern matching and construction (with concrete
              syntax!)</para>
            </listitem>

            <listitem>
              <para>Equation/constraint solving</para>
            </listitem>

            <listitem>
              <para>Relational calculus</para>
            </listitem>

            <listitem>
              <para>Rewrite rules for normalization/canonicalization of any
              kind of data-structure</para>
            </listitem>

            <listitem>
              <para>Support for parsing using context-free grammars (via
              importing modules from the SDF language).</para>
            </listitem>

            <listitem>
              <para>(de)Serialization of values</para>
            </listitem>

            <listitem>
              <para>Communication with databases</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Rascal provides typed data constructors for common
          mathematical structures, such as:</para>

          <itemizedlist>
            <listitem>
              <para>terms (a.k.a. abstract data types, tree nodes)</para>
            </listitem>

            <listitem>
              <para>parse trees (derivations of context-free grammars, for
              concrete syntax and direct manipulation of source code)</para>
            </listitem>

            <listitem>
              <para>relations</para>
            </listitem>

            <listitem>
              <para>sets</para>
            </listitem>

            <listitem>
              <para>maps</para>
            </listitem>

            <listitem>
              <para>tuples</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>In Rascal you can implement high-fidelity source-to-source
          transformations. Without too much overhead, programs can do
          extensive rewriting of the source code without the loss of
          particular layout standards or source code comments.</para>
        </listitem>

        <listitem>
          <para>Rascal is syntax-safe. When you use Rascal to generate or
          transform source code, it statically detects whether the resulting
          source code is syntactically correct.</para>
        </listitem>

        <listitem>
          <para>Rascal is executed by an interpreter written in Java, or it
          can be compiled to Java classes.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.issues">
    <title xml:id="Issues">Issues</title>

    <itemizedlist>
      <listitem>
        <para>See <xref linkend="section.patterns" /> for a description of
        patterns. There are still some questions about patterns:</para>

        <itemizedlist>
          <listitem>
            <para>Do we want the subexpressions in patterns? [Proposal: no
            since it complicates the syntax]</para>
          </listitem>

          <listitem>
            <para>Do we want string variables in patterns? [Undecided]</para>
          </listitem>

          <listitem>
            <para>Do we want to add regular expression matching primitives to
            patterns? Ex.</para>

            <itemizedlist>
              <listitem>
                <para><programlisting>[| if @any@ $Stats fi |]</programlisting></para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>How do we identify built-in sorts (bool, int, etc) with their
        syntactic counterparts?</para>
      </listitem>

      <listitem>
        <para>In a list comprehension: do list values splice into the list
        result?</para>
      </listitem>

      <listitem>
        <para>Ditto for set comprehensions.</para>
      </listitem>

      <listitem>
        <para>Some clean up of Rscript notation (operators "o" and "x" should
        go).</para>
      </listitem>

      <listitem>
        <para>We need an io-library.</para>
      </listitem>

      <listitem>
        <para>We need memo functions.</para>
      </listitem>

      <listitem>
        <para>How is lexical matching incorporated?</para>
      </listitem>

      <listitem>
        <para>Unexplored idea: add (possibly lazy) generators for all types;
        this allows to generate, for instance, all statements in a
        program.</para>
      </listitem>

      <listitem>
        <para>Shopping list of ideas in Tom:</para>

        <itemizedlist>
          <listitem>
            <para>Named patterns to avoid building a term, i.e. w@[| while
            $Exp do $stat od |].</para>
          </listitem>

          <listitem>
            <para>Anti-patterns, i.e. the complement of a patterns: ! [| while
            $Exp do $stat od |] matches anything but a while. (we had that in
            ASF+SDF too, it's needed)</para>
          </listitem>

          <listitem>
            <para>Anonymous variables a la Prolog: [| while $_ do $stat od
            |].</para>
          </listitem>

          <listitem>
            <para>String matching in patterns.</para>
          </listitem>

          <listitem>
            <para>Tom uses the notation %[ ... ]% for quoted strings with
            embedded @...@ constructs that are evaluated. It also has a
            backquote construct.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Shopping list of ideas from TXL:</para>

        <itemizedlist>
          <listitem>
            <para>"redefine" allows modification of an imported
            grammar.</para>
          </listitem>

          <listitem>
            <para>An "any" sort that matches anything.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Graveyard</title>

    <para>Don't read the following sections; they are leftovers from earlier
    versions of this document but may still contain material that can be
    reused.</para>
  </section>

  <section>
    <title>Mapping features to datatypes</title>

    <para><note>
        <para>This section has played a role during initial design; it is now
        outdated.</para>
      </note>Emphasized cells indicate a new datatype/feature combination that
    needs to be thought out.</para>

    <table xml:id="table.features">
      <title>Features vs datatypes</title>

      <tgroup cols="9">
        <colspec align="left" colname="col1" colnum="1" colwidth="2*" />

        <colspec align="center" colname="col2" colnum="2" colwidth="1*" />

        <colspec align="center" colname="col3" colnum="3" colwidth="1*" />

        <colspec align="center" colname="col4" colnum="4" colwidth="1*" />

        <colspec align="center" colname="col5" colnum="5" colwidth="1*" />

        <colspec align="center" colname="col6" colnum="6" colwidth="1*" />

        <colspec align="center" colname="col7" colnum="7" colwidth="1*" />

        <colspec align="center" colname="col8" colnum="8" colwidth="1*" />

        <colspec align="center" colname="col9" colnum="9" colwidth="1*" />

        <thead>
          <row>
            <entry>Which features work on which datatypes?</entry>

            <entry>CF syntax trees</entry>

            <entry>CF syntax lists</entry>

            <entry>Lexical syntax trees</entry>

            <entry>Lexical syntax lists</entry>

            <entry>Lists</entry>

            <entry>Sets</entry>

            <entry>Relations</entry>

            <entry>Tuples</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Pattern matching</entry>

            <entry>Y (CS)</entry>

            <entry>Y, CS, LM</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS, LM</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Pattern construction</entry>

            <entry>Y, CS</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS</entry>

            <entry>Y</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Generator/ Comprehension</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>LC</entry>

            <entry>SC</entry>

            <entry>SC</entry>

            <entry>N</entry>
          </row>

          <row>
            <entry>Complete Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Equations</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Polymorphism</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Serialization</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Traversal Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Subtyping</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N, except character class inclusion</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <itemizedlist>
      <listitem>
        <para>BC = Backward Compatible with ASF</para>
      </listitem>

      <listitem>
        <para>CS = Concrete Syntax</para>
      </listitem>

      <listitem>
        <para>HT= head/tail matching</para>
      </listitem>

      <listitem>
        <para>LC = List comprehension</para>
      </listitem>

      <listitem>
        <para>LM = List Matching</para>
      </listitem>

      <listitem>
        <para>N = No</para>
      </listitem>

      <listitem>
        <para>PS = Prefic Syntax</para>
      </listitem>

      <listitem>
        <para>SC = Set Comprehension</para>
      </listitem>

      <listitem>
        <para>Y = Yes</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Outdated examples</title>

    <section>
      <title>Generating Graph files in Dot format</title>

      <para>This example illustrates the use of a comprehension on the
      right-hand side of an equation.<programlisting>module Dot-generation

imports Dot-syntax

fun Dot gen-dot(rel[ID, ID] Rel) {
    [| digraph example {
                        $([ node(Tup) | &lt;ID,ID&gt; Tup : Rel ])
                       }
    |]
}

fun DotElem* gen-node(&lt;ID Id1, ID Id2&gt;) {
    [| node $Id1; node $Id2; $Id1 -&gt; $Id2 |}}
}</programlisting></para>
    </section>
  </section>

  <section xml:id="section.integration-tscript">
    <title>Integration with Tscripts (Outdated)</title>

    <note>
      <para>It is not yet clear whether we will also include Tscript in the
      integration effort. For the time being, this section is considered
      outdated.</para>
    </note>

    <section>
      <title>Introduction</title>

      <para>It is possible to speculate on an even further integration of
      formalisms and combining the above amalgan of ASF+SDF and Rscript with
      Tscripts.</para>
    </section>

    <section>
      <title>Requirements</title>

      <itemizedlist>
        <listitem>
          <para>R12: The resulting language uses a single type system. This
          means that relational types (possible including syntactic objects)
          can be used in Tscripts.</para>
        </listitem>

        <listitem>
          <para>R13: The current "expressions" in Tscript (terms that occur at
          the rhs of an assignment) are replaced by calls to ASF+SDF or
          Rscript functions.</para>
        </listitem>

        <listitem>
          <para>R14: There is minimal duplication in functionality between
          ASF+SDF/Rscript/Tscript.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Different styles of Type Declarations</title>

      <para>We have at the moment, unfortunately, a proliferation of
      declaration styles for types.</para>

      <para>Functions are declared in ASF+SDF as:</para>

      <programlisting>typecheck(PROGRAM) -&gt; Boolean</programlisting>

      <para>Observe that only the type of the parameter is given but that it
      does not have a name.</para>

      <para>In Rscript we have:</para>

      <programlisting>int sum(set[int] SI) = ...</programlisting>

      <para>while in Tscript processes are declared as</para>

      <programlisting>process mkWave(N : int) is ...</programlisting>

      <para>For variables a similar story applies. Variables are declared in
      ASF+SDF as:</para>

      <programlisting>"X" [0-9]+    -&gt; INT</programlisting>

      <para>In Rscript we have:</para>

      <programlisting>int X

int X : S   (in comprehensions)</programlisting>

      <para>and in Tscript we have:</para>

      <programlisting>X : int</programlisting>

      <para>In order to unify these styles, we might do the following:</para>

      <itemizedlist>
        <listitem>
          <para>The type of an entity is always written before the entity
          itself.</para>
        </listitem>

        <listitem>
          <para>Formal parameters have a name.</para>
        </listitem>
      </itemizedlist>

      <para>In essence, this amounts to using the declaration style as used in
      Rscript. So we get:</para>

      <programlisting>Boolean typecheck(PROGRAM P) is ...

process mkWave(int N) is ...</programlisting>

      <para>Or do we want things like:</para>

      <programlisting>function typecheck(P : PROGRAM) -&gt; Boolean is ...

var X -&gt; int

process mkWave(int N) is ...</programlisting>

      <para>Advantages are:</para>

      <itemizedlist>
        <listitem>
          <para>The category of the entity is immediately clear (function,
          var, process, tool, ...).</para>
        </listitem>

        <listitem>
          <para>It is readable to further qualify the category, i.e.,
          traversal function, hidden var, restartable tool)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Global Flow of Control</title>

      <para>We have to settle the possible flow of control between the three
      entities ASF+SDF, Rscript and Tscript. Since Tscript imposes the notion
      of an atomic action it would be problematic to have completely
      unrestricted flow of control. Therefore it is logical to use Tscript for
      the top-level control and to limit the use of ASF+SDF and Rscript to
      computations within atomic actions. There is no reason to restrict the
      flow of control between ASF+SDF and Rscript.</para>

      <para>What are the consequences of the above choice? Let's analyze two
      cases:</para>

      <itemizedlist>
        <listitem>
          <para>Parse a file from within an ASF+SDF specification. This (and
          similar built-ins) that use the operating system are removed from
          ASF+SDF. Their effect has to be achieved at the Tscript-level which
          is the natural place for such primitives.</para>
        </listitem>

        <listitem>
          <para>Describe I/O for a defined language. Consider Pico extended
          with a read statement. Here the situation is more complicated. We
          cannot argue that the flow of control in the Pico program (as
          determined by an interpreter written in ASF+SDF) should be moved to
          the Tscript level since Tscript simply does not have the primitives
          to express this. On the other hand, we have to interrupt the flow of
          control of the Pico interpreter when we need to execute a read
          statement. The obvious way to achieve this is</para>

          <itemizedlist>
            <listitem>
              <para>At the Tscript level, a loop repeatedly calls the Pico
              interpreter until it is done.</para>
            </listitem>

            <listitem>
              <para>After each call the Pico interpreter returns with
              either:</para>

              <itemizedlist>
                <listitem>
                  <para>An indication that the eecution is complete (and
                  possibly a final state and/or final value).</para>
                </listitem>

                <listitem>
                  <para>An indication that an external action has to be
                  executed, for instance the read statement. This indication
                  should also contain the intermediate state of the
                  interpreter. When the external action has been executed, the
                  Pico interpreter can be restarted with as arguments the
                  value of the external action and the intermediate
                  state.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Experimentation will have to show whether such a framework is
      acceptable.</para>
    </section>

    <section>
      <title>Modularization</title>

      <para>Rscript and Tscript have no, respectively, very limited mechanisms
      for modularization. ASF+SDF, however, provides a module mechanism with
      imports, hiding, parameters and renaming. This mechanism was originally
      included in ASF, was taken over by SDF and is now reused in ASF+SDF.
      Currently, there are not yet sufficiently large Rscripts to feel the
      need for modules. In Tscript, there is a strong need for restricted name
      spaces and for imposing limitations on name visibility in order to limit
      the possible interactions of a process with its surroundings and to make
      it possible to create nested process definitions. What are the design
      options we have to explore?</para>

      <para>First, we can design a new module system that is more suited for
      our current requirements. The advantage is that we can create an optimal
      solution, the disadvantage is that there are high costs involved
      regarding implementation effort and migrations of existing ASF+SDF
      specifications to the new module scheme.</para>

      <para>Second, we can design an add-on to the ASF+SDF module system that
      addresses our current needs.</para>

      <para>Third, we can try to reuse the current ASF+SDF module
      system.</para>

      <para>As a general note, parameterized modules, polymorphics types and
      renamings are competing features. We should understand what we want. It
      is likely that we do not need all of them.</para>

      <para>Before delving into one of the above alternative approaches, let's
      list our requirements first.</para>

      <itemizedlist>
        <listitem>
          <para>We need grammar modules that allow the following operations:
          import, renaming, deletion (currently not supported but important to
          have a fixed base grammar on many variations on it).
          Parameterization and export/hidden: unclear.</para>
        </listitem>

        <listitem>
          <para>We need function modules (ASF+SDF and Rscript) that provide:
          import, maybe parametrization, and export/hidden.</para>
        </listitem>

        <listitem>
          <para>We need process modules (Tscript) that provide: import,
          export, hiding.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
</article>