<?xml version="1.0" encoding="US-ASCII"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Rascal Requirements and Design Document</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Tijs</firstname><surname>van der
        Storm</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is a braindump of ideas. See <xref
    linkend="section.issues" /> for the issues that have to be
    resolved.</para>
  </note>

  <section>
    <title>Introduction</title>

    <para>Rascal is the working name for a new version of ASF+SDF, which will
    be extended with an efficient built-in set and relation data-type. This
    basically means that we include most features of the RScript language into
    ASF+SDF. The goals of this language are:</para>

    <itemizedlist>
      <listitem>
        <para>Separating pure syntax definitions (SDF) from function
        definitions.</para>
      </listitem>

      <listitem>
        <para>Easy syntax-directed analysis of programming languages.</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction.</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning.</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation.</para>
      </listitem>

      <listitem>
        <para>Efficient and scalable implementation.</para>
      </listitem>
    </itemizedlist>

    <para>The above goals are all but one already met in the current design of
    ASF+SDF, and the current design of RScript. What is missing is the
    connection (and to be honest: an efficient implementation of relational
    operators). Alas, any bridge between the two languages is both complex to
    manage and an efficiency bottleneck. This work is an attempt to
    consolidate this engineering trade-off.</para>

    <para>In <xref linkend="section.integration-tscript" /> we will also
    explore the issues when we take integration one step further and also
    include Tscripts in the considerations.</para>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Backward compatible with ASF+SDF. We need to port old
          ASF+SDF definitions to Rascal.</para>
        </listitem>

        <listitem>
          <para>R3: Compilation speed: parsetable generation is a major
          bottleneck in current ASF+SDF. This needs to be fixed.</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability and easy parsing of a
          wide range of source languages.</para>
        </listitem>

        <listitem>
          <para>R5: Functional (no side-effects).</para>
        </listitem>

        <listitem>
          <para>R6: File I/O (contradicts R5).</para>
        </listitem>

        <listitem>
          <para>R7: Easily accessible fact storage (similar to a heap, but
          remember R5 and the details of backtracking).</para>
        </listitem>

        <listitem>
          <para>R8: List matching (because of R2, influences R7).</para>
        </listitem>

        <listitem>
          <para>R9: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as
          scoping).</para>
        </listitem>

        <listitem>
          <para>R10: Syntax trees can be elements of the builtin
          data-structures (but not vice versa).</para>
        </listitem>

        <listitem>
          <para>R11: Features are orthogonal: try to keep the number of ways
          to write down a program minimal</para>
        </listitem>

        <listitem>
          <para>R12 (<emphasis role="bold">new</emphasis>): Minimize possible
          syntactic ambiguities; resolve them by type inference.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Mapping features to datatypes</title>

    <para>Emphasized cells indicate a new datatype/feature combination that
    needs to be thought out.</para>

    <table xml:id="table.features">
      <title>Features vs datatypes</title>

      <tgroup cols="9">
        <colspec align="left" colname="col1" colnum="1" colwidth="2*" />

        <colspec align="center" colname="col2" colnum="2" colwidth="1*" />

        <colspec align="center" colname="col3" colnum="3" colwidth="1*" />

        <colspec align="center" colname="col4" colnum="4" colwidth="1*" />

        <colspec align="center" colname="col5" colnum="5" colwidth="1*" />

        <colspec align="center" colname="col6" colnum="6" colwidth="1*" />

        <colspec align="center" colname="col7" colnum="7" colwidth="1*" />

        <colspec align="center" colname="col8" colnum="8" colwidth="1*" />

        <colspec align="center" colname="col9" colnum="9" colwidth="1*" />

        <thead>
          <row>
            <entry>Which features work on which datatypes?</entry>

            <entry>CF syntax trees</entry>

            <entry>CF syntax lists</entry>

            <entry>Lexical syntax trees</entry>

            <entry>Lexical syntax lists</entry>

            <entry>Lists</entry>

            <entry>Sets</entry>

            <entry>Relations</entry>

            <entry>Tuples</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Pattern matching</entry>

            <entry>Y (CS)</entry>

            <entry>Y, CS, LM</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS, LM</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Pattern construction</entry>

            <entry>Y, CS</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS</entry>

            <entry>Y</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Generator/ Comprehension</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>LC</entry>

            <entry>SC</entry>

            <entry>SC</entry>

            <entry>N</entry>
          </row>

          <row>
            <entry>Complete Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Equations</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Polymorphism</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Serialization</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Traversal Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Subtyping</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N, except character class inclusion</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <itemizedlist>
      <listitem>
        <para>BC = Backward Compatible with ASF</para>
      </listitem>

      <listitem>
        <para>CS = Concrete Syntax</para>
      </listitem>

      <listitem>
        <para>HT= head/tail matching</para>
      </listitem>

      <listitem>
        <para>LC = List comprehension</para>
      </listitem>

      <listitem>
        <para>LM = List Matching</para>
      </listitem>

      <listitem>
        <para>N = No</para>
      </listitem>

      <listitem>
        <para>PS = Prefic Syntax</para>
      </listitem>

      <listitem>
        <para>SC = Set Comprehension</para>
      </listitem>

      <listitem>
        <para>Y = Yes</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Questions</title>

    <para><itemizedlist>
        <listitem>
          <para>Q1: What about the overlap between sets of tuples and
          relations? We should build relations in for efficiency. Is there
          going to be a type equivalence. Are tuples going to be first class
          datatypes?</para>
        </listitem>

        <listitem>
          <para>Q2: Do we need to introduce the basic datatypes Integer and
          Boolean because sets and relations have typical builtin functions
          for that? Or can we put these things in a library? How about
          Locations? We need to introduce as few builtin syntax as possible to
          prevent ambiguity and confusion... Can we offer efficient relations
          without introducing a dependency on a fixed Integer/Boolean
          syntax??? It would be SIMPLE if only syntax trees are the leafs of
          nested lists/sets/relations/tuples.</para>
        </listitem>

        <listitem>
          <para>Q3: Concrete syntax will introduce problems with the new fixed
          syntax builtin datatypes (prefix functions, lists, sets, relations,
          tuples). Efficiently make a type-checker that can resolve most of
          the ambiguities.</para>
        </listitem>

        <listitem>
          <para>Q4: We should allow (optionally) quoting/escaping concrete
          syntax parts. If Q3 results in error or undecidable disambiguation,
          the user must be able to clarify precisely.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Rascal at a glance</title>

    <para>Rascal is summarized in the following subsections.</para>

    <para>See <xref linkend="Issues" /> for the issues that still have to be
    resolved.</para>

    <section>
      <title>Modules</title>

      <itemizedlist>
        <listitem>
          <para>"Syntax modules" are identical to standard SDF modules and
          define concrete syntax.</para>
        </listitem>

        <listitem>
          <para>Ordinary modules may import other modules and define types and
          functions.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Types</title>

      <para>The type system (and notation) are mostly similar to that of
      Rscript, but</para>

      <itemizedlist>
        <listitem>
          <para>Symbols (as defined by a syntax module) are also types.</para>
        </listitem>

        <listitem>
          <para>There are built-in types (bool, int str, loc) that have a
          syntactic counterpart (not yet defined how to do this
          exactly).</para>
        </listitem>

        <listitem>
          <para>There is a catch-all type "any".</para>
        </listitem>

        <listitem>
          <para>Relations can have optional column names.</para>
        </listitem>

        <listitem>
          <para>There is subtyping (as opposed to aliasing of types in
          Rscript)</para>
        </listitem>

        <listitem>
          <para>All syntactic types are a subtype of the type TREE that
          corresponds to AsFix.</para>
        </listitem>

        <listitem>
          <para>Up casts from a subtype to enclosing type are
          automatic.</para>
        </listitem>

        <listitem>
          <para>Down casts require a run-time check.</para>
        </listitem>
      </itemizedlist>

      <para>As a design strategy we try to offer the option to leave out as
      many type indications as possible.</para>

      <para>Type declarations may introduce new structured (abstract as oopsed
      to concrete) types.</para>

      <para>Types may include type variables like
      <literal>&amp;<replaceable>T</replaceable></literal> as in
      Rscript.</para>
    </section>

    <section>
      <title>Variables</title>

      <para></para>
    </section>

    <section>
      <title>Functions</title>

      <para>A function declaration consists of a visibility declaration, the
      keyword <literal>fun</literal>, result type, a function name, typed
      arguments and a function body.</para>

      <para>A visibility declaration is one of the keywords
      <literal>public</literal> or <literal>private</literal>
      (default).</para>

      <para>A function body contains optional variable declarations (with
      optional initializations) followed by an expression. The value of the
      expression is the value of the function.</para>

      <para>Functions can later be extended:</para>

      <itemizedlist>
        <listitem>
          <para>The keyword <literal>extend</literal> before a function
          declaration extends a previously defined function with the same
          signature.</para>
        </listitem>

        <listitem>
          <para>Local declarations in the extension function are added to the
          original function.</para>
        </listitem>

        <listitem>
          <para>If both bodies consist of a <literal>switch</literal> or
          <literal>visit</literal> construct, the cases are merged.</para>
        </listitem>

        <listitem>
          <para>Other cases may be considered: switch + expr, expr + switch,
          visit + expr, and expr + visit.</para>
        </listitem>

        <listitem>
          <para>No other extensions are allowed.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.patterns">
      <title>Concrete Patterns</title>

      <para>There is a notation of "pattern": a quoted concrete syntax
      fragment that may contain variables and subexpresions to be evaluated.
      We want to cover the whole spectrum from maximally quoted patterns that
      can unambiguously describe <emphasis role="bold">any</emphasis> syntax
      fragment to minimally quoted patterns as we are used to in ASF+SDF.
      Therefore we support the following mechanisms:</para>

      <itemizedlist>
        <listitem>
          <para>Optionally typed variables, written as
          <literal>&lt;<replaceable>TYPE</replaceable>
          <replaceable>NAME</replaceable>&gt;</literal> or
          <literal>&lt;<replaceable>NAME</replaceable>&gt;</literal>.</para>
        </listitem>

        <listitem>
          <para>Quoted patterns enclosed between <literal>[|</literal> and
          <literal>|]</literal>. Inside a fully quoted string, the characters
          <literal>&lt;</literal>, <literal>&gt;</literal> and
          <literal>|</literal> can be escaped as <literal>\&lt;</literal>,
          <literal>\&gt;</literal>, <literal>\|</literal>. Fully quoted
          patterns may contain variables.</para>
        </listitem>

        <listitem>
          <para>Unquoted patterns are an (unquoted) syntax fragment that may
          contain variables.</para>
        </listitem>
      </itemizedlist>

      <para>Quoted and unquoted patterns form the
      <emphasis>patterns</emphasis> that are supported in Rascal.</para>

      <para>Examples are:</para>

      <itemizedlist>
        <listitem>
          <para>Quoted pattern with typed variables:<programlisting>[| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od |]</programlisting></para>
        </listitem>

        <listitem>
          <para>Quoted pattern with untyped variables:<programlisting>[| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
        </listitem>

        <listitem>
          <para>Unquoted pattern with typed variables:<programlisting>while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od</programlisting></para>
        </listitem>

        <listitem>
          <para>Unquoted pattern with untyped variables:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>
        </listitem>
      </itemizedlist>

      <para>Obviously, with less quoting and type information, the probability
      of ambiguities increases. Our assumption is that a type checker can
      resolve them.</para>

      <para>Implementation hint. For every sort S in the syntax definition add
      the following rules:</para>

      <programlisting><replaceable>S</replaceable>                     -&gt; Pattern
"&lt;<replaceable>" "S</replaceable>"? Variable "&gt;" -&gt; <replaceable>S</replaceable>      </programlisting>
    </section>

    <section>
      <title>Abstract Patterns</title>

      <para>Type declarations may introduce a signature of abstract terms.
      These terms (possibly including typed variables as introduced for
      concrete patterns) may be used as abstract patterns at the same postion
      where concrete patterns are allowed.</para>
    </section>

    <section>
      <title>Expressions</title>

      <para>Expressions correspond roughly to Rscript expressions with some
      extensions:<itemizedlist>
          <listitem>
            <para>There are lists, sets and relations together with
            comprehensions for these types.</para>
          </listitem>

          <listitem>
            <para>Generators in comprehensions may range over syntax
            trees.</para>
          </listitem>

          <listitem>
            <para>Generators may have a strategy option to indicate:</para>

            <itemizedlist>
              <listitem>
                <para>all = continue</para>
              </listitem>

              <listitem>
                <para>first = break</para>
              </listitem>

              <listitem>
                <para>td = top-down</para>
              </listitem>

              <listitem>
                <para>bu = bottom-up</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>The complete repertoire of operators in Rscript is
            available.</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Statements</title>

      <para>Rascal has the following statement types:</para>

      <itemizedlist>
        <listitem>
          <para>Variable declaration with initialization.</para>
        </listitem>

        <listitem>
          <para>An assignment statement assigns a value to a (local or global)
          variable.</para>
        </listitem>

        <listitem>
          <para>If-then statement and if-then-else statement.</para>
        </listitem>

        <listitem>
          <para>A "return" statement returns a value from a function.</para>
        </listitem>

        <listitem>
          <para>A "switch" statement is similar to a switch statement in C or
          Java and for a given subject term, it corresponds to the matching
          provided by the left-hand sides of a set of rewrite rules. However,
          it provides <emphasis role="bold">only</emphasis> matching at the
          top level of the subject term and does not traverse it. The type of
          each pattern must be identical to the type of the subject term (or
          be a subtype of it).</para>
        </listitem>

        <listitem>
          <para>A rewrite rule consists of a Pattern followed by =&gt; and a
          replacement:<programlisting><replaceable>Pattern</replaceable> =&gt; <replaceable>Replacement</replaceable></programlisting>or
          the pattern is followed by a block of statements:<programlisting>Pattern: Block</programlisting></para>

          <para>A block may consist of declarations and statements.</para>
        </listitem>

        <listitem>
          <para>A "visit" statement corresponds to a traversal function. Given
          a subject term and a list of rewrite rules it traverses the term.
          Depending on the precise rules it may perform replacement (mimicking
          a transformer), update local variables (mimicking an accumulator) or
          a combination of these two. The visit statement may contain the same
          strategy options as a generator and also:</para>

          <itemizedlist>
            <listitem>
              <para>repeat = compute a fixed-point: repeat as long as the
              traversal function changes values.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>A "yield" statement that delivers a value during a
          traversal.</para>
        </listitem>

        <listitem>
          <para>A "solve" statement to solve a set of linear equations.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>Here we list experimental examples of Rascal code to try out
    features.</para>

    <section>
      <title>Variations on Booleans</title>

      <para>It seems that every language specification effort has to produce a
      specification of the Booleans at some moment, so let's try it now. We
      try the following versions:</para>

      <itemizedlist>
        <listitem>
          <para>A version using visit, see <xref
          linkend="section.booleans-with-visit" />.</para>
        </listitem>

        <listitem>
          <para>A version using an implicit reduction function</para>
        </listitem>
      </itemizedlist>

      <para>We use the following common syntax:<programlisting>module Booleans-syntax
exports 
  sorts Bool

  context-free syntax
    "true"        -&gt; Bool
    "false"       -&gt; Bool
    Bool "&amp;" Bool -&gt; Bool {left}
    Bool "|" Bool -&gt; Bool {right}</programlisting></para>

      <section xml:id="section.booleans-with-visit">
        <title>Booleans using visit</title>

        <para>A simple solution exists using the visit construct that we have
        encountered in the above examples.<programlisting>module Bool-example1
imports Booleans-syntax

fun Bool reduce(Bool B) {
    visit bu B {
      true &amp; &lt;Bool B2&gt;  =&gt; B2    %% Style 1: Use Variables
      false &amp; &lt;Bool B2&gt; =&gt; false

      true | true   =&gt; true      %% Style 2: Use a truth table
      true | false  =&gt; true
      false | true  =&gt; true
      false | false =&gt; false
    }
}</programlisting></para>

        <para>Observe that there are two styles:</para>

        <itemizedlist>
          <listitem>
            <para>Using variables on the left-hand side: the visit is needed
            to fully normalize the result.</para>
          </listitem>

          <listitem>
            <para>A truth table: this is sufficient as is.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Abstract Booleans</title>

        <para>In the above example we used concrete syntax for Booleans
        expressions. It also possible to define Booleans as abstract
        terms.<programlisting>module Bool-abstract

type Bool true;
type Bool false;
type Bool and(Bool,Bool);
type Bool or(Bool, Bool);

fun Bool reduce(Bool B) {
    visit bu B {
      and(true, &lt;Bool B2&gt;)  =&gt; B2    %% Style 1: Use Variables
      and(false, &lt;Bool B2&gt;) =&gt; false

      or(true, true)   =&gt; true      %% Style 2: Use a truth table
      or(true, false)  =&gt; true
      or(false, true)  =&gt; true
      or(false, false) =&gt; false
    }
}</programlisting></para>

        <para>First, type declarations are used to define the abstract syntax
        of the type Bool. Next, a similar reduce function is defined as
        before, but now we use abstract patterns.</para>
      </section>

      <section>
        <title>Booleans with implicit reduce</title>

        <para>In ASF, values are always reduced to a normal form when they are
        created. In order to approximate this bahaviour we introduce the
        possibility to associate a reduction function with all values of a
        sort:</para>

        <para><programlisting>simplify Bool B as reduce(B)</programlisting>with
        as meaning that the (sort preserving) function
        <literal>reduce</literal> is applied whenever a value of type
        <literal>Bool</literal> is constructed. A notational alternative is to
        include this in the function declaration:<programlisting>reduction fun Bool reduce(Bool B) { ... }</programlisting></para>

        <para>There are some issues here:</para>

        <itemizedlist>
          <listitem>
            <para>It should be forbidden that more than one simplify applies
            for the same sort. This situation could arise due to
            imports.</para>
          </listitem>

          <listitem>
            <para>We could (optionally) forbid or warn for the explicit use of
            a function that is used as simplifier.</para>
          </listitem>

          <listitem>
            <para>We have not yet addressed visibility (public/private/hidden
            etc) of names. We should be carefull in determining the visibility
            and scope of the simplify construct.</para>
          </listitem>

          <listitem>
            <para>It is interesting that the simplify construct allows us to
            explicitly use certain sorts as free terms or as terms that are to
            be simplfied, depending on the context. This flexibility is absent
            in ASF.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Tree traversal</title>

      <para>Here is the TREE example that we use in explaining traversal
      functions in ASF+SDF.<programlisting>module Tree-syntax
imports basic/Integers

exports 
  sorts TREE
  context-free syntax
    Integer         -&gt; TREE
    f(TREE,TREE)    -&gt; TREE
    g(TREE,TREE)    -&gt; TREE
    h(TREE,TREE)    -&gt; TREE
    i(TREE,TREE)    -&gt; TREE</programlisting><programlisting>module Tree-Examples
imports Tree-syntax 

%% Ex1: Count leaves in a TREE
%% Idea: int N : T generates alle Integer leaves in the tree
%% # is the built-in length-of operator

fun int cnt(TREE T) {
    return #{N | int N : T}
}

%% Ex1: an equivalent,  more purist, version of the same function:
fun int cnt(TREE T) {
    return #{N | &lt;Integer N&gt; : T}
}

%% Ex1: alternative solution using trafo functions:

fun int cnt(TREE T) {
    int C = 0;
    visit T {
      &lt;Integer N&gt; : C = C+1
    };
    return C;
}

%% Ex2: Sum all leaves in a TREE
%% NB sum is a built-in that adds all elements in a set or list.
%% Here we see immediately the need to identify
%% - the built-in sort "int"
%% - the syntactic sort "Integer"

fun int sumtree(TREE T) {
    return sum({N | int N : T});
}

%% Ex2: using accumulator

fun int cnt(TREE T) {
    int C = 0;
    visit T {
      &lt;Integer N&gt; : C = C+N
    };
    return C;
}

%% Ex3: Increment all leaves in a TREE
%% Idea: using the construct "visit T { ... }" visit all leaves in the 
%% tree T that match an integer and replace each N in T by N+1.
%% The expression as a whole returns the modified term.
%% Note that two conversions are needed here:
%% - from int to NAT to match subterms
%% - from int to NAT to convert the result of addition into 
%%   a NAT tree

fun TREE inc(TREE T) {
    visit T {
      &lt;Integer N&gt;: yield (N + 1)
    };
}

%% Ex4: full replacement of g by i
%% The whole repertoire of traversal functions is available:
%% - visit first bu T { ... }
%% - visit all td  T { ... }
%% - etc.
%% with:
%% "first" (= break) and "all" (= continue).
%% "bu" (= bottom-up) and "td" (=top-down)
%% A nice touch is that these properties are not tied to the
%% declaration of a travesal function (as in ASF+SDF) but to 
%% its use.

fun TREE frepl(TREE T) {
    visit all bu T {
      g(&lt;TREE T1&gt;, &lt;TREE T2&gt;) =&gt; i(&lt;TREE T1&gt;, &lt;TREE T2&gt;)
    };
}

%% Ex5: Deep replacement of g by i

fun TREE frepl(TREE T) {
    visit first bu T {
      g(&lt;TREE T1&gt;, &lt;TREE T2&gt;) =&gt; i(&lt;TREE T1&gt;, &lt;TREE T2&gt;)
    };
}

%% Ex6: shallow replacement of g by i (i.e. only outermost 
%% g's are replaced); 

fun TREE srepl(TREE T) {
    visit first td T {
      g(&lt;TREE T1&gt;, &lt;TREE T2&gt;) =&gt; i(&lt;TREE T1&gt;, &lt;TREE T2&gt;)
    };
}


%% Ex7: We can also add the first/td directives to all generators 
%% (where "all td" would be the default):

fun set[TREE] find_outer_gs(TREE T) {
    return
    { S | STATEMENT S : first td T, 
          g(&lt;TREE T1&gt;, &lt;TREE T2&gt;) := S };
}

%% Ex8: accumulating transformer that increments leaves with amount D and counts them
fun &lt;int, TREE&gt; count_and_inc(TREE T, int C, int D) {
    int C = 0;
    
    visit T {
      &lt;Integer N&gt;: { C = C + 1; yield N+D }
     };
     return &lt;C, T&gt;;
}
</programlisting></para>
    </section>

    <section>
      <title>Substitution in Lambda</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.</para>

      <programlisting>module examples/Lambda/Lambda-syntax

exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+               -&gt; Var
context-free syntax
     "prime" "(" Var ")"  -&gt; Var  %% generate unique name
     Var                  -&gt; Exp  %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp  %% function abstraction
     Exp Exp              -&gt; Exp  %% function application
</programlisting>

      <para>Examples:</para>

      <para><programlisting>module Lambda-Examples
imports Lambda-syntax

fun set[Var] allVars(Exp E) {
    return {V | Var V : E}
}

fun set[Var] boundVars(Exp E) {
    return {V | fn &lt;Var V&gt; =&gt; &lt;Exp E1&gt; : E};
} 

fun set[Var] freeVars(Exp E) {
    return allVars(E) \ boundVars(E);
}

%% Generate a fresh variable if V does not occur in 
%% given set of variables.

fun Var fresh(Var V, set[Var] S) {
    if (V in S){ return prime(V); } else {return V;};
}

%% Substitution: replace all occurrences of V in E2 by E1

fun Exp subst(Var V1, Exp E1, Exp E2) {

    switch E2 {
      &lt;Var V2&gt;: if(V1 != V2){ yield V2; }

      &lt;Var V2&gt;: if(V1 == V2){ yield E1; }

      &lt;Exp Ea&gt; &lt;Exp Eb&gt;: {
         Exp EaS = subst(V, E, Ea);
         Exp EbS = subst(V, E, Eb);
         return &lt;Exp EaS&gt; &lt;Exp EbS&gt;;
      } 

      fn &lt;Var V2&gt; =&gt; &lt;Var Ea&gt;: 
         if (V1 == V2) { yield fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt; }

      fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;:
         if(V1 != V2 &amp;&amp; 
            not(V1 in freeVars(E2) &amp;&amp; 
            V2 in freeVars(E1))){
           Exp E1S = subst(V1, E1, Ea);
           yield fn &lt;Var V2&gt; =&gt; &lt;Exp E1S&gt;;
         }              
 
       fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;: 
          if(V1 != V2 &amp;&amp; 
             V1 in freeVars(Ea) &amp;&amp; 
             V2 in freeVars(E1)){
             Var V3 = fresh(V2, freeVars(Ea) union freeVars(E1));
             Exp EaS = subst(V1, E1, subst(V2, V3, E2));
             yield fn &lt;Var V3&gt; =&gt; &lt;Exp EaS&gt;;
          }
    };
}</programlisting><note>
          <para>There are a lot of ambiguities in the body of subst!</para>
        </note></para>
    </section>

    <section>
      <title>Renaming in Let</title>

      <para><programlisting>module Let-syntax
exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+                           -&gt; Var
context-free syntax
     Var                              -&gt; Exp
     "let" Var "=" Exp "in" Exp "end" -&gt; Exp </programlisting>Examples:<programlisting>module Let-Example
imports Let

%% Rename all bound variables in an Exp
%% Version 1: purely functional
%% Exp: given expression to be renamed
%% rel[Var,Var]: renaming table
%% Int: counter to generate global variables

fun Exp rename(Exp E, rel[Var,Var] Rn, Int Cnt) {
    switch E {
      let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end: {
        Var Y = "x" + Cnt;  %% this + operator concatenates 
                            %% (after converting the int to str)
        int Cnt1 = Cnt + 1;
        Exp E1R = rename(E1, Rn, Cnt);
        Exp E2R = rename(E2, {&lt;V, Y&gt;} union Rn, Cnt1);
        return let &lt;Var Y &gt;= &lt;Exp E1R&gt;
               in 
                   &lt;Exp E2R&gt;
               end;
      }

    &lt;Var V&gt;: return Rn[V]

    &lt;Exp E1&gt;: return E1
    };
}</programlisting>Here are some OUTDATED experiments with global
      variables:<programlisting>%% Rename all bound variables in an Exp
%% Version 2: using a global variable
%% to generate new variables

fun Var newVar() {
    global int Cnt := 0   %% Initialize global Cnt on first call 
                          %% of newVar. This is similar to a 
                          %% local static var in C.
    Cnt := Cnt + 1;
    "x" + Cnt
}       

%% Rename -- Version 2

fun Exp rename(Exp E, rel[Var,Var] Rn) {
    Var V, Y;

    switch E {

    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $(rename(E1, Rn)) 
              in 
                $(rename(E2, {&lt;V, Y&gt;} union Rn)) 
              end
           |]
       when Y := newVar()

    [| $V |] =&gt; V1
       when { V1 } == Rn[V]
  
    [| $E |] =&gt; E
    }
}

%% Rename -- Version 3, with Rn also as global variabele

fun Var newVar() {
    global int Cnt := 0   
    Cnt := Cnt + 1;
    "x" + Cnt
}       

fun Exp rename(Exp E) {
    global rel[Var, Var] Rn := {}
    Var V, Y;
 
    switch E {
    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $rename(E1) 
              in 
                 $rename(E2) 
              end
           |]
       when Y := newVar,
            Rn :=  {&lt;V, Y&gt;} union Rn
              
    [| $V |] =&gt; V1
       when { V1 } == Rn[V]
 
    [| $E |] = E
    }
}

%% Question: how to reset the value of global variables?
%% Idea: model them as arguments:
%% - fun Var newVar(global int Cnt := 0) { ... }
%% and allow calls without arguments (as in above example) or
%% with arguments:
%% - newVar(13)
%% which resets the value of Cnt.</programlisting></para>
    </section>

    <section>
      <title>Concise Pico Typechecker</title>

      <para>The following example shows the tight integration ASF with
      comprehensions.<programlisting>module Typecheck

imports Pico-syntax
imports Errors

type Env = rel[PICO-ID,TYPE];

fun list[Error] tcp(PROGRAM P) {
    switch P {
      begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
        Env Env = {&lt;Id, Type&gt; | &lt;PICO-ID Id&gt; : &lt;TYPE Type&gt; : Decls};
        return [ tcst(S, Env) | Stat S : Series ]     %% list comprehension
      }
    };
}

fun list[Error] tcst(Stat Stat, Env Env) {
    switch Stat {
      &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt;: {
        {&lt;Id, Type&gt;} = Env[Id];
        return type-of(Exp, Type, Env);
      }

      if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:
        return type-of(Exp, natural, Env) + 
               tcs(Stats1, Env) + tcs(Stats2, Env);

      while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od: 
        yield type-of(Exp, natural, Env) + tcs(Stats, Env);
    };
}

fun list[Error] type-of(Exp E, TYPE Type, Env Env) {
    switch E {
      &lt;NatCon N&gt;: if(Type == natural){ return []; }

      &lt;StrCon S&gt;: if(Type == string) { return []; }

      &lt;PICO-ID Id&gt;: {
        {&lt;Id,Type2&gt;} = Env[Id];
        if(Type2 == Type) { return []; }
      }

      &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type-of(E1, natural, Env) + 
                  type-of(E1, natural, Env);
        }

      &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type-of(E1, natural, Env) + 
                  type-of(E1, natural, Env);
        }

      &lt;EXP E1&gt; || &lt;EXP E2&gt; =&gt; 
        if(Type == string){
          return type-of(E1, string, Env) + 
                 type-of(E1, string, Env)
        }
    
      &lt;EXP Exp&gt;: return [error("Incorrect type")];
    };
}</programlisting></para>
    </section>

    <section>
      <title>Pico control flow extraction</title>

      <programlisting>module Pico-controlflow
imports pico/syntax/Pico

type CP EXP;     %% A Code Point, union of two types
type CP STATEMENT;

type CFSEGMENT &lt; set[CP] entry, rel[CP,CP] graph, set[CP] exit&gt;;

fun CFSEGMENT cflow({STATEMENT ";"}* Stats){ 
    switch Stats {
      &lt;STATEMENT Stat&gt; ; &lt;{STATEMENT ";"}* Stats2&gt;: { 
         &lt;set[CP] En1, rel[CP,CP] R1, set[CP] Ex1&gt; = cflow(Stat);
         &lt;set[CP] En2, rel[CP,CP] R2, set[CP] Ex2&gt; = cflow(Stats2);
         return &lt;En1, R1 union R2 union (Ex1 x En2), Ex2&gt;;
      }

      [| |]: return &lt;{}, {}, {}&gt;;
    };
}

fun CFSEGMENT cflow(STATEMENT Stat){
    switch Stat {
      while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od: {
        &lt;set[CP] En,  rel[CP,CP] R,  set[CP] Ex&gt; = cflow(Stats);
        return &lt;{Exp}, ({Exp} x En) union R union (Ex x {Exp}),{Exp}&gt;;
      }
                
      if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats2&gt; fi: {
        &lt;set[CP] En1, rel[CP,CP] R1, set[CP] Ex1&gt; = cflow(Stats1);
        &lt;set[CP] En2, rel[CP,CP] R2, set[CP] Ex2&gt; = cflow(Stats2);
        return &lt; {Exp}, 
                 ({Exp} x En1) union ({Exp} x En2) union R1 union R2,
                 Ex1 union Ex2
               &gt;;
      }
          
      &lt;STATEMENT Stat&gt;: return &lt;{Stat}, {}, {Stat}&gt;;
    };
}</programlisting>

      <para></para>
    </section>

    <section>
      <title>Pico use def extraction</title>

      <programlisting>module Pico-use-def

imports pico/syntax/Pico

fun rel[EXP,PICO-ID] uses(PROGRAM P) {
  return {&lt;E,Id&gt; | EXP E : P, PICO-ID Id := E};
}

fun rel[STATEMENT, PICO-ID] defs(PROGRAM P) { 
  return {&lt;S, Id&gt; | STATEMENT S : P, 
                    &lt;PICO-ID Id&gt; := &lt;EXP Exp&gt; := S};
}</programlisting>

      <para>The above uses a "matching condition" to decompose
      <literal>S</literal>. The problem solved is that we want to have a name
      for the whole assignment <emphasis>and</emphasis> for the lhs
      identifier.</para>
    </section>

    <section>
      <title>Pico uninitialized variables</title>

      <para><programlisting>module Pico-uninit
imports pico/syntax/Pico 
        Pico-controlflow 
        Pico-use-def

fun set[PICO-ID] uninit(PROGRAM P) {
    rel[EXP,PICO-ID] Uses = uses(P);
    rel[STATEMENT, PICO-ID] Defs = defs(P);
    CFSEGMENT CFLOW = cflow(P);
    set[CP] Root = CFLOW.entry;
    rel[CP,CP] Pred = CFLOW.graph;

    {Id | &lt;EXP E, PICO-ID Id&gt; : Uses,
                 E in reachX(Root, Defs[-,Id], Pred)
    };
}</programlisting>Questions (UPDATE THIS):</para>

      <itemizedlist>
        <listitem>
          <para>There is a subtyping issue here. De type of
          <literal>reachX</literal> is:</para>

          <para><literal>set[&amp;T] reachX(set[&amp;T]
          Start,</literal></para>

          <para><literal> set[&amp;T] Excl, </literal></para>

          <para><literal> rel[&amp;T,&amp;T] Rel)</literal></para>

          <para>but <literal>E</literal> has type <literal>EXP</literal>,
          <literal>{ROOT}</literal> has type
          <literal>set[STATEMENT]</literal>, and <literal>cflow</literal> has
          type <literal>rel[CP,CP]</literal>, with <literal>type CP = EXP |
          STATEMENT</literal>. It requires proper subtyping, e.g.
          set[STATEMENT] &lt; set[CP], to type this.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico common subsexpression elimination</title>

      <para><programlisting>module Pico-common-subexpression

imports pico/syntax/Pico 
        Pico-controlflow 
        Pico-use-def

fun PROGRAM cse(PROGRAM P) {
    rel[STATEMENT, PICO-ID] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;
    rel[EXP, PICO-ID] replacements = 
       {&lt;E2, Id&gt; | STATEMENT S : P,
                   &lt;PICO-ID Id&gt; := &lt;EXP E&gt; := S,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[-,Id], Pred)
       };
 
    visit P {
      &lt;EXP E &gt; =&gt; if({ Id } := replacements[E]) yield Id;
    };
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions E2 by Id, such
      that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>Id does not occur in E,</para>
        </listitem>

        <listitem>
          <para>E2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and E2.</para>
        </listitem>
      </itemizedlist>

      <para>Note that a slight abbreviation is possible if we introduce
      labelled patterns (here S):</para>

      <programlisting> rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | &lt;PICO-ID Id&gt; := &lt;EXP E&gt; S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[-,Id], Pred)
       };</programlisting>

      <para>Also note that we could factor out the assignment pattern to make
      cse more generic if we introduce patterns a sfirst class
      citizens:</para>

      <programlisting>fun PROGRAM cse(PROGRAM P, pat STATEMENT Assign(PICO-ID Id, EXP E)) {
 ...
    rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | Assign S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[-,Id], Pred)
       };
 
 ...
}</programlisting>

      <para>Example invocations (Pico style)</para>

      <programlisting>cse(P, &lt;PICO-ID Id&gt; := &lt;EXP E&gt;)</programlisting>

      <para>or (Cobol style):</para>

      <programlisting>cse(P, move &lt;EXP E&gt; to &lt;PICO-ID Id&gt;)</programlisting>

      <para>Note that the order of variables in the pattern and its
      declaration may differ.</para>

      <para>It is to be determined how the instantiation of a pattern looks,
      e.g.</para>

      <programlisting>Assign([|x|], [| y = 1 |])</programlisting>
    </section>

    <section>
      <title>Pico constant propagation</title>

      <para><programlisting>module Pico-constant-propagation

imports pico/syntax/Pico 
        Pico-controlflow 
        Pico-use-def

fun Boolean is-constant(EXP E) {
   switch E {
     &lt;NatCon N&gt; =&gt; true

     &lt;StrCon S&gt; =&gt; true

     &lt;EXP E&gt; =&gt; false
   }
}

fun PROGRAM cp(PROGRAM P) {
    rel[STATEMENT, PICO-ID] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;

    rel[PICO-ID, EXP] replacements = 
      {&lt;Id2, E&gt; | STATEMENT S : P,
                  &lt;PICO-ID Id&gt; := &lt;EXP E&gt; := S,
                  is-constant(E),
                  PICO-ID Id2 : reachX({S},Defs[-,Id],Pred),
                  Id2 == Id 
      };  
 
    visit P {
     &lt;PICO-ID Id&gt;: if({ EXP E } := replacements[Id]) return E
    };  
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions Id2 by the constant E,
      such that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>E is constant,</para>
        </listitem>

        <listitem>
          <para>Id2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>Id2 is equal to Id,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and Id2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Innerproduct</title>

      <para>[Example taken from TXL documentation]</para>

      <para>Define nnerproduct on vectors of integers, e.g. (1 2 3).(3 2 1)
      =&gt; 10.<programlisting>module examples/Vectors/Vector-syntax

exports
  imports basic/Integers
sorts Vector

context-free syntax
   "(" Integer* ")"    -&gt; Vector
   Vector "." Vector   -&gt; Integer</programlisting></para>

      <programlisting>module Innerproduct

imports Vector-syntax

fun int innerProduct(Vector V1, V2){
    if ( ( &lt;Integer N1&gt; &lt;Integer* Rest1&gt; ) := V1 &amp;&amp;
         ( &lt;Integer N2&gt; &lt;Integer* Rest2&gt; ) := V2 
       )
       return (N1*N2) + innerProduct( (&lt;Rest1&gt;), (&lt;Rest2&gt;) )
    else 
       return 0;
}</programlisting>
    </section>

    <section>
      <title>Bubble sort</title>

      <para>[Example taken from TXL documentation]</para>

      <programlisting>module Bubble

fun Integer* sort(Integer* Numbers){
    visit Numbers {
      &lt;Integer* Rest1&gt; &lt;Integer N1&gt; &lt;Integer N2&gt; &lt;Integer* Rest2&gt;:
        if(N1 &gt; N2){
          return sort(&lt;Integer* Rest1&gt; &lt;Integer N2&gt; &lt;Integer N1&gt; &lt;Integer* Rest&gt;);
        }
    };
}</programlisting>

      <para>This example raises a number of issues about the execution of
      visit.</para>

      <para>Another way to write this is:</para>

      <programlisting>module Bubble2

fun Integer* sort(Integer* Numbers){
    visit repeat Numbers {
      &lt;Integer N1&gt; &lt;Integer N2&gt;: if( N1 &gt; N2) yield &lt;Integer N2&gt; &lt;Integer N1&gt;

     }
}</programlisting>

      <para>The visit will replace all adjacent pairs that are in the wrong
      order in the current list. This is repeated (fixed point operator) until
      no more changes are possible.</para>
    </section>

    <section>
      <title>Generic Bubble sort</title>

      <para>Here is a generic bubble sort wich uses type parameters
      (&amp;ELEM) and a function parameter.<programlisting>module Bubble-Gen

fun &amp;Elem* sort(Elem* Elements, fun bool GreaterThan(&amp;Elem, &amp;Elem)){
   
  visit repeat Elements {
      &lt;E1&gt; &lt;E2&gt;: if(GreaterThan(E1, E2)) yield &lt;E2&gt; &lt;E1&gt;

     }
}</programlisting>Do we want this generality? What are the implications for
      the implementation? The current syntax does not yet allow type variables
      in patterns.</para>
    </section>

    <section>
      <title>Reaching definitions</title>

      <para>Recall the equations construct as used, for example, in the
      reaching definitions example in the Rscript guide. It computes the
      values of a set of variables until none of them changes any
      longer.<programlisting>module Pico-reaching-defs

type Def  = &lt;Stat theStat, Var theVar&gt;
type Use  = &lt;Stat theStat, Var theVar&gt;

fun set[Stat] predecessor(rel[Stat,Stat] P, Stat S) { return P[-,S] }

fun set[Stat] successor(rel[Stat,Stat] P, Stat S) { return P[S,-] }

fun rel[Stat, Def] reaching-definitions(rel[Stat,Var] DEFS, 
                                        rel[Stat,Stat] PRED) {

    set[Stat] STATEMENT = carrier(PRED);

    rel[Stat,Def] DEF  = {&lt;S,&lt;S,V&gt;&gt; | &lt;Stat S, Var V&gt; : DEFS};

    rel[Stat,Def] KILL = 
        {&lt;S1, &lt;S2, V&gt;&gt; | &lt;Stat S1, Var V&gt; : DEFS, 
                         &lt;Stat S2, V&gt; : DEFS, 
                         S1 != S2
        };

     rel[Stat,Def] IN = {};
     rel[Stat,Def] OUT = DEF;

     solve {
           IN  =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Stat P : predecessor(PRED,S), 
                            Def D : OUT[P]};
           OUT = {&lt;S, D&gt; |  int S : STATEMENT, 
                            Def D : DEF[S] union (IN[S] \ KILL[S])}
    };
    return IN;
}</programlisting></para>
    </section>

    <section>
      <title>Read-Eval-Print Loop (REPR)</title>

      <para>For the scripting of application it is important to have a command
      language and read-eval-print loop. Here is an attempt. The command
      prompt is "&gt;".<programlisting>&gt; import lang.java.syntax.Main as Java
&gt; str source := read("program.java");
&gt; CU program := Java.CU.parse(source);

&gt; accu int count(CU P, int cnt) {
&gt;   switch P {
&gt;     Java.Statements.IF =&gt; cnt++;
&gt;   }
&gt; }

&gt; count(program)
17</programlisting>There are several innovations here:</para>

      <itemizedlist>
        <listitem>
          <para>The import associates a name with the imported module.<note>
              <para>This means that "grammar" and "rule" become notions that
              can be manipulated.</para>
            </note></para>
        </listitem>

        <listitem>
          <para>There is a read functions that reads a text file into a
          string.<note>
              <para>We need an io library that reads/writes strings and data
              values.</para>
            </note></para>
        </listitem>

        <listitem>
          <para>We associate a parse function with every non-terminal in a
          grammar.</para>
        </listitem>

        <listitem>
          <para>The notation <literal>Java.Statements.IF</literal> consists of
          three parts:</para>

          <itemizedlist>
            <listitem>
              <para>Language name</para>
            </listitem>

            <listitem>
              <para>Sort name</para>
            </listitem>

            <listitem>
              <para>Rule name (currently implemented with the "cons"
              attribute).</para>
            </listitem>
          </itemizedlist>

          <para>It can be used as pattern. Other potential uses are as
          generator:<programlisting>{S | Java.Statements.IF S : P}</programlisting>It
          generates all if statements in P.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Outdated examples</title>

    <section>
      <title>Pico Typecheck using dynamically scoped variables
      (OUTDATED)</title>

      <para>The following example details the use of a dynscope global
      variable for building up and using an environment. Notice that we
      introduce <emphasis>void</emphasis> functions as a
      result.<programlisting>module Typecheck

imports Pico-syntax

hiddens

type Env = rel[PICO-ID,TYPE]

exports

fun Bool tc(PROGRAM P) {
    dyn Env Env := {};
    switch P {
      [| begin $Decls $Stats end |] =&gt; tcs(Stats)
         when Env := tcd(Decls)
    }
}

fun Env tcd(Decls Decls) {
    {&lt; Id, Type&gt; | [| $(PICO-ID Id) : $(TYPE Type) |] : Decls}
}

fun Bool tcs(Stats Stats) {
    Stat Stat;
    Stats Stats;
    switch (Stats) {
    [| |]                =&gt; true

    [| $Stat ; $Stats |] =&gt; tcst(Stat) + tcst(Stats)
    }
}

fun Bool tcst(Stat Stat) {
    Id Id;
    Exp Exp;
    Stats Stats, Stats1, Stats2;
    switch (Stat) {
      [| $Id := $Exp |] =&gt; type-of(Exp, Type)
         when {&lt;Id, Type&gt;} := Env[Id]

      [| if $Exp then $Stats1 else $Stats2y fi |] =&gt;
         type-of(Exp, natural) + tcs(Stats1) + tcs(Stats2)

      [| while $Exp do $Stats od |] =&gt;
         type-of(Exp, natural) + tcs(Stats)
    }
}

fun list[Error] type-of(Exp E, TYPE Type) {
    NatCon NatCon;
    StrCon StrCon;
    Id Id;
    Exp Exp;

    switch (E) {
      [| $NatCon |] =&gt; []
         when Type == natural

      [| $StrCon |] =&gt; []
         when Type == string

      [| $Id |] =&gt; [] 
         when {&lt;Id,Type2&gt;} := Env[Id],
              Type2 == Type
            
      [| $Exp |] =&gt; [error("Incorrect type")]
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico eval with dynamically scoped variables (OUTDATED)</title>

      <para>A Pico evaluator using dynamic variables. It still uses functions
      that return VEnvs (this is not consistent and should be changed).</para>

      <programlisting>fun VEnv evalProgram(Program p) {
    dyn VEnv venv;
    Decls decls;
    Series series;

    switch p {
      [| begin $decls $series end |] =&gt; evalStatements(series)
         when venv := evalDecls(decls);
    }
}

fun VEnv evalDecls(Decls decls) {
    Id-Type* idtypes;
    switch decls {
      [| declare $idtypes |] =&gt; evalIdTypes(idtypes)
    }
}

fun VEnv evalIdTypes(Id-Type* idtypes) {
    Id id;
    Id-Type* tail;
    switch idtypes { 
      [| $id : natural, $tail |] =&gt; store(evalIdTypes(tail),id,0)
  
      [| $id : string, $ tail |] =&gt; store(evalIdTypes(tail),id,"")

      [| |] =&gt; []
    }
}

fun VEnv evalStatements(Statement* series) {
    Statement stat; Statement* stats;
    switch series  {
      [| $stat; $stats |] =&gt; venv
         when venv := evalStatement(stat),
              venv := evalStatements(stats)
      [| |] =&gt; venv
    }
}

fun VEnv evalStatement(Statement stat) {
    Exp exp;
    Series series, series1, series2;
    
    switch stat {    
      [| if $exp then $series1 else $series2 fi |] =&gt; 
         evalStatements(series1)
         when evalExp(exp, venv) != 0

      [| if $exp then $series1 else $series2 fi |] =&gt; 
         evalStatements(series2)
         when evalExp(exp, venv) == 0
        
      [| while $exp do $series od |] =&gt; venv
         when evalExp(exp, venv) == 0

      
      [| while $exp do $series od |] =&gt; 
         evalStatement([|while $exp do $series od |])
         when evalExp(exp, venv) != 0,
              venv := evalStatements(series)
    }
}

fun VEnv evalExp(Exp exp) {
    Exp exp1, exp2;
    Natural nat1, nat2;
    StrCon str1, str2, str3;

    switch exp {
      [| $exp1 + $exp2 |] =&gt; nat1 + nat2
         when nat1 := eve(exp1),
              nat2 := eve(exp2)
       
      [| $exp1 - $exp2 |] =&gt; nat1 -/ nat2
         when nat1 := eve(exp1),
              nat2 := eve(exp2)
        
        
      [| $exp1 \|\| $exp2 |] =&gt; str3
         when str1 := eve(exp1),
              str2 := eve(exp2),
              str3 := concat(str1, str2)

      [| $exp1 |] =&gt; nil-value     %% default "equation"
   }
}</programlisting>
    </section>

    <section>
      <title>Generating Graph files in Dot format</title>

      <para>This example illustrates the use of a comprehension on the
      right-hand side of an equation.<programlisting>module Dot-generation

imports Dot-syntax

fun Dot gen-dot(rel[ID, ID] Rel) {
    [| digraph example {
                        $([ node(Tup) | &lt;ID,ID&gt; Tup : Rel ])
                       }
    |]
}

fun DotElem* gen-node(&lt;ID Id1, ID Id2&gt;) {
    [| node $Id1; node $Id2; $Id1 -&gt; $Id2 |}}
}</programlisting></para>
    </section>
  </section>

  <section>
    <title>Syntax Definition</title>

    <para>See separate SDF definition.</para>
  </section>

  <section xml:id="section.integration-tscript">
    <title>Integration with Tscripts (Outdated)</title>

    <note>
      <para>It is not yet clear whether we will also include Tscript in the
      integration effort. For the time being, this section is considered
      outdated.</para>
    </note>

    <section>
      <title>Introduction</title>

      <para>It is possible to speculate on an even further integration of
      formalisms and combining the above amalgan of ASF+SDF and Rscript with
      Tscripts.</para>
    </section>

    <section>
      <title>Requirements</title>

      <itemizedlist>
        <listitem>
          <para>R12: The resulting language uses a single type system. This
          means that relational types (possible including syntactic objects)
          can be used in Tscripts.</para>
        </listitem>

        <listitem>
          <para>R13: The current "expressions" in Tscript (terms that occur at
          the rhs of an assignment) are replaced by calls to ASF+SDF or
          Rscript functions.</para>
        </listitem>

        <listitem>
          <para>R14: There is minimal duplication in functionality between
          ASF+SDF/Rscript/Tscript.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Different styles of Type Declarations</title>

      <para>We have at the moment, unfortunately, a proliferation of
      declaration styles for types.</para>

      <para>Functions are declared in ASF+SDF as:</para>

      <programlisting>typecheck(PROGRAM) -&gt; Boolean</programlisting>

      <para>Observe that only the type of the parameter is given but that it
      does not have a name.</para>

      <para>In Rscript we have:</para>

      <programlisting>int sum(set[int] SI) = ...</programlisting>

      <para>while in Tscript processes are declared as</para>

      <programlisting>process mkWave(N : int) is ...</programlisting>

      <para>For variables a similar story applies. Variables are declared in
      ASF+SDF as:</para>

      <programlisting>"X" [0-9]+    -&gt; INT</programlisting>

      <para>In Rscript we have:</para>

      <programlisting>int X

int X : S   (in comprehensions)</programlisting>

      <para>and in Tscript we have:</para>

      <programlisting>X : int</programlisting>

      <para>In order to unify these styles, we might do the following:</para>

      <itemizedlist>
        <listitem>
          <para>The type of an entity is always written before the entity
          itself.</para>
        </listitem>

        <listitem>
          <para>Formal parameters have a name.</para>
        </listitem>
      </itemizedlist>

      <para>In essence, this amounts to using the declaration style as used in
      Rscript. So we get:</para>

      <programlisting>Boolean typecheck(PROGRAM P) is ...

process mkWave(int N) is ...</programlisting>

      <para>Or do we want things like:</para>

      <programlisting>function typecheck(P : PROGRAM) -&gt; Boolean is ...

var X -&gt; int

process mkWave(int N) is ...</programlisting>

      <para>Advantages are:</para>

      <itemizedlist>
        <listitem>
          <para>The category of the entity is immediately clear (function,
          var, process, tool, ...).</para>
        </listitem>

        <listitem>
          <para>It is readable to further qualify the category, i.e.,
          traversal function, hidden var, restartable tool)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Global Flow of Control</title>

      <para>We have to settle the possible flow of control between the three
      entities ASF+SDF, Rscript and Tscript. Since Tscript imposes the notion
      of an atomic action it would be problematic to have completely
      unrestricted flow of control. Therefore it is logical to use Tscript for
      the top-level control and to limit the use of ASF+SDF and Rscript to
      computations within atomic actions. There is no reason to restrict the
      flow of control between ASF+SDF and Rscript.</para>

      <para>What are the consequences of the above choice? Let's analyze two
      cases:</para>

      <itemizedlist>
        <listitem>
          <para>Parse a file from within an ASF+SDF specification. This (and
          similar built-ins) that use the operating system are removed from
          ASF+SDF. Their effect has to be achieved at the Tscript-level which
          is the natural place for such primitives.</para>
        </listitem>

        <listitem>
          <para>Describe I/O for a defined language. Consider Pico extended
          with a read statement. Here the situation is more complicated. We
          cannot argue that the flow of control in the Pico program (as
          determined by an interpreter written in ASF+SDF) should be moved to
          the Tscript level since Tscript simply does not have the primitives
          to express this. On the other hand, we have to interrupt the flow of
          control of the Pico interpreter when we need to execute a read
          statement. The obvious way to achieve this is</para>

          <itemizedlist>
            <listitem>
              <para>At the Tscript level, a loop repeatedly calls the Pico
              interpreter until it is done.</para>
            </listitem>

            <listitem>
              <para>After each call the Pico interpreter returns with
              either:</para>

              <itemizedlist>
                <listitem>
                  <para>An indication that the eecution is complete (and
                  possibly a final state and/or final value).</para>
                </listitem>

                <listitem>
                  <para>An indication that an external action has to be
                  executed, for instance the read statement. This indication
                  should also contain the intermediate state of the
                  interpreter. When the external action has been executed, the
                  Pico interpreter can be restarted with as arguments the
                  value of the external action and the intermediate
                  state.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Experimentation will have to show whether such a framework is
      acceptable.</para>
    </section>

    <section>
      <title>Modularization</title>

      <para>Rscript and Tscript have no, respectively, very limited mechanisms
      for modularization. ASF+SDF, however, provides a module mechanism with
      imports, hiding, parameters and renaming. This mechanism was originally
      included in ASF, was taken over by SDF and is now reused in ASF+SDF.
      Currently, there are not yet sufficiently large Rscripts to feel the
      need for modules. In Tscript, there is a strong need for restricted name
      spaces and for imposing limitations on name visibility in order to limit
      the possible interactions of a process with its surroundings and to make
      it possible to create nested process definitions. What are the design
      options we have to explore?</para>

      <para>First, we can design a new module system that is more suited for
      our current requirements. The advantage is that we can create an optimal
      solution, the disadvantage is that there are high costs involved
      regarding implementation effort and migrations of existing ASF+SDF
      specifications to the new module scheme.</para>

      <para>Second, we can design an add-on to the ASF+SDF module system that
      addresses our current needs.</para>

      <para>Third, we can try to reuse the current ASF+SDF module
      system.</para>

      <para>As a general note, parameterized modules, polymorphics types and
      renamings are competing features. We should understand what we want. It
      is likely that we do not need all of them.</para>

      <para>Before delving into one of the above alternative approaches, let's
      list our requirements first.</para>

      <itemizedlist>
        <listitem>
          <para>We need grammar modules that allow the following operations:
          import, renaming, deletion (currently not supported but important to
          have a fixed base grammar on many variations on it).
          Parameterization and export/hidden: unclear.</para>
        </listitem>

        <listitem>
          <para>We need function modules (ASF+SDF and Rscript) that provide:
          import, maybe parametrization, and export/hidden.</para>
        </listitem>

        <listitem>
          <para>We need process modules (Tscript) that provide: import,
          export, hiding.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Protyping/implementation of Rascal</title>

    <para>Every prototype will have to address the following issues:</para>

    <itemizedlist>
      <listitem>
        <para>Parsing/typechecking/evaluating Rascal.</para>
      </listitem>

      <listitem>
        <para>How to implement the relational operations.</para>
      </listitem>

      <listitem>
        <para>How to implement matching.</para>
      </listitem>

      <listitem>
        <para>How to implement replacement.</para>
      </listitem>

      <listitem>
        <para>How to implement traversals.</para>
      </listitem>
    </itemizedlist>

    <para>The following options should be considered:</para>

    <itemizedlist>
      <listitem>
        <para>Implementation of a typechecker in ASF+SDF:</para>

        <itemizedlist>
          <listitem>
            <para>Gives good insight in the type system and is comparable in
            complexity to the Rscript typechecker.</para>
          </listitem>

          <listitem>
            <para>Work: 2 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            ASF+SDF.</para>
          </listitem>

          <listitem>
            <para>Bound to be very slow.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of a typechecker in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Interesting exercise to asses Rascal.</para>
          </listitem>

          <listitem>
            <para>Not so easy to do without working Rascal
            implementation.</para>
          </listitem>

          <listitem>
            <para>Not so easy when Rascal is still in flux.</para>
          </listitem>

          <listitem>
            <para>Effort: 1 week</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Ditto.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Extending the current ASF+SDF interpreter.</para>

        <itemizedlist>
          <listitem>
            <para>This is a viable options. It requires extensions of
            AsFix.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Translation of Rascal to ASF+SDF in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Unclear whether this has longer term merit.</para>
          </listitem>

          <listitem>
            <para>Allows easy experimentation and reuse of current ASF+SDF
            implementation.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an interpreter in Java.</para>

        <itemizedlist>
          <listitem>
            <para>A future proof and efficient solution.</para>
          </listitem>

          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            Java.</para>
          </listitem>

          <listitem>
            <para>Effort: 8 weeks.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="section.issues">
    <title xml:id="Issues">Issues</title>

    <itemizedlist>
      <listitem>
        <para>See <xref linkend="section.patterns" /> for a description of
        patterns. There are still some questions about patterns:</para>

        <itemizedlist>
          <listitem>
            <para>Do we want the subexpressions in patterns? [Proposal: no
            since it complicates the syntax]</para>
          </listitem>

          <listitem>
            <para>Do we want string variables in patterns? [Undecided]</para>
          </listitem>

          <listitem>
            <para>Do we want to add regular expression matching primitives to
            patterns? Ex.</para>

            <itemizedlist>
              <listitem>
                <para><programlisting>[| if @any@ $Stats fi |]</programlisting></para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Dynamic variables need more thought; do we really want them?
        [Proposal: let's do without them.]</para>
      </listitem>

      <listitem>
        <para>The relation (no pun intended) between local variable
        declarations in functions, patterns and comprehensions has to be
        established.</para>
      </listitem>

      <listitem>
        <para>How do we identify built-in sorts (bool, int, etc) with their
        syntactic counterparts?</para>
      </listitem>

      <listitem>
        <para>What happens if no case in a switch matches? Some kind of
        failure? How does it propagate? Runtime error?</para>
      </listitem>

      <listitem>
        <para>In a list comprehension: do list values splice into the list
        result?</para>
      </listitem>

      <listitem>
        <para>Ditto for set comprehensions.</para>
      </listitem>

      <listitem>
        <para>Unexplored idea: add (possibly lazy) generators for all types;
        this allows to generate, for instance, all statements in a
        program.</para>
      </listitem>

      <listitem>
        <para>Shopping list of ideas in Tom:</para>

        <itemizedlist>
          <listitem>
            <para>Named patterns to avoid building a term, i.e. w@[| while
            $Exp do $stat od |].</para>
          </listitem>

          <listitem>
            <para>Anti-patterns, i.e. the complement of a patterns: ! [| while
            $Exp do $stat od |] matches anything but a while.</para>
          </listitem>

          <listitem>
            <para>Anonymous variables a la Prolog: [| while $_ do $stat od
            |].</para>
          </listitem>

          <listitem>
            <para>String matching in patterns.</para>
          </listitem>

          <listitem>
            <para>Tom uses the notation %[ ... ]% for quoted strings with
            embedded @...@ constructs that are evaluated. It also has a
            backquote construct.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Shopping list of ideas from TXL:</para>

        <itemizedlist>
          <listitem>
            <para>"redefine" allows modification of an imported
            grammar.</para>
          </listitem>

          <listitem>
            <para>An "any" sort that matches anything.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>
</article>