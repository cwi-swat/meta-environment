<?xml version="1.0" encoding="UTF-8"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Rascal Requirements and Design Document</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Tijs</firstname><surname>van der
        Storm</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is a braindump of ideas that is slowly converging to a
    coherent design. See <xref linkend="section.issues" /> for the issues that
    have to be resolved.</para>
  </note>

  <section>
    <title>Introduction</title>

    <para>We have identified the need for better language support for
    specifying and implementing software analysis and transformation tools. In
    this document we embark on a design of a domain-specific language that is
    intended to provide a comprehensive and easy to use set of concepts for
    that domain. The goals of the envisaged language (with working name
    Rascal) are:</para>

    <itemizedlist>
      <listitem>
        <para>Providing a successor of ASF+SDF that has of all its benefits
        and fixes all of its shortcomings.</para>
      </listitem>

      <listitem>
        <para>Separating pure syntax definitions (SDF) from function
        definitions.</para>
      </listitem>

      <listitem>
        <para>Easy syntax-directed analysis of programming languages.</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction.</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning.</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation.</para>
      </listitem>

      <listitem>
        <para>Efficient and scalable implementation.</para>
      </listitem>

      <listitem>
        <para>Unsurprising concepts, syntax and semantics for a wide audience.
        Where possible we will stay close to C and Java notation.</para>
      </listitem>
    </itemizedlist>

    <para>Many of the above goals are to a certain extent already met in the
    current design of ASF+SDF, and the current design of RScript. What is
    missing is the connection (and to be honest: an efficient implementation
    of relational operators). Alas, any bridge between the two languages is
    both complex to manage and an efficiency bottleneck. This work is an
    attempt to consolidate this engineering trade-off. This basically means
    that we include most features of the RScript language into ASF+SDF.
    Although we take these languages as conceptual starting point, Rascal is a
    completely new design that has an imperative semantics at it's core rather
    than a functional semantics. As a whole, Rascal is a simpler but more
    expressive language.</para>
  </section>

  <section>
    <title>Rascal for various audiences</title>

    <para>In this section we enumerate numerous facts about Rascal that
    advertise it to different audiences</para>

    <section>
      <title>Generic arguments</title>

      <para>What is good about Rascal in a few words?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is a DSL for source code analysis and transformation.
          It provides a pletora of high level statements and expressions,
          taking away the boilerplate of implementing and debugging tools that
          manipulate programs.</para>
        </listitem>

        <listitem>
          <para>Rascal combines the best features of imperative programming
          with the best features of functional programming and term rewriting.
          <itemizedlist>
              <listitem>
                <para>Simple structured statements for control flow and
                variable assignments for data flow are powerful and simple
                features of the imperative programming paradigm. They allow
                control flow and data flow to be understandable and
                traceable.</para>
              </listitem>

              <listitem>
                <para>From functional programming we borrow that all values
                are immutable and non-null. Issues with aliasing and
                referential integrity, such as frequently occur in imperative
                and OO programming therefore do not exist in Rascal.</para>
              </listitem>

              <listitem>
                <para>The Rascal type system is as powerful as most functional
                languages (higher-order polymorphic functions), however to
                make the language debuggable and understandable it, in
                principle, does not provide type inference.</para>
              </listitem>

              <listitem>
                <para>From term rewriting we inherit powerful pattern matching
                facilities, integration with context-free parsing and concrete
                syntax.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>

        <listitem>
          <para>Rascal supports both a scripting experience, and a compiled
          program experience.</para>
        </listitem>

        <listitem>
          <para>Rascal is type safe, but flexible. It's type system prevents
          common programming errors, but still allows ample opportunity for
          reusable code. The reasons are that we allow co-variance in the
          sub-typing relationship, high-order polymorphic functions and
          parameterized data-types.</para>
        </listitem>

        <listitem>
          <para>Rascal allows different styles of programming. From extremely
          high level specification, down to straight imperative
          programming.</para>
        </listitem>

        <listitem>
          <para>Rascal was inspired by and borrows from several other DSL's
          for program analysis and transformation in academia and industry,
          namely ASF+SDF, Rscript, TXL, TOM, DMS, Stratego, Elan, Maude, Grok,
          Haskell, ML and SETL.</para>
        </listitem>

        <listitem>
          <para>Rascal integrates seemlessly with Eclipse IMP and The
          Meta-Environment.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for ASF+SDF programmers</title>

      <para>Rascal is the successor of ASF+SDF. What's the difference? What's
      the same?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal has roughly all the high level features of ASF+SDF and
          some more. Old ASF+SDF specifications can be transformed to Rascal
          programs using a conversion tool.</para>
        </listitem>

        <listitem>
          <para>Rascal still uses SDF for syntax definition and parser
          generation.</para>
        </listitem>

        <listitem>
          <para>Rascal has a module system that is independent of SDF. Rascal
          modules introduce a namespace scope for variables and functions,
          which can be either private or public. Rewrite rules are global as
          in ASF+SDF. Modules can have type parameters as in SDF, which are
          instantiated by import statements.</para>
        </listitem>

        <listitem>
          <para>In Rascal, patterns and variables in concrete syntax may
          optionally be quoted and escaped, and support explicit declaration
          of the top non-terminal to solve ambiguity.<caution>
              <para>How?</para>
            </caution></para>
        </listitem>

        <listitem>
          <para>In ASF+SDF the execution order of the elements of equations is
          left-hand side (for matching), conditions, and right-hand side (for
          constructing a normal form). In Rascal the elements of rules read in
          a more natural order that corresponds with the order of
          execution.</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive and efficient implementations for sets,
          relations and maps</para>
        </listitem>

        <listitem>
          <para>Rascal can be used without SDF, supporting for example regular
          expressions and abstract data types (pure ATerms)</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive support for functions, which have a fixed
          syntax, always return a value and have a body consisting of
          imperative control flow statements. Adding a function will not
          trigger the need for regenerating parse tables as is the case in the
          current ASF+SDF implementation. Function types can be polymorphic in
          their parameters and also allow functions as arguments to implement
          reusable algorithms.</para>
        </listitem>

        <listitem>
          <para>The imperative nature of Rascal allows you to factor out
          common code and nest conditionals, unlike in ASF+SDF where
          alternative control flow paths have to be encoded by enumerating
          equations with non-overlapping conditions.</para>
        </listitem>

        <listitem>
          <para>Rascal is an imperative language, which natively supports I/O
          and other side-effects without work-arounds. When backtracking
          occurs, for example during list matching, Rascal makes sure that
          <emphasis role="bold">most</emphasis> side-effects are undone, and
          that I/O is delayed until no more backtracking can occur. Even
          rewrite rules support side-effects in Rascal.<caution>
              <para>Clarify the above.</para>
            </caution></para>
        </listitem>

        <listitem>
          <para>Rascal has native support for traversals, instead of the
          add-on it used to be in ASF+SDF. The visit statement is comparable
          to a traversal function, and is as type-safe as the previous, and
          more programmeable.</para>
        </listitem>

        <listitem>
          <para>Instead of accumulator values of traversal functions in
          ASF+SDF, Rascal simply supports lexically scoped variables that can
          be updated using assignments.</para>
        </listitem>

        <listitem>
          <para>Rascal adds specific expressions for relational calculus, all
          borrowed directly from RScript.</para>
        </listitem>

        <listitem>
          <para>When programming using Rascal functions, instead of rules, the
          control flow of a program becomes easily traceable and debuggable.
          It is simply like stepping through well structured code.</para>
        </listitem>

        <listitem>
          <para>Rascal is based on a Java interpreter, or a Java run-time when
          compiled. So the code is more portable.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for imperative and object-oriented programmers</title>

      <para>Rascal is an imperative DSL with high level statements and
      expressions specifically targeted at the domain of analysis and
      transformation of source code:</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is safe: there are no null values, and all values are
          immutable. Source code and abstract syntax trees, and the facts
          extracted from them are immutable. The Rascal interpreter and
          compiler make sure this is implemented efficiently. Without
          mutability it is easy to combine stages of your programs that
          analyse or annotate with stages that transform. Sharing a value does
          not introduce a coupling like in OO, simply because changes are only
          visible to the code that changes the values.</para>
        </listitem>

        <listitem>
          <para>Rascal is extra safe: it has a type system that prevents
          casting exceptions and other run-time failures. Still the type
          system specifically allows many kinds of combinations. For example,
          unlike in Java a set of integers is a subtype of a set of numbers
          (co-variance), which allows you to reuse algorithm for sets of
          numbers on sets of integers. It also provides true polymorphic and
          functions (no erasure), and functions can safely be parameters to
          other functions.</para>
        </listitem>

        <listitem>
          <para>Rascal provides high level statements and expressions
          for:</para>

          <itemizedlist>
            <listitem>
              <para>Visitors in all kinds of orders, expressed very concisely,
              and type safe.</para>
            </listitem>

            <listitem>
              <para>Pattern matching and construction (with concrete
              syntax!)</para>
            </listitem>

            <listitem>
              <para>Equation/constraint solving</para>
            </listitem>

            <listitem>
              <para>Relational calculus</para>
            </listitem>

            <listitem>
              <para>Rewrite rules for normalization/canonicalization of any
              kind of data-structure</para>
            </listitem>

            <listitem>
              <para>Support for parsing using context-free grammars (via
              importing modules from the SDF language).</para>
            </listitem>

            <listitem>
              <para>(de)Serialization of values</para>
            </listitem>

            <listitem>
              <para>Communication with databases</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Rascal provides typed data constructors for common
          mathematical structures, such as:</para>

          <itemizedlist>
            <listitem>
              <para>terms (a.k.a. abstract data types, tree nodes)</para>
            </listitem>

            <listitem>
              <para>parse trees (derivations of context-free grammars, for
              concrete syntax and direct manipulation of source code)</para>
            </listitem>

            <listitem>
              <para>relations</para>
            </listitem>

            <listitem>
              <para>sets</para>
            </listitem>

            <listitem>
              <para>maps</para>
            </listitem>

            <listitem>
              <para>graphs</para>
            </listitem>

            <listitem>
              <para>tuples</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>In Rascal you can implement high-fidelity source-to-source
          transformations. Without too much overhead, programs can do
          extensive rewriting of the source code without the loss of
          particular layout standards or source code comments.</para>
        </listitem>

        <listitem>
          <para>Rascal is syntax-safe. When you use Rascal to generate or
          transform source code, it statically detects whether the resulting
          source code is syntactically correct.</para>
        </listitem>

        <listitem>
          <para>Rascal is executed by an interpreter written in Java, or it
          can be compiled to Java classes.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Old ASF+SDF programs are translatable to Rascal.</para>
        </listitem>

        <listitem>
          <para>R3: Edit Rascal and SDF and compile complex programs within a
          few minutes maximally (parsetable generation is a major bottleneck
          in current ASF+SDF. This needs to be fixed.)</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability and easy parsing of a
          wide range of source languages.</para>
        </listitem>

        <listitem>
          <para>R5: File I/O.</para>
        </listitem>

        <listitem>
          <para>R6: Easily accessible fact storage (similar to a heap, but
          remember the details of backtracking, see R19).</para>
        </listitem>

        <listitem>
          <para>R7: List matching (because of R2, also very handy for
          manipulating lists in concrete syntax).</para>
        </listitem>

        <listitem>
          <para>R8: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as scoping),
          allowing to factor out common code.</para>
        </listitem>

        <listitem>
          <para>R9: Syntax trees can be elements of the builtin
          data-structures (but not vice versa).</para>
        </listitem>

        <listitem>
          <para>R10: Try to keep features orthogonal: try to keep the number
          of ways to write down a program minimal, this is not a law since
          other requirements take precedence</para>
        </listitem>

        <listitem>
          <para>R11: Minimize possible syntactic ambiguities; resolve them by
          type checking.</para>
        </listitem>

        <listitem>
          <para>R12: Integrates well with refactoring infra-structure (i.e.
          can provide appropriate interfaces with pre-condition checking,
          previews and commits as found in interactive refactoring
          contexts)</para>
        </listitem>

        <listitem>
          <para>R13: No 'null' values, preventing common programming
          errors</para>
        </listitem>

        <listitem>
          <para>R14: All values immutable, preventing common programming
          errors and allowing for certain kinds of optimizations</para>
        </listitem>

        <listitem>
          <para>R15: Should be able to match and construct strings using
          regular expressions (for making the simpler things simple, if you
          can do without a grammar, why not?)</para>
        </listitem>

        <listitem>
          <para>R16: Can get/set data from databases, such as the pdb from
          Eclipse IMP, but possibly also from ODBC/JDBC data sources.</para>
        </listitem>

        <listitem>
          <para>R17: Type safe, but flexible. We want a type system that
          prevents common programming errors, but still allows ample
          opportunity for reuse.</para>
        </listitem>

        <listitem>
          <para>R18: Syntax safe, programmers should not be allowed to
          construct programs that are syntactically incorrect w.r.t a certain
          context-free grammar.</para>
        </listitem>

        <listitem>
          <para>R19: Backtracking safe, programmers should not have to deal
          with the mind boggling feature interactions between side-effects and
          backtracking.</para>
        </listitem>

        <listitem>
          <para>R20: Traceable/debuggable, programmers should be able to
          easily trace through the execution of a Rascal program using the
          simplest of debugging tools, like printf statements, and the use of
          a simple debugging interface which allows to step through the source
          code and inspect values in a transparent fashion.</para>
        </listitem>

        <listitem>
          <para>R21: Minimize the use of type inference, such that the
          programmer must always declare her intentions by providing types for
          functions, data-types and variables. This makes debugging easier and
          providing clear error messages too. When variables are implicitly
          bound by pattern matching or related functionality, exceptions to
          this requirement might be made in favor of conciseness.</para>
        </listitem>

        <listitem>
          <para>R22: Allow the implementation of reusable modules and
          functions (i.e. parametric polymorphism and or functions as
          parameters).</para>
        </listitem>

        <listitem>
          <para>R23: We need something like rewrite rules for implementing
          data-types that are always canonicalized/normalized. For some
          analysis algorithms this allows the programmer to implement domain
          specific optimizations over plain relational calculus or tree
          visiting that actually needed for scalability.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Rascal at a glance</title>

    <para>Rascal consists of the following elements:</para>

    <itemizedlist>
      <listitem>
        <para>Modules to group definitions, proving scopes and visibility
        constructs.</para>
      </listitem>

      <listitem>
        <para>A type system and corresponding values, providing parameterized
        types, polymorphic functions and higher-order parameters.</para>
      </listitem>

      <listitem>
        <para>Variables to associate a name with a value in some scope.</para>
      </listitem>

      <listitem>
        <para>Parameterized functions.</para>
      </listitem>

      <listitem>
        <para>Abstract patterns, regular expression patterns and syntax
        patterns to deconstruct (match) values and to construct (make)
        them.</para>
      </listitem>

      <listitem>
        <para>Expressions provide the elementary computations on
        values.</para>
      </listitem>

      <listitem>
        <para>Statements provide structured control flow and more advanced
        control flow in computations, such as visitors and fixed point
        computations</para>
      </listitem>
    </itemizedlist>

    <para>These elements are summarized in the following subsections.</para>

    <section>
      <title>Modules</title>

      <para>Modules are the organizational unit of Rascal. They may:</para>

      <itemizedlist>
        <listitem>
          <para>Import another Rascal module (suffix: <literal>.ras</literal>)
          using <literal>import</literal>. Imports are not transitive. We do
          allow circular imports.</para>
        </listitem>

        <listitem>
          <para>Import SDF modules (suffix: <literal>.sdf</literal>) using
          <literal>import</literal>.</para>
        </listitem>

        <listitem>
          <para>Import Java modules (for the benefit of functions written in
          Java, suffix <literal>.java</literal>) using
          <literal>import</literal>.</para>
        </listitem>

        <listitem>
          <para>Extend another Rascal module using <literal>extend</literal>.
          This includes a verbatim copy (similar to
          <literal>#include</literal>) of the-module-to-be-extended in the
          current module. We allow redefinitions of declared names. We do not
          allow circular extension.</para>
        </listitem>

        <listitem>
          <para>Define data, views on data, types, rules or functions.</para>
        </listitem>

        <listitem>
          <para>Be parameterized with the names of formal types that are
          instantiated with an actual type when the module is imported.</para>
        </listitem>

        <listitem>
          <para>Contain a main function that is the starting point of
          execution. We allow several flavours of main
          function:<programlisting>public void main() { ... }</programlisting>does
          not give access to program arguments while<programlisting>public void main(list[str] argv) { ... }</programlisting></para>

          <para>gives access to all program arguments. We may add extra types
          that help in parsing command line arguments.</para>
        </listitem>
      </itemizedlist>

      <para>Declarations may be either private to a module or public to all
      modules that import the current module. Rules are always public and are
      globally applied.</para>

      <para>Modules introduce a namespace and qualified names (using the
      <literal>::</literal> operator) may be used to uniquely identify
      elements of a module from the outside. Inside the module, this
      qualification is implicit. The qualified name consist of two parts: a
      directory name (a list of names separated by <literal>/</literal>) and a
      module name.</para>

      <para>Rascal modules are located in a file with the name of the module,
      with suffix <literal>.ras</literal>. They should be located in a
      directory corresponding to the directory part of the module name. From
      other modules,
      <literal><replaceable>M</replaceable>::<replaceable>F</replaceable></literal>
      denotes function <replaceable>F</replaceable> from module
      <replaceable>M</replaceable>.</para>
    </section>

    <section>
      <title>Names</title>

      <para>Rascal aims at seamless integration with Java and its names adhere
      to the following conventions:</para>

      <itemizedlist>
        <listitem>
          <para>A Rascal Name is identical to a Java Indentifier except that
          we <emphasis>do</emphasis> allow -- for reasons of compatibility
          with names in SDF -- dashes (<literal>-</literal>) but do
          <emphasis>not</emphasis> allow the dollar sign
          (<literal>$</literal>) in names. In the initial implementation all
          reserved words in both Java and Rascal cannot be used as a Name.
          <remark>For better syntax errors it is probably better to warn for
          Java keywords later on.</remark></para>
        </listitem>

        <listitem>
          <para>Sorts and Symbols are inherited from SDF but we extend sort
          (that may only start with an uppercase letter in SDF) to be a more
          liberal, and allow Names instead.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Types and Subtypes</title>

      <section>
        <title>Types</title>

        <para>The type system (and notation) are mostly similar to that of
        Rscript, but</para>

        <itemizedlist>
          <listitem>
            <para>We have a type hierarchy that defines a partial order on
            types.</para>
          </listitem>

          <listitem>
            <para>There is a single top for this type hierarchy, it is called
            "<literal>value</literal>" and a single bottom that is called
            "<literal>void</literal>".</para>
          </listitem>

          <listitem>
            <para>There are built-in types (<literal>bool</literal>,
            <literal>int</literal>, <literal>double</literal>,
            <literal>str</literal>, <literal>loc</literal>).</para>
          </listitem>

          <listitem>
            <para>Symbols (as defined by an SDF module) are also types.<note>
                <para>The currently supported subset of SDF symbols contains:
                single and double quoted literal, character class, sort name,
                lists with and without separator, alternative, and option.
                This subset will be extended on demand.</para>
              </note><note>
                <para>There is no automatic mapping between the built-in types
                and types generated by an SDF module. The programmer is
                responsible for conversion. Typical library functions that are
                helpfull are:</para>

                <itemizedlist>
                  <listitem>
                    <para><literal>unparseToString</literal> converts any
                    value of an SDF type to a string.</para>
                  </listitem>

                  <listitem>
                    <para><literal>toInt</literal> converts strings to
                    integers.</para>
                  </listitem>

                  <listitem>
                    <para><literal>toDouble</literal> converts strings to
                    doubles.</para>
                  </listitem>
                </itemizedlist>
              </note></para>
          </listitem>

          <listitem>
            <para>All syntactic types are a subtype of the type
            <literal>tree</literal> that corresponds to an Universal Parse
            Tree Representation (UPTR). We will use AsFix as UPTR. Up casts
            from a subtype to an enclosing type are automatic. The type
            <literal>tree</literal> is "special" in the following
            sense:</para>

            <itemizedlist>
              <listitem>
                <para>Parsers generate values of type
                <literal>tree</literal>.</para>
              </listitem>

              <listitem>
                <para>Although the type <literal>tree</literal> can be defined
                in Rascal, its definition is built-in in order to preserve the
                consistency with the parser.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Types for sets, maps, relations and tuples can be formed
            from types; Maps, relations and tuples can have optional column
            names. Note that a map resembles a function and differs from a
            binary relation: for each domain value in a map only a single
            range value is allowed.</para>
          </listitem>

          <listitem>
            <para>Functions can be polymorphic in their parameters as well as
            in their return type.</para>
          </listitem>

          <listitem>
            <para>Function parameters can be function types, meaning that the
            name of a properly typed function or a locally defined anonymous
            function can be passed as a parameter.</para>
          </listitem>

          <listitem>
            <para>The last parameter of a function may be of the form
            <literal>list[<replaceable>T</replaceable>]
            <replaceable>Name</replaceable>...</literal> and indicates a
            variable list of remaining parameters of type
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para>Data declarations may introduce new structured types and
            have the form<programlisting>data N Pat1 | Pat2 | ...</programlisting>where
            N is the name of the datatype and Pat1, Pat2, are prefix patterns
            describing the variants of the datatype. For instance,
            <programlisting>data Bool btrue | bfalse | band(Bool L, Bool R)  | bor(Bool L, Bool R);  </programlisting>defines
            the datatype <literal>Bool</literal> that contains various
            constants and constructor functions.<note>
                <para>We assume that all constructors for a datatype lead to a
                corresponding function to construct a term of that datatype.
                This eliminates the need to quote abstract terms in
                statements.</para>
              </note></para>

            <note>
              <para>Constructor names of datatypes may be quoted in order to
              avoid clashes with reserved words or illegal names.</para>
            </note>
          </listitem>

          <listitem>
            <para>We have <emphasis>views</emphasis> on data types that define
            templates or overlays over an existing type. A view defines a
            (possibly complex) pattern that matches the structure of another
            datatype. A view provides an alternative (and possibly simplified)
            access mechanism for existing data structures. A standard example
            is to define a view on a parse tree that suppresses all auxiliary
            information and better reflects the actual abstract tree that is
            represented as in<programlisting>view Bool &lt;: tree and appl(...) | or appl(...)</programlisting></para>

            <para>This defines the type <literal>Bool</literal> as a view on
            trees with two alternatives named <literal>and</literal> and
            <literal>or</literal>. Each view should be of type
            <literal>tree</literal>. Views for the same type are
            exclusive.</para>
          </listitem>

          <listitem>
            <para><caution>
                <para>Maybe, the following needs further discussion.</para>
              </caution>Parse trees are implicitly defined by a data
            declaration and we provide APIGEN-like functionality to access
            their elements by automatically providing views for each SDF
            rule:</para>

            <itemizedlist>
              <listitem>
                <para>Elements of an SDF syntax rule may be explicitly
                labelled as in:<programlisting> lhs1:EXP "+" lhs2:EXP -&gt; EXP {left}</programlisting>In
                this case the selectors <literal>lhs1</literal> and
                <literal>lhs2</literal> are provided that can be used to
                select (or replace) one of the subtrees of this rule.</para>
              </listitem>

              <listitem>
                <para>If these labels are absent, an automatic naming scheme
                is used:</para>

                <itemizedlist>
                  <listitem>
                    <para>For each sort in the SDF rule, a selector with the
                    same name is provided.</para>
                  </listitem>

                  <listitem>
                    <para>Syntactic lists get the name of the element sort,
                    followed by "<literal>-list</literal>".</para>
                  </listitem>

                  <listitem>
                    <para>Optionals get the name of the element sort, followed
                    by "<literal>-opt</literal>".</para>
                  </listitem>
                </itemizedlist>

                <para>In case there are more occurrences of the same syntactic
                element, the provided selector names are consecutively
                numbered, e.g., <literal>EXP1</literal>,
                <literal>EXP2</literal> or <literal>STATEMENT-list1</literal>,
                <literal>STATEMENT-list2</literal>.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Types may include type variables like
            <literal>&amp;<replaceable>T</replaceable></literal> as in Rscript
            with the following refinement:</para>

            <itemizedlist>
              <listitem>
                <para>In the type
                <literal>rel[&amp;<replaceable>*T</replaceable>]</literal>,
                the type variable
                <literal>&amp;<replaceable>T</replaceable></literal> is bound
                to the tuple type of the relation, i.e. an actual type
                <literal>rel[int,str]</literal> will bind
                &amp;<replaceable>*T</replaceable> to the type
                <literal>tuple[int,str]</literal>.</para>
              </listitem>

              <listitem>
                <para>Composition of tuple types is only allowed in the result
                type.</para>
              </listitem>

              <listitem>
                <para>In a similar fashion, in
                <literal>map[&amp;<replaceable>*T</replaceable>]</literal>,
                the type variable
                <literal>&amp;<replaceable>*T</replaceable></literal> is bound
                to the tuple type of the map.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>A type declaration introduces a name for a new type that is
            a subtype of a given type, e.g.,<programlisting>type rel[node,node] Graph</programlisting>introduces
            the type <literal>Graph</literal> as a subtype of
            <literal>rel[node,node]</literal>. There are no built-in
            subtypes.</para>
          </listitem>

          <listitem>
            <para>The name that is introduced by a type declaration may even
            be parameterized with one or more type variables,
            e.g.,<programlisting>type rel[&amp;Node, &amp;Node] Graph[&amp;Node]</programlisting></para>

            <para>Of course, the type variables that are used in the type in
            the left part should occur as parameters in the right part of the
            definition and vice versa.</para>
          </listitem>

          <listitem>
            <para>Types may be declared only once and are mutually
            exclusive.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Subtypes</title>

        <para>The type hierarchy leads to a subtype relation &lt;: that can be
        defined (in ASF+SDF) as follows:<programlisting>%% Subtyping rules (&lt;:) on Types

[let00] void &lt;: T                          = true

[let01] T &lt;: value                         = true

[let02] T &lt;: T                             = true

[let03] T &lt;: &amp; N                           = true

[let04] T &lt;: &amp;N &lt;: T'                      = T &lt;: T'

[let05] N[&amp;T] &lt;: N[&amp;U]                     = true

[let06] list[T] &lt;: list[T']                = T &lt;: T'

[let07] set[T] &lt;: set[T']                  = T &lt;: T'

[let08] tuple[ONTs] &lt;: tuple[ONTs']        = ONTs &lt;: ONTs'

[let09] map[T1, T2] &lt;: map[T1', T2']       = T1 &lt;: T1' &amp;  T2 &lt;: T2'

[let10] map[T1, T2] &lt;: rel[T1', T2']       = T1 &lt;: T1' &amp;  T2 &lt;: T2'

[let11] rel[ONTs] &lt;: rel[ONTs']            = ONTs &lt;: ONTs'

[let12] rel[ONTs] &lt;: set[tuple[ONTs']]     = ONTs &lt;: ONTs'

[let13] set[tuple[ONTs]] &lt;: rel[ONTs']     = ONTs &lt;: ONTs'

[let14] T &lt;: T' == true,        %% covariant
        ONTs' &lt;: ONTs == true   %% contravariant
        =========================================
        fun T N (ONTs) &lt;: fun T' N (ONTs') = true
[default-let]
        T &lt;: T'                            = false
</programlisting></para>

        <para>Here T, T1, T2, T' etc represent types, and ONTs, ONTs' etc
        represented lists of OptionallyNamedTypes, e.g., a type that
        optionally followed by a name. We omit the definition of &lt;= on
        OptionallyNamedTypes. The above rules also describe certain
        equivalences between types, e.g., a map can be compared with a
        relation, a relation can be compared with a set of tuples, and the
        like.</para>

        <para>We throw the names in types away in the subtype relation.</para>

        <para>The subtyping relation for function types is tricky and treats
        result type and argument types differently. We have, for instance,
        that</para>

        <para><programlisting>set[int] f(int i) &lt;: fun set[&amp;T] f(int i)  %% since int &lt;: &amp;T

int f(number x) &lt;: fun number f (int x)    %% assuming int &lt;: number</programlisting>but
        <emphasis>not</emphasis> that</para>

        <para><programlisting>number f(int x) &lt;: fun number f (number x) %% assuming int &lt;: number</programlisting></para>

        <para>In addition to the above rules for subtyping, each type
        definition introduces an additional subtype relation, e.g., the
        previous definition for Graph, <programlisting>type rel[node,node] Graph</programlisting></para>

        <para>introduces the following subtype relation:<programlisting>Graph &lt;: rel[node,node]</programlisting></para>
      </section>
    </section>

    <section>
      <title>Type Equivalence</title>

      <para>Types are compatible if they occur on the same path from void to
      value in the type lattice. This is a middle road between structural and
      nominal type equivalence, we call it <emphasis>intensional structural
      type equivalence</emphasis>. An example can illustrate this. Assume we
      have the following definitions for general graphs, control flow graphs
      and data flow graphs:<programlisting>type rel[node,node] Graph
type Graph CFGraph
type Graph DFGraph</programlisting></para>

      <para><literal>CFGraph</literal> and <literal>Graph</literal> are
      compatible, and the same holds for <literal>DFGraph</literal> and
      <literal>Graph</literal>. This implies that the types
      <literal>CFGraph</literal> and <literal>Graph</literal> (resp.
      <literal>DFGraph</literal> and <literal>Graph</literal>) can be freely
      passed as parameter, assigned, returned and value. This is, however, not
      true for CFGraph and DFGraph since they are incompatible. Passing a
      value from the one to the other type can only be done via the common
      type <literal>Graph</literal>. This uncomventional type scheme allows
      flexible conversion between subtypes (without casting or runtime checks)
      while preserving the opaqueness of disjoint subtypes of the same
      ancestor type.</para>
    </section>

    <section>
      <title>Attributes</title>

      <para>Attributes are adornments of data and programs and come in two
      flavours:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>value annotations</emphasis> that allow associating
          one or more named values to another value.</para>
        </listitem>

        <listitem>
          <para><emphasis>declaration tags</emphasis> that allow associating
          one or more named values to a declaration in a Rascal
          program.</para>
        </listitem>
      </itemizedlist>

      <para>The former are intended to attach application data to values, like
      adding position information or control flow information to source code
      or adding visualization information to a relation. The latter are
      intended to add metadata to a Rascal program and allow to influence the
      execution of the Rascal program, for instance, by adding memoization
      hints or database mappings for relations.</para>

      <section>
        <title>Value annotations</title>

        <para>Annotations may be associated with any value and are represented
        by a mapping of type <literal>map[str,Type]</literal>, i.e.,
        annotation names are strings and annotation values are values of a
        type that is explicitly declared. Any value of any named type can be
        annotated and the type of these annotations can be declared precisely.
        For instance, we can add to the graph datatype introduced earlier, the
        annotation with name <literal>LayoutStrategy</literal> that defines
        which graph layout algorithm to apply to a particular graph,
        e.g.,<programlisting>anno Graph LayoutStrategy "dot" | "tree" | "force" | 
                          "hierarchy" | "fisheye"</programlisting></para>

        <para>Note that the type that can be used in annotation declaration is
        identical to a type used in a data declaration. In a similar way, we
        can add to certain syntactic constructs of programs (e.g.,
        <literal>STATEMENT</literal>) an annotation with name
        <literal>posinfo</literal> that contains location
        information:<programlisting>anno STATEMENT posinfo loc</programlisting>or
        location information could be added for all syntax
        trees:<programlisting>anno tree posinfo loc</programlisting></para>

        <para>. The folllowing two operators are provided for handling
        annotations:</para>

        <itemizedlist>
          <listitem>
            <para><literal><replaceable>Val</replaceable> @
            <replaceable>Anno</replaceable></literal>: retrieves the value of
            annotation <replaceable>Anno</replaceable> of value
            <replaceable>Val</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal><replaceable>Var</replaceable> @
            <replaceable>Anno</replaceable> =
            <replaceable>Val</replaceable></literal>: set the value of
            annotation <replaceable>Anno</replaceable> of the value of
            variable <replaceable>Var</replaceable> to
            <replaceable>Val</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Declaration tags</title>

        <para>All declarations in a Rascal program may contain (in fixed
        positions depending on the declaration type) one or more declaration
        tags (<literal>tag</literal>). A tag is defined by declaring its name,
        the declaration type to which it can be attached, and the name and
        type of the annotation. The declaration type <literal>all</literal>,
        makes the declaration tag applicable for all possible declaration
        types. All declaration tags have the generic format
        <literal>@<replaceable>Name</replaceable>{ ... }</literal>, with
        arbitrary text between the brackets that is further constrained by the
        declared type. Here is an example of a license tag:<programlisting>tag module license str</programlisting>This
        will allow to write things like:<programlisting>module Booleans
@license{This module is distributed under the GPL}
...</programlisting>Other examples of declaration tags are:<programlisting>tag all todo str             %% a todo note for all declaration types
tag function deprecated void %% marks a deprecated function
tag function memo int        %% bounded memoization of 
                             %% function calls
tag all doc str              %% documentation string
tag function primitive str   %% a primitive, built-in, function</programlisting>Here
        are two examples from the standard library:<programlisting>public &amp;T first(list[&amp;T] L)
  throws empty_list(str msg)
  @doc{First element of list: first}
  @primitive{"List.first"}

public &amp;T max(set[&amp;T] R)
  @doc{Maximum of a set: max}
{
  &amp;T result = arb(R);
  for(&amp;T E : R){
    result = max(result, E);
  }
  return result;
}</programlisting></para>
      </section>
    </section>

    <section>
      <title>Variables</title>

      <para>Variables are names that have an associated scope and in that
      scope they have a value. A variable declaration consists of a type
      followed by the variable name and---depending on the syntactic
      position---they are followed by an initialization. There are no null
      values, which implies that all variables must be initialized at
      declaration time. Also, this implies that all expressions must return a
      value. Especially for functions, this means that all execution paths of
      a function must have a return statement.</para>

      <para>Variables may be introduced at the following syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para>As formal parameters of a function. Their scope is the
          function and they get their initial value when the function is
          called.</para>
        </listitem>

        <listitem>
          <para>Local variables in a function body are declared and
          initialized. Their scope is the function body.</para>
        </listitem>

        <listitem>
          <para>Variables in patterns. For patterns in match positions,
          <emphasis>declared</emphasis> variables are initialized during the
          match and their scope is the rule in which they occur. For
          <emphasis>used</emphasis> variables, their value is substituted
          during the match.</para>
        </listitem>

        <listitem>
          <para>For variables introduced by pattern matching in conditional
          statements (if-then, and while), if the condition succeeds, the
          scope of the variables are the block of code that is executed
          conditionally.</para>
        </listitem>

        <listitem>
          <para>Variables in anti-patterns are never visible, but nevertheless
          their names are reserved in the scope that they would have had when
          the pattern was a normal positive matching pattern.</para>
        </listitem>

        <listitem>
          <para>Variables that are introduced by generators in comprehensions
          or for statement, have the comprehension, respectively, for
          statement as scope.</para>
        </listitem>

        <listitem>
          <para>Global variables are declared and ALWAYS initialized at the
          top level of each module and <emphasis role="bold">these
          initialization may not contain circular calls.</emphasis></para>
        </listitem>

        <listitem>
          <para>Functions that use a global variable have to be explicitly
          declare it as well. The value of a global variable can be used and
          replaced by all functions that have locally declared it.<caution>
              <para>Bas: Shadowing?</para>
            </caution></para>
        </listitem>
      </itemizedlist>

      <para>We will see below that there are certain contexts in which
      assignments to variables are undone in the case of failure.</para>
    </section>

    <section>
      <title>Functions</title>

      <section>
        <title>Overview</title>

        <para>A function declaration consists of a visibility declaration,
        result type, a function name, typed arguments and a function body.
        Functions without a result type have type
        <literal>void</literal>.</para>

        <para>A visibility declaration is one of the keywords
        <literal>public</literal> or <literal>private</literal>
        (default).</para>

        <para>A function body is a list of statements, each terminated by a
        semi-colon. Each unique control flow path through a function must have
        a return statement, such that each function always returns a proper
        value.</para>

        <para>Functions can raise exceptions and these may -- for
        documentation purposes -- optionally be declared as part of the
        function signature (i.e., we have unchecked exceptions in contrast
        with checked exceptions in Java).</para>

        <para>Functions with the tag "<literal>java</literal>" have a body
        written in Java. They have the following properties:</para>

        <itemizedlist>
          <listitem>
            <para>Arguments and result are pure Rascal values.</para>
          </listitem>

          <listitem>
            <para>Java functions cannot acces the global state of the Rascal
            program. Their only interface is via input parameters and a result
            value. They cannot access Rascal global variables.</para>
          </listitem>

          <listitem>
            <para>Side effects caused by Java functions in the Java state, are
            not undone in the case of backtracking.</para>
          </listitem>
        </itemizedlist>

        <note>
          <para>These Java functions are primarily intended for implementing
          library functions and for interfacing with Eclipse.</para>
        </note>

        <para>Functions with the tag <literal>@memo</literal> are memo
        functions that cache previous arguments/result combinations.</para>
      </section>

      <section>
        <title>Overloading</title>

        <para>Functions may be <emphasis>overloaded</emphasis>, i.e.,
        functions with the same name but with different argument and result
        types can be declared. Overloading is subject to the restriction that
        if several versions of a function are declared with the same name,
        then one or more of the following conditions should hold:</para>

        <itemizedlist>
          <listitem>
            <para>the number of parameters differs;</para>
          </listitem>

          <listitem>
            <para>there is at least one parameter position with incomparable
            types w.r.t. the type hierarchy, i.e., not (A &lt;: B) and not
            (B&lt;:A).</para>
          </listitem>
        </itemizedlist>

        <para>The result type does not play a role in these conditions and
        overloading on result types is thus forbidden.</para>

        <para>Here are some examples.</para>

        <para><programlisting>%% OK, since int and double are incomparable 

int +(int a, int b) { ... }
double +(double a, double b) { ... }

%% NOT OK, since int is comparable to value 
%% (int is -- like all types -- a subtype of value)

int +(value a, value b) { ... }
int +(int a, int b) { ... }

%% OK since for every two definitions selected from this
%% set there is at least one parameter position different;
%% in this example the overloading on result types will never 
%% be used to select the function

int    +(int a, int b)
double +(int a, double b)
double +(double a, int b)
double +(double a, double b)

%% NOT OK, since arguments cannot be resolved.

int randomValue()
str randomValue()</programlisting></para>

        <para>How should overloading be resolved in the presence of type
        parameters? Our approach is simple but effective: a type parameter
        <literal>&amp;<replaceable><replaceable>T</replaceable></replaceable></literal>
        is taken to be of type <literal>value</literal>, unless it is
        explicitly constrained to be smaller than (or smaller than or equal
        to) another type U by writing
        <literal>&amp;<replaceable>T</replaceable> &lt;:
        <replaceable>U</replaceable></literal>. For the sake of overloading
        resolution, a constrained type parameter will be considered to have
        the type of the constraint, i.e., in <literal>fun
        F(&amp;<replaceable>T</replaceable> &lt; U)</literal> we assume the
        <literal>&amp;<replaceable>T</replaceable></literal> to be of type
        <literal>U</literal>.</para>

        <para>Here are more examples:</para>

        <para><programlisting>%% NOT OK, because &amp;T might be any type (i.e. value),
%% which is comparable to int

str f(int x)
str f(&amp;T x)

%% NOT OK, since both T's may bind to comparable types and
%% value and int are comparable

int f(&amp;T x, value y)
int f(&amp;T y, int x)

%% OK, since the second arguments have incomparable types

int f(&amp;T x, int y)
int f(&amp;T y, double x)</programlisting></para>
      </section>

      <section>
        <title>Formal description of overloading</title>

        <para>Given the subtype relation <literal>&lt;=:</literal> defined
        earlier, we can easily formalize overloading resolution by defining
        two predicates: <literal>incomparable</literal> describes when two
        lists of OptionallyNamedTypes can be compared and
        <literal>may-overload</literal> describes when two function types
        satisfy the overloading restrictions:<programlisting>%% Incomparable

[com1] incomparable(ONTs, ONTs') = 
       not((ONTs &lt;: ONTs') | (ONTs' &lt;: ONTs))

%% May-overload

[mo-1] may-overload(fun T N (ONTs), fun T' N' (ONTs')) = 
       not(N == N') | 
       incomparable(ONTs, ONTs')</programlisting></para>
      </section>

      <section>
        <title>Anonymous Functions</title>

        <para>We also allow <emphasis>anonymous functions</emphasis>, i.e.,
        functions that are declared locally and can be passed as argument to
        another function, be returned as value of a function, or even be
        stored as value in a set or relation. <caution>
            <para>Causes aliasing; How does this interfere with backtracking?
            We may forbid write access to globals outside the current
            context.</para>
          </caution>When such functions are called they are called in the
        lexical scope in which they were defined. For instance, the Rascal
        standard Library defines a <literal>mapper</literal> function that
        applies a function to a list or set. An anonymous function can be used
        to define such function arguments. Here is a function
        <literal>addOne</literal>, that adds 1 to each element of its argument
        list:<programlisting>list[int] addOne(list[int] L)
    return mapper(L, fun int (int N) { return N +1 })</programlisting><code></code></para>

        <programlisting>fun fun(int) -&gt; int makeAdder(int n)
    return fun int (int x) { return x + 1 }</programlisting>

        <caution>
          <para>The above needs further editing/explanation.</para>
        </caution>
      </section>
    </section>

    <section>
      <title>Patterns</title>

      <para>We distinguish four kinds of patterns:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Abstract</emphasis> patterns: prefix dataterms that
          are generated by a signature.</para>
        </listitem>

        <listitem>
          <para><emphasis>Regular expression</emphasis> patterns: conventional
          regular expressions</para>
        </listitem>

        <listitem>
          <para><emphasis>Syntax</emphasis> patterns: textual fragments that
          are generated by a context-free grammar.</para>
        </listitem>

        <listitem>
          <para><emphasis>Lexical</emphasis> patterns: a special case of
          syntax patterns dealing with lexical notions like identifiers,
          numeric constants, and the like.</para>
        </listitem>
      </itemizedlist>

      <para>Patterns may contain variables and can occur in two syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Match</emphasis> positions where the patterns is
          matched against another term and the variables in the pattern are
          bound when the match is successfull. Examples of match positions
          are:</para>

          <itemizedlist>
            <listitem>
              <para>In a case construct, immediately after the
              <literal>case</literal>, <literal>acase</literal> or
              <literal>rcase</literal> keyword.</para>
            </listitem>

            <listitem>
              <para>The left-hand side of a <literal>rules</literal> or
              <literal>arules</literal> statement.</para>
            </listitem>

            <listitem>
              <para>In a generator, where generated values are matched against
              the pattern.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis>Make</emphasis> positions where the pattern is used
          to construct a new term (after replacing any variables in the
          pattern by their values. Examples of make positions are:</para>

          <itemizedlist>
            <listitem>
              <para>In a case construct, immediately after the
              <literal>=&gt;</literal> operator.</para>
            </listitem>

            <listitem>
              <para>The right-hand side of a <literal>rules</literal> or
              <literal>arules</literal> statement.</para>
            </listitem>

            <listitem>
              <para>As an ordinary expression in the form of a quoted syntax
              pattern, or a call to a constructor for a dataterm.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>In make positions, patterns may also contain function calls
      (written between <literal>&lt;</literal> and <literal>&gt;</literal>)
      that are replaced by their value during the construction of the pattern.
      Example:<programlisting>&lt;subst(V1, E1, Ea)&gt;</programlisting></para>

      <para><note>
          <para>To avoid syntactic complications, we currently refrain from
          allowing arbitrary expressions inside patterns, e.g., using notation
          like <literal>#{ ... }</literal>. However, since function arguments
          can be arbitrary expressions, this is hardly a restriction.</para>
        </note>A pattern may be turned into an
      <emphasis>anti-pattern</emphasis> by prefixing it with the symbol
      <literal>!</literal>. An anti-pattern matches in all cases where the
      original pattern does not match. A match of an anti-pattern cannot bind
      any variables but these variables are nonetheless reserved in the
      corresponding scope.</para>

      <section>
        <title>Abstract Patterns</title>

        <para>Data declarations introduce a signature of abstract terms and
        abstract patterns can be used to perform matching on them. The same
        terms that or in a data delcaration, possibly including typed
        variables that play a similar role as pattern variables in syntax
        patterns, may be used as abstract patterns at the same position where
        concrete patterns are allowed. Lists, sets and tuples may also occur
        in abstract patterns. Here are some examples of abstract
        patterns:<programlisting>%% Assuming:
%% data Bool band(Bool L, Bool R);
%% Bool B2;
%% An abstract pattern matching a band node:

band(btrue, B2)

%% The variable B2 can also be declared inside the pattern:

band(true, Bool B2)

%% Assuming:
%% data PICO_VALUE intval(int) | strval(str);
%% An abstract pattern matching an intval:

intval(int n1)

%% Assuming:
%% int P, Q; 
%% list[int] Nums1, Nums2;

[Nums1, P, Q, Nums2]

%% This can also be written as:
[list[int Nums1], int P, int Q, list[int] Nums2]

%% Mixtures of variables declared outside the pattern 
%% and inside the pattern are also allowed:

[Nums1, int P, int Q, Nums2]</programlisting></para>

        <para>An abstract pattern may be preceeded by the key word
        <literal>abs</literal>, in order to resolve ambiguities with syntax
        patterns.</para>
      </section>

      <section>
        <title>Regular Expression Patterns</title>

        <para>Regular expression patterns are ordinary regular expressions
        that are used to match a string value and to decompose it in parts and
        also to compose new strings. Regular expression patterns bind
        variables of type <literal>str</literal> when the match succeeds,
        otherwise they do not bind anything. Their syntax and semantics
        parallels abstract and concrete syntax patterns as much as possible.
        This means that they can occur in cases of <literal>visit</literal>
        and <literal>switch</literal> statements, on the left-hand side of the
        match operator (<literal>~~</literal>) and as declarator in
        generators.</para>

        <para>We use a regular expression language that extends the lexical
        syntax rules found in SDF towards Java regex with the following
        exceptions:</para>

        <itemizedlist>
          <listitem>
            <para>Regular expression are delimited by / and / optionally
            followed by a modifier (see below).</para>
          </listitem>

          <listitem>
            <para>Character classes are written in the SDF way.</para>
          </listitem>

          <listitem>
            <para>Java regular expressions might have optional groups, which
            may introduce null bindings. Since null pointers are not allowed
            in Rascal, we limit the kinds of expressions one can write here by
            not allowing nesting of named groups.</para>
          </listitem>

          <listitem>
            <para>We allow named groups, syntax
            <literal>&lt;<replaceable>Name</replaceable>:<replaceable>Regex</replaceable>&gt;</literal>,
            which introduce a variable of type <literal>str</literal> named
            <replaceable>Name</replaceable>.</para>
          </listitem>

          <listitem>
            <para>We allow name use in a regular expression:
            <literal>&lt;<replaceable>Name</replaceable>&gt;</literal> which
            inserts the string value of <replaceable>Name</replaceable> in the
            pattern.</para>
          </listitem>

          <listitem>
            <para>We allow function calls inside a regular expression:
            <literal>&lt;<replaceable>F</replaceable>(...)&gt;</literal> which
            inserts the string value of the function call in the regular
            expression.</para>
          </listitem>

          <listitem>
            <para>Named groups have to be outermost, such that they can only
            bind in one way.</para>
          </listitem>

          <listitem>
            <para>Unlike Perl, Java uses the notation
            <literal>(?<replaceable>Option</replaceable>)</literal> inside the
            regular expression to set options like multi-line matching
            <literal>(?m)</literal>, case-insensitive matching
            <literal>(?i)</literal> etc. We let these options follow te
            regular expression.</para>
          </listitem>

          <listitem>
            <para>We omit some more esoteric features of Java regex like
            (octal and hex constants, look ahead and look behind) but these
            can always be added.</para>
          </listitem>

          <listitem>
            <para>We have an explicit grammar for the regular expression
            language that facilitates translation to Java regex.</para>
          </listitem>
        </itemizedlist>

        <para>Here are some examples of regular patterns.<programlisting>/\brascal\b/i</programlisting>does
        a case-insensitive match (<literal>i</literal>) of the word rascal
        between word boundaries (<literal>\b</literal>). And<programlisting>/^.*?&lt;word:\w+&gt;&lt;rest:.*$&gt;/m</programlisting>does
        a multi-line match (<literal>m</literal>), matches the first
        consecutive word characters (<literal>\w</literal>) and assigns them
        to the variable <literal>word</literal>. The remainder of the string
        is assigned to the variable <literal>rest</literal>.</para>
      </section>

      <section xml:id="section.patterns">
        <title>Syntax Patterns</title>

        <para>There is a notation of a <emphasis>syntax pattern</emphasis>: a
        (possibly quoted) concrete syntax fragment that may contain variables.
        We want to cover the whole spectrum from maximally quoted patterns
        that can unambiguously describe <emphasis role="bold">any</emphasis>
        syntax fragment to minimally quoted patterns as we are used to in
        ASF+SDF. Therefore we support the following mechanisms:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>pattern variable declaration</emphasis>, written
            as <literal>&lt;<replaceable>TYPE</replaceable>
            <replaceable>NAME</replaceable>&gt;</literal> declares a new
            variable with a scope determined by the syntactic context of the
            pattern.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>pattern variable use</emphasis>, written as
            <literal>&lt;<replaceable>NAME</replaceable>&gt;</literal>, uses
            the value of an already declared variabele during the use of the
            pattern.</para>
          </listitem>

          <listitem>
            <para>Quoted patterns enclosed between <literal>[|</literal> and
            <literal>|]</literal>. Inside a fully quoted string, the
            characters <literal>&lt;</literal>, <literal>&gt;</literal> and
            <literal>|</literal> can be escaped as <literal>\&lt;</literal>,
            <literal>\&gt;</literal>, <literal>\|</literal>. Fully quoted
            patterns may contain pattern variable declarations and pattern
            variable uses.</para>
          </listitem>

          <listitem>
            <para>A quoted pattern may be optionally preceeded by an SDF
            symbol to define its desired syntactic type.</para>
          </listitem>

          <listitem>
            <para>Unquoted patterns are (unquoted) syntax fragments that may
            contain pattern variable declarations and pattern variable
            uses.</para>
          </listitem>

          <listitem>
            <para>Inside syntax patterns, layout is ignored.</para>
          </listitem>
        </itemizedlist>

        <para>Quoted and unquoted patterns form the syntax patterns that are
        supported in Rascal.</para>

        <para>Examples are:</para>

        <itemizedlist>
          <listitem>
            <para>Quoted syntax pattern with two pattern variable
            declarations:<programlisting>[| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Quoted syntax pattern with two pattern variable
            uses:<programlisting>[| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Identical to the previous example, but with a declaration of
            the desired syntactic type:<programlisting>STATEMENT [| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with two pattern variable
            declarations:<programlisting>while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with two pattern variable
            uses:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>
          </listitem>
        </itemizedlist>

        <para>Obviously, with less quoting and type information, the
        probability of ambiguities increases. Our assumption is that a type
        checker can resolve them.</para>

        <note>
          <para>Implementation hint (used to check the examples in this
          document). For every sort S in the syntax definition add the
          following rules:</para>

          <programlisting><replaceable>S</replaceable>                   -&gt; Pattern
"&lt;<replaceable>" "S</replaceable>"? Name "&gt;"   -&gt; <replaceable>S</replaceable>      </programlisting>
        </note>
      </section>

      <section>
        <title>Lexical Patterns</title>

        <para>A special case of syntax patterns, are lexical patterns that
        describe lexical notions such as identifiers, numeric constants and
        the like. Lexical patterns can appear as part of a concrete syntax
        pattern. Our solution is a middle road between the original solution
        used in ASF+SDF (simple but not type safe) and the current solution in
        ASF+SDF (complex but type safe). The key idea is that a constructor
        function is implicitly created for every lexical definition, i.e.,
        when the SDF definition defines the lexical sort
        <literal>LS</literal>, then the following lexical constructor function
        <literal>ls</literal> (the sort name in lower case) is implicitly
        defined:<programlisting>    ls( LEXARGS ) -&gt; LS</programlisting></para>

        <para><literal>LEXARGS</literal> consist of zero or more:</para>

        <itemizedlist>
          <listitem>
            <para>String constants.</para>
          </listitem>

          <listitem>
            <para>Typed Variables enclosed in angle brackets (as used in other
            patterns).</para>
          </listitem>
        </itemizedlist>

        <para>The <literal>LEXARGS</literal> argument combined should form a
        strings of sort <literal>LS</literal>.<note>
            <para>The current solution in ASF+SDF requires that all
            intermediate lexical constructors are explicitly written in the
            pattern. Here we relax this requirement.</para>
          </note></para>

        <para>For instance, given a lexical syntax for numbers (part of an SDF
        definition):<programlisting>sorts DIGIT NAT-CON
lexical syntax
   [0-9]    -&gt; DIGIT
   DIGIT+   -&gt; NAT-CON</programlisting></para>

        <para>A rule that would remove leading zeros looks like
        this:<programlisting>  natcon("0" &lt;DIGIT+ Ds&gt;) =&gt; natcon(&lt;Ds&gt;)</programlisting><note>
            <para>Unlike the ASF+SDF solution, it is not necessary to make a
            distinction between ordinary variables, lexical variables, and
            layout variables. Here, all variables are treated equal and their
            syntactic position determines how they are used.</para>
          </note>We also allow arbitrary character classes as type in a
        pattern variable, e.g., one could also write:<programlisting>  natcon("0" &lt;[0-9]+ Ds&gt;) =&gt; natcon(&lt;Ds&gt;)</programlisting></para>

        <para><caution>
            <para>Make lexical patterns and regular patterns more similar to
            each other.</para>
          </caution></para>

        <para>According to conventions imposed by the SDF implementation, for
        each lexically defined sort <replaceable>S</replaceable> the sorts
        <literal><replaceable>S</replaceable>-Lex</literal> (lexical
        definition of <replaceable>S</replaceable>) and
        <literal><replaceable>S</replaceable>-CF</literal> (context-free
        definition of <replaceable>S</replaceable>) are created together with
        the inclusion rule<programlisting><replaceable>S</replaceable>-Lex -&gt; <replaceable>S</replaceable>-CF</programlisting></para>

        <para>For precise typing of lexical patterns, one may have to resort
        to these generated types.<caution>
            <para>How do we parameterize layout?<programlisting>import Java[LAYOUT =&gt; JAVA-LAYOUT]</programlisting></para>
          </caution></para>
      </section>
    </section>

    <section>
      <title>Statements</title>

      <para>The different statement types are described in the following
      subsections.</para>

      <section>
        <title>Declaration and assignment</title>

        <para>Rascal provides variable declarations with optional
        initialization. If the initialization is missing, no control flow path
        may exist with use before definition. An assignment statement assigns
        a value to a variable. The left-hand side is of syntactic type
        <replaceable>Assignable</replaceable>, and may be a simple variable,
        index of variable, field selection of variable, or a combination of
        these. Assignments may be undone in the context of a failing case of a
        switch or visit statement.</para>

        <para>An assignment may also contain one of the assignment operators
        <literal>+=</literal>, <literal>-=</literal>, <literal>*=</literal>,
        <literal>/=</literal>, <literal>&amp;=</literal>, and
        <literal>|=</literal>.</para>
      </section>

      <section>
        <title>Standard control statements</title>

        <para>Rascal supports the following standard control
        statements:</para>

        <itemizedlist>
          <listitem>
            <para>If-then statement and if-then-else statement.</para>
          </listitem>

          <listitem>
            <para>A <literal>while</literal> statement to repeat a block of
            code while a given Predicate is true.</para>
          </listitem>

          <listitem>
            <para>A <literal>for</literal> statement repeats a block of code
            for each value produced by a generator.</para>
          </listitem>

          <listitem>
            <para>A <literal>return</literal> statement returns a value from a
            function, or just returns (for functions with result type void).
            Note that return jumps out of an entire function, even if it is
            nested in a complicated control flow statement such as
            visit.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Solve statement</title>

        <para>Rascal provides a solve statement for the solution of sets of
        simultaneous linear equations. The format is:<programlisting>solve (<replaceable>Expression</replaceable>) {
  <replaceable>Assignable1</replaceable> = <replaceable>Expression1</replaceable>;
  <replaceable>Assignable2</replaceable> = <replaceable>Expression2</replaceable>;
  ...
}</programlisting></para>

        <para>The solve statement is executed by performing the assignments in
        its body as long as the value of at least one assignable at the
        left-hand side of an assignment changes. The optional
        <replaceable>Expression</replaceable> directly following the
        <literal>solve</literal> keyword, gives an upperbound on the number of
        iterations.</para>
      </section>

      <section>
        <title>Exception handling</title>

        <para>A <literal>try</literal> statement can be used to execute a
        statement and to catch any exception raised by that statement and
        resembles the corresponding Java construct:<programlisting>try <replaceable>Statement</replaceable>
catch <replaceable>Pattern1</replaceable> : <replaceable>Statement1</replaceable>
catch <replaceable>Pattern2</replaceable> : <replaceable>Statement2</replaceable>
...
finally: Statement</programlisting>A throw statement can raise an
        exception.</para>
      </section>

      <section>
        <title>Switch and fail statement</title>

        <para>A <literal>switch</literal> statement is similar to a switch
        statement in C or Java and has the form:<programlisting>switch ( <replaceable>Expression</replaceable> ) {
case <replaceable>Rule</replaceable>1;
case <replaceable>Rule</replaceable>2;
...
default: ...
}</programlisting></para>

        <para>The value of the expression is the subject term that will be
        matched by the successive cases in the switch statement. This
        corresponds to the matching provided by the left-hand sides of a set
        of rewrite rules. However, the switch statement provides <emphasis
        role="bold">only</emphasis> matching at the top level of the subject
        term and does not traverse it. The type of the pattern in each case
        must be identical to the type of the subject term (or be a subtype of
        it). If no case matches, the switch acts as a dummy statement. There
        is no fall through from one case to the next.</para>

        <para>Each case contains a Rule that can have one of the following
        forms:</para>

        <itemizedlist>
          <listitem>
            <para><programlisting><replaceable>SyntaxPattern</replaceable><replaceable>1</replaceable> =&gt; <replaceable>SyntaxPattern2</replaceable></programlisting>When
            the subject matches
            <replaceable>SyntaxPattern</replaceable><replaceable>1</replaceable>,
            <replaceable>SyntaxPattern</replaceable><replaceable>2</replaceable>
            is returned from the enclosing function (after proper
            substitution).</para>
          </listitem>

          <listitem>
            <para><programlisting><replaceable>AbstractPattern</replaceable><replaceable>1</replaceable> =&gt; <replaceable>AbstractPattern</replaceable><replaceable>2</replaceable> <emphasis
                  role="bold">or</emphasis> <replaceable>PatternVariable</replaceable></programlisting>When
            the subject matches
            <replaceable>Abstractpattern</replaceable><replaceable>1</replaceable>,
            <replaceable>AbstractPattern</replaceable><replaceable>2</replaceable>
            is returned from the enclosing function (after proper
            substitution). When the right-hand side consists of a single
            <replaceable>PatternVariable</replaceable>, its value is
            returned.</para>
          </listitem>

          <listitem>
            <para><programlisting><replaceable>RegExpPattern</replaceable> =&gt; <replaceable>StringLiteral</replaceable> <replaceable>or</replaceable> <replaceable>PatternVariable</replaceable></programlisting></para>

            <para>When the subject matches
            <replaceable>RexExpPattern</replaceable><replaceable>1</replaceable>,
            <replaceable>StringLiteral</replaceable> (or the single
            <replaceable>PatternVariable</replaceable>) is returned from the
            enclosing function (after proper substitution).</para>
          </listitem>

          <listitem>
            <para><programlisting><replaceable>Pattern</replaceable> : <replaceable>Statement</replaceable></programlisting></para>

            <para>This is the most general case. When the subject matches
            <replaceable>Pattern</replaceable>, the
            <replaceable>Statement</replaceable> is executed. The execution of
            <replaceable>Statement</replaceable> should lead to one of the
            following:</para>

            <itemizedlist>
              <listitem>
                <para>Execution of a <literal>return</literal> statement that
                returns a value from the enclosing function.</para>
              </listitem>

              <listitem>
                <para>Execution of a <literal>fail</literal> statement: all
                side effects of <replaceable>Statement</replaceable> are
                undone and the next case is tried.</para>
              </listitem>

              <listitem>
                <para>None of the above: execution continues with the
                statement following the switch.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <note>
          <para>In the future we intend to unify the first three alternatives
          into:<programlisting><replaceable>Pattern1</replaceable> =&gt; <replaceable>Pattern2</replaceable></programlisting>Right
          now, we stick to these three alternatives to reduce the number of
          syntactic ambiguities.</para>
        </note>
      </section>

      <section>
        <title>Flow of control and local alternatives</title>

        <para>The flow of control in Rascal is more or less traditional,
        except that in some situations local alternatives may exist. This is
        in particular the case when using patterns that contain list or set
        patterns. In those cases, more than one match may be possible and the
        flow of control is such that these matches can be handled
        appropriately. We have the following:</para>

        <itemizedlist>
          <listitem>
            <para>The "if" and "while" statement provide ordinary flow of
            control and their condition may not contain list patterns, set
            patterns or generators.</para>
          </listitem>

          <listitem>
            <para>The for-statement also provides ordinary flow of control and
            its condition is a generator.</para>
          </listitem>

          <listitem>
            <para>We have break and continue statements.</para>
          </listitem>

          <listitem>
            <para>The "switch" and "visit" construct introduce a save/commit
            barrier before and after each case. Executing a fail in the code
            associated with a case leads to undoing side-effects and
            continuation with the next case.</para>
          </listitem>

          <listitem>
            <para>We already have "forall" (suggestion: rename this to "all")
            and "exists" as predicates that test that all (or at least one
            element) satisfies a predicate.</para>
          </listitem>

          <listitem>
            <para>TO BE DISCUSSED: The new statement constructs "all" and
            "exists" have a list or set pattern as condition. They establish a
            save/commit barrier around each iteration. When an iteration
            completes normally all its side-effects are made permanent and
            execution continues with the next iteration (all) or the next
            statement (exists). When "fail" is encountered during execution,
            all side-effects are undone and execution continues with the next
            iteration.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Expressions</title>

      <table xml:id="table.operators-on-datatypes">
        <title>Operators on Datatypes</title>

        <tgroup cols="11">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center"> </entry>

              <entry align="center">bool </entry>

              <entry align="center">int</entry>

              <entry align="center">double</entry>

              <entry align="center">str</entry>

              <entry align="center">loc</entry>

              <entry align="center">list</entry>

              <entry align="center">tuple</entry>

              <entry align="center">set</entry>

              <entry align="center">map</entry>

              <entry align="center">rel</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>equal</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>
            </row>

            <row>
              <entry>nequal</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>
            </row>

            <row>
              <entry>less</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>
            </row>

            <row>
              <entry>lesseq</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>
            </row>

            <row>
              <entry>greater</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>
            </row>

            <row>
              <entry>greatereq</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>
            </row>

            <row>
              <entry>and/inter</entry>

              <entry>&amp;&amp;</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>&amp;</entry>

              <entry>&amp;</entry>

              <entry>&amp;</entry>
            </row>

            <row>
              <entry>or/union</entry>

              <entry>||</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>|</entry>

              <entry>|</entry>

              <entry>|</entry>
            </row>

            <row>
              <entry>not</entry>

              <entry>!</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>add/conc</entry>

              <entry></entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry></entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>sub/diff</entry>

              <entry></entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry></entry>

              <entry></entry>

              <entry>-</entry>

              <entry></entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>prod</entry>

              <entry></entry>

              <entry>*</entry>

              <entry>*</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>*</entry>

              <entry>*</entry>

              <entry>*</entry>

              <entry>*</entry>
            </row>

            <row>
              <entry>div</entry>

              <entry></entry>

              <entry>/</entry>

              <entry>/</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>in</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>in</entry>

              <entry></entry>

              <entry>in</entry>

              <entry>in</entry>

              <entry>in</entry>

              <entry>in</entry>

              <entry>in</entry>
            </row>

            <row>
              <entry>notin</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>notin</entry>

              <entry></entry>

              <entry>notin</entry>

              <entry>notin</entry>

              <entry>notin</entry>

              <entry>notin</entry>

              <entry>notin</entry>
            </row>

            <row>
              <entry>*-closure</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>*</entry>

              <entry>*</entry>
            </row>

            <row>
              <entry>+-closure</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>+</entry>

              <entry>+</entry>
            </row>

            <row>
              <entry>project</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>[ _ ]</entry>

              <entry></entry>

              <entry>[ _ ]</entry>

              <entry>[ _ ]</entry>

              <entry></entry>

              <entry>[ _ ]</entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><note>
          <para>Some operators do not fit nicely in this scheme since they do
          not operate on the basic data types:</para>

          <itemizedlist>
            <listitem>
              <para><literal>@</literal> get annotation value</para>
            </listitem>

            <listitem>
              <para><literal>~~</literal> match</para>
            </listitem>

            <listitem>
              <para><literal>!~</literal> no match</para>
            </listitem>

            <listitem>
              <para><literal>_ ? _ : _</literal> conditional expression</para>
            </listitem>
          </itemizedlist>
        </note></para>

      <section>
        <title>Basic values</title>

        <para>Constants of type <literal>bool</literal>,
        <literal>int</literal> , <literal>double</literal>,
        <literal>str</literal> and <literal>loc</literal> are expressions. All
        operators for all datatypes are summarized in <xref
        linkend="table.operators-on-datatypes" />.</para>
      </section>

      <section>
        <title>Structured values</title>

        <para>Values of the structured types <literal>list</literal>,
        <literal>set</literal>, <literal>tuple</literal>,
        <literal>rel</literal> and <literal>map </literal>are expressions and
        can be constructed as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Lists are enclosed between [ and ] and the elements are
            separated by comma's, e.g.<literal> ["abc", "def"]</literal> or
            <literal>[true, false, false, true]</literal>. For lists of
            integers, a special shorthand exists to describe ranges of
            integers:</para>

            <itemizedlist>
              <listitem>
                <para><literal>[<replaceable>F</replaceable>..<replaceable>L</replaceable>]</literal>
                ranges from first element <replaceable>F</replaceable> to (and
                including) last element <replaceable>L</replaceable> with
                increments of 1.</para>
              </listitem>

              <listitem>
                <para><literal>[<replaceable>F</replaceable>,<replaceable>S</replaceable>,..<replaceable>E</replaceable>]</literal>,
                ranges from first element <replaceable>F</replaceable>, second
                element S to (and including) last element
                <replaceable>L</replaceable> with increments of
                <literal>S</literal> - <replaceable>F</replaceable>.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Sets are enclosed between { and } and the elements are
            separated by comma's, e.g.<literal> {"abc", "def"}</literal> or
            <literal>{true, false}</literal>.</para>
          </listitem>

          <listitem>
            <para>Tuples are enclosed between &lt; and &gt; and the elements
            are separated by comma's, e.g. <literal>&lt;1, "twee",
            3&gt;</literal>.</para>
          </listitem>

          <listitem>
            <para>Relations are sets of tuples.</para>
          </listitem>

          <listitem>
            <para>Maps are a special form of binary relation and satisfy the
            constraint that the first element of each tuple is unique. Maps
            model functions. To distinguish between map tuples and tuples in
            general relations, we write them as &lt;E1 -&gt; E2&gt;.</para>
          </listitem>
        </itemizedlist>

        <para>An index operator
        <literal><replaceable>R</replaceable>[<replaceable>N</replaceable>]</literal>
        can be applied to values of types list, tuple, string and returns the
        <replaceable>N</replaceable>-th element. It throws the exception
        <literal>out_of_range(str msg)</literal> when the index value is out
        of range.</para>

        <para>For a map <replaceable>M</replaceable>,
        <replaceable>M</replaceable>[<replaceable>N</replaceable>], returns
        the single image value corresponding with
        <replaceable>N</replaceable>. This expression may also occur as
        left-hand side of an assignment:<programlisting><replaceable>M</replaceable>[<replaceable>N</replaceable>] = <replaceable>V</replaceable></programlisting>which
        first removes from <replaceable>M</replaceable> the tuple with domain
        value <replaceable>N</replaceable> and then adds the tuple
        &lt;<replaceable>N</replaceable> -&gt;
        <replaceable>V</replaceable>&gt;. The net effect is that a new map
        value is assigned to <replaceable>M</replaceable>.</para>

        <para>For all structured values, we provide comprehensions for lists
        of the form:<programlisting>[ E | G1, ..., Gn ]</programlisting>and
        for sets, maps and relations of the form:<programlisting>{ E | G1, ..., Gn }</programlisting></para>
      </section>

      <section>
        <title>Tree values</title>

        <para>Syntax trees are expressions and generators in comprehensions
        may range over syntax trees.</para>

        <para>Generators may have a strategy option to indicate:</para>

        <itemizedlist>
          <listitem>
            <para><literal>top-down</literal></para>
          </listitem>

          <listitem>
            <para><literal>top-down-break</literal></para>
          </listitem>

          <listitem>
            <para><literal>bottom-up</literal> (this is the default)</para>
          </listitem>

          <listitem>
            <para><literal>bottom-up-break</literal></para>
          </listitem>
        </itemizedlist>

        <para>The two other strategy options (<literal>innermost</literal> and
        <literal>outermost</literal>) are only meaningfull in the context of a
        <literal>visit</literal> expression.</para>
      </section>

      <section>
        <title>Predicates</title>

        <para>Predicates are expressions that yield a value of type bool and
        include <literal>==</literal> (equal), <literal>!=</literal> (not
        equal), <literal>&lt;</literal> (less), <literal>&lt;=</literal> (less
        or equal), <literal>&gt;</literal> (greater), <literal>&gt;=</literal>
        (greater or equal). Predicates are used in control statements and in
        conditional expressions written as<programlisting><replaceable>Predicate</replaceable> ? <replaceable>Expression1</replaceable> : <replaceable>Expression2</replaceable></programlisting>Other
        predicates are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>in</literal>, <literal>notin</literal>: membership
            test.</para>
          </listitem>

          <listitem>
            <para><literal>~~</literal> match</para>
          </listitem>

          <listitem>
            <para><literal>!~</literal> nomatch</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Visit expression and insert statement</title>

        <para>A <literal>visit</literal> expression corresponds to a traversal
        function in ASF+SDF and has the form:<programlisting><replaceable>Strategy</replaceable> visit ( <replaceable>Expression</replaceable> ) {
case <replaceable>Rule</replaceable>1;
case <replaceable>Rule</replaceable>2;
...
default: ...
}</programlisting>Given a subject term (the current value of
        <replaceable>Expression</replaceable>) and a list of cases (resembling
        rewrite rules) it traverses the term. Depending on the precise rules
        it may perform replacement (mimicking a transformer), update local
        variables (mimicking an accumulator) or a combination of these two. If
        <emphasis role="bold">any</emphasis> of the cases contains an
        <literal>insert</literal> statement, the value of the visit expression
        is a new value that is obtained by successive insertions in the
        subject term by executing one or more cases. Otherwise, the value of
        the subject term is returned.</para>

        <para>The visit expression is optionally preceeded by one of the
        following strategy indications that determine the traversal order of
        the subject:</para>

        <itemizedlist>
          <listitem>
            <para><literal>top-down</literal></para>
          </listitem>

          <listitem>
            <para><literal>top-down-break</literal></para>
          </listitem>

          <listitem>
            <para><literal>bottom-up</literal> (this is the default)</para>
          </listitem>

          <listitem>
            <para><literal>bottom-up-break</literal></para>
          </listitem>

          <listitem>
            <para><literal>innermost</literal> = compute a fixed-point: repeat
            a bottom-up traversal as long as the traversal function changes
            values.</para>
          </listitem>

          <listitem>
            <para><literal>outermost</literal> = compute a fixed-point: repeat
            a traversal traversal as long as the traversal function changes
            values.</para>
          </listitem>
        </itemizedlist>

        <para>The execution of the cases is similar to the cases in a switch
        statement with the following exceptions:</para>

        <itemizedlist>
          <listitem>
            <para>The three Rule cases of the form ... =&gt; ... <emphasis
            role="bold">insert</emphasis> their result in the subject (instead
            of returning a value).</para>
          </listitem>

          <listitem>
            <para>In the fourth case
            <literal><replaceable>Pattern</replaceable> :
            <replaceable>Statement</replaceable></literal>, executing
            <replaceable>Statement</replaceable> should lead to one of the
            following:</para>

            <itemizedlist>
              <listitem>
                <para>Execution of an <literal>insert</literal> statement of
                the form <literal>insert
                <replaceable>Expression</replaceable></literal>. The value of
                <replaceable>Expression</replaceable> replaces the subtree of
                the subject that is currently being visited. Note that a copy
                of the subject is created at the start of the visit statement
                and all insertions are made in this copy. As a consequence,
                insertions cannot influence matches later on.<note>
                    <para>An <literal>insert</literal> statement may only
                    occur inside a <literal>visit</literal> expression.</para>
                  </note></para>
              </listitem>

              <listitem>
                <para>Execution of a <literal>fail</literal> statement: all
                side effects of <replaceable>Statement</replaceable> are
                undone, no insertion is made, and the next case is
                tried.</para>
              </listitem>

              <listitem>
                <para>Execution of a <literal>return</literal> statement that
                returns a value from the enclosing function.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>Each case keyword may be followed by a type constraint of the
        form <literal>[<replaceable>Type</replaceable>]</literal> that limits
        the type of the tree nodes to which the case applies.</para>

        <para>The precise behaviour of the visit statement depends on the type
        of the subject:</para>

        <itemizedlist>
          <listitem>
            <para>For type <literal>tree</literal>, all nodes of the tree are
            visited (in the order determined by the strategy). SyntaxPatterns
            and AbstractPatterns directly match tree nodes. RexExpPatterns
            match only values of type string.</para>
          </listitem>

          <listitem>
            <para>For structured types (list, set, map, rel), the elements of
            the structured type are visited and matched against the cases.
            When inserts are made, a new structured value is created.<caution>
                <para>Have strategies any effect for non-tree subjects?</para>
              </caution></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Global rules</title>

      <para>The Rules that we have already encountered in switch and visit
      statement, can also be defined globally and are the closest to rewrite
      rules as we will get in Rascal. Unlike functions that are always called
      explicitly when needed, global rules are always applied implicitly,
      i.e., whenever a value of some type is created and there are rules
      defined for that type, they are immediately applied. In principle, rules
      can be used to define arbitrary computations. In practice, they are
      mostly used to guarantee that certain constraints are satisfied whenever
      a value of some type is created.</para>

      <para>Rules have the general form:<programlisting>rule <replaceable>Name</replaceable> <replaceable>Rule</replaceable></programlisting>Here
      is an example for concrete Booleans:</para>

      <para><programlisting>rule a1 true &amp; &lt;Bool B2&gt;   =&gt; &lt;B2&gt;</programlisting>and
      here for abstract Booleans:</para>

      <para><programlisting>rule a1 band(btrue, &lt;Bool B2&gt;)  =&gt; &lt;B2&gt; </programlisting></para>

      <para>As we have seen before, the replacement part may also have the
      form colon (<literal>:</literal>) followed by an arbitrary statement.
      During execution of rules the following applies:</para>

      <itemizedlist>
        <listitem>
          <para>Rules are applied non-deterministically, and in any order of
          matching.</para>
        </listitem>

        <listitem>
          <para>The right hand side of rules can contain fail statements,
          which cause backtracking over the alternative rules for a certain
          constructor.</para>
        </listitem>

        <listitem>
          <para>When the right-hand side is a statement, a return statement
          determines the value of the actual replacement.</para>
        </listitem>
      </itemizedlist>

      <para>As with cases, the rule keyword may be immediately followed by a
      type constraint to limit its applicability.<caution>
          <para>Default rules?</para>
        </caution></para>
    </section>

    <section>
      <title>Failure and side-effects</title>

      <para>There are two contexts in which side-effects, i.e., assignment to
      variables, have to be undone in case of failure. These contexts are a
      rule in a switch or visit statement. If the pattern on the left-handside
      of the rule matches there are various possibilities:</para>

      <itemizedlist>
        <listitem>
          <para>All control flow paths through the right-hand side of the rule
          end in a return statement. In this case, the rule can not fail and
          all side-effects caused by the execution of the right-hand side are
          committed.</para>
        </listitem>

        <listitem>
          <para>One or more control path can fail. This can be caused by an
          explicit fail statement or an if-then statement with missing
          else-branch (the missing else-branch acts as a fail). In the case of
          failure all side-effects (of local and global variables) are
          undone.</para>
        </listitem>

        <listitem>
          <para>If a rule fails there are two possibilities:</para>

          <itemizedlist>
            <listitem>
              <para>the left-hand side contains a list pattern that has more
              matching options; the next option is tried.</para>
            </listitem>

            <listitem>
              <para>the left-hand side contains a list patterns that has no
              more matching options or it contains no list pattern at all; the
              next rule is tried.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The possible choice points are:</para>

          <itemizedlist>
            <listitem>
              <para>case in a switch, visit statement.</para>
            </listitem>

            <listitem>
              <para>match of left-hand side of rule.</para>
            </listitem>

            <listitem>
              <para>Selection of a binding of list variables during list
              matching, except if there is one possibility left.</para>
            </listitem>

            <listitem>
              <para>Selection of an element by a generator.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The possible failure points are:</para>

          <itemizedlist>
            <listitem>
              <para>fail statement</para>
            </listitem>

            <listitem>
              <para>a predicate used as generator in a comprehension.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The possible success points are:</para>

          <itemizedlist>
            <listitem>
              <para><literal>return</literal> (jumps out of function scope and
              pops all choice points).</para>
            </listitem>

            <listitem>
              <para><literal>insert</literal> (jumps to enclosing switch or
              visit or rule choice)</para>
            </listitem>

            <listitem>
              <para>true predicate in comprehension (jumps to next assignment
              of generator).</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>On failure, the currently active choice point is used to undo
          side-effects and to continue execution.</para>
        </listitem>

        <listitem>
          <para>Side effects caused by built-in functions (like file i/o,
          socket communication, etc.) are <emphasis role="bold">not</emphasis>
          undone.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>Here we list experimental examples of Rascal code to try out
    features.</para>

    <section>
      <title>Hello world</title>

      <para>The ritual first example:<programlisting>module Hello

public void main() {
   println("Hello, this is my first Rascal program");
}</programlisting></para>
    </section>

    <section>
      <title>Table of squares</title>

      <para>Another ritual example, printing a table of
      squares:<programlisting>module Squares

public void main(list[str] argv){
  int N = toInt(argv[0]);
  map[int,int] squares = {};
  for(int I : [1 .. N]){
     squares[I] = I * I;
  }
  println("Table of squares from 1 to ", N);
  println(squares);
}</programlisting><caution>
          <para>We need a mechanism to insert values in strings,
          e.g.<programlisting> println("Table of squares from 1 to &lt;N&gt;");</programlisting></para>
        </caution></para>
    </section>

    <section>
      <title>Table of word counts per file</title>

      <para><programlisting>module WordCount
 
public void main(list[str] argv){
  map[str, int] counts = {};
  for(str fileName : argv){
    try {
      counts[fileName] = wordCount(readFile(fileName));
    }
    catch: println("Skipping file &lt;fileName&gt;");
  }

  println("In total &lt;sum(range(counts))&gt; words in all files");
  println("Word counts per file: &lt;counts&gt;");
}

int wordCount(str S){
  int count = 0;
  %% the m-option enables multi-line matching
  for(/[a-zA-Z0-9]+/m: S){
       count += 1;
  }
  return count;
}

%% Here is an alternative (but less desirable) declaration:
int wordCount2(str S){
  int count = 0;
  %% \w matches any word character
  %% &lt;...&gt; are groups and should appear at the top level.
  %% m turns on multi-line matching
  while (/^.*?&lt;word:\w+&gt;&lt;rest:.*$&gt;/m ~~ S) { 
    count += 1; 
    S = rest; 
  }
  return count;
}

%% Maintain word count per word.
%% Note how the += operator initializes each map entry
%% to an appropriate value (0 in this case)
map[str,int] wordCountPerWord(str S){
  map[str,int] allCounts = {};

 for(/&lt;word:^[a-zA-Z0-9]+&gt;/m: S){
       allCounts[word] ? 0 += 1; 
  }
  return allCounts;
}</programlisting></para>
    </section>

    <section>
      <title>Word replacement</title>

      <para>Here are two versions of a word replacement function:<caution>
          <para>How does this example work?</para>
        </caution></para>

      <para><programlisting>module WordReplacement

str capitalize1(str S){
    return visit (S) {
      %% \b matches a word boundary
      %% i turns on case-independent matching
      case /\brascal\b/i =&gt; "Rascal"
    };
}

str capitalize2(str S, str Pat, str Repl){
    return visit (S) {
      case /\b&lt;Pat&gt;\b/i =&gt; "&lt;Repl&gt;"
    };
}</programlisting>The function <literal>capitalize1</literal>, replaces all
      occurrences of <literal>rascal</literal> (in all possible cases) by the
      standard spelling <literal>Rascal</literal>. The function
      <literal>capitalize2</literal> is a generalization of
      <literal>capitalize1</literal>: it takes a subject string, a pattern
      string and a replacement string. Observe how the argument
      <literal>Pat</literal> is inserted in the regular expression.</para>

      <para>The call <literal>capitalize2(Subject, "rascal",
      "Rascal")</literal> will have the same effect as
      <literal>capitalize1(Subject)</literal>.</para>
    </section>

    <section>
      <title>Finding date-related variables</title>

      <para>In year 2000 conversions, the starting point for analysis could be
      variables with a date-related name. Here is how to find
      them:<programlisting>module DateVars

set[Var] getDateVars(Program P){
   return {V | Var V : P, 
               /.*(date|dt|year|yr).*$/i ~~ toString(V)};
}</programlisting></para>
    </section>

    <section>
      <title>Booleans</title>

      <para>It seems that every language specification effort has to produce a
      specification of the Booleans at some moment, so let's try it now. We
      try several variations.</para>

      <para>We use the following common syntax:<programlisting>module Booleans-syntax
exports 
  sorts Bool

  context-free syntax
    "true"        -&gt; Bool
    "false"       -&gt; Bool
    Bool "&amp;" Bool -&gt; Bool {left}
    Bool "|" Bool -&gt; Bool {right}</programlisting></para>

      <section xml:id="section.booleans-with-visit">
        <title>Concrete Booleans defined with visit</title>

        <para>Using the visit construct that we have described above, we can
        write the definitions for the functions <literal>&amp;</literal> and
        <literal>|</literal> as follows:<programlisting>module Bool-examples1

import languages/Booleans/syntax;

Bool reduce(Bool B) {
    Bool B1, B2;
    return bottom-up visit(B) {
      case true &amp; &lt;B2&gt;   =&gt; &lt;B2&gt;
      case false &amp; &lt;B2&gt;  =&gt; false

      case true | true   =&gt; true
      case true | false  =&gt; true
      case false | true  =&gt; true
      case false | false =&gt; false
    };
}</programlisting></para>

        <para>Observe that there are two styles:</para>

        <itemizedlist>
          <listitem>
            <para>In the definition for <literal>&amp;</literal>, we use
            variables on the left-hand side: the visit is needed to fully
            normalize the result.</para>
          </listitem>

          <listitem>
            <para>In the definition of <literal>|</literal>, we use a truth
            table.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Abstract Booleans defined with visit</title>

        <para>In the above example we used concrete syntax for Booleans
        expressions. It also possible to define Booleans as abstract
        terms.<programlisting>module Bool-abstract

data Bool btrue;
data Bool bfalse;
data Bool band(Bool L, Bool R);
data Bool bor(Bool L, Bool R);  

Bool reduce(Bool B) {
    Bool B1, B2;
    return bottom-up visit(B) {
      case band(btrue, B2)      =&gt; B2   %% Use Variables
      case band(bfalse, B2)     =&gt; bfalse
      case bor(btrue, btrue)    =&gt; btrue  %% Use a truth table
      case bor(btrue, bfalse)   =&gt; btrue
      case bor(bfalse, btrue)   =&gt; btrue
      case bor(bfalse, bfalse)  =&gt; bfalse
    };
}</programlisting></para>

        <para>First, type declarations are used to define the abstract syntax
        of the type Bool. Next, a similar reduce function is defined as
        before, but now we use abstract patterns.</para>
      </section>

      <section>
        <title>Abstract Booleans defined with rules</title>

        <para>In ASF, values are always reduced to a normal form before they
        are created. For some applications this normalization or
        canonicalization feature is very handy. We introduce the following
        syntax, which can also help in the transformation of old ASF+SDF
        programs to Rascal:</para>

        <para><programlisting>module Bool-rules

data Bool btrue;
data Bool bfalse;
data Bool band(Bool L, Bool R);
data Bool bor(Bool L, Bool R);  

rule a1 band(btrue, Bool B2)  =&gt; B2 
rule a2 band(bfalse, Bool B2) =&gt; bfalse

rule o1 bor(btrue, btrue)     =&gt; btrue
rule o2 bor(btrue, bfalse)    =&gt; btrue
rule o3 bor(bfalse, btrue)    =&gt; btrue
rule o4 bor(bfalse, bfalse)   =&gt; bfalse</programlisting>These rules are
        applied on every Bool that is constructed. Like in ASF+SDF it is the
        responsibility of the programmer to make sure the rules are confluent
        and terminating. A rule definition has the same syntax and semantics
        as the switch construct, allowing backtracking, side-effects and
        checking of conditions.</para>

        <para>There are some issues here:</para>

        <itemizedlist>
          <listitem>
            <para>It should be dissallowed to have private rules on public
            constructors; normalization is a global effect on public
            data-structures. On the other hand, constructors that are local to
            a module may have some private rules applied to them; but public
            rules on private constructors are dissallowed too.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Concrete Booleans defined with rules</title>

        <para>In a similar fashion, the concrete syntax version of Booleans
        can be defined using rules:<programlisting>module Bool-conc-rules

import languages/Booleans/syntax;

rule a1 true &amp; &lt;Bool B2&gt;   =&gt; &lt;B2&gt;
rule a2 false &amp; &lt;Bool B2&gt;  =&gt; false

rule o1 true | true        =&gt; true
rule o2 true | false       =&gt; true
rule o3 false | true       =&gt; true
rule o4 false | false      =&gt; false</programlisting></para>
      </section>
    </section>

    <section>
      <title>Abstract Graph datatype</title>

      <para>In the Meta-Environment we use an abstract data type to exchange
      data representing graphs. It can be defined as follows.<programlisting>module Graph

data Graph graph(NodeList nodes, 
                 EdgeList edges, 
                 AttributeList attributes);

type list[Node] Nodelist;

data Node node(NodeId id, 
               AttributeList attributes);

data Node subgraph(NodeId id, 
                   NodeList nodes, 
                   EdgeList edges, 
                   AttributeList attributes);

data NodeId id(term id);

type list[Attribute] AttributeList;

data Attribute bounding-box(Point first, Point second);
data Attribute color(Color color);
data Attribute curve-points(Polygon points);
data Attribute direction(Direction direction);
data Attribute fill-color(Color color);
data Attribute info(str key, value value);
data Attribute label(str label);
data Attribute tooltip(str tooltip);
data Attribute location(int x, int y);
data Attribute shape(Shape shape);
data Attribute size(int width, int height);
data Attribute style(Style style);
data Attribute level(str level);
data Attribute file(File file);
data Attribute file(value file);

data Color rgb(int red, int green, int blue);

data Style bold | dashed | dotted | filled | invisible | solid;

data Shape box | circle | diamond | egg | elipse | hexagon | 
           house | octagon | parallelogram | plaintext | 
           trapezium | triangle;

data Direction forward | back | both | none;

type list[Edge] Edgelist;

data Edge edge(NodeId from, 
               NodeId to, 
               AttributeList attributes);

type list[Point] Polygon;

data Point point(int x, int y);</programlisting></para>
    </section>

    <section>
      <title>Tree traversal</title>

      <para>Here is the binary tree example that we use in explaining
      traversal functions in ASF+SDF.<programlisting>module BTree-syntax
imports basic/Integers

exports 
  sorts BTREE
  context-free syntax
    Integer         -&gt; BTREE
    f(BTREE,BTREE)  -&gt; BTREE
    g(BTREE,BTREE)  -&gt; BTREE
    h(BTREE,BTREE)  -&gt; BTREE
    i(BTREE,BTREE)  -&gt; BTREE</programlisting><programlisting>module BTree-Examples
import BTree-syntax; 

%% Ex1: Count leaves in a BTREE
%% Idea: int N : T generates alle Integer leaves in the tree
%% Observe that there is no need to touch the contents of 
%% each Integer since we only count them.

int cnt(BTREE T) {
    return size({N | Integer N : T});
}

%% Ex1: alternative solution using a visit statement

int cnt(BTREE T) {
    int C = 0;
    visit(T) {
      case &lt;Integer N&gt; : C = C+1;
    };
    return C;
}
 
%% Ex2: Sum all leaves in a BTREE
%% NB sum is a built-in that adds all elements in a set or list.
%% Here we see immediately the need to convert between
%% - the syntactic sort "Integer"
%% - the built-in sort "int"
%% We use the toInt function that attempts convert any tree
%% to an int.

int sumtree(BTREE T) {
    return sum({toInt(N) | Integer N : T});
}

%% Ex2: using visit statement

int cnt(BTREE T) {
    int C = 0;
    visit(T) {
      case &lt;Integer N&gt; : C = C+toInt(N);
    };
    return C;
}

%% Ex3: Increment all leaves in a BTREE
%% Idea: using the visit statement visit all leaves in
%% the tree T that match an integer and replace each N in T by N+1.
%% The expression as a whole returns the modified tree
%% Note that two conversions are needed here:
%% - from Integer to int (using toInt)
%% - from int back to Integer (using parseString)

BTREE inc(BTREE T) {
    return visit (T) {
      case &lt;Integer N&gt;: insert parseString(toInt(N)+1);
    };
}

%% Ex4: full replacement of g by i
%% The whole repertoire of ASF+SDF traversal functions is available:
%% - bottom-up visit (T) { ... }
%% - bottom-up-break visit (T) { ... }
%% - etc.
%% A nice touch is that these properties are not tied to the
%% declaration of a travesal function (as in ASF+SDF) but to 
%% its use.

BTREE frepl(BTREE T) {
    return bottom-up visit (T) {
      case [| g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) |] =&gt;
           i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    };
}

%% Ex5: Deep replacement of g by i

BTREE frepl(BTREE T) {
    return bottom-up-break visit (T) {
      case[| g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) |] =&gt;
             i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    };
}

%% Ex6: shallow replacement of g by i (i.e. only outermost 
%% g's are replaced); 

BTREE srepl(BTREE T) {
    return top-down-break visit (T) {
      case [| g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) |] =&gt; 
              i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    };
}

%% Ex7: We can also add the top-down-break directive to the 
%% generator to get only outermost nodes.

set[BTREE] find_outer_gs(BTREE T) {
    return
    { S | top-down-break STATEMENT S : T, 
          [| g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) |] ~~ S };
}
 
%% Ex8: accumulating transformer that increments leaves with 
%% amount D and counts them
tuple[int, BTREE] count_and_inc(BTREE T, int D) {
    int C = 0;
    
    visit (T) {
      case &lt;Integer N&gt;: { C = C + 1; 
                          int N1 = toInt(N) + D; 
                          insert parse(unparseToString(N1));
                        }
    };
    return &lt;C, T&gt;;
}
</programlisting></para>
    </section>

    <section>
      <title>Substitution in Lambda</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.</para>

      <programlisting>module examples/Lambda/Lambda-syntax

exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+               -&gt; Var
context-free syntax
     "prime" "(" Var ")"  -&gt; Var  %% generate unique name
     Var                  -&gt; Exp  %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp  %% function abstraction
     Exp Exp              -&gt; Exp  %% function application
</programlisting>

      <para>Examples:</para>

      <para><programlisting>module Lambda-Examples

import Lambda-syntax;

set[Var] allVars(Exp E) {
    return {V | Var V : E};
}

set[Var] boundVars(Exp E) {
    return {V | fn &lt;Var V&gt; =&gt; &lt;Exp E1&gt; : E};
} 

set[Var] freeVars(Exp E) {
    return allVars(E) - boundVars(E);
}

%% Generate a fresh variable if V does not occur in 
%% given set of variables.

Var fresh(Var V, set[Var] S) {
    if (V in S){ return prime(V); } else {return V;}
}

%% Substitution: replace all occurrences of V in E2 by E1

Exp subst(Var V1, Exp E1, Exp E2) {

    return visit (E2) { 
      case &lt;Var V2&gt;: insert (V1==V2) ? E1 : V2;

      case &lt;Exp Ea&gt; &lt;Exp Eb&gt;:
        insert [| &lt;subst(V, E, Ea)&gt; &lt;subst(V, E, Eb)&gt; |];

      case fn &lt;Var V2&gt; =&gt; &lt;Var Ea&gt;:
        if (V1 == V2) { insert [| fn &lt;V2&gt; =\&gt; &lt;Ea&gt; |]; }

      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;:
        if(V1 != V2 &amp;&amp; !(V1 in freeVars(E2) &amp;&amp; 
           V2 in freeVars(E1))){
           insert [| fn &lt;V2&gt; =\&gt; &lt;subst(V1, E1, Ea)&gt; |];
        }              
 
      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;: 
        if(V1 != V2 &amp;&amp; V1 in freeVars(Ea) &amp;&amp;
           V2 in freeVars(E1)){
           Var V3 = fresh(V2, freeVars(Ea) + freeVars(E1));
           Exp EaS = subst(V1, E1, subst(V2, V3, E2));
           insert [| fn &lt;V3&gt; =\&gt; &lt;EaS&gt; |];
        }
    };
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let</title>

      <para><programlisting>module Let-syntax
exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+                           -&gt; Var
context-free syntax
     Var                              -&gt; Exp
     "let" Var "=" Exp "in" Exp "end" -&gt; Exp </programlisting>Examples:<programlisting>module Let-Example

import Let;

%% Rename all bound variables in an Exp
%% Version 1: purely functional
%% Exp: given expression to be renamed
%% rel[Var,Var]: renaming table
%% Int: counter to generate unique variables

Exp rename(Exp E, rel[Var,Var] Rn, Int Cnt) {
    switch (E) {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end:
         return [| let &lt;parseString("x" + toString(Cnt))&gt; = 
                       &lt;rename(E1, Rn, Cnt)&gt;
                   in 
                       &lt;rename(E2, {&lt;V, Y&gt;} + Rn, Cnt+1)&gt;
                   end
                |];
          
    case &lt;Var V&gt;: return Rn[V];

    default: return E;
    }
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let using globals</title>

      <para>Here is the same renaming function now using two global
      variables.<programlisting>module Let-Example

import Let;

%% Rename all bound variables in an Exp
%% Version 2: using global variables
%% Cnt: global counter to generate fresh variables
%% rel[Var,Var]: global renaming table

global int Cnt = 0;
global rel[Var,Var] Rn = {};

Var newVar() {
    global int Cnt;  
    Cnt = Cnt + 1;
    return parseString("x" + toString(Cnt));
}

Exp rename(Exp E) {
    global int Cnt;
    global rel[Var,Var] Rn;
    switch (E) {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end: {
         Var Y = newVar();
         Rn = {&lt;V, Y&gt;} + Rn;
         return [| let &lt;Y&gt;= &lt;rename(E1)&gt;
                   in 
                      &lt;rename(E2)&gt;
                   end 
                |];
          }

    case &lt;Var V&gt;: return Rn[V];

    default: return E;
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico Typechecker</title>

      <para>The following example shows a typechecker for Pico that generates
      a list of error messages.<programlisting>module Typecheck

import Pico-syntax;
import Errors;

type map[PICO-ID,TYPE] Env;

list[Error] tcp(PROGRAM P) {
    switch (P) {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
           Env Env = {&lt;Id, Type&gt; | 
                      [| &lt;PICO-ID Id&gt; : &lt;TYPE Type&gt; |] : Decls};
           return [ tcst(S, Env) | Stat S : Series ];
      }
    }
    return [];
}

list[Error] tcst(Stat Stat, Env Env) {
    switch (Stat) {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt;|]: {
        TYPE Type = Env[Id];
        return type_of(Exp, Type, Env);
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:
        return type_of(Exp, natural, Env) + 
               tcs(Stats1, Env) + tcs(Stats2, Env);

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od: 
        return type_of(Exp, natural, Env) + tcs(Stats, Env);
    }
    return [];
}
 
list[Error] type_of(Exp E, TYPE Type, Env Env) {
    switch (E) {
      case &lt;NatCon N&gt;: if(Type == natural){ return []; }

      case &lt;StrCon S&gt;: if(Type == string) { return []; }

      case &lt;PICO-ID Id&gt;: {
         TYPE Type2 = Env(Id);
         if(Type2 == Type) { return []; }
      }

      case &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type_of(E1, natural, Env) + 
                  type_of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; - &lt;EXP E2&gt;:
        if(Type == natural){
           return type_of(E1, natural, Env) + 
                  type_of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; || &lt;EXP E2&gt;: 
        if(Type == string){
          return type_of(E1, string, Env) + 
                 type_of(E1, string, Env);
        }
    
      default: return [error("Incorrect type")];
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator</title>

      <para><programlisting>module Pico-eval
import pico/syntax/Pico;
 
data PICO_VALUE intval(int) | strval(str);

type map[PICO-ID, PICO_VALUE] VEnv;

VEnv evalProgram(PROGRAM P){
    switch (P) {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          VEnv Env = evalDecls(Decls);
          return evalStatements(Series, Env);
      }
   }
}

VEnv evalDecls(DECLS Decls){
    VEnv Env = {};
    visit (Decls) {
      case &lt;PICO-ID Id&gt; : string: { 
           Env[Id] = strval(""); 
           return Env;
      }
      case &lt;PICO-ID Id&gt; : natural: { 
           Env[Id] = intval(0);  
           return Env;
      }
    };
    return Env;
}

VEnv evalStatements({STATEMENT ";"}* Series, VEnv Env){
    switch (Series) {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        Env Env2 = evalStatement(Stat, Env);
        return evalStatements(Series2, Env2);
      }
      default: return Env;
    }
}

VEnv evalStatement(STATEMENT Stat, VEnv Env){
    switch (Stat) {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        Env[Id] = evalExp(Exp, Env);
        return Env;
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                       else &lt;{STATEMENT ";"}* Stats1&gt; fi:{
        if(evalExp(Exp, Env) != intval(0)){
          return evalStatments(Stats1, Env);
        } else {
          return evalStatements(Stats2, Env);
        }
      }

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od: {
        if(evalExp(Exp, Env) != intval(0)){
          return Env;
        } else {
          VEnv Env2 = evalStatements(Stats1, Env);
          return evalStatement(Stat, Env2);
        }
      }
      default: return Env;
    }
}

PICO_VALUE evalExp(Exp exp, VEnv Env) {
    switch (exp) {
      case NatCon[| &lt;NatCon N&gt; |]: 
           return intval(toInt(unparseToString(N)));

      case StrCon[| &lt;StrCon S&gt; |]: 
           return strval(unparseToString(S));

      case PICO-ID[| &lt;PICO-ID Id&gt; |]: 
           return Env[Id];

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;:
           if(intval(int n1) ~~ evalExp(exp1, Env) &amp;&amp;
              intval(int n2) ~~ evalExp(exp2, Env)){
              return intval(n1 + n2);
           }
      
      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;:
            if(intval(int n1) ~~ evalExp(exp1, Env) &amp;&amp;
               intval(int n2) ~~ evalExp(exp2, Env)){
               return intval(n1 - n2);
           }
 
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;:
           if(strval(str s1) ~~ evalExp(exp1, Env) &amp;&amp;
              strval(str s2) ~~ evalExp(exp2, Env)){
              return strval(s1 + s2);
           }
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator with globals</title>

      <para>Here is the same evaluator but now using a global variable to
      represent the value environment.<programlisting>module Pico-eval

import pico/syntax/Pico;

data PICO_VALUE intval(int) | strval(str);

type map[PICO-ID, PICO_VALUE] VEnv;

VEnv Env = {};

void evalProgram(PROGRAM P){
    switch(P) {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          evalDecls(Decls);
          evalStatements(Series);
      }
   }
}

VEnv evalDecls(DECLS Decls){
    global Venv Env;
    visit (Decls) {
      case &lt;PICO-ID Id&gt; : string:  Env[Id] = strval("");
      case &lt;PICO-ID Id&gt; : natural: Env[Id] = intval(0);
    };
    return Env;
}

void evalStatements({STATEMENT ";"}* Series){
    switch (Series) {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        evalStatement(Stat);
        evalStatements(Series2);
        return;
      }
      default: return;
    }
}

void evalStatement(STATEMENT Stat){
    global Venv Env;
    switch (Stat) {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        Env[Id] = evalExp(Exp);
        return;
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:{
        if(evalExp(Exp) != intval(0)) {
          evalStatements(Stats1);
          return;
        } else {
          evalStatements(Stats2);
          return;
        }
      }

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od:{
        if(evalExp(Exp) != intval(0)){
          return;
        } else {
          evalStatements(Stats1);
          evalStatement(Stat);
          return;
        }
      }
    }
};

PICO_VALUE evalExp(Exp exp) {
    global Venv Env;
    switch (exp) {
      case &lt;NatCon N&gt;: intval(toInt(unparseToString(N)));

      case &lt;StrCon S&gt;: return strval(unparseToString(S));

      case &lt;PICO-ID Id&gt;: return Env[Id];

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;:
           if(intval(int n1) ~~ evalExp(exp1) &amp;&amp;
              intval(int n2) ~~ evalExp(exp2)){
              return intval(n1 + n2);
           }

      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;:
           if(intval(int n1) ~~ evalExp(exp1) &amp;&amp;
              intval(int n2) ~~ evalExp(exp2)){
              return intval(n1 - n2);
           }
   
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;:
           if(strval(str s1) ~~ evalExp(exp1) &amp;&amp;
              strval(str s2) ~~ evalExp(exp2)){
              return strval(s1 + s2);
           }
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico control flow extraction</title>

      <programlisting>module Pico-controlflow
 
import pico/syntax/Pico;

data CP exp(EXP) | stat(STATEMENT);

type tuple[set[CP] entry, 
           rel[CP,CP] graph, 
           set[CP] exit] CFSEGMENT;

CFSEGMENT cflow({STATEMENT ";"}* Stats){ 
    switch (Stats) {
      case &lt;STATEMENT Stat&gt; ; &lt;{STATEMENT ";"}* Stats2&gt;: { 
           CFSEGMENT CF1 = cflow(Stat);
           CFSEGMENT CF2 = cflow(Stats2);
           return &lt;CF1.entry, 
                   CF1.graph | CF2.graph | (CF1.exit * CF2.entry), 
                   CF2.exit&gt;;
      }

      case [| |]: return &lt;{}, {}, {}&gt;;
    }
}

CFSEGMENT cflow(STATEMENT Stat){
    switch (Stat) {
      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od : {
           CFSEGMENT CF = cflow(Stats);
           set[CP] E = {exp(Exp)};
           return &lt; E, 
                    (E * CF.entry) | CF.graph | (CF.exit * E),
                    E
                  &gt;;
      }
                
      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats2&gt; fi: {
           CFSEGMENT CF1 = cflow(Stats1);
           CFSEGMENT CF2 = cflow(Stats2);
           set[CP] E = {exp(Exp)};
           return &lt; E, 
                    (E * CF1.entry) | (E * CF2.entry) | 
                                      CF1.graph | CF2.graph,
                    CF1.exit | CF2.exit
                  &gt;;
      }
         
      case &lt;STATEMENT Stat&gt;: return &lt;{Stat}, {}, {Stat}&gt;;
    }
}
</programlisting>

      <para></para>
    </section>

    <section>
      <title>Pico use def extraction</title>

      <programlisting>module Pico-use-def

import pico/syntax/Pico;

rel[PICO-ID, EXP] uses(PROGRAM P) {
  return {&lt;Id, E&gt; | EXP E : P, [| &lt;PICO-ID Id&gt; |] ~~ E};
}

rel[PICO-ID, STATEMENT] defs(PROGRAM P) { 
  return {&lt;Id, S&gt; | STATEMENT S : P, 
                    [| &lt;PICO-ID Id&gt; := &lt;EXP Exp&gt; |] ~~ S};
}</programlisting>

      <para>The above uses a "matching condition" to decompose
      <literal>S</literal>. The problem solved is that we want to have a name
      for the whole assignment <emphasis>and</emphasis> for the lhs
      identifier. Also note that, compared to older definitions of these
      functions, the iudentifier is placed as first element in each
      tuple.</para>
    </section>

    <section>
      <title>Pico uninitialized variables</title>

      <para><programlisting>module Pico-uninit

import pico/syntax/Pico;

import Pico-controlflow;
import Pico-use-def;

set[PICO-ID] uninit(PROGRAM P) {
    rel[EXP,PICO-ID] Uses = uses(P);
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    CFSEGMENT CFLOW = cflow(P);
    set[CP] Root = CFLOW.entry;
    rel[CP,CP] Pred = CFLOW.graph; 

    return {Id | &lt;EXP E, PICO-ID Id&gt; : Uses,
                 E in reachX(Root, Defs[Id], Pred)
    };
}
</programlisting></para>
    </section>

    <section>
      <title>Pico common subsexpression elimination</title>

      <para><programlisting>module Pico-common-subexpression

import pico/syntax/Pico;
import Pico-controlflow;
import Pico-use-def;

PROGRAM cse(PROGRAM P) {
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;
    map[EXP, PICO-ID] replacements = 
       {&lt;E2 -&gt; Id&gt; | STATEMENT S : P,
                   [| &lt;PICO-ID Id&gt; := &lt;EXP E&gt; |] ~~ S,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[Id], Pred)
       };
  
    return visit (P) {
      case &lt;EXP E&gt;: if([| &lt;PICO-ID Id&gt; |] ~~ replacements(E)){
                       replace-by Id;
                    }
    };
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions E2 by Id, such
      that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>Id does not occur in E,</para>
        </listitem>

        <listitem>
          <para>E2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and E2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico constant propagation</title>

      <para><programlisting>module Pico-constant-propagation

import  pico/syntax/Pico;
import  Pico-controlflow;
import  Pico-use-def;

Boolean is_constant(EXP E) {
   switch (E) {
     case &lt;NatCon N&gt;: return true;

     case &lt;StrCon S&gt;: return true;

     case &lt;EXP E&gt;: return false;
   }
}

PROGRAM cp(PROGRAM P) {
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;

    map[PICO-ID, EXP] replacements = 
      {&lt;Id2 -&gt; E&gt; | STATEMENT S : P,
                  [| &lt;PICO-ID Id&gt; := &lt;EXP E&gt; |] ~~ S,
                  is_constant(E),
                  PICO-ID Id2 : reachX({S},Defs[Id],Pred),
                  Id2 == Id 
      };  
 
    return visit (P) {
     case &lt;PICO-ID Id&gt;: if(&lt;EXP E&gt; ~~ replacements[Id]){
                           insert E;
                        }
    };
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions Id2 by the constant E,
      such that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id ~~ E,</para>
        </listitem>

        <listitem>
          <para>E is constant,</para>
        </listitem>

        <listitem>
          <para>Id2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>Id2 is equal to Id,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and Id2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico Reaching definitions</title>

      <para>Recall the equations construct as used, for example, in the
      reaching definitions example in the Rscript guide. It computes the
      values of a set of variables until none of them changes any longer. The
      "solve" statement achives the same effect.<programlisting>module Pico-reaching-defs

type tuple[Stat theStat, Var theVar] Def;
type tuple[Stat theStat, Var theVar] Use;

set[Stat] predecessor(rel[Stat,Stat] P, Stat S) { 
    return invert(P)[S];
}

set[Stat] successor(rel[Stat,Stat] P, Stat S) { 
    return P(S);
}

rel[Stat, Def] reaching_definitions(rel[Stat,Var] DEFS, 
                                        rel[Stat,Stat] PRED) {

    set[Stat] STATEMENT = carrier(PRED);

    rel[Stat,Def] DEF  = {&lt;S,&lt;S,V&gt;&gt; | tuple[Stat S, Var V]: DEFS};

    rel[Stat,Def] KILL = 
        {&lt;S1, &lt;S2, V&gt;&gt; | tuple[Stat S1, Var V] : DEFS, 
                         tuple[Stat S2, V] : DEFS, 
                         S1 != S2
        };

     rel[Stat,Def] IN = {};
     rel[Stat,Def] OUT = DEF;

     solve {
           IN  =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Stat P : predecessor(PRED,S), 
                            Def D : OUT[P]};
           OUT =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Def D : DEF[S] + (IN[S] - KILL[S])}
    }
    return IN;
}</programlisting></para>
    </section>

    <section>
      <title>Structured lexicals: numbers</title>

      <para>Given the SDF definition:<programlisting>sorts Digit Number Real  
lexical syntax
   [0-9]             -&gt; Digit
   Digit+            -&gt; Number
   Number "." Number -&gt; Real</programlisting>we can write a normalization
      rule for <literal>Number</literal> that removes leading
      zeros:<programlisting>rule n1 number("0" &lt;Digit+ Ds&gt;) =&gt; number(&lt;Ds&gt;)</programlisting></para>

      <para>Note that a character class can be used instead of the sort
      <literal>Digit</literal>:<programlisting>rule n2 number("0" &lt;[0-9]+ Ds&gt;) =&gt; number(&lt;Ds&gt;)</programlisting></para>

      <para>A truncation function on <literal>Real</literal> can replace the
      mantissa by 0:</para>

      <para><programlisting>Real truncate(Real R){
    switch (R) {
       case real(&lt;Number Num&gt; "." &lt;Digit+ Ds&gt;) =&gt; real(&lt;Num&gt; "." "0")
    }
}</programlisting></para>
    </section>

    <section>
      <title>Structured Lexicals: strings</title>

      <para>Given the SDF definition:<programlisting>sorts String NQChar
lexical syntax
   ~[\"]             -&gt; NQChar
   [\"] NQChar* [\"] -&gt; String</programlisting>A function that removes the
      <emphasis>first</emphasis> newline from a string can be written
      as:<programlisting>String removeFirstNL(String S){
    switch (S) {
      case string("\"" &lt;NQChar* Chars1&gt; "\n" &lt;NQChar* Chars2&gt; "\"") =&gt;
           string("\"" &lt;Chars1&gt; &lt;Chars2&gt; "\"")
    }
}</programlisting></para>

      <para>A function that removes all newline from a string:<programlisting>String removeAllNL(String S){
    return innermost visit (S) {
      case string("\"" &lt;NQChar* Chars1&gt; "\n" &lt;NQChar* Chars2&gt; "\"") =&gt;
           string("\"" &lt;Chars1&gt; &lt;Chars2&gt; "\"")
    };
}</programlisting></para>
    </section>

    <section>
      <title>Symbol table with scopes</title>

      <para>Here is a (probably naive) implementation of a symbol table that
      maintains a list of numbered scopes as well as a (Name, Value) mapping
      in each scope. Note that we introduce parameterized modules to do this
      right.<programlisting>module SymTable[&amp;Name, &amp;Value]

%% A scope-oriented symbol table.
%% Each scope consists of a map from names to values. 
%% This is more intended to explore whether this can be expressed
%% *at all* than that the datatype is well designed.

type rel[&amp;Name, &amp;Value] ScopeMap;
type int ScopeId;
data STable[&amp;Name, &amp;Value] stable(ScopeId scope, 
                                  rel[int, ScopeMap] scopes); 

%%Create a new, empty,  table
fun STable[&amp;Name, &amp;Value] new_table(){
  return stable(0, {&lt;0, {}&gt;});
}

%% Create a new, non-empty, table
fun STable[&amp;Name, &amp;Value] new_table(ScopeId scope, 
                              rel[int, ScopeMap] scopes){
  return stable(scope, scopes);
} 

%% Update, in a given scope, the value of a variable
fun STable[&amp;Name, &amp;Value] update(STable[&amp;Name, &amp;Value] ST, 
                                 ScopeId scope, 
                                 &amp;Name N, 
                                 &amp;Value V){
  ST.scopes(scope) = V;
  return new_table(scope, ST.scopes)
}

%% Get, in a given scope, the value of a variable
fun STable[&amp;Name, &amp;Value] value_of(STable[&amp;Name, &amp;Value] ST, 
                                ScopeId scope, 
                                &amp;Name N){
  return ST.scopes(scope)(N)
}

%% update, in the current scope, the value of a variable
fun STable[&amp;Name, &amp;Value] update(STable[&amp;Name, &amp;Value] ST, 
                                 &amp;Name N, 
                                 &amp;Value V){
%%  ST.scopes(scope)(N)= V;
  return new_table(scope, ST.scopes)
}

%% Get, in the current scope, the value of a variable
fun STable value_of(STable[&amp;Name, &amp;Value] ST, 
                 &amp;Name N){
  return ST.scopes(ST.scope)(N)
}

%% add a new scope and make it the current scope
fun STable[&amp;Name, &amp;Value] new_scope(STable[&amp;Name, &amp;Value] ST){
  ScopeId scope = ST.scope + 1;
  return new_table(scope, ST.scopes);
}

%% switch to another scope
fun STable[&amp;Name, &amp;Value] switch_scope(STable[&amp;Name, &amp;Value] ST, 
                                       ScopeId scope){
  return new_table(scope, ST.scopes);
}

</programlisting></para>
    </section>

    <section>
      <title>Innerproduct</title>

      <para>[Example inspired by TXL documentation]</para>

      <para>Define nnerproduct on lists of integers, e.g. innerProduct([1, 2,
      3] .[3, 2, 1]) =&gt; 10.</para>

      <programlisting>module Innerproduct

int innerProduct(list[int] V1, list[int] V2){
    if (size(V1) == 0 || size(V2) == 0){
       return 0;
    } else {
       return (N1*N2) + innerProduct(rest(V1), rest(V2));
    }
 }</programlisting>
    </section>

    <section>
      <title>Bubble sort</title>

      <para>[Example inspired byTXL documentation]</para>

      <programlisting>module Bubble

%% sort1: uses list indexing and for-loop

list[int] sort1(list[int] Numbers){
  for(int I : [0 .. size(Numbers) - 2 ]){
     if(Numbers[I] &gt; Numbers[I+1]){
       Numbers[I], Numbers[I+1] = Numbers[I+1], Numbers[I];
       return sort(Numbers);
     }
  }
  return Numbers;
}

%% sort2: uses list matching and switch

list[int] sort2(list[int] Numbers){
  list[int] Nums1, Nums2;
  int P, Q;

  switch(Numbers){
    case [Nums1, P, Q, Nums2]:
       if(P &gt; Q){
          return sort([Nums1, Q, P, Nums2]);
       }
     default: return Numbers;
   }
  
}

%% sort3: uses list matching and visit

list[int] sort3(list[int] Numbers){
  list[int] Nums1, Nums2;
  int P, Q;

  return innermost visit(Numbers){
    case [Nums1, P, Q, Nums2]:
       if(P &gt; Q){
          insert [Nums1, Q, P, Nums2];
       }
     default: Numbers;
    };
}

</programlisting>
    </section>

    <section>
      <title>Generic Bubble sort</title>

      <para>Here is a generic bubble sort wich uses type parameters (&amp;E)
      and a function parameter.<programlisting>module Bubble-Gen

list[&amp;E] sort(list[&amp;E] Elements, bool GreaterThan(&amp;E, &amp;E)){
  for(int I : [0 .. size(Elements) - 2]){
     if(GreaterThan(Elements[I],  Elements[I+1])){
       Elements[I], Elements[I+1] = Elements[I+1], Elements[I];
       return sort(Elements);
     }
  }
  return Elements;
}</programlisting></para>

      <para>Of course, we can write a generic sort on arbitrary lists.</para>
    </section>

    <section>
      <title>Applying Rascal to Rascal</title>

      <para>Here are some simple examples of applying Rascal to
      itself:<programlisting>module SimpleExamples

imports Rascal;

int cntModules(Rascal program)
@doc{Count the modules in a Rascal program}
{
    int cnt = 0;

    visit (program){
      case Module M: cnt += 1;
    };
    return cnt;
}

set[Name] extractNames(Rascal program)
@doc{Extract all names from a Rascal program}
{
   set[Name] names = {};

   visit (program){
      case Name Nm: names += Name;
    };
    return names;
}

Rascal rename(Rascal program)
@doc{Prefix all names in the program with "x"}
{
   set[Name] names = {};

   return visit (program){
      case Name Nm: insert parseString("x" + toString(Nm));
    };
}

Rascal invertIf(Rascal program)
@doc{Switch the branches of if statements}
{
  return visit (program){
      case if (&lt;Expression E&gt;)  &lt;Block B1&gt; else &lt;Block B2&gt;: 
           insert [| if (!&lt;E&gt;) &lt;B2&gt; else &lt;B1&gt; |];
    };
}</programlisting></para>
    </section>

    <section>
      <title>Read-Eval-Print Loop (REPL) [Needs further discussion]</title>

      <para>For the scripting of applications it is important to have a
      command language and read-eval-print loop. Here is an attempt. </para>

      <para>We copy the Python REPL style:</para>

      <itemizedlist>
        <listitem>
          <para>The command promt prompt is "&gt;&gt;&gt;".</para>
        </listitem>

        <listitem>
          <para>Continuation lines are prefixed with "...".</para>
        </listitem>

        <listitem>
          <para>Answers start at the beginning of the line.</para>
        </listitem>
      </itemizedlist>

      <para><programlisting>&gt;&gt;&gt; {1, 2, 3} + {2, 3, 4}
{1, 2, 3, 4}
&gt;&gt;&gt; first([1, 2, 3])
1
&gt;&gt;&gt; rest([ 1,
...           2, 3])
[2, 3]</programlisting>One advantage of this style is that such a dialog can
      be run and checked automatically. This has two effects:</para>

      <itemizedlist>
        <listitem>
          <para>Examples in manuals become test cases.</para>
        </listitem>

        <listitem>
          <para>We can introduce a "tests" attribute for functions that
          conatisn a REPL script. This can also be tested.
          Example:<programlisting>public &amp;T max(set[&amp;T] R)
  @doc{Maximum of a set}
  @tests{
  &gt;&gt;&gt; max({1, 2, 3})
  3
  &gt;&gt;&gt; max({3, 2, 1})
  3
  }
{
  &amp;T result = arb(R);
  for(&amp;T E : R){
    result = max(result, E);
  }
  return result;
}</programlisting></para>
        </listitem>
      </itemizedlist>

      <para><caution>
          <para>The remainder of this section is a mess!</para>
        </caution><programlisting>&gt;&gt;&gt; import lang.java.syntax.Main as Java;
&gt;&gt;&gt; str source = read("program.java");
&gt;&gt;&gt; CU program = parseString(source);

data B and(B b1, B b2)

B.and &lt;= B &lt;= value

lexical syntax
  [\n\ \t\n] -&gt; LAYOUT


view Boolean &lt;= tree and(B b1, LAYOUT? l, 'a' a?, LAYOUT? l2, B b2) appl(prod([ B &amp; B -&gt; B], [ B b1 , LAYOUT? _, lit('a'), LAYOUT? _ = appl(),B b2 ])
view Boolean &lt;= tree or()            appl()

Boolean . and &lt;= Boolean &lt;= tree &lt;= value

&gt; int count(CU P) {
&gt;   int cnt = 0;
    Boolean B1 = true, B2, B3;

&gt;   visit(P) {
      acase and(B1,l1=&lt;LAYOUT? L&gt;,&lt;Boolean B2&gt;) =&gt; and(B1, l1=parseString(" "), a=A, l2=" ", B2) 
      case &lt;Boolean B1&gt; &amp; &lt;B2&gt; : 
      case B &amp; B : 
      case [| &lt;Identifier&gt; |] : natural =&gt;
&gt;     acase if(&lt;E&gt;,&lt;S&gt;) : cnt++;
      acase &lt;Bool.and is&gt; 
&gt;   }
&gt;   return cnt
&gt; }

&gt; count(program)
17</programlisting>There are several innovations here:</para>

      <itemizedlist>
        <listitem>
          <para>The import associates a name with the imported module.<caution>
              <para>Work out the details.</para>
            </caution><note>
              <para>This means that "grammar" and "rule" become notions that
              can be manipulated.</para>
            </note></para>
        </listitem>

        <listitem>
          <para>There is a read functions that reads a text file into a
          string.</para>
        </listitem>

        <listitem>
          <para>We associate a parse function with every non-terminal in a
          grammar.</para>
        </listitem>

        <listitem>
          <para>The notation <literal>Java::Statements.IF</literal> consists
          of three parts:</para>

          <itemizedlist>
            <listitem>
              <para>Language name</para>
            </listitem>

            <listitem>
              <para>Sort name</para>
            </listitem>

            <listitem>
              <para>Rule name (currently implemented with the "cons"
              attribute).</para>
            </listitem>
          </itemizedlist>

          <para>It can be used as pattern. Other potential uses are as
          generator:<programlisting>{S | Java::Statements.IF S : P}</programlisting>It
          generates all if statements in P.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>The Rascal standard library</title>

    <para>In this section we summarize the (over 300!) functions in the Rascal
    Standard Library.</para>

    <section>
      <title>Main functions</title>

      <para>The main functions of the library are listed in the following
      table.</para>

      <table>
        <title>Main functions in Rascal Standard Library (see Table <xref
        linkend="table.operators-on-datatypes" /> for all operators)</title>

        <tgroup cols="11">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center"> </entry>

              <entry align="center">bool</entry>

              <entry align="center">int</entry>

              <entry align="center">double</entry>

              <entry align="center">str </entry>

              <entry align="center">loc</entry>

              <entry align="center">list</entry>

              <entry align="center">tuple</entry>

              <entry align="center">set</entry>

              <entry align="center">map</entry>

              <entry align="center">rel</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>size</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>get</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>arb</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>toInt</entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>toDouble</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>toString</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>toList</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>-</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>toSet</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>toMap</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>toRel</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>reverse</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>split</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>startsWith</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>endsWith</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>toLowerCase</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>toUpperCase</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>reducer</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>mapper</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>min</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>max</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>sum</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>multiply</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>average</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>get_location</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>set_location</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Notes:</para>

      <itemizedlist>
        <listitem>
          <para>Operator <literal>==</literal> implements equality on all
          types. It is extended for data types using structural
          equality.</para>
        </listitem>

        <listitem>
          <para>Operator <literal>&lt;</literal> implements less-than on all
          types.</para>
        </listitem>

        <listitem>
          <para>Operators +, -, *, / implement these operators for most types.
          For structured types these operatords exist in three flavours:
          structured value op struct, structured value op element, and element
          op structured value.</para>
        </listitem>

        <listitem>
          <para><literal>size</literal> gives the number of elements of many
          types.</para>
        </listitem>

        <listitem>
          <para><literal>get</literal> (corresponds to the indexing notation
          R[N]) gives the N-th element of a structure.</para>
        </listitem>

        <listitem>
          <para><literal>arb</literal> generates an arbitrary element from a
          structured value.</para>
        </listitem>

        <listitem>
          <para><literal>toString</literal> converts all values to a string
          representation.</para>
        </listitem>

        <listitem>
          <para><literal>toList</literal>, <literal>toSet</literal>,
          <literal>toMap</literal>, <literal>toRel</literal> provide
          conversions between structured types. They may be implemented as
          just a type conversion (and not a data conversion).</para>
        </listitem>

        <listitem>
          <para><literal>reverse</literal> reverses the elements of ordered
          structured types.</para>
        </listitem>

        <listitem>
          <para><literal>reduce</literal>r and <literal>mapper</literal> take
          a function as argument and traverse a structured value.<note>
              <para>Due to a name class with the type constructor
              <literal>map</literal>, we use the name
              <literal>mapper</literal> for a function that is ussually called
              <literal>map</literal>. The usual function
              <literal>reduce</literal> is therefore called
              <literal>reducer</literal>.</para>
            </note></para>
        </listitem>

        <listitem>
          <para><literal>min</literal> and <literal>max</literal> compute the
          smallest (largest) of two basic values or all elements of structured
          values.</para>
        </listitem>

        <listitem>
          <para><literal>average</literal> computes the average value of
          structured values that contain integers or doubles.</para>
        </listitem>

        <listitem>
          <para>get_location and set_location are access functions for values
          of type <literal>loc</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Additional functions on lists sets, maps and relations</title>

      <para>Additional functions on lists, sets maps and relations are listed
      in the following table.<table>
          <title>Additional functions on lists, sets, maps and
          relations</title>

          <tgroup cols="6">
            <colspec align="center" />

            <thead>
              <row>
                <entry align="center"> </entry>

                <entry align="center">list</entry>

                <entry align="center">set</entry>

                <entry align="center">map</entry>

                <entry align="center">rel</entry>

                <entry align="center">graph</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>first</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>rest</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>makeString</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>sort</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>id</entry>

                <entry></entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>power</entry>

                <entry></entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>compose</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>invert</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>complement</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>domain</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>range</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>carrier</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>domainR</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>rangeR</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>carrierR</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>domainX</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>rangeX</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>carrierX</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>

                <entry></entry>
              </row>

              <row>
                <entry>top</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>bottom</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>reachR</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>reachX</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>Other functions</title>

      <para>The remaining functions take care of annotations, the tree
      datatype, input/output and communication with the global database with
      program facts, the Program Database (PDB).</para>
    </section>

    <section>
      <title>Source code</title>

      <para>This is a very first draft of the library. When the structure is
      stable we will split it in modules.<caution>
          <para>The following code is maintained externally and then copied
          :-( to this document, so be carefull with changes.</para>
        </caution><programlisting>module RascalStandardLibrary

%%tag function primitive QualName;
%%tag function memo void;
%%tag function java CompilationUnit;
%%tag all doc str;

%% Here is a flat list of library functions that will
%% structured in to coherent submodules.

%% --- Comparison operators ----------------------------------
%% Each type defines == and &lt;. The following
%% functions extend them.

public bool !=(&amp;T A, &amp;T B){
  return !(A == B);
}

public bool &lt;=(&amp;T A, &amp;T B){
  return A &lt; B || A == B;
}

public bool &gt;(&amp;T A, &amp;T B){
  return B &lt; A &amp;&amp; A != B;
}

public bool &gt;=(&amp;T A, &amp;T B){
  return B &lt; A;
}

public &amp;T min(&amp;T A, &amp;T B){
  return (A &lt; B) ? A : B;
}

public &amp;T max(&amp;T A, &amp;T B){
  return (A &lt; B) ? B : A;
}

%% --- Boolean (bool) ----------------------------------------

public bool ==(bool B1, bool B2)
  @doc{Equality on Booleans}
  @primitive{"Bool.equal"}

public bool &lt;(bool B1, bool B2)
  @primitive{"Bool.less"}
 
public bool &amp;&amp;(bool B1, bool B2)
  @primitive{"Bool.and"}

public bool ||(bool B1, bool B2)
  @primitive{"Bool.or"}

public bool !(bool B){
  return B ? false : true;
}

public int arb()
  @primitive{"Bool.arb"}

public int toInt(bool B)
  @primitive{"Bool.toInt"}

public double toDouble(bool B)
  @primitive{"Bool.toDouble"}

public str toString(bool B)
  @primitive{"Bool.toString"}

%% --- Integer (int)------------------------------------------

public bool ==(int I1, int I2)
  @primitive{"Int.equal"}
  
public bool &lt;(int I1, int I2)
  @primitive{"Int.less"}

public int +(int I1, int I2) 
  @primitive{"Int.add"}

public int -(int I1, int I2)  
  @primitive{"Int.sub"}

public int *(int I1, int I2)
@primitive{"Int.mul}
 
public int /(int I1, int I2)
  throws divide_by_zero(str msg)
  @primitive{"Int.div"}

public int arb(int bgn, int end)
throws illegal_argument(str msg) %% if(end - bgn &lt;= 0)
  @primitive{"Int.arb"} 

public double toDouble(int I)
  @primitive{"Int.toDouble"}

public str toString(int I)  
  @primitive{"toStringInt"}

%% --- Double (double) ---------------------------------------

public bool ==(double D1, double D2)
  @primitive{"Double.equal"} 

public bool ==(double D, int I){
  return D == toDouble(I);
}

public bool ==(int I, double D){
  return toDouble(I) == D;
}

public bool &lt;(double D1, double D2)
  @primitive{"Double.less"}

public bool &lt;(double D, int I){
  return D &lt; toDouble(I);
}

public bool &lt;(int I, double D){
  return toDouble(I) &lt; D;
}

public double +(double D1, double D2)
  @primitive{"Double.add"}
  
public bool +(double D, int I){
  return D + toDouble(I);
}

public bool +(int I, double D){
  return toDouble(I) + D;
}

public double -(double D1, double D2)
  @primitive{"Double.sub"}
 
public bool -(double D, int I){
  return D - toDouble(I);
}

public bool -(int I, double D){
  return toDouble(I) - D;
}

public double *(double D1, double D2)
  @primitive{"Double.mul"} 

public bool *(double D, int I){
  return D * toDouble(I);
}

public bool *(int I, double D){
  return toDouble(I) * D;
}

public double /(double D1, double D2)
throws divide_by_zero(str msg)
  @primitive{"Double.div"}
  
public bool /(double D, int I){
  return D / toDouble(I);
}

public bool /(int I, double D){
  return toDouble(I) / D;
}

public double arb(double bgn, double end)
throws illegal_argument(str msg) %% if(end - bgn &lt;= 0)
  @primitive{"Double.arb"}

public int toInt(double D)
  @primitive{"Double.toInt"}
 
public str toString(double D)
  @primitive{"Double.toString"}

%% --- Strings (str) -----------------------------------------

public bool ==(str S1, str S2)
  @primitive{"String.equal"}

public bool &lt;(str S1, str S2)
  @primitive{"String.less"}

public str +(str S1, str S2)
  @doc{Concatenate two strings}
  @primitive{"String.concat"}

public int size(str S)
  @primitive{"String.size"}

public int get(str S, int N)
  throws out_of_range(str msg){
  return charAt(S, N);
}

%% get and charAt (as provided by java) are synonyms

public int charAt(str S, int N)
  throws out_of_range(str msg)
  @primitive{"String.charAt"}

public int toInt(str S)
  throws cannot_convert_to_int(str msg)
  @primitive{"String.toInt"}

public int toDouble(str S)
  throws cannot_convert_to_double(str msg)
  @primitive{"String.toDouble"}

public list[int] toList(str S)
  throws cannot_convert_int_to_char(str msg)
  @primitive{"String.toList"}
 
public set[int] toSet(str S)
  @primitive{"String.toSet"}

public str reverse(str S)
  @primitive{"String.reverse"}

public list[str] split(str S, str Regex)
  @primitive{"String.split"}

public bool startsWith(str S, str Prefix)
  @primitive{"String.startsWith"}

public bool endsWith(str S, str Suffix)
  @primitive{"String.endsWith"}

public str toLowerCase(str S)
  @primitive{"String.toLowerCase"}

public str toUpperCase(str S)
  @primitive{"String.toUpperCase"}


%% The above is a selection of methods from Java's String class.
%% Others will be added on demand.

%% --- Locations ---------------------------------------------
   
%% The location datatype
data location location(str filename,
                       int beginline,
                       int endline,
                       int begincol,
                       int endcol,
                       int offset,
                       int length);

anno tree posinfo loc;

public bool ==(loc L1, loc L2)
  @primitive{"Location.equal"} 

public bool &lt;(loc L1, loc L2)
  @primitive{"Location.less"}

public str toString(loc L)
  @primitive{"Location.toString"}

public loc get_location(&amp;T Subject)
  throws location_missing(str msg)
  @primitive{"Location.get_location"}

public &amp;T set_location(&amp;T Subject, loc L)
  @primitive{"Location.set_location"}

%% --- Lists -------------------------------------------------

public bool ==(list[&amp;T] L1, list[&amp;T] L2)
  @primitive{"List.equal"}

public bool &lt;(list[&amp;T] L1, list[&amp;T] L2)
  @primitive{"List.less"}

public list[&amp;T] +(list[&amp;T] L1, list[&amp;T] L2)
  @primitive{"List.concat"}

public list[&amp;T] +(list[&amp;T] L, &amp;T E){
  return L + [E];
}

public list[&amp;T] +(&amp;T E, list[&amp;T] L){
  return [E] + L;
}

public int size(list[&amp;T] L)
  @primitive{"List.size"}
 
public &amp;T get(list[&amp;T] L, int N)
  throws out_of_range(str msg)
  @doc{Get list element: get}
  @primitive{"List.get"}

public &amp;T arb(list[&amp;T] L)
  throws empty_list(str msg)
  @primitive{"List.arb"}

public str toString(list[&amp;T] L)
  @primitive{"List.toString"}


public set[&amp;T] toSet(list[&amp;T] L)
  @primitive{"List.toSet"}

public map[&amp;T, &amp;U] toMap(list[tuple[&amp;T, &amp;U]] L)
  throws domain_not_unique(str msg)
  @primitive{"List.toMap"}
 
public rel[&amp;T] toRel(list[&amp;T] L)
  @primitive{"List.toRel"}

public list[&amp;T] reverse(list[&amp;T] L)
  @primitive{"List.reverse"}

public &amp;T reducer(list[&amp;T] L, &amp;T F (&amp;T,&amp;T), &amp;T unit){
  &amp;T result = unit;
  for(&amp;T E : L){
    result = F(result, E);
  }
  return result;
}

public list[&amp;T] mapper(list[&amp;T] L, &amp;T F (&amp;T,&amp;T)){
  return [F(E) | &amp;T E : L];
}

public &amp;T min(list[&amp;T] L)
@doc{Minimum element of a list: min}
{
  &amp;T result = arb(L);
  for(&amp;T E : L){
   if(less(E, result)){
      result = min(result, E);
   }
  }
  return result;
}

public &amp;T max(list[&amp;T] L)
@doc{Maximum element of a list: max}
{
  &amp;T result = arb(L);
  for(&amp;T E : L){
   if(less(result, E)){
      result = max(result, E);
   }
  }
  return result;
}

public &amp;T sum(list[&amp;T] L, &amp;T zero)
@doc{Add elements of a List: sum}
{
  return reducer(L, +, zero);
}

public &amp;T multiply(set[&amp;T] R, &amp;T unity)
@doc{Multiply elements of a list: multiply}
{
  return reducer(L, *, unity);
}

public &amp;T average(list[&amp;T] L, &amp;T zero)
@doc{Average of elements of a list: average}
{
  return sum(L, zero)/size(L);
}

public &amp;T first(list[&amp;T] L)
  throws empty_list(str msg)
  @doc{First element of list: first}
  @primitive{"List.first"}

public &amp;T rest(list[&amp;T] L)
  throws empty_list(str msg)
  @doc{Remaining elements of list: rest}
  @primitive{"List.rest"}

public str makeString(list[int] L)
  throws cannot_convert_int_to_char(str msg)
  @primitive{"List.makeString"}

public list[&amp;T] sort(list[&amp;T] L, bool less(&amp;T, &amp;T))
  @doc{Sort elements of list: sort}
  @primitive{"list.sort"}
 
%% --- Tuples ------------------------------------------------

public bool ==(tuple[&amp;T] R, tuple[&amp;T] S)
  @primitive{"Tuple.equal"}
 
public bool &lt;(tuple[&amp;T] R, tuple[&amp;T] S)
  @primitive{"Tuple.less"}
 
public tuple[&amp;T + &amp;U] +(tuple[&amp;T] R, tuple[&amp;U] S)
  @primitive{"Tuple.conc"}

public tuple[&amp;T + &amp;U] +(tuple[&amp;T] R, &amp;U E){
  return R + &lt;E&gt;;
}

public tuple[&amp;T + &amp;U] +(&amp;T E, tuple[&amp;U] R){
  return &lt;E&gt; + R;
}

public int size(tuple[&amp;T] R)
  @primitive{"Tuple.size"}

public value get(tuple[&amp;T] R, int N)
  throws out_of_range(str msg)
  @primitive{"Tuple.get"}

public str toString(tuple[&amp;T] R)
  @primitive{"Tuple.toString"}

%% --- Sets  -------------------------------------------------

public bool ==(set[&amp;T] R, set[&amp;T] S)
  @primitive{"Set.equal"}

public bool &lt;(set[&amp;T] R, set[&amp;T] S)
  @primitive{"Set.less"}

public set[&amp;T] |(set[&amp;T] R, set[&amp;T] S)
  @doc{Union of two sets}
  @primitive{"Set.union"}
  
public set[&amp;T] |(set[&amp;T] S, &amp;T E){
  return S + {E};
}

public set[&amp;T] |(&amp;T E, set[&amp;T] S){
  return {E} + S;
}

public set[&amp;T] -(set[&amp;T] R, set[&amp;T] S)
  @doc{Difference of two sets}
  @primitive{"Set.diff"}

public set[&amp;T] -(set[&amp;T] S, &amp;T E){
  return S - {E};
}

public set[&amp;T] -(&amp;T E, set[&amp;T] S){
  return {E} - S;
}

public set[&amp;T] &amp;(set[&amp;T] R, set[&amp;T] S)
  @doc{Intersection of two sets}
  @primitive{"Set.intersection"}

public set[&amp;T] &amp;(set[&amp;T] S, &amp;T E){
  return S &amp; {E};
}

public set[&amp;T] &amp;(&amp;T E, set[&amp;T] S){
  return {E} &amp; S;
}

public int size(set[&amp;T] S)
  @primitive{"Set.size"}

public &amp;T arb(set[&amp;T] S)
throws empty_set(str msg)
  @primitive{"Set.arb"}
  
public str toString(set[&amp;T] S)
  @primitive{"Set.toString"}

public list[&amp;T] toList(set[&amp;T] S)  
  @primitive{"List.toList"}
  
public map[&amp;T, &amp;U] toMap(set[tuple[&amp;T, &amp;U]] S)
  throws non_unique_domain(str msg)
  @primitive{"Set.toMap"}

public rel[&amp;T] toRel(set[&amp;T] S)
   @primitive{"Set.toRel"}

public &amp;T reducer(set[&amp;T] S, &amp;T F (&amp;T,&amp;T), &amp;T unit){
  &amp;T result = unit;
  for(&amp;T E : S){
    result = F(result, E);
  }
  return result;
}

public set[&amp;T] mapper(set[&amp;T] S, &amp;T F (&amp;T,&amp;T)){
  return {F(E) | &amp;T E : S};
}

public &amp;T min(set[&amp;T] S)
  @doc{Minimum of a set}
{
  &amp;T result = arb(S);
  for(&amp;T E : S){
    result = min(result, E);
  }
  return result;
}

public &amp;T max(set[&amp;T] R)
  @doc{Maximum of a set}
{
  &amp;T result = arb(R);
  for(&amp;T E : R){
    result = max(result, E);
  }
  return result;
}

public &amp;T sum(set[&amp;T] S, &amp;T zero)
  @doc{Sum elements of a Set: sum}
{
  return reducer(S, +, zero);
}

public &amp;T multiply(set[&amp;T] S, &amp;T unity)
  @doc{Multiply elements of a Set}
{
  return reducer(S, *, unity);
}

public &amp;T average(set[&amp;T] S, &amp;T zero)
  @doc{Average of elements of a set}
{
  return sum(S, zero)/size(R);
}

%% TODO

%% Powerset: power0
%%public set[set[&amp;T]] power0(set[&amp;T] R)
%% throw unimplemented("power0")

%% Powerset: power1
%%public set[set[&amp;T]] power1(set[&amp;T] R)
%%  throw unimplemented("power0")

%% --- Maps --------------------------------------------------

public bool ==(map[&amp;T, &amp;U] M1, map[&amp;T, &amp;U] M2)
  @primitive{"Map.equal"}
  
public bool &lt;(map[&amp;T, &amp;U] M1, map[&amp;T, &amp;U] M2)
  @primitive{"Map.less"}
  
public map[&amp;T] |(map[&amp;T] R, map[&amp;T] S)
  @primitive{"Map.union"}
  
public map[&amp;T] |(map[&amp;T] S, &amp;T E){
  return S | {E};
}

public map[&amp;T] |(&amp;T E, map[&amp;T] S){
  return {E} | S;
}

public map[&amp;T] -(map[&amp;T] R, map[&amp;T] S)
  @doc{Difference of two maps}
  @primitive{"Map.diff"}
 
public map[&amp;T] -(map[&amp;T] S, &amp;T E){
  return S - {E};
}

public map[&amp;T] -(&amp;T E, map[&amp;T] S){
  return {E} - S;
}

public map[&amp;T] &amp;(map[&amp;T] R, map[&amp;T] S)
  @primitive{"Map.mul"}
  @doc{Intersection of two maps: operator &amp;}

public map[&amp;T] &amp;(map[&amp;T] S, &amp;T E){
  return S &amp; {E};
}

public map[&amp;T] &amp;(&amp;T E, map[&amp;T] S){
  return {E} &amp; S;
}

public int size(map[&amp;T] M)
  @primitive{"Map.size"}

public &amp;T arb(map[&amp;T] M)
throws empty_map(str msg)
  @primitive{"Map.arb"}
  
public str toString(map[&amp;T] R)
  @primitive{"Map.toString"}
  
public list[tuple[&amp;T, &amp;U]] toList(map[&amp;T, &amp;U] M)
  @primitive{"Map.toList"}

public set[tuple[&amp;T, &amp;U]] toSet(map[&amp;T, &amp;U] M)
  @primitive{"Map.toSet"}

public rel[tuple[&amp;T, &amp;U]] toRel(map[&amp;T, &amp;U] M)
  @primitive{"Map.toRel"}

public map[&amp;T] mapper(map[&amp;T] M, &amp;T F (&amp;T,&amp;T)){
  return {F(E) | &amp;T E : M};
}

%% --- Relations ---------------------------------------------

public bool ==(rel[&amp;T] R, rel[&amp;T] S)
  @primitive{"Rel.equal"}
  
public bool &lt;(rel[&amp;T] R, rel[&amp;T] S)
  @primitive{"Rel.less"}
  
public rel[&amp;T] |(rel[&amp;T] R1, rel[&amp;T] R2)
  @doc{Union of two relations}
  @primitive{"Rel.union"}

public rel[&amp;T] |(&amp;T E, rel[&amp;T] R){
  return toRel({E}) | R;
}

public rel[&amp;T] |(rel[&amp;T] R, &amp;T E){
  return R | toRel({E});
}

public rel[&amp;T] -(rel[&amp;T] R1, rel[&amp;T] R2)
  @doc{Difference of two relations}
  @primitive{"Rel.diff"}
  
public rel[&amp;T] &amp;(rel[&amp;T] R1, rel[&amp;T] R1)
  @doc{Intersection of two relations}
  @primitive{"Rel.intersection"}

public int size(rel[&amp;T] R)
  @primitive{"Rel.size"}
  
public &amp;T arb(rel[&amp;T] R)
throws empty_relation(str msg)
  @primitive{"Rel.arb"}

public str toString(rel[&amp;T] R)
  @primitive{"Rel.toString"}

%% Note: in rel[&amp;T], the type variable &amp;T refers 
%% to the tuple type of the relation.

public list[&amp;T] toList(rel[&amp;T] R)
  @primitive{"Rel.toList"}
  
public set[&amp;T] toSet(rel[&amp;T] R)
  @primitive{"Rel.toSet"}

public map[&amp;T] toMap(rel[tuple[&amp;T]] S)
  throws non_unique_domain(str msg)
  @primitive{"Ret.toMap"}

public rel[&amp;T] mapper(rel[&amp;T] R, &amp;T F (&amp;T,&amp;T)){
  return {F(E) | &amp;T E : R};
}

public rel[&amp;T1, &amp;T2] *(set[&amp;T1] R, set[&amp;T2] S)
  @doc{Carthesian product of two sets}
{
  return {&lt;X, Y&gt; | &amp;T1 X : R, &amp;T2 Y : S};
}

public rel[&amp;T1, &amp;T3] compose(rel[&amp;T1, &amp;T2] R,
                                 rel[&amp;T2, &amp;T3] S)
  @doc{Compose two relations}
{
   return {&lt;X, Z&gt; | &lt;&amp;T1 X, &amp;T2 Y1&gt;: R, 
                    &lt;&amp;T2 Y2, &amp;T3 Z&gt;: S, Y1 == Y2};
}

public rel[&amp;T, &amp;T] id(set[&amp;T] S)
  @doc{Identity relation}
{
  return { &lt;X, X&gt; | &amp;T X : S};
}

public rel[&amp;T2, &amp;T1] invert (rel[&amp;T1, &amp;T2] R)
  @doc{Inverse of relation}
{
  return { &lt;Y, X&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R };
}


public rel[&amp;T1, &amp;T2] complement(rel[&amp;T1, &amp;T2] R)
  @doc{Complement of relation}
{
  return (domain(R) * range(R)) - R;
}

public set[&amp;T1] domain (rel[&amp;T1,&amp;T2] R)
  @doc{Domain of relation}
{
  return { X | &lt;&amp;T1 X, &amp;T2 Y&gt; : R };
}

public set[&amp;T1] range (rel[&amp;T1,&amp;T2] R)
  @doc{Range of relation}
{
  return { Y | &lt;&amp;T1 X, &amp;T2 Y&gt; : R };
}

public set[&amp;T]  carrier (rel[&amp;T,&amp;T] R)
  @doc{Carrier of relation}
{
  return domain(R) + range(R);
}

public rel[&amp;T1,&amp;T2] domainR (rel[&amp;T1,&amp;T2] R, set[&amp;T1] S)
  @doc{Domain Restriction of a relation}
{
  return { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, X in S };
}

public rel[&amp;T1,&amp;T2] rangeR (rel[&amp;T1,&amp;T2] R, set[&amp;T2] S)
  @doc{range Restriction of a relation}
{
  return { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, Y in S };
}

public rel[&amp;T,&amp;T] carrierR (rel[&amp;T,&amp;T] R, set[&amp;T] S)
  @doc{Carrier restriction of a relation}
{
  return { &lt;X, Y&gt; | &lt;&amp;T X, &amp;T Y&gt; : R, X in S, Y in S };
}

public rel[&amp;T1,&amp;T2] domainX (rel[&amp;T1,&amp;T2] R, set[&amp;T1] S)
  @doc{Domain exclusion of a relation}
{
  return { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, X notin S };
}

public rel[&amp;T1,&amp;T2] rangeX (rel[&amp;T1,&amp;T2] R, set[&amp;T2] S)
  @doc{Range exclusion of a relation}
{
  return { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, Y notin S };
}

public rel[&amp;T,&amp;T] carrierX (rel[&amp;T,&amp;T] R, set[&amp;T] S)
  @doc{Carrier exclusion of a relation}
{
  return { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, 
                    !(X in S), !(Y in S) };
}

%% Relations viewed as graphs

type rel[&amp;T,&amp;T] graph[&amp;T];

public set[&amp;T] top(graph[&amp;T] G)
  @doc{Top of a Graph}
{
  return domain(G) - range(G);
}

public set[&amp;T] bottom(graph[&amp;T] G)
  @doc{Bottom of a Graph}
{
  return range(G) - domain(G);
}

public set[&amp;T] reachR(set[&amp;T] Start, set[&amp;T] Restr,
                          graph[&amp;T] G)
  @doc{Reachability with restriction}
{
  return range(compose(domainR(G, Start), 
                       carrierR(G, Restr)+));
}

public set[&amp;T] reachX(set[&amp;T] Start, set[&amp;T] Excl, 
                          graph[&amp;T] G)
  @doc{Reachability with exclusion}
{
  return range(compose(domainR(G, Start), 
                       carrierX(G, Excl)+));
}

public list[&amp;T] shortestPathPair(&amp;T From, &amp;T To, graph[&amp;T] G)
  @doc{Shortest path between pair of nodes}
  @primitive{"Graph.shortestPathPair"}

public set[list[&amp;T]] shortestPathFrom(&amp;T From, graph[&amp;T] G)
  @doc{Shortest path between one node and all others}
  @primitive{"Graph.shortestPathFrom"}

public set[list[&amp;T]] shortestPathAll(graph[&amp;T] G)
  @doc{Shortest path between all nodes}
  @primitive{"Graph.shortestPathAll"}

%% TO DO

public rel[&amp;T, &amp;T] closure(rel[&amp;T, &amp;T])
  @primitive{"Rel.closure"}

%% --- Annotations -------------------------------------------

public bool has_annotation(&amp;T Subject, str Name)
  @doc{Test whether a named annotation exists.
       A synonym for the ? operator.}
  @primitive{"Annotation.has_annotation"}

public value get_annotation(&amp;T Subject, str Name)
  throws missing_annotation(str msg)
  @doc{Get the value of a named annotation.
       A synonym for the @ operator.}
  @primitive{"Annotation.get_annotation"}

public map[str,value] get_annotations(&amp;T Subject)
  @doc{Get all annotations}
  @primitive{"Annotation.get_annotations"}
 
public &amp;T set_annotation(&amp;T Subject, 
                             str Name, value AValue)
  @doc{Set the value of a named annotation.
       A synonym for: Var @ Anno = Exp}
  @primitive{"Annotation.set_annotation"}

public &amp;T set_annotations(&amp;T Subject, 
                              map[str, value] Annos)
  @doc{Set all annotations}
  @primitive{"Annotation.set_annotations"}

%% --- Parsing and Unparsing -------------------------------------

public tree parseFile(str filename)
  throws file_does_not_exist(str msg)
  @primitive{"Parse.parseFile"}

public tree parseString(str source)
  @primitive{"Parse.parseString"}
  
public str unparseToString(tree Subject)
  @primitive{"Parse.unparseToString"}
  
public str unparseToFile(tree Subject, str filename)
  throws cannot_create(str msg) 
  throws write_error(str msg) 
  @primitive{"Parse.unparseToFile"}

%% --- trees -------------------------------------------------

public int toInt(tree Subject)
  throws cannot_convert(str msg)
  @primitive{"Tree.toInt"}

public int toDouble(tree Subject)
  throws cannot_convert(str msg)
  @primitive{"Tree.toDouble"}

public int toString(tree Subject)
  throws cannot_convert(str msg)
  @primitive{"Tree.toString"}

public bool elementOf(tree S1, tree S2)
  @primitive{"Tree.elementOf"}


%% --- io ----------------------------------------------------

public str readFile(str filename)
  throws does_not_exist(str msg)            
  throws read_error(str msg)
  @primitive{"IO.read"}


public &amp;T readTerm(str filename) 
  throws does_not_exist(str msg)  
  throws read_error(str msg)
  throws term_error(str msg, loc l)
  @primitive{"IO.readTerm"}


public void write(str filename, &amp;T Subject) 
  throws cannot_create(str msg)  
  throws write_error(str msg)
  @primitive{"IO.write"}

public void print(list[value] V...)
  @primitive{"IO.print"}

public void println(list[value] V...)
  @primitive{"IO.println"}
 
%% --- Interface with the Program Database -------------------
%% The following function provide a bare minimum and will
%% have to compared with the current PDB interface.
%% We assume one active PDB that can be opened and closed.
%% Values can be written to and read from the PDB.

%% Idea: it would be nice to model the PDB as a value
%% of type map[str, value] and to access it that way!

public void openPDB(str name) 
  throws cannot_open(str msg)
  @primitive{"PDB.open"}

public void closePDB()
  throws cannot_close(str msg)
  @primitive{"PDB.close"}

public void writePDB(str name, &amp;T val)
  throws cannot_write(str msg)
  @primitive{"PDB.write"}

public &amp;T readPDB(str name)
  throws cannot_read(str msg)
  @primitive{"PDB.readPDB"}

%% If name is of type set[&amp;T], then the set incr
%% is added to it. Similar for a rel[&amp;T]

public void addSetPDB(str name, set[&amp;T] incr)
  throws does_not_exist(str msg)
  @primitive{"PDB.addSet"}

public void addRelPDB(str name, rel[&amp;T] incr)
  throws does_not_exist(str msg)
  @primitive{"PDB.addRel"}
</programlisting></para>
    </section>
  </section>

  <section>
    <title>Syntax Definition</title>

    <para>See separate SDF definition.</para>
  </section>

  <section>
    <title>Protyping/implementation of Rascal</title>

    <para>Every prototype will have to address the following issues:</para>

    <itemizedlist>
      <listitem>
        <para>Parsing/typechecking/evaluating Rascal.</para>
      </listitem>

      <listitem>
        <para>Ambiguous parse trees.</para>
      </listitem>

      <listitem>
        <para>How to implement the relational operations.</para>
      </listitem>

      <listitem>
        <para>How to implement matching.</para>
      </listitem>

      <listitem>
        <para>How to implement replacement.</para>
      </listitem>

      <listitem>
        <para>How to implement traversals.</para>
      </listitem>
    </itemizedlist>

    <para>The following options should be considered:</para>

    <itemizedlist>
      <listitem>
        <para>Implementation of a typechecker in ASF+SDF:</para>

        <itemizedlist>
          <listitem>
            <para>Gives good insight in the type system and is comparable in
            complexity to the Rscript typechecker.</para>
          </listitem>

          <listitem>
            <para>Work: 2 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            ASF+SDF.</para>
          </listitem>

          <listitem>
            <para>Bound to be very slow.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of a typechecker in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Interesting exercise to asses Rascal.</para>
          </listitem>

          <listitem>
            <para>Not so easy to do without working Rascal
            implementation.</para>
          </listitem>

          <listitem>
            <para>Not so easy when Rascal is still in flux.</para>
          </listitem>

          <listitem>
            <para>Effort: 1 week</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Ditto.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Extending the current ASF+SDF interpreter.</para>

        <itemizedlist>
          <listitem>
            <para>This is a viable options. It requires extensions of
            UPTR.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Translation of Rascal to ASF+SDF in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Unclear whether this has longer term merit.</para>
          </listitem>

          <listitem>
            <para>Allows easy experimentation and reuse of current ASF+SDF
            implementation.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an interpreter in Java.</para>

        <itemizedlist>
          <listitem>
            <para>A future proof and efficient solution.</para>
          </listitem>

          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            Java.</para>
          </listitem>

          <listitem>
            <para>Effort: 8 weeks.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Rascal implementation ideas</title>

    <para>Rascal needs to support both a scripting experience as an optimized
    compiled language experience. Also, it needs to integrate fully with
    Meta-Environment and Eclipse IMP. Therefore, we have both a simple and
    unoptimized interpreter in mind, as well as a compiler that aggressively,
    but correctly, optimizes Rascal programs. The run-time of compiled
    programs and the interpreter will share the implementation of
    data-structures.</para>

    <section>
      <title>Data structures</title>

      <para>Both the compiled code and the interpreter will run on the same
      data-structures which are defined by the IMP PDB project.</para>

      <itemizedlist>
        <listitem>
          <para>We could start with the simple implementation that is now in
          IMP already which is based on the Java library and use the clone
          method to implement immutability. This will prove to be slow, but
          its an easy start.</para>
        </listitem>

        <listitem>
          <para>Integration with the ATerms; extend the ATerm library with all
          the features of the PDB, such that it becomes an implementation of
          the PDB's interfaces.</para>

          <itemizedlist>
            <listitem>
              <para>PDB's terms are typed, while ATerms are not.</para>
            </listitem>

            <listitem>
              <para>ATerms demand canonicalization/sharing, which may prove to
              be hard to implement for maps, sets and relations.</para>
            </listitem>

            <listitem>
              <para>PDB does not yet have any story for serialization.</para>
            </listitem>

            <listitem>
              <para>ATerms will need to "implement" the PDB's interfaces which
              will add a dependency and seriously break other peoples code if
              we are not careful</para>
            </listitem>

            <listitem>
              <para>ATerms need to be typed in order to implement correct
              visiting behavior when AFun's are overloaded.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The C story is harder</para>

          <itemizedlist>
            <listitem>
              <para>Extension of C ATerms is hard due to the nature of C, the
              ATerm garbage collector, the ATerm header implementation and the
              amount of users of the ATerm library</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>It may be a good idea to generate Rascal data-types from SDF
          definitions as an intermediate step, however, Rascal should still
          implement special code for UPTR trees for performance reasons
          (unlike Apigen which does not know anything about UPTR).</para>
        </listitem>

        <listitem>
          <para>The current PDB implementation does type checking at run-time.
          After implementing a type-checker for Rascal, we can easily add an
          implementation which does not do type checking at run-time in order
          to improve performance.</para>
        </listitem>

        <listitem>
          <para>The immutability feature of Rascal data is implemented in the
          data-structures and not by the compiler or the interpeter.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Interpreter</title>

      <para>We just enumerate the thoughts that pop up once in a while:</para>

      <itemizedlist>
        <listitem>
          <para>Write the interpreter in Java, and use it later to bootstrap
          the compiler which will be written in Rascal.</para>
        </listitem>

        <listitem>
          <para>Provide a REPL prompt such that experimenting can be done
          on-the-fly, both on the commandline, and in an Eclipse view.</para>
        </listitem>

        <listitem>
          <para>"fail" can be implemented using a Java exception, the catch
          will be at the choice points (switch).</para>
        </listitem>

        <listitem>
          <para>"return" can also be implemented using a Java exception;
          remember return can jump out of the context of a visitor that could
          be nested deeply in the structure of a term or a tree.</para>
        </listitem>

        <listitem>
          <para>List matching, and especially the kind of backtracking it
          requires will be implemented using exceptions instead of using
          continuations.</para>
        </listitem>

        <listitem>
          <para>Pattern matching needs to be implemented separately for both
          builtin data-types, abstract data types and concrete parse trees.
          Possibly using three "adapters" we can factor out the
          algorithm.</para>
        </listitem>

        <listitem>
          <para>We use apigen to bootstrap the interpreter. The interpreter
          will traverse the apigen object trees to implement it's
          functionality using separate classes.</para>
        </listitem>

        <listitem>
          <para>When the compiler is finished and bootstrapped on the
          interpreter, it may be worthwhile to reimplement/bootstrap the
          interpreter on the compiler again.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Compiler</title>

      <para>The compiler will mainly follow the design of Mark's ASF+SDF
      compiler, which has proven to generate the fastest code in the world for
      these kinds of applications. Furthermore, these ideas have popped
      up:</para>

      <itemizedlist>
        <listitem>
          <para>Bootstrap the compiler using the interpreter.</para>
        </listitem>

        <listitem>
          <para>Generate as readable function names as possible, mainly taking
          hints from the Rascal programs and of course from the SDF
          definitions.</para>
        </listitem>

        <listitem>
          <para>Generate Java code, one class per module.</para>
        </listitem>

        <listitem>
          <para>There is an issue with the globality of rewrite rules, they
          probably need to be collected and merged into a single factory per
          application. Rules apparently break modular compilation, especially
          if you want to optimize matching automatons</para>
        </listitem>

        <listitem>
          <para>For visitors we could first generate a tree node type
          reachability graph, and use it to generate a full traversal for a
          certain visitor. The generated visitor would not recurse into
          subtrees that will not be visited.</para>
        </listitem>

        <listitem>
          <para>After generating the visitors, non-recursive visits (i.e. the
          backbone of the grammar) can be inlined as much as possible to
          prevent using the stack for visiting trees.</para>
        </listitem>

        <listitem>
          <para>Inlining in general should be done very aggressively. This
          will allow other kinds of optimizations, like preventing superfluous
          condition checking. The ASF+SDF compiler does not do this yet, and
          it could mean a serious performance improvement. The cost is
          compilation time obviously, since the Java compiler is going to have
          to compile a lot more code.</para>
        </listitem>

        <listitem>
          <para>The simple control flow constructs of Rascal almost map
          one-to-one to Java</para>
        </listitem>

        <listitem>
          <para>"fail" is always in the current context/frame, so we need no
          exception implementation for fail.</para>
        </listitem>

        <listitem>
          <para>Like in Mark's compiler, list matching is to be implemented
          using nested while loops.</para>
        </listitem>

        <listitem>
          <para>"return" can be mapped to normal return statement in Java,
          except in the context of a visitor, where it should be an exception
          that is caught by the containing function of the visit, which
          immediately returns the result in the catch block that surrounds the
          call to the generated function that implements the visitor.</para>
        </listitem>

        <listitem>
          <para>Important optimizations:</para>

          <itemizedlist>
            <listitem>
              <para>Matching automaton:</para>

              <itemizedlist>
                <listitem>
                  <para>Sharing prefixes (note that we can not reorder cases
                  of a switch, or the rules?!?)</para>
                </listitem>

                <listitem>
                  <para>Common subexpression elimination</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Constant detection and propagation</para>
            </listitem>

            <listitem>
              <para>Aggressive inlining (where to stop?)</para>
            </listitem>

            <listitem>
              <para>Specialization and instantiation of visitors using
              grammars and data-type definitions</para>
            </listitem>

            <listitem>
              <para>Help the garbage collector by assigning 'null' to fields
              that will not be used anymore, or will be killed without being
              used.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Rascal functions with a Java body need the following:</para>

          <itemizedlist>
            <listitem>
              <para>Generate for each argument an Java argument with
              appropirtae Java type.</para>
            </listitem>

            <listitem>
              <para>For each return statement, check the type of the resulting
              value against the return type in the function header.</para>
            </listitem>

            <listitem>
              <para>Catch any exceptions raised by the Java code, convert them
              to string and rethrow as Rascal exception.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.issues">
    <title xml:id="Issues">Issues</title>

    <itemizedlist>
      <listitem>
        <para>Which comment convention will we use? <remark>Let's use Java
        style comments.</remark></para>
      </listitem>

      <listitem>
        <para>In a list comprehension: do list values splice into the list
        result?</para>
      </listitem>

      <listitem>
        <para>Ditto for set comprehensions.</para>
      </listitem>

      <listitem>
        <para>Unexplored idea: add (possibly lazy) generators for all types;
        this allows to generate, for instance, all statements in a
        program.</para>
      </listitem>

      <listitem>
        <para>Shopping list of ideas in Tom:</para>

        <itemizedlist>
          <listitem>
            <para>Named patterns to avoid building a term, i.e. w@[| while
            $Exp do $stat od |].</para>
          </listitem>

          <listitem>
            <para>Anonymous variables a la Prolog: [| while $_ do $stat od
            |].</para>
          </listitem>

          <listitem>
            <para>String matching in patterns.</para>
          </listitem>

          <listitem>
            <para>Tom uses the notation %[ ... ]% for quoted strings with
            embedded @...@ constructs that are evaluated. It also has a
            backquote construct.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Shopping list of ideas from TXL:</para>

        <itemizedlist>
          <listitem>
            <para>"redefine" allows modification of an imported
            grammar.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Expression operators</title>

    <para><table>
        <title>Usage of selected characters in Rascal Syntax</title>

        <tgroup cols="2">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center"> Characters</entry>

              <entry align="center">Used in</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>+</entry>

              <entry>+ (add/conc), +=, + (closure)</entry>
            </row>

            <row>
              <entry>-</entry>

              <entry>- (sub/diff), -=, in names</entry>
            </row>

            <row>
              <entry>*</entry>

              <entry>* (prod), *=, * (closure)</entry>
            </row>

            <row>
              <entry>/</entry>

              <entry>/ (div)</entry>
            </row>

            <row>
              <entry>=</entry>

              <entry>== (equal), != (nequal), =&gt; (case), +=, -=, *=, /=,
              &amp;=, |=, &lt;= (leq), &gt;= (geq)</entry>
            </row>

            <row>
              <entry>&amp;</entry>

              <entry>&amp; (intersection), &amp;&amp; (and), &amp;=, &amp;
              (type var)</entry>
            </row>

            <row>
              <entry>@</entry>

              <entry>@ (get annotation), _ @ _ = _ (modify annotation), @{...}
              (declaration annotation)</entry>
            </row>

            <row>
              <entry>|</entry>

              <entry>| (union), || (or), [| _ |] (quotes), { _ | _ }
              (comprehension), |=</entry>
            </row>

            <row>
              <entry>!</entry>

              <entry>! (not), != (neq), !~ (nomatch)</entry>
            </row>

            <row>
              <entry>&gt;</entry>

              <entry>&gt; (gt), &gt;= (geq), =&gt; (case), &lt; _ &gt;
              (PatternVariable), &lt; _ &gt; (tuple)</entry>
            </row>

            <row>
              <entry>&lt;</entry>

              <entry>&lt; (lt), &lt;= (leq), &lt; _ &gt; (PatternVariable),
              &lt; _ &gt; (tuple), &lt;: (subtype)</entry>
            </row>

            <row>
              <entry>?</entry>

              <entry>? (anno operator), _ ? _ : _ (cond expr)</entry>
            </row>

            <row>
              <entry>:</entry>

              <entry>~~ (match), !~~ (nomatch), case _ : (case), in generator,
              &lt;: (subtype)</entry>
            </row>

            <row>
              <entry>[ and ]</entry>

              <entry>[| _ |] (quote), [ _ ] (projection), [ _ | _ ] (list
              comprehension), [ _ ] (list), type decls</entry>
            </row>

            <row>
              <entry>{ and }</entry>

              <entry>{ _ } (statements), { _ } (set/rel), { _ | _ } (set/rel
              comprehension)</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
  </section>

  <section>
    <title>Visitor definitions (UNDECIDED and INCOMPLETE)</title>

    <para>Visitor definitions are a new idea that borrow the programmability
    of Systems S's single level traversals and add them to Rascal. The idea is
    to be able to define the strategy annotations of visit statements and
    generators using a simple expression language. A definition takes as
    formal argument the code block of the visit statement (s), which is what
    needs to be done at every node (the visitor).</para>

    <para><programlisting>%% first recurse to the arguments, then try v, 
%% which if it fails returns the original structure.
<emphasis role="bold">visitor</emphasis> bottom-up(v) = <emphasis role="bold">all</emphasis>(bottom-up(v)) ; (v <emphasis
          role="bold">&lt;+</emphasis> <emphasis role="bold">id</emphasis>)

<emphasis role="bold">visitor</emphasis> innermost(t,v) = <emphasis
          role="bold">all</emphasis>(innermost(t,v)) ; <emphasis role="bold">repeat</emphasis>(v &lt;+ id) 
    </programlisting>We demand that all visitors are infallible, which means
    that when the v block fails, they must return a default result of the
    correct type. In most cases, this would be the identity (id).</para>

    <para>We can also try to give these definitions a more imperative look, as
    if they are patterns for generating code for the visitors, as in:</para>

    <para><programlisting><emphasis role="bold">visitor</emphasis> bottom-up(v) {
  <emphasis role="bold">all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {             %% try is the '&lt;+' of System S, 
                    %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    <emphasis role="bold">yield</emphasis> t;
  } 
}

%% innermost goes down and only returns after 
%% nothing changes anymore

<emphasis role="bold">visitor</emphasis> innermost(v) {
  <emphasis role="bold">all</emphasis> {
    innermost(v);     %% apply this to all children first.
  }
  <emphasis role="bold">while (true) {</emphasis> {    %% then until kingdom come, apply this block:
    <emphasis role="bold">try</emphasis> {
      v;              %% if v succeeds, it has a yield or a return
                      %% statement that updates the current node. 
    } <emphasis role="bold">catch fail</emphasis>(t) { %% if v fails after all, we obtain a reference
                      %% to the current node visited which we can 
                      %% return;
      <emphasis role="bold">yield</emphasis> t;
    } 
  }
}   

visitor bottom-up-dbg(v) {  <emphasis role="bold">
  all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {              %% try is the '&lt;+' of System S,
                     %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    printf("DBG: bottom-up visitor failed on: " + t);
    <emphasis role="bold">yield</emphasis> t;
  } 
}</programlisting>After such definitions, most of which would be in the
    standard library of Rascal, we can use them to program actual
    visits:</para>

    <para><programlisting>visit bottom-up (t) {
  pattern =&gt; pattern
  pattern2 : { effect; }
}</programlisting></para>
  </section>
</article>