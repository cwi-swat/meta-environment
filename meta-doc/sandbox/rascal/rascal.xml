<?xml version="1.0" encoding="US-ASCII"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Rascal Requirements and Design Document</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Tijs</firstname><surname>van der
        Storm</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is a braindump of ideas. See <xref
    linkend="section.issues" /> for the issues that have to be
    resolved.</para>
  </note>

  <section>
    <title>Introduction</title>

    <para>Rascal is the working name for a new version of ASF+SDF, which will
    be extended with an efficient built-in set and relation data-type. This
    basically means that we include most features of the RScript language into
    ASF+SDF. The goals of this language are:</para>

    <itemizedlist>
      <listitem>
        <para>Separating pure syntax definitions (SDF) from function
        definitions.</para>
      </listitem>

      <listitem>
        <para>Easy syntax-directed analysis of programming languages.</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction.</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning.</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation.</para>
      </listitem>

      <listitem>
        <para>Efficient and scalable implementation.</para>
      </listitem>
    </itemizedlist>

    <para>The above goals are all but one already met in the current design of
    ASF+SDF, and the current design of RScript. What is missing is the
    connection (and to be honest: an efficient implementation of relational
    operators). Alas, any bridge between the two languages is both complex to
    manage and an efficiency bottleneck. This work is an attempt to
    consolidate this engineering trade-off.</para>

    <para>In <xref linkend="section.integration-tscript" /> we will also
    explore the issues when we take integration one step further and also
    include Tscripts in the considerations.</para>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Backward compatible with ASF+SDF. We need to port old
          ASF+SDF definitions to Rascal.</para>
        </listitem>

        <listitem>
          <para>R3: Compilation speed: parsetable generation is a major
          bottleneck in current ASF+SDF. This needs to be fixed.</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability and easy parsing of a
          wide range of source languages.</para>
        </listitem>

        <listitem>
          <para>R5: Functional (no side-effects).</para>
        </listitem>

        <listitem>
          <para>R6: File I/O (contradicts R5).</para>
        </listitem>

        <listitem>
          <para>R7: Easily accessible fact storage (similar to a heap, but
          remember R5 and the details of backtracking).</para>
        </listitem>

        <listitem>
          <para>R8: List matching (because of R2, influences R7).</para>
        </listitem>

        <listitem>
          <para>R9: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as
          scoping).</para>
        </listitem>

        <listitem>
          <para>R10: Syntax trees can be elements of the builtin
          data-structures (but not vice versa).</para>
        </listitem>

        <listitem>
          <para>R11: Features are orthogonal: try to keep the number of ways
          to write down a program minimal</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Mapping features to datatypes</title>

    <para>Emphasized cells indicate a new datatype/feature combination that
    needs to be thought out.</para>

    <table xml:id="table.features">
      <title>Features vs datatypes</title>

      <tgroup cols="9">
        <colspec align="left" colname="col1" colnum="1" colwidth="2*" />

        <colspec align="center" colname="col2" colnum="2" colwidth="1*" />

        <colspec align="center" colname="col3" colnum="3" colwidth="1*" />

        <colspec align="center" colname="col4" colnum="4" colwidth="1*" />

        <colspec align="center" colname="col5" colnum="5" colwidth="1*" />

        <colspec align="center" colname="col6" colnum="6" colwidth="1*" />

        <colspec align="center" colname="col7" colnum="7" colwidth="1*" />

        <colspec align="center" colname="col8" colnum="8" colwidth="1*" />

        <colspec align="center" colname="col9" colnum="9" colwidth="1*" />

        <thead>
          <row>
            <entry>Which features work on which datatypes?</entry>

            <entry>CF syntax trees</entry>

            <entry>CF syntax lists</entry>

            <entry>Lexical syntax trees</entry>

            <entry>Lexical syntax lists</entry>

            <entry>Lists</entry>

            <entry>Sets</entry>

            <entry>Relations</entry>

            <entry>Tuples</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Pattern matching</entry>

            <entry>Y (CS)</entry>

            <entry>Y, CS, LM</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS, LM</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Pattern construction</entry>

            <entry>Y, CS</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS</entry>

            <entry>Y</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Generator/ Comprehension</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>LC</entry>

            <entry>SC</entry>

            <entry>SC</entry>

            <entry>N</entry>
          </row>

          <row>
            <entry>Complete Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Equations</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Polymorphism</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Serialization</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Traversal Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Subtyping</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N, except character class inclusion</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <itemizedlist>
      <listitem>
        <para>BC = Backward Compatible with ASF</para>
      </listitem>

      <listitem>
        <para>CS = Concrete Syntax</para>
      </listitem>

      <listitem>
        <para>HT= head/tail matching</para>
      </listitem>

      <listitem>
        <para>LC = List comprehension</para>
      </listitem>

      <listitem>
        <para>LM = List Matching</para>
      </listitem>

      <listitem>
        <para>N = No</para>
      </listitem>

      <listitem>
        <para>PS = Prefic Syntax</para>
      </listitem>

      <listitem>
        <para>SC = Set Comprehension</para>
      </listitem>

      <listitem>
        <para>Y = Yes</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Questions</title>

    <para><itemizedlist>
        <listitem>
          <para>Q1: What about the overlap between sets of tuples and
          relations? We should build relations in for efficiency. Is there
          going to be a type equivalence. Are tuples going to be first class
          datatypes?</para>
        </listitem>

        <listitem>
          <para>Q2: Do we need to introduce the basic datatypes Integer and
          Boolean because sets and relations have typical builtin functions
          for that? Or can we put these things in a library? How about
          Locations? We need to introduce as few builtin syntax as possible to
          prevent ambiguity and confusion... Can we offer efficient relations
          without introducing a dependency on a fixed Integer/Boolean
          syntax??? It would be SIMPLE if only syntax trees are the leafs of
          nested lists/sets/relations/tuples.</para>
        </listitem>

        <listitem>
          <para>Q3: Concrete syntax will introduce problems with the new fixed
          syntax builtin datatypes (prefix functions, lists, sets, relations,
          tuples). Efficiently make a type-checker that can resolve most of
          the ambiguities.</para>
        </listitem>

        <listitem>
          <para>Q4: We should allow (optionally) quoting/escaping concrete
          syntax parts. If Q3 results in error or undecidable disambiguation,
          the user must be able to clarify precisely.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Rascal at a glance</title>

    <para>Rascal is summarized in the following subsections.</para>

    <para>See <xref linkend="Issues" /> for the issues that still have to be
    resolved.</para>

    <section>
      <title>Modules</title>

      <itemizedlist>
        <listitem>
          <para>"Syntax modules" are identical to standard SDF modules and
          define concrete syntax.</para>
        </listitem>

        <listitem>
          <para>Ordinary modules may import other modules and define types and
          functions.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Types</title>

      <para>The type system (and notation) are mostly similar to that of
      Rscript, but</para>

      <itemizedlist>
        <listitem>
          <para>Symbols (as defined by a syntax module) are also types.</para>
        </listitem>

        <listitem>
          <para>There are built-in types (bool, int str, loc) that have a
          syntactic counterpart (not yet defined how to do this
          exactly).</para>
        </listitem>

        <listitem>
          <para>Relations can have optional column names.</para>
        </listitem>
      </itemizedlist>

      <para>As a design strategy we try to offer the option to leave out as
      many type indications as possible.</para>

      <para>A type declaration may introduce an abbreviation for a comples
      type.</para>
    </section>

    <section>
      <title>Functions</title>

      <para>A function declaration consists of a function name, typed
      arguments, result type and a function body.</para>

      <para>A function body contains a number of variable declarations (with
      optional initializations) followed by an expression. The value of the
      expression is the value of the function.</para>
    </section>

    <section xml:id="section.patterns">
      <title>Patterns</title>

      <para>There is a notation of "pattern": a quoted concrete syntax
      fragment that may contain variables and subexpresions to be evaluated.
      We want to cover the whole spectrum from maximally quoted patterns that
      can unambiguously describe <emphasis role="bold">any</emphasis> syntax
      fragment to minimally quoted patterns as we are used to in ASF+SDF.
      Therefore we support the following mechanisms:</para>

      <itemizedlist>
        <listitem>
          <para>Optionally typed variables, written as
          <literal>&lt;<replaceable>TYPE</replaceable>
          <replaceable>NAME</replaceable>&gt;</literal> or
          <literal>&lt;<replaceable>NAME</replaceable>&gt;</literal>.</para>
        </listitem>

        <listitem>
          <para>Quoted patterns enclosed between <literal>[|</literal> and
          <literal>|]</literal>. Inside a fully quoted string, the characters
          <literal>&lt;</literal>, <literal>&gt;</literal> and
          <literal>|</literal> can be escaped as <literal>\&lt;</literal>,
          <literal>\&gt;</literal>, <literal>\|</literal>. Fully quotred
          patterns may contain variables.</para>
        </listitem>

        <listitem>
          <para>Unquoted patterns are an (unquoted) syntax fragment that may
          contain variables.</para>
        </listitem>
      </itemizedlist>

      <para>Quoted and unquoted patterns form the
      <emphasis>patterns</emphasis> that are supported in Rascal.</para>

      <para>Examples are:</para>

      <itemizedlist>
        <listitem>
          <para>Quoted pattern with typed variables:<programlisting>[| while &lt;EXP Exp&gt; do &lt;${STATEMENT ";"}* Stats&gt; od |]</programlisting></para>
        </listitem>

        <listitem>
          <para>Quoted pattern with untyped variables:<programlisting>[| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
        </listitem>

        <listitem>
          <para>Unquoted pattern with typed variables:<programlisting>while &lt;EXP Exp&gt; do &lt;${STATEMENT ";"}* Stats&gt; od</programlisting></para>
        </listitem>

        <listitem>
          <para>Unquoted pattern with untyped variables:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>
        </listitem>
      </itemizedlist>

      <para>Obviously, with less quoting and type information, the probability
      of ambiguities increases. Our assumption is that a type checker can
      resolve them.</para>

      <para>Implementation hint. For every sort S in the syntax definition add
      the following rules:</para>

      <programlisting><replaceable>S</replaceable>                     -&gt; Pattern
"&lt;<replaceable>" "S</replaceable>"? Variable "&gt;" -&gt; <replaceable>S</replaceable>      </programlisting>
    </section>

    <section>
      <title>Expressions</title>

      <para>Expressions correspond roughly to Rscript expressions with some
      extensions:<itemizedlist>
          <listitem>
            <para>There are lists, sets and relations together with
            comprehensions for these types.</para>
          </listitem>

          <listitem>
            <para>A "switch" expression is similar to a Switch statement in C
            or Java and corresponds to the matching provided by the left-hand
            sides of a set of rewrite rules. However, it provides <emphasis
            role="bold">only</emphasis> matching at the top level of its
            argument and does not traverse its argument.</para>
          </listitem>

          <listitem>
            <para>A "replace" expression corresponds to a traversal function
            (transformer). Given a term and a list of pattern/replacement
            pairs it traverses the term and performs replacements. Note that
            replace does <emphasis role="bold">not</emphasis> provide the
            fixed-point functionality of innermost rewriting (try to rewrite
            as long as there is a change). This behaviour has to be made
            explicit by recursion.</para>
          </listitem>

          <listitem>
            <para>Pattern/replacement pairs may have conditions preceeded by
            the keyword <literal>when</literal>.</para>
          </listitem>

          <listitem>
            <para>Generators in comprehensions may range over syntax
            trees.</para>
          </listitem>

          <listitem>
            <para>Replace and generators may have a strategy option to
            indicate:</para>

            <itemizedlist>
              <listitem>
                <para>all = continue</para>
              </listitem>

              <listitem>
                <para>first = break</para>
              </listitem>

              <listitem>
                <para>td = top-down</para>
              </listitem>

              <listitem>
                <para>bu = bottom-up</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>Here we list experimental examples of Rascal code to try out
    features.</para>

    <section>
      <title>Tree traversal</title>

      <para>Here is the TREE example that we use in explaining traversal
      functions in ASF+SDF.<programlisting>module Tree-syntax
imports basic/Integers

exports 
  sorts TREE
  context-free syntax
    Integer         -&gt; TREE
    f(TREE,TREE)    -&gt; TREE
    g(TREE,TREE)    -&gt; TREE
    h(TREE,TREE)    -&gt; TREE
    i(TREE,TREE)    -&gt; TREE</programlisting><programlisting>module Tree-Examples
imports Tree-syntax

%% Ex1a: Count leaves in a TREE
%% Idea: int N : T generates alle Integer leaves in the tree
%% # is the built-in length-of operator

fun int cnt(TREE T) {
    #{N | int N : T}
}

%% Ex1b: an equivalent,  more purist, version of the same function:
fun int cnt(TREE T) {
    #{N | &lt;Integer N&gt; : T}
}

%% Ex2: Sum all leaves in a TREE
%% NB sum is a built-in that adds all elements in a set or list.
%% Here we see immediately the need to identify
%% - the built-in sort "int"
%% - the syntactic sort "Integer"

fun int sumtree(TREE T) {
    sum({N | int N : T})
}

%% Ex3: Increment all leaves in a TREE
%% Idea: using the construct "replace T { ... }" all leaves in the 
%% tree T that match an integer and replaces each N in T by N+1.
%% The expression as a whole returns the modified term.
%% This is an extremely compact manner of writing a transformer!
%% Note that two conversions are needed here:
%% - from int to NAT to match subterms
%% - from int to NAT to convert the result of addition into 
%%   a NAT tree

fun TREE inc(TREE T) {
    replace T {
      &lt;Integer N&gt; =&gt; &lt;N1&gt;
      when Integer N1 := N + 1
    }
}

%% Ex4: full replacement of g by i
%% The whole repertoire of traversal functions is available:
%% - replace T first bu { ... }
%% - replace T all td { ... }
%% - etc.
%% with:
%% "first" (= break) and "all" (= continue).
%% "bu" (= bottom-up) and "td" (=top-down)
%% A nice touch is that these properties are not tied to the
%% declaration of a travesal function (as in ASF+SDF) but to 
%% its use.

fun TREE frepl(TREE T) {
    replace T all bu{
      g(&lt;TREE T1&gt;, &lt;TREE T2&gt;) =&gt; i(&lt;TREE T1&gt;, &lt;TREE T2&gt;)
    }
}

fun TREE drepl(TREE T) {
    replace T first {
      g(&lt;TREE T1&gt;, &lt;TREE T2&gt;) =&gt; i(&lt;TREE T1&gt;, &lt;TREE T2&gt;)
    }
}

fun TREE drepl(TREE T) {
    replace T first bu {
      g(&lt;TREE T1&gt;, &lt;TREE T2&gt;) =&gt; i(&lt;TREE T1&gt;, &lt;TREE T2&gt;)
    }
}

%% Ex6: shallow replacement of g by i (i.e. only outermost 
%% g's are replaced); 

fun TREE srepl(TREE T) {
    replace T first td {
      g(&lt;TREE T1&gt;, &lt;TREE T2&gt;) =&gt; i(&lt;TREE T1&gt;, &lt;TREE T2&gt;)
    }
}

%% Continuing this line of thought, we can also add these 
%% directives to all generators (where "all td" would be 
%% the default):

fun set[TREE] find_outer_gs(TREE T) {
    { S | first td STATEMENT S : T, 
          g(&lt;TREE T1&gt;, &lt;TREE T2&gt;) := S }
}</programlisting></para>
    </section>

    <section>
      <title>Booleans</title>

      <para>Probably a non-typical example, but let's try it anyway. It looks
      horrible compared to the ASF version but gives an indication how we can
      convert ASF+SDF specifications to Rascal. See <xref
      linkend="section.booleans-with-replace" /> for a much shorter version
      that uses <literal>replace</literal>.</para>

      <programlisting>module Booleans-syntax
exports 
  sorts Bool

  context-free syntax
    "true"        -&gt; Bool
    "false"       -&gt; Bool
    Bool "&amp;" Bool -&gt; Bool {left}
    Bool "|" Bool -&gt; Bool {right}</programlisting>

      <programlisting>module Bool-examples
imports Booleans-syntax

fun Bool and(Bool B1, B2) { %% reduce &amp; operator
    switch B1 {
      true      =&gt; reduce(B2)
      false     =&gt; false
      &lt;Bool B&gt;  =&gt; &lt;B1&gt; &amp; &lt;B2&gt;
    }    
}

fun Bool or(Bool B1, B2) { %% reduce | operator
    switch B1 {
      true      =&gt; true
      false     =&gt; reduce(B2)
      &lt;Bool B&gt;  =&gt; &lt;B1&gt; | &lt;B2&gt;
    }    
}

fun Bool reduce(Bool B){
    switch B {
      &lt;Bool B1&gt; &amp; &lt;Bool B2&gt; =&gt; and(B1, B2)
      &lt;Bool B1&gt; | &lt;Bool B2&gt; =&gt; or(B1, B2)
      &lt;Bool B3&gt;             =&gt; B
    }
}</programlisting>
    </section>

    <section xml:id="section.booleans-with-replace">
      <title>Booleans (version2 using replace)</title>

      <para>The earlier definition of Booleans was quite involved. A much
      simpler solution exists using the replace construct that we have
      encountered in the above examples.<programlisting>module Bool-examples2
imports Booleans-syntax

fun Bool reduce(Bool B) {
    replace B bu {
      true &amp; &lt;Bool B2&gt;   =&gt; reduce(B2)   %% Style 1: Variables and recursion
      false &amp; &lt;Bool B2&gt;  =&gt; false

      true | true   =&gt; true              %% Style 2: truth table
      true | false  =&gt; true
      false | true  =&gt; true
      false | false =&gt; false
    }
}</programlisting></para>

      <para>Observe that there are two styles:</para>

      <itemizedlist>
        <listitem>
          <para>Using variables on the left-hand side: a recursive application
          of reduce is needed to fully normalize the result.</para>
        </listitem>

        <listitem>
          <para>A truth table: this is sufficient as is.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Substitution in Lambda</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.</para>

      <programlisting>module examples/Lambda/Lambda-syntax

exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+               -&gt; Var
context-free syntax
     "prime" "(" Var ")"  -&gt; Var  %% generate unique name
     Var                  -&gt; Exp  %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp  %% function abstraction
     Exp Exp              -&gt; Exp  %% function application
</programlisting>

      <para>Examples:</para>

      <para><programlisting>module Lambda-Examples
imports Lambda-syntax

fun set[Var] allVars(Exp E) {
    {V | Var V : E}
}

fun set[Var] boundVars(Exp E) {
    {V | fn &lt;Var V&gt; =&gt; &lt;Exp E1&gt; : E}
}

fun set[Var] freeVars(Exp E) {
    allVars(E) \ boundVars(E)
}

%% Generate a fresh variable if V does not occur in 
%% given set of variables.

fun Var fresh(Var V, set[Var] S) {
    if V in S then prime(V) else V fi
}

%% Substitution: replace all occurrences of V in E2 by E1

fun Exp subst(Var V1, Exp E1, Exp E2) {

    switch E2 {
      &lt;Var V2&gt; =&gt; V2
         when V1 != V2

      &lt;Var V2&gt; =&gt; E1
         when V1 == V2 

      &lt;Exp Ea&gt; &lt;Exp Eb&gt;  =&gt; &lt;Exp EaS&gt; &lt;Exp EbS&gt;
         when Exp EaS := subst(V, E, Ea),
              Exp EbS := subst(V, E, Eb)

      fn &lt;Var V2&gt; =&gt; &lt;Var Ea&gt; =&gt;  fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;
         when V1 == V2

      fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt; =&gt; fn &lt;Var V2&gt; =&gt; &lt;Exp E1S&gt;
         when V1 != V2,
              not(V1 in freeVars(E2) &amp; V2 in freeVars(E1)),
              Exp E1S := subst(V1, E1, Ea)
 
       fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;  =&gt; fn &lt;Var V3&gt; =&gt; &lt;Exp EaS&gt;
         when V1 != V2,
              V1 in freeVars(Ea) &amp; V2 in freeVars(E1),
              V3 := fresh(V2, freeVars(Ea) union freeVars(E1)),
              Exp EaS := subst(V1, E1, subst(V2, V3, E2))
    }
}</programlisting><note>
          <para>There are a lot of ambiguities in the body of subst!</para>
        </note></para>
    </section>

    <section>
      <title>Renaming in Let</title>

      <para><programlisting>module Let-syntax
exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+                           -&gt; Var
context-free syntax
     Var                              -&gt; Exp
     "let" Var "=" Exp "in" Exp "end" -&gt; Exp </programlisting>Examples:<programlisting>module Let-Example
imports Let

%% Rename all bound variables in an Exp
%% Version 1: purely functional
%% Exp: given expression to be renamed
%% rel[Var,Var]: renaming table
%% Int: counter to generate global variables

fun Exp rename(Exp E, rel[Var,Var] Rn, Int Cnt) {
    switch(E) {
    let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end =&gt;
           let &lt;Var Y &gt;= &lt;Exp E1R&gt;
           in 
              &lt;Exp E2R&gt;
           end 
        when Var Y := "x" + Cnt,  %% this + operator concatenates 
                                  %% (after converting the int to str)
             int Cnt1 := Cnt + 1,
	    Exp E1R := rename(E1, Rn, Cnt),
             Exp E2R := rename(E2, {&lt;V, Y&gt;} union Rn, Cnt1)

    &lt;Var V&gt; =&gt; V1
       when { Var V1 } := Rn[V]

    &lt;Exp E1&gt; =&gt; E1
    }
}</programlisting>Here are some OUTDATED experiments with global
      variables:<programlisting>%% Rename all bound variables in an Exp
%% Version 2: using a global variable
%% to generate new variables

fun Var newVar() {
    global int Cnt := 0   %% Initialize global Cnt on first call 
                          %% of newVar. This is similar to a 
                          %% local static var in C.
    Cnt := Cnt + 1;
    "x" + Cnt
}       

%% Rename -- Version 2

fun Exp rename(Exp E, rel[Var,Var] Rn) {
    Var V, Y;

    switch E {

    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $(rename(E1, Rn)) 
              in 
                $(rename(E2, {&lt;V, Y&gt;} union Rn)) 
              end
           |]
       when Y := newVar()

    [| $V |] =&gt; V1
       when { V1 } == Rn[V]
  
    [| $E |] =&gt; E
    }
}

%% Rename -- Version 3, with Rn also as global variabele

fun Var newVar() {
    global int Cnt := 0   
    Cnt := Cnt + 1;
    "x" + Cnt
}       

fun Exp rename(Exp E) {
    global rel[Var, Var] Rn := {}
    Var V, Y;
 
    switch E {
    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $rename(E1) 
              in 
                 $rename(E2) 
              end
           |]
       when Y := newVar,
            Rn :=  {&lt;V, Y&gt;} union Rn
              
    [| $V |] =&gt; V1
       when { V1 } == Rn[V]
 
    [| $E |] = E
    }
}

%% Question: how to reset the value of global variables?
%% Idea: model them as arguments:
%% - fun Var newVar(global int Cnt := 0) { ... }
%% and allow calls without arguments (as in above example) or
%% with arguments:
%% - newVar(13)
%% which resets the value of Cnt.</programlisting></para>
    </section>

    <section>
      <title>Concise Pico Typechecker</title>

      <para>The following example shows the tight integration ASF with
      comprehensions.<programlisting>module Typecheck

imports Pico-syntax
imports Errors

type Env = rel[PICO-ID,TYPE];

fun list[Error] tcp(PROGRAM P) {
    switch P {
    begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end =&gt;
           [ tcst(S, Env) | Stat S : Series ]     %% list comprehension
       when Env Env := {&lt;Id, Type&gt; | 
                        &lt;PICO-ID Id&gt; : &lt;TYPE Type&gt; : Decls}
    }
}

fun list[Error] tcst(Stat Stat, Env Env) {
    switch Stat {
    &lt;PICO-ID Id&gt; := &lt;EXP Exp&gt; =&gt; type-of(Exp, Type, Env)
       when {&lt;Id, Type&gt;} := Env[Id]

    if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                 else &lt;{STATEMENT ";"}* Stats1&gt; fi =&gt;
           type-of(Exp, natural, Env) + 
           tcs(Stats1, Env) + tcs(Stats2, Env)

    while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od =&gt;
           type-of(Exp, natural, Env) + tcs(Stats, Env)
    }
}

fun list[Error] type-of(Exp E, TYPE Type, Env Env) {
    switch E {
    &lt;NatCon N&gt; =&gt; []
       when Type == natural

    &lt;StrCon S&gt; =&gt; []
       when Type == string

    &lt;PICO-ID Id&gt; =&gt; [] 
       when {&lt;Id,Type2&gt;} := Env[Id],
            Type2 == Type

    &lt;EXP E1&gt; + &lt;EXP E2&gt;  =&gt; type-of(E1, natural, Env) + 
                            type-of(E1, natural, Env)
       when Type == natural

    &lt;EXP E1&gt; + &lt;EXP E2&gt;  =&gt; type-of(E1, natural, Env) + 
                            type-of(E1, natural, Env)
       when Type == natural

    &lt;EXP E1&gt; || &lt;EXP E2&gt; =&gt; type-of(E1, string, Env) + 
                            type-of(E1, string, Env)
       when Type == string
    
    &lt;EXP Exp&gt; =&gt; [error("Incorrect type")]
    }
}</programlisting></para>

      <programlisting>%% Discussion: it may be interesting to generalize switch to allow 
%% multiple arguments:
   switch (E, Type) {
    [| $NatCon |], [| natural |] =&gt; []

    [| $StrCon |], [| string |] =&gt; []

    [| $Id |], Type =&gt; [] 
       when {&lt;Id,Type2&gt;} := Env[Id],
            Type2 == Type
            
    [| $Exp |], Type =&gt; [error("Incorrect type")]
    }
%% Even patterns and expressions could be allowed as cases.</programlisting>
    </section>

    <section>
      <title>Pico control flow extraction</title>

      <programlisting>module Pico-controlflow
imports pico/syntax/Pico

type CP = EXP | STATEMENT;     %% A Code Point, union of two types

type CFSEGMENT = &lt; set[CP] entry, rel[CP,CP] graph, set[CP] exit&gt;;

fun CFSEGMENT cflow({STATEMENT ";"}* Stats){ 
    switch Stats {
      &lt;STATEMENT Stat&gt; ; &lt;{STATEMENT ";"}* Stats2&gt; =&gt;
             &lt;En1, R1 union R2 union (Ex1 x En2), Ex2&gt;
         when &lt;set[CP] En1, rel[CP,CP] R1, set[CP] Ex1&gt; := cflow(Stat),
              &lt;set[CP] En2, rel[CP,CP] R2, set[CP] Ex2&gt; := cflow(Stats2)

      [| |] =&gt; &lt;{}, {}, {}&gt;
    }
}

fun CFSEGMENT cflow(STATEMENT Stat){
    switch Stat {
      while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od =&gt;
             &lt;{Exp}, ({Exp} x En) union R union (Ex x {Exp}),{Exp}&gt;
         when &lt;set[CP] En,  rel[CP,CP] R,  set[CP] Ex&gt; := cflow(Stats)
                
      if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats2&gt; fi =&gt;
             &lt; {Exp}, 
               ({Exp} x En1) union ({Exp} x En2) union R1 union R2,
                Ex1 union Ex2
             &gt;
         when &lt;set[CP] En1, rel[CP,CP] R1, set[CP] Ex1&gt; := cflow(Stats1),
              &lt;set[CP] En2, rel[CP,CP] R2, set[CP] Ex2&gt; := cflow(Stats2)
           
      &lt;STATEMENT Stat&gt;  =&gt; &lt;{Stat}, {}, {Stat}&gt;
    }
}</programlisting>

      <para>Note that most type information in declarations can be omitted,
      yielding a more friendly version, e.g.</para>

      <programlisting>fun CFSEGMENT cflow(STATEMENT Stat){
    switch Stat {
      while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od =&gt;
             &lt;{Exp}, ({Exp} x En) union R union (Ex x {Exp}),{Exp}&gt;
         when &lt;En, R, Ex&gt; := cflow(Stats)
                
      if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats2&gt; fi =&gt;
             &lt; {Exp}, 
               ({Exp} x En1) union ({Exp} x En2) union R1 union R2,
                Ex1 union Ex2
             &gt;
         when &lt;En1, R1, Ex1&gt; := cflow(Stats1),
              &lt;En2, R2, Ex2&gt; := cflow(Stats2)
           
      &lt;STATEMENT Stat&gt;  =&gt; &lt;{Stat}, {}, {Stat}&gt;
    }
}</programlisting>
    </section>

    <section>
      <title>Pico use def extraction</title>

      <programlisting>module Pico-use-def

imports pico/syntax/Pico

fun rel[EXP,PICO-ID] uses(PROGRAM P) {
  {&lt;E,Id&gt; | EXP E : P, PICO-ID Id := E}
}

fun rel[STATEMENT, PICO-ID] defs(PROGRAM P) { 
  {&lt;S, Id&gt; | STATEMENT S : P, 
                        &lt;PICO-ID Id&gt; := &lt;EXP Exp&gt; := S}
}</programlisting>

      <para>The above uses a "matching condition" to decompose
      <literal>S</literal>. The problem solved is that we want to have a name
      for the whole assignment <emphasis>and</emphasis> for the lhs
      identifier.</para>
    </section>

    <section>
      <title>Pico uninitialized variables</title>

      <para><programlisting>module Pico-uninit
imports pico/syntax/Pico 
        Pico-controlflow 
        Pico-use-def

fun set[PICO-ID] uninit(PROGRAM P) {
    rel[EXP,PICO-ID] Uses := uses(P);
    rel[STATEMENT, PICO-ID] Defs := defs(P);
    CFSEGMENT CFLOW := cflow(P);
    set[CP] Root := CFLOW.entry;
    rel[CP,CP] Pred := CFLOW.graph;

    {Id | &lt;EXP E, PICO-ID Id&gt; : Uses,
                 E in reachX(Root, Defs[-,Id], Pred)
    }
}</programlisting>Questions (UPDATE THIS):</para>

      <itemizedlist>
        <listitem>
          <para>There is a subtyping issue here. De type of
          <literal>reachX</literal> is:</para>

          <para><literal>set[&amp;T] reachX(set[&amp;T]
          Start,</literal></para>

          <para><literal> set[&amp;T] Excl, </literal></para>

          <para><literal> rel[&amp;T,&amp;T] Rel)</literal></para>

          <para>but <literal>E</literal> has type <literal>EXP</literal>,
          <literal>{ROOT}</literal> has type
          <literal>set[STATEMENT]</literal>, and <literal>cflow</literal> has
          type <literal>rel[CP,CP]</literal>, with <literal>type CP = EXP |
          STATEMENT</literal>. It requires proper subtyping, e.g.
          set[STATEMENT] &lt; set[CP], to type this.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico common subsexpression elimination</title>

      <para><programlisting>module Pico-common-subexpression

imports pico/syntax/Pico 
        Pico-controlflow 
        Pico-use-def

fun PROGRAM cse(PROGRAM P) {
    rel[STATEMENT, PICO-ID] Defs := defs(P);
    rel[CP,CP] Pred := cflow(P).graph;
    rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | STATEMENT S : P,
                   &lt;PICO-ID Id&gt; := &lt;EXP E&gt; := S,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[-,Id], Pred)
       };
 
    replace P {
      &lt;EXP E &gt; =&gt; Id
         when { Id } := replacements[E]   
    }
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions E2 by Id, such
      that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>Id does not occur in E,</para>
        </listitem>

        <listitem>
          <para>E2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and E2.</para>
        </listitem>
      </itemizedlist>

      <para>Note that a slight abbreviation is possible if we introduce
      labelled patterns (here S):</para>

      <programlisting> rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | &lt;PICO-ID Id&gt; := &lt;EXP E&gt; S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[-,Id], Pred)
       };</programlisting>

      <para>Also note that we could factor out the assignment pattern to make
      cse more generic if we introduce patterns a sfirst class
      citizens:</para>

      <programlisting>fun PROGRAM cse(PROGRAM P, pat STATEMENT Assign(PICO-ID Id, EXP E)) {
 ...
    rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | Assign S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[-,Id], Pred)
       };
 
 ...
}</programlisting>

      <para>Example invocations (Pico style)</para>

      <programlisting>cse(P, &lt;PICO-ID Id&gt; := &lt;EXP E&gt;)</programlisting>

      <para>or (Cobol style):</para>

      <programlisting>cse(P, move &lt;EXP E&gt; to &lt;PICO-ID Id&gt;)</programlisting>

      <para>Note that the order of variables in the pattern and its
      declaration may differ.</para>

      <para>It is to be determined how the instantiation of a pattern looks,
      e.g.</para>

      <programlisting>Assign([|x|], [| y = 1 |])</programlisting>
    </section>

    <section>
      <title>Pico constant propagation</title>

      <para><programlisting>module Pico-constant-propagation

imports pico/syntax/Pico 
        Pico-controlflow 
        Pico-use-def

fun Boolean is-constant(EXP E) {
   switch E {
     &lt;NatCon N&gt; =&gt; true

     &lt;StrCon S&gt; =&gt; true

     &lt;EXP E&gt; =&gt; false
   }
}

fun PROGRAM cp(PROGRAM P) {
    rel[STATEMENT, PICO-ID] Defs := defs(P);
    rel[CP,CP] Pred := cflow(P).graph;

    rel[PICO-ID, EXP] replacements := 
      {&lt;Id2, E&gt; | STATEMENT S : P,
                  &lt;PICO-ID Id&gt; := &lt;EXP E&gt; := S,
                  is-constant(E),
                  PICO-ID Id2 : reachX({S},Defs[-,Id],Pred),
                  Id2 == Id 
      };  
 
    replace P {
     &lt;PICO-ID Id&gt; =&gt; E
        when { EXP E } := replacements[Id]
    }  
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions Id2 by the constant E,
      such that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>E is constant,</para>
        </listitem>

        <listitem>
          <para>Id2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>Id2 is equal to Id,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and Id2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Innerproduct</title>

      <para>[Example taken from TXL documentation]</para>

      <para>Define nnerproduct on vectors of integers, e.g. (1 2 3).(3 2 1)
      =&gt; 10.<programlisting>module examples/Vectors/Vector-syntax

exports
  imports basic/Integers
sorts Vector

context-free syntax
   "(" Integer* ")"    -&gt; Vector
   Vector "." Vector   -&gt; Integer</programlisting></para>

      <programlisting>module Innerproduct

imports Vector-syntax

fun int innerProduct(Vector V1, V2){
    if ( &lt;Integer N1&gt; &lt;Integer* Rest1&gt; ) := V1 &amp; 
       ( &lt;Integer N2&gt; &lt;Integer* Rest2&gt; ) := V2 
    then
       (N1*N2) + innerProduct( (&lt;Rest1&gt;), (&lt;Rest2&gt;) )
    else 
       0
    fi
}</programlisting>
    </section>

    <section>
      <title>Bubble sort</title>

      <para>[Example taken from TXL documentation]</para>

      <programlisting>module Bubble

fun Integer* sort(Integer* Numbers){
    replace Numbers {
      &lt;Integer* Rest1&gt; &lt;Integer N1&gt; &lt;Integer N2&gt; &lt;Integer* Rest2&gt; =&gt;
         sort(&lt;Integer* Rest1&gt; &lt;Integer N2&gt; &lt;Integer N1&gt; &lt;Integer* Rest&gt;)
      when N1 &gt; N2
    }
}</programlisting>

      <para>This example raises a number of issues about the execution of
      replace.</para>

      <para>First, are Rest1 and Rest needed? Would</para>

      <programlisting>    replace Numbers {
      &lt;Integer N1&gt; &lt;Integer N2&gt; =&gt; &lt;Integer N2&gt; &lt;Integer N1&gt;
      when N1 &gt; N2
      &lt;
    }</programlisting>

      <para>be ok?</para>

      <para>Another way to write this is:</para>

      <programlisting>module Bubble

fun Integer* sort(Integer* Numbers){
    sort( replace Numbers {
            &lt;Integer N1&gt; &lt;Integer N2&gt; =&gt; &lt;Integer N2&gt; &lt;Integer N1&gt;
            when N1 &gt; N2
          }
        )
}</programlisting>

      <para>The replace will replace all adjacent pairs that are in the wrong
      order in the current list. The resulting list becomes the argument of a
      new call to sort.</para>
    </section>

    <section>
      <title>Generic Bubble sort</title>

      <para>Here is a generic bubble sort wich uses type parameters
      (&amp;ELEM) and a function parameter.<programlisting>module Bubble

fun &amp;Elem* sort(Elem* Elements, fun bool GreaterThan(&amp;Elem, &amp;Elem)){
    sort( replace Elements {
            &lt;E1&gt; &lt;E2&gt; =&gt; &lt;E2&gt; &lt;E1&gt;
            when GreaterThan(E1, E2)
          }
         )
}</programlisting>Do we want this generality? What are the implications for
      the implementation? The current syntax does not yet allow type variables
      in patterns.</para>
    </section>
  </section>

  <section>
    <title>Outdated examples</title>

    <section>
      <title>Pico Typecheck using dynamically scoped variables
      (OUTDATED)</title>

      <para>The following example details the use of a dynscope global
      variable for building up and using an environment. Notice that we
      introduce <emphasis>void</emphasis> functions as a
      result.<programlisting>module Typecheck

imports Pico-syntax

hiddens

type Env = rel[PICO-ID,TYPE]

exports

fun Bool tc(PROGRAM P) {
    dyn Env Env := {};
    switch P {
      [| begin $Decls $Stats end |] =&gt; tcs(Stats)
         when Env := tcd(Decls)
    }
}

fun Env tcd(Decls Decls) {
    {&lt; Id, Type&gt; | [| $(PICO-ID Id) : $(TYPE Type) |] : Decls}
}

fun Bool tcs(Stats Stats) {
    Stat Stat;
    Stats Stats;
    switch (Stats) {
    [| |]                =&gt; true

    [| $Stat ; $Stats |] =&gt; tcst(Stat) + tcst(Stats)
    }
}

fun Bool tcst(Stat Stat) {
    Id Id;
    Exp Exp;
    Stats Stats, Stats1, Stats2;
    switch (Stat) {
      [| $Id := $Exp |] =&gt; type-of(Exp, Type)
         when {&lt;Id, Type&gt;} := Env[Id]

      [| if $Exp then $Stats1 else $Stats2y fi |] =&gt;
         type-of(Exp, natural) + tcs(Stats1) + tcs(Stats2)

      [| while $Exp do $Stats od |] =&gt;
         type-of(Exp, natural) + tcs(Stats)
    }
}

fun list[Error] type-of(Exp E, TYPE Type) {
    NatCon NatCon;
    StrCon StrCon;
    Id Id;
    Exp Exp;

    switch (E) {
      [| $NatCon |] =&gt; []
         when Type == natural

      [| $StrCon |] =&gt; []
         when Type == string

      [| $Id |] =&gt; [] 
         when {&lt;Id,Type2&gt;} := Env[Id],
              Type2 == Type
            
      [| $Exp |] =&gt; [error("Incorrect type")]
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico eval with dynamically scoped variables (OUTDATED)</title>

      <para>A Pico evaluator using dynamic variables. It still uses functions
      that return VEnvs (this is not consistent and should be changed).</para>

      <programlisting>fun VEnv evalProgram(Program p) {
    dyn VEnv venv;
    Decls decls;
    Series series;

    switch p {
      [| begin $decls $series end |] =&gt; evalStatements(series)
         when venv := evalDecls(decls);
    }
}

fun VEnv evalDecls(Decls decls) {
    Id-Type* idtypes;
    switch decls {
      [| declare $idtypes |] =&gt; evalIdTypes(idtypes)
    }
}

fun VEnv evalIdTypes(Id-Type* idtypes) {
    Id id;
    Id-Type* tail;
    switch idtypes { 
      [| $id : natural, $tail |] =&gt; store(evalIdTypes(tail),id,0)
  
      [| $id : string, $ tail |] =&gt; store(evalIdTypes(tail),id,"")

      [| |] =&gt; []
    }
}

fun VEnv evalStatements(Statement* series) {
    Statement stat; Statement* stats;
    switch series  {
      [| $stat; $stats |] =&gt; venv
         when venv := evalStatement(stat),
              venv := evalStatements(stats)
      [| |] =&gt; venv
    }
}

fun VEnv evalStatement(Statement stat) {
    Exp exp;
    Series series, series1, series2;
    
    switch stat {    
      [| if $exp then $series1 else $series2 fi |] =&gt; 
         evalStatements(series1)
         when evalExp(exp, venv) != 0

      [| if $exp then $series1 else $series2 fi |] =&gt; 
         evalStatements(series2)
         when evalExp(exp, venv) == 0
        
      [| while $exp do $series od |] =&gt; venv
         when evalExp(exp, venv) == 0

      
      [| while $exp do $series od |] =&gt; 
         evalStatement([|while $exp do $series od |])
         when evalExp(exp, venv) != 0,
              venv := evalStatements(series)
    }
}

fun VEnv evalExp(Exp exp) {
    Exp exp1, exp2;
    Natural nat1, nat2;
    StrCon str1, str2, str3;

    switch exp {
      [| $exp1 + $exp2 |] =&gt; nat1 + nat2
         when nat1 := eve(exp1),
              nat2 := eve(exp2)
       
      [| $exp1 - $exp2 |] =&gt; nat1 -/ nat2
         when nat1 := eve(exp1),
              nat2 := eve(exp2)
        
        
      [| $exp1 \|\| $exp2 |] =&gt; str3
         when str1 := eve(exp1),
              str2 := eve(exp2),
              str3 := concat(str1, str2)

      [| $exp1 |] =&gt; nil-value     %% default "equation"
   }
}</programlisting>
    </section>

    <section>
      <title>Generating Graph files in Dot format</title>

      <para>This example illustrates the use of a comprehension on the
      right-hand side of an equation.<programlisting>module Dot-generation

imports Dot-syntax

fun Dot gen-dot(rel[ID, ID] Rel) {
    [| digraph example {
                        $([ node(Tup) | &lt;ID,ID&gt; Tup : Rel ])
                       }
    |]
}

fun DotElem* gen-node(&lt;ID Id1, ID Id2&gt;) {
    [| node $Id1; node $Id2; $Id1 -&gt; $Id2 |}}
}</programlisting></para>
    </section>
  </section>

  <section>
    <title>Syntax Definition</title>

    <para>See separate SDF definition.</para>
  </section>

  <section xml:id="section.integration-tscript">
    <title>Integration with Tscripts (Outdated)</title>

    <note>
      <para>It is not yet clear whether we will also include Tscript in the
      integration effort. For the time being, this section is considered
      outdated.</para>
    </note>

    <section>
      <title>Introduction</title>

      <para>It is possible to speculate on an even further integration of
      formalisms and combining the above amalgan of ASF+SDF and Rscript with
      Tscripts.</para>
    </section>

    <section>
      <title>Requirements</title>

      <itemizedlist>
        <listitem>
          <para>R12: The resulting language uses a single type system. This
          means that relational types (possible including syntactic objects)
          can be used in Tscripts.</para>
        </listitem>

        <listitem>
          <para>R13: The current "expressions" in Tscript (terms that occur at
          the rhs of an assignment) are replaced by calls to ASF+SDF or
          Rscript functions.</para>
        </listitem>

        <listitem>
          <para>R14: There is minimal duplication in functionality between
          ASF+SDF/Rscript/Tscript.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Different styles of Type Declarations</title>

      <para>We have at the moment, unfortunately, a proliferation of
      declaration styles for types.</para>

      <para>Functions are declared in ASF+SDF as:</para>

      <programlisting>typecheck(PROGRAM) -&gt; Boolean</programlisting>

      <para>Observe that only the type of the parameter is given but that it
      does not have a name.</para>

      <para>In Rscript we have:</para>

      <programlisting>int sum(set[int] SI) = ...</programlisting>

      <para>while in Tscript processes are declared as</para>

      <programlisting>process mkWave(N : int) is ...</programlisting>

      <para>For variables a similar story applies. Variables are declared in
      ASF+SDF as:</para>

      <programlisting>"X" [0-9]+    -&gt; INT</programlisting>

      <para>In Rscript we have:</para>

      <programlisting>int X

int X : S   (in comprehensions)</programlisting>

      <para>and in Tscript we have:</para>

      <programlisting>X : int</programlisting>

      <para>In order to unify these styles, we might do the following:</para>

      <itemizedlist>
        <listitem>
          <para>The type of an entity is always written before the entity
          itself.</para>
        </listitem>

        <listitem>
          <para>Formal parameters have a name.</para>
        </listitem>
      </itemizedlist>

      <para>In essence, this amounts to using the declaration style as used in
      Rscript. So we get:</para>

      <programlisting>Boolean typecheck(PROGRAM P) is ...

process mkWave(int N) is ...</programlisting>

      <para>Or do we want things like:</para>

      <programlisting>function typecheck(P : PROGRAM) -&gt; Boolean is ...

var X -&gt; int

process mkWave(int N) is ...</programlisting>

      <para>Advantages are:</para>

      <itemizedlist>
        <listitem>
          <para>The category of the entity is immediately clear (function,
          var, process, tool, ...).</para>
        </listitem>

        <listitem>
          <para>It is readable to further qualify the category, i.e.,
          traversal function, hidden var, restartable tool)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Global Flow of Control</title>

      <para>We have to settle the possible flow of control between the three
      entities ASF+SDF, Rscript and Tscript. Since Tscript imposes the notion
      of an atomic action it would be problematic to have completely
      unrestricted flow of control. Therefore it is logical to use Tscript for
      the top-level control and to limit the use of ASF+SDF and Rscript to
      computations within atomic actions. There is no reason to restrict the
      flow of control between ASF+SDF and Rscript.</para>

      <para>What are the consequences of the above choice? Let's analyze two
      cases:</para>

      <itemizedlist>
        <listitem>
          <para>Parse a file from within an ASF+SDF specification. This (and
          similar built-ins) that use the operating system are removed from
          ASF+SDF. Their effect has to be achieved at the Tscript-level which
          is the natural place for such primitives.</para>
        </listitem>

        <listitem>
          <para>Describe I/O for a defined language. Consider Pico extended
          with a read statement. Here the situation is more complicated. We
          cannot argue that the flow of control in the Pico program (as
          determined by an interpreter written in ASF+SDF) should be moved to
          the Tscript level since Tscript simply does not have the primitives
          to express this. On the other hand, we have to interrupt the flow of
          control of the Pico interpreter when we need to execute a read
          statement. The obvious way to achieve this is</para>

          <itemizedlist>
            <listitem>
              <para>At the Tscript level, a loop repeatedly calls the Pico
              interpreter until it is done.</para>
            </listitem>

            <listitem>
              <para>After each call the Pico interpreter returns with
              either:</para>

              <itemizedlist>
                <listitem>
                  <para>An indication that the eecution is complete (and
                  possibly a final state and/or final value).</para>
                </listitem>

                <listitem>
                  <para>An indication that an external action has to be
                  executed, for instance the read statement. This indication
                  should also contain the intermediate state of the
                  interpreter. When the external action has been executed, the
                  Pico interpreter can be restarted with as arguments the
                  value of the external action and the intermediate
                  state.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Experimentation will have to show whether such a framework is
      acceptable.</para>
    </section>

    <section>
      <title>Modularization</title>

      <para>Rscript and Tscript have no, respectively, very limited mechanisms
      for modularization. ASF+SDF, however, provides a module mechanism with
      imports, hiding, parameters and renaming. This mechanism was originally
      included in ASF, was taken over by SDF and is now reused in ASF+SDF.
      Currently, there are not yet sufficiently large Rscripts to feel the
      need for modules. In Tscript, there is a strong need for restricted name
      spaces and for imposing limitations on name visibility in order to limit
      the possible interactions of a process with its surroundings and to make
      it possible to create nested process definitions. What are the design
      options we have to explore?</para>

      <para>First, we can design a new module system that is more suited for
      our current requirements. The advantage is that we can create an optimal
      solution, the disadvantage is that there are high costs involved
      regarding implementation effort and migrations of existing ASF+SDF
      specifications to the new module scheme.</para>

      <para>Second, we can design an add-on to the ASF+SDF module system that
      addresses our current needs.</para>

      <para>Third, we can try to reuse the current ASF+SDF module
      system.</para>

      <para>As a general note, parameterized modules, polymorphics types and
      renamings are competing features. We should understand what we want. It
      is likely that we do not need all of them.</para>

      <para>Before delving into one of the above alternative approaches, let's
      list our requirements first.</para>

      <itemizedlist>
        <listitem>
          <para>We need grammar modules that allow the following operations:
          import, renaming, deletion (currently not supported but important to
          have a fixed base grammar on many variations on it).
          Parameterization and export/hidden: unclear.</para>
        </listitem>

        <listitem>
          <para>We need function modules (ASF+SDF and Rscript) that provide:
          import, maybe parametrization, and export/hidden.</para>
        </listitem>

        <listitem>
          <para>We need process modules (Tscript) that provide: import,
          export, hiding.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Protyping/implementation of Rascal</title>

    <para>Every prototype will have to address the following issues:</para>

    <itemizedlist>
      <listitem>
        <para>Parsing/typechecking/evaluating Rascal.</para>
      </listitem>

      <listitem>
        <para>How to implement the relational operations.</para>
      </listitem>

      <listitem>
        <para>How to implement matching.</para>
      </listitem>

      <listitem>
        <para>How to implement replacement.</para>
      </listitem>

      <listitem>
        <para>How to implement traversals.</para>
      </listitem>
    </itemizedlist>

    <para>The following options should be considered:</para>

    <itemizedlist>
      <listitem>
        <para>Implementation of a typechecker in ASF+SDF:</para>

        <itemizedlist>
          <listitem>
            <para>Gives good insight in the type system and is comparable in
            complexity to the Rscript typechecker.</para>
          </listitem>

          <listitem>
            <para>Work: 2 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            ASF+SDF.</para>
          </listitem>

          <listitem>
            <para>Bound to be very slow.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of a typechecker in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Interesting exercise to asses Rascal.</para>
          </listitem>

          <listitem>
            <para>Not so easy to do without working Rascal
            implementation.</para>
          </listitem>

          <listitem>
            <para>Not so easy when Rascal is still in flux.</para>
          </listitem>

          <listitem>
            <para>Effort: 1 week</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Ditto.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Extending the current ASF+SDF interpreter.</para>

        <itemizedlist>
          <listitem>
            <para>This is a viable options. It requires extensions of
            AsFix.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Translation of Rascal to ASF+SDF in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Unclear whether this has longer term merit.</para>
          </listitem>

          <listitem>
            <para>Allows easy experimentation and reuse of current ASF+SDF
            implementation.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an interpreter in Java.</para>

        <itemizedlist>
          <listitem>
            <para>A future proof and efficient solution.</para>
          </listitem>

          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            Java.</para>
          </listitem>

          <listitem>
            <para>Effort: 8 weeks.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="section.issues">
    <title xml:id="Issues">Issues</title>

    <itemizedlist>
      <listitem>
        <para>See <xref linkend="section.patterns" /> for a description of
        patterns. There are still some questions about patterns:</para>

        <itemizedlist>
          <listitem>
            <para>Do we want the subexpressions in patterns? [Proposal: no
            since it complicates the syntax]</para>
          </listitem>

          <listitem>
            <para>Do we want string variables in patterns? [Undecided]</para>
          </listitem>

          <listitem>
            <para>Do we want to add regular expression matching primitives to
            patterns? Ex.</para>

            <itemizedlist>
              <listitem>
                <para><programlisting>[| if @any@ $Stats fi |]</programlisting></para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Dynamic variables need more thought; do we really want them?
        [Proposal: let's do without them.]</para>
      </listitem>

      <listitem>
        <para>The relation (no pun intended) between local variable
        declarations in functions, patterns and comprehensions has to be
        established.</para>
      </listitem>

      <listitem>
        <para>We keep the polymorphic types &amp;T1 as in Rscript.</para>
      </listitem>

      <listitem>
        <para>How does list matching fit in? Probably no problem, see above
        examples.</para>
      </listitem>

      <listitem>
        <para>How do we identify built-in sorts (bool, int, etc) with their
        syntactic counterparts?</para>
      </listitem>

      <listitem>
        <para>What happens if no case in a switch matches? Some kind of
        failure? How does it propagate? Runtime error?</para>
      </listitem>

      <listitem>
        <para>In a list comprehension: do list values splice into the list
        result?</para>
      </listitem>

      <listitem>
        <para>Ditto for set comprehensions.</para>
      </listitem>

      <listitem>
        <para>Unexplored idea: add (possibly lazy) generators for all types;
        this allows to generate, for instance, all statements in a
        program.</para>
      </listitem>

      <listitem>
        <para>The "equations" from Rscript are not yet included.</para>
      </listitem>

      <listitem>
        <para>Shopping list of ideas in Tom:</para>

        <itemizedlist>
          <listitem>
            <para>Named patterns to avoid building a term, i.e. w@[| while
            $Exp do $stat od |].</para>
          </listitem>

          <listitem>
            <para>Anti-patterns, i.e. the complement of a patterns: ! [| while
            $Exp do $stat od |] matches anything but a while.</para>
          </listitem>

          <listitem>
            <para>Anonymous variables a la Prolog: [| while $_ do $stat od
            |].</para>
          </listitem>

          <listitem>
            <para>String matching in patterns.</para>
          </listitem>

          <listitem>
            <para>Tom uses the notation %[ ... ]% for quoted strings with
            embedded @...@ constructs that are evaluated. It also has a
            backquote construct.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Shopping list of ideas from TXL:</para>

        <itemizedlist>
          <listitem>
            <para>"redefine" allows modification of an imported
            grammar.</para>
          </listitem>

          <listitem>
            <para>An "any" sort that matches anything.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>
</article>