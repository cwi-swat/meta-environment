<?xml version="1.0" encoding="US-ASCII"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Rascal Requirements and Design Document</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Tijs</firstname><surname>van der
        Storm</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is a braindump of ideas that is slowly converging to a
    coherent design. See <xref linkend="section.issues" /> for the issues that
    have to be resolved.</para>
  </note>

  <section>
    <title>Rationale</title>

    <para>In the domain of software analysis and transformation, there exists
    a phletora of domain-specific languages for defining grammars, rewrite
    rules, software analysis and the like. So why embark on the design of yet
    another DSL in this area? We see the following arguments for this:</para>

    <itemizedlist>
      <listitem>
        <para>Many existing DSLs are based on more or less exotic concepts
        that do excite researchers but are frightening for users without an
        appropriate research background.</para>
      </listitem>

      <listitem>
        <para>The notation used in many DSLs is uninviting to say the
        least.</para>
      </listitem>

      <listitem>
        <para>The scope of DSLs is usually narrow (this is where the word
        "domain-specific" kicks in). The tasks involved in carrying out a code
        analysis or renovation project require several DSLs. Integration
        between these DSLs is insufficient.</para>
      </listitem>

      <listitem>
        <para>As designers of various DSLs (ASF+SDF, Tscript, Rscript, ...) we
        have seen the positive as well as the negative side of DSLs. We
        certainly know howto implement DSLs in this area.</para>
      </listitem>

      <listitem>
        <para>We see an opportunity for a user-friendly, conceptually
        high-level, and rich DSL for all tasks related to software analysis
        and transformation.</para>
      </listitem>
    </itemizedlist>

    <para>With this background and an essential dose of optimism, we embark on
    this trip ... .</para>
  </section>

  <section>
    <title>Introduction</title>

    <para>The goals of the envisaged language (with working name Rascal)
    are:</para>

    <itemizedlist>
      <listitem>
        <para>Providing a successor of ASF+SDF that has of all its benefits
        and fixes all of its shortcomings.</para>
      </listitem>

      <listitem>
        <para>Separating pure syntax definitions (SDF) from function
        definitions.</para>
      </listitem>

      <listitem>
        <para>Easy syntax-directed analysis of programming languages.</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction.</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning.</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation.</para>
      </listitem>

      <listitem>
        <para>Efficient and scalable implementation.</para>
      </listitem>

      <listitem>
        <para>Unsurprising concepts, syntax and semantics for a wide audience.
        Where possible we will stay close to C and Java notation.</para>
      </listitem>
    </itemizedlist>

    <para>Many of the above goals are to a certain extent already met in the
    current design of ASF+SDF, and the current design of RScript. What is
    missing is the connection (and to be honest: an efficient implementation
    of relational operators). Alas, any bridge between the two languages is
    both complex to manage and an efficiency bottleneck. This work is an
    attempt to consolidate this engineering trade-off. This basically means
    that we include most features of the RScript language into ASF+SDF.
    Although we take these languages as conceptual starting point, Rascal is a
    completely new design that has an imperative semantics at it's core rather
    than a functional semantics. As a whole, Rascal is a simpler but more
    expressive language.</para>
  </section>

  <section>
    <title>Rascal for various audiences</title>

    <para>In this section we enumerate numerous facts about Rascal that
    advertise it to different audiences</para>

    <section>
      <title>Generic arguments</title>

      <para>What is good about Rascal in a few words?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is a DSL for source code analysis and transformation.
          It provides a pletora of high level statements and expressions,
          taking away the boilerplate of implementing and debugging tools that
          manipulate programs.</para>
        </listitem>

        <listitem>
          <para>Rascal combines the best features of imperative programming
          with the best features of functional programming and term rewriting.
          <itemizedlist>
              <listitem>
                <para>Simple structured statements for control flow and
                variable assignments for data flow are powerful and simple
                features of the imperative programming paradigm. They allow
                control flow and data flow to be understandable and
                traceable.</para>
              </listitem>

              <listitem>
                <para>From functional programming we borrow that all values
                are immutable and non-null. Issues with aliasing and
                referential integrity, such as frequently occur in imperative
                and OO programming therefore do not exist in Rascal.</para>
              </listitem>

              <listitem>
                <para>The Rascal type system is as powerful as most functional
                languages (higher-order polymorphic functions), however to
                make the language debuggable and understandable it, in
                principle, does not provide type inference.</para>
              </listitem>

              <listitem>
                <para>From term rewriting we inherit powerful pattern matching
                facilities, integration with context-free parsing and concrete
                syntax.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>

        <listitem>
          <para>Rascal supports both a scripting experience, and a compiled
          program experience.</para>
        </listitem>

        <listitem>
          <para>Rascal is type safe, but flexible. It's type system prevents
          common programming errors, but still allows ample opportunity for
          reusable code. The reasons are the we allow co-variance in the
          sub-typing relationship, high-order polymorphic functions and
          parameterized data-types.</para>
        </listitem>

        <listitem>
          <para>Rascal allows different styles of programming. From extremely
          high level specification, down to straight imperative
          programming.</para>
        </listitem>

        <listitem>
          <para>Rascal was inspired by and borrows from several other DSL's
          for program analysis and transformation in academia and industry,
          namely ASF+SDF, Rscript, TXL, TOM, DMS, Stratego, Elan, Maude, Grok,
          Haskell, ML and Setl.</para>
        </listitem>

        <listitem>
          <para>Rascal integrates seemlessly with Eclipse IMP and The
          Meta-Environment.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for ASF+SDF programmers</title>

      <para>Rascal is the successor of ASF+SDF. What's the difference? What's
      the same?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal has roughly all the high level features of ASF+SDF and
          some more. Old ASF+SDF specifications can be transformed to Rascal
          programs using a conversion tool.</para>
        </listitem>

        <listitem>
          <para>Rascal still uses SDF for syntax definition and parser
          generation.</para>
        </listitem>

        <listitem>
          <para>Rascal has a module system that is independent of SDF. Rascal
          modules introduce a namespace scope for variables and functions,
          which can be either private or public. Rewrite rules are global as
          in ASF+SDF. Modules can have type parameters as in SDF, which are
          instantiated by import statements.</para>
        </listitem>

        <listitem>
          <para>In Rascal, patterns and variables in concrete syntax may
          optionally be quoted and escaped, and support explicit declaration
          of the top non-terminal to solve ambiguity.</para>
        </listitem>

        <listitem>
          <para>Rascal rules read in the order of execution instead of first
          the left-hand side, then the conditions, and then the right-hand
          side of ASF+SDF equations</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive and efficient implementations for sets,
          relations and maps</para>
        </listitem>

        <listitem>
          <para>Rascal can be used without SDF, supporting for example regular
          expressions and abstract data types (pure ATerms)</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive support for functions, which have a fixed
          syntax, always return a value and have imperative control flow
          statements. Adding a function will not trigger the need for
          regenerating parse tables. Function types can be polymorphic in
          their parameters and also allow functions as arguments to implement
          reusable algorithms.</para>
        </listitem>

        <listitem>
          <para>The imperative nature of Rascal allows you to factor out
          common code and nest conditionals, unlike in ASF+SDF where
          alternative control flow paths had to be encoded by enumerating
          equations with non-overlapping conditions.</para>
        </listitem>

        <listitem>
          <para>Rascal is an imperative language, which natively supports I/O
          and other side-effects without work-arounds. When backtracking
          occurs, for example over list matching, Rascal makes sure that most
          side-effects are undone, and that I/O is delayed until no more
          backtracking can occur. Even rewrite rules support side-effects in
          Rascal.</para>
        </listitem>

        <listitem>
          <para>Rascal has native support for traversals, instead of the
          add-on it used to be in ASF+SDF. The visit statement is comparable
          to a traversal function, and is as type-safe as the previous, and
          more programmeable.</para>
        </listitem>

        <listitem>
          <para>Instead of accumulator values of traversal functions in
          ASF+SDF, Rascal simply supports lexically scoped variables that can
          be updated using assignments.</para>
        </listitem>

        <listitem>
          <para>Rascal adds specific expressions for relational calculus, all
          borrowed directly from RScript.</para>
        </listitem>

        <listitem>
          <para>When programming using Rascal functions, instead of rules, the
          control flow of a program becomes easily traceable and debuggable.
          It is simply like stepping through well structured code.</para>
        </listitem>

        <listitem>
          <para>Rascal is based on a Java interpreter, or a Java run-time when
          compiled. So the code is more portable.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for imperative and object-oriented programmers</title>

      <para>Rascal is an imperative DSL with high level statements and
      expressions specifically targeted at the domain of analysis and
      transformation of source code:</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is safe: there are no null values, and all values are
          immutable. Source code and abstract syntax trees, and the facts
          extracted from them are immutable. The Rascal interpreter and
          compiler make sure this is implemented efficiently. Without
          mutability it is easy to combine stages of your programs that
          analyse or annotate with stages that transform. Sharing a value does
          not introduce a coupling like in OO, simply because changes are only
          visible to the code that changes the values.</para>
        </listitem>

        <listitem>
          <para>Rascal is extra safe: it has a type system that prevents
          casting exceptions and other run-time failures. Still the type
          system specifically allows many kinds of combinations. For example,
          unlike in Java a set of integers is a subtype of a set of numbers
          (co-variance), which allows you to reuse algorithm for sets of
          numbers on sets of integers. It also provides true polymorphic and
          functions (no erasure), and functions can safely be parameters to
          other functions.</para>
        </listitem>

        <listitem>
          <para>Rascal provides high level statements and expressions
          for:</para>

          <itemizedlist>
            <listitem>
              <para>Visitors in all kinds of orders, expressed very concisely,
              and type safe.</para>
            </listitem>

            <listitem>
              <para>Pattern matching and construction (with concrete
              syntax!)</para>
            </listitem>

            <listitem>
              <para>Equation/constraint solving</para>
            </listitem>

            <listitem>
              <para>Relational calculus</para>
            </listitem>

            <listitem>
              <para>Rewrite rules for normalization/canonicalization of any
              kind of data-structure</para>
            </listitem>

            <listitem>
              <para>Support for parsing using context-free grammars (via
              importing modules from the SDF language).</para>
            </listitem>

            <listitem>
              <para>(de)Serialization of values</para>
            </listitem>

            <listitem>
              <para>Communication with databases</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Rascal provides typed data constructors for common
          mathematical structures, such as:</para>

          <itemizedlist>
            <listitem>
              <para>terms (a.k.a. abstract data types, tree nodes)</para>
            </listitem>

            <listitem>
              <para>parse trees (derivations of context-free grammars, for
              concrete syntax and direct manipulation of source code)</para>
            </listitem>

            <listitem>
              <para>relations</para>
            </listitem>

            <listitem>
              <para>sets</para>
            </listitem>

            <listitem>
              <para>maps</para>
            </listitem>

            <listitem>
              <para>tuples</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>In Rascal you can implement high-fidelity source-to-source
          transformations. Without too much overhead, programs can do
          extensive rewriting of the source code without the loss of
          particular layout standards or source code comments.</para>
        </listitem>

        <listitem>
          <para>Rascal is syntax-safe. When you use Rascal to generate or
          transform source code, it statically detects whether the resulting
          source code is syntactically correct.</para>
        </listitem>

        <listitem>
          <para>Rascal is executed by an interpreter written in Java, or it
          can be compiled to Java classes.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Old ASF+SDF programs are translatable to Rascal.</para>
        </listitem>

        <listitem>
          <para>R3: Edit Rascal and SDF and compile complex programs within a
          few minutes maximally (parsetable generation is a major bottleneck
          in current ASF+SDF. This needs to be fixed.)</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability and easy parsing of a
          wide range of source languages.</para>
        </listitem>

        <listitem>
          <para>R5: (<emphasis role="bold">dropped</emphasis>) Functional (no
          side-effects), dropped due to incompatibility with R7, R6</para>
        </listitem>

        <listitem>
          <para>R6: File I/O (contradicts R5).</para>
        </listitem>

        <listitem>
          <para>R7: Easily accessible fact storage (similar to a heap, but
          remember R5 and the details of backtracking).</para>
        </listitem>

        <listitem>
          <para>R8: List matching (because of R2, influences R7, but also very
          handy for manipulating lists in concrete syntax).</para>
        </listitem>

        <listitem>
          <para>R9: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as scoping),
          allowing to factor out common code.</para>
        </listitem>

        <listitem>
          <para>R10: Syntax trees can be elements of the builtin
          data-structures (but not vice versa).</para>
        </listitem>

        <listitem>
          <para>R11: Try to keep features orthogonal: try to keep the number
          of ways to write down a program minimal, this is not a law since
          other requirements take precedence</para>
        </listitem>

        <listitem>
          <para>R12 (<emphasis role="bold">new</emphasis>): Minimize possible
          syntactic ambiguities; resolve them by type checking.</para>
        </listitem>

        <listitem>
          <para>R13:(<emphasis role="bold">new</emphasis>): Integrates well
          with refactoring infra-structure (i.e. can provide appropriate
          interfaces with pre-condition checking, previews and commits as
          found in interactive refactoring contexts)</para>
        </listitem>

        <listitem>
          <para>R14 (<emphasis role="bold">new</emphasis>): no 'null' values,
          preventing common programming errors</para>
        </listitem>

        <listitem>
          <para>R15 (<emphasis role="bold">new</emphasis>): all values
          immutable, preventing common programming errors and allowing for
          certain kinds of optimizations</para>
        </listitem>

        <listitem>
          <para>R16 (<emphasis role="bold">new</emphasis>): should be able to
          match and construct strings using regular expressions (for making
          the simpler things simple, if you can do without a grammar, why
          not?)</para>
        </listitem>

        <listitem>
          <para>R17 (<emphasis role="bold">new</emphasis>): can get/set data
          from databases, such as the pdb from Eclipse IMP, but possibly also
          from ODBC/JDBC data sources.</para>
        </listitem>

        <listitem>
          <para>R18 (<emphasis role="bold">new</emphasis>): type safe, but
          flexible. We want a type system that prevents common programming
          errors, but still allows ample opportunity for reuse.</para>
        </listitem>

        <listitem>
          <para>R19 (<emphasis role="bold">new</emphasis>): syntax safe,
          programmers should not be allowed to construct programs that are
          syntactically incorrect w.r.t a certain context-free grammar.</para>
        </listitem>

        <listitem>
          <para>R20 (<emphasis role="bold">new</emphasis>): backtracking safe,
          programmers should not have to deal with the mind boggling feature
          interactions between side-effects and backtracking.</para>
        </listitem>

        <listitem>
          <para>R21 (<emphasis role="bold">new</emphasis>):
          traceable/debuggable, programmers should be able to easily trace
          through the execution of a Rascal program using the simplest of
          debugging tools, like printf statements, and the use of a simple
          debugging interface which allows to step through the source code and
          inspect values in a transparent fashion.</para>
        </listitem>

        <listitem>
          <para>R22 (<emphasis role="bold">new</emphasis>): minimize the use
          of type inference, such that the programmer must always declare her
          intentions by providing types for functions, data-types and
          variables. This makes debugging easier and providing clear error
          messages too. When variables are implicitly bound by pattern
          matching or related functionality, exceptions to this requirement
          might be made in favor of conciseness.</para>
        </listitem>

        <listitem>
          <para>R23 (<emphasis role="bold">new</emphasis>): allow the
          implementation of reusable modules and functions (i.e. parametric
          polymorphism and or functions as parameters).</para>
        </listitem>

        <listitem>
          <para>R24 (<emphasis role="bold">new</emphasis>): we need something
          like rewrite rules for implementing data-types that are always
          canonicalized/normalized. For some analysis algorithms this allows
          the programmer to implement domain specific optimizations over plain
          relational calculus or tree visiting that actually needed for
          scalability.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Rascal at a glance</title>

    <para>Rascal consists of the following elements:</para>

    <itemizedlist>
      <listitem>
        <para>Modules to group definitions, proving scopes and visibility
        constructs</para>
      </listitem>

      <listitem>
        <para>A type system and corresponding values, providing parameterized
        types, polymorphic functions and higher-order parameters.</para>
      </listitem>

      <listitem>
        <para>Variables to associate a name with a value in some scope.</para>
      </listitem>

      <listitem>
        <para>Parameterized functions.</para>
      </listitem>

      <listitem>
        <para>Abstract, regular expression and syntax patterns to deconstruct
        (match) values and to construct (make) them.</para>
      </listitem>

      <listitem>
        <para>Expressions provide the elementary computations on
        values.</para>
      </listitem>

      <listitem>
        <para>Statements for providing structured control flow and more
        advanced control flow in computations, such as visitors and fixed
        point computations</para>
      </listitem>
    </itemizedlist>

    <para>These elements are summarized in the following subsections.</para>

    <section>
      <title>Modules</title>

      <para>Modules are the organizational unit of Rascal. They may:</para>

      <itemizedlist>
        <listitem>
          <para>Import another Rascal module using <literal>import</literal>.
          <remark>Do we allow circular imports? Proposal: No.</remark></para>
        </listitem>

        <listitem>
          <para>Extend another Rascal module using <literal>extend</literal>.
          This includes a verbatim copy (similar to
          <literal>#include</literal>) of the-module-to-be-extended in the
          current module. We allow redefinitions of declared names.</para>
        </listitem>

        <listitem>
          <para>Import SDF modules using
          <literal>import-syntax</literal>.</para>
        </listitem>

        <listitem>
          <para>Import Java modules (for the benefit of functions written in
          Java) using <literal>import-java</literal>.</para>
        </listitem>

        <listitem>
          <para>Define datatypes, subtypes, or rules and functions.</para>
        </listitem>

        <listitem>
          <para>Be parameterized with the names of formal types that are
          instantiated with an actual type when the module is imported.</para>
        </listitem>

        <listitem>
          <para>Contain a main function that is the starting point of
          execution:<programlisting>public int main(list[str] argv) { ... }</programlisting></para>
        </listitem>
      </itemizedlist>

      <para>Functions, subtypes and datatypes may be either private to a
      module or public to all modules that import the current module. Rules
      are always public and are globally applied.</para>

      <para>Modules introduce a namespace and qualified names (using the
      <literal>::</literal> operator) may be used to uniquely identify
      elements of a module from the outside. Inside the module, this
      qualification is implicit.<note>
          <para>We should clarify what we want to have:</para>

          <itemizedlist>
            <listitem>
              <para>modules: yes</para>
            </listitem>

            <listitem>
              <para>a nested structure (directory style) of modules:
              yes</para>
            </listitem>

            <listitem>
              <para>packages: no?</para>
            </listitem>
          </itemizedlist>
        </note></para>
    </section>

    <section>
      <title>Names</title>

      <para>Rascal aims at seamless integration with Java and its names adhere
      to the following conventions:</para>

      <itemizedlist>
        <listitem>
          <para>A Rascal Name is identical to a Java Indentifier. All reserved
          words in both Java and Rascal cannot be used as a Name. <remark>For
          better syntax errors it is probably better to warn for Java keywords
          later on.</remark></para>
        </listitem>

        <listitem>
          <para>Sorts and Symbols are inherited from SDF but we extend sort
          (that may only start with an uppercase letter in SDF) to be a more
          liberal Name. <remark>SDF Sorts may include a dash symbol (-)which
          is not allowed in Java Identifiers. Forbidding the dash requires
          changing all existing SDF definitions. Allowing a dash in Names
          requires an added check in the compiler that Identifiers with dashes
          are generated as Java names. Suggestion: add dash and check in
          compiler.</remark></para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Types and Subtypes</title>

      <section>
        <title>Types</title>

        <para>The type system (and notation) are mostly similar to that of
        Rscript, but</para>

        <itemizedlist>
          <listitem>
            <para>We have a type hierarchy that defines a partial order on
            types.</para>
          </listitem>

          <listitem>
            <para>There is a single root for this type hierarchy, it is called
            "<literal>value</literal>".</para>
          </listitem>

          <listitem>
            <para>There are built-in types (<literal>bool</literal>,
            <literal>int</literal>, <literal>double</literal>,
            <literal>number</literal>, <literal>str</literal>,
            <literal>loc</literal>, <literal>void</literal>).</para>
          </listitem>

          <listitem>
            <para>The types <literal>int</literal> and
            <literal>double</literal> are subtypes of
            <literal>number</literal>.</para>
          </listitem>

          <listitem>
            <para>Symbols (as defined by an SDF module) are also types.</para>
          </listitem>

          <listitem>
            <para>All syntactic types are a subtype of the type
            <literal>tree</literal> that corresponds to UPTR. Up casts from a
            subtype to an enclosing type are automatic; Down casts require a
            run-time check/cast. The type <literal>tree</literal> is "special"
            in the following sense:</para>

            <itemizedlist>
              <listitem>
                <para>Parsers generate values of type
                <literal>tree</literal>.</para>
              </listitem>

              <listitem>
                <para>Although the type <literal>tree</literal> can be defined
                in Rascal, its definition is built-in in order to preserve the
                consistency with the parser.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Types for sets, maps, relations and tuples can be formed
            from types; Maps, relations and tuples can have optional column
            names.</para>
          </listitem>

          <listitem>
            <para>Functions can be polymorphic in their parameters as well as
            in their return type.</para>
          </listitem>

          <listitem>
            <para>Function parameters can be function types, maening that the
            name of a properly types function can be passed as a
            parameter.</para>
          </listitem>

          <listitem>
            <para>Arbitrarily nested expressions may contain calls to
            overloaded functions that need to be resolved.</para>
          </listitem>

          <listitem>
            <para>Data declarations may introduce new structured types. <note>
                <para>We assume that all constructors for a datatype lead to a
                corresponding function to construct a term of that datatype.
                This eliminates the need to quote abstract terms in
                statements.</para>
              </note></para>

            <note>
              <para>Constructor names of datatypes may be quoted in order to
              avoid clashes with reserved words or illegal names.</para>
            </note>
          </listitem>

          <listitem>
            <para>Types may include type variables like
            <literal>&amp;<replaceable>T</replaceable></literal> as in Rscript
            with the following refinement:</para>

            <itemizedlist>
              <listitem>
                <para>In the type
                <literal>rel[&amp;<replaceable>T</replaceable>]</literal>, the
                type variable
                <literal>&amp;<replaceable>T</replaceable></literal> is bound
                to the tuple type of the relation, i.e. an actual type
                <literal>rel[int,str]</literal> will bind
                &amp;<replaceable>T</replaceable> to the type
                <literal>tuple[int,str]</literal>.</para>
              </listitem>

              <listitem>
                <para>In a similar fashion, in
                <literal>map[&amp;<replaceable>T</replaceable>]</literal>, the
                type variable
                <literal>&amp;<replaceable>T</replaceable></literal> is bound
                to the tuple type of the map.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>A type declaration introduces a name for a new type that is
            a subtype of a given type, e.g.,<programlisting>type rel[node,node] Graph</programlisting>introduces
            the type <literal>Graph</literal> as a subtype of
            <literal>rel[node,node]</literal>. There are no built-in
            subtypes.</para>
          </listitem>

          <listitem>
            <para>The name that is introduced by a type declaration may even
            be parameterized with one or more type variables,
            e.g.,<programlisting>type rel[&amp;Node, &amp;Node] Graph[&amp;Node]</programlisting></para>

            <para>Of course, the type variables that are used in the type in
            the left part should occur as parameters in the right part of the
            definition.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Subtypes</title>

        <para>The type hierarchy leads to a subtype relation &lt;= that can be
        defined (in ASF+SDF) as follows:<programlisting>%% Subtyping rules (&lt;=) on Types

[let01] int &lt;= number                      = true

[let02] double &lt;= number                   = true

[let03] T &lt;= value                         = true

[let04] T &lt;= T                             = true

[let04] T &lt;= &amp; N                           = true

[let05] T &lt;= &amp;N &lt;= T'                      = T &lt;= T'

[let06] N[&amp;T] &lt;= N[&amp;U]                     = true

[let07] list[T] &lt;= list[T']                = T &lt;= T'

[let08] set[T] &lt;= set[T']                  = T &lt;= T'

[let09] tuple[ONTs] &lt;= tuple[ONTs']        = ONTs &lt;= ONTs'

[let10] map[T1, T2] &lt;= map[T1', T2']       = T1 &lt;= T1' &amp;  T2 &lt;= T2'

[let11] map[T1, T2] &lt;= rel[T1', T2']       = T1 &lt;= T1' &amp;  T2 &lt;= T2'

[let12] rel[ONTs] &lt;= rel[ONTs']            = ONTs &lt;= ONTs'

[let13] rel[ONTs] &lt;= set[tuple[ONTs']]     = ONTs &lt;= ONTs'

[let14] set[tuple[ONTs]] &lt;= rel[ONTs']     = ONTs &lt;= ONTs'

[let15] T &lt;= T' == true,
        ONTs &lt;= ONTs' == true
        =========================================
        fun T N (ONTs) &lt;= fun T' N (ONTs') = true
[default-let]
        T &lt;= T'                            = false
</programlisting></para>

        <para>Here T, T1, T2, T' etc represent types, and ONTs, ONTs' etc
        represented lists of OptionallyNamedTypes, e.g., a type that
        optionally followed by a named. We omit the definition of &lt;= on
        OptionallyNamedTypes. The above rules also describe certain
        equivalences between types, e.g., a map can be compared with a
        relation, a relation can be compared with a set of tuples, and the
        like.</para>

        <para>In addition to these rules, each type definition introduces an
        additional subtype relation, e.g., the previous definition for Graph,
        <programlisting>type rel[node,node] Graph</programlisting></para>

        <para>introduces the following subtype relation:<programlisting>Graph &lt;= rel[node,node]</programlisting></para>

        <para><note>
            <para>Do chain rules (injections) in imported SDF module introduce
            a subtype relation?</para>
          </note><note>
            <para>How do we handle the optional names that occur in types?
            Currently, we throw them away in the subtype relation. Should we
            also compare these names?</para>
          </note><note>
            <para>What is the final word on int, double and number?</para>
          </note></para>
      </section>
    </section>

    <section>
      <title>Annotations</title>

      <para>Annotations may be associated with any value and are represented
      by a mapping of type <literal>map[str,value]</literal>, i.e., annotation
      names are strings and annotation values are arbitrary values of type
      <literal>value</literal>. The standard library provides functions for
      handling annotations.</para>
    </section>

    <section>
      <title>Variables</title>

      <para>Variables are names that have an associated scope and in that
      scope they have a value. A variable declaration consists of a type
      followed by the variable name and---depending on the syntactic
      position---they are followed by an initialization. There are no null
      values, which implies that all variables must be initialized at
      declaration time. Also, this implies that all expressions must return a
      value. Especially for functions, this means that all execution paths of
      a function must have a return statement.</para>

      <para>Variables may be introduced at the following syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para>As formal parameters of a function. Their scope is the
          function and they get their initial value when the function is
          called.</para>
        </listitem>

        <listitem>
          <para>Local variables in a function body are declared and
          initialized. Their scope is the function body.</para>
        </listitem>

        <listitem>
          <para>Variables in patterns. For patterns in match positions,
          variables are initialized during the match and their scope is the
          rule in which they occur. For patterns in make positions, the values
          of variables are taken from the local scope.</para>
        </listitem>

        <listitem>
          <para>For variables introduced by pattern matching in conditional
          statements (if-then, and while), if the condition succeeds, the
          scope of the variables are the block of code that is executed
          conditionally.</para>
        </listitem>

        <listitem>
          <para>Variables in anti-patterns are never visible, but nevertheless
          their names are reserved in the scope that they would have had when
          the pattern was a normal positive matching pattern.</para>
        </listitem>

        <listitem>
          <para>Variables that are introduced by generators in comprehensions
          or for statement, have the comprehension, respectively, for
          statement as scope.</para>
        </listitem>

        <listitem>
          <para>Global variables are declared and ALWAYS initialized at the
          top level of each module and <emphasis role="bold">these
          initialization may not contain function calls.</emphasis> Functions
          that use a global variable have to be explicitly declare it as well.
          The value of a global variable can be used and replaced by all
          functions that have locally declared it.</para>
        </listitem>
      </itemizedlist>

      <para>We will see below that there are certain contexts in which
      assignments to variables are undone in the case of failure.</para>
    </section>

    <section>
      <title>Functions</title>

      <section>
        <title>Overview</title>

        <para>A function declaration consists of a visibility declaration, the
        keyword <literal>fun</literal>, result type, a function name, typed
        arguments and a function body. Functions without a result type have
        type <literal>void</literal>.</para>

        <para>A visibility declaration is one of the keywords
        <literal>public</literal> or <literal>private</literal>
        (default).</para>

        <para>A function body is a list of statements, optionally separated by
        semi-colons. Each unique control flow path through a function must
        have a return statement, such that each function always returns a
        proper value.</para>

        <para>Functions can raise exceptions and these may -- for
        documentation purposes -- optionally be declared as part of the
        function signature (i.e., we have unchecked exceptions in contrast
        with checked exceptions in Java).</para>

        <para>Functions preceeded by the keyword "<literal>java</literal>"
        have a body written in Java. They have the following
        properties:</para>

        <itemizedlist>
          <listitem>
            <para>Arguments and result are pure Rascal values.</para>
          </listitem>

          <listitem>
            <para>Java functions cannot acces the global state of the Rascal
            program. Their only interface is via input parameters and a result
            value. They cannot access Rascal global variables.</para>
          </listitem>

          <listitem>
            <para>Side effects caused by Java functions in the Java state, are
            not undone in the case of backtracking.</para>
          </listitem>
        </itemizedlist>

        <note>
          <para>These Java functions are primarily intended for implementing
          library functions and for interfacing with Eclipse.</para>
        </note>

        <para>Functions preceeded by the keyword "memo" are memo functions
        that cache previous arguments/result combinations.<note>
            <para>Do we need library functions to tune the memo behaviour
            (e.g., flush cache, change cache size)?</para>
          </note></para>
      </section>

      <section>
        <title>Overloading</title>

        <para>Functions may be <emphasis>overloaded</emphasis>, i.e.,
        functions with the same name but with different argument and result
        types can be declared. Overloading is subject to the restriction that
        if several versions of a function are declared with the same name,
        then one or more of the following conditions should hold:</para>

        <itemizedlist>
          <listitem>
            <para>the number of arguments differs;</para>
          </listitem>

          <listitem>
            <para>there is at least one argument position with incomparable
            types w.r.t. the type hierarchy, i.e., not (A &lt;= B) and not
            (B&lt;=A).</para>
          </listitem>

          <listitem>
            <para>the result types of the two functions are
            incomparable.</para>
          </listitem>
        </itemizedlist>

        <para>Here are some examples.<note>
            <para>These examples need more thought!</para>
          </note></para>

        <para><programlisting>%% OK, since int and double are incomparable 
%% (both subtypes of 'number')

fun int +(int a, int b) { ... }
fun double +(double a, double b) { ... }

%% KO, since int is comparable to value 
%% (int is a subtype of number which is a subtype of value)

fun int +(value a, value b) { ... }
fun int +(int a, int b) { ... }

%% OK, but the context must be specific enough to 
%% see the difference

fun int +(number a, number b) { ... }
fun double +(number a, number b) { ... }

fun test() {
  int x = 1 + 2       %% OK, x = 3 because + resolved to int
  int y = 1.5 + 2     %% OK, y = 3 (truncated from 3.5)
                      %% because + resolved to int
  double z = 1.5 + 2  %% OK, z = 3.5, because + resolved to double
  number w = 1 + 3    %% KO, context too unspecific to resolve +.
}

%% OK since for every two definitions selected from this
%% set there is at least one parameter position different;
%% in this example the overloading on result types will never 
%% be used to select the function

fun int    +(int a, int b)
fun int    +(int a, double b)
fun int    +(double a, int b)
fun double +(double a, double b)
fun double +(int a, double b)
fun double +(double a, int b)

%% KO, since str is a subtype of value

fun value randomValue()
fun str   randomValue()

%% OK, but the context must be specific enough:

fun str randomValue()
fun int randomValue()

fun test() {
  str x = randomValue();   %% OK
  int y = randomValue();   %% OK
  value z = randomValue(); %% KO, too unspecific to resolve 
                           %% randomValue.
}</programlisting></para>

        <para>How should overloading be resolved in the presence of type
        parameters? Our approach is simple but effective: a type parameter
        <literal>&amp;<replaceable><replaceable>T</replaceable></replaceable></literal>
        is taken to be of type <literal>value</literal>, unless it is
        explicitly constrained to be smaller than (or smaller than or equal
        to) another type U by writing
        <literal>&amp;<replaceable>T</replaceable> &lt;
        <replaceable>U</replaceable></literal> or
        <literal>&amp;<replaceable>T</replaceable> &lt;=
        <replaceable>U</replaceable></literal>. For the sake of overloading
        resolution, a constrained type parameter will be considered to have
        the type of the constraint, i.e., in <literal>fun
        F(&amp;<replaceable>T</replaceable> &lt; number)</literal> we assume
        the <literal>&amp;<replaceable>T</replaceable></literal> to be of type
        <literal>number</literal>.</para>

        <para>Here are some examples:</para>

        <para><programlisting>%% KO, because &amp;T might be any type (i.e. value),
%% which is comparable to int

fun str f(int x)
fun str f(&amp;T x)

%% KO, since both T's may bind to comparable types and
%% number and int are comparable

fun int f(&amp;T x, number y)
fun int f(&amp;T y, int x)

%% OK, since the second arguments have incomparable types

fun int f(&amp;T x, int y)
fun int f(&amp;T y, double x)

%% OK, because the result types will be incomparable
%% however &amp;T is bound

fun &amp;T &lt;= int    foo()
fun &amp;T &lt;= double foo()

%% KO, since both &amp;T's might be comparable:
fun &amp;T      bar()
fun &amp;T &lt;= A bar()</programlisting></para>

        <para><note>
            <para>What are the use cases of bounded polymorphism?</para>
          </note></para>
      </section>

      <section>
        <title>Formal description of overloading</title>

        <para>Given the subtype relation <literal>&lt;=</literal> defined
        earlier, we can easily formalize overloading resolution by defining
        two predicates: <literal>incomparable</literal> describes when two
        lists of OptionallyNamedTypes can be compared and
        <literal>may-overload</literal> describes when two function types
        satisfy the overloading restrictions:<programlisting>%% Incomparable

[com1] incomparable(ONTs, ONTs') = 
       not((ONTs &lt;= ONTs') | (ONTs' &lt;= ONTs))

%% May-overload

[mo-1] may-overload(fun T N (ONTs), fun T' N' (ONTs')) = 
       not(N == N') | 
       incomparable(ONTs, ONTs') | 
       incomparable(T, T')</programlisting></para>
      </section>

      <section>
        <title>Anonymous Functions</title>

        <para>We also allow <emphasis>anonymous functions</emphasis>, i.e.,
        functions that are declared locally and can be passed as argument to
        another function, be returned as value of a function, or even be
        stored as value in a set or relation. When such functions are called
        they are called in the lexical scope in which they were defined. For
        instance, the Rascal standard Library defines a
        <literal>mapper</literal> function that applies a function to a list
        or set. An anonymous function can be used to define such function
        arguments. Here is a function <literal>addOne</literal>, that adds 1
        to each element of its argument list:<programlisting>fun list[int] addOne(list[int] L)
    return mapper(L, fun int (int N) { return N +1 })</programlisting></para>
      </section>
    </section>

    <section>
      <title>Patterns</title>

      <para>We distinguish three kinds of patterns:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Abstract</emphasis> patterns: prefix dataterms that
          are generated by a signature.</para>
        </listitem>

        <listitem>
          <para><emphasis>Regular expression</emphasis> patterns: conventional
          regular expressions</para>
        </listitem>

        <listitem>
          <para><emphasis>Syntax</emphasis> patterns: textual fragments that
          are generated by a context-free grammar.</para>
        </listitem>

        <listitem>
          <para><emphasis>Lexical</emphasis> patterns: a special case of
          syntax patterns dealing with lexical notions like identifiers,
          numeric constants, and the like.</para>
        </listitem>
      </itemizedlist>

      <para>Patterns may contain variables and can occur in two syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Match</emphasis> positions where the patterns is
          matched against another term and the variables in the pattern are
          bound when the match is successfull. Examples of match positions
          are:</para>

          <itemizedlist>
            <listitem>
              <para>In a case construct, immediately after the
              <literal>case</literal>, <literal>acase</literal> or
              <literal>rcase</literal> keyword.</para>
            </listitem>

            <listitem>
              <para>The left-hand side of a <literal>rules</literal> or
              <literal>arules</literal> statement.</para>
            </listitem>

            <listitem>
              <para>In a generator, where generated values are matched against
              the pattern.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis>Make</emphasis> positions where the pattern is used
          to construct a new term (after replacing any variables in the
          pattern by their values. Examples of make positions are:</para>

          <itemizedlist>
            <listitem>
              <para>In a case construct, immediately after the
              <literal>=&gt;</literal> operator.</para>
            </listitem>

            <listitem>
              <para>The right-hand side of a <literal>rules</literal> or
              <literal>arules</literal> statement.</para>
            </listitem>

            <listitem>
              <para>As an ordinary expression in the form of a quoted syntax
              pattern, or a call to a constructor for a dataterm.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <section>
        <title>Abstract Patterns</title>

        <para>Datatype declarations introduce a signature of abstract
        terms.These terms (possibly including typed variables as introduced
        for concrete patterns) may be used as abstract patterns at the same
        position where concrete patterns are allowed. Type declarations define
        an inclusion relation between types.</para>
      </section>

      <section>
        <title>Regular Expression Patterns</title>

        <para>Regular expression patterns are ordinary regular expressions
        that are used to match a string value and to decompose it in parts and
        also to compose new strings. In a match position, a regular expression
        may be preceeded by a newly declared variable (always of type
        <literal>list[str]</literal>) and the symbol <literal>~=</literal>.
        When the variable is present it will contain the matches obtained by
        the regular expression.</para>
      </section>

      <section xml:id="section.patterns">
        <title>Syntax Patterns</title>

        <para>There is a notation of a <emphasis>syntax pattern</emphasis>: a
        (possibly quoted) concrete syntax fragment that may contain variables.
        We want to cover the whole spectrum from maximally quoted patterns
        that can unambiguously describe <emphasis role="bold">any</emphasis>
        syntax fragment to minimally quoted patterns as we are used to in
        ASF+SDF. Therefore we support the following mechanisms:</para>

        <itemizedlist>
          <listitem>
            <para>Optionally typed variables, written as
            <literal>&lt;<replaceable>TYPE</replaceable>
            <replaceable>NAME</replaceable>&gt;</literal> or
            <literal>&lt;<replaceable>NAME</replaceable>&gt;</literal>.</para>
          </listitem>

          <listitem>
            <para>Quoted patterns enclosed between <literal>[|</literal> and
            <literal>|]</literal>. Inside a fully quoted string, the
            characters <literal>&lt;</literal>, <literal>&gt;</literal> and
            <literal>|</literal> can be escaped as <literal>\&lt;</literal>,
            <literal>\&gt;</literal>, <literal>\|</literal>. Fully quoted
            patterns may contain variables.</para>
          </listitem>

          <listitem>
            <para>Unquoted patterns are an (unquoted) syntax fragment that may
            contain variables.</para>
          </listitem>
        </itemizedlist>

        <para>Quoted and unquoted patterns form the syntax patterns that are
        supported in Rascal.</para>

        <para>Examples are:</para>

        <itemizedlist>
          <listitem>
            <para>Quoted syntax pattern with typed variables:<programlisting>[| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Quoted syntax pattern with untyped
            variables:<programlisting>[| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with typed
            variables:<programlisting>while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with untyped
            variables:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>
          </listitem>
        </itemizedlist>

        <para>Obviously, with less quoting and type information, the
        probability of ambiguities increases. Our assumption is that a type
        checker can resolve them.</para>

        <note>
          <para>Implementation hint (used to check the examples in this
          document). For every sort S in the syntax definition add the
          following rules:</para>

          <programlisting><replaceable>S</replaceable>                   -&gt; Pattern
"&lt;<replaceable>" "S</replaceable>"? Name "&gt;"   -&gt; <replaceable>S</replaceable>      </programlisting>
        </note>
      </section>

      <section>
        <title>Lexical Patterns</title>

        <para>A special case of syntax patterns, are lexical patterns that
        describe lexical notions such as identifiers, numeric constants and
        the like. Lexical patterns can appear as part of a concrete syntax
        pattern. Our solution is a middle road between the original solution
        used in ASF+SDF (simple but not type safe) and the current solution in
        ASF+SDF (complex but type safe). The key idea is that a constructor
        function is implicitly created for every lexical definition, i.e.,
        when the SDF definition defines the lexical sort
        <literal>LS</literal>, then the following lexical constructor function
        <literal>ls</literal> (the sort name in lower case) is implicitly
        defined:<programlisting>    ls( LEXARGS ) -&gt; LS</programlisting></para>

        <para><literal>LEXARGS</literal> consist of zero or more:</para>

        <itemizedlist>
          <listitem>
            <para>String constants.</para>
          </listitem>

          <listitem>
            <para>Typed Variables enclosed in angle brackets (as used in other
            patterns).</para>
          </listitem>
        </itemizedlist>

        <para>The <literal>LEXARGS</literal> argument combined should form a
        strings of sort <literal>LS</literal>.<note>
            <para>The current solution in ASF+SDF requires that all
            intermediate lexical constructors are explicitly written in the
            pattern. Here we relax this requirement.</para>
          </note></para>

        <para>For instance, given a lexical syntax for numbers (part of an SDF
        definition):<programlisting>sorts DIGIT NAT-CON
lexical syntax
   [0-9]    -&gt; DIGIT
   DIGIT+   -&gt; NAT-CON</programlisting></para>

        <para>A rule that would remove leading zeros looks like
        this:<programlisting>  natcon("0" &lt;DIGIT+ Ds&gt;) =&gt; natcon(&lt;Ds&gt;)</programlisting><note>
            <para>Unlike the ASF+SDF solution, it is not necessary to make a
            distinction between ordinary variables, lexical variables, and
            layout variables. Here, all variables are treated equal and their
            syntactic position determines how they are used.</para>
          </note></para>
      </section>
    </section>

    <section>
      <title>Expressions</title>

      <para>Expressions correspond roughly to Rscript expressions with some
      extensions:<itemizedlist>
          <listitem>
            <para>There are lists, sets and relations together with
            comprehensions for these types.</para>
          </listitem>

          <listitem>
            <para>Generators in comprehensions may range over syntax
            trees.</para>
          </listitem>

          <listitem>
            <para>Generators may have a strategy option to indicate:</para>

            <itemizedlist>
              <listitem>
                <para><literal>top-down</literal></para>
              </listitem>

              <listitem>
                <para><literal>top-down-break</literal></para>
              </listitem>

              <listitem>
                <para><literal>bottom-up</literal> (this is the
                default)</para>
              </listitem>

              <listitem>
                <para><literal>bottom-up-break</literal></para>
              </listitem>
            </itemizedlist>

            <para>The two other strategy option (<literal>innermost</literal>
            and <literal>outermost</literal>) are only meaningfull in the
            context of a <literal>visit</literal> statement.</para>
          </listitem>

          <listitem>
            <para>The complete repertoire of operators in Rscript is available
            but we have applied some rationalization. Note that with each
            operator, we also associate a named function that can be used as
            function argument.</para>

            <itemizedlist>
              <listitem>
                <para><literal>+</literal> (function: <literal>add</literal>)
                is now used for addition, union and concatenation (the
                operator <literal>union</literal> is gone).</para>
              </listitem>

              <listitem>
                <para><literal>-</literal> (function: <literal>sub</literal>)
                is now used for substraction, difference (the operator
                <literal>\</literal> is gone)</para>
              </listitem>

              <listitem>
                <para><literal>*</literal> (function: <literal>mul</literal>)
                is now used for multiplication and intersection (the operator
                <literal>inter</literal> is gone).</para>
              </listitem>

              <listitem>
                <para><literal>/</literal> (function: <literal>div</literal>)
                is used for integer and double division.</para>
              </listitem>

              <listitem>
                <para>There are new assignment operators +=, -=, *=.</para>
              </listitem>

              <listitem>
                <para>The relational operators <literal>==</literal>
                (function: <literal>equal</literal>) and
                <literal>&lt;</literal> (function: <literal>less</literal>)
                are available for values of all types. They are used to define
                <literal>&lt;=</literal> (function:
                <literal>less_equal</literal>), <literal>&gt;</literal>
                (function: <literal>greater</literal>) and
                <literal>&gt;=</literal> (function:
                <literal>greater_equal</literal>) as well as the functions
                <literal>min</literal> and <literal>max</literal>.</para>
              </listitem>

              <listitem>
                <para>For a binary relation <replaceable>R</replaceable> that
                is a map (i.e. it associates a single value with each domain
                element)
                <replaceable>R</replaceable>(<replaceable>N</replaceable>),
                returns the single image value corresponding with
                <replaceable>N</replaceable>. This expression may also occur
                as left-hand side of an assignment:<programlisting><replaceable>R</replaceable>(<replaceable>N</replaceable>) = <replaceable>V</replaceable></programlisting>first
                removes from <replaceable>R</replaceable> the tuple with
                domain value <replaceable>N</replaceable> and then adds the
                tuple &lt;<replaceable>N</replaceable>,
                <replaceable>V</replaceable>&gt;. The net effect is that a new
                map value is assigned to <replaceable>R</replaceable>.</para>
              </listitem>

              <listitem>
                <para>An index operator
                <literal><replaceable>R</replaceable>[<replaceable>N</replaceable>]</literal>
                can be applied to values of types list, set, tuple, rel,
                string and returns the <replaceable>N</replaceable>-th
                element.</para>
              </listitem>

              <listitem>
                <para>The Rscript image notation R[n] and R[-,n] is
                discontinued.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist></para>

      <note>
        <para>Do we need a cast operator to down cast values?</para>
      </note>
    </section>

    <section>
      <title>Statements</title>

      <para>Rascal has the following statement types, which can be nested and
      composed in the usual structured manner:</para>

      <itemizedlist>
        <listitem>
          <para>Variable declaration with initialization.</para>
        </listitem>

        <listitem>
          <para>An assignment statement assigns a value to a variable.</para>
        </listitem>

        <listitem>
          <para>If-then statement and if-then-else statement.</para>
        </listitem>

        <listitem>
          <para>A <literal>return</literal> statement returns a value from a
          function, or just returns (for functions with result type void).
          Note that return jumps out of an entire function, even if it is
          nested in a complicated control flow statement such as visit.</para>
        </listitem>

        <listitem>
          <para>A <literal>yield</literal> statement that delivers a
          replacement value during a traversal initiated by a visit statement,
          or a switch statement.</para>
        </listitem>

        <listitem>
          <para>A <literal>fail</literal> statement which jumps to the deepest
          nested choice point (i.e. a switch or a visit) and tries the next
          option available. Fail is the dual of return/yield.</para>
        </listitem>

        <listitem>
          <para>A throw statement can raise an exception.</para>
        </listitem>

        <listitem>
          <para>A <literal>switch</literal> statement is similar to a switch
          statement in C or Java and for a given subject term, it corresponds
          to the matching provided by the left-hand sides of a set of rewrite
          rules. However, it provides <emphasis role="bold">only</emphasis>
          matching at the top level of the subject term and does not traverse
          it. The type of each pattern must be identical to the type of the
          subject term (or be a subtype of it). It is an error if no case
          matches.</para>
        </listitem>

        <listitem>
          <para>A rewrite rule (not a top-level statement, but a child of
          switch and visit) consists of a Pattern followed by : and a
          statement that returns the replacement value:<programlisting>case <replaceable>Pattern</replaceable> : <replaceable>Statement</replaceable></programlisting></para>

          <para>A statement may consist of declarations and statements and is
          implicitly extended with a <literal>fail</literal> statement. The
          statement must therefore yield or return a value or the case as a
          whole will fail. To maintain some resemblance with rewrite rules, we
          also support the form</para>

          <programlisting>case <replaceable>Pattern</replaceable> =&gt; <replaceable>Replacement</replaceable></programlisting>

          <para>which is an abbreviation for<programlisting>case <replaceable>Pattern</replaceable> : yield <replaceable>Replacement</replaceable></programlisting>Depending
          on the kind of pattern we use a different keyword:</para>

          <itemizedlist>
            <listitem>
              <para><literal>case</literal> for (concrete) syntax
              patterns.</para>
            </listitem>

            <listitem>
              <para><literal>acase</literal> for abstract patterns.</para>
            </listitem>

            <listitem>
              <para><literal>rcase</literal> for regular patterns.<note>
                  <para>These three different keywords are not very elegant
                  but they help to remove disambiguities.</para>
                </note></para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>A <literal>visit</literal> statement corresponds to a
          traversal function from ASF+SDF. Given a subject term and a list of
          rewrite rules it traverses the term. Depending on the precise rules
          it may perform replacement (mimicking a transformer), update local
          variables (mimicking an accumulator) or a combination of these two.
          The visit statement may contain the same strategy options as a
          generator and also:</para>

          <itemizedlist>
            <listitem>
              <para><literal>innermost</literal> = compute a fixed-point:
              repeat a bottom-up traversal as long as the traversal function
              changes values.</para>
            </listitem>

            <listitem>
              <para><literal>outermost</literal> = compute a fixed-point:
              repeat a traversal traversal as long as the traversal function
              changes values.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>A <literal>for</literal> statement to repeat a block of
          code.</para>
        </listitem>

        <listitem>
          <para>A <literal>solve</literal> statement to solve a set of linear
          equations.</para>
        </listitem>

        <listitem>
          <para>A <literal>try</literal> statement can be used to execute a
          statement and to catch any exception raised by that
          statement.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Failure and side-effects</title>

      <para>There are two contexts in which side-effects, i.e., assignment to
      variables, have to be undone in case of failure. These contexts are a
      rewrite rule in a switch or visit statement. If the pattern on the
      left-handside of the rule matches there are various
      possibilities:</para>

      <itemizedlist>
        <listitem>
          <para>All control flow path through the right-hand side of the rule
          end in a return statement. In this case, the rule can not fail and
          all side-effects caused by the execution of the right-hand side are
          committed.</para>
        </listitem>

        <listitem>
          <para>One or more control path can fail. This can be caused by an
          explicit fail statement or an if-then statement with missing
          else-branch. In the case of failure all side-effects are
          undone.<note>
              <para>Will we undo all side-effects or only the side-effects on
              global variables?</para>
            </note></para>
        </listitem>

        <listitem>
          <para>If a rule fails there are two possibilities:</para>

          <itemizedlist>
            <listitem>
              <para>the left-hand side contains a list pattern that has more
              matching options; the next option is tried.</para>
            </listitem>

            <listitem>
              <para>the left-hand side contains a list patterns that has no
              more matching options or it contains no list pattern at all; the
              next rule is tried.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>Here we list experimental examples of Rascal code to try out
    features.</para>

    <section>
      <title>Booleans</title>

      <para>It seems that every language specification effort has to produce a
      specification of the Booleans at some moment, so let's try it now. We
      try several variations.</para>

      <para>We use the following common syntax:<programlisting>module Booleans-syntax
exports 
  sorts Bool

  context-free syntax
    "true"        -&gt; Bool
    "false"       -&gt; Bool
    Bool "&amp;" Bool -&gt; Bool {left}
    Bool "|" Bool -&gt; Bool {right}</programlisting></para>

      <section xml:id="section.booleans-with-visit">
        <title>Concrete Booleans defined with visit</title>

        <para>Using the visit construct that we have described above, we can
        write the definitions for the functions <literal>&amp;</literal> and
        <literal>|</literal> as follows:<programlisting>module Bool-examples1

import-syntax Booleans-syntax;

fun Bool reduce(Bool B) {
    visit bottom-up B {
      case true &amp; &lt;Bool B2&gt;   =&gt; &lt;B2&gt;
      case false &amp; &lt;Bool B2&gt;  =&gt; false

      case true | true        =&gt; true
      case true | false       =&gt; true
      case false | true       =&gt; true
      case false | false      =&gt; false
    }
}</programlisting></para>

        <para>Observe that there are two styles:</para>

        <itemizedlist>
          <listitem>
            <para>In the definition for <literal>&amp;</literal>, we use
            variables on the left-hand side: the visit is needed to fully
            normalize the result.</para>
          </listitem>

          <listitem>
            <para>In the definition of <literal>|</literal>, we use a truth
            table.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Abstract Booleans defined with visit</title>

        <para>In the above example we used concrete syntax for Booleans
        expressions. It also possible to define Booleans as abstract
        terms.<programlisting>module Bool-abstract

data Bool btrue;
data Bool bfalse;
data Bool band(Bool, Bool);
data Bool bor(Bool, Bool); 

fun Bool reduce(Bool B) {
    visit bottom-up B {
      acase band(btrue, &lt;Bool B2&gt;)  =&gt; &lt;B2&gt;     %% Use Variables
      acase band(bfalse, &lt;Bool B2&gt;) =&gt; bfalse

      acase bor(btrue, btrue)       =&gt; btrue  %% Use a truth table
      acase bor(btrue, bfalse)      =&gt; btrue
      acase bor(bfalse, btrue)      =&gt; btrue
      acase bor(bfalse, bfalse)     =&gt; bfalse
    }
}</programlisting></para>

        <para>First, type declarations are used to define the abstract syntax
        of the type Bool. Next, a similar reduce function is defined as
        before, but now we use abstract patterns.</para>
      </section>

      <section>
        <title>Abstract Booleans defined with arules</title>

        <para>In ASF, values are always reduced to a normal form before they
        are created. For some applications this normalization or
        canonicalization feature is very handy. We introduce the following
        syntax, which can also help in the transformation of old ASF+SDF
        programs to Rascal:</para>

        <para><programlisting>module Bool-rules

data Bool btrue;
data Bool bfalse;
data Bool band(Bool, Bool);
data Bool bor(Bool, Bool); 

arules(Bool) {
      band(btrue, &lt;Bool B2&gt;)  =&gt; &lt;B2&gt; 
      band(bfalse, &lt;Bool B2&gt;) =&gt; bfalse

      bor(btrue, btrue)       =&gt; btrue
      bor(btrue, bfalse)      =&gt; btrue
      bor(bfalse, btrue)      =&gt; btrue
      bor(bfalse, bfalse)     =&gt; bfalse
}</programlisting>These rules are applied on every Bool that is constructed.
        Like in ASF+SDF it is the responsibility of the programmer to make
        sure the rules are confluent and terminating. The body of a rules
        definition has the same syntax and semantics as the switch construct,
        allowing backtracking, side-effects and checking of conditions.</para>

        <para>There are some issues here:</para>

        <itemizedlist>
          <listitem>
            <para>It should be dissallowed to have private rules on public
            constructors; normalization is a global effect on public
            data-structures. On the other hand, constructors that are local to
            a module may have some private rules applied to them; but public
            rules on private constructors are dissallowed too.</para>
          </listitem>

          <listitem>
            <para>We previously had other ideas about this feature. We
            introduced a reduce keyword that would call a certain named
            function at the construction of every Bool. The problem with that
            feature is that the operational semantics (in the eyes of the
            Rascal programmer) really looks like first some term is to be
            created, and then a function will be applied to normalize it. In
            reality though, we want to normalize the terms in an innermost
            fashion, and at construction time, so that the terms on the
            left-hand side of the rules are never actually created or
            allocated.</para>
          </listitem>
        </itemizedlist>

        <note>
          <para>The following seems more declarative and more close to the
          semantics of rewrite rules being applied everywhere and in any
          order:</para>

          <para><programlisting> rule and(true,B2) =&gt; B2
 rule and(true,B2) : { print("rule!"); yield B2 }</programlisting></para>
        </note>
      </section>

      <section>
        <title>Concrete Booleans defined with rules</title>

        <para>In a similar fashion, the concrete syntax version of Booleans
        can be defined using rules:<programlisting>module Bool-conc-rules

import Booleans-syntax;

rules(Bool) {
      true &amp; &lt;Bool B2&gt;   =&gt; &lt;B2&gt;
      false &amp; &lt;Bool B2&gt;  =&gt; false

      true | true        =&gt; true
      true | false       =&gt; true
      false | true       =&gt; true
      false | false      =&gt; false
}</programlisting></para>
      </section>
    </section>

    <section>
      <title>Abstract Graph datatype</title>

      <para>In the Meta-Environment we use an abstract data type to exchange
      data representing graphs. It can be defined as follows.<programlisting>module Graph

data Graph graph(NodeList nodes, 
                 EdgeList edges, 
                 AttributeList attributes);

type list[Node] Nodelist;

data Node node(NodeId id, 
               AttributeList attributes);

data Node subgraph(NodeId id, 
                   NodeList nodes, 
                   EdgeList edges, 
                   AttributeList attributes);

data NodeId id(term id);

type list[Attribute] AttributeList;

data Attribute bounding-box(Point first, Point second);
data Attribute color(Color color);
data Attribute curve-points(Polygon points);
data Attribute direction(Direction direction);
data Attribute fill-color(Color color);
data Attribute info(str key, value value);
data Attribute label(str label);
data Attribute tooltip(str tooltip);
data Attribute location(int x, int y);
data Attribute shape(Shape shape);
data Attribute size(int width, int height);
data Attribute style(Style style);
data Attribute level(str level);
data Attribute file(File file);
data Attribute file(value file);

data Color rgb(int red, int green, int blue);

data Style bold | dashed | dotted | filled | invisible | solid;

data Shape box | circle | diamond | egg | elipse | hexagon | 
           house | octagon | parallelogram | plaintext | 
           trapezium | triangle;

data Direction forward | back | both | none;

type list[Edge] Edgelist;

data Edge edge(NodeId from, 
               NodeId to, 
               AttributeList attributes);

type list[Point] Polygon;

data Point point(int x, int y);</programlisting></para>
    </section>

    <section>
      <title>Tree traversal</title>

      <para>Here is the binary tree example that we use in explaining
      traversal functions in ASF+SDF.<programlisting>module BTree-syntax
imports basic/Integers

exports 
  sorts BTREE
  context-free syntax
    Integer         -&gt; BTREE
    f(BTREE,BTREE)  -&gt; BTREE
    g(BTREE,BTREE)  -&gt; BTREE
    h(BTREE,BTREE)  -&gt; BTREE
    i(BTREE,BTREE)  -&gt; BTREE</programlisting><programlisting>module BTree-Examples
import-syntax BTree-syntax; 

%% Ex1: Count leaves in a BTREE
%% Idea: int N : T generates alle Integer leaves in the tree

fun int cnt(BTREE T) {
    return size({N | int N : T})
}

%% Ex1: an equivalent,  more purist, version of the same function:
fun int cnt(BTREE T) {
    return size({N | Integer N : T})
}

%% Ex1: alternative solution using trafo functions:

fun int cnt(BTREE T) {
    int C = 0;
    visit T {
      case &lt;Integer N&gt; : C = C+1
    };
    return C;
}
 
%% Ex2: Sum all leaves in a BTREE
%% NB sum is a built-in that adds all elements in a set or list.
%% Here we see immediately the need to identify
%% - the built-in sort "int"
%% - the syntactic sort "Integer"

fun int sumtree(BTREE T) {
    return sum({N | int N : T});
}

%% Ex2: using accumulator

fun int cnt(BTREE T) {
    int C = 0;
    visit T {
      case &lt;Integer N&gt; : C = C+N
    };
    return C;
}

%% Ex3: Increment all leaves in a BTREE
%% Idea: using the construct "visit T { ... }" visit all leaves in
%% thetree T that match an integer and replace each N in T by N+1.
%% The expression as a whole returns the modified term.
%% Note that two conversions are needed here:
%% - from int to NAT to match subterms
%% - from int to NAT to convert the result of addition into 
%%   a NAT tree

fun BTREE inc(BTREE T) {
    visit T {
      case &lt;Integer N&gt;: yield (N + 1)
    };
}

%% Ex4: full replacement of g by i
%% The whole repertoire of traversal functions is available:
%% - visit bottom-up T { ... }
%% - visit bottom-up-break  T { ... }
%% - etc.
%% A nice touch is that these properties are not tied to the
%% declaration of a travesal function (as in ASF+SDF) but to 
%% its use.

fun BTREE frepl(BTREE T) {
    visit bottom-up T {
      case g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) =&gt;
           i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    };
}

%% Ex5: Deep replacement of g by i

fun BTREE frepl(BTREE T) {
    visit bottom-up-break T {
      case g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) =&gt;
           i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    };
}

%% Ex6: shallow replacement of g by i (i.e. only outermost 
%% g's are replaced); 

fun BTREE srepl(BTREE T) {
    visit top-down-break T {
      case g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) =&gt; 
           i(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;)
    };
}

%% Ex7: We can also add the first/td directives to all generators 
%% (where "all td" would be the default):

fun set[BTREE] find_outer_gs(BTREE T) {
    return
    { S | STATEMENT S : top-down-break T, 
          g(&lt;BTREE T1&gt;, &lt;BTREE T2&gt;) := S };
}
 
%% Ex8: accumulating transformer that increments leaves with 
%% amount D and counts them
fun tuple[int, BTREE] count_and_inc(BTREE T, int C, int D) {
    int C = 0;
    
    visit T {
      case &lt;Integer N&gt;: { C = C + 1; N = N + D; yield [| &lt;N&gt; |]}
     };
     return &lt;C, T&gt;;
}
</programlisting></para>
    </section>

    <section>
      <title>Substitution in Lambda</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.</para>

      <programlisting>module examples/Lambda/Lambda-syntax

exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+               -&gt; Var
context-free syntax
     "prime" "(" Var ")"  -&gt; Var  %% generate unique name
     Var                  -&gt; Exp  %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp  %% function abstraction
     Exp Exp              -&gt; Exp  %% function application
</programlisting>

      <para>Examples:</para>

      <para><programlisting>module Lambda-Examples

import-syntax Lambda-syntax;

fun set[Var] allVars(Exp E) {
    return {V | Var V : E}
}

fun set[Var] boundVars(Exp E) {
    return {V | fn &lt;Var V&gt; =&gt; &lt;Exp E1&gt; : E};
} 

fun set[Var] freeVars(Exp E) {
    return allVars(E) - boundVars(E);
}

%% Generate a fresh variable if V does not occur in 
%% given set of variables.

fun Var fresh(Var V, set[Var] S) {
    if (V in S){ return prime(V); } else {return V;};
}

%% Substitution: replace all occurrences of V in E2 by E1

fun Exp subst(Var V1, Exp E1, Exp E2) {

    switch E2 {
      case &lt;Var V2&gt;: if(V1 != V2){ yield [| &lt;V2&gt; |] }

      case &lt;Var V2&gt;: if(V1 == V2){ yield [| &lt;E1&gt; |] }

      case &lt;Exp Ea&gt; &lt;Exp Eb&gt;: {
        Exp EaS = subst(V, E, Ea);
        Exp EbS = subst(V, E, Eb);
        return [| &lt;Exp EaS&gt; &lt;Exp EbS&gt; |];
      } 

      case fn &lt;Var V2&gt; =&gt; &lt;Var Ea&gt;:
        if (V1 == V2) { yield [| fn &lt;V2&gt; =\&gt; &lt;Ea&gt; |] }

      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;:
        if(V1 != V2 and not(V1 in freeVars(E2) and 
           V2 in freeVars(E1))){
           Exp E1S = subst(V1, E1, Ea);
           yield [| fn &lt;Var V2&gt; =\&gt; &lt;Exp E1S&gt; |];
        }              
 
      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;: 
        if(V1 != V2 and V1 in freeVars(Ea) and 
           V2 in freeVars(E1)){
           Var V3 = fresh(V2, freeVars(Ea) + freeVars(E1));
           Exp EaS = subst(V1, E1, subst(V2, V3, E2));
           yield [| fn &lt;Var V3&gt; =\&gt; &lt;Exp EaS&gt; |];
        }
    };
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let</title>

      <para><programlisting>module Let-syntax
exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+                           -&gt; Var
context-free syntax
     Var                              -&gt; Exp
     "let" Var "=" Exp "in" Exp "end" -&gt; Exp </programlisting>Examples:<programlisting>module Let-Example
imports Let;

%% Rename all bound variables in an Exp
%% Version 1: purely functional
%% Exp: given expression to be renamed
%% rel[Var,Var]: renaming table
%% Int: counter to generate global variables

fun Exp rename(Exp E, rel[Var,Var] Rn, Int Cnt) {
    switch E {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end: {
         Var Y = "x" + Cnt;  %% this + operator concatenates 
                             %% (after converting the int to str)
         int Cnt1 = Cnt + 1;
         Exp E1R = rename(E1, Rn, Cnt);
         Exp E2R = rename(E2, {&lt;V, Y&gt;} + Rn, Cnt1);
         return make let &lt;Var Y &gt;= &lt;Exp E1R&gt;
                     in 
                        &lt;Exp E2R&gt;
                     end;
          }

    case &lt;Var V&gt;: return Rn(V)

    default: return E
    };
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let using globals</title>

      <para>Here is the same renaming function now using two global
      variables.<programlisting>module Let-Example

import-syntax Let;

%% Rename all bound variables in an Exp
%% Version 2: using global variables
%% Cnt: global counter to generate fresh variables
%% rel[Var,Var]: global renaming table

global int Cnt = 0;
global rel[Var,Var] Rn = {};

fun Var newVar() {
    global int Cnt;  
    Cnt = Cnt + 1;
    return "x" + Cnt
}

fun Exp rename(Exp E) {
    global int Cnt;
    global rel[Var,Var] Rn;
    switch E {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end: {
         Var Y = newVar();
         Rn = {&lt;V, Y&gt;} + Rn;
         Exp E1R = rename(E1);
         Exp E2R = rename(E2);
         return [| let &lt;Var Y &gt;= &lt;Exp E1R&gt;
                   in 
                      &lt;Exp E2R&gt;
                   end 
                |]
          }

    case &lt;Var V&gt;: return Rn(V)

    default: return E
    };
}</programlisting></para>
    </section>

    <section>
      <title>Concise Pico Typechecker</title>

      <para>The following example shows the tight integration ASF with
      comprehensions.<programlisting>module Typecheck

imports Pico-syntax;
imports Errors;

subtype Env rel[PICO-ID,TYPE];

fun list[Error] tcp(PROGRAM P) {
    switch P {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
           Env Env = {&lt;Id, Type&gt; | 
                      [| &lt;PICO-ID Id&gt; : &lt;TYPE Type&gt; |] : Decls};
           return [ tcst(S, Env) | Stat S : Series ] 
      }
    };
}

fun list[Error] tcst(Stat Stat, Env Env) {
    switch Stat {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt;|]: {
        TYPE Type = Env(Id);
        return type-of(Exp, Type, Env);
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:
        return type-of(Exp, natural, Env) + 
               tcs(Stats1, Env) + tcs(Stats2, Env)

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od: 
        yield type-of(Exp, natural, Env) + tcs(Stats, Env)
    };
}

fun list[Error] type-of(Exp E, TYPE Type, Env Env) {
    switch E {
      case &lt;NatCon N&gt;: if(Type == natural){ return []; }

      case &lt;StrCon S&gt;: if(Type == string) { return []; }

      case &lt;PICO-ID Id&gt;: {
         TYPE Type2 = Env(Id);
         if(Type2 == Type) { return []; }
      }

      case &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type-of(E1, natural, Env) + 
                  type-of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type-of(E1, natural, Env) + 
                  type-of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; || &lt;EXP E2&gt;: 
        if(Type == string){
          return type-of(E1, string, Env) + 
                 type-of(E1, string, Env)
        }
    
      default: return [error("Incorrect type")]
    };
}</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator</title>

      <para><programlisting>module Pico-eval
imports pico/syntax/Pico;

type int PICO-VALUE;
type str PICO-VALUE;

type map[PICO-ID, PICO-VALUE] VEnv;

fun VEnv evalProgram(PROGRAM P){
    switch P {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          VEnv Env = evalDecls(Decls);
          return evalStatements(Series, Env);
      }
   }
};

fun VEnv assign(VEnv Env, PICO-ID Id, PICO-VALUE V){
  Env(Id) = V;
  return Env
}

fun PICO-VALUE valueOf(VEnv Env, PICO-ID Id){
  return Env(Id);
}

fun VEnv evalDecls(DECLS Decls){
    VEnv Env = {};
    visit Decls {
      case &lt;PICO-ID Id&gt; : string:  Env = assign(Env, Id, "")
      case &lt;PICO-ID Id&gt; : natural: Env = assign(Env, Id, 0)
    }
}

fun VEnv evalStatements({STATEMENT ";"}* Series, VEnv Env){
    switch Series {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        Env Env2 = evalStatement(Stat, Env);
        return evalStatements(Series2, Env2);
      }
      case [| |]: return Env
    }
}

fun VEnv evalStatement(STATEMENT Stat, VEnv Env){
    switch Stat {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        PICO-VALUE Val = evalExp(Exp, Env);
        return assign(Env, Id, Val)
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:{
        PICO-VALUE Val = evalExp(Exp, Env);
        if(Val != 0)
          return evalStatments(Stats1, Env)
        else 
          return evalStatements(Stats2, Env)

      }

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od:{
        PICO-VALUE Val = evalExp(Exp, Env);
        if(Val != 0)
          return Env
        else {
          VEnv Env2 = evalStatements(Stats1, Env);
          return evalStatement(Stat, Env2)
        }
      }
    };
};

fun PICO-VALUE evalExp(Exp exp, VEnv Env) {
    switch exp {
      case &lt;NatCon N&gt;: return N

      case &lt;StrCon S&gt;: return S

      case &lt;PICO-ID Id&gt;: return valueOf(Env, Id)

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;: {
           Natural nat1 = evalExp(exp1, Env);
           Natural nat2 = evalExp(exp2, Env);
           return nat1 + nat2;
      }
      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;: {
           Natural nat1 = evalExp(exp1, Env);
           Natural nat2 = evalExp(exp2, Env);
           return nat1 + nat2;
      }
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;: {
           StrCon str1 = evalExp(exp1, Env);
           StrCon str2 = evalExp(exp2, Env);
           return concat(str1, str2);
      }
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator with globals</title>

      <para>Here is the same evaluator but now using a global variable to
      represent the value environment.<programlisting>module Pico-eval
imports pico/syntax/Pico;

type int PICO-VALUE;
type str PICO-VALUE;

type map[PICO-ID, PICO-VALUE] VEnv;

fun void evalProgram(PROGRAM P){
    switch P {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          evalDecls(Decls);
          evalStatements(Series);
      }
   }
};

fun void assign(PICO-ID Id, PICO-VALUE V){
  global Venv Env;
  Env(Id) = V;
  return;
}

fun PICO-VALUE valueOf(PICO-ID Id){
  global Venv Env;
  return Env(Id); 
}

fun VEnv evalDecls(DECLS Decls){
    global VEnv Env = {};
    visit Decls {
      case &lt;PICO-ID Id&gt; : string:  assign(Id, "")
      case &lt;PICO-ID Id&gt; : natural: assign(Id, 0)
    }
}

fun void evalStatements({STATEMENT ";"}* Series){
    global VEnv Env;
    switch Series {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        evalStatement(Stat);
        evalStatements(Series2);
        return
      }
      case [| |]: return
    }
}

fun void evalStatement(STATEMENT Stat){
    global VEnv Env;
    switch Stat {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        PICO-VALUE Val = evalExp(Exp);
        assign(Id, Val);
        return
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:{
        PICO-VALUE Val = evalExp(Exp);
        if(Val != 0) {
          evalStatements(Stats1);
          return
        } else {
          evalStatements(Stats2);
          return
        }
      }

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od:{
        PICO-VALUE Val = evalExp(Exp);
        if(Val != 0)
          return
        else {
          evalStatements(Stats1);
          evalStatement(Stat);
          return
        }
      }
    };
};

fun PICO-VALUE evalExp(Exp exp) {
    global VEnv Env;
    switch exp {
      case &lt;NatCon N&gt;: return N

      case &lt;StrCon S&gt;: return S

      case &lt;PICO-ID Id&gt;: return valueOf(Id)

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;: {
           Natural nat1 = evalExp(exp1);
           Natural nat2 = evalExp(exp2);
           return nat1 + nat2;
      }
      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;: {
           Natural nat1 = evalExp(exp1);
           Natural nat2 = evalExp(exp2);
           return nat1 + nat2;
      }
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;: {
           StrCon str1 = evalExp(exp1);
           StrCon str2 = evalExp(exp2);
           return concat(str1, str2);
      }
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico control flow extraction</title>

      <para><note>
          <para>Is the definition of CP ok?</para>
        </note></para>

      <programlisting>module Pico-controlflow
 
import-syntax pico/syntax/Pico;

type EXP CP;         
type STATEMENT CP;

type tuple[set[CP] entry, 
           rel[CP,CP] graph, 
           set[CP] exit] CFSEGMENT;

fun CFSEGMENT cflow({STATEMENT ";"}* Stats){ 
    switch Stats {
      case &lt;STATEMENT Stat&gt; ; &lt;{STATEMENT ";"}* Stats2&gt;: { 
           tuple[set[CP] En1, rel[CP,CP] R1, set[CP] Ex1] = 
                                                     cflow(Stat);
           tuple[set[CP] En2, rel[CP,CP] R2, set[CP] Ex2] = 
                                                     cflow(Stats2);
           return &lt;En1, R1 + R2 + product(Ex1, En2), Ex2&gt;
      }

      case [| |]: return &lt;{}, {}, {}&gt;
    }
}; 

fun CFSEGMENT cflow(STATEMENT Stat){
    switch Stat {
      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od : {
           tuple[set[CP] En,  rel[CP,CP] R,  set[CP] Ex] = 
                                                     cflow(Stats);
           return &lt;{Exp}, product({Exp}, En) + R + 
                          product(Ex, {Exp}),
                   {Exp}&gt;;
      }
                
      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats2&gt; fi: {
           tuple[set[CP] En1, rel[CP,CP] R1, set[CP] Ex1] = 
                                                    cflow(Stats1);
           tuple[set[CP] En2, rel[CP,CP] R2, set[CP] Ex2] = 
                                                    cflow(Stats2);
           return &lt; {Exp}, 
                    product({Exp}, En1) + 
                    product({Exp}, En2) + R1 + R2,
                    Ex1 + Ex2 
                  &gt;;
      }
         
      case &lt;STATEMENT Stat&gt;: return &lt;{Stat}, {}, {Stat}&gt;
    };
}
</programlisting>

      <para></para>
    </section>

    <section>
      <title>Pico use def extraction</title>

      <programlisting>module Pico-use-def

import-syntax pico/syntax/Pico;

fun rel[PICO_ID, EXP] uses(PROGRAM P) {
  return {&lt;Id, E&gt; | EXP E : P, PICO_ID Id := E}
}

fun rel[PICO_ID, STATEMENT] defs(PROGRAM P) { 
  return {&lt;Id, S&gt; | STATEMENT S : P, 
                    [| &lt;PICO_ID Id&gt; := &lt;EXP Exp&gt; |] := S}
}</programlisting>

      <para>The above uses a "matching condition" to decompose
      <literal>S</literal>. The problem solved is that we want to have a name
      for the whole assignment <emphasis>and</emphasis> for the lhs
      identifier. Also note that, compared to older definitions of these
      functions, the iudentifier is placed as first element in each
      tuple.</para>
    </section>

    <section>
      <title>Pico uninitialized variables</title>

      <para><programlisting>module Pico-uninit

import-syntax pico/syntax/Pico;

import Pico-controlflow;
import Pico-use-def;

fun set[PICO_ID] uninit(PROGRAM P) {
    rel[EXP,PICO_ID] Uses = uses(P);
    rel[PICO_ID, STATEMENT] Defs = defs(P);
    CFSEGMENT CFLOW = cflow(P);
    set[CP] Root = CFLOW.entry;
    rel[CP,CP] Pred = CFLOW.graph; 

    return {Id | tuple[EXP E, PICO_ID Id] : Uses,
                 E in reachX(Root, Defs[Id], Pred)
    };
}</programlisting></para>
    </section>

    <section>
      <title>Pico common subsexpression elimination</title>

      <para><programlisting>module Pico-common-subexpression

import-syntax pico/syntax/Pico;
import Pico-controlflow;
import Pico-use-def;

fun PROGRAM cse(PROGRAM P) {
    rel[PICO_ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;
    map[EXP, PICO_ID] replacements = 
       {&lt;E2, Id&gt; | STATEMENT S : P,
                   [| &lt;PICO_ID Id&gt; := &lt;EXP E&gt; |] := S,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[Id], Pred)
       };
  
    visit P {
      case &lt;EXP E&gt;: if(PICO_ID Id := replacements(E)) yield Id
    };
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions E2 by Id, such
      that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>Id does not occur in E,</para>
        </listitem>

        <listitem>
          <para>E2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and E2.</para>
        </listitem>
      </itemizedlist>

      <para>Note that a slight abbreviation is possible if we introduce
      labelled patterns (here S): [UNDER DISCUSSION]</para>

      <programlisting> rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | &lt;PICO-ID Id&gt; := &lt;EXP E&gt; S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs(Id), Pred)
       };</programlisting>

      <para>Also note that we could factor out the assignment pattern to make
      cse more generic if we introduce patterns as first class
      citizens:</para>

      <programlisting>fun PROGRAM cse(PROGRAM P, 
                pat STATEMENT Assign(PICO-ID Id, EXP E)) {
 ...
    rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | Assign S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs(Id), Pred)
       };
 
 ...
}</programlisting>

      <para>Example invocations (Pico style)</para>

      <programlisting>cse(P, &lt;PICO-ID Id&gt; := &lt;EXP E&gt;)</programlisting>

      <para>or (Cobol style):</para>

      <programlisting>cse(P, move &lt;EXP E&gt; to &lt;PICO-ID Id&gt;)</programlisting>

      <para>Note that the order of variables in the pattern and its
      declaration may differ.</para>

      <para>It is to be determined how the instantiation of a pattern looks,
      e.g.</para>

      <programlisting>Assign([|x|], [| y = 1 |])</programlisting>
    </section>

    <section>
      <title>Pico constant propagation</title>

      <para><programlisting>module Pico-constant-propagation

import-syntax pico/syntax/Pico;
import  Pico-controlflow;
import  Pico-use-def;

fun Boolean is_constant(EXP E) {
   switch E {
     case &lt;NatCon N&gt; =&gt; true

     case &lt;StrCon S&gt; =&gt; true

     case &lt;EXP E&gt;    =&gt; false
   }
}

fun PROGRAM cp(PROGRAM P) {
    rel[PICO_ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;

    map[PICO_ID, EXP] replacements = 
      {&lt;Id2, E&gt; | STATEMENT S : P,
                  [| &lt;PICO_ID Id&gt; := &lt;EXP E&gt; |] := S,
                  is_constant(E),
                  PICO_ID Id2 : reachX({S},Defs[Id],Pred),
                  Id2 == Id 
      };  
 
    visit P {
     case &lt;PICO-ID Id&gt;: if(EXP E := replacements[Id]) yield E
    };  
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions Id2 by the constant E,
      such that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>E is constant,</para>
        </listitem>

        <listitem>
          <para>Id2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>Id2 is equal to Id,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and Id2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico Reaching definitions</title>

      <para>Recall the equations construct as used, for example, in the
      reaching definitions example in the Rscript guide. It computes the
      values of a set of variables until none of them changes any longer. The
      "solve" statement achives the same effect.<programlisting>module Pico-reaching-defs

type tuple[Stat theStat, Var theVar] Def;
type tuple[Stat theStat, Var theVar] Use;

fun set[Stat] predecessor(rel[Stat,Stat] P, Stat S) { 
    return invert(P)(S)
}

fun set[Stat] successor(rel[Stat,Stat] P, Stat S) { 
    return P(S)
}

fun rel[Stat, Def] reaching_definitions(rel[Stat,Var] DEFS, 
                                        rel[Stat,Stat] PRED) {

    set[Stat] STATEMENT = carrier(PRED);

    rel[Stat,Def] DEF  = {&lt;S,&lt;S,V&gt;&gt; | tuple[Stat S, Var V]: DEFS};

    rel[Stat,Def] KILL = 
        {&lt;S1, &lt;S2, V&gt;&gt; | tuple[Stat S1, Var V] : DEFS, 
                         tuple[Stat S2, V] : DEFS, 
                         S1 != S2
        };

     rel[Stat,Def] IN = {};
     rel[Stat,Def] OUT = DEF;

     solve {
           IN  =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Stat P : predecessor(PRED,S), 
                            Def D : OUT[P]};
           OUT =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Def D : DEF[S] + (IN[S] - KILL[S])}
    };
    return IN;
}</programlisting></para>
    </section>

    <section>
      <title>Structured lexicals: numbers</title>

      <para>Given the SDF definition:<programlisting>sorts Digit Number Real  
lexical syntax
   [0-9]             -&gt; Digit
   Digit+            -&gt; Number
   Number "." Number -&gt; Real</programlisting>we can write normalization
      rules for <literal>Number</literal> that remove leading
      zeros:<programlisting>rules(Number){
   number("0" &lt;Digit+ Ds&gt;) =&gt; number(&lt;Ds&gt;)
}</programlisting>A truncation function on <literal>Real</literal> can replace
      the mantissa by 0:</para>

      <para><programlisting>fun Real trunk(Real R){
    switch R {
       case real(&lt;Number Num&gt; "." &lt;Digit+ Ds&gt;) =&gt; real(&lt;Num&gt; "." "0")
    }
}</programlisting></para>
    </section>

    <section>
      <title>Structured Lexicals: strings</title>

      <para>Given the SDF definition:<programlisting>sorts String NQChar
lexical syntax
   ~[\"]             -&gt; NQChar
   [\"] NQChar* [\"] -&gt; String</programlisting>A function that removes the
      <emphasis>first</emphasis> newline from a string can be written
      as:<programlisting>fun String removeNL(String S){
    switch S {
      case string("\"" &lt;NQChar* Chars1&gt; "\n" &lt;NQChar* Chars2 "\"") =&gt;
           string("\"" &lt;Chars1&gt; &lt;Chars2&gt; "\"")
    }
}</programlisting></para>
    </section>

    <section>
      <title>Symbol table with scopes</title>

      <para>Here is a (probably naive) implementation of a symbol table that
      maintains a list of numbered scopes as well as a (Name, Value) mapping
      in each scope. Note that we introduce parameterized modules to do this
      right.<programlisting>module SymTable[&amp;Name, &amp;Value]

%% A scope-oriented symbol table.
%% Each scope consists of a map from names to values. 
%% This is more intended to explore whether this can be expressed
%% *at all* than that the datatype is well designed.

type rel[&amp;Name, &amp;Value] ScopeMap;
type int ScopeId;
data STable[&amp;Name, &amp;Value] stable(ScopeId scope, 
                                  rel[int, ScopeMap] scopes); 

%%Create a new, empty,  table
fun STable[&amp;Name, &amp;Value] new_table(){
  return stable(0, {&lt;0, {}&gt;});
}

%% Create a new, non-empty, table
fun STable[&amp;Name, &amp;Value] new_table(ScopeId scope, 
                              rel[int, ScopeMap] scopes){
  return stable(scope, scopes);
} 

%% Update, in a given scope, the value of a variable
fun STable[&amp;Name, &amp;Value] update(STable[&amp;Name, &amp;Value] ST, 
                                 ScopeId scope, 
                                 &amp;Name N, 
                                 &amp;Value V){
  ST.scopes(scope) = V;
  return new_table(scope, ST.scopes)
}

%% Get, in a given scope, the value of a variable
fun STable[&amp;Name, &amp;Value] value_of(STable[&amp;Name, &amp;Value] ST, 
                                ScopeId scope, 
                                &amp;Name N){
  return ST.scopes(scope)(N)
}

%% update, in the current scope, the value of a variable
fun STable[&amp;Name, &amp;Value] update(STable[&amp;Name, &amp;Value] ST, 
                                 &amp;Name N, 
                                 &amp;Value V){
%%  ST.scopes(scope)(N)= V;
  return new_table(scope, ST.scopes)
}

%% Get, in the current scope, the value of a variable
fun STable value_of(STable[&amp;Name, &amp;Value] ST, 
                 &amp;Name N){
  return ST.scopes(ST.scope)(N)
}

%% add a new scope and make it the current scope
fun STable[&amp;Name, &amp;Value] new_scope(STable[&amp;Name, &amp;Value] ST){
  ScopeId scope = ST.scope + 1;
  return new_table(scope, ST.scopes);
}

%% switch to another scope
fun STable[&amp;Name, &amp;Value] switch_scope(STable[&amp;Name, &amp;Value] ST, 
                                       ScopeId scope){
  return new_table(scope, ST.scopes);
}

</programlisting></para>
    </section>

    <section>
      <title>Innerproduct</title>

      <para>[Example taken from TXL documentation]</para>

      <para>Define nnerproduct on vectors of integers, e.g. (1 2 3).(3 2 1)
      =&gt; 10.<programlisting>module examples/Vectors/Vector-syntax

exports
  imports basic/Integers
sorts Vector

context-free syntax
   "(" Integer* ")"    -&gt; Vector
   Vector "." Vector   -&gt; Integer</programlisting></para>

      <programlisting>module Innerproduct

imports Vector-syntax

fun int innerProduct(Vector V1, V2){
    if ( ( &lt;Integer N1&gt; &lt;Integer* Rest1&gt; ) := V1 &amp;&amp;
         ( &lt;Integer N2&gt; &lt;Integer* Rest2&gt; ) := V2 
       )
       return (N1*N2) + innerProduct( (&lt;Rest1&gt;), (&lt;Rest2&gt;) )
    else 
       return 0;
}</programlisting>
    </section>

    <section>
      <title>Bubble sort</title>

      <para>[Example taken from TXL documentation]</para>

      <programlisting>module Bubble

fun Integer* sort(Integer* Numbers){
    visit Numbers {
      case &lt;Integer* Rest1&gt; 
              &lt;Integer N1&gt; &lt;Integer N2&gt; 
           &lt;Integer* Rest2&gt;:
           if(N1 &gt; N2){
              return sort(make &lt;Integer* Rest1&gt; 
                                  &lt;Integer N2&gt; &lt;Integer N1&gt; 
                               &lt;Integer* Rest&gt;);
           }
    };
    return Numbers
}</programlisting>

      <para>This example raises a number of issues about the execution of
      visit.</para>

      <para>Another way to write this is:</para>

      <programlisting>module Bubble2

fun Integer* sort(Integer* Numbers){
    visit repeat Numbers {
      case &lt;Integer N1&gt; &lt;Integer N2&gt;:
        if( N1 &gt; N2) 
            yield make &lt;Integer N2&gt; &lt;Integer N1&gt;
    };
    return Numbers
}</programlisting>

      <para>The visit will replace all adjacent pairs that are in the wrong
      order in the current list. This is repeated (fixed point operator) until
      no more changes are possible.</para>
    </section>

    <section>
      <title>Generic Bubble sort [under discussion]</title>

      <para>Here is a generic bubble sort wich uses type parameters
      (&amp;ELEM) and a function parameter.<programlisting>module Bubble-Gen

fun &amp;Elem* sort(&amp;Elem* Elements, 
                fun bool GreaterThan(&amp;Elem, &amp;Elem)){
   
  visit repeat Elements {
      case &lt;Elem E1&gt; &lt;Elem E2&gt;: 
        if(GreaterThan(E1, E2)) 
           yield make &lt;Elem E2&gt; &lt;Elem E1&gt;

     }
}</programlisting>Do we want this generality? What are the implications for
      the implementation? The current syntax does not yet allow type variables
      in patterns.</para>
    </section>

    <section>
      <title>Read-Eval-Print Loop (REPR) [Needs further discussion]</title>

      <para>For the scripting of application it is important to have a command
      language and read-eval-print loop. Here is an attempt. The command
      prompt is "&gt;".<programlisting>&gt; import lang.java.syntax.Main as Java
&gt; str source := read("program.java");
&gt; CU program := Java.CU.parse(source);

&gt; fun int count(CU P) {
    int cnt := 0;
&gt;   visit P {
&gt;     Java.Statements.IF =&gt; cnt++;
&gt;   }
    return cnt
&gt; }

&gt; count(program)
17</programlisting>There are several innovations here:</para>

      <itemizedlist>
        <listitem>
          <para>The import associates a name with the imported module.<note>
              <para>This means that "grammar" and "rule" become notions that
              can be manipulated.</para>
            </note></para>
        </listitem>

        <listitem>
          <para>There is a read functions that reads a text file into a
          string.<note>
              <para>We need an io library that reads/writes strings and data
              values.</para>
            </note></para>
        </listitem>

        <listitem>
          <para>We associate a parse function with every non-terminal in a
          grammar.</para>
        </listitem>

        <listitem>
          <para>The notation <literal>Java.Statements.IF</literal> consists of
          three parts:</para>

          <itemizedlist>
            <listitem>
              <para>Language name</para>
            </listitem>

            <listitem>
              <para>Sort name</para>
            </listitem>

            <listitem>
              <para>Rule name (currently implemented with the "cons"
              attribute).</para>
            </listitem>
          </itemizedlist>

          <para>It can be used as pattern. Other potential uses are as
          generator:<programlisting>{S | Java.Statements.IF S : P}</programlisting>It
          generates all if statements in P.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>The Rascal standard library</title>

    <para>In this section we summarize the (over 300!) functions in the Rascal
    Standard Library.</para>

    <section>
      <title>Main functions</title>

      <para>The main functions of the library are listed in the following
      table.</para>

      <table>
        <title>Main functions and operators in Rascal Standard Library</title>

        <tgroup cols="11">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center">&#160;</entry>

              <entry align="center">bool</entry>

              <entry align="center">int</entry>

              <entry align="center">double</entry>

              <entry align="center">str&#160;</entry>

              <entry align="center">loc</entry>

              <entry align="center">list</entry>

              <entry align="center">set</entry>

              <entry align="center">map</entry>

              <entry align="center">rel</entry>

              <entry align="center">tuple_</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>_==_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>_&lt;_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>_+_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>_-_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>_*_</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>_/_</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>size</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>get</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>arb</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>toString</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>
            </row>

            <row>
              <entry>toList</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>toSet</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>toMap</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>toRel</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>-</entry>

              <entry></entry>
            </row>

            <row>
              <entry>reverse</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>reducer</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>mapper</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>
            </row>

            <row>
              <entry>min</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>max</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>sum</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>multiply</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>average</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>get_location</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>set_location</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>x</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Notes:</para>

      <itemizedlist>
        <listitem>
          <para>Operator <literal>==</literal> implements equality on all
          types. It is extended for data types using structural
          equality.</para>
        </listitem>

        <listitem>
          <para>Operator <literal>&lt;</literal> implements less-than on all
          types.</para>
        </listitem>

        <listitem>
          <para>Operators +, -, *, / implement these operators for most types.
          For structured types these operatords exist in three flavours:
          structured value op struct, structured value op element, and element
          op structured value.</para>
        </listitem>

        <listitem>
          <para><literal>size</literal> gives the number of elements of many
          types.</para>
        </listitem>

        <listitem>
          <para><literal>get</literal> (corresponds to the indexing notation
          R[N]) gives the N-th element of a structure.</para>
        </listitem>

        <listitem>
          <para><literal>arb</literal> generates an arbitrary element from a
          structured value.</para>
        </listitem>

        <listitem>
          <para><literal>toString</literal> converts all values to a string
          representation.</para>
        </listitem>

        <listitem>
          <para><literal>toList</literal>, <literal>toSet</literal>,
          <literal>toMap</literal>, <literal>toRel</literal> provide
          conversions between structured types. They may be implemented as
          just a type conversion (and not a data conversion).</para>
        </listitem>

        <listitem>
          <para><literal>reverse</literal> reverses the elements of ordered
          structured types.</para>
        </listitem>

        <listitem>
          <para><literal>reduce</literal>r and <literal>mapper</literal> take
          a function as argument and traverse a structured value.<note>
              <para>Due to a name class with the type constructor
              <literal>map</literal>, we use the name
              <literal>mapper</literal> for a function that is ussually called
              <literal>map</literal>.</para>
            </note></para>
        </listitem>

        <listitem>
          <para><literal>min</literal> and <literal>max</literal> compute the
          smallest (largest) of two basic values or all elements of structured
          values.</para>
        </listitem>

        <listitem>
          <para><literal>average</literal> computes the average value of
          structured values that contain integers or doubles.</para>
        </listitem>

        <listitem>
          <para>get_location and set_location are access functions for values
          of type <literal>loc</literal>.</para>
        </listitem>

        <listitem>
          <para>For relations</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Additional functions on lists sets, maps and relations</title>

      <para>Additional functions on lists, sets maps and relations are listed
      in the following table.<table>
          <title>Additional functions on lists, sets, maps and
          relations</title>

          <tgroup cols="5">
            <colspec align="center" />

            <thead>
              <row>
                <entry align="center">&#160;</entry>

                <entry align="center">list</entry>

                <entry align="center">set</entry>

                <entry align="center">map</entry>

                <entry align="center">rel</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>first</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>rest</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>makeString</entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>id</entry>

                <entry></entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>power</entry>

                <entry></entry>

                <entry>x</entry>

                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>product</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>compose</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>invert</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>complement</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>domain</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>range</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>carrier</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>domainR</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>rangeR</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>carrierR</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>domainX</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>rangeX</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>carrierX</entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>top</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>bottom</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>reachR</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>
              </row>

              <row>
                <entry>reachX</entry>

                <entry></entry>

                <entry></entry>

                <entry></entry>

                <entry>x</entry>
              </row>
            </tbody>
          </tgroup>
        </table>Notes:</para>

      <itemizedlist>
        <listitem>
          <para>These functions are borrowed from the Rscript library.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>closure is missing</para>
      </note>
    </section>

    <section>
      <title>Other functions</title>

      <para>The remaining functions take care of annotations, input/output and
      communication with the global database with program facts, the Program
      Database (PDB).</para>
    </section>

    <section>
      <title>Source code</title>

      <para>This is a very first draft of the library. When the structure is
      stable we will split it in modules.<note>
          <para>The following code is maintained externally and then copied
          :-( to this document, so be carefull with changes.</para>
        </note><programlisting>module RascalStandardLibrary

%% Here is a flat list of library functions that will
%% structured in to coherent submodules.

%% --- Comparison operators ----------------------------------
%% Each type defines == and &lt;. The following
%% functions extend them.

public fun bool &lt;=(&amp;T A, &amp;T B)
  return A &lt; B or A == B

public fun bool &gt;(&amp;T A, &amp;T B)
  return B &lt; A and not A == B

public fun bool &gt;=(&amp;T A, &amp;T B)
  return B &lt; A

public fun &amp;T min(&amp;T A, &amp;T B){
  if(A &lt; B)
    return A
  else
    return B;
}

public fun &amp;T max(&amp;T A, &amp;T B){
  if(A &lt; B)
    return B
  else
    return A;
}

%% --- Boolean (bool) ----------------------------------------

public fun bool ==(bool B1, bool B2)
 primitive("Bool.equal")

public fun bool &lt;(bool B1, bool B2)
  primitive("Bool.less")

public fun bool +(bool B1, bool B2)
  primitive("Bool.add")

public fun bool -(bool B1, bool B2)
 primitive("Bool.sub")

public fun bool *(bool B1, bool B2)
  primitive("Bool.mul")

%% Arbitrary boolean: arb
public fun int arb()
 primitive("Bool.arb")

public fun str toString(bool B)
 primitive("Bool.toString")

%% --- Integer (int)------------------------------------------

public fun bool ==(int I1, int I2)
 primitive("Int.equal")

public fun bool &lt;(int I1, int I2)
  primitive("Int.less")

public fun int +(int I1, int I2)
 primitive("Int.add")

public fun int -(int I1, int I2)
  primitive("-Int")

public fun int *(int I1, int I2)
  primitive("Int.mul")

%% Arbitrary integer: arb
public fun int arb(int bgn, int end)
       throws illegal_argument(str msg) %% if(end - bgn &lt;= 0)
 primitive("Int.arb") 

public fun str toString(int I)
 primitive("toStringInt")

%% --- Double (double) ---------------------------------------

public fun bool ==(double D1, double D2)
  primitive("Double.equal")

public fun bool &lt;(double D1, double D2)
  primitive("Double.less")

public fun double +(double D1, double D2)
  primitive("Double.add")

public fun double -(double D1, double D2)
  primitive("Double.sub")

public fun double *(double D1, double D2)
  primitive("Double.mul")

public fun double /(double D1, double D2)
  primitive("Double.div")

%% Arbitrary double: arb
public fun double arb(double bgn, double end)
       throws illegal_argument(str msg) %% if(end - bgn &lt;= 0)
 primitive("Double.arb")

public fun str toString(double D)
  primitive("Double.toString")

%% --- Strings (str) -----------------------------------------

public fun bool ==(str S1, str S2)
  primitive("String.equal")

public fun bool &lt;(str S1, str S2)
 primitive("String.less")

public fun str +(str S1, str S2)
  primitive("String.add")

public fun int size(str S)
  primitive("String.size")

public fun int get(str S, int N)
       throws out_of_range(str msg)
 primitive("String.get")

public fun list[int] toList(str S)
       throws cannot_convert_int_to_char(str msg)
  primitive("String.toList")
 
public fun set[int] toSet(str S)
  primitive("String.toSet")

public fun str reverse(str S)
  primitive("String.reverse")

%% Add functions for other methods of Java's String class

%% --- Locations ---------------------------------------------

%% The location datatype
data location location(str filename,
                       int beginline,
                       int endline,
                       int begincol,
                       int endcol,
                       int offset,
                       int length);

public fun bool ==(loc L1, loc L2)
  primitive("Location.equal")

public fun bool &lt;(loc L1, loc L2)
  primitive("Location.less")

public fun str toString(loc L)
  primitive("Location.toString")

public fun loc get_location(&amp;T Subject)
       throws location_missing(str msg)
 primitive("Location.get_location")

public fun &amp;T set_location(&amp;T Subject, loc L)
   primitive("Location.set_location")

%% --- Lists -------------------------------------------------

public fun bool ==(list[&amp;T] L1, list[&amp;T] L2)
  primitive("List.equal")

public fun bool &lt;(list[&amp;T] L1, list[&amp;T] L2)
  primitive("List.less")

public fun list[&amp;T] +(list[&amp;T] L1, list[&amp;T] L2)
   primitive("List.add")

public fun list[&amp;T] +(list[&amp;T] L, &amp;T E)
  return L + [E];

public fun list[&amp;T] +(&amp;T E, list[&amp;T] L)
  return [E] + L;

%% Size of list: size
public fun int size(list[&amp;T] L)
  primitive("List.size")

%% Get list element: get
public fun &amp;T get(list[&amp;T] L, int N)
       throws out_of_range(str msg)
  primitive("List.get")

%% Arbitrary element of list: arb
public fun &amp;T arb(list[&amp;T] L)
  primitive("List.arb")

public fun str toString(list[&amp;T] L)
  primitive("List.toString")

public fun str makeString(list[int] L)
       throws cannot_convert_int_to_char(str msg)
  primitive("List.makeString")

public fun set[&amp;T] toSet(list[&amp;T] L)
  primitive("List.toSet")

public fun map[&amp;T, &amp;U] toMap(list[tuple[&amp;T, &amp;U]] L)
       throws domain_not_unique(str msg)
  primitive("List.toMap")

public fun rel[&amp;T] toRel(list[&amp;T] L)
  primitive("List.toRel")

public fun list[&amp;T] reverse(list[&amp;T] L)
  primitive("List.reverse")

public fun &amp;T reducer(list[&amp;T] L, fun &amp;T F (&amp;T,&amp;T), &amp;T unit){
  &amp;T result = unit;
  for(&amp;T E : L){
    result = F(result, E)
  };
  return result
}

public fun list[&amp;T] mapper(list[&amp;T] L, fun &amp;T F (&amp;T,&amp;T))
  return [F(E) | &amp;T E : L];

%% Minimum element of a list: min
public fun &amp;T min(list[&amp;T] L){
  &amp;T result = arb(L);
  for(&amp;T E : L)
   if(less(E, result))
      result = min(result, E);
  return result
}

%% Maximum element of a list: max
public fun &amp;T max(list[&amp;T] L){
  &amp;T result = arb(L);
  for(&amp;T E : L)
   if(less(result, E))
      result = max(result, E);
  return result
}

%% Add elements of a List: sum
public fun &amp;T sum(list[&amp;T] L, &amp;T zero){
  return reducer(L, +, zero);
}

%% Multiply elements of a list: multiply
public fun &amp;T multiply(set[&amp;T] R, &amp;T one){
  return reducer(L, *, one);
}

%% Average of elements of a list: average
public fun &amp;T average(list[&amp;T] L, &amp;T zero)
  return sum(L, zero)/size(L)

%% First element of list; first
public fun &amp;T first(list[&amp;T] L)
       throws empty_list(str msg)
  primitive("List.first")

%% Remaining elements of list: rest
public fun &amp;T rest(list[&amp;T] L)
      throws empty_list(str msg)
  primitive("List.rest")

%% --- Tuples ------------------------------------------------

public fun bool ==(tuple[&amp;T] R, tuple[&amp;T] S)
  primitive("Tuple.equal")

%% less
public fun bool &lt;(tuple[&amp;T] R, tuple[&amp;T] S)
  primitive("Tuple.less")

%% Note the use of + on types to concatenate the types
%% of tuple elements

public fun tuple[&amp;T + &amp;U] +(tuple[&amp;T] R, tuple[&amp;U] S)
  primitive("Tuple.add")

public fun tuple[&amp;T + &amp;U] +(tuple[&amp;T] R, &amp;U E){
  return R + &lt;E&gt;;
}

public fun tuple[&amp;T + &amp;U] +(&amp;T E, tuple[&amp;U] R){
  return &lt;E&gt; + R;
}

public fun int size(tuple[&amp;T] R)
  primitive("Tuple.size")

public fun value get(tuple[&amp;T] R, int N)
       throws out_of_range(str msg)
  primitive("Tuple.get")

public fun str toString(tuple[&amp;T] R)
  primitive("Tuple.toString")

%% --- Sets  -------------------------------------------------

%% ==

public fun bool ==(set[&amp;T] R, set[&amp;T] S)
  primitive("Set.equal")
%% &lt;
public fun bool &lt;(set[&amp;T] R, set[&amp;T] S)
  primitive("Set.less")

%% Add two sets (set union): add (operator +)
public fun set[&amp;T] +(set[&amp;T] R, set[&amp;T] S)
  primitive("Set.add")

public fun set[&amp;T] +(set[&amp;T] S, &amp;T E)
  return S + {E}

public fun set[&amp;T] +(&amp;T E, set[&amp;T] S)
  return {E} + S

%% Substract two sets (set difference): sub (operator -)
public fun set[&amp;T] -(set[&amp;T] R, set[&amp;T] S)
  primitive("Set.sub")

public fun set[&amp;T] -(set[&amp;T] S, &amp;T E)
  return S - {E};

public fun set[&amp;T] -(&amp;T E, set[&amp;T] S)
  return {E} - S;

%% Multiply two sets (set intersection): mul (operator *)
public fun set[&amp;T] *(set[&amp;T] R, set[&amp;T] S)
  primitive("Set.mul")

public fun set[&amp;T] *(set[&amp;T] S, &amp;T E)
  return S * {E}

public fun set[&amp;T] *(&amp;T E, set[&amp;T] S)
  return {E} * S;

%% Size of set: size
public fun int size(set[&amp;T] R)
  primitive("Set.size")

%% Arbitrary element of set: arb
public fun &amp;T arb(set[&amp;T] S)
  primitive("Set.arb")

public fun str toString(set[&amp;T] R)
  primitive("Set.toString")

public fun list[&amp;T] toList(set[&amp;T] S)
  primitive("List.toList")

public fun map[&amp;T, &amp;U] toMap(set[tuple[&amp;T, &amp;U]] S)
       throws non_unique_domain(str msg)
  primitive("Set.toMap")

public fun rel[&amp;T] toRel(set[&amp;T] S)
  primitive("Set.toRel")

public fun &amp;T reducer(set[&amp;T] S, fun &amp;T F (&amp;T,&amp;T), &amp;T unit){
  &amp;T result = unit;
  for(&amp;T E : S){
    result = F(result, E)
  };
  return result
}

public fun set[&amp;T] mapper(set[&amp;T] S, fun &amp;T F (&amp;T,&amp;T))
  return {F(E) | &amp;T E : S};

%% Minimum of a set: min
public fun &amp;T min(set[&amp;T] S){
  &amp;T result = arb(S);
  for(&amp;T E : S)
    result = min(result, E);
  return result
}

%% Maximum of a set: max
public fun &amp;T max(set[&amp;T] R){
  &amp;T result = arb(R);
  for(&amp;T E : R)
    result = max(result, E);
  return result
}

%% Sum elements of a Set: sum
public fun &amp;T sum(set[&amp;T] S, &amp;T zero){
  return reducer(S, +, zero);
}

%% Multiply elements of a Set: multiply
public fun &amp;T multiply(set[&amp;T] S, &amp;T one){
  return reducer(S, *, one);
}

%% Average of elements of a set; average
public fun &amp;T average(set[&amp;T] S, &amp;T zero)
  return sum(S, zero)/size(R)

%% Powerset: power0
public fun set[set[&amp;T]] power0(set[&amp;T] R)
 throw unimplemented("power0")

%% Powerset: power1
public fun set[set[&amp;T]] power1(set[&amp;T] R)
  throw unimplemented("power0")

%% --- Maps --------------------------------------------------

public fun bool ==(map[&amp;T, &amp;U] M1, map[&amp;T, &amp;U] M2)
  primitive("Map.equal")

public fun bool &lt;(map[&amp;T, &amp;U] M1, map[&amp;T, &amp;U] M2)
  primitive("Map.less")

public fun map[&amp;T] +(map[&amp;T] R, map[&amp;T] S)
  primitive("Map.add")

public fun map[&amp;T] +(map[&amp;T] S, &amp;T E)
  return S + {E};

public fun map[&amp;T] +(&amp;T E, map[&amp;T] S)
  return {E} + S

%% Substract two maps (set difference): sub (operator -)
public fun map[&amp;T] -(map[&amp;T] R, map[&amp;T] S)
   primitive("Map.sub")

public fun map[&amp;T] -(map[&amp;T] S, &amp;T E)
  return S - {E}

public fun map[&amp;T] -(&amp;T E, map[&amp;T] S)
  return {E} - S

%% Multiply two maps (set intersection): mul (operator *)
public fun map[&amp;T] *(map[&amp;T] R, map[&amp;T] S)
  primitive("Map.mul")

public fun map[&amp;T] *(map[&amp;T] S, &amp;T E)
  return S * {E}

public fun map[&amp;T] *(&amp;T E, map[&amp;T] S)
  return {E} * S

public fun int size(map[&amp;T] M)
  primitive("Map.size")

public fun &amp;T arb(map[&amp;T] M)
  primitive("Map.arb")

public fun str toString(map[&amp;T] R)
  primitive("Map.toString")

public fun list[tuple[&amp;T, &amp;U]] toList(map[&amp;T, &amp;U] M)
  primitive("Map.toList")

public fun rel[tuple[&amp;T, &amp;U]] toSet(map[&amp;T, &amp;U] M)
  primitive("Map.toSet")

public fun rel[tuple[&amp;T, &amp;U]] toRel(map[&amp;T, &amp;U] M)
  primitive("Map.toRel")

%% Is this meaningfull?
public fun &amp;T reducer(map[&amp;T] S, fun &amp;T F (&amp;T,&amp;T), &amp;T unit){
  &amp;T result = unit;
  for(&amp;T E : S){
    result = F(result, E)
  };
  return result
}

public fun map[&amp;T] mapper(map[&amp;T] M, fun &amp;T F (&amp;T,&amp;T))
  return {F(E) | &amp;T E : M};

%% --- Relations ---------------------------------------------

public fun bool ==(rel[&amp;T] R, rel[&amp;T] S)
  primitive("Rel.equal")

public fun bool &lt;(rel[&amp;T] R, rel[&amp;T] S)
  primitive("Rel.less")

%% Add two relations (union): add (operator +)
public fun rel[&amp;T] +(rel[&amp;T] R1, rel[&amp;T] R2)
  primitive("Rel.add")

public fun rel[&amp;T] +(&amp;T E, rel[&amp;T] R)
  return toRel({E}) + R

public fun rel[&amp;T] +(rel[&amp;T] R, &amp;T E)
  return R + toRel({E})

%% Substract two relations (difference): sub (operator -)
public fun rel[&amp;T] -(rel[&amp;T] R1, rel[&amp;T] R2)
  primitive("Rel.sub")

%% Multiply two relations (intersection): mul (operator *)
public fun rel[&amp;T] *(rel[&amp;T] R1, rel[&amp;T] R1)
  primitive("Rel.mull")

%% Size of relation: size
public fun int size(rel[&amp;T] R)
  primitive("Rel.size")

public fun &amp;T arb(rel[&amp;T] R)
  primitive("Rel.arb")

public fun str toString(rel[&amp;T] R)
  primitive("Rel.toString")

%% Note: in rel[&amp;T], the type variable &amp;T refers 
%% to the tuple type of the relation.

public fun list[&amp;T] toList(rel[&amp;T] R)
  primitive("Rel.toList")

public fun set[&amp;T] toSet(rel[&amp;T] R)
  primitive("Rel.toSet")

public fun rel[&amp;T] toRel(set[&amp;T] S)
  primitive("Set.toRel")

public fun rel[&amp;T] mapper(rel[&amp;T] R, fun &amp;T F (&amp;T,&amp;T))
  return {F(E) | &amp;T E : R};

%% Carthesian product of two sets: product (was: x)
public fun rel[&amp;T1, &amp;T2] product(rel[&amp;T1] R, rel[&amp;T2] S)
  return {&lt;X, Y&gt; | &amp;T1 X : R, &amp;T2 Y : S}

%% Compose two relations: compose (was: o)
public fun rel[&amp;T1, &amp;T3] compose(rel[&amp;T1, &amp;T2] R,
                                 rel[&amp;T2, &amp;T3] S)
   return {&lt;X, Z&gt; | tuple[&amp;T1 X, &amp;T2 Y1]: R, 
                    tuple[&amp;T2 Y2, &amp;T3 Z]: S, Y1 == Y2}

%% Identity relation: id
public fun rel[&amp;T, &amp;T] id(set[&amp;T] S)
  return { &lt;X, X&gt; | &amp;T X : S}

%% Inverse relation: invert (was: inv)
public fun rel[&amp;T2, &amp;T1] invert (rel[&amp;T1, &amp;T2] R)
  return { &lt;Y, X&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R }

%% Complement of relation: complement (was: compl)
public fun rel[&amp;T1, &amp;T2] complement(rel[&amp;T1, &amp;T2] R)
  return product(domain(R), range(R)) - R

%% Domain of relation: domain
public fun set[&amp;T1] domain (rel[&amp;T1,&amp;T2] R)
  return { X | tuple[&amp;T1 X, &amp;T2 Y] : R }

%% Range of relation: range
public fun set[&amp;T1] range (rel[&amp;T1,&amp;T2] R)
  return { Y | tuple[&amp;T1 X, &amp;T2 Y] : R }

%% Carrier of relation: carrier
public fun set[&amp;T]  carrier (rel[&amp;T,&amp;T] R) 
  return domain(R) + range(R)

%% Domain Restriction of a Relation: domainR
public fun rel[&amp;T1,&amp;T2] domainR (rel[&amp;T1,&amp;T2] R, set[&amp;T1] S)
  return { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, X in S }

%% Range Restriction of a Relation: rangeR
public fun rel[&amp;T1,&amp;T2] rangeR (rel[&amp;T1,&amp;T2] R, set[&amp;T2] S)
  return { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, Y in S }

%% Carrier Restriction of a Relation: carrierR
public fun rel[&amp;T,&amp;T] carrierR (rel[&amp;T,&amp;T] R, set[&amp;T] S)
  return { &lt;X, Y&gt; | tuple[&amp;T X, &amp;T Y] : R, X in S, Y in S }

%% Domain Exclusion of a Relation: domainX
public fun rel[&amp;T1,&amp;T2] domainX (rel[&amp;T1,&amp;T2] R, set[&amp;T1] S)
  return { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, X notin S }

%% Range Exclusion of a Relation: rangeX
public fun rel[&amp;T1,&amp;T2] rangeX (rel[&amp;T1,&amp;T2] R, set[&amp;T2] S)
   { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, Y notin S }

%% Carrier Exclusion of a Relation: carrierX
public fun rel[&amp;T,&amp;T] carrierX (rel[&amp;T,&amp;T] R, set[&amp;T] S)
  return { &lt;X, Y&gt; | tuple[&amp;T1 X, &amp;T2 Y] : R, 
                    X notin S, Y notin S }

%% Relations viewed as graphs

%% Top of a Relation: top
public fun set[&amp;T] top(rel[&amp;T, &amp;T] R)
  return domain(R) - range(R)

%% Bottom of a Relation: bottom
public fun set[&amp;T] bottom(rel[&amp;T,&amp;T] R)
  return range(R) - domain(R)

%% Reachability with Restriction: reachR
public fun set[&amp;T] reachR(set[&amp;T] Start, set[&amp;T] Restr,
                          rel[&amp;T,&amp;T] Rel)
  return range(compose(domainR(Rel, Start), 
                       carrierR(Rel, Restr)+))

%% Reachability with Exclusion: reachX
public fun set[&amp;T] reachX(set[&amp;T] Start, set[&amp;T] Excl, 
                          rel[&amp;T,&amp;T] Rel)
  return range(compose(domainR(Rel, Start), 
                       carrierX(Rel, Excl)+))

%% TO DO

public fun rel[&amp;T, &amp;T] closure(rel[&amp;T, &amp;T])
  primitive("Rel.closure")

%% --- Annotations -------------------------------------------

%% Test whether a named annotation exists.
public fun bool has_annotation(&amp;T Subject)
  primitive("Annotation.has_annotation");

%% Get the value of a named annotation
public fun value get_annotation(&amp;T Subject, str Name)
       throws missing_annotation(str msg)
  primitive("Annotation.get_annotation")

%% Get all annotations
public fun map[str,value] get_annotations(&amp;T Subject)
  primitive("Annotation.get_annotation")

%% Set the value of a named annotation
public fun &amp;T set_annotation(&amp;T Subject, 
                             str Name, value AValue)
  primitive("Annotation.set_annotation")

%% Set all annotations
public fun &amp;T set_annotations(&amp;T Subject, 
                              map[str, value] Annos)
  primitive("Annotation.set_annotations")


%% --- Parsing/Unparsing -------------------------------------

public fun &amp;T parseFile(str filename)
       throws file_does_not_exist(str msg)
  primitive("Parse.parseFile")

%% TODO
public fun &amp;T parseString(str source)
  primitive("Parse.parseString")

%% TODO
public fun str unparseToString(&amp;T Subject)
  primitive("Parse.unparseToString")

public fun str unparseToFile(&amp;T Subject, str filename)
       throws cannot_create(str msg) 
       throws write_error(str msg) 
  primitive("Parse.unparseToFile")

%% --- io ----------------------------------------------------

public fun str readFile(str filename)
       throws does_not_exist(str msg)            
       throws read_error(str msg)
  primitive("IO.read")

public fun &amp;T readTerm(str filename) 
       throws does_not_exist(str msg)  
       throws read_error(str msg)
       throws term_error(str msg, loc l)
  primitive("IO.readTerm")

public fun void write(str filename, &amp;T Subject) 
       throws cannot_create(str msg)  
       throws write_error(str msg)
  primitive("IO.write")

%% --- Interface with the Program Database -------------------
%% The following function provide a bare minimum and will
%% have to compared with the current PDB interface.
%% We assume one active PDB that can be opened and closed.
%% Values can be written to and read from the PDB.

%% Idea: it would be nice to model the PDB as a value
%% of type map[str, value] and to access it that way!

public fun void openPDB(str name) 
       throws cannot_open(str msg)
 primitive("PDB.open")

public fun void closePDB()
       throws cannot_close(str msg)
  primitive("PDB.close")

public fun void writePDB(str name, &amp;T val)
       throws cannot_write(str msg)
  primitive("PDB.write")

public fun &amp;T readPDB(str name)
       throws cannot_read(str msg)
  primitive("PDB.readPDB")

%% If name is of type set[&amp;T], then the set incr
%% is added to it. Similar for a rel[&amp;T]

public fun void addSetPDB(str name, set[&amp;T] incr)
       throws does_not_exist(str msg)
  primitive("PDB.addSet")

public fun void addRelPDB(str name, rel[&amp;T] incr)
       throws does_not_exist(str msg)
  primitive("PDB.addRel")
</programlisting></para>
    </section>
  </section>

  <section>
    <title>Syntax Definition</title>

    <para>See separate SDF definition.</para>
  </section>

  <section>
    <title>Protyping/implementation of Rascal</title>

    <para>Every prototype will have to address the following issues:</para>

    <itemizedlist>
      <listitem>
        <para>Parsing/typechecking/evaluating Rascal.</para>
      </listitem>

      <listitem>
        <para>How to implement the relational operations.</para>
      </listitem>

      <listitem>
        <para>How to implement matching.</para>
      </listitem>

      <listitem>
        <para>How to implement replacement.</para>
      </listitem>

      <listitem>
        <para>How to implement traversals.</para>
      </listitem>
    </itemizedlist>

    <para>The following options should be considered:</para>

    <itemizedlist>
      <listitem>
        <para>Implementation of a typechecker in ASF+SDF:</para>

        <itemizedlist>
          <listitem>
            <para>Gives good insight in the type system and is comparable in
            complexity to the Rscript typechecker.</para>
          </listitem>

          <listitem>
            <para>Work: 2 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            ASF+SDF.</para>
          </listitem>

          <listitem>
            <para>Bound to be very slow.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of a typechecker in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Interesting exercise to asses Rascal.</para>
          </listitem>

          <listitem>
            <para>Not so easy to do without working Rascal
            implementation.</para>
          </listitem>

          <listitem>
            <para>Not so easy when Rascal is still in flux.</para>
          </listitem>

          <listitem>
            <para>Effort: 1 week</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Ditto.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Extending the current ASF+SDF interpreter.</para>

        <itemizedlist>
          <listitem>
            <para>This is a viable options. It requires extensions of
            UPTR.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Translation of Rascal to ASF+SDF in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Unclear whether this has longer term merit.</para>
          </listitem>

          <listitem>
            <para>Allows easy experimentation and reuse of current ASF+SDF
            implementation.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an interpreter in Java.</para>

        <itemizedlist>
          <listitem>
            <para>A future proof and efficient solution.</para>
          </listitem>

          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            Java.</para>
          </listitem>

          <listitem>
            <para>Effort: 8 weeks.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Rascal implementation ideas</title>

    <para>Rascal needs to support both a scripting experience as an optimized
    compiled language experience. Also, it needs to integrate fully with
    Meta-Environment and Eclipse IMP. Therefore, we have both a simple and
    unoptimized interpreter in mind, as well as a compiler that aggressively,
    but correctly, optimizes Rascal programs. The run-time of compiled
    programs and the interpreter will share the implementation of
    data-structures.</para>

    <section>
      <title>Data structures</title>

      <para>Both the compiled code and the interpreter will run on the same
      data-structures which are defined by the IMP PDB project.</para>

      <itemizedlist>
        <listitem>
          <para>We could start with the simple implementation that is now in
          IMP already which is based on the Java library and use the clone
          method to implement immutability. This will prove to be slow, but
          its an easy start.</para>
        </listitem>

        <listitem>
          <para>Integration with the ATerms; extend the ATerm library with all
          the features of the PDB, such that it becomes an implementation of
          the PDB's interfaces.</para>

          <itemizedlist>
            <listitem>
              <para>PDB's terms are typed, while ATerms are not.</para>
            </listitem>

            <listitem>
              <para>ATerms demand canonicalization/sharing, which may prove to
              be hard to implement for maps, sets and relations.</para>
            </listitem>

            <listitem>
              <para>PDB does not yet have any story for serialization.</para>
            </listitem>

            <listitem>
              <para>ATerms will need to "implement" the PDB's interfaces which
              will add a dependency and seriously break other peoples code if
              we are not careful</para>
            </listitem>

            <listitem>
              <para>ATerms need to be typed in order to implement correct
              visiting behavior when AFun's are overloaded.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The C story is harder</para>

          <itemizedlist>
            <listitem>
              <para>Extension of C ATerms is hard due to the nature of C, the
              ATerm garbage collector, the ATerm header implementation and the
              amount of users of the ATerm library</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>It may be a good idea to generate Rascal data-types from SDF
          definitions as an intermediate step, however, Rascal should still
          implement special code for UPTR trees for performance reasons
          (unlike Apigen which does not know anything about UPTR).</para>
        </listitem>

        <listitem>
          <para>The current PDB implementation does type checking at run-time.
          After implementing a type-checker for Rascal, we can easily add an
          implementation which does not do type checking at run-time in order
          to improve performance.</para>
        </listitem>

        <listitem>
          <para>The immutability feature of Rascal data is implemented in the
          data-structures and not by the compiler or the interpeter.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Interpreter</title>

      <para>We just enumerate the thoughts that pop up once in a while:</para>

      <itemizedlist>
        <listitem>
          <para>Write the interpreter in Java, and use it later to bootstrap
          the compiler which will be written in Rascal.</para>
        </listitem>

        <listitem>
          <para>Provide a REPL prompt such that experimenting can be done
          on-the-fly, both on the commandline, and in an Eclipse view.</para>
        </listitem>

        <listitem>
          <para>"fail" can be implemented using a Java exception, the catch
          will be at the choice points (switch).</para>
        </listitem>

        <listitem>
          <para>"return" can also be implemented using a Java exception;
          remember return can jump out of the context of a visitor that could
          be nested deeply in the structure of a term or a tree.</para>
        </listitem>

        <listitem>
          <para>List matching, and especially the kind of backtracking it
          requires will be implemented using exceptions instead of using
          continuations.</para>
        </listitem>

        <listitem>
          <para>Pattern matching needs to be implemented separately for both
          builtin data-types, abstract data types and concrete parse trees.
          Possibly using three "adapters" we can factor out the
          algorithm.</para>
        </listitem>

        <listitem>
          <para>We use apigen to bootstrap the interpreter. The interpreter
          will traverse the apigen object trees to implement it's
          functionality using separate classes.</para>
        </listitem>

        <listitem>
          <para>When the compiler is finished and bootstrapped on the
          interpreter, it may be worthwhile to reimplement/bootstrap the
          interpreter on the compiler again.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Compiler</title>

      <para>The compiler will mainly follow the design of Mark's ASF+SDF
      compiler, which has proven to generate the fastest code in the world for
      these kinds of applications. Furthermore, these ideas have popped
      up:</para>

      <itemizedlist>
        <listitem>
          <para>Bootstrap the compiler using the interpreter.</para>
        </listitem>

        <listitem>
          <para>Generate as readable function names as possible, mainly taking
          hints from the Rascal programs and of course from the SDF
          definitions.</para>
        </listitem>

        <listitem>
          <para>Generate Java code, one class per module.</para>
        </listitem>

        <listitem>
          <para>There is an issue with the globality of rewrite rules, they
          probably need to be collected and merged into a single factory per
          application. Rules apparently break modular compilation, especially
          if you want to optimize matching automatons</para>
        </listitem>

        <listitem>
          <para>For visitors we could first generate a tree node type
          reachability graph, and use it to generate a full traversal for a
          certain visitor. The generated visitor would not recurse into
          subtrees that will not be visited.</para>
        </listitem>

        <listitem>
          <para>After generating the visitors, non-recursive visits (i.e. the
          backbone of the grammar) can be inlined as much as possible to
          prevent using the stack for visiting trees.</para>
        </listitem>

        <listitem>
          <para>Inlining in general should be done very aggressively. This
          will allow other kinds of optimizations, like preventing superfluous
          condition checking. The ASF+SDF compiler does not do this yet, and
          it could mean a serious performance improvement. The cost is
          compilation time obviously, since the Java compiler is going to have
          to compile a lot more code.</para>
        </listitem>

        <listitem>
          <para>The simple control flow constructs of Rascal almost map
          one-to-one to Java</para>
        </listitem>

        <listitem>
          <para>"fail" is always in the current context/frame, so we need no
          exception implementation for fail.</para>
        </listitem>

        <listitem>
          <para>Like in Mark's compiler, list matching is to be implemented
          using nested while loops.</para>
        </listitem>

        <listitem>
          <para>"return" can be mapped to normal return statement in Java,
          except in the context of a visitor, where it should be an exception
          that is caught by the containing function of the visit, which
          immediately returns the result in the catch block that surrounds the
          call to the generated function that implements the visitor.</para>
        </listitem>

        <listitem>
          <para>Important optimizations:</para>

          <itemizedlist>
            <listitem>
              <para>Matching automaton:</para>

              <itemizedlist>
                <listitem>
                  <para>Sharing prefixes (note that we can not reorder cases
                  of a switch, or the rules?!?)</para>
                </listitem>

                <listitem>
                  <para>Common subexpression elimination</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Constant detection and propagation</para>
            </listitem>

            <listitem>
              <para>Aggressive inlining (where to stop?)</para>
            </listitem>

            <listitem>
              <para>Specialization and instantiation of visitors using
              grammars and data-type definitions</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Rascal functions with a Java body need the following:</para>

          <itemizedlist>
            <listitem>
              <para>Generate for each argument an Java argument with
              appropirtae Java type.</para>
            </listitem>

            <listitem>
              <para>For each return statement, check the type of the resulting
              value against the return type in the function header.</para>
            </listitem>

            <listitem>
              <para>Catch any exceptions raised by the Java code, convert them
              to string and rethrow as Rascal exception.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.issues">
    <title xml:id="Issues">Issues</title>

    <itemizedlist>
      <listitem>
        <para>Which comment convention will we use? <remark>Let's use Java
        style comments.</remark></para>
      </listitem>

      <listitem>
        <para>Extensibility of functions. <remark>Proposal: let's not provide
        facilities for this.</remark></para>
      </listitem>

      <listitem>
        <para>How do we identify built-in sorts (bool, int, etc) with their
        syntactic counterparts?</para>
      </listitem>

      <listitem>
        <para>In a list comprehension: do list values splice into the list
        result?</para>
      </listitem>

      <listitem>
        <para>Ditto for set comprehensions.</para>
      </listitem>

      <listitem>
        <para>Unexplored idea: add (possibly lazy) generators for all types;
        this allows to generate, for instance, all statements in a
        program.</para>
      </listitem>

      <listitem>
        <para>Shopping list of ideas in Tom:</para>

        <itemizedlist>
          <listitem>
            <para>Named patterns to avoid building a term, i.e. w@[| while
            $Exp do $stat od |].</para>
          </listitem>

          <listitem>
            <para>Anti-patterns, i.e. the complement of a patterns: ! [| while
            $Exp do $stat od |] matches anything but a while. (we had that in
            ASF+SDF too, it's needed)</para>
          </listitem>

          <listitem>
            <para>Anonymous variables a la Prolog: [| while $_ do $stat od
            |].</para>
          </listitem>

          <listitem>
            <para>String matching in patterns.</para>
          </listitem>

          <listitem>
            <para>Tom uses the notation %[ ... ]% for quoted strings with
            embedded @...@ constructs that are evaluated. It also has a
            backquote construct.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Shopping list of ideas from TXL:</para>

        <itemizedlist>
          <listitem>
            <para>"redefine" allows modification of an imported
            grammar.</para>
          </listitem>

          <listitem>
            <para>An "any" sort that matches anything.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Graveyard</title>

    <para>Don't read the following sections; they are leftovers from earlier
    versions of this document but may still contain material that can be
    reused.</para>
  </section>

  <section>
    <title>Mapping features to datatypes</title>

    <para><note>
        <para>This section has played a role during initial design; it is now
        outdated.</para>
      </note>Emphasized cells indicate a new datatype/feature combination that
    needs to be thought out.</para>

    <table xml:id="table.features">
      <title>Features vs datatypes</title>

      <tgroup cols="9">
        <colspec align="left" colname="col1" colnum="1" colwidth="2*" />

        <colspec align="center" colname="col2" colnum="2" colwidth="1*" />

        <colspec align="center" colname="col3" colnum="3" colwidth="1*" />

        <colspec align="center" colname="col4" colnum="4" colwidth="1*" />

        <colspec align="center" colname="col5" colnum="5" colwidth="1*" />

        <colspec align="center" colname="col6" colnum="6" colwidth="1*" />

        <colspec align="center" colname="col7" colnum="7" colwidth="1*" />

        <colspec align="center" colname="col8" colnum="8" colwidth="1*" />

        <colspec align="center" colname="col9" colnum="9" colwidth="1*" />

        <thead>
          <row>
            <entry>Which features work on which datatypes?</entry>

            <entry>CF syntax trees</entry>

            <entry>CF syntax lists</entry>

            <entry>Lexical syntax trees</entry>

            <entry>Lexical syntax lists</entry>

            <entry>Lists</entry>

            <entry>Sets</entry>

            <entry>Relations</entry>

            <entry>Tuples</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Pattern matching</entry>

            <entry>Y (CS)</entry>

            <entry>Y, CS, LM</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS, LM</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Pattern construction</entry>

            <entry>Y, CS</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS</entry>

            <entry>Y</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Generator/ Comprehension</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>LC</entry>

            <entry>SC</entry>

            <entry>SC</entry>

            <entry>N</entry>
          </row>

          <row>
            <entry>Complete Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Equations</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Polymorphism</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Serialization</entry>

            <entry>UPTR</entry>

            <entry>UPTR</entry>

            <entry>UPTR</entry>

            <entry>UPTR</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Traversal Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Subtyping</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N, except character class inclusion</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <itemizedlist>
      <listitem>
        <para>BC = Backward Compatible with ASF</para>
      </listitem>

      <listitem>
        <para>CS = Concrete Syntax</para>
      </listitem>

      <listitem>
        <para>HT= head/tail matching</para>
      </listitem>

      <listitem>
        <para>LC = List comprehension</para>
      </listitem>

      <listitem>
        <para>LM = List Matching</para>
      </listitem>

      <listitem>
        <para>N = No</para>
      </listitem>

      <listitem>
        <para>PS = Prefic Syntax</para>
      </listitem>

      <listitem>
        <para>SC = Set Comprehension</para>
      </listitem>

      <listitem>
        <para>Y = Yes</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Visitor definitions (UNDECIDED and INCOMPLETE)</title>

    <para>Visitor definitions are a new idea that borrow the programmability
    of Systems S's single level traversals and add them to Rascal. The idea is
    to be able to define the strategy annotations of visit statements and
    generators using a simple expression language. A definition takes as
    formal argument the code block of the visit statement (s), which is what
    needs to be done at every node (the visitor).</para>

    <para><programlisting>%% first recurse to the arguments, then try v, 
%% which if it fails returns the original structure.
<emphasis role="bold">visitor</emphasis> bottom-up(v) = <emphasis role="bold">all</emphasis>(bottom-up(v)) ; (v <emphasis
          role="bold">&lt;+</emphasis> <emphasis role="bold">id</emphasis>)

<emphasis role="bold">visitor</emphasis> innermost(t,v) = <emphasis
          role="bold">all</emphasis>(innermost(t,v)) ; <emphasis role="bold">repeat</emphasis>(v &lt;+ id) 
    </programlisting>We demand that all visitors are infallible, which means
    that when the v block fails, they must return a default result of the
    correct type. In most cases, this would be the identity (id).</para>

    <para>We can also try to give these definitions a more imperative look, as
    if they are patterns for generating code for the visitors, as in:</para>

    <para><programlisting><emphasis role="bold">visitor</emphasis> bottom-up(v) {
  <emphasis role="bold">all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {             %% try is the '&lt;+' of System S, 
                    %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    <emphasis role="bold">yield</emphasis> t;
  } 
}

%% innermost goes down and only returns after 
%% nothing changes anymore

<emphasis role="bold">visitor</emphasis> innermost(v) {
  <emphasis role="bold">all</emphasis> {
    innermost(v);     %% apply this to all children first.
  }
  <emphasis role="bold">while (true) {</emphasis> {    %% then until kingdom come, apply this block:
    <emphasis role="bold">try</emphasis> {
      v;              %% if v succeeds, it has a yield or a return
                      %% statement that updates the current node. 
    } <emphasis role="bold">catch fail</emphasis>(t) { %% if v fails after all, we obtain a reference
                      %% to the current node visited which we can 
                      %% return;
      <emphasis role="bold">yield</emphasis> t;
    } 
  }
}   

visitor bottom-up-dbg(v) {  <emphasis role="bold">
  all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {              %% try is the '&lt;+' of System S,
                     %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    printf("DBG: bottom-up visitor failed on: " + t);
    <emphasis role="bold">yield</emphasis> t;
  } 
}</programlisting>After such definitions, most of which would be in the
    standard library of Rascal, we can use them to program actual
    visits:</para>

    <para><programlisting>visit bottom-up (t) {
  pattern =&gt; pattern
  pattern2 : { effect; }
}</programlisting></para>
  </section>

  <section>
    <title>Outdated examples</title>

    <section>
      <title>Generating Graph files in Dot format</title>

      <para>This example illustrates the use of a comprehension on the
      right-hand side of an equation.<programlisting>module Dot-generation

imports Dot-syntax

fun Dot gen-dot(rel[ID, ID] Rel) {
    [| digraph example {
                        $([ node(Tup) | &lt;ID,ID&gt; Tup : Rel ])
                       }
    |]
}

fun DotElem* gen-node(&lt;ID Id1, ID Id2&gt;) {
    [| node $Id1; node $Id2; $Id1 -&gt; $Id2 |}}
}</programlisting></para>
    </section>
  </section>

  <section xml:id="section.integration-tscript">
    <title>Integration with Tscripts (Outdated)</title>

    <note>
      <para>It is not yet clear whether we will also include Tscript in the
      integration effort. For the time being, this section is considered
      outdated.</para>
    </note>

    <section>
      <title>Introduction</title>

      <para>It is possible to speculate on an even further integration of
      formalisms and combining the above amalgan of ASF+SDF and Rscript with
      Tscripts.</para>
    </section>

    <section>
      <title>Requirements</title>

      <itemizedlist>
        <listitem>
          <para>R12: The resulting language uses a single type system. This
          means that relational types (possible including syntactic objects)
          can be used in Tscripts.</para>
        </listitem>

        <listitem>
          <para>R13: The current "expressions" in Tscript (terms that occur at
          the rhs of an assignment) are replaced by calls to ASF+SDF or
          Rscript functions.</para>
        </listitem>

        <listitem>
          <para>R14: There is minimal duplication in functionality between
          ASF+SDF/Rscript/Tscript.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Different styles of Type Declarations</title>

      <para>We have at the moment, unfortunately, a proliferation of
      declaration styles for types.</para>

      <para>Functions are declared in ASF+SDF as:</para>

      <programlisting>typecheck(PROGRAM) -&gt; Boolean</programlisting>

      <para>Observe that only the type of the parameter is given but that it
      does not have a name.</para>

      <para>In Rscript we have:</para>

      <programlisting>int sum(set[int] SI) = ...</programlisting>

      <para>while in Tscript processes are declared as</para>

      <programlisting>process mkWave(N : int) is ...</programlisting>

      <para>For variables a similar story applies. Variables are declared in
      ASF+SDF as:</para>

      <programlisting>"X" [0-9]+    -&gt; INT</programlisting>

      <para>In Rscript we have:</para>

      <programlisting>int X

int X : S   (in comprehensions)</programlisting>

      <para>and in Tscript we have:</para>

      <programlisting>X : int</programlisting>

      <para>In order to unify these styles, we might do the following:</para>

      <itemizedlist>
        <listitem>
          <para>The type of an entity is always written before the entity
          itself.</para>
        </listitem>

        <listitem>
          <para>Formal parameters have a name.</para>
        </listitem>
      </itemizedlist>

      <para>In essence, this amounts to using the declaration style as used in
      Rscript. So we get:</para>

      <programlisting>Boolean typecheck(PROGRAM P) is ...

process mkWave(int N) is ...</programlisting>

      <para>Or do we want things like:</para>

      <programlisting>function typecheck(P : PROGRAM) -&gt; Boolean is ...

var X -&gt; int

process mkWave(int N) is ...</programlisting>

      <para>Advantages are:</para>

      <itemizedlist>
        <listitem>
          <para>The category of the entity is immediately clear (function,
          var, process, tool, ...).</para>
        </listitem>

        <listitem>
          <para>It is readable to further qualify the category, i.e.,
          traversal function, hidden var, restartable tool)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Global Flow of Control</title>

      <para>We have to settle the possible flow of control between the three
      entities ASF+SDF, Rscript and Tscript. Since Tscript imposes the notion
      of an atomic action it would be problematic to have completely
      unrestricted flow of control. Therefore it is logical to use Tscript for
      the top-level control and to limit the use of ASF+SDF and Rscript to
      computations within atomic actions. There is no reason to restrict the
      flow of control between ASF+SDF and Rscript.</para>

      <para>What are the consequences of the above choice? Let's analyze two
      cases:</para>

      <itemizedlist>
        <listitem>
          <para>Parse a file from within an ASF+SDF specification. This (and
          similar built-ins) that use the operating system are removed from
          ASF+SDF. Their effect has to be achieved at the Tscript-level which
          is the natural place for such primitives.</para>
        </listitem>

        <listitem>
          <para>Describe I/O for a defined language. Consider Pico extended
          with a read statement. Here the situation is more complicated. We
          cannot argue that the flow of control in the Pico program (as
          determined by an interpreter written in ASF+SDF) should be moved to
          the Tscript level since Tscript simply does not have the primitives
          to express this. On the other hand, we have to interrupt the flow of
          control of the Pico interpreter when we need to execute a read
          statement. The obvious way to achieve this is</para>

          <itemizedlist>
            <listitem>
              <para>At the Tscript level, a loop repeatedly calls the Pico
              interpreter until it is done.</para>
            </listitem>

            <listitem>
              <para>After each call the Pico interpreter returns with
              either:</para>

              <itemizedlist>
                <listitem>
                  <para>An indication that the eecution is complete (and
                  possibly a final state and/or final value).</para>
                </listitem>

                <listitem>
                  <para>An indication that an external action has to be
                  executed, for instance the read statement. This indication
                  should also contain the intermediate state of the
                  interpreter. When the external action has been executed, the
                  Pico interpreter can be restarted with as arguments the
                  value of the external action and the intermediate
                  state.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Experimentation will have to show whether such a framework is
      acceptable.</para>
    </section>

    <section>
      <title>Modularization</title>

      <para>Rscript and Tscript have no, respectively, very limited mechanisms
      for modularization. ASF+SDF, however, provides a module mechanism with
      imports, hiding, parameters and renaming. This mechanism was originally
      included in ASF, was taken over by SDF and is now reused in ASF+SDF.
      Currently, there are not yet sufficiently large Rscripts to feel the
      need for modules. In Tscript, there is a strong need for restricted name
      spaces and for imposing limitations on name visibility in order to limit
      the possible interactions of a process with its surroundings and to make
      it possible to create nested process definitions. What are the design
      options we have to explore?</para>

      <para>First, we can design a new module system that is more suited for
      our current requirements. The advantage is that we can create an optimal
      solution, the disadvantage is that there are high costs involved
      regarding implementation effort and migrations of existing ASF+SDF
      specifications to the new module scheme.</para>

      <para>Second, we can design an add-on to the ASF+SDF module system that
      addresses our current needs.</para>

      <para>Third, we can try to reuse the current ASF+SDF module
      system.</para>

      <para>As a general note, parameterized modules, polymorphics types and
      renamings are competing features. We should understand what we want. It
      is likely that we do not need all of them.</para>

      <para>Before delving into one of the above alternative approaches, let's
      list our requirements first.</para>

      <itemizedlist>
        <listitem>
          <para>We need grammar modules that allow the following operations:
          import, renaming, deletion (currently not supported but important to
          have a fixed base grammar on many variations on it).
          Parameterization and export/hidden: unclear.</para>
        </listitem>

        <listitem>
          <para>We need function modules (ASF+SDF and Rscript) that provide:
          import, maybe parametrization, and export/hidden.</para>
        </listitem>

        <listitem>
          <para>We need process modules (Tscript) that provide: import,
          export, hiding.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
</article>