<?xml version="1.0" encoding="US-ASCII"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Rascal Requirements and Design Document</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Tijs</firstname><surname>van der
        Storm</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is a braindump of ideas. See <xref linkend="Issues" />
    for the issues that have to be resolved.</para>
  </note>

  <section>
    <title>Introduction</title>

    <para>Rascal is the working name for a new version of ASF+SDF, which will
    be extended with an efficient built-in set and relation data-type. This
    basically means that we include most features of the RScript language into
    ASF+SDF. The goals of this language are:</para>

    <itemizedlist>
      <listitem>
        <para>Separating pure syntax definitions (SDF) from function
        definitions.</para>
      </listitem>

      <listitem>
        <para>Easy syntax-directed analysis of programming languages.</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction.</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning.</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation.</para>
      </listitem>

      <listitem>
        <para>Efficient and scalable implementation.</para>
      </listitem>
    </itemizedlist>

    <para>The above goals are all but one already met in the current design of
    ASF+SDF, and the current design of RScript. What is missing is the
    connection (and to be honest: an efficient implementation of relational
    operators). Alas, any bridge between the two languages is both complex to
    manage and an efficiency bottleneck. This work is an attempt to
    consolidate this engineering trade-off.</para>

    <para>In <xref linkend="section.integration-tscript" /> we will also
    explore the issues when we take integration one step further and also
    include Tscripts in the considerations.</para>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Backward compatible with ASF+SDF. We need to port old
          ASF+SDF definitions to Rascal.</para>
        </listitem>

        <listitem>
          <para>R3: Compilation speed: parsetable generation is a major
          bottleneck in current ASF+SDF. This needs to be fixed.</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability and easy parsing of a
          wide range of source languages.</para>
        </listitem>

        <listitem>
          <para>R5: Functional (no side-effects).</para>
        </listitem>

        <listitem>
          <para>R6: File I/O (contradicts R5).</para>
        </listitem>

        <listitem>
          <para>R7: Easily accessible fact storage (similar to a heap, but
          remember R5 and the details of backtracking).</para>
        </listitem>

        <listitem>
          <para>R8: List matching (because of R2, influences R7).</para>
        </listitem>

        <listitem>
          <para>R9: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as
          scoping).</para>
        </listitem>

        <listitem>
          <para>R10: Syntax trees can be elements of the builtin
          data-structures (but not vice versa).</para>
        </listitem>

        <listitem>
          <para>R11: Features are orthogonal: try to keep the number of ways
          to write down a program minimal</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Mapping features to datatypes</title>

    <para>Emphasized cells indicate a new datatype/feature combination that
    needs to be thought out.</para>

    <table xml:id="table.features">
      <title>Features vs datatypes</title>

      <tgroup cols="9">
        <colspec align="left" colname="col1" colnum="1" colwidth="2*" />

        <colspec align="center" colname="col2" colnum="2" colwidth="1*" />

        <colspec align="center" colname="col3" colnum="3" colwidth="1*" />

        <colspec align="center" colname="col4" colnum="4" colwidth="1*" />

        <colspec align="center" colname="col5" colnum="5" colwidth="1*" />

        <colspec align="center" colname="col6" colnum="6" colwidth="1*" />

        <colspec align="center" colname="col7" colnum="7" colwidth="1*" />

        <colspec align="center" colname="col8" colnum="8" colwidth="1*" />

        <colspec align="center" colname="col9" colnum="9" colwidth="1*" />

        <thead>
          <row>
            <entry>Which features work on which datatypes?</entry>

            <entry>CF syntax trees</entry>

            <entry>CF syntax lists</entry>

            <entry>Lexical syntax trees</entry>

            <entry>Lexical syntax lists</entry>

            <entry>Lists</entry>

            <entry>Sets</entry>

            <entry>Relations</entry>

            <entry>Tuples</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Pattern matching</entry>

            <entry>Y (CS)</entry>

            <entry>Y, CS, LM</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS, LM</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Pattern construction</entry>

            <entry>Y, CS</entry>

            <entry>Y, PS</entry>

            <entry>Y, PS</entry>

            <entry>Y</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y, HT</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Generator/ Comprehension</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>LC</entry>

            <entry>SC</entry>

            <entry>SC</entry>

            <entry>N</entry>
          </row>

          <row>
            <entry>Complete Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Equations</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y, BC</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Polymorphism</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Serialization</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>AsFix</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Traversal Functions</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>

          <row>
            <entry>Subtyping</entry>

            <entry>N</entry>

            <entry>N</entry>

            <entry>N, except character class inclusion</entry>

            <entry>N</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>

            <entry>Y</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <itemizedlist>
      <listitem>
        <para>BC = Backward Compatible with ASF</para>
      </listitem>

      <listitem>
        <para>CS = Concrete Syntax</para>
      </listitem>

      <listitem>
        <para>HT= head/tail matching</para>
      </listitem>

      <listitem>
        <para>LC = List comprehension</para>
      </listitem>

      <listitem>
        <para>LM = List Matching</para>
      </listitem>

      <listitem>
        <para>N = No</para>
      </listitem>

      <listitem>
        <para>PS = Prefic Syntax</para>
      </listitem>

      <listitem>
        <para>SC = Set Comprehension</para>
      </listitem>

      <listitem>
        <para>Y = Yes</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Questions</title>

    <para><itemizedlist>
        <listitem>
          <para>Q1: What about the overlap between sets of tuples and
          relations? We should build relations in for efficiency. Is there
          going to be a type equivalence. Are tuples going to be first class
          datatypes?</para>
        </listitem>

        <listitem>
          <para>Q2: Do we need to introduce the basic datatypes Integer and
          Boolean because sets and relations have typical builtin functions
          for that? Or can we put these things in a library? How about
          Locations? We need to introduce as few builtin syntax as possible to
          prevent ambiguity and confusion... Can we offer efficient relations
          without introducing a dependency on a fixed Integer/Boolean
          syntax??? It would be SIMPLE if only syntax trees are the leafs of
          nested lists/sets/relations/tuples.</para>
        </listitem>

        <listitem>
          <para>Q3: Concrete syntax will introduce problems with the new fixed
          syntax builtin datatypes (prefix functions, lists, sets, relations,
          tuples). Efficiently make a type-checker that can resolve most of
          the ambiguities.</para>
        </listitem>

        <listitem>
          <para>Q4: We should allow (optionally) quoting/escaping concrete
          syntax parts. If Q3 results in error or undecidable disambiguation,
          the user must be able to clarify precisely.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Rascal at a glance</title>

    <para>Rascal can be summarized as follows:</para>

    <itemizedlist>
      <listitem>
        <para>"Syntax modules" are identical to standard SDF modules and
        define concrete syntax.</para>
      </listitem>

      <listitem>
        <para>Ordinary modules define types and functions.</para>
      </listitem>

      <listitem>
        <para>The type system (and notation) are mostly similar to that of
        Rscript, but</para>

        <itemizedlist>
          <listitem>
            <para>Symbols (as defined by a syntax module) are also
            types.</para>
          </listitem>

          <listitem>
            <para>There are built-in types (bool, int str, loc) that have a
            syntactic counterpart (not yet defined how to do this
            exactly).</para>
          </listitem>

          <listitem>
            <para>Relations can have optional column names.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Expressions correspond roughly to Rscript expressions with some
        extensions:</para>

        <itemizedlist>
          <listitem>
            <para>There is a notation of "pattern": a quoted concrete syntax
            fragment that may contain variables and subexpresions to be
            evaluated.</para>
          </listitem>

          <listitem>
            <para>There are lists, sets and relations together with
            comprhensions for these types.</para>
          </listitem>

          <listitem>
            <para>A "select" expression corresponds to the matching provided
            by a set of rewrite rules. However, it provides only matching at
            the top level of its argument.</para>
          </listitem>

          <listitem>
            <para>A "replace" expression corresponds to a traversal function
            (transformer). Given a term and a list of pattern/replacement
            pairs it traverses the term as long as replacements are
            possible.</para>
          </listitem>

          <listitem>
            <para>A "search" expression also corresponds to a traversal
            function. Given a term and a list of patterns, it returns a list
            all subterms that match any of patterns.</para>
          </listitem>

          <listitem>
            <para>Generators in comprehensions may range over syntax
            trees.</para>
          </listitem>

          <listitem>
            <para>Replace, search and generators have a strategy option to
            indicate:</para>

            <itemizedlist>
              <listitem>
                <para>all = continue</para>
              </listitem>

              <listitem>
                <para>first = break</para>
              </listitem>

              <listitem>
                <para>td = top-down</para>
              </listitem>

              <listitem>
                <para>bu = bottom-up</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>A function contains a number of variable declarations followed
        by an expression.</para>
      </listitem>

      <listitem>
        <para>There is a notion of global (dynamically scoped) variables.
        Status not yet clear.</para>
      </listitem>
    </itemizedlist>

    <para>See <xref linkend="Issues" /> for the issues that still have to be
    resolved.</para>
  </section>

  <section>
    <title>Examples</title>

    <para>Here we list experimental examples of Rascal code to try out new and
    old features.</para>

    <section>
      <title>Booleans</title>

      <para>Probably a non-typical example, but let's try it anyway. It looks
      horrible compared to the ASF version but gives an indication how we can
      convert ASF+SDF specifications to Rascal. See <xref
      linkend="section.booleans-with-replace" /> for a much shorter version
      that uses replace.</para>

      <programlisting>syntax module Booleans

exports 
  sorts Bool

  context-free syntax
    "true"        -&gt; Bool
    "false"       -&gt; Bool
    Bool "&amp;" Bool -&gt; Bool {left}
    Bool "|" Bool -&gt; Bool {right}

module Bool-examples
imports Booleans

fun Bool and(Bool B1, B2) { %% reduce &amp; operator
    Bool B;
    select B1 {
      [| true |]  =&gt; reduce(B2)
      [| false |] =&gt; [| false |]
      [| $B |]    =&gt; [| $B1 &amp; $B2 |]
    }    
}

fun Bool or(Bool B1, B2) { %% reduce | operator
    Bool B;
    select B1 {
      [| true  |] =&gt; [| true |]
      [| false |] =&gt; reduce(B2)
      [| $B |]    =&gt; [| $B1 | $B2 |]
    }    
}

fun Bool reduce(Bool B){
    Bool B1, B2, B3;
    select B {
      [| $B1 &amp; $B2 |]  =&gt; and(B1, B2)
      [| $B1 \| $B2 |] =&gt; or(B1, B2)  %% Note: | has to be escaped!
      [| $B3 |]        =&gt; B
    }
}</programlisting>
    </section>

    <section>
      <title>Deep tree matching instead of tree traversal</title>

      <para><programlisting>%% Mark a pure syntax module as such with "syntax"

syntax module Tree-syntax
imports Naturals
exports TREE
  context-free syntax
    NAT             -&gt; TREE
    f(TREE,TREE)    -&gt; TREE
    g(TREE,TREE)    -&gt; TREE
    h(TREE,TREE)    -&gt; TREE
    i(TREE,TREE)    -&gt; TREE

%%--------------------------------

module Tree-Examples
imports Tree-syntax

%% Ex1a: Count leaves in a TREE
%% Idea: NAT N : T generates alle NAT leaves in the tree
%% # is the built-in length-of operator

fun int cnt(TREE T) {
    #{N | NAT N : T}
}

%% Ex1b: an equivalent,  more purist, version of the same function:
fun int cnt(TREE T) {
    #{N | [| $(NAT N) |] : T}
}

%% Ex2: Sum all leaves in a TREE
%% NB sum is a built-in that adds all elements in a set or list.
%% Here we see immediately the need to identify
%% - the built-in sort "int"
%% - the syntactic sort "NAT"

fun int sumtree(TREE T) {
    sum({N | int N : T})
}

%% Ex3: Increment all leaves in a TREE
%% Idea: using the construct "replace T { ... }" all leaves in the 
%% tree T that match an integer and replaces each N in T by N+1.
%% The expression as a whole returns the modified term.
%% This is an extremely compact manner of writing a transformer!
%% Note that two conversions are needed here:
%% - from int to NAT to match subterms
%% - from int to NAT to convert the result of addition into 
%%   a NAT tree

fun TREE inc(TREE T) {
    int N;
    replace T {
      [| $N |] =&gt; [| $(N + 1) |]
    }
}

%% Ex4: full replacement of g by i
%% Question: how about the traversal order?
%% Probable answer: bottom-up and top-down are both ok so it does 
%% not matter in this example.
%% Bottom-up case: g's are replaced by i's.
%% Top-down case: g's are replaced by i's but in the arguments of 
%% the new i-tree g's are later replaced by i's.
%% Question: Is it relevant to fix the traversal order? 
%% The choice should then be bottom-up since top-down can be
%% achieved with recursion (see srepl, below).

fun TREE frepl(TREE T) {
    TREE T1, T2;
    replace T {
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |]
    }
}

%% Ex5a: deep replacement of g by i which usually requires
%% a bottom-up traversal + break;

fun TREE drepl(TREE T) {
    TREE T1, T11, T12, T2, T21, T22;
    replace T { 
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |]
         when not exists [| g($T11, $T12) |] : T1, 
              not exists [| g($T21, $T22)  |]: T2
    }   
}

%% Assume that the traversal is always bottom-up
%% and introduce a "first" directive (= break).
%% Along this line "all" would be the default.

fun TREE drepl(TREE T) {
    TREE T1, T2;
    replace T first {
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |] 
    }
}

%% If we want the whole repertoire of traversal functions
%% can be made available:
%% - replace T first bu { ... }
%% - replace T all td { ... }
%% - etc.
%% A nice touch is that these properties are not tied to the
%% declaration of a travesal function (as in ASF+SDF) but to 
%% its use. The above would become:

fun TREE drepl(TREE T) {
    TREE T1, T2;
    replace T first bu {
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |] 
    }
}

%% Ex6a: shallow replacement of g by i (i.e. only outermost 
%% g's are replaced); Usually done with a top-down traversal.
%% For brevity, we use here a string variable FUN that matches
%% a function symbol: do we want this? It corresponds to a 
%% lexical variable.

fun TREE srepl(TREE T) {
    TREE T1, T2;
    str FUN;
    
    select (T) {
      [| g($T1, $T2) |]    =&gt; [| i($T1, $T2) |]
      [| $FUN($T1, $T2) |] =&gt; [| $FUN($(srepl(T1)) $(srepl(T2))) |]
    }
}

%% Using traversal attributes, one could write this as:

fun TREE srepl(TREE T) {
    TREE T1, T2;
    replace T first td {
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |]
    }
}

%% Continuing this line of thought, we can also add these 
%% directives to all generators (where "all td" would be 
%% the default):

fun set[TREE] find_outer_gs(TREE T) {
    TREE T1, T2;
    { S | first td STATEMENT S : T, [| g($T1, $T2) |] == S }
}

or maybe abbreviated as (eliminating the need for a variable S):

fun set[TREE] find_outer_gs(TREE T) {
    TREE T1, T2;
    search T first td {
      [| g($T1, $T2) |]
    }
}

and similar for inner g's:

fun set[TREE] find_inner_gs(TREE T) {
    TREE T1, T2;
    search T first bu {
      [| g($T1, $T2) |]
    }
}</programlisting></para>
    </section>

    <section xml:id="section.booleans-with-replace">
      <title>Booleans (version2 using replace)</title>

      <para>The earlier definition of Booleans was quite involved. A much
      simpler solution exists using the replace construct that we have
      encountered in the above examples.<programlisting>module Bool-examples2
imports Booleans

fun Bool reduce(Bool B) {
    Bool B1, B2;
    replace B bu {
      [| true &amp; $B2 |]   =&gt; B2
      [| false &amp; $B2 |]  =&gt; [| false |]

      [| true \| $B2 |]  =&gt; [| true |]
      [| false \| $B2 |] =&gt; B2
    }
}</programlisting></para>
    </section>

    <section>
      <title>Dot Product</title>

      <para>[Example taken from TXL documentation]</para>

      <programlisting>syntax module Vectors
sorts Vector

context-free syntax
   "(" NAT* ")"      -&gt; Vector

   Vector "." Vector -&gt; NAT %% innerproduct, e.g. (1 2 3).(3 2 1)  =&gt;  10

module Innerproduct

imports Vectors

fun int innerProduct(Vector V1, V2){
    NAT N1, N2;
    NAT* Rest1, Rest2;

    if [| ($N1 $Rest1) |] := V1 &amp; 
       [| ($N2 $Rest2) |] := 2 
    then
       (N1*N2) + innerProduct([| ($Rest1) |], [| ($Rest2) |])
    else 
       0
    fi
}</programlisting>
    </section>

    <section>
      <title>Bubble sort</title>

      <para>[Example taken from XL documentation]</para>

      <programlisting>module Bubble

fun NAT* sort(NAT* Numbers){
    NAT N1, N2;
    NAT* Rest1, Rest2;
    replace Numbers {
      [| $Rest1 $N1 $N2 $Rest2 |] =&gt; [| $Rest1 $N2 $N1 $Rest2 |]
      when N1 &gt; N2
    }
}</programlisting>

      <para>Are $Rest1 and $Rest2 needed? Would</para>

      <programlisting>    replace Numbers {
      [| $N1 $N2 |] =&gt; [| $N2 $N1 |]
      when N1 &gt; N2
    }</programlisting>

      <para>be ok?</para>
    </section>

    <section>
      <title>Generic Bubble sort</title>

      <para>Here is a generic bubble sort wich uses type parameters
      (&amp;ELEM) and a function parameter.<programlisting>module Bubble

fun &amp;ELEM* sort(&amp;ELEM* Elements, fun bool GreaterThan(&amp;ELEM, &amp;ELEM)){
    &amp;ELEM E1, NE2;
    &amp;ELEM* Rest1, Rest2;
    replace Elements {
      [| $Rest1 $E1 $E2 $Rest2 |] =&gt; [| $Rest1 $E2 $E1 $Rest2 |]
      when GreaterThan(E1, E2)
    }
}</programlisting>Do we want this generality? What are the implications for
      the implementation?</para>
    </section>

    <section>
      <title>Lambda Substitution</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.<programlisting>syntax module Lambda

sorts Var %% variables
      Exp %% expressions

context-free functions
     "prime" "(" Var ")"  -&gt; Var  %% generate unique name
     Var                  -&gt; Exp  %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp  %% function abstraction
     Exp Exp              -&gt; Exp  %% function application

%%------------------------------

module Lambda-Examples
imports Lambda

fun set[Var] allVars(Exp E) {
    {V | Var V : E}
}

fun set[Var] boundVars(Exp E) {
    {V | [| fn $(Var V) =&gt; $(Exp E1) |] : E}
}

fun set[Var] freeVars(Exp E) {
    allVars(E) \ boundVars(E)
}

%% Generate a fresh variable if V does not occur in 
%% given set of variables.

fun Var fresh(Var V, set[Var] S) {
    if V in S then prime(V) else V fi
}

%% Substitution: replace all occurrences of V in E2 by E1

fun Exp subst(Var V1, Exp E1, Exp E2) {
    Var V2;
    Exp Ea, Eb;

    select E2 {
      [| $V2 |] =&gt; V2
         when V1 != V2

      [| $V2 |] =&gt; E1
         when V1 == V2 

      [| $Ea $Eb |]  =&gt; [| $(subst(V, E, Ea)) $(subst(V, E, Eb)) |]

      [| fn $V2 =&gt; $Ea |] =&gt;  [| fn $V2 =&gt; $Ea |]
         when V1 == V2

      [| fn $V2 =&gt; $Ea |] =&gt; [| fn $V2 =&gt; $(subst(V1, E1, Ea)) |]
         when V1 != V2,
              not(V1 in freeVars(E2) &amp; V2 in freeVars(E1))

      [| fn $V2 =&gt; $Ea |] =&gt; 
      [| fn $V3 =&gt; $(subst(V1, E1, subst(V2, V3, E2))) |]
         when V1 != V2,
              V1 in freeVars(Ea) &amp; V2 in freeVars(E1),
              V3 := fresh(V2,  freeVars(Ea) union freeVars(E1))
    }
}</programlisting></para>
    </section>

    <section>
      <title>Renaming</title>

      <para><programlisting>syntax module Let
sorts Var %% variables
      Exp %% expressions
context-free functions
     
     Var                             -&gt; Exp %% single variable
     
     "let" Var "=" Exp "in Exp "end" -&gt; Exp %% function abstraction
%%------------------------------------------

module Let-Example
import Let

%% Rename all bound variables in an Exp
%% Version 1: purely functional
%% Exp: given expression to be renamed
%% rel[Var,Var]: renaming table
%% Int: counter to generate global variables

fun Exp rename(Exp E, rel[Var,Var] Rn, Int Cnt) {
    int Cnt1;
    Var V, Y;
    Exp E1, E2;

    select(E) {
    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $(rename(E1, Rn, Cnt)) 
              in 
                 $(rename(E2, {&lt;V, Y&gt;} union Rn, Cnt1)) 
              end 
           |]
        when Y := "x" + Cnt,   %% this + operator concatenates 
                               %% (after converting the int to str)
             Cnt1 := Cnt + 1

    [| $V' |] =&gt; V1
       when { V1 } == Rn[V]

    [| $E' |] =&gt; E
    }
}

%% Rename all bound variables in an Exp
%% Version 2: using a global variable
%% to generate new variables

fun Var newVar() {
    global int Cnt := 0   %% Initialize global Cnt on first call 
                          %% of newVar. This is similar to a 
                          %% local static var in C.
    Cnt := Cnt + 1;
    "x" + Cnt
}       

%% Rename -- Version 2

fun Exp rename(Exp E, rel[Var,Var] Rn) {
    Var V, Y;

    select (E) {

    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $(rename(E1, Rn)) 
              in 
                $(rename(E2, {&lt;V, Y&gt;} union Rn)) 
              end
           |]
       when Y := newVar()

    [| $V |] =&gt; V1
       when { V1 } == Rn[V]
  
    [| $E |] =&gt; E
    }
}

%% Rename -- Version 3, with Rn also as global variabele

fun Var newVar() {
    global int Cnt := 0   
    Cnt := Cnt + 1;
    "x" + Cnt
}       

fun Exp rename(Exp E) {
    global rel[Var, Var] Rn := {}
    Var V, Y;
 
    select (E){
    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $rename(E1) 
              in 
                 $rename(E2) 
              end
           |]
       when Y := newVar,
            Rn :=  {&lt;V, Y&gt;} union Rn
              
    [| $V |] =&gt; V1
       when { V1 } == Rn[V]
 
    [| $E |] = E
    }
}

%% Question: how to reset the value of global variables?
%% Idea: model them as arguments:
%% - fun Var newVar(global int Cnt := 0) { ... }
%% and allow calls without arguments (as in above example) or
%% with arguments:
%% - newVar(13)
%% which resets the value of Cnt.</programlisting></para>
    </section>

    <section>
      <title>Concise Pico Typechecker</title>

      <para>The following example shows the tight integration ASF with
      comprehensions.</para>

      <programlisting>module Typecheck

imports Pico-syntax
imports Errors

type Env = rel[PICO-ID,TYPE]

var
    DECLS Decls;
    {STATEMENT ";"}* Series;
    Id Id;
    TYPE Type;
    Env Env;

fun list[Error] tcp(PROGRAM P) {
    select P {
    [| begin $Decls $Series end |] =&gt;
           [ tcst(S, Env) | Stat S : Series ] %% list comprehension
       when Env := {&lt;Id, Type&gt; | 
                    [| $(PICO-ID Id) : $(TYPE Type) |] : Decls}
    }
}

fun list[Error] tcst(Stat Stat, Env Env) {
    select Stat {
    [| $Id := $Exp |] =&gt; type-of(Exp, Type, Env)
       when {&lt;Id,Type&gt;} := Env[Id]

    [| if $Exp then $Stats1 else $Stats2 fi |] =&gt;
           type-of(Exp, natural, Env) + 
           tcs(Stats1, Env) + tcs(Stats2, Env)

    [| while $Exp do $Stats od |] =&gt;
           type-of(Exp, natural, Env) + tcs(Stats, Env)
    }
}

fun list[Error] type-of(Exp E, TYPE Type, Env Env) {
    NatCon NatCon;
    StrCon StrCon;
    Id Id;
    Exp Exp;

    select E {
    [| $NatCon |] =&gt; []
       when Type == natural

    [| $StrCon |] =&gt; []
       when Type == string

    [| $Id |] =&gt; [] 
       when {&lt;Id,Type2&gt;} := Env[Id],
            Type2 == Type
            
    [| $Exp |] =&gt; [error("Incorrect type")]
    }
}

%% Discussion: it may be interesting to generalize select to allow 
%% multiple arguments:
   select (E, Type) {
    [| $NatCon |], [| natural |] =&gt; []

    [| $StrCon |], [| string |] =&gt; []

    [| $Id |], Type =&gt; [] 
       when {&lt;Id,Type2&gt;} := Env[Id],
            Type2 == Type
            
    [| $Exp |], Type =&gt; [error("Incorrect type")]
    }
%% Even patterns and expressions could be allowed as cases.</programlisting>
    </section>

    <section>
      <title>Generating Dot files</title>

      <para>This example illustrates the use of a comprehension on the
      right-hand side of an equation.<programlisting>module Dot-generation

imports Dot-syntax

fun Dot gen-dot(rel[ID, ID] Rel) {
    [| digraph example {
                        $([ node(Tup) | &lt;ID,ID&gt; Tup : Rel ])
                       }
    |]
}

fun DotElem* gen-node(&lt;ID Id1, ID Id2&gt;) {
    [| node $Id1; node $Id2; $Id1 -&gt; $Id2 |}}
}</programlisting></para>
    </section>

    <section>
      <title>Pico Typecheck using dynamically scoped variables</title>

      <para>The following example details the use of a dynscope global
      variable for building up and using an environment. Notice that we
      introduce <emphasis>void</emphasis> functions as a
      result.<programlisting>module Typecheck

imports Pico-syntax

hiddens

type Env = rel[PICO-ID,TYPE]

exports

fun Bool tc(PROGRAM P) {
    dyn Env Env := {};
    select P {
      [| begin $Decls $Stats end |] =&gt; tcs(Stats)
         when Env := tcd(Decls)
    }
}

fun Env tcd(Decls Decls) {
    {&lt; Id, Type&gt; | [| $(PICO-ID Id) : $(TYPE Type) |] : Decls}
}

fun Bool tcs(Stats Stats) {
    Stat Stat;
    Stats Stats;
    select (Stats) {
    [| |]                =&gt; true

    [| $Stat ; $Stats |] =&gt; tcst(Stat) + tcst(Stats)
    }
}

fun Bool tcst(Stat Stat) {
    Id Id;
    Exp Exp;
    Stats Stats, Stats1, Stats2;
    select (Stat) {
      [| $Id := $Exp |] =&gt; type-of(Exp, Type)
         when {&lt;Id, Type&gt;} := Env[Id]

      [| if $Exp then $Stats1 else $Stats2y fi |] =&gt;
         type-of(Exp, natural) + tcs(Stats1) + tcs(Stats2)

      [| while $Exp do $Stats od |] =&gt;
         type-of(Exp, natural) + tcs(Stats)
    }
}

fun list[Error] type-of(Exp E, TYPE Type) {
    NatCon NatCon;
    StrCon StrCon;
    Id Id;
    Exp Exp;

    select (E) {
      [| $NatCon |] =&gt; []
         when Type == natural

      [| $StrCon |] =&gt; []
         when Type == string

      [| $Id |] =&gt; [] 
         when {&lt;Id,Type2&gt;} := Env[Id],
              Type2 == Type
            
      [| $Exp |] =&gt; [error("Incorrect type")]
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico eval with dynamically scoped variables</title>

      <para>A Pico evaluator using dynamic variables. It still uses functions
      that return VEnvs (this is not consistent and should be changed).</para>

      <programlisting>fun VEnv evalProgram(Program p) {
    dyn VEnv venv;
    Decls decls;
    Series series;

    select p {
      [| begin $decls $series end |] =&gt; evalStatements(series)
         when venv := evalDecls(decls);
    }
}

fun VEnv evalDecls(Decls decls) {
    Id-Type* idtypes;
    select decls {
      [| declare $idtypes |] =&gt; evalIdTypes(idtypes)
    }
}

fun VEnv evalIdTypes(Id-Type* idtypes) {
    Id id;
    Id-Type* tail;
    select idtypes { 
      [| $id : natural, $tail |] =&gt; store(evalIdTypes(tail),id,0)
  
      [| $id : string, $ tail |] =&gt; store(evalIdTypes(tail),id,"")

      [| |] =&gt; []
    }
}

fun VEnv evalStatements(Statement* series) {
    Statement stat; Statement* stats;
    select series  {
      [| $stat; $stats |] =&gt; venv
         when venv := evalStatement(stat),
              venv := evalStatements(stats)
      [| |] =&gt; venv
    }
}

fun VEnv evalStatement(Statement stat) {
    Exp exp;
    Series series, series1, series2;
    
    select stat {    
      [| if $exp then $series1 else $series2 fi |] =&gt; 
         evalStatements(series1)
         when evalExp(exp, venv) != 0

      [| if $exp then $series1 else $series2 fi |] =&gt; 
         evalStatements(series2)
         when evalExp(exp, venv) == 0
        
      [| while $exp do $series od |] =&gt; venv
         when evalExp(exp, venv) == 0

      
      [| while $exp do $series od |] =&gt; 
         evalStatement([|while $exp do $series od |])
         when evalExp(exp, venv) != 0,
              venv := evalStatements(series)
    }
}

fun VEnv evalExp(Exp exp) {
    Exp exp1, exp2;
    Natural nat1, nat2;
    StrCon str1, str2, str3;

    select exp {
      [| $exp1 + $exp2 |] =&gt; nat1 + nat2
         when nat1 := eve(exp1),
              nat2 := eve(exp2)
       
      [| $exp1 - $exp2 |] =&gt; nat1 -/ nat2
         when nat1 := eve(exp1),
              nat2 := eve(exp2)
        
        
      [| $exp1 \|\| $exp2 |] =&gt; str3
         when str1 := eve(exp1),
              str2 := eve(exp2),
              str3 := concat(str1, str2)

      [| $exp1 |] =&gt; nil-value     %% default "equation"
   }
}</programlisting>
    </section>

    <section>
      <title>Pico control flow extraction</title>

      <programlisting>module Pico-controlflow
imports pico/syntax/Pico

type CP = EXP | STATEMENT;     %% A Code Point, union of two types

type cf_segment &lt; set[CP] entry, rel[CP,CP] graph, set[CP] exit&gt;;

fun cf_segment cflow({STATEMENT ";"}* Stats){
    Stat Stat;
    Stat+ Stats2;
    rel[CP,CP] R1, R2;
    set[CP] En1, En2, Ex1, Ex2;
    
    select Stats {
      [| Stat ; $Stats2 |] =&gt;
             &lt;En1, R1 union R2 union (Ex1 x En2), Ex2&gt;
         when &lt;En1, R1, Ex1&gt; := cflow(Stat),
              &lt;En2, R2, Ex2&gt; := cflow(Stats2)

      [| |] =&gt; &lt;{}, {}, {}&gt;
    }
}

fun cf_segment cflow(STATEMENT Stat){
    Exp Exp;
    Stat* Stats, Stats1, Stats2;
    rel[CP,CP] R1, R2;
    set[CP] En1, En2, Ex1, Ex2;

    select Stat {
      [| while $Exp do $Stats od |] =&gt;
             &lt;{Exp}, ({Exp} x En) union R union (Ex x {Exp}),{Exp}&gt;
         when &lt;En, R, Ex&gt; := cflow(Stats)
                
      [| if $Exp then $Stats1 else $Stats2 fi |] =&gt;
             &lt; {Exp}, 
               ({Exp} x En1) union ({Exp} x En2) union R1 union R2,
                Ex1 union Ex2
             &gt;
         when &lt;En1, R1, Ex1&gt; := cflow(Stats1),
              &lt;En2, R2, Ex2&gt; := cflow(Stats2)
           
      [| $Stat |]  =&gt; &lt;{Stat}, {}, {Stat}&gt;
    }
}</programlisting>
    </section>

    <section>
      <title>Pico use def extraction</title>

      <programlisting>module Pico-use-def

imports pico/syntax/Pico

fun rel[EXP,PICO-ID] uses(PROGRAM P) {
  {&lt;E,Id&gt; | EXP E : P, [| $(PICO-ID Id) |] == E}
}

fun rel[STATEMENT, PICO-ID] defs(PROGRAM P) { 
  {&lt;S, Id&gt; | STATEMENT S : P, 
                        [| $(PICO-ID Id) := $(EXP Exp) |] == S}
}</programlisting>

      <para>The above uses a "matching condition" to decompose
      <literal>S</literal>. The problem solved is that we want to have a name
      for the whole assignment <emphasis>and</emphasis> for the lhs
      identifier.</para>
    </section>

    <section>
      <title>Pico uninitialized variables</title>

      <para><programlisting>module Pico-uninit
imports pico/syntax/Pico Pico-controlflow Pico-use-def

fun set[PICO-ID] uninit(PROGRAM P) {
    rel[EXP,PICO-ID] Uses := uses(P);
    rel[STATEMENT, PICO-ID] Defs := defs(P);
    cf_segment CFLOW := cflow(P);
    set[CP] Root := CFLOW.entry;
    rel[CP,CP] Pred := CFLOW.graph;

    {Id | &lt;EXP E, PICO-ID Id&gt; : Uses,
                 E in reachX(Root, Defs[-,Id], Pred)
    }
}</programlisting>Questions (UPDATE THIS):</para>

      <itemizedlist>
        <listitem>
          <para>There is, maybe, a typing issue here. De type of
          <literal>reachX</literal> is:</para>

          <para><literal>set[&amp;T] reachX(set[&amp;T]
          Start,</literal></para>

          <para><literal> set[&amp;T] Excl, </literal></para>

          <para><literal> rel[&amp;T,&amp;T] Rel)</literal></para>

          <para>but <literal>E</literal> has type <literal>EXP</literal>,
          <literal>{ROOT}</literal> has type
          <literal>set[STATEMENT]</literal>, and <literal>cflow</literal> has
          type <literal>rel[CP,CP]</literal>, with <literal>EXP | STATEMENT
          -&gt; CP</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico common subsexpression elimination</title>

      <para><programlisting>module Pico-common-subexpression

fun PROGRAM cse(PROGRAM P) {
    rel[STATEMENT, PICO-ID] Defs := defs(P);
    rel[CP,CP] Pred := cflow(P).graph
    rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | STATEMENT S : P,
                   [| $(PICO-ID Id) := $(EXP E) |] == S,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[-,Id], Pred)
       };
 
    replace P {
      [| E |] =&gt; Id
         when { Id } := replacements[E]   
    }
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions E2 by Id, such
      that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>Id does not occur in E,</para>
        </listitem>

        <listitem>
          <para>E2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and E2.</para>
        </listitem>
      </itemizedlist>

      <para>Note that a slight abbreviation is possible if we introduce
      labelled patterns (here S):</para>

      <programlisting> rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | [| $(PICO-ID Id) := $(EXP E) |] S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[-,Id], Pred)
       };</programlisting>

      <para>Also note that we could factor out the assignment pattern to make
      cse more generic if we introduce patterns a sfirst class
      citizens:</para>

      <programlisting>fun PROGRAM cse(PROGRAM P, pat STATEMENT Assign(PICO-ID Id, EXP E)) {
 ...
    rel[EXP, PICO-ID] replacements := 
       {&lt;E2, Id&gt; | Assign S : P,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[-,Id], Pred)
       };
 
 ...
}</programlisting>

      <para>Example invocations:</para>

      <programlisting>cse(P, [| $(PICO-ID Id) := $(EXP E) |])</programlisting>

      <para>or</para>

      <programlisting>cse(P, [| move $(EXP E) to $(PICO-ID Id) |])</programlisting>

      <para>Note that the order of variables in the pattern and its
      declaration may differ.</para>

      <para>It is to be determined how the instantiation of a pattern looks,
      e.g.</para>

      <programlisting>Assign([|x|], [| y = 1 |])</programlisting>
    </section>

    <section>
      <title>Pico constant propagation</title>

      <para><programlisting>module Pico-constant-propagation

fun Boolean is-constant(EXP E) {
   Int Int;
   Str Str;
   select (E){
     [| $Int |] =&gt; true

     [| $Str |] =&gt; true

     [| $E |] =&gt; false
   }
}

fun PROGRAM cp(PROGRAM P) {
    rel[STATEMENT, PICO-ID] Defs := defs(P);
    rel[CP,CP] Pred := cflow(P).graph;
    PICO-ID Id, Id1, Id2;

    rel[PICO-ID, EXP] replacements := 
      {&lt;Id2, E&gt; | STATEMENT S : P,
                  [| $(PICO-ID Id) := $(EXP E) |] == S,
                  is-constant(E),
                  PICO-ID Id2 : reachX({S},Defs[-,Id],Pred),
                  Id2 == Id 
      };  
 
    replace P {
     [| $Id |] =&gt; E
        when { E } := replacements[Id]
    }  
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions Id2 by the constant E,
      such that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>E is constant,</para>
        </listitem>

        <listitem>
          <para>Id2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>Id2 is equal to Id,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and Id2.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Syntax Definition</title>

    <para>See separate SDF definition.</para>
  </section>

  <section xml:id="section.integration-tscript">
    <title>Integration with Tscripts (Outdated)</title>

    <note>
      <para>It is not yet clear whether we will also include Tscript in the
      integration effort. For the time being, this section is considered
      outdated.</para>
    </note>

    <section>
      <title>Introduction</title>

      <para>It is possible to speculate on an even further integration of
      formalisms and combining the above amalgan of ASF+SDF and Rscript with
      Tscripts.</para>
    </section>

    <section>
      <title>Requirements</title>

      <itemizedlist>
        <listitem>
          <para>R12: The resulting language uses a single type system. This
          means that relational types (possible including syntactic objects)
          can be used in Tscripts.</para>
        </listitem>

        <listitem>
          <para>R13: The current "expressions" in Tscript (terms that occur at
          the rhs of an assignment) are replaced by calls to ASF+SDF or
          Rscript functions.</para>
        </listitem>

        <listitem>
          <para>R14: There is minimal duplication in functionality between
          ASF+SDF/Rscript/Tscript.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Different styles of Type Declarations</title>

      <para>We have at the moment, unfortunately, a proliferation of
      declaration styles for types.</para>

      <para>Functions are declared in ASF+SDF as:</para>

      <programlisting>typecheck(PROGRAM) -&gt; Boolean</programlisting>

      <para>Observe that only the type of the parameter is given but that it
      does not have a name.</para>

      <para>In Rscript we have:</para>

      <programlisting>int sum(set[int] SI) = ...</programlisting>

      <para>while in Tscript processes are declared as</para>

      <programlisting>process mkWave(N : int) is ...</programlisting>

      <para>For variables a similar story applies. Variables are declared in
      ASF+SDF as:</para>

      <programlisting>"X" [0-9]+    -&gt; INT</programlisting>

      <para>In Rscript we have:</para>

      <programlisting>int X

int X : S   (in comprehensions)</programlisting>

      <para>and in Tscript we have:</para>

      <programlisting>X : int</programlisting>

      <para>In order to unify these styles, we might do the following:</para>

      <itemizedlist>
        <listitem>
          <para>The type of an entity is always written before the entity
          itself.</para>
        </listitem>

        <listitem>
          <para>Formal parameters have a name.</para>
        </listitem>
      </itemizedlist>

      <para>In essence, this amounts to using the declaration style as used in
      Rscript. So we get:</para>

      <programlisting>Boolean typecheck(PROGRAM P) is ...

process mkWave(int N) is ...</programlisting>

      <para>Or do we want things like:</para>

      <programlisting>function typecheck(P : PROGRAM) -&gt; Boolean is ...

var X -&gt; int

process mkWave(int N) is ...</programlisting>

      <para>Advantages are:</para>

      <itemizedlist>
        <listitem>
          <para>The category of the entity is immediately clear (function,
          var, process, tool, ...).</para>
        </listitem>

        <listitem>
          <para>It is readable to further qualify the category, i.e.,
          traversal function, hidden var, restartable tool)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Global Flow of Control</title>

      <para>We have to settle the possible flow of control between the three
      entities ASF+SDF, Rscript and Tscript. Since Tscript imposes the notion
      of an atomic action it would be problematic to have completely
      unrestricted flow of control. Therefore it is logical to use Tscript for
      the top-level control and to limit the use of ASF+SDF and Rscript to
      computations within atomic actions. There is no reason to restrict the
      flow of control between ASF+SDF and Rscript.</para>

      <para>What are the consequences of the above choice? Let's analyze two
      cases:</para>

      <itemizedlist>
        <listitem>
          <para>Parse a file from within an ASF+SDF specification. This (and
          similar built-ins) that use the operating system are removed from
          ASF+SDF. Their effect has to be achieved at the Tscript-level which
          is the natural place for such primitives.</para>
        </listitem>

        <listitem>
          <para>Describe I/O for a defined language. Consider Pico extended
          with a read statement. Here the situation is more complicated. We
          cannot argue that the flow of control in the Pico program (as
          determined by an interpreter written in ASF+SDF) should be moved to
          the Tscript level since Tscript simply does not have the primitives
          to express this. On the other hand, we have to interrupt the flow of
          control of the Pico interpreter when we need to execute a read
          statement. The obvious way to achieve this is</para>

          <itemizedlist>
            <listitem>
              <para>At the Tscript level, a loop repeatedly calls the Pico
              interpreter until it is done.</para>
            </listitem>

            <listitem>
              <para>After each call the Pico interpreter returns with
              either:</para>

              <itemizedlist>
                <listitem>
                  <para>An indication that the eecution is complete (and
                  possibly a final state and/or final value).</para>
                </listitem>

                <listitem>
                  <para>An indication that an external action has to be
                  executed, for instance the read statement. This indication
                  should also contain the intermediate state of the
                  interpreter. When the external action has been executed, the
                  Pico interpreter can be restarted with as arguments the
                  value of the external action and the intermediate
                  state.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Experimentation will have to show whether such a framework is
      acceptable.</para>
    </section>

    <section>
      <title>Modularization</title>

      <para>Rscript and Tscript have no, respectively, very limited mechanisms
      for modularization. ASF+SDF, however, provides a module mechanism with
      imports, hiding, parameters and renaming. This mechanism was originally
      included in ASF, was taken over by SDF and is now reused in ASF+SDF.
      Currently, there are not yet sufficiently large Rscripts to feel the
      need for modules. In Tscript, there is a strong need for restricted name
      spaces and for imposing limitations on name visibility in order to limit
      the possible interactions of a process with its surroundings and to make
      it possible to create nested process definitions. What are the design
      options we have to explore?</para>

      <para>First, we can design a new module system that is more suited for
      our current requirements. The advantage is that we can create an optimal
      solution, the disadvantage is that there are high costs involved
      regarding implementation effort and migrations of existing ASF+SDF
      specifications to the new module scheme.</para>

      <para>Second, we can design an add-on to the ASF+SDF module system that
      addresses our current needs.</para>

      <para>Third, we can try to reuse the current ASF+SDF module
      system.</para>

      <para>As a general note, parameterized modules, polymorphics types and
      renamings are competing features. We should understand what we want. It
      is likely that we do not need all of them.</para>

      <para>Before delving into one of the above alternative approaches, let's
      list our requirements first.</para>

      <itemizedlist>
        <listitem>
          <para>We need grammar modules that allow the following operations:
          import, renaming, deletion (currently not supported but important to
          have a fixed base grammar on many variations on it).
          Parameterization and export/hidden: unclear.</para>
        </listitem>

        <listitem>
          <para>We need function modules (ASF+SDF and Rscript) that provide:
          import, maybe parametrization, and export/hidden.</para>
        </listitem>

        <listitem>
          <para>We need process modules (Tscript) that provide: import,
          export, hiding.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Protyping/implementation of Rascal</title>

    <para>Every prototype will have to address the following issues:</para>

    <itemizedlist>
      <listitem>
        <para>Parsing/typechecking/evaluating Rascal.</para>
      </listitem>

      <listitem>
        <para>How to implement the relational operations.</para>
      </listitem>

      <listitem>
        <para>How to implement matching.</para>
      </listitem>

      <listitem>
        <para>How to implement replacement.</para>
      </listitem>

      <listitem>
        <para>How to implement traversals.</para>
      </listitem>
    </itemizedlist>

    <para>The following options should be considered:</para>

    <itemizedlist>
      <listitem>
        <para>Implementation of a typechecker in ASF+SDF:</para>

        <itemizedlist>
          <listitem>
            <para>Gives good insight in the type system and is comparable in
            complexity to the Rscript typechecker.</para>
          </listitem>

          <listitem>
            <para>Work: 2 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            ASF+SDF.</para>
          </listitem>

          <listitem>
            <para>Bound to be very slow.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of a typechecker in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Interesting exercise to asses Rascal.</para>
          </listitem>

          <listitem>
            <para>Not so easy to do without working Rascal
            implementation.</para>
          </listitem>

          <listitem>
            <para>Not so easy when Rascal is still in flux.</para>
          </listitem>

          <listitem>
            <para>Effort: 1 week</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an evaluator in Rascal.</para>

        <itemizedlist>
          <listitem>
            <para>Ditto.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Extending the current ASF+SDF interpreter.</para>

        <itemizedlist>
          <listitem>
            <para>This is a viable options. It requires extensions of
            AsFix.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Translation of Rascal to ASF+SDF in ASF+SDF.</para>

        <itemizedlist>
          <listitem>
            <para>Unclear whether this has longer term merit.</para>
          </listitem>

          <listitem>
            <para>Allows easy experimentation and reuse of current ASF+SDF
            implementation.</para>
          </listitem>

          <listitem>
            <para>Effort: 4 weeks</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Implementation of an interpreter in Java.</para>

        <itemizedlist>
          <listitem>
            <para>A future proof and efficient solution.</para>
          </listitem>

          <listitem>
            <para>Requires reimplementation of matching &amp; rewriting in
            Java.</para>
          </listitem>

          <listitem>
            <para>Effort: 8 weeks.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title xml:id="Issues">Issues</title>

    <itemizedlist>
      <listitem>
        <para>How will we quote patterns and terms? Currently we use the
        convention:</para>

        <itemizedlist>
          <listitem>
            <para>Pattern is enclosed between [| and |]</para>
          </listitem>

          <listitem>
            <para>Variables are prefixed with $</para>
          </listitem>

          <listitem>
            <para>A declared variable is written as $(Type Var).</para>
          </listitem>

          <listitem>
            <para>An expression <replaceable>E</replaceable> to be computed
            and inserted is written as $(<replaceable>E</replaceable>).</para>
          </listitem>

          <listitem>
            <para>Examples:</para>

            <itemizedlist>
              <listitem>
                <para><programlisting>[| while $Exp do $Stats od |]</programlisting></para>
              </listitem>

              <listitem>
                <para><programlisting>{&lt;S, Id&gt; | STATEMENT S : P, 
           [| $(PICO-ID Id) := $(EXP Exp) |] == S}</programlisting></para>
              </listitem>

              <listitem>
                <para><programlisting>[| let $Y = $(rename(E1)) in $(rename(E2)) end |]</programlisting></para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>This is good for disambiguation but gives notational overhead.
        Is there a more concise scheme?</para>
      </listitem>

      <listitem>
        <para>More questions about patterns:</para>

        <itemizedlist>
          <listitem>
            <para>Do we want the subexpressions in patterns?</para>
          </listitem>

          <listitem>
            <para>Should "patterns" be first-class citizens that can be used
            as values?</para>
          </listitem>

          <listitem>
            <para>Do we want string variables in patterns?</para>
          </listitem>

          <listitem>
            <para>Do we want to add regular expression matching primitives to
            patterns? Ex.</para>

            <itemizedlist>
              <listitem>
                <para><programlisting>[| if @any@ $Stats fi |]</programlisting></para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Dynamic variables need more thought; do we want them?</para>
      </listitem>

      <listitem>
        <para>The relation (no pun intended) between local variable
        declarations in functions, patterns and comprehensions has to be
        established.</para>
      </listitem>

      <listitem>
        <para>Do we add column names in relations (as Jurgen and Bob are
        currently doing)? Currently both are supported.</para>
      </listitem>

      <listitem>
        <para>We keep the polymorphic types &amp;T1 as in Rscript.</para>
      </listitem>

      <listitem>
        <para>How does list matching fit in? Probably no problem, see above
        examples.</para>
      </listitem>

      <listitem>
        <para>How do we identify built-in sorts (bool, int, etc) with their
        syntactic counterparts?</para>
      </listitem>

      <listitem>
        <para>What happens if no case in a select matches? Some kind of
        failure? How does it propagate? Runtime error?</para>
      </listitem>

      <listitem>
        <para>In a list comprehension: do list values splice into the list
        result?</para>
      </listitem>

      <listitem>
        <para>Ditto for set comprehensions.</para>
      </listitem>

      <listitem>
        <para>Unexplored idea: add (possibly lazy) generators for all types;
        this allows to generate, for instance, all statements in a
        program.</para>
      </listitem>

      <listitem>
        <para>The "equations" from Rscript are not yet included.</para>
      </listitem>

      <listitem>
        <para>Should "functions" be first-class citizens that can be used as
        values?</para>
      </listitem>

      <listitem>
        <para>Shopping list of ideas in Tom:</para>

        <itemizedlist>
          <listitem>
            <para>Named patterns to avoid building a term, i.e. w@[| while
            $Exp do $stat od |].</para>
          </listitem>

          <listitem>
            <para>Anti-patterns, i.e. the complement of a patterns: ! [| while
            $Exp do $stat od |] matches anything but a while.</para>
          </listitem>

          <listitem>
            <para>Anonymous variables a la Prolog: [| while $_ do $stat od
            |].</para>
          </listitem>

          <listitem>
            <para>String matching in patterns.</para>
          </listitem>

          <listitem>
            <para>Tom uses the notation %[ ... ]% for quoted strings with
            embedded @...@ constructs that are evaluated. It also has a
            backquote construct.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Shopping list of ideas from TXL:</para>

        <itemizedlist>
          <listitem>
            <para>"redefine" allows modification of an imported
            grammar.</para>
          </listitem>

          <listitem>
            <para>An "any" sort that matches anything.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>
</article>