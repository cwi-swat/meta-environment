<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<article>
  <title>Rascal Requirements and Design Document</title>

  <authorblurb>
    <para><authorinitials>Paul</authorinitials> <authorinitials>Klint, Tijs
    van der Storm, and Jurgen Vinju</authorinitials>,</para>

    <para><orgname>Centrum voor Wiskunde en Informatica</orgname>, <address>Amsterdam, The Netherlands</address><mediaobject>
        <imageobject>
          <imagedata fileref="../../logos/cwi.gif" />
        </imageobject>
      </mediaobject></para>
  </authorblurb>

  <section>
    <title>Introduction</title>

    <para>Rascal is the working name for a new version of the Algebraic
    Specification Formalism, which will be extended with an efficient built-in
    set and relation data-type. This basically means that we include most
    features of the RScript language into ASF. The goals of this language
    are:</para>

    <itemizedlist>
      <listitem>
        <para>Easy syntax-directed analysis of programming languages</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation</para>
      </listitem>

      <listitem>
        <para>Efficient</para>
      </listitem>
    </itemizedlist>

    <para>The above goals are all but one already met in the current design of
    ASF, and the current design of RScript. What is missing is the
    <emphasis>connection.</emphasis> Alas, any bridge between the two
    languages is both complex to manage and an efficiency bottleneck. This
    work is an attempt to consolidate this engineering trade-off.</para>

    <para>In section Integration with Tscripts we will also explore the issues
    when we take integration one step further and also include Tscripts in the
    considerations.</para>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Backward compatible with ASF</para>
        </listitem>

        <listitem>
          <para>R3: Compilation speed: parsetable generation is a major
          bottleneck in current ASF. This needs to be fixed.</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability</para>
        </listitem>

        <listitem>
          <para>R5: functional (no side-effects)</para>
        </listitem>

        <listitem>
          <para>R6: file I/O (contradicts R5)</para>
        </listitem>

        <listitem>
          <para>R7: Easily accessible fact storage (similar to a heap, but
          remember R5 and the details of backtracking)</para>
        </listitem>

        <listitem>
          <para>R8: List matching (because of R2, influences R7)</para>
        </listitem>

        <listitem>
          <para>R9: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as
          scoping)</para>
        </listitem>

        <listitem>
          <para>R10: Syntax trees can be elements of the builtin
          data-structures (but not vice versa)</para>
        </listitem>

        <listitem>
          <para>R11: Features are orthogonal: try to keep the number of ways
          to write down a program minimal</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Mapping features to datatypes</title>

    <para>Emphasized cells indicate a new datatype/feature combination that
    needs to be thought out.</para>

    <informaltable border="1">
      <tr>
        <th>Which features work on which datatypes?</th>

        <th>Context-free syntax trees</th>

        <th>Context-free syntax lists</th>

        <th>Lexical syntax trees</th>

        <th>Lexical syntax lists</th>

        <th>Lists</th>

        <th>Sets</th>

        <th>Relations</th>

        <th>Tuples</th>
      </tr>

      <tr>
        <th>Pattern matching</th>

        <td>Yes, Concrete syntax</td>

        <td>Yes, Concrete syntax, List matching</td>

        <td>Yes, prefix syntax</td>

        <td>Yes, Prefix syntax, List matching</td>

        <td><emphasis>Yes, only head/tail matching</emphasis></td>

        <td><emphasis>Yes, head/tail matching</emphasis></td>

        <td><emphasis>Yes, head/tail matching</emphasis></td>

        <td><emphasis>Yes</emphasis></td>
      </tr>

      <tr>
        <th>Pattern construction</th>

        <td>Yes, Concrete syntax</td>

        <td>Yes, Prefix syntax</td>

        <td>Yes, Prefix syntax</td>

        <td><emphasis>Yes</emphasis></td>

        <td><emphasis>Yes, only head/tail</emphasis></td>

        <td><emphasis>Yes, only head/tail</emphasis></td>

        <td><emphasis>Yes, head/tail</emphasis></td>

        <td><emphasis>Yes</emphasis></td>
      </tr>

      <tr>
        <th>Generator/Comprehension</th>

        <td>NO</td>

        <td><emphasis>NO</emphasis></td>

        <td>NO</td>

        <td><emphasis>NO</emphasis></td>

        <td>List comprehesion</td>

        <td>Set comprehensions</td>

        <td>Set comprehension</td>

        <td><emphasis role="bold">No</emphasis></td>
      </tr>

      <tr>
        <th>Complete Functions</th>

        <td><emphasis>Yes</emphasis></td>

        <td><emphasis>Yes</emphasis></td>

        <td><emphasis>Yes</emphasis></td>

        <td><emphasis>Yes</emphasis></td>

        <td>Yes</td>

        <td>Yes</td>

        <td>Yes</td>

        <td>Yes</td>
      </tr>

      <tr>
        <th>Equations</th>

        <td>Yes, backward compatible</td>

        <td>Yes, backward compatible</td>

        <td>Yes, backward compatible</td>

        <td>Yes, backward compatible</td>

        <td><emphasis>Yes</emphasis></td>

        <td>Yes</td>

        <td>Yes</td>

        <td>Yes</td>
      </tr>

      <tr>
        <th>Polymorphism</th>

        <td><emphasis role="bold">No</emphasis></td>

        <td><emphasis role="bold">No</emphasis></td>

        <td><emphasis role="bold">No</emphasis></td>

        <td><emphasis role="bold">No</emphasis></td>

        <td>Yes</td>

        <td>Yes</td>

        <td>Yes</td>

        <td>Yes</td>
      </tr>

      <tr>
        <th>Serialization</th>

        <td>AsFix</td>

        <td>AsFix</td>

        <td>AsFix</td>

        <td>AsFix</td>

        <td><emphasis>Yes</emphasis></td>

        <td><emphasis>Yes</emphasis></td>

        <td><emphasis>Yes</emphasis></td>

        <td>Yes</td>
      </tr>

      <tr>
        <th>Traversal Functions</th>

        <td>Yes</td>

        <td>Yes</td>

        <td>Yes</td>

        <td>Yes</td>

        <td><emphasis>Yes</emphasis></td>

        <td>Yes</td>

        <td>Yes</td>

        <td>Yes</td>
      </tr>

      <tr>
        <th>Subtyping</th>

        <td>No</td>

        <td>No</td>

        <td>No, except character class inclusion</td>

        <td>No</td>

        <td><emphasis>Yes</emphasis></td>

        <td><emphasis>Yes</emphasis></td>

        <td><emphasis>Yes</emphasis></td>

        <td><emphasis>Yes</emphasis></td>
      </tr>
    </informaltable>
  </section>

  <section>
    <title>Questions</title>

    <para><itemizedlist>
        <listitem>
          <para>Q1: What about the overlap between sets of tuples and
          relations? We should build relations in for efficiency. Is there
          going to be a type equivalence. Are tuples going to be first class
          datatypes?</para>
        </listitem>

        <listitem>
          <para>Q2: Do we need to introduce the basic datatypes Integer and
          Boolean because sets and relations have typical builtin functions
          for that? Or can we put these things in a library? How about
          Locations? We need to introduce as feq builtin syntax as possible to
          prevent ambiguity and confusion... Can we offer efficient relations
          without introducing a dependency on a fixed Integer/Boolean
          syntax??? It would be SIMPLE if only syntax trees are the leafs of
          nested lists/sets/relations/tuples.</para>
        </listitem>

        <listitem>
          <para>Q3: Concrete syntax will introduce problems with the new fixed
          syntax builtin datatypes (prefix functions, lists, sets, relations,
          tuples). Efficiently make a type-checker that can resolve most of
          the ambiguities.</para>
        </listitem>

        <listitem>
          <para>Q4: We should allow (optionally) quoting/escaping concrete
          syntax parts. If Q3 results in error or undecidable disambiguation,
          the user must be able to clarify precisely.</para>
        </listitem>
      </itemizedlist></para>

    <para></para>
  </section>

  <section>
    <title>Example</title>

    <para>Here we list experimental example Rascal code to try out new and old
    features.</para>

    <section>
      <title>Deep tree matching instead of tree traversal</title>

      <para><programlisting>module Tree-syntax

imports Naturals

exports TREE

  context-free syntax
    NAT        -&gt; TREE
    f(TREE,TREE)    -&gt; TREE
    g(TREE,TREE)    -&gt; TREE
    h(TREE,TREE)    -&gt; TREE
       i(TREE,TREE)    -&gt; TREE

module Examples
imports Tree-syntax

%% Ex1: Count leaves in a TREE

function cnt(TREE)       -&gt; INT
[] cnt(T) = #{N | INT N : T}

%% Idea: INT N : T generates alle INT leaves in the tree
%% # is the built-in length-of operator

%% Ex2: Sum all leaves in a TREE

function sum_tree(TREE)       -&gt; INT
[] sum_tree(T) = sum({N | INT N : T})

%% NB sum is a built-in that add all elements in a set.

%% Ex3: Increment all leaves in a TREE

function inc(TREE)        -&gt; TREE
[] inc(T) = INT N : T =&gt; N+1

%% Idea: INT N : T generates alle INT leaves in the tree
%% INT N : T =&gt; N+1 replaces each N by N+1
%% The expression as a whole returns the modified term.
%% This is an extremely compact manner of writing a transformer!

%% Ex4: full replacement of g by i

function frepl(TREE)  -&gt; TREE
[] frepl(T) = g(T1, T2) : T =&gt; i(frepl(T1), frepl(T2))

%% Ex5: deep replacement of g by i

function drepl(TREE)  -&gt; TREE
[] drepl(T) = g(T1, T2) : T =&gt; i(T1, T2)
  when T1 == drepl(T1),
    T2 == drepl(T2)

%% Ex6: shallow replacement of g by i

function srepl(TREE)  -&gt; TREE
[] srepl(T) = g(T1, T2) : T =&gt; i(T1, T2) </programlisting></para>
    </section>

    <section>
      <title>Lambda Substitution</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.<programlisting>module Lambda

sorts Var %% variables
      Exp %% expressions

context-free functions
     "prime" "(" Var ")"  -&gt; Var              %% generate unique name
     Var                  -&gt; Exp              %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp              %% function abstraction
     Exp Exp              -&gt; Exp              %% function application

function allVars(Exp) -&gt; set[Var]
[] allVars(E) = {V | &lt;&lt;Var V&gt;&gt; : E}


function boundVars(Exp) -&gt; set[Var]
[] boundVars(E) = {V | &lt;&lt;fn Var V =&gt; Exp E1&gt;&gt; : E}

function freeVars(Exp) -&gt; set[Var]
[] freeVars(E) = allVars(E) \ boundVars(E)

%% Generate a fresh variable if V does not occur in given set.
function fresh(Var, set[Var]) -&gt; Var
[] fresh(V, S) = if V in S then prime(V) else V fi

%% Substitution: replace all occurrences of V in E2 by E1

function subst(Var, Exp, Exp)  -&gt; Exp

[1] subst(V1, E, V2) = V2 when V1 != V2

[2] subst(V, E, V) = E

[3] subst(V, E, E1 E2) = subst(V, E, E1) subst(V, E, E2)

[4] subst(V, E1, fn V =&gt; E2) = fn V =&gt; E2
[5] subst(V1, E1, fn V2 =&gt; E2) = fn V2 =&gt; subst(V1, E1, E2)
   when V1 != V2,
        not(V1 in freeVars(E2) and V2 in freeVars(E1))

[6] subst(V1, E1, fn V2 =&gt; E2) = fn V3 =&gt; subst(V1, E1, subst(V2, V3, E2))
   when
        V1 != V2,
        V1 in freeVars(E2) and V2 in freeVars(E1),
        V3 := fresh(V2,  freeVars(E2) union freeVars(E1)) </programlisting></para>
    </section>

    <section>
      <title>Renaming</title>

      <para><programlisting>module Renaming

sorts Var %% variables

     Exp %% expressions

context-free functions

     Var                                -&gt; Exp   %% single variable

     "let" Var "=" Exp "in Exp "end"    -&gt; Exp   %% function

     abstraction

%% Rename all bound variables in an Exp

%% Version 1: purely functional

%% Exp: given expression to be renamed

%% rel[Var,Var]: renaming table

%% Int: counter to generate global variables

function rename(Exp E, rel[Var,Var] Rn, Int Cnt) -&gt; Exp

[] rename(let V = E1 in E2 end, Rn, Cnt) =
  let Y = rename(E1, Rn, Cnt) in rename(E2, {&lt;V, Y&gt;} union Rn, Cnt') end

  when
    Y := "x" + Cnt,                             %% this + concatenates (after conversion)

    Cnt' := Cnt + 1

[] rename(V, Rn, Cnt) = V1

  when

    { V1 } = Rn[V]

[default]

  rename(E, Rn, Cnt) = E

%% Rename all bound variables in an Exp

%% Version 2: using global variables to generate new variables

global variable

      Cnt -&gt; int := 0                           %% Global has to be initialyzed somewhere

function newVar() -&gt; Var

[] newVar() = "x" + Cnt        

  when Cnt := Cnt + 1

%% Rename -- Version 2

function rename(Exp, rel[Var,Var])

[] rename(let V = E1 in E2 end, Rn) =
  let Y = rename(E1, Rn) in rename(E2, {&lt;V, Y&gt;} union Rn) end

  when
    Y := newVar

[] rename(V, Rn) = V1

  when

    { V1 } = Rn[V]

[default]

  rename(E, Rn) = E

%% Rename -- Version 3, with Rn also as global variabele

global variable

      Rn -&gt; rel[Var, Var]

function rename(Exp)

[] rename(let V = E1 in E2 end) =
  let Y = rename(E1) in rename(E2) end

  when
    Y := newVar,

    Rn :=  {&lt;V, Y&gt;} union Rn

[] rename(V) = V1

  when

    { V1 } = Rn[V]

[default]

  rename(E) = E </programlisting></para>
    </section>

    <section>
      <title>Dynamically scoped variables</title>

      <para>The following example details the use of a dynscope global
      variable for building up and using an environment. Notice that we
      introduce <emphasis>void</emphasis> functions as a
      result.<programlisting>module Typecheck

imports Pico-syntax

hiddens

types
 rel[PICO-ID,TYPE] -&gt; Environment

variables
 "Decls" -&gt; Decl*
 "Stats"[0-9]* -&gt; Stat*
 "Bool"  -&gt; bool
 "Exp"   -&gt; EXP
 "Nat"   -&gt; NatCon
 "Str"   -&gt; StrCon
global variables
 "Env"   -&gt; Environment

exports

function tc(PROGRAM)     -&gt; bool
[] tc(begin Decls Stats end) = tcs(Stats)
  when Env := tcd(Decls)

traversal function tcd(Decls) -&gt; void
[] tcd(Id : Type) = void
   when Env := Env union {&lt;Id,Type&gt;}

function tcs(Stats) -&gt; bool
[] tcs( ) = true
[] tcs(Stat; Stats) = tcst(Stat) &amp;&amp; tcst(Stats)

function tcst(Stat) -&gt; bool
[] tcst(Id := Exp) = type-of(Exp) in Env[Id]
[] tcst(if Exp then Stats1 else Stats2) =
    type-of(Exp) == natural &amp;&amp; tcs(Stats1) &amp;&amp; tcs(Stats2)
[] tcst(while Exp do Stats od) = type-of(Exp) == natural &amp;&amp; tcs(Stats)

function type-of(Exp) -&gt; PICO-TYPE
[] type-of(NatCon) = natural
[] type-of(StrCon) = string
[] type-of(Id) = Type when {&lt;Id,Type&gt;} := Env[Id] </programlisting></para>
    </section>
  </section>

  <section>
    <title>Syntax Definition</title>

    <para><programlisting>lexical syntax
  [0-9]+    -&gt; NatCon
  "true"    -&gt; BoolCon
  "false"   -&gt; BoolCon
  [\0-\255] -&gt; ByteCon

context-free syntax
  %% foreach symbol S in the user-defined grammar:
  S                                 -&gt; Term {cons("to-term")}
  Term                              -&gt; S    {cons("from-term")}
  Type "(" Term ")"                 -&gt; Term {cons("cast")}
  Name "(" {Term ","}* ")"          -&gt; Term {cons("function")}
  "[" {Term ","}* "]"               -&gt; Term {cons("list")}
  "{" {Term ","}* "}"               -&gt; Term {cons("set")}
  "[" Term "|" {Generator ","}+ "]" -&gt; Term {cons("list-comprehension")}
  "{" Term "|" {Generator ","}+ "}" -&gt; Term {cons("set-comprehension")}
  "&lt;" {Term ","}* "&gt;"               -&gt; Term {cons("tuple")}
  "[" Term ":" Term "]"             -&gt; Term {cons("list-construction")}
  "{" Term ":" Term "}"             -&gt; Term {cons("set-construction")}
  BoolCon                           -&gt; Term {cons("boolean")}
  NatCon                            -&gt; Term {cons("number")}
  ByteCon                           -&gt; Term {cons("blob")}

context-free syntax
  Term "in" Term    -&gt; Term
  Term "union" Term -&gt; Term
  "#" Term          -&gt; Term
  %% etcetera

context-free syntax
  "module" ModuleName Section*    -&gt; Module

context-free syntax
  "variables" VariableDefinition* -&gt; Section
  Definition Rule*                -&gt; Section
  "equations" Rule*               -&gt; Section
  "tests" Test*                   -&gt; Section
  Modifier+ Section               -&gt; Section {non-assoc} %% to distribute modifiers over all elements of a section

  Modifier* Name "(" {Type ","}* ")" "-&gt;" Type -&gt; Definition
  Modifier* {Name ","}+ "-&gt;" Type              -&gt; VariableDefinition 
  "bottom-up"                                  -&gt; Modifier
  "top-down"                                   -&gt; Modifier
  "break"                                      -&gt; Modifier
  "continue"                                   -&gt; Modifier
  "loop"                                       -&gt; Modifier
  "strict"                                     -&gt; Modifier
  "wild"                                       -&gt; Modifier
  "exports"                                    -&gt; Modifier
  "hiddens"                                    -&gt; Modifier

context-free syntax
  Term "=" Term                         -&gt; Rule %% type preserving
  Term "=" Term "when" {Condition ","}+ -&gt; Rule
  {Condition ","}+ "===&gt;" Term "=" Term -&gt; Rule

context-free syntax
  Condition                             -&gt; Test
  {Condition ","}+ "===&gt;" Condition     -&gt; Test
  Condition "when" {Condition ","}+     -&gt; Test

context-free syntax
  Term ":=" Term  -&gt; Condition {cons("match")}     
  Term "!:=" Term -&gt; Condition {cons("not-match")}
  Term "==" Term  -&gt; Condition {cons("equals")}
  Term "!=" Term  -&gt; Condition {cons("not-equals")}
  Term "::" Term  -&gt; Condition {cons("generator")}  %% only applicable in comprehensions for now, not rules (although a semantics similar to list matching might apply, i.e. find the first element that satisfies the following conditions)

context-free syntax
  %% Symbol from the Sdf definition of Sdf:
  Symbol                    -&gt; Type
  "&amp;" Type                  -&gt; Type
  TypeName                  -&gt; Type
  "list" "[" Type "]"       -&gt; Type
  "set" "[" Type "]"        -&gt; Type

  "rel" "[" {Type ","}+ "]" -&gt; Type
  "&lt;" {Type","}* "&gt;"        -&gt; Type
  "void"                    -&gt; Type
  "natural"                 -&gt; Type
  "boolean"                 -&gt; Type
  "loc"                     -&gt; TYpe</programlisting></para>
  </section>

  <section>
    <title>Integration with Tscripts</title>

    <section>
      <title>Introduction</title>

      <para>It is possible to speculate on an even further integration of
      formalisms and combining the above amalgan of ASF+SDF and Rscript with
      Tscripts.</para>
    </section>

    <section>
      <title>Requirements</title>

      <itemizedlist>
        <listitem>
          <para>R12: The resulting language uses a single type system. This
          means that relational types (possible including syntactic objects)
          can be used in Tscripts.</para>
        </listitem>

        <listitem>
          <para>R13: The current "expressions" in Tscript (terms that occur at
          the rhs of an assignment) are replaced by calls to ASF+SDF or
          Rscript functions.</para>
        </listitem>

        <listitem>
          <para>R14: There is minimal duplication in functionality between
          ASF+SDF/Rscript/Tscript.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Different styles of Type Declarations</title>

      <para>We have at the moment, unfortunately, a .proliferation of
      declaration styles for types.</para>

      <para>Functions are declared in ASF+SDF as:</para>

      <programlisting>typecheck(PROGRAM) -&gt; Boolean</programlisting>

      <para>Observe that only the type of the parameter is given but that it
      does not have a name.</para>

      <para>In Rscript we have:</para>

      <programlisting>int sum(set[int] SI) = ...</programlisting>

      <para>while in Tscript processes are declared as</para>

      <programlisting>process mkWave(N : int) is ...</programlisting>

      <para>For variables a similar story applies. Variables are declared in
      ASF+SDF as:</para>

      <programlisting>"X" [0-9]+    -&gt; INT</programlisting>

      <para>In Rscript we have:</para>

      <programlisting>int X

int X : S   (in comprehensions)</programlisting>

      <para>and in Tscript we have:</para>

      <programlisting>X : int</programlisting>

      <para>In order to unify these styles, we might do the following:</para>

      <itemizedlist>
        <listitem>
          <para>The type of an entity is always written before the entity
          itself.</para>
        </listitem>

        <listitem>
          <para>Formal parameters have a name.</para>
        </listitem>
      </itemizedlist>

      <para>In essence, this amounts to using the declaration style as used in
      Rscript. So we get:</para>

      <programlisting>Boolean typecheck(PROGRAM P) is ...

process mkWave(int N) is ...</programlisting>

      <para>Or do we want things like:</para>

      <programlisting>function typeckeck(PROGRAM P) returns Boolean is ...

var X -&gt; int

process mkWave(int N) is ...</programlisting>

      <para>Advantages are:</para>

      <itemizedlist>
        <listitem>
          <para>The category of the entity is immediately clear (function,
          var, process, tool, ...).</para>
        </listitem>

        <listitem>
          <para>It is readable to further qualify the category, i.e.,
          traversal function, hidden var, restartable tool)</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
</article>