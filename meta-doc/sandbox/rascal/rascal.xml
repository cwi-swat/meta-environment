<?xml version="1.0" encoding="US-ASCII"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Rascal Requirements and Design Document</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Tijs</firstname><surname>van der
        Storm</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is a braindump of ideas. See <xref linkend="Issues" />
    for the issues that have to be resolved.</para>
  </note>

  <section>
    <title>Introduction</title>

    <para>Rascal is the working name for a new version of ASF+SDF, which will
    be extended with an efficient built-in set and relation data-type. This
    basically means that we include most features of the RScript language into
    ASF+SDF. The goals of this language are:</para>

    <itemizedlist>
      <listitem>
        <para>Separating pure syntax definitions (SDF) from function
        definitions.</para>
      </listitem>

      <listitem>
        <para>Easy syntax-directed analysis of programming languages.</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction.</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning.</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation.</para>
      </listitem>

      <listitem>
        <para>Efficient and scalable implementation.</para>
      </listitem>
    </itemizedlist>

    <para>The above goals are all but one already met in the current design of
    ASF+SDF, and the current design of RScript. What is missing is the
    <emphasis>connection.</emphasis> Alas, any bridge between the two
    languages is both complex to manage and an efficiency bottleneck. This
    work is an attempt to consolidate this engineering trade-off.</para>

    <para>In section Integration with Tscripts we will also explore the issues
    when we take integration one step further and also include Tscripts in the
    considerations.</para>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Backward compatible with ASF+SDF.</para>
        </listitem>

        <listitem>
          <para>R3: Compilation speed: parsetable generation is a major
          bottleneck in current ASF+SDF. This needs to be fixed.</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability and easy parsing of a
          wide range of source languages.</para>
        </listitem>

        <listitem>
          <para>R5: Functional (no side-effects).</para>
        </listitem>

        <listitem>
          <para>R6: File I/O (contradicts R5).</para>
        </listitem>

        <listitem>
          <para>R7: Easily accessible fact storage (similar to a heap, but
          remember R5 and the details of backtracking).</para>
        </listitem>

        <listitem>
          <para>R8: List matching (because of R2, influences R7).</para>
        </listitem>

        <listitem>
          <para>R9: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as
          scoping).</para>
        </listitem>

        <listitem>
          <para>R10: Syntax trees can be elements of the builtin
          data-structures (but not vice versa).</para>
        </listitem>

        <listitem>
          <para>R11: Features are orthogonal: try to keep the number of ways
          to write down a program minimal</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Mapping features to datatypes</title>

    <para>Emphasized cells indicate a new datatype/feature combination that
    needs to be thought out.</para>

    <informaltable border="1">
      <tr>
        <th>Which features work on which datatypes?</th>

        <th>CF syntax trees</th>

        <th>CF syntax lists</th>

        <th>Lexical syntax trees</th>

        <th>Lexical syntax lists</th>

        <th>Lists</th>

        <th>Sets</th>

        <th>Relations</th>

        <th>Tuples</th>
      </tr>

      <tr>
        <th>Pattern matching</th>

        <td>Y (CS)</td>

        <td>Y, CS, LM</td>

        <td>Y, PS</td>

        <td>Y, PS, LM</td>

        <td>Y, HT</td>

        <td>Y, HT</td>

        <td>Y, HT</td>

        <td>Y</td>
      </tr>

      <tr>
        <th>Pattern construction</th>

        <td>Y, CS</td>

        <td>Y, PS</td>

        <td>Y, PS</td>

        <td>Y</td>

        <td>Y, HT</td>

        <td>Y, HT</td>

        <td>Y, HT</td>

        <td>Y</td>
      </tr>

      <tr>
        <th>Generator/ Comprehension</th>

        <td>N</td>

        <td>N</td>

        <td>N</td>

        <td>N</td>

        <td>LC</td>

        <td>SC</td>

        <td>SC</td>

        <td>N</td>
      </tr>

      <tr>
        <th>Complete Functions</th>

        <td><emphasis>Y</emphasis></td>

        <td><emphasis>Y</emphasis></td>

        <td><emphasis>Y</emphasis></td>

        <td><emphasis>Y</emphasis></td>

        <td>Y</td>

        <td>Y</td>

        <td>Y</td>

        <td>Y</td>
      </tr>

      <tr>
        <th>Equations</th>

        <td>Y, BC</td>

        <td>Y, BC</td>

        <td>Y, BC</td>

        <td>Y, BC</td>

        <td><emphasis>Y</emphasis></td>

        <td>Y</td>

        <td>Y</td>

        <td>Y</td>
      </tr>

      <tr>
        <th>Polymorphism</th>

        <td>N</td>

        <td>N</td>

        <td>N</td>

        <td>N</td>

        <td>Y</td>

        <td>Y</td>

        <td>Y</td>

        <td>Y</td>
      </tr>

      <tr>
        <th>Serialization</th>

        <td>AsFix</td>

        <td>AsFix</td>

        <td>AsFix</td>

        <td>AsFix</td>

        <td><emphasis>Y</emphasis></td>

        <td><emphasis>Y</emphasis></td>

        <td><emphasis>Y</emphasis></td>

        <td>Y</td>
      </tr>

      <tr>
        <th>Traversal Functions</th>

        <td>Y</td>

        <td>Y</td>

        <td>Y</td>

        <td>Y</td>

        <td><emphasis>Y</emphasis></td>

        <td>Y</td>

        <td>Y</td>

        <td>Y</td>
      </tr>

      <tr>
        <th>Subtyping</th>

        <td>N</td>

        <td>N</td>

        <td>N, except character class inclusion</td>

        <td>N</td>

        <td><emphasis>Y</emphasis></td>

        <td><emphasis>Y</emphasis></td>

        <td><emphasis>Y</emphasis></td>

        <td><emphasis>Y</emphasis></td>
      </tr>
    </informaltable>

    <itemizedlist>
      <listitem>
        <para>BC = Backward Compatible with ASF</para>
      </listitem>

      <listitem>
        <para>CS = Concrete Syntax</para>
      </listitem>

      <listitem>
        <para>HT= head/tail matching</para>
      </listitem>

      <listitem>
        <para>LC = List comprehension</para>
      </listitem>

      <listitem>
        <para>LM = List Matching</para>
      </listitem>

      <listitem>
        <para>N = No</para>
      </listitem>

      <listitem>
        <para>PS = Prefic Syntax</para>
      </listitem>

      <listitem>
        <para>SC = Set Comprehension</para>
      </listitem>

      <listitem>
        <para>Y = Yes</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Questions</title>

    <para><itemizedlist>
        <listitem>
          <para>Q1: What about the overlap between sets of tuples and
          relations? We should build relations in for efficiency. Is there
          going to be a type equivalence. Are tuples going to be first class
          datatypes?</para>
        </listitem>

        <listitem>
          <para>Q2: Do we need to introduce the basic datatypes Integer and
          Boolean because sets and relations have typical builtin functions
          for that? Or can we put these things in a library? How about
          Locations? We need to introduce as few builtin syntax as possible to
          prevent ambiguity and confusion... Can we offer efficient relations
          without introducing a dependency on a fixed Integer/Boolean
          syntax??? It would be SIMPLE if only syntax trees are the leafs of
          nested lists/sets/relations/tuples.</para>
        </listitem>

        <listitem>
          <para>Q3: Concrete syntax will introduce problems with the new fixed
          syntax builtin datatypes (prefix functions, lists, sets, relations,
          tuples). Efficiently make a type-checker that can resolve most of
          the ambiguities.</para>
        </listitem>

        <listitem>
          <para>Q4: We should allow (optionally) quoting/escaping concrete
          syntax parts. If Q3 results in error or undecidable disambiguation,
          the user must be able to clarify precisely.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Examples</title>

    <para>Here we list experimental examples of Rascal code to try out new and
    old features.</para>

    <section>
      <title>Booleans</title>

      <para>Probably a non-typical example, but let's try it anyway. (It looks
      horrible compared to the ASF version)</para>

      <programlisting>syntax module Booleans

exports 
  sorts Bool

  context-free syntax
    "true"        -&gt; Bool
    "false"       -&gt; Bool
    Bool "&amp;" Bool -&gt; Bool {left}
    Bool "|" Bool -&gt; Bool {right}

module Bool-examples
imports Booleans

fun Bool and(Bool B1, B2) { %% reduce &amp; operator
    Bool B;
    select(B1){
    [| true |]  =&gt; reduce(B2)
    [| false |] =&gt; false
    [| $B |]    =&gt; [| $B1 &amp; $B2 |]
    }    
}

fun Bool or(Bool B1, B2) { %% reduce | operator
    Bool B;
    select(B1){
    [| true  |] =&gt; true
    [| false |] =&gt; reduce(B2)
    [| $B |]    =&gt; [| $B1 | $B2 |]
    }    
}

fun Bool reduce(Bool B){
    Bool B1, B2, B3;
    select(B){
    [| $B1 &amp; $B2 |] =&gt; and(B1, B2)
    [| $B1 | $B2 |] =&gt; or(B1, B2)
    [| $B3 |]       =&gt; B
    }
}</programlisting>
    </section>

    <section>
      <title>Deep tree matching instead of tree traversal</title>

      <para><programlisting>%% Mark a pure syntax module as such with "syntax"

syntax module Tree-syntax
imports Naturals
exports TREE
  context-free syntax
    NAT             -&gt; TREE
    f(TREE,TREE)    -&gt; TREE
    g(TREE,TREE)    -&gt; TREE
    h(TREE,TREE)    -&gt; TREE
    i(TREE,TREE)    -&gt; TREE

%%--------------------------------

module Tree-Examples
imports Tree-syntax

%% Ex1a: Count leaves in a TREE
%% Idea: int N : T generates alle int leaves in the tree
%% # is the built-in length-of operator

fun int cnt(TREE T) {
    #{N | NAT N : T}
}

%% Ex1b: an equivalent,  more purist, version of the same function:
fun int cnt(TREE T) {
    #{N | [| $(NAT N) |] : T}
}

%% Ex2: Sum all leaves in a TREE
%% NB sum is a built-in that adds all elements in a set or 
%% list.
%% Here we see immediately the need to identify
%% - the built-in sort "int"
%% - the syntactic sort "NAT"

fun int sumtree(TREE T) {
    sum({N | int N : T})
}

%% Ex3: Increment all leaves in a TREE
%% Idea: using T replace int N by N+1 generates alle leaves in the 
%% tree T that match an integer and replaces each N in T by N+1.
%% The expression as a whole returns the modified term.
%% This is an extremely compact manner of writing a 
%% transformer!
%% Note that two conversions are needed here:
%% - from int to NAT to match subterms
%% - from int to NAT to convert the result of addition into a NAT tree

fun TREE inc(TREE T) {
    int N;
    replace T {
      [| $N |] =&gt; [| $(N + 1) |]
    }
}

%% Ex4: full replacement of g by i
%% Question: how about the traversal order?
%% Probable answer: bottom-up and top-down are both ok so it does not matter.
%% Bottom-up case: g are replaced by i's.
%% Top-down case: g are replaced by i's but in the arguments of the new i-tree
%% g's are later replaced by i's.
%% Question: Is it relevant to fix the traversal order? 
%% The choice should then be bottom-up since top-down can be
%% achieved with recursion (see srepl, below).

fun TREE frepl(TREE T) {
    TREE T1, T2;
    replace T {
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |]
    }

%% Ex5a: deep replacement of g by i which usually requires
%% a bottom-up traversal + break;

fun TREE drepl(TREE T) {
    TREE T1, T11, T12, T2, T21, T22;
    replace T { 
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |]
         when not exists [| g($T11, $T12) |] : T1, 
              not exists [| g($T21, $T22)  |]: T2
    }   
}

%% Assume that the traversal is always bottom-up
%% and introduce a "first" directive (= break).
%% Along this line "all" would be the default.

fun TREE drepl(TREE T) {
    TREE T1, T2;
    replace T first {
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |] 
    }
}

%% If we want the whole repertoire of traversal functions
%% can be made available:
%% - using T replace first bu ...
%% - using T replcae all td ...
%% - etc.
%% A nice touch is that these properties are not tied to the
%% declaration of a travesal function (as in ASF+SDF) but to its use.
%% The above would become:

fun TREE drepl(TREE T) {
    TREE T1, T2;
    replace T first bu {
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |] 
    }
}

%% Ex6a: shallow replacement of g by i (i.e. only outermost g's are replaced);
%% Usually done with a top-down traversal.
%% For brevity, we use here a string variable FUN that matches
%% a function symbol: do we want this? It corresponds to a lexical variable.

fun TREE srepl(TREE T) {
    TREE T1, T2;
    str FUN;
    
    select (T) {
    [| g($T1, $T2) |]    =&gt; [| i($T1, $T2) |]
    [| $FUN($T1, $T2) |] =&gt; [| $FUN($(srepl(T1)) $(srepl(T2))) |]
    }
}

%% Using traversal attributes, one could write this as:

fun TREE srepl(TREE T) {
    TREE T1, T2;
    replace T first td {
      [| g($T1, $T2) |] =&gt; [| i($T1, $T2) |]
    }
}

%% Continuing this line of thought, we can also add these directives
%% to all generators (where "all td" would be the default):

fun set[TREE] find_outer_gs(TREE T) {
    TREE T1, T2;
    { S | first td STATEMENT S : T, [| g($T1, $T2) |] == S }
}

or may abbreviated as (eliminating the need for a variable S):

fun set[TREE] find_outer_gs(TREE T) {
    TREE T1, T2;
    search T first td {
      [| g($T1, $T2) |]
    }
}

and abbreviation:

fun set[TREE] find_inner_gs(TREE T) {
    TREE T1, T2;
    search T first bu {
      [| g($T1, $T2) |]
    }
}</programlisting></para>
    </section>

    <section>
      <title>Lambda Substitution</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.<programlisting>syntax module Lambda

sorts Var %% variables
      Exp %% expressions

context-free functions
     "prime" "(" Var ")"  -&gt; Var  %% generate unique name
     Var                  -&gt; Exp  %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp  %% function abstraction
     Exp Exp              -&gt; Exp  %% function application

%%------------------------------

module Lambda-Examples
imports Lambda

fun set[Var] allVars(Exp E) {
    {V | Var V : E}
}

fun set[Var] boundVars(Exp E) {
    {V | [| fn $(Var V) =&gt; $(Exp E1) |] : E}
}

fun set[Var] freeVars(Exp E) {
    allVars(E) \ boundVars(E)
}

%% Generate a fresh variable if V does not occur in 
%% given set of variables.

fun Var fresh(Var V, set[Var] S) {
    if V in S then prime(V) else V fi
}

%% Substitution: replace all occurrences of V in E2 by E1
%% This functions used to be defined by separate equations,
%% now we use a case distinction

fun Exp subst(Var V1, Exp E1, Exp E2) {
    Var V2;
    Exp Ea, Eb;

    select (E2) {
      [| $V2 |] =&gt; V2
         when V1 != V2

      [| $V2 |] =&gt; E1
         when V1 == V2 

      [| $Ea $Eb |]  =&gt; [| $(subst(V, E, Ea)) $(subst(V, E, Eb)) |]

      [| fn $V2 =&gt; $Ea |] =&gt;  [| fn $V2 =&gt; $Ea |]
         when V1 == V2

      [| fn $V2 =&gt; $Ea |] =&gt; [| fn $V2 =&gt; $(subst(V1, E1, Ea)) |]
         when V1 != V2,
              not(V1 in freeVars(E2) &amp; V2 in freeVars(E1))

      [| fn $V2 =&gt; $Ea |] =&gt; [| fn $V3 =&gt; $(subst(V1, E1, subst(V2, V3, E2))) |]
         when V1 != V2,
              V1 in freeVars(Ea) &amp; V2 in freeVars(E1),
              V3 := fresh(V2,  freeVars(Ea) union freeVars(E1))
    }
}</programlisting></para>
    </section>

    <section>
      <title>Renaming</title>

      <para><programlisting>syntax module Let
sorts Var %% variables
      Exp %% expressions
context-free functions
     
     Var                             -&gt; Exp %% single variable
     
     "let" Var "=" Exp "in Exp "end" -&gt; Exp %% function abstraction
%%------------------------------------------

module Let-Example
import Let

%% Rename all bound variables in an Exp
%% Version 1: purely functional
%% Exp: given expression to be renamed
%% rel[Var,Var]: renaming table
%% Int: counter to generate global variables

fun Exp rename(Exp E, rel[Var,Var] Rn, Int Cnt) {
    int Cnt1;
    Var V, Y;
    Exp E1, E2;

    select(E) {
    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $(rename(E1, Rn, Cnt)) 
              in 
                 $rename(E2, {&lt;V, Y&gt;} union Rn, Cnt1) 
              end 
           |]
        when Y := "x" + Cnt,   %% this + operator concatenates 
                               %% (after converting the int to str)
             Cnt1 := Cnt + 1

    [| $V' |] =&gt; V1
       when { V1 } == Rn[V]

    [| $E' |] =&gt; E
    }
}

%% Rename all bound variables in an Exp
%% Version 2: using a global variable
%% to generate new variables


fun Var newVar() {
    global int Cnt := 0   %% Initialize global Cnt on first call of newVar
                          %% This is similar to a local static var in C.
    Cnt := Cnt + 1;
    return "x" + Cnt
}       

%% Rename -- Version 2

fun Exp rename(Exp E, rel[Var,Var] Rn) {
    Var V, Y;

    select (E) {

    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $(rename(E1, Rn)) 
              in 
                $(rename(E2, {&lt;V, Y&gt;} union Rn)) 
              end
           |]
       when Y := newVar

    [| $V |] =&gt; V1
       when { V1 } == Rn[V]
  
    [| $E |] =&gt; E
    }
}

%% Rename -- Version 3, with Rn also as global variabele

fun Var newVar() {
    global int Cnt := 0   %% Initialize global Cnt on first call of newVar
    Cnt := Cnt + 1;
    return "x" + Cnt
}       

fun Exp rename(Exp E) {
    global rel[Var, Var] Rn := {}
    Var V, Y;
 
    select (E){
    [| let $V = $E1 in $E2 end |] =&gt;
           [| let $Y = $rename(E1) 
              in 
                 $rename(E2) 
              end
           |]
       when Y := newVar,
            Rn :=  {&lt;V, Y&gt;} union Rn
              
    [| $V |] =&gt; V1
       when { V1 } == Rn[V]
 
    [| $E |] = E
    }
}

%% Question: how to reset the value of global variables?
%% Idea: model them as arguments:
%% - fun Var newVar(global int Cnt := 0) { ... }
%% and allow calls without arguments (as in above example) or
%% with arguments:
%% - newVar(13)
%% which resets the value of Cnt.</programlisting></para>
    </section>

    <section>
      <title>Concise Pico Typechecker</title>

      <para>The following example shows the tight integration ASF with
      comprehensions.</para>

      <programlisting>module Typecheck

imports Pico-syntax
imports Errors

types
 rel[PICO-ID,TYPE] -&gt; Env

var
    DECLS Decls;
    {STATEMENT ";"}* Series;
    Id Id;
    TYPE Type;
    Env Env;

fun list[Error] tcp(PROGRAM P) {
    select (P){
    [| begin $Decls $Series end |] =&gt;
           [ tcst(S, Env) | Stat S : Series ]
       when Env := {&lt;Id, Type&gt; | [| $(PICO-ID Id) : $(TYPE Type) |] : Decls}
    }
}

fun list[Error] tcst(Stat Stat, Env Env) {
    select (Stat) {
    [| $Id := $Exp |] =&gt; type-of(Exp, Type, Env)
       when {&lt;Id,Type&gt;} := Env[Id]

    [| if $Exp then $Stats1 else $Stats2 fi |] =&gt;
           type-of(Exp, natural, Env) + 
           tcs(Stats1, Env) + tcs(Stats2, Env)

    [| while $Exp do $Stats od |] =&gt;
           type-of(Exp, natural, Env) + tcs(Stats, Env)
    }
}

fun list[Error] type-of(Exp E, TYPE Type, Env Env) {
    NatCon NatCon;
    StrCon StrCon;
    Id Id;
    Exp Exp;

    select (E) {
    [| $NatCon |] =&gt; []
       when Type == natural

    [| $StrCon |] =&gt; []
       when Type == string

    [| $Id |] =&gt; [] 
       when {&lt;Id,Type2&gt;} := Env[Id],
            Type2 == Type
            
    [| $Exp |] =&gt; [error("Incorrect type")]
    }
}

%% Discussion: it may be interesting to generalize select to allow 
%% multiple arguments:
   select (E, Type) {
    [| $NatCon |], [| natural |] =&gt; []

    [| $StrCon |], [| string |] =&gt; []

    [| $Id |], Type =&gt; [] 
       when {&lt;Id,Type2&gt;} := Env[Id],
            Type2 == Type
            
    [| $Exp |], Type =&gt; [error("Incorrect type")]
    }
%% Even patterns and expressions could be allowed as cases.</programlisting>
    </section>

    <section>
      <title>Generating Dot files</title>

      <para>This example illustrates the use of a comprehension on the
      right-hand side of an equation.<programlisting>module Dot-generation

imports Dot-syntax

fun Dot gen-dot(rel[ID, ID] Rel) {
    [| digraph example {
                        $([ node(Tup) | &lt;ID,ID&gt; Tup : Rel ])
                       }
    |]
}

fun DotElem* gen-node(&lt;ID Id1, ID Id2&gt;) {
    [| node $Id1; node $Id2; $Id1 -&gt; $Id2 |}}
}</programlisting></para>
    </section>

    <section>
      <title>Dynamically scoped variables</title>

      <para>The following example details the use of a dynscope global
      variable for building up and using an environment. Notice that we
      introduce <emphasis>void</emphasis> functions as a
      result.<programlisting>module Typecheck

imports Pico-syntax

hiddens

types
 rel[PICO-ID,TYPE] -&gt; Env

variables
 "Decls" -&gt; Decl*
 "Stats"[0-9]* -&gt; Stat*
 "Bool"  -&gt; bool
 "Exp"   -&gt; EXP
 "Nat"   -&gt; NatCon
 "Str"   -&gt; StrCon

exports

fun Bool tc(PROGRAM P) {
    dyn Env Env := {};
    select (P) {
    [| begin $Decls $Stats end |] =&gt; tcs(Stats)
       when Env := tcd(Decls) 
}

fun Env tcd(Decls Decls) -&gt; void
    {&lt; Id, Type&gt; | [| $(PICO-ID Id) : $(TYPE Type) |] : Decls}

fun Bool tcs(Stats Stats) {
    Stat Stat;
    Stats Stats;
    select (Stats) {
    [| |]                =&gt; true

    [| $Stat ; $Stats |] =&gt; tcst(Stat) + tcst(Stats)
    }
}

fun Bool tcst(Stat Stat) {
    Id Id;
    Exp Exp;
    Stats Stats, Stats1, Stats2;
    select (Stat) {
    [| $Id := $Exp |] =&gt; type-of(Exp, Type)
        when {&lt;Id, Type&gt;} := Env[Id]

    [| if $Exp then $Stats1 else $Stats2 fi |] =&gt;
           type-of(Exp) == natural + tcs(Stats1) + tcs(Stats2)

    [| while $Exp do $Stats od |] =&gt;
          type-of(Exp) == natural + tcs(Stats)
    }
}

fun list[Error] type-of(Exp E, TYPE Type) {
    NatCon NatCon;
    StrCon StrCon;
    Id Id;
    Exp Exp;

    select (E) {
    [| $NatCon |] =&gt; []
       when Type == natural

    [| $StrCon |] =&gt; []
       when Type == string

    [| $Id |] =&gt; [] 
       when {&lt;Id,Type2&gt;} := Env[Id],
            Type2 == Type
            
    [| $Exp |] =&gt; [error("Incorrect type")]
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico control flow extraction</title>

      <programlisting>module Pico-controlflow
imports pico/syntax/Pico

sorts CP %% A Code Point

context-free syntax
    EXP | STATEMENT  -&gt; CP %% Waar moet dit staan?

fun &lt; set[CP], rel[CP,CP], set[CP] &gt; cflow({STATEMENT ";"}* Stats){
    Stat Stat;
    Stat+ Stats2;
    rel[CP,CP] R1, R2;
    set[CP] En1, En2, Ex1, Ex2;
    
    select (Stats) {
    [| Stat ; $Stats2 |] =&gt;
           &lt;En1, R1 union R2 union (Ex1 x En2), Ex2&gt;
       when &lt;En1, R1, Ex1&gt; := cflow(Stat),
            &lt;En2, R2, Ex2&gt; := cflow(Stats2)

    [| |] =&gt; &lt;{}, {}, {}&gt;
    }
}

fun &lt; set[CP], rel[CP,CP], set[CP] &gt; cflow(STATEMENT Stat){
    Exp Exp;
    Stat* Stats, Stats1, Stats2;
    rel[CP,CP] R1, R2;
    set[CP] En1, En2, Ex1, Ex2;

    select (Stat) {
    [| while $Exp do $Stats od |] =&gt;
           &lt;{Exp}, ({Exp} x En) union R union (Ex x {Exp}), {Exp}&gt;
       when &lt;En, R, Ex&gt; := cflow(Stats)
                
    [| if $Exp then $Stats1 else $Stats2 fi |] =&gt;
           &lt; {Exp}, 
             ({Exp} x En1) union ({Exp} x En2) union R1 union R2,
              Ex1 union Ex2
           &gt;
       when &lt;En1, R1, Ex1&gt; := cflow(Stats1),
            &lt;En2, R2, Ex2&gt; := cflow(Stats2)
           
    [| $Stat |]  =&gt; &lt;{Stat}, {}, {Stat}&gt;
    }
}</programlisting>
    </section>

    <section>
      <title>Pico use def extraction</title>

      <programlisting>module Pico-use-def

imports pico/syntax/Pico

fun rel[EXP,PICO-ID] uses(PROGRAM P) {
  {&lt;E,Id&gt; | EXP E : P, [| $(PICO-ID Id) |] == E}
}

fun rel[STATEMENT, PICO-ID] defs(PROGRAM P) { 
  {&lt;S, Id&gt; | STATEMENT S : P, 
                        [| $(PICO-ID Id) := $(EXP Exp) |] == S}
}</programlisting>

      <para>The above uses a "matching condition" to decompose
      <literal>S</literal>. The problem solved is that we want to have a name
      for the whole assignment <emphasis>and</emphasis> for the lhs
      identifier.</para>
    </section>

    <section>
      <title>Pico uninitialized variables</title>

      <para><programlisting>module Pico-uninit
imports pico/syntax/Pico Pico-controlflow Pico-use-def

fun set[PICO-ID] uninit(PROGRAM P) {
    rel[EXP,PICO-ID] Uses := uses(P);
    rel[STATEMENT, PICO-ID] Defs := defs(P),
    &lt; set[CP], rel[CP,CP], set[CP] &gt; CFLOW := cflow(P);
    set[CP] Root := CFLOW.entry;  %% define these fields somewhere
    rel[CP,CP] Pred := CFLOW.rel;

    {Id | &lt;EXP E, PICO-ID Id&gt; : range(Uses),
                 E in reachX(Root, Defs[-,Id], Pred)
    }
}</programlisting>Questions (UPDATE THIS):</para>

      <itemizedlist>
        <listitem>
          <para>There is, maybe, a typing issue here. De type of
          <literal>reachX</literal> is:</para>

          <para><literal>set[&amp;T] reachX(set[&amp;T]
          Start,</literal></para>

          <para><literal> set[&amp;T] Excl, </literal></para>

          <para><literal> rel[&amp;T,&amp;T] Rel)</literal></para>

          <para>but <literal>E</literal> has type <literal>EXP</literal>,
          <literal>{ROOT}</literal> has type
          <literal>set[STATEMENT]</literal>, and <literal>cflow</literal> has
          type <literal>rel[CP,CP]</literal>, with <literal>EXP | STATEMENT
          -&gt; CP</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico common subsexpression elimination (UPDATE)</title>

      <para><programlisting>module Pico-common-subexpression

fun PROGRAM cse(PROGRAM P) {
    rel[STATEMENT, PICO-ID] Defs := defs(P);
    rel[CP,CP] Pred := cflow(P).rel
 
    using P do { replace E2 by Id |
                 STATEMENT S : P,
                 [| $(PICO-ID Id) := $(EXP E) |] == S,
                 Id notin E,
                 EXP E2 : reachX({S}, Defs[-,Id], Pred)
               }
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions E2 by Id, such
      that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>Id does not occur in E,</para>
        </listitem>

        <listitem>
          <para>E2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and E2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico constant propagation (UPDATE)</title>

      <para><programlisting>module Pico-constant-propagation

fun Boolean is-constant(EXP E) {
   Int Int;
   Str Str;
   select (E){
   [| $Int |] =&gt; true

   [| $Str |] =&gt; true

   [| $E |] =&gt; false
   }
}

fun &amp;TERM replace(&amp;TERM T, rel[&amp;SUBTERM, &amp;SUBTERM] R)

fun PROGRAM cp(PROGRAM P) {
    rel[STATEMENT, PICO-ID] Defs := defs(P);
    rel[CP,CP] Pred := cflow(P).rel;
    replace { &lt;Id2, E&gt; |
              STATEMENT S : P,
              [| $(PICO-ID Id) := $(EXP E) |] == S,
              is-constant(E),
              PICO-ID Id2 : reachX({S},Defs[-,Id],Pred),
              Id2 == Id     
            } in P

or:
   replace P {
     Id2 =&gt; E
     when STATEMENT S : P,
          [| $(PICO-ID Id) := $(EXP E) |] == S,
          is-constant(E),
          PICO-ID Id2 : reachX({S},Defs[-,Id],Pred),
          Id2 == Id     
   }
    
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions Id2 by the constant E,
      such that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>E is constant,</para>
        </listitem>

        <listitem>
          <para>Id2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>Id2 is equal to Id,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and Id2.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Syntax Definition (THIS DEFINITION IS OBSOLETE)</title>

    <para><programlisting>lexical syntax
  [0-9]+    -&gt; NatCon
  "true"    -&gt; BoolCon
  "false"   -&gt; BoolCon
  [\0-\255] -&gt; ByteCon

context-free syntax
  %% foreach symbol S in the user-defined grammar:
  S                                 -&gt; Term {cons("to-term")}
  Term                              -&gt; S    {cons("from-term")}
  Type "(" Term ")"                 -&gt; Term {cons("cast")}
  Name "(" {Term ","}* ")"          -&gt; Term {cons("function")}
  "[" {Term ","}* "]"               -&gt; Term {cons("list")}
  "{" {Term ","}* "}"               -&gt; Term {cons("set")}
  "[" Term "|" {Generator ","}+ "]" -&gt; Term {cons("list-comprehension")}
  "{" Term "|" {Generator ","}+ "}" -&gt; Term {cons("set-comprehension")}
  "&lt;" {Term ","}* "&gt;"               -&gt; Term {cons("tuple")}
  "[" Term ":" Term "]"             -&gt; Term {cons("list-construction")}
  "{" Term ":" Term "}"             -&gt; Term {cons("set-construction")}
  BoolCon                           -&gt; Term {cons("boolean")}
  NatCon                            -&gt; Term {cons("number")}
  ByteCon                           -&gt; Term {cons("blob")}

context-free syntax
  Term "in" Term    -&gt; Term
  Term "union" Term -&gt; Term
  "#" Term          -&gt; Term
  %% etcetera

context-free syntax
  "module" ModuleName Section*    -&gt; Module

context-free syntax
  "variables" VariableDefinition* -&gt; Section
  Definition Rule*                -&gt; Section
  "equations" Rule*               -&gt; Section
  "tests" Test*                   -&gt; Section
  Modifier+ Section               -&gt; Section {non-assoc} %% to distribute modifiers over all 
                                                         %% elements of a section

  Modifier* Name "(" {Type ","}* ")" "-&gt;" Type -&gt; Definition
  Modifier* {Name ","}+ "-&gt;" Type              -&gt; VariableDefinition 
  "bottom-up"                                  -&gt; Modifier
  "top-down"                                   -&gt; Modifier
  "break"                                      -&gt; Modifier
  "continue"                                   -&gt; Modifier
  "loop"                                       -&gt; Modifier
  "strict"                                     -&gt; Modifier
  "wild"                                       -&gt; Modifier
  "exports"                                    -&gt; Modifier
  "hiddens"                                    -&gt; Modifier

context-free syntax
  Term "=" Term                         -&gt; Rule %% type preserving
  Term "=" Term "when" {Condition ","}+ -&gt; Rule
  {Condition ","}+ "===&gt;" Term "=" Term -&gt; Rule

context-free syntax
  Condition                             -&gt; Test
  {Condition ","}+ "===&gt;" Condition     -&gt; Test
  Condition "when" {Condition ","}+     -&gt; Test

context-free syntax
  Term ":=" Term  -&gt; Condition {cons("match")}     
  Term "!:=" Term -&gt; Condition {cons("not-match")}
  Term "==" Term  -&gt; Condition {cons("equals")}
  Term "!=" Term  -&gt; Condition {cons("not-equals")}
  Term "::" Term  -&gt; Condition {cons("generator")}  %% only applicable in comprehensions for now, 
                                                    %% not rules (although a semantics similar to 
                                                    %% list matching might apply, i.e. find the first 
                                                    %% element that satisfies the following conditions)

context-free syntax
  %% Symbol from the Sdf definition of Sdf:
  Symbol                    -&gt; Type
  "&amp;" Type                  -&gt; Type
  TypeName                  -&gt; Type
  "list" "[" Type "]"       -&gt; Type
  "set" "[" Type "]"        -&gt; Type

  "rel" "[" {Type ","}+ "]" -&gt; Type
  "&lt;" {Type","}* "&gt;"        -&gt; Type
  "void"                    -&gt; Type
  "natural"                 -&gt; Type
  "boolean"                 -&gt; Type
  "loc"                     -&gt; TYpe</programlisting></para>
  </section>

  <section>
    <title>Integration with Tscripts (UPDATE THIS)</title>

    <section>
      <title>Introduction</title>

      <para>It is possible to speculate on an even further integration of
      formalisms and combining the above amalgan of ASF+SDF and Rscript with
      Tscripts.</para>
    </section>

    <section>
      <title>Requirements</title>

      <itemizedlist>
        <listitem>
          <para>R12: The resulting language uses a single type system. This
          means that relational types (possible including syntactic objects)
          can be used in Tscripts.</para>
        </listitem>

        <listitem>
          <para>R13: The current "expressions" in Tscript (terms that occur at
          the rhs of an assignment) are replaced by calls to ASF+SDF or
          Rscript functions.</para>
        </listitem>

        <listitem>
          <para>R14: There is minimal duplication in functionality between
          ASF+SDF/Rscript/Tscript.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Different styles of Type Declarations</title>

      <para>We have at the moment, unfortunately, a proliferation of
      declaration styles for types.</para>

      <para>Functions are declared in ASF+SDF as:</para>

      <programlisting>typecheck(PROGRAM) -&gt; Boolean</programlisting>

      <para>Observe that only the type of the parameter is given but that it
      does not have a name.</para>

      <para>In Rscript we have:</para>

      <programlisting>int sum(set[int] SI) = ...</programlisting>

      <para>while in Tscript processes are declared as</para>

      <programlisting>process mkWave(N : int) is ...</programlisting>

      <para>For variables a similar story applies. Variables are declared in
      ASF+SDF as:</para>

      <programlisting>"X" [0-9]+    -&gt; INT</programlisting>

      <para>In Rscript we have:</para>

      <programlisting>int X

int X : S   (in comprehensions)</programlisting>

      <para>and in Tscript we have:</para>

      <programlisting>X : int</programlisting>

      <para>In order to unify these styles, we might do the following:</para>

      <itemizedlist>
        <listitem>
          <para>The type of an entity is always written before the entity
          itself.</para>
        </listitem>

        <listitem>
          <para>Formal parameters have a name.</para>
        </listitem>
      </itemizedlist>

      <para>In essence, this amounts to using the declaration style as used in
      Rscript. So we get:</para>

      <programlisting>Boolean typecheck(PROGRAM P) is ...

process mkWave(int N) is ...</programlisting>

      <para>Or do we want things like:</para>

      <programlisting>function typecheck(P : PROGRAM) -&gt; Boolean is ...

var X -&gt; int

process mkWave(int N) is ...</programlisting>

      <para>Advantages are:</para>

      <itemizedlist>
        <listitem>
          <para>The category of the entity is immediately clear (function,
          var, process, tool, ...).</para>
        </listitem>

        <listitem>
          <para>It is readable to further qualify the category, i.e.,
          traversal function, hidden var, restartable tool)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Global Flow of Control</title>

      <para>We have to settle the possible flow of control between the three
      entities ASF+SDF, Rscript and Tscript. Since Tscript imposes the notion
      of an atomic action it would be problematic to have completely
      unrestricted flow of control. Therefore it is logical to use Tscript for
      the top-level control and to limit the use of ASF+SDF and Rscript to
      computations within atomic actions. There is no reason to restrict the
      flow of control between ASF+SDF and Rscript.</para>

      <para>What are the consequences of the above choice? Let's analyze two
      cases:</para>

      <itemizedlist>
        <listitem>
          <para>Parse a file from within an ASF+SDF specification. This (and
          similar built-ins) that use the operating system are removed from
          ASF+SDF. Their effect has to be achieved at the Tscript-level which
          is the natural place for such primitives.</para>
        </listitem>

        <listitem>
          <para>Describe I/O for a defined language. Consider Pico extended
          with a read statement. Here the situation is more complicated. We
          cannot argue that the flow of control in the Pico program (as
          determined by an interpreter written in ASF+SDF) should be moved to
          the Tscript level since Tscript simply does not have the primitives
          to express this. On the other hand, we have to interrupt the flow of
          control of the Pico interpreter when we need to execute a read
          statement. The obvious way to achieve this is</para>

          <itemizedlist>
            <listitem>
              <para>At the Tscript level, a loop repeatedly calls the Pico
              interpreter until it is done.</para>
            </listitem>

            <listitem>
              <para>After each call the Pico interpreter returns with
              either:</para>

              <itemizedlist>
                <listitem>
                  <para>An indication that the eecution is complete (and
                  possibly a final state and/or final value).</para>
                </listitem>

                <listitem>
                  <para>An indication that an external action has to be
                  executed, for instance the read statement. This indication
                  should also contain the intermediate state of the
                  interpreter. When the external action has been executed, the
                  Pico interpreter can be restarted with as arguments the
                  value of the external action and the intermediate
                  state.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Experimentation will have to show whether such a framework is
      acceptable.</para>
    </section>

    <section>
      <title>Modularization</title>

      <para>Rscript and Tscript have no, respectively, very limited mechanisms
      for modularization. ASF+SDF, however, provides a module mechanism with
      imports, hiding, parameters and renaming. This mechanism was originally
      included in ASF, was taken over by SDF and is now reused in ASF+SDF.
      Currently, there are not yet sufficiently large Rscripts to feel the
      need for modules. In Tscript, there is a strong need for restricted name
      spaces and for imposing limitations on name visibility in order to limit
      the possible interactions of a process with its surroundings and to make
      it possible to create nested process definitions. What are the design
      options we have to explore?</para>

      <para>First, we can design a new module system that is more suited for
      our current requirements. The advantage is that we can create an optimal
      solution, the disadvantage is that there are high costs involved
      regarding implementation effort and migrations of existing ASF+SDF
      specifications to the new module scheme.</para>

      <para>Second, we can design an add-on to the ASF+SDF module system that
      addresses our current needs.</para>

      <para>Third, we can try to reuse the current ASF+SDF module
      system.</para>

      <para>As a general note, parameterized modules, polymorphics types and
      renamings are competing features. We should understand what we want. It
      is likely that we do not need all of them.</para>

      <para>Before delving into one of the above alternative approaches, let's
      list our requirements first.</para>

      <itemizedlist>
        <listitem>
          <para>We need grammar modules that allow the following operations:
          import, renaming, deletion (currently not supported but important to
          have a fixed base grammar on many variations on it).
          Parameterization and export/hidden: unclear.</para>
        </listitem>

        <listitem>
          <para>We need function modules (ASF+SDF and Rscript) that provide:
          import, maybe parametrization, and export/hidden.</para>
        </listitem>

        <listitem>
          <para>We need process modules (Tscript) that provide: import,
          export, hiding.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title xml:id="Issues">Issues</title>

    <itemizedlist>
      <listitem>
        <para>The <emphasis role="bold">replace</emphasis> construct needs
        more thought.</para>

        <itemizedlist>
          <listitem>
            <para>Can we better enforce that the replacements occur in
            <replaceable>Term</replaceable>?</para>
          </listitem>

          <listitem>
            <para>Is this the right approach to get rid of indications for
            bottom-up/topdown and continue/break?</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>How will we quote patterns and terms? Currently we use the
        convention:</para>

        <itemizedlist>
          <listitem>
            <para>Pattern is enclosed between [| and |]</para>
          </listitem>

          <listitem>
            <para>Variable are prefixed with $</para>
          </listitem>

          <listitem>
            <para>A declared variable is written as $(Type Var).</para>
          </listitem>

          <listitem>
            <para>A subterm to be reduced is also prefixed with $.</para>
          </listitem>

          <listitem>
            <para>Examples:</para>

            <itemizedlist>
              <listitem>
                <para>[| while $Exp do $Stats od |]</para>
              </listitem>

              <listitem>
                <para>{&lt;S, Id&gt; | STATEMENT S : P, [| $(PICO-ID Id) :=
                $(EXP Exp) |] == S}</para>
              </listitem>

              <listitem>
                <para>[| let $Y = $rename(E1) in $rename(E2) end |]</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>This is good for disambiguation but gives notational overhead.
        Is there a more concise scheme?</para>
      </listitem>

      <listitem>
        <para>Dynamic variables need more thought.</para>
      </listitem>

      <listitem>
        <para>Do we add column names in relations (as Jurgen and Bob are
        currently doing)?</para>
      </listitem>

      <listitem>
        <para>We keep the polymorphic types &amp;T1 as in Rscript.</para>
      </listitem>

      <listitem>
        <para>Do we want string variables in patterns?</para>
      </listitem>

      <listitem>
        <para>List matching?</para>
      </listitem>

      <listitem>
        <para>Do we want to add regular expression matching primitives to
        patterns? Ex.</para>

        <itemizedlist>
          <listitem>
            <para>[| if @any@ $Stats fi |]</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>How do we identify built-in sorts (bool, int, etc) with their
        syntactic counterparts?</para>
      </listitem>

      <listitem>
        <para>What happens if no case in a select matches?</para>
      </listitem>

      <listitem>
        <para>Unexplored idea: add (possibly lazy) generators for all types;
        this allows to generate, for instance, all statements in a
        program.</para>
      </listitem>
    </itemizedlist>
  </section>
</article>