<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
]>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns6="http://www.w3.org/1999/xhtml"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>The Language Specification Formalism ASF+SDF</title>

    <pubdate>$Rev: 20719$ by $Author: paulk$ at $Date: 2006-12-13 22:16:02
    +0100 (Wed, 13 Dec 2006)$</pubdate>

    <authorgroup>
      <author>
        <personname><firstname>Mark</firstname><surname>van den
        Brand</surname></personname>
      </author>

      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <warning>
    <para>This document is work in progress. It is in transition between The
    Meta-Enviroment V1.5 and V2.0.</para>
  </warning>

  <section>
    <title>An Introduction to ASF+SDF</title>

    <para>ASF+SDF is intended for the high-level, modular, description of the
    syntax <emphasis>and</emphasis> semantics of computer-based formal
    languages. It is the result of the marriage of two formalisms ASF
    (Algebraic Specification Formalism) and SDF (Syntax Definition
    Formalism).</para>

    <para>ASF is based on the notion of a module consisting of a signature
    defining the abstract syntax of functions and a set of conditional
    equations defining their semantics. Modules can be imported in other
    modules.</para>

    <para>SDF allows the simultaneous definition of concrete (i.e., lexical
    and context-free) and abstract syntax and implicitly defines a translation
    from text strings to syntax trees. See The Syntax Definion Formalism SDF
    for complete coverage of SDF.</para>

    <para>The main idea of ASF+SDF is to identify the abstract syntax defined
    by the signature in ASF specifications with the abstract syntax defined
    implicitly by an SDF specification, thus yielding a standard mapping from
    text to abstract syntax tree. This allows the association of semantics
    with (the tree representation of) text and introduces user-defined
    notation in specifications. ASF+SDF is therefore a modular specification
    formalism for the integrated definition of syntax and semantics of a
    (programming) language. Other views on ASF+SDF are:</para>

    <itemizedlist>
      <listitem>
        <para>a first-order functional programming language with</para>

        <itemizedlist>
          <listitem>
            <para>user-defined synyax,</para>
          </listitem>

          <listitem>
            <para>tree traversal capabilities</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>an algebraic specification formalism.</para>
      </listitem>
    </itemizedlist>

    <para>Whatever viewpoint is taken, ASF+SDF is a powerful formalism for the
    declarative description of programming languages and meta programs.</para>

    <para>Each module <replaceable>M</replaceable> in an SDF specification is
    stored in a file <replaceable>M</replaceable><literal>.sdf</literal>. To
    each module <replaceable>M</replaceable> one can simply add equations as
    needed by providing them in a file
    <replaceable>M</replaceable><literal>.asf</literal>. The result is an
    ASF+SDF specification. We call
    <replaceable>M</replaceable><literal>.sdf</literal> the <emphasis>SDF
    part</emphasis> of module <replaceable>M</replaceable> and
    <replaceable>M</replaceable><literal>.asf</literal> the <emphasis>ASF
    part</emphasis> of <replaceable>M</replaceable>.</para>

    <para>We will now describe the ingredients of the ASF part of
    modules:</para>

    <itemizedlist>
      <listitem>
        <para>Simple Equations: unconditional and conditional
        equations.</para>
      </listitem>

      <listitem>
        <para>Advanced Equations: default equations, list matching, memo
        functions, lexical functions, traversal functions.</para>
      </listitem>

      <listitem>
        <para>Tests.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="SimpleEquations">
    <title>Simple Equations</title>

    <!--\index{equations@equations} \index{Asf+Sdf@\asfsdf}-->

    <para>With equations a meaning or semantics may be added to functions
    declared in the lexical and context-free syntax sections. In particular,
    equations consist of two \emph{open terms}, i.e. terms possibly containing
    variables. In the context of ASF+SDF, an open term is any string that can
    be parsed according to one of the sorts in the specification (possibly
    including variables). Examples of (open) terms are
    <literal>true</literal>, <literal>not(false)</literal>, and <literal>true
    | Bool</literal>.</para>

    <section xml:id="UnconditionalEquations">
      <title>Unconditional Equations</title>

      <!--\index{unconditional equations@unconditional equations}-->

      <para>An equality then consists of two (possibly open) terms
      <replaceable>L</replaceable> (lefthand side) and
      <replaceable>R</replaceable> (righthand side) such that:</para>

      <itemizedlist>
        <listitem>
          <para><replaceable>L</replaceable> and <replaceable>R</replaceable>
          are of the same sort.</para>
        </listitem>

        <listitem>
          <para><replaceable>L</replaceable> is not a single variable.</para>
        </listitem>

        <listitem>
          <para>The variables that occur in <replaceable>R</replaceable> also
          occur in <replaceable>L</replaceable>.</para>
        </listitem>
      </itemizedlist>

      <para>It is assumed that the variables occurring in the equation are
      universally quantified. In other words, the equality holds for all
      possible values of the variables. The equality of two terms
      <replaceable>L</replaceable> and <replaceable>R</replaceable> is defined
      in ASF+SDF by the following <emphasis>unconditional</emphasis>
      equation:<programlisting>[<replaceable>TagId</replaceable>] <replaceable>L</replaceable> = <replaceable>R</replaceable></programlisting>where
      <replaceable>TagId</replaceable> is a sequence of letters, digits,
      and/or minus signs (<literal>-</literal>) starting with a letter or a
      digit.</para>
    </section>

    <section xml:id="ConditionalEquations">
      <title>Conditional Equations</title>

      <!--\index{conditional equations@conditional equations}-->

      <para>An unconditional equation is a special case of a
      <emphasis>conditional equation</emphasis>, i.e., an equality with one or
      more associated conditions (premises). The equality is sometimes called
      the <emphasis>conclusion</emphasis> of the conditional equation. In
      ASF+SDF a conditional equation can be written in three (syntactically
      different, but semantically equivalent) ways. Using
      <literal>when</literal><programlisting>[<replaceable>TagId</replaceable>]  <replaceable>L</replaceable> = <replaceable>R</replaceable> when <replaceable>C</replaceable><subscript>1</subscript>, <replaceable>C</replaceable><subscript>2</subscript>, ...</programlisting>or
      using an implication arrow <literal>===&gt;</literal><programlisting>[<replaceable>TagId</replaceable>]  <replaceable>C</replaceable><subscript>1</subscript>, <replaceable>C</replaceable><subscript>2</subscript>, ... ===&gt; <replaceable>L</replaceable> = <replaceable>R</replaceable></programlisting>or
      using a horizontal bar</para>

      <para><programlisting>[<replaceable>TagId</replaceable>]  <replaceable>C</replaceable><subscript>1</subscript>, <replaceable>C</replaceable><subscript>2</subscript>, ... 
        =============
           <replaceable>L</replaceable> = <replaceable>R</replaceable></programlisting></para>

      <para>where <replaceable>C</replaceable><subscript>1</subscript> ,
      <replaceable>C</replaceable><subscript>2</subscript> , ... are
      conditions which may be of one of the following forms:</para>

      <itemizedlist>
        <listitem>
          <para>match: <replaceable>S</replaceable><literal> :=
          </literal><replaceable>T</replaceable></para>
        </listitem>

        <listitem>
          <para>non-match: <replaceable>S</replaceable><literal>
          !:=</literal><replaceable> T</replaceable></para>
        </listitem>

        <listitem>
          <para>equality (positive): <replaceable>S</replaceable><literal>
          ==</literal><replaceable> T</replaceable> (also known as
          <emphasis>positive</emphasis> condition)</para>
        </listitem>

        <listitem>
          <para>non-equality: <replaceable>S</replaceable><literal> !=
          </literal><replaceable>T</replaceable> (also known as
          <emphasis>negative</emphasis> condition)</para>
        </listitem>
      </itemizedlist>

      <para>The conditions of an equation are evaluated from left to right.
      Let, initially, <replaceable>Vars</replaceable> be the set of variables
      occurring in the left-hand side <replaceable>LVars</replaceable> of the
      conclusion of the equation.</para>

      <para>Match conditions are evaluated as follows. The left-hand side of a
      matching condition must contain at least one new or fresh variable not
      in <replaceable>Vars</replaceable>. Reduce the right-hand side of the
      match condition to a normal form and the match condition succeeds if
      this normal form and the left-hand side of the condition match. The new
      variables resulting from this match are added to
      <replaceable>Vars</replaceable>.</para>

      <important>
        <para>The variables occurring in both <replaceable>Vars</replaceable>
        and the left-hand side must represent the syntactically the same
        subterm.</para>
      </important>

      <para>For the evaluation of each equality condition we require that the
      condition contains only variables in <replaceable>Vars</replaceable>.
      Reduce both sides of the condition to normal form and the condition
      succeeds if both normal forms are identical. Technically, this is called
      a <emphasis>join</emphasis> condition. The evaluation of negative
      conditions is described by replacing in the above description
      `identical' and `match' by `not identical' and `do not match',
      respectively. <important>
          <para>It is not allowed to introduce new variables in a negative
          condition.</para>
        </important>After the successful evaluation of the conditions, all
      variables occurring in the right-hand side of the conclusion of the
      equation should be in <replaceable>Vars</replaceable>. New variables
      (see above) should therefore <emphasis>not</emphasis> occur on
      <emphasis>both</emphasis> sides of a positive condition, in a negative
      condition, or in the right-hand side of the conclusion.</para>
    </section>

    <section xml:id="ExecutingEquations">
      <title>Executing Equations</title>

      <!--\index{leftmost-innermost@leftmost-innermost} \index{rewrite rules@rewrite rules} \index{default equations@default equations}-->

      <para>In the ASF+SDF Meta-Environment, equations can be executed as
      <emphasis>rewrite rules</emphasis>. The above equation is thus executed
      as the rewrite rule <replaceable>L</replaceable> -&gt;
      <replaceable>R</replaceable>. This can be used to reduce some initial
      closed term (i.e., not containing variables) to a <emphasis>normal
      form</emphasis> (i.e., a term that is not reducible any further) by
      repeatedly applying rules from the specification. A term is always
      reduced in the context of a certain module, say
      <replaceable>M</replaceable>. The rewrite rules that may be used for the
      reduction of the term are the rules declared in
      <replaceable>M</replaceable> itself and in the modules that are
      (directly or indirectly) imported by <replaceable>M</replaceable>. The
      search for an applicable rule is determined by the reduction strategy,
      that is, the procedure used to select a subterm for possible reduction.
      In our case the<emphasis> leftmost-innermost</emphasis> reduction
      strategy is used. This means that a left-to-right, depth-first traversal
      of the term is performed and that for each subterm encountered an
      attempt is made to reduce it. Next, the rules are traversed one after
      the other. The textual order of the rules is irrelevant, but <link
      linkend="DefaultEquations">default equations</link> come last.</para>

      <important>
        <para>A specification should always be <emphasis>confluent</emphasis>
        and <emphasis>terminating</emphasis>. Confluent means that the order
        in which the rules are applied has no effect on the outcome.
        Terminating means that the application of rules cannot go on
        indefinitely. We do not check for these two properties.</para>
      </important>

      <para> If the selected subterm and the left-hand side of a rule (more
      precisely: of the left-hand side of its conclusion) match, we say that a
      <emphasis>redex</emphasis> has been found and the following happens. The
      conditions of the rule are evaluated and if the evaluation of a
      condition fails, other rules (if any) with matching left-hand sides are
      tried. If the evaluation of all conditions succeeds, the selected
      subterm is replaced by the right-hand side of the rule (more precisely:
      the right-hand side of the conclusion of the rule) after performing
      proper <emphasis>substitutions</emphasis>. Substitutions come into
      existence by the initial matching of the rule and by the evaluation of
      its conditions. For the resulting term the above process is repeated
      until no further reductions are possible and a normal form is reached
      (if any).</para>
    </section>

    <section>
      <title>Examples</title>

      <para>We give here a number of elementary examples with the sole purpose
      to illustrate a range of features of ASF+SDF:</para>

      <itemizedlist>
        <listitem>
          <para><link linkend="AdditionMultiplicationOfNumerals">Addition and
          Multiplication on Numerals</link>.</para>
        </listitem>

        <listitem>
          <para><link linkend="Booleans">Booleans</link>: simple truth values
          and operations.</para>
        </listitem>

        <listitem>
          <para><link linkend="FriendlyBooleans">FriendlyBooleans</link>:
          truth values with user-defined syntax.</para>
        </listitem>
      </itemizedlist>

      <para>For larger and more <emphasis>interesting</emphasis> examples, we
      refer to XXX.</para>

      <important>
        <para>Add ref</para>
      </important>

      <section xml:id="AdditionMultiplicationOfNumerals">
        <title>Addition and Multiplication on Numerals</title>

        <para>The natural numbers 0, 1, 2, ... can be represented in a form
        that is more convenient for formal reasoning:</para>

        <itemizedlist>
          <listitem>
            <para>0 is represented by <literal>0</literal>.</para>
          </listitem>

          <listitem>
            <para>1 is represented by <literal>succ(0)</literal>.</para>
          </listitem>

          <listitem>
            <para>2 is represented by <literal>succ(succ(0))</literal>.</para>
          </listitem>

          <listitem>
            <para>...</para>
          </listitem>

          <listitem>
            <para>The number <replaceable>N</replaceable> is represented by
            <literal>succ</literal><superscript><replaceable>N</replaceable></superscript><literal>(0)</literal>,
            i.e., <replaceable>N</replaceable> applications of
            <literal>succ</literal> to <literal>0</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>Let's first formalize the grammar of these numeralsin an SDF
        definition:</para>

        <example xml:id="EX_Numerals">
          <title>SDF Definition of Numerals</title>

          <programlisting linenumbering="numbered">module Numerals
exports
 sorts NUM                   <co xml:id="co.num" />
 imports basic/Whitespace    <co xml:id="co.whitespace" />
  context-free syntax
      "0"          -&gt; NUM    <co xml:id="co.0" />
      succ(NUM)    -&gt; NUM    <co xml:id="co.succ" />
  context-free start-symbols
      NUM                    <co xml:id="co.start-num" /></programlisting>

          <para>Notes:</para>

          <calloutlist>
            <callout arearefs="co.num">
              <para>Declares the sort <literal>NUM</literal> that will
              represent all numerals.</para>
            </callout>

            <callout arearefs="co.whitespace">
              <para>Import the library module basic/Whitespace in order to
              define layout and comments.</para>
            </callout>

            <callout arearefs="co.0">
              <para>Define the constant <literal>0</literal>.</para>
            </callout>

            <callout arearefs="co.succ">
              <para>Define the succesor function <literal>succ</literal>. Note
              that we use a prefix function here; the unabbreviated definition
              would be</para>

              <programlisting>"succ" "(" NUM ")" -&gt; NUM</programlisting>
            </callout>

            <callout arearefs="co.start-num">
              <para>Declare <literal>NUM</literal> as start symbol to enable
              the parsing of <literal>NUM</literal>s.</para>
            </callout>
          </calloutlist>
        </example>

        <important>
          <para>It is a common mistake to forget to either include
          <literal>basic/Whitespace</literal> or to define layout and comments
          yourself. The effect will be that you get seemingly unexplainable
          parse errors in your equations.</para>
        </important>

        <important>
          <para>If you forget the definition of a start symbol, no input terms
          can be parsed for the sort that you are probably interested in.
          Better safe than sorry: add start symbols.</para>
        </important>

        <para>Having defined numerals, we can parse texts like
        <literal>0</literal>, <literal>succ(0)</literal>, etc. as
        syntactically correct NUMs.</para>

        <para>The next step is to define addition and multiplication on
        numerals. Let's start with addition. We do this by introducing a
        module Adder that defines syntax for the add function and also defines
        its meaning.</para>

        <example>
          <title><literal>Adder.sdf</literal>: the SDF part of the Adder
          module</title>

          <programlisting>module Adder
exports
  imports Numerals                    <co xml:id="co.imp-numerals" />
  context-free syntax
      add(NUM, NUM)  -&gt; NUM           <co xml:id="co.add" /> 
  variables
      "<replaceable>X</replaceable>"            -&gt; NUM           <co
              xml:id="co.adder-x" />
      "<replaceable>Y</replaceable>"            -&gt; NUM</programlisting>

          <para>Notes:</para>

          <calloutlist>
            <callout arearefs="co.imp-numerals">
              <para>Import the previously defined module Numerals.</para>
            </callout>

            <callout arearefs="co.add">
              <para>Define the <literal>add</literal> function.</para>
            </callout>

            <callout arearefs="co.adder-x">
              <para>Define the variables <literal>X</literal> and
              <literal>Y</literal> of sort <literal>NUM</literal>. They will
              be sued in the equations.</para>
            </callout>
          </calloutlist>
        </example>

        <para>Now we are ready for the equations that define the add
        function:</para>

        <example>
          <title><literal>Adder.asf:</literal> the ASF part of the Adder
          module</title>

          <programlisting>equations                             <co
              xml:id="co.numerals-equations" />

[1] add(0, <replaceable>X</replaceable>) = <replaceable>X                     </replaceable><co
              xml:id="co.numerals-1" />
[2] add(succ(<replaceable>X</replaceable>), Y) = succ(add(<replaceable>X</replaceable>,<replaceable>Y</replaceable>))  <co
              xml:id="co.numerals-2" /></programlisting>

          <para>Notes:</para>

          <calloutlist>
            <callout arearefs="co.numerals-equations">
              <para>The ASF part starts with the keyword
              <literal>equations</literal>.</para>
            </callout>

            <callout arearefs="co.numerals-1">
              <para>First equation: adding <literal>0</literal> to an
              arbitrary numeral <replaceable>X</replaceable> yields that same
              numeral.</para>
            </callout>

            <callout arearefs="co.numerals-2">
              <para>Adding <replaceable>Y</replaceable> to the successor of
              <replaceable>X</replaceable> is the same as applying the
              successor to the addition of <replaceable>X</replaceable> and
              <replaceable>Y</replaceable>.</para>
            </callout>
          </calloutlist>
        </example>

        <para>After these preparations we can parse and reduce terms using the
        module Adder:</para>

        <itemizedlist>
          <listitem>
            <para>The term <literal>0</literal> reduces to
            <literal>0</literal> in zero steps; no simplifications are
            possible.</para>
          </listitem>

          <listitem>
            <para>The term <literal>succ(0)</literal> reduces to
            <literal>succ(0)</literal> in zero steps; no simplifications are
            possible.</para>
          </listitem>

          <listitem>
            <para>The term <literal>add(succ(succ(0)),
            succ(succ(0)))</literal> reduces to
            <literal>succ(succ(succ(succ(0))))</literal> in 3 steps; this
            corresponds to 2 + 2 = 4.</para>
          </listitem>
        </itemizedlist>

        <para>We complete this example by defining a multiplication operator
        on numerals as well.</para>

        <example>
          <title>Muliplier.sdf</title>

          <programlisting>module Multiplier
exports
  imports Adder                       <co xml:id="co.multiplier-import-adder" />
  context-free syntax
    mul(NUM,NUM) -&gt; NUM               <co xml:id="co.multiplier-mul" /></programlisting>

          <para>Notes:</para>

          <calloutlist>
            <callout arearefs="co.multiplier-import-adder">
              <para>Import the previoulsy defined module Adder.</para>
            </callout>

            <callout arearefs="co.multiplier-mul">
              <para>Define the syntax of the function mul.</para>
            </callout>
          </calloutlist>
        </example>

        <para>The equations that define <literal>mul</literal> are as
        follows:</para>

        <example>
          <title>Multiplier.asf</title>

          <para><programlisting>equations

[1] mul(0, <replaceable>X</replaceable>) = 0                      <co
                xml:id="co.multiplier-mul-1" />
[2] mul(succ(<replaceable>X</replaceable>), Y) = add(mul(<replaceable>X</replaceable>,<replaceable>Y</replaceable>), <replaceable>Y</replaceable>) <co
                xml:id="co.multiplier-mul-2" /></programlisting>Notes:<calloutlist>
              <callout arearefs="co.multiplier-mul-1">
                <para>Multiplying any numeral by zero yields zero.</para>
              </callout>

              <callout arearefs="co.multiplier-mul-2">
                <para>Reduce multiplication to addition: multiplying
                <replaceable>Y</replaceable> by <replaceable>X</replaceable>+1
                is the same as multiplying <replaceable>Y</replaceable> by
                <replaceable>X</replaceable> and then adding
                <replaceable>Y</replaceable>.</para>
              </callout>
            </calloutlist></para>
        </example>

        <para>We can now parse and reduce terms using the module
        Multiplier:</para>

        <itemizedlist>
          <listitem>
            <para>The term <literal>mul(succ(succ(succ(0))),
            succ(succ(0)))</literal> reduces to
            <literal>succ(succ(succ(succ(succ(succ(0))))))</literal>; this
            corresponds to 3 * 2 = 6.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="Booleans">
        <title>Booleans</title>

        <para>The Boolean constants <literal>true</literal> and
        <literal>false</literal> and the Boolean functions
        <literal>and</literal>, <literal>or</literal> and
        <literal>not</literal> are also completely elementary and therefore
        well-suited for illustrating some more features of ASF+SDF. The syntax
        of Booleans is given in <link
        linkend="Booleans.sdf">Booleans.sdf</link>.</para>

        <example xml:id="Booleans.sdf">
          <title>Booleans.sdf</title>

          <programlisting>module Booleans
exports
  sorts BoolCon                        <co xml:id="co.booleans.boolcon" />
  context-free syntax
     "true"  -&gt; BoolCon                <co xml:id="co.booleans.true" />
     "false" -&gt; BoolCon

  sorts Boolean                        <co xml:id="co.booleans.boolean" />
  context-free start-symbols           <co xml:id="co.booleans.startsymbols" />
        Boolean
  context-free syntax
     BoolCon               -&gt; Boolean  <co
              xml:id="co.booleans.boolcon-boolean" />
     and(Boolean, Boolean) -&gt; Boolean  <co xml:id="co.booleans.and" />
     or(Boolean,Boolean)   -&gt; Boolean  
     not(Boolean)          -&gt; Boolean  

hiddens                                <co xml:id="co.booleans.hiddens" />
  imports basic/Comments               <co xml:id="co.booleans.comments" />
  variables
     "<replaceable>B</replaceable>" -&gt; Boolean                    <co
              xml:id="co.booleans.var" /></programlisting>

          <para>Notes:</para>

          <calloutlist>
            <callout arearefs="co.booleans.boolcon">
              <para>Introduce the sort BoolCon that will represent the
              constants <literal>true</literal> and <literal>false</literal>.
              It is good practice to define constants as a separate
              sort.</para>
            </callout>

            <callout arearefs="co.booleans.true">
              <para>Here are the definitions of the constants
              themselves.</para>
            </callout>

            <callout arearefs="co.booleans.boolean">
              <para>Introduce our sort of interest:
              <literal>Boolean</literal>.</para>
            </callout>

            <callout arearefs="co.booleans.startsymbols">
              <para>Since we will be dealing with Boolean terms, it is
              mandatory that they can be parsed. Hence we need to define a
              start symbol for them.</para>
            </callout>

            <callout arearefs="co.booleans.boolcon-boolean">
              <para>Every Boolean constant <literal>BoolCon</literal> is a
              <literal>Boolean</literal>.</para>
            </callout>

            <callout arearefs="co.booleans.and">
              <para>Definition of <literal>and</literal>,
              <literal>or</literal> and <literal>not</literal>.</para>
            </callout>

            <callout arearefs="co.booleans.hiddens">
              <para>It is good practice to define comments (as needed in the
              equations) and variables as hidden. This has the advantage that
              comment conventions and variable declaration do propagate to the
              modules that import the current module.</para>
            </callout>

            <callout arearefs="co.booleans.comments">
              <para>Import standard comments.</para>
            </callout>

            <callout arearefs="co.booleans.var">
              <para>Define the single variable <replaceable>B</replaceable>
              for later use in the equations.</para>
            </callout>
          </calloutlist>
        </example>

        <para>After these preparations we are ready to parse Boolean terms
        like:</para>

        <itemizedlist>
          <listitem>
            <para><literal>true</literal></para>
          </listitem>

          <listitem>
            <para><literal>and(true,false)</literal></para>
          </listitem>

          <listitem>
            <para><literal>and(or(true,not(false)),true)</literal></para>
          </listitem>

          <listitem>
            <para><literal>or(true,
            <replaceable>B</replaceable>)</literal></para>
          </listitem>

          <listitem>
            <para>and so on and so forth.</para>
          </listitem>
        </itemizedlist>

        <para>The definition of the functions on Booleans now simply requires
        writing down the truth tables in the form of equations and is given in
        <link linkend="Booleans.asf">Booleans.asf</link>.</para>

        <example xml:id="Booleans.asf">
          <title>Booleans.asf</title>

          <programlisting>equations

[or1] or(true, true)     = true
[or2] or(true, false)    = true
[or3] or(false, true)    = true
[or4] or(false, false)   = false

[and1] and(true, true)   = true
[and2] and(true, false)  = false
[and3] and(false, true)  = false
[and4] and(false, false) = false

[not1] not(true) = false
[not2] not(false) = true</programlisting>
        </example>

        <para>We can now parse and reduce terms using Booleans:</para>

        <itemizedlist>
          <listitem>
            <para>The term <literal>true</literal> reduces to
            <literal>true</literal>.</para>
          </listitem>

          <listitem>
            <para>The term <literal>and(true,false)</literal> reduces to
            <literal>false</literal>.</para>
          </listitem>

          <listitem>
            <para>The term <literal>and(or(true,not(false)),true)</literal>
            reduces to <literal>true</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>As a final touch, a similar but shorter definition of the
        Boolean functions is possible. By using variable
        <replaceable>B</replaceable>, which we did declare but have not used
        so far, a shorter definition is possible see, for instance, the
        definition for <literal>or</literal> <link
        linkend="shorter-def-or">below</link>.</para>

        <example xml:id="shorter-def-or">
          <title>A shorter definition for <literal>or</literal>.</title>

          <programlisting>[or1'] or(true, <replaceable>B</replaceable>)  = true
[or2'] or(false, <replaceable>B</replaceable>) = <replaceable>B</replaceable></programlisting>
        </example>
      </section>

      <section xml:id="FriendlyBooleans">
        <title>Booleans with user-defined syntax</title>

        <para>The Booleans we have seen in the <link
        linkend="Booleans">previous example</link> are fine, but the strict
        prefix notation makes Boolean terms less readable. Would it be
        possible to use more friendly notation like <literal>true &amp;
        false</literal> instead of <literal>and(true, false)</literal> or
        <literal>true | false</literal> instead of <literal>or(true,
        false)</literal>?</para>

        <example xml:id="FriendlyBooleans.sdf">
          <title><literal>FriendlyBooleans.sdf</literal></title>

          <programlisting>module FriendlyBooleans
exports
  sorts BoolCon
  context-free syntax
     "true"  -&gt; BoolCon
     "false" -&gt; BoolCon

  sorts Boolean
  context-free start-symbols
        Boolean
  context-free syntax
     BoolCon               -&gt; Boolean
     Boolean "&amp;" Boolean   -&gt; Boolean {left}     <co
              xml:id="co.friendlybooleans-and" />
     Boolean "|" Boolean   -&gt; Boolean {left}
     not(Boolean)          -&gt; Boolean
     "(" Boolean ")"       -&gt; Boolean {bracket}  <co
              xml:id="co.friendlybooleans-bracket" />
  context-free priorities                        <co
              xml:id="co.friendlybooleans.priority" />
     Boolean "&amp;" Boolean -&gt; Boolean &gt;
     Boolean "|" Boolean -&gt; Boolean
hiddens
  imports basic/Comments
  variables
     "<replaceable>B</replaceable>" -&gt; Boolean</programlisting>

          <para>Notes:</para>

          <calloutlist>
            <callout arearefs="co.friendlybooleans-and">
              <para>Here the infix syntax for the and and or function is
              defined.</para>
            </callout>

            <callout arearefs="co.friendlybooleans-bracket">
              <para>Since we have infix functions, parentheses are needed for
              grouping.</para>
            </callout>

            <callout arearefs="co.friendlybooleans.priority">
              <para>A priority rules defines that <literal>&amp;</literal>
              binds stronger than <literal>|</literal>.</para>
            </callout>
          </calloutlist>
        </example>

        <para>After these preparations, the equations are shown in <link
        linkend="FriendlyBooleans.asf">FriendlyBooleans.asf</link>.</para>

        <example xml:id="FriendlyBooleans.asf">
          <title><literal>FriendlyBooleans.asf</literal></title>

          <programlisting>equations

[or1] true | <replaceable>B</replaceable>    = true
[or2] false | <replaceable>B</replaceable>   = <replaceable>B</replaceable>

[and1] true &amp; <replaceable>B</replaceable>   = <replaceable>B</replaceable>
[and2] false &amp; <replaceable>B</replaceable>  = false

[not1] not(true)  = false
[not2] not(false) = true</programlisting>
        </example>

        <important>
          <para>Something interesting is going on here: we defined syntax
          rules in <literal>FriendlyBooleans.sdf</literal> and use them here
          in <literal>FriendlyBooleans.sdf</literal>. This means that we use
          syntax in the equations that we have defined ourselves! Think about
          the implications of this: if we have an SDF definition for a
          programming language, we can easily write equations that contain
          programming language fragments. This unique feature makes ASF+SDF
          the ultimate language for writing program transformations.</para>
        </important>
      </section>
    </section>
  </section>

  <section xml:id="Equations">
    <title>Advanced Equations</title>

    <para>The simple equations described in the previous section are powerfull
    enough to formulate the solution of any computational problem. However,
    ASF+SDF provides some more advanced features that can make the life of the
    specification writer a lot simpler:</para>

    <itemizedlist>
      <listitem>
        <para><link linkend="DefaultEquations">Default equations</link>:
        equations that apply when no other equations is applicable.</para>
      </listitem>

      <listitem>
        <para><link linkend="ListMatching">List matching</link>: decompose and
        compose arbitrary lists.</para>
      </listitem>

      <listitem>
        <para><link linkend="MemoFunctions">Memo functions</link>: memoize the
        values of previous function invocations.</para>
      </listitem>

      <listitem>
        <para><link linkend="LexicalConstructorFunctions">Lexical constructor
        functions</link>: get acces to and modify the lexical (string)
        representation of programs.</para>
      </listitem>

      <listitem>
        <para><link linkend="TraversalFunctions">Traversal functions</link>:
        traverse complex structures with a minimal specification
        effort.</para>
      </listitem>
    </itemizedlist>

    <section xml:id="DefaultEquations">
      <title>Default Equations</title>

      <!--\index{default equations@default equations}-->

      <para>The evaluation strategy for normalizing terms given the equations
      is based on innermost rewriting. All equations have the same priority.
      Given the outermost function symbol of a redex the set of equations with
      this outermost function symbol in the left-hand side is selected and all
      these rules will be tried. However, sometimes a specification writer
      would like to write down a rule with a special status: <emphasis>try
      this rule if all other rules fail</emphasis>. A kind of default
      behaviour is needed. ASF+SDF offers functionality in order to obtain
      this behaviour. If the <replaceable>TagId</replaceable> of an equation
      starts with <literal>default-</literal> this equation is considered to
      be a special equation which will only be applied if no other rule
      matches. </para>

      <section>
        <title>Example: Comparing Types</title>

        <para>The modules <link
        linkend="CODE_types"><literal>Types.sdf</literal></link> and <link
        linkend="Types.asf">Types.asf</link> show an example of the use of a
        default equation. The problem we want to solve is as follows. Suppose
        we are solving a typechecking problem and have a sort
        <literal>Type</literal> that represents the possible types. It is
        likely that we will need a function <literal>compatible</literal> that
        checks whether two types are compatible, for instance, when they
        appear on the left-hand and right-hand side of an assignment statement
        or when the actual/formal correspondence of procedure parameters has
        to be checked. Potentially, Type may contain a lot of different type
        values and comparing them all is a combinatorial problem.</para>

        <example xml:id="CODE_types">
          <title>Types.sdf</title>

          <para><programlisting>module Types

imports basic/Whitespace
imports basic/Booleans

exports
  context-free start-symbols Type
  sorts Type

  context-free syntax
    "natural"     -&gt; Type
    "string"      -&gt; Type
    "nil-type"    -&gt; Type
    compatible(Type, Type) -&gt; Boolean

hiddens
  variables
    "<replaceable>Type</replaceable>"[0-9]*  -&gt; Type</programlisting></para>
        </example>

        <para>In Types.sdf, we define a sort <literal>Type</literal> that can
        have values <literal>natural</literal>, <literal>string</literal> and
        <literal>nil-type</literal>.</para>

        <example xml:id="Types.asf">
          <title>Types.asf</title>

          <programlisting>equations

  [Type-1]  compatible(natural, natural) = true
  [Type-2]  compatible(string, string)   = true
  [default-Type] 
            compatible(<replaceable>Type1</replaceable>,<replaceable>Type2</replaceable>)      = false </programlisting>
        </example>

        <para>In <link
        linkend="CODE_types"><literal>Types.sdf</literal></link>, we define
        three equations: two for checking the cases that the arguments of
        <literal>compatible</literal> are equal and one default equation for
        checking the remaining cases.</para>

        <para>An alternative definition is given in <link
        linkend="Types2.asf">Types2.asf</link> where equation
        <literal>[Type-1]</literal> has a left-hand side that contains the
        same variable (<replaceable>Type</replaceable>) twice. This has as
        effect that the left-hand side only matches if the two arguments of
        <literal>compatible</literal> are identical.</para>

        <example xml:id="Types2.asf">
          <title>Types2.asf</title>

          <programlisting>equations

  [Type-1]  compatible(<replaceable>Type</replaceable>, <replaceable>Type</replaceable>)  = true
  [default-Type] 
            compatible(<replaceable>Type1</replaceable>,<replaceable>Type2</replaceable>) = false </programlisting>
        </example>

        <para>To complete this story, yet another specification style for this
        problem exists that uses a negative condition instead of a default
        equation. This is shown in <link
        linkend="Types3.asf">Types3.asf</link>.<example xml:id="Types3.asf">
            <title>Types3.asf</title>

            <programlisting>equations

  [Type-1]  compatible(<replaceable>Type</replaceable>, <replaceable>Type</replaceable>)  = true
  [Type-2]       <replaceable>Type1</replaceable> != <replaceable>Type2</replaceable>
            ===============================
            compatible(<replaceable>Type1</replaceable>,<replaceable>Type2</replaceable>) = false </programlisting>
          </example></para>

        <para>You may not be impressed by the savings that we get in this tiny
        example. You will, however, be pleasantly surprised when you use the
        above techniques and see how short specification become when dealing
        with real-life cases.</para>
      </section>
    </section>

    <section xml:id="ListMatching">
      <title>List Matching</title>

      <!--\index{list matching@list matching} \index{associative matching@associative matching}-->

      <para>List matching, also known as <emphasis>associative
      matching</emphasis>, is a powerful mechanism to describe complex
      functionality in a compact way. Unlike the matching of ordinary
      (non-list) variables, the matching of a list variable may have more than
      one solution since the variable can match lists of arbitrary length. As
      a result, backtracking is needed. For instance, to match <literal>X
      Y</literal> (a list expression containing the two list variables
      <literal>X</literal> and <literal>Y</literal> indicating the division of
      a list into two sublists) with the list <literal>ab</literal> (a list
      containing two elements) the following three alternatives have to be
      considered:</para>

      <itemizedlist>
        <listitem>
          <para>X = (empty), Y = ab</para>
        </listitem>

        <listitem>
          <para>X = a, Y = b</para>
        </listitem>

        <listitem>
          <para>X = ab, Y = (empty).</para>
        </listitem>
      </itemizedlist>

      <para>In the unconditional case, backtracking occurs only during
      matching. When conditions are present, the failure of a condition
      following the match of a list variable leads to the trial of the next
      possible match of the list variable and the repeated evaluation of
      following conditions.</para>

      <section>
        <title>Example: Sets</title>

        <para>Let's consider the problem of removing double elements from a
        list. This shown in Sets.sdf and Sets.asf.</para>

        <example xml:id="Sets.sdf">
          <title>Sets.sdf</title>

          <para><programlisting>module Sets

imports basic/Whitespace

exports
  context-free start-symbols Set
  sorts Elem Set

  lexical syntax
    [a-z]+ -&gt; Elem                <co xml:id="co.sets.elem" />

  context-free syntax
    "{" {Elem ","}* "}" -&gt; Set    <co xml:id="co.sets.syntax" />

hiddens
  variables
    "Elem"[0-9]*  -&gt; Elem         <co xml:id="co.sets.var-elem" />
    "Elem*"[0-9]* -&gt; {Elem ","}*  <co xml:id="co.sets.var-elem-list" /></programlisting>Notes:</para>

          <calloutlist>
            <callout arearefs="co.sets.elem">
              <para>This defines elements as single letters.</para>
            </callout>

            <callout arearefs="co.sets.syntax">
              <para>This defines the syntax of a <literal>Set</literal>: an
              opening curly bracket, a list of zero or more
              <literal>Elem</literal>s separated by comma's, followed by a
              closing curly bracket. This is a typical syntax pattern; don't
              get confused for the different roles that the curly brackets
              play: the <literal>"{"</literal> and <literal>"}"</literal> are
              literal string that are part of the syntax of
              <literal>Set</literal>s, while <literal>{Elem ","}*</literal>
              describes a syntactic list of <literal>Elem</literal>s separated
              by commas.</para>
            </callout>

            <callout arearefs="co.sets.var-elem">
              <para>This defines variables <literal>Elem1</literal>,
              <literal>Elem2</literal> and so on of sort
              <literal>Elem</literal>.</para>
            </callout>

            <callout arearefs="co.sets.var-elem-list">
              <para>This defines variables <literal>Elem*1</literal>,
              <literal>Elem*2</literal> and so on of sort <literal>{Elem
              ","}*</literal>. Observe the funny variable name containing the
              non-alphanumeric character <literal>*</literal>. Some ASF+SDF
              specification writers use the convention that variables that
              range over list sorts end on either <literal>*</literal> or
              <literal>+</literal> and maybe followed by digits.</para>
            </callout>
          </calloutlist>
        </example>

        <para>We can now parse sets like:</para>

        <itemizedlist>
          <listitem>
            <para><literal>{}</literal></para>
          </listitem>

          <listitem>
            <para><literal>{a}</literal></para>
          </listitem>

          <listitem>
            <para><literal>{a, b}</literal></para>
          </listitem>

          <listitem>
            <para><literal>{a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q,
            r, s, t, u, v, w, x, y, z}</literal></para>
          </listitem>

          <listitem>
            <para>and so on.</para>
          </listitem>
        </itemizedlist>

        <para>The actual solution of our problem, removed duplicates from a
        list, is shown in <link linkend="Sets.asf">Sets.asf</link>. Observe
        that the single equation has a left-hand side with two occurences of
        variable Elem, so it will match on a list that contains two identical
        elements.</para>

        <para>In the right-hand side, one of these occurences is removed.
        However, this same equation remains applicable as long as the list
        contains duplicate elements.<example xml:id="Sets.asf">
            <title>Sets.asf</title>

            <programlisting>equations
  
  [set] {Elem*1, Elem, Elem*2, Elem, Elem*3} = {Elem*1, Elem, Elem*2, Elem*3}</programlisting>
          </example></para>

        <important>
          <para>This specification of sets is very elegant but may become very
          expensive to execute when applied to large sets. There are several
          strategies to solve this:</para>

          <itemizedlist>
            <listitem>
              <para>Use ordered lists and ensure that the insert operation
              checks for duplicates.</para>
            </listitem>

            <listitem>
              <para>Use a more sophisticated representation like, for
              instance, a balanced tree.</para>
            </listitem>
          </itemizedlist>
        </important>
      </section>

      <section>
        <title>Example: Lists</title>

        <para>A sample of operations on lists of integers is shown in <link
        linkend="Lists.sdf">Lists.sdf</link> and <link
        linkend="Lists.asf">Lists.asf</link>.</para>

        <example xml:id="Lists.sdf">
          <title>Lists.sdf</title>

          <para><programlisting>module Lists

imports basic/Booleans
imports basic/Integers
imports basic/Whitespace

exports
  context-free start-symbols 
        Boolean Integer List             <co xml:id="co.lists.start" />
  sorts List

  context-free syntax
    "[" {Integer ","}*  "]"   -&gt; List    <co xml:id="co.lists.list" />
    List "++" Integer         -&gt; List    <co xml:id="co.lists.conc1" />
    Integer "++" List         -&gt; List    <co xml:id="co.lists.conc2" />
    is-element(Integer, List) -&gt; Boolean <co xml:id="co.lists.is-element" />
    length(List)              -&gt; Integer <co xml:id="co.lists.length" />
    reverse(List)             -&gt; List    <co xml:id="co.lists.reverse" />
    sort(List)                -&gt; List    <co xml:id="co.lists.sort" />

hiddens
  variables
    "Int"[0-9]*  -&gt; Integer
    "Int*"[0-9]* -&gt; {Integer ","}* </programlisting>Notes:<calloutlist>
              <callout arearefs="co.lists.start">
                <para>Below, we define functions with result sorts
                <literal>Boolean</literal>, <literal>Integer</literal> and
                <literal>List</literal> and all these sorts will probably
                occur in input terms. It is therefore a good idea declare all
                these sort as start symbol.</para>
              </callout>

              <callout arearefs="co.lists.list">
                <para>Define the syntax of lists of integers.</para>
              </callout>

              <callout arearefs="co.lists.conc1">
                <para>Append an integer to a list.</para>
              </callout>

              <callout arearefs="co.lists.conc2">
                <para>Prepend an integer to a list.</para>
              </callout>

              <callout arearefs="co.lists.is-element">
                <para>Check for element in list.</para>
              </callout>

              <callout arearefs="co.lists.length">
                <para>Determine length of list.</para>
              </callout>

              <callout arearefs="co.lists.reverse">
                <para>Reverse a list.</para>
              </callout>

              <callout arearefs="co.lists.sort">
                <para>Sort a list</para>
              </callout>
            </calloutlist></para>

          <para>Given these syntax definitions, we can define the meaning of
          the various functions in <link
          linkend="Lists.asf">Lists.asf</link>.</para>
        </example>

        <example xml:id="Lists.asf">
          <title>Lists.asf</title>

          <programlisting>equations
  [app-1] [Int*] ++ Int = [Int*, Int]                       <co
              xml:id="co.lists.asf.app" />
  [pre-1] Int ++ [Int*] = [Int, Int*]

  [len-1] length([]) = 0                                    <co
              xml:id="co.lists.asf.length" />
  [len-2] length([Int, Int*]) = 1 + length([Int*])

  [is-1] is-element(Int, [Int*1, Int, Int*2]) = true        <co
              xml:id="co.lists.asf.is-element" />
  [default-is]
         is-element(Int, [Int*]) = false

  [rev-1] reverse([]) = []                                  <co
              xml:id="co.lists.asf.reverse" />
  [rev-2] reverse([Int, Int*]) = reverse([Int*]) ++ Int

  [srt-1]                          Int1 &gt; Int2 == true      <co
              xml:id="co.lists.asf.sort" />
          ================================================================================
         sort([Int*1, Int1, Int*2, Int2, Int*3]) = sort([Int*1, Int2, Int*2, Int1, Int*3])
   [default-srt]
          sort([Int*]) = [Int*]</programlisting>

          <para>Notes:</para>

          <calloutlist>
            <callout arearefs="co.lists.asf.app">
              <para>The definition of the append and prepend operators
              <literal>++</literal> illustrates how list variables like
              <literal>Int*</literal> can be used to first extract elements
              from a list and later insert them in a new list.</para>
            </callout>

            <callout arearefs="co.lists.asf.length">
              <para>The <literal>length</literal> function is defined by a
              simple induction on lists.</para>
            </callout>

            <callout arearefs="co.lists.asf.is-element">
              <para>The two occurrences of the variable <literal>Int</literal>
              in equation <literal>[is-1]</literal> illustrate the use of list
              matching for a search for a given element in a list.</para>
            </callout>

            <callout arearefs="co.lists.asf.reverse">
              <para>The reverse functions is defined by recurring over the
              elements of the list. Note how the append operator
              <literal>++</literal> is used in equation
              <literal>[rev-2]</literal>. One can avoid using an auxiliary
              operator at the expense of introducing a condition and an extra
              variable:</para>

              <programlisting>[rev-2']      [Int*1] := reverse([Int*])
          ===================================
          reverse([Int, Int*]) = [Int*1, Int]</programlisting>
            </callout>

            <callout arearefs="co.lists.asf.sort">
              <para>The equations for sort show, once more, the expressive
              power of list matching: in the left-hand side of
              <literal>[srt-1]</literal> two elements
              <replaceable>Int1</replaceable> and
              <replaceable>Int2</replaceable> are picked and if Int is greater
              than <replaceable>Int2</replaceable>, the elements are swapped
              and sort is applied again.</para>
            </callout>
          </calloutlist>
        </example>
      </section>
    </section>

    <section xml:id="MemoFunctions">
      <title>Memo Functions</title>

      <!--\index{memo functions@memo functions}-->

      <para>Computations may contain unnecessary repetitions. This is the case
      when a function with the same argument values is computed more than
      once. Memo functions exploit this behaviour and can improve the
      efficiency of ASF+SDF specifications. Given a set of argument values for
      some function the normal form can be obtained via rewriting. It is
      possible that some function is called with the same set of arguments
      over and over again. Each time the function is rewritten to obtain the
      same normal again. By means of adding the <literal>memo</literal>
      attribute, this behaviour is improved by storing the set of argument
      values and the derived normal form in a memo-table. For each set of
      argument values it is checked whether there exists a normal form in the
      memo-table. If so, this normal form is returned. If not, the function
      given this set of argument values is normalized and stored in the
      memo-table. There is some overhead involved in accessing the memo-table.
      Therefore, it is not wise to add the memo attribute to each function.
      With respect to the operational behaviour adding a memo attribute does
      not have any effect. The Fibonacci function shown <link
      linkend="CODE_fib">below</link> is decorated with the memo attribute to
      improve its efficiency.</para>

      <example xml:id="CODE_fib">
        <title>Using the memo attribute when defining Fibonacci</title>

        <para><programlisting>module Fib

imports basic/Whitespace

exports
  context-free start-symbols Int
  sorts Int

  context-free syntax
    "0"             -&gt; Int
    "s" "(" Int ")" -&gt; Int

  context-free syntax
    add(Int, Int) -&gt; Int

    fib(Int)      -&gt; Int {memo}

hiddens
  variables
    [xy][0-9]* -&gt; Int

equations

  [add-s] add(s(x), y) = s(add(x, y))
  [add-z] add(0, y) = y

  [fib-z] fib(0) = s(0)
  [fib-o] fib(s(0)) = s(0)
  [fib-x] fib(s(s(x))) = add(fib(s(x)), fib(x))</programlisting></para>
      </example>

      <para>The resulting improvement in performance is shown as
      follows:</para>

      <table border="1">
        <caption>Execution times for the evaluation of fib(n)</caption>

        <tr>
          <td><emphasis role="bold">fib(n)</emphasis></td>

          <td><emphasis role="bold">Time without memo (sec)</emphasis></td>

          <td><emphasis role="bold">Time with memo (sec)</emphasis></td>
        </tr>

        <tr>
          <td><literal>fib(16)</literal></td>

          <td>2.0</td>

          <td>0.7</td>
        </tr>

        <tr>
          <td><literal>fib(17)</literal></td>

          <td>3.5</td>

          <td>1.1</td>
        </tr>

        <tr>
          <td><literal>fib(18)</literal></td>

          <td>5.9</td>

          <td>1.8</td>
        </tr>

        <tr>
          <td><literal>fib(19)</literal></td>

          <td>10.4</td>

          <td>3.3</td>
        </tr>
      </table>
    </section>

    <section xml:id="LexicalConstructorFunctions">
      <title>Lexical Constructor Functions</title>

      <para>The only way to access the actual characters of a lexical token is
      by means of the so-called lexical constructor functions. For each
      lexical sort <replaceable>LEX</replaceable> a lexical constructor
      function is automatically derived, the corresponding syntax definition
      is: <programlisting><replaceable>lex</replaceable>( CHAR* ) -&gt; <replaceable>LEX</replaceable></programlisting>
      The sort <replaceable>CHAR</replaceable> is a predefined sort to access
      the characters. Characters can be directly addressed by the
      representation or via variables which may be of the sorts
      <literal>CHAR</literal>, <literal>CHAR*</literal>, or
      <literal>CHAR+</literal>. The latter two represent lists of characters.
      In the example <link linkend="CODE_lcfs">below</link> the lexical
      constructor function <literal>nat-con</literal> is used to remove the
      leading zeros from a number.</para>

      <para><example xml:id="CODE_lcfs">
          <title>Use of lexical constructor</title>

          <para><programlisting>module Nats

imports basic/Whitespace

exports
  context-free start-symbols Nat-con
  sorts Nat-con

  lexical syntax
    [0-9]+ -&gt; Nat-con 

hiddens
  variables
    "Char+"[0-9]* -&gt; CHAR+
equations

  [1] nat-con("0" Char+) = nat-con(Char+)</programlisting></para>
        </example></para>

      <important>
        <para>The argument of a lexical constructor may be an arbitrary list
        of characters and there is <emphasis>no check that they match the
        lexical definition of the corresponding sort</emphasis>. This means
        that when writing a specification one should be aware that it is
        possible to construct illegal lexical entities, for instance, by
        inserting letters in an integer. In the example <link
        linkend="CODE_illegallcfs">below</link> via the lexical constructor
        function <literal>nat-con</literal> a natural number containing the
        letter <literal>a</literal> is constructed.</para>
      </important>

      <example xml:id="CODE_illegallcfs">
        <title>Illegal use of lexical constructor functions</title>

        <para><programlisting>module Nats

imports basic/Whitespace

exports
  context-free start-symbols Nat-con
  sorts Nat-con

  lexical syntax
    [0-9]+ -&gt; Nat-con 

hiddens
  variables
    "Char+"[0-9]* -&gt; CHAR+

equations

  [1] nat-con(Char+) = nat-con(Char+ "a")      </programlisting></para>
      </example>
    </section>

    <section xml:id="TraversalFunctions">
      <title>Traversal Functions</title>

      <!--\index{traversal functions@traversal functions} \index{accumulator@accumulator} \index{transformer@transformer}-->

      <para>Program analysis and program transformation usually take the
      syntax tree of a program as starting point. One common problem that one
      encounters is how to express the <emphasis>traversal</emphasis> of the
      tree: visit all the nodes of the tree and extract information from some
      nodes or make changes to certain other nodes. The kinds of nodes that
      may appear in a program's syntax tree are determined by the grammar of
      the language the program is written in. Typically, each rule in the
      grammar corresponds to a node category in the syntax tree. Real-life
      languages are described by grammars which can easily contain several
      hundred, if not thousands of grammar rules. This immediately reveals a
      hurdle for writing tree traversals: a naive recursive traversal function
      should consider many node categories and the size of its definition will
      grow accordingly. This becomes even more dramatic if we realize that the
      traversal function will only do some real work (apart from traversing)
      for very few node categories. Traversal functions in ASF+SDF
      \cite{BKV03} solve this problem. We distinguish three kinds of traversal
      functions, defined as follows.</para>

      <formalpara>
        <title>Transformer</title>

        <para>A <emphasis>transformer</emphasis> is a sort-preserving
        transformation that will traverse its first argument. Possible extra
        arguments may contain additional data that can be used (but not
        modified) during the traversal. A transformer is declared as follows:
        <programlisting><replaceable>f</replaceable>(<replaceable>S</replaceable><subscript>1</subscript>, ..., <replaceable>S</replaceable><subscript>n</subscript>) -&gt; <replaceable>S</replaceable><subscript>1</subscript> {traversal(trafo, ...)}</programlisting>Because
        a transformer always returns the same sort, it is type-safe. A
        transformer is used to transform a tree.</para>
      </formalpara>

      <formalpara>
        <title>Accumulator</title>

        <para>An <emphasis>accumulator</emphasis> is a mapping of all node
        types to a single type. It will traverse its first argument, while the
        second argument keeps the accumulated value. An accumulator is
        declared as follows:<programlisting><replaceable>f</replaceable>(<replaceable>S</replaceable><subscript>1</subscript>, <replaceable>S</replaceable><subscript>2</subscript> ,..., <replaceable>S</replaceable><subscript>n</subscript>) -&gt; <replaceable>S</replaceable><subscript>2</subscript> {traversal(accu, ...)}</programlisting>After
        each application of an accumulator, the accumulated argument is
        updated. The next application of the accumulator, possibly somewhere
        else in the term, will use the <emphasis>new</emphasis> value of the
        accumulated argument. In other words, the accumulator acts as a
        global, modifiable, state during the traversal. An accumulator
        function never changes the tree, only its accumulated argument.
        Furthermore, the type of the second argument has to be equal to the
        result type. The end-result of an accumulator is the value of the
        accumulated argument. By these restrictions, an accumulator is also
        type-safe for every instantiation. An accumulator is meant to be used
        to extract information from a tree.</para>
      </formalpara>

      <formalpara>
        <title>Accumulating transformer</title>

        <para>An <emphasis>accumulating transformer</emphasis> is a sort
        preserving transformation that accumulates information while
        traversing its first argument. The second argument maintains the
        accumulated value. The return value of an accumulating transformer is
        a tuple consisting of the transformed first argument and accumulated
        value. An accumulating transformer is declared as
        follows:<programlisting><replaceable>f</replaceable>(<replaceable>S</replaceable><subscript>1</subscript>, <replaceable>S</replaceable><subscript>2</subscript> ,..., <replaceable>S</replaceable><subscript>n</subscript>) -&gt; <replaceable>&lt;<replaceable>S</replaceable><subscript>1</subscript>, S</replaceable><subscript>2</subscript>&gt; {traversal(accu, trafo, ...)}</programlisting>An
        accumulating transformer is used to simultaneously extract information
        from a tree and transform it.</para>
      </formalpara>

      <formalpara>
        <title>Visiting Orders</title>

        <para>Having these three types of traversals, they must be completed
        with visiting orders. Visiting orders determine the order of traversal
        and the <emphasis>depth</emphasis> of the traversal. We provide the
        following two strategies for each type of traversal:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para>Bottom-up: the traversal visits <emphasis>all</emphasis> the
          subtrees of a node where the visiting function applies in an
          <emphasis>bottom-up</emphasis> fashion. The annotation
          <literal>bottom-up</literal> selects this behavior. A traversal
          function without an explicit indication of a visiting strategy also
          uses the bottom-up strategy.</para>
        </listitem>

        <listitem>
          <para>Top-down: the traversal visits the subtrees of a node in an
          top-down fashion and stops recurring at the first node where the
          visiting function applies and does not visit the subtrees of that
          node. The annotation <literal>top-down</literal> selects this
          behavior.</para>
        </listitem>
      </itemizedlist>

      <para>Beside the three types of traversals and the order of visiting, we
      can also influence whether we want to stop or continue at the matching
      occurrences:</para>

      <itemizedlist>
        <listitem>
          <para>Break: the traversal stops at matching occurrences.</para>
        </listitem>

        <listitem>
          <para>Continue: the traversal continues at matching
          occurrences.</para>
        </listitem>
      </itemizedlist>

      <para>The visiting strategies in combination with the continuation
      strategies is visualized in the \link{``traversal cube''}[, see
      Figure~\Ref]{FIG:treetraversals}. The current implementation of the
      traversal mechanism only supports the left-to-right visiting
      strategy.</para>

      <para>\begin{figure} \begin{center} \begin{Label}{FIG:treetraversals} \T
      \includegraphics[width=8cm]{order} \W \htmlimage{order.gif} \caption{The
      ``traversal cube'': principal ways of traversing a tree} \end{Label}
      \end{center} \end{figure} We give two simple examples of traversal
      functions that are both based on the <link
      linkend="CODE_tree-language">tree language</link> that describes binary
      prefix expressions with natural numbers as leaves. Examples are
      <literal>f(0,1)</literal> and <literal>f(g(1,2),
      h(3,4))</literal>.</para>

      <example xml:id="CODE_tree-language">
        <title>A simple tree language</title>

        <para><programlisting>module Tree-syntax

imports basic/Integer
imports basic/Whitespace

exports
  context-free start-symbols Tree
  sorts Tree

  context-free syntax
    Integer       -&gt; Tree
    f(Tree, Tree) -&gt; Tree
    g(Tree, Tree) -&gt; Tree
    h(Tree, Tree) -&gt; Tree</programlisting></para>
      </example>

      <para>Our <link linkend="CODE_inc">first example</link> transforms a
      given tree into a new tree in which all numbers have been
      incremented.</para>

      <example xml:id="CODE_inc">
        <title>The transformer <literal>inc</literal> increments all numbers
        in a tree</title>

        <para><programlisting>module Tree-inc
imports Tree-syntax

exports
  context-free syntax
    inc(Tree) -&gt; Tree {traversal(trafo, top-down, continue)}
  
hiddens
  variables
    "N"[0-9]* -&gt; Integer

equations
  [1] inc(N) = N + 1</programlisting></para>
      </example>

      <para>Our <link linkend="CODE_sum">second example</link> computes the
      sum of all numbers in a tree.</para>

      <example xml:id="CODE_sum">
        <title>The accumulator <literal>sum</literal> that sums all numbers in
        a tree</title>

        <para><programlisting>module Tree-sum
imports Tree-syntax
exports
  context-free syntax
    sum(Tree, Integer) -&gt; Integer {traversal(accu, top-down, continue)}
  
hiddens
  variables
    "N"[0-9]* -&gt; Integer

equations
  [1] sum(N1, N2) = N1 + N2</programlisting></para>

        <para>The SDF definition of a traversal function has to fulfill a
        number of requirements:</para>

        <itemizedlist>
          <listitem>
            <para>Traversal functions can only be defined in the context-free
            syntax section.</para>
          </listitem>

          <listitem>
            <para>Traversal functions must be prefix functions.</para>
          </listitem>

          <listitem>
            <para>The first argument of the prefix function is always a sort
            of a node of the tree that is traversed, for both accumulating as
            well as transformation functions.</para>
          </listitem>

          <listitem>
            <para>In case of a transformation function the result sort
            <replaceable>Tree</replaceable> should always be same as the sort
            of the first argument:<programlisting><replaceable>tf</replaceable>(<replaceable>Tree</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, ..., <replaceable>A</replaceable><subscript>n</subscript>) -&gt; <replaceable>Tree</replaceable> {traversal(trafo, ...)}</programlisting></para>
          </listitem>

          <listitem>
            <para>In case of an accumulating function, the second argument
            <replaceable>Accu</replaceable> represents the accumulator and the
            result sort should be of the same sort:<programlisting><replaceable>tf</replaceable>(<replaceable>Tree</replaceable>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, ..., <replaceable>A</replaceable><subscript>n</subscript>) -&gt; <replaceable>Accu</replaceable> {traversal(accu, ...)}</programlisting></para>
          </listitem>

          <listitem>
            <para>In case of an accumulating transformation function, the
            first argument represents the tree node
            <replaceable>Tree</replaceable>, the second the accumulator
            <replaceable>Accu</replaceable>, and the result sort should be a
            tuple consisting of the tree node sort (first element of the
            tuple) and the accumulator (second element of the
            tuple):<programlisting><replaceable>tf</replaceable>(<replaceable>Tree</replaceable>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, ..., <replaceable>A</replaceable><subscript>n</subscript>) -&gt; &lt;<replaceable>Tree</replaceable>, <replaceable>Accu</replaceable>&gt; {traversal(accu, trafo, ...)}</programlisting></para>
          </listitem>

          <listitem>
            <para>The traversal functions may have more arguments, the only
            restriction is that they should be consistent over the various
            occurrences of the same traversal function. <programlisting><replaceable>tf</replaceable>(<replaceable>Tree</replaceable><subscript>1</subscript>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, ..., <replaceable>A</replaceable><subscript>n</subscript>) -&gt; <replaceable>Tree</replaceable><subscript>1</subscript> {traversal(trafo, continue, top-down)}
<replaceable>tf</replaceable>(<replaceable>Tree</replaceable><subscript>2</subscript>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, ..., <replaceable>A</replaceable><subscript>n</subscript>) -&gt; <replaceable>Tree</replaceable><subscript>2</subscript> {traversal(trafo, continue, top-down)}</programlisting></para>
          </listitem>

          <listitem>
            <para>The order of the traversal attributes is free, but should be
            used consistently, for instance the following definition is not
            allowed:<programlisting><replaceable>tf</replaceable>(<replaceable>Tree</replaceable><subscript>1</subscript>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, ..., <replaceable>A</replaceable><subscript>n</subscript>) -&gt; <replaceable>Tree</replaceable><subscript>1</subscript> {traversal(trafo, top-down, continue)}
<replaceable>tf</replaceable>(<replaceable>Tree</replaceable><subscript>1</subscript>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, ..., <replaceable>A</replaceable><subscript>n</subscript>) -&gt; <replaceable>Tree</replaceable><subscript>2</subscript> {traversal(trafo, continue, top-down)}
</programlisting></para>
          </listitem>

          <listitem>
            <para>If the number of arguments of the traversal function
            changes, you should introduce a new function name. The following
            definitions are not correct: <programlisting><replaceable>tf</replaceable>(<replaceable>Tree</replaceable><subscript>1</subscript>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, <replaceable>A</replaceable><subscript>2</subscript>)      -&gt; <replaceable>Tree</replaceable><subscript>1</subscript> {traversal(trafo, top-down, continue)}
<replaceable>tf</replaceable>(<replaceable>Tree</replaceable><subscript>1</subscript>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, <replaceable>A</replaceable><subscript>2</subscript>,<replaceable> A</replaceable><subscript>3</subscript>)  -&gt; <replaceable>Tree</replaceable><subscript>2</subscript> {traversal(trafo, continue, top-down)}</programlisting>but
            should be:<programlisting><replaceable>tf</replaceable>1(<replaceable>Tree</replaceable><subscript>1</subscript>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, <replaceable>A</replaceable><subscript>2</subscript>)      -&gt; <replaceable>Tree</replaceable><subscript>1</subscript> {traversal(trafo, top-down, continue)}
<replaceable>tf</replaceable>2(<replaceable>Tree</replaceable><subscript>1</subscript>, <replaceable>Accu</replaceable>, <replaceable>A</replaceable><subscript>1</subscript>, <replaceable>A</replaceable><subscript>2</subscript>,<replaceable> A</replaceable><subscript>3</subscript>)  -&gt; <replaceable>Tree</replaceable><subscript>2</subscript> {traversal(trafo, continue, top-down)}</programlisting></para>
          </listitem>
        </itemizedlist>
      </example>

      <para>In the SDF part of a module it is needed to define traversal
      functions for all sorts which are needed in the equations.</para>
    </section>

    <section xml:id="Tests">
      <title>Tests</title>

      <para></para>
    </section>

    <section xml:id="WhichSpecsAreExecutable">
      <title>Which Specifications are Executable?</title>

      <para>Which ASF+SDF specifications can be executed? The <link
      linkend="CODE_itemsets">specification of sets</link> illustrates a
      non-executable specification, since equation<literal> [2]</literal>,
      which expresses that two elements in a set may be exchanged, will lead
      to an infinite rewriting loop.</para>

      <example xml:id="CODE_itemsets">
        <title>Non-executable specification for sets</title>

        <para><programlisting>module ItemSet

imports basic/Whitespace

exports
  context-free start-symbols Set
  sorts Item Set 

  lexical syntax
    [a-z]+ -&gt; Item 

  context-free syntax
    Set[Item] -&gt; Set

hiddens
  variables
    "i"[0-9]* -&gt; Item
    "l"[0-9]* -&gt; {Item ","}* 

equations

  [1] {l1, i, l2, i, l3}   = {l1, i, l2, l3} 
  [2] {l1, i1, l2, i2, l3} = {l1, i2, l2, i1, l3} </programlisting></para>
      </example>
    </section>

    <section xml:id="CommonErrors">
      <title>Common Errors when Executing Specifications</title>

      <itemizedlist>
        <listitem>
          <para>When using the inequality operator <literal>!=</literal> in a
          condition, no new variables may be introduced in either side of the
          inequality.</para>
        </listitem>

        <listitem>
          <para>If the normal form of a term still contains function symbols
          that should have been removed during rewriting, you probably have
          forgotten one or more equations that define the function. A typical
          situation is that you have given an <emphasis>incomplete</emphasis>
          set of equations defining the function.</para>
        </listitem>

        <listitem>
          <para>The rewriting process does not stop. Your equations probably
          contain an infinite loop.</para>
        </listitem>

        <listitem>
          <para>Be careful when a condition contains both instantiated and
          uninstantiated variables.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="ASFSDF-checker">
    <title>Well-formedness checks on ASF+SDF</title>

    <para>In order to improve the quality of the written specifications, a
    number of checks are performed before an SDF specification is transformed
    into a parse table. The checks are performed on two levels: the first
    level are SDF specific checks, the second level are ASF+SDF specific
    checks. There are various categories of messages in The
    Meta-Environment</para>

    <itemizedlist>
      <listitem>
        <para>Parse errors.</para>
      </listitem>

      <listitem>
        <para>SDF type check warnings.</para>
      </listitem>

      <listitem>
        <para>SDF type check errors.</para>
      </listitem>

      <listitem>
        <para>ASF type check errors.</para>
      </listitem>
    </itemizedlist>

    <para>We will briefly discuss each of the error messages and indicate what
    is exactly wrong in the specification. Furthermore we will hint at how the
    error can be fixed.</para>

    <section>
      <title>Parse Errors</title>

      <para>There are three different types of parse errors:</para>

      <itemizedlist>
        <listitem>
          <para>A syntax error, which is reported by pinpointing the exact
          location in the file and the message <literal>Parse error near
          cursor</literal> in case of an editor or in the message pane an
          error message similar to<literal>Parse error: character
          '<replaceable>c</replaceable>' unexpected</literal>. This means that
          the parser detected a syntax error in the text to be parsed and can
          not proceed its parsing process. Clicking on the error in the
          <literal>Errors</literal>-pane moves the cursor to the exact error
          location and launches if needed the editor. A variant of the syntax
          error message is: <literal>Parse error: eof
          unexpected</literal>.</para>
        </listitem>

        <listitem>
          <para>A cycle, in case of an editor the cursor is positioned at the
          position where the first cycle is detected in the input and the
          message is <literal>Cycle:
          &lt;list_of_production_rules&gt;</literal> is printed. A cycle is
          reported whenever the parser detects a non terminating chain of
          reductions. All production rules in the cycle are shown as
          <literal>&lt;list_of_production_rules&gt;</literal>.</para>
        </listitem>

        <listitem>
          <para>An ambiguity, again in case of an editor the cursor is
          positioned at the position where the first ambiguity is detected in
          the input and the message <literal>Ambiguity:
          &lt;list_of_production_rules&gt;</literal> is printed. An ambiguity
          is reported whenever the parser was able to recognized a (part of)
          the input sentence in different ways. The
          <literal>&lt;list_of_production_rules&gt;</literal> shows all
          production rules that are involved in the ambiguity.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="PlainSDFwarnings">
      <title>Type check warnings for plain SDF</title>

      <para>The warnings and error for SDF are separated into 4 sections.
      First we will discuss the type check warnings and <link
      linkend="PlainSDFerrors">errors</link> for plain SDF. This variant of
      SDF is independent of ASF. Later we will discuss the <link
      linkend="ASFSDFwarnings">warnings</link> and <link
      linkend="ASFSDFerrors">errors</link> for SDF used in combination with
      ASF. In this case we need to be more strict and every SDF construct is
      supported by ASF. Warnings do not break the specification, but it is
      advisable to fix them anyway. Often they point out some not well-formed
      part in the specification.</para>

      <itemizedlist>
        <listitem>
          <para><literal>undeclared sorts</literal>: This warning indicates
          that a sort is used which is not explicitly declared, or it is
          declared but in a hidden section.</para>
        </listitem>

        <listitem>
          <para><literal>double declared sort</literal>: This warning points
          out that the sort is already declared somewhere in this module, or
          in one of the imported modules.</para>
        </listitem>

        <listitem>
          <para><literal>double declared start-symbol</literal>: This warning
          indicates that the start-symbol is previously defined as
          start-symbol as well. This can be in the current module or in one of
          the imported modules.</para>
        </listitem>

        <listitem>
          <para><literal>illegal attribute: {bracket, left, right, assoc,
          non-assoc}</literal>: This warning is generated because the
          syntactic form of the production rule and the attribute do not
          match. Given this mismatch the intended behaviour will not be
          effective.</para>
        </listitem>

        <listitem>
          <para><literal>used in priorities but undefined</literal>: This
          warning is generated whenever a production rule is used in a
          priority section which is not defined in this module or in one of
          the imported modules. It is possible that this production rule will
          be defined in one of the modules which imports this module.
          Normally, this indicates a typo.</para>
        </listitem>

        <listitem>
          <para><literal>inconsistent rhs in priorities</literal>: This
          warning is caused by a production rule which has not the same
          right-hand side as the other production rules in the priority
          relation. Whenever this occurs the effect of the expressed priority
          relation will be ignored. This check is performed modulo
          injections.</para>
        </listitem>

        <listitem>
          <para><literal>unknown constructor used in priorities</literal>:
          This warning indicates the use of a constructor which is not used in
          the corresponding set of production rules with the same right-hand
          side. This is a very weak check on consistent use of constructor
          information.</para>
        </listitem>

        <listitem>
          <para><literal>sort CHAR used in production rule</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>deprecated tuple notation</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>deprecated unquoted symbol notation</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>deprecated non-plain sort
          definition</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>aliased symbol already declared</literal>:</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="PlainSDFerrors">
      <title>Type check errors for plain SDF</title>

      <itemizedlist>
        <listitem>
          <para><literal>module not available</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>start-symbols in &lt;ModuleName&gt; not defined in
          any right-hand</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>literal in right-hand-side not
          allowed</literal></para>
        </listitem>

        <listitem>
          <para><literal>only sort allowed in right-hand-side of
          lexical-function</literal></para>
        </listitem>

        <listitem>
          <para><literal>double used label</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>constructor has already been used</literal>:&#160;The
          combination of right-hand symbol and the constructor information
          should be unique. This warning points this out. It is advisable not
          to ignore this warning. In fact, for the parser these double
          constructors are no problem, but there are tools based on SDF for
          which this is problematic.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="ASFSDFwarnings">
      <title>Type check warnings for ASF+SDF</title>

      <itemizedlist>
        <listitem>
          <para><literal>exported variables section</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>kernel syntax construction</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>production renamings not supported</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>not supported symbol</literal>:</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="ASFSDFerrors">
      <title>Type check errors for ASF+SDF</title>

      <itemizedlist>
        <listitem>
          <para><literal>traversal attributes in non-prefix
          function</literal></para>
        </listitem>

        <listitem>
          <para><literal>illegal traversal attribute</literal></para>
        </listitem>

        <listitem>
          <para><literal>missing bottom-up or top-down
          attribute</literal></para>
        </listitem>

        <listitem>
          <para><literal>missing break or continue attribute</literal></para>
        </listitem>

        <listitem>
          <para><literal>missing trafo and/or accu attribute</literal></para>
        </listitem>

        <listitem>
          <para><literal>accu should return accumulated type</literal></para>
        </listitem>

        <listitem>
          <para><literal>trafo should return traversed type</literal></para>
        </listitem>

        <listitem>
          <para><literal>accutrafo should return tuple of correct
          types</literal></para>
        </listitem>

        <listitem>
          <para><literal>inconsistent arguments of traversal
          productions</literal></para>
        </listitem>

        <listitem>
          <para><literal>inconsistent traversal attributes</literal></para>
        </listitem>

        <listitem>
          <para>asf equation sort must not be used</para>
        </listitem>

        <listitem>
          <para><literal>charclasses not allowed in context-free
          syntax</literal></para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Type check warnings for ASF</title>

      <itemizedlist>
        <listitem>
          <para><literal>Lexical probably intended to be a
          variable</literal></para>
        </listitem>

        <listitem>
          <para><literal>Deprecated condition syntax "="</literal></para>
        </listitem>

        <listitem>
          <para><literal>constructor not expected as outermost function symbol
          of left hand side</literal></para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Type check errors for ASF</title>

      <itemizedlist>
        <listitem>
          <para><literal>equations contain ambiguities</literal></para>
        </listitem>

        <listitem>
          <para><literal>uninstantiated variable occurrence</literal></para>
        </listitem>

        <listitem>
          <para><literal>negative condition introduces
          variable(s)</literal></para>
        </listitem>

        <listitem>
          <para><literal>uninstantiated variables in both sides of
          condition</literal></para>
        </listitem>

        <listitem>
          <para><literal>uninstantiated variables in equality
          condition</literal></para>
        </listitem>

        <listitem>
          <para><literal>right-hand side of matching condition introduces
          variables</literal></para>
        </listitem>

        <listitem>
          <para><literal>matching condition does not introduce new
          variables</literal></para>
        </listitem>

        <listitem>
          <para><literal>strange condition encountered</literal></para>
        </listitem>

        <listitem>
          <para><literal>Left hand side is contained in a
          list</literal></para>
        </listitem>

        <listitem>
          <para><literal>no variables may be introduced in left hand side of
          test</literal></para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="HistoricalNotes">
    <title>Historical Notes</title>

    <para></para>
  </section>

  <!--%%\subsubsection{Delaying} \label{Delay}
%%
%%Both the compiler and the evaluator are based on innermost rewriting.
%%In some cases it is more efficient to overrule this rewriting
%%strategy. The disadvantage of innermost rewriting are redundant work
%%in some cases and in some cases even non-termination. An example
%%of the first point and indirectly of the second point is the
%%evaluation of a conditional (see Figure~\ref{CODE:conditional}), 
%%using innermost rewriting the evaluation of an conditional 
%%amounts to evaluating the expression, then part, and else part, independent
%%of the result of the evaluation of the expression.
%%
%%\begin{figure}
%%\label{CODE:conditional}
%%\begin{IncCode}
%%\begin{verbatim}
%%module Conditional
%%
%%imports Layout Expr Booleans
%%

%%exports
%%  context-free syntax
%%    "if" Bool "then" Expr "else" Expr "fi" -> Expr
%%
%%hiddens
%%  variables
%%    "Bool"[0-9]* -> Bool
%%    "Expr"[0-9]* -> Expr
%%
%%equations
%%
%%  [if-t] if true then Expr1 else Expr2 fi = Expr1
%%  [if-f] if false then Expr1 else Expr2 fi = Expr2
%%\end{verbatim}
%%\end{IncCode}
%%\caption{Equations for conditions}
%%\end{figure}   

%%\subsubsection{Getters and Setters Functions}
%%\label{GettersSetters}
%%
%%\index{getter functions@getter functions}
%%\index{setter functions@setter functions}

-->
</article>