<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
]>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns6="http://www.w3.org/1999/xhtml"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>The Syntax Definition Formalism SDF</title>

    <pubdate>$Rev$ by $Author$ at $Date: 2006-12-16 17:45:23
    +0100 (Sat, 16 Dec 2006) $</pubdate>

    <authorgroup>
      <author>
        <personname><firstname>Mark</firstname><surname>van den
        Brand</surname></personname>
      </author>

      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <warning>
    <para>This document is work in progress. It is in transition between The
    Meta-Enviroment V1.5 and V2.0. See <link linkend="sdf_ToDo">ToDo</link>
    section.</para>
  </warning>

  <section xml:id="Introduction">
    <title>An Introduction to SDF</title>

    <para>If you want to:</para>

    <itemizedlist>
      <listitem>
        <para>describe the syntax of an existing language like C, C++, Java,
        or Cobol,</para>
      </listitem>

      <listitem>
        <para>describe an embedded language and need to combine several
        language grammars,</para>
      </listitem>

      <listitem>
        <para>describe the syntax of your newly designed domain-specific
        language,</para>
      </listitem>

      <listitem>
        <para>get a front-end for the semantic analysis of programming or
        application languages,</para>
      </listitem>
    </itemizedlist>

    <para>then SDF may be the right technology to use.</para>

    <section>
      <title xml:id="YetAnotherFormalism">Why use SDF?</title>

      <para>The Syntax Definition Formalism SDF is intended for the high-level
      description of grammars for programming languages, application
      languages, domain-specific languages, data formats and other
      computer-based formal languages. The primary goal of any SDF definition
      is the description of syntax. The secondary goal is to generate a
      working parser from this definition. A parser is a tool that takes a
      string that represents a program as input and outputs a tree that
      represents the same program in a more structured form. SDF is based
      mainly on context-free grammars, like EBNF is. It has a number of
      additions that make it more apt to describe the syntax of really complex
      programming languages. Especially the languages that were not originally
      designed to be formally defined, or to have parsers generated for, are
      the ones that SDF is meant to be applicable to.</para>

      <para>These are the unique selling points of SDF, from the language
      definition point of view:</para>

      <itemizedlist>
        <listitem>
          <para>SDF allows modular grammar definitions. This enables the
          combination and re-use of grammars and makes it easy to handle
          embedded languages or different dialects of a common base language.
          It means that you are allowed to write any grammar in SDF, not just
          LALR(1) or LL(1) grammars.</para>
        </listitem>

        <listitem>
          <para>SDF allows more declarative grammars definitions and this
          results in simpler and more "natural" grammars that are not polluted
          by idiosyncrasies of particular parsing techniques. This allows an
          SDF definition to be independent of the implementation of
          SDF.</para>
        </listitem>

        <listitem>
          <para>SDF allows the integrated definition of lexical and
          context-free syntax.</para>
        </listitem>

        <listitem>
          <para>SDF allows declarative disambiguation. For typical ambiguous
          constructs in programming languages SDF allows you to define a
          disambiguation with mathematical precision. Note however that SDF
          does not have a disambiguation construct for every possible
          ambiguity.</para>
        </listitem>
      </itemizedlist>

      <para>The implementation of SDF is the combination of an SLR(1) parse
      table generator and a scannerless generalized LR parser.The goal of this
      implementation is to fully implement all expressiveness that is
      available in SDF, and avoiding any hidden implementation details.
      </para>

      <para>These are the unique selling points of the implementation of SDF,
      from the parser generation point of view:</para>

      <itemizedlist>
        <listitem>
          <para>There is no seperate scanner. This prevents all kinds of
          "lexical ambiguity" to occur at all, simply because the parser has
          more context information. </para>
        </listitem>

        <listitem>
          <para>It accepts all context-free grammars, including the ambiguous
          ones. Many programming languages do not only have LR(1) conflicts,
          they truly have ambiguous syntaxes (like C for example).</para>
        </listitem>

        <listitem>
          <para>It generates all ambiguous derivations, so no implicit choices
          are made. This is done without backtracking, and without the
          possibility for exponential behavior.</para>
        </listitem>

        <listitem>
          <para>It constructs parse trees automatically, and the optional
          mapping from parse trees to abstract syntax trees is also
          provided.</para>
        </listitem>

        <listitem>
          <para>It implements the SDF disambiguation constructs as parse tree
          filters in an efficient manner.</para>
        </listitem>
      </itemizedlist>

      <para>Note that the language definition point of view, and the parser
      generation point of view are closely related. Because of SDF's focus on
      the definition of languages and explicitly declaring disambiguations it
      is particulary well suited for situations that have "language
      multiplicity":</para>

      <itemizedlist>
        <listitem>
          <para>Having to deal with many language dialects (such as in reverse
          engineering COBOL programs)</para>
        </listitem>

        <listitem>
          <para>Dealing with embedded languages (SQL in COBOL/C)</para>
        </listitem>

        <listitem>
          <para>Dealing with language extensions (Java with AspectJ)</para>
        </listitem>

        <listitem>
          <para>Dealing with domain specific languages (many small languages,
          and DSL evolution)</para>
        </listitem>
      </itemizedlist>

      <para>The basic assumption of SDF is that <emphasis>all</emphasis>
      derivations of an input string will be produced. This guarantees that
      <emphasis>no implicit disambiguation</emphasis> will take place. To
      disambiguate, the user has to give explicit (declarative) disambiguation
      rules. Examples of disambiguation rules are
      <emphasis>longest-match</emphasis> and <emphasis>priorities</emphasis>.
      By making all these <emphasis>language design choices</emphasis>
      explicit in a concise manner, SDF allows you to deal with language
      multiplicity in a more visible (controlled) fashion. In that way high
      level syntax definition in SDF is like high level programming.</para>
    </section>

    <section>
      <title>How to use SDF?</title>

      <para>There are two ways to write an SDF specification, generate a
      parser for it, and use that parser:</para>

      <itemizedlist>
        <listitem>
          <para>By far the simplest way is to use the ASF+SDF Meta-Environment
          which provides interactive editing of SDF modules and completely
          automates the parser generation phase. After editing an SDF
          specification you can directly use it to parse input text, visualize
          parse trees and see syntax highlighting.</para>
        </listitem>

        <listitem>
          <para>At the command line you can use the programs
          <command>sdf2table</command> to generate a parse table and
          <command>sglr</command> to parse text using the generated parse
          table. <remark>Add links to relevant documents.</remark></para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Learning more</title>

      <para>You may want to refresh you knowledge of grammars and parsing by
      reading Syntax Analysis.</para>

      <warning>
        <para>Add cross link.</para>
      </warning>

      <para>There is a special "How To" on disambiguation with SDF: "SDF
      Disambiguation Medkit for programming languages".</para>

      <warning>
        <para>Add cross link</para>
      </warning>

      <para>If you learn more easily by example, please refer to the SDF
      library and the ASF+SDF library for examples of syntax definitions of
      programming languages.</para>

      <warning>
        <para>Add reference</para>
      </warning>

      <para>The full syntax definition of SDF in SDF is the final reference on
      the syntax of SDF. </para>

      <warning>
        <para>Add reference to SDF's definition</para>
      </warning>
    </section>

    <section>
      <title>This document</title>

      <para>In this document we describe the syntax of SDF and its basic
      semantics. It provides the basic knowledge for writing syntax
      definitions in SDF using small examples. </para>

      <itemizedlist>
        <listitem>
          <para><link linkend="Modules">Modules and Modular Structure</link>:
          a key aspect of SDF is that syntax specifications can be divided in
          modules.</para>
        </listitem>

        <listitem>
          <para><link linkend="Symbols">Symbols</link>: the building blocks
          for writing grammar rules.</para>
        </listitem>

        <listitem>
          <para><link linkend="Grammars">Grammars</link>: a catch-all concept
          that covers production rules, import sections, priority declarations
          and more.</para>
        </listitem>

        <listitem>
          <para><link linkend="sdf_Examples">Examples</link>: numerous
          examples how to define common syntactic constructs.</para>
        </listitem>

        <listitem>
          <para><link linkend="Priorities">Priorities</link>: the mechanisms
          needed to resolve ambiguities in grammars.</para>
        </listitem>

        <listitem>
          <para><link linkend="Disambiguation">Disambiguation</link>: applying
          priorities.</para>
        </listitem>

        <listitem>
          <para><link linkend="Parameterization">Parameterization and
          Renaming</link>: increase the re-usability of modules.</para>
        </listitem>

        <listitem>
          <para><link linkend="Variables">Variables</link>: add variables to
          grammars for the benefit of semantic formalisms.</para>
        </listitem>

        <listitem>
          <para><link linkend="WellformednessSDF">Well-formedness</link>:
          well-formedness checks applied to SDF specifications.</para>
        </listitem>
      </itemizedlist>

      <para>In <link linkend="sdf_HistoricalNotes">Historical Notes</link>, we
      give background and key references.</para>

      <para>As an index to this document, the following example exhibits
      allmost all features of SDF with references to the appropriate sections.
      SDF keywords are highlighted in boldface.</para>

      <table>
        <title>Arbitrary SDF example definition, showing many of its features,
        with references to sections</title>

        <tgroup cols="2">
          <tbody>
            <row>
              <entry><programlisting><emphasis role="bold">module</emphasis> languages/mylanguage/MyFunnyExample[Param1 Param2]
  <emphasis role="bold">imports</emphasis> basic/Whitespace
  <emphasis role="bold">imports</emphasis> utilities/Parsing[Expr]
  <emphasis role="bold">imports</emphasis> languages/mylanguage/MyExpressions[Expression =&gt; Expr]

<emphasis role="bold">exports</emphasis>
 <emphasis role="bold">sorts</emphasis> Identifier Expr List Stat
 <emphasis role="bold">lexical syntax</emphasis>
   [A-Z][a-z]+ -&gt; Identifier
 <emphasis role="bold">lexical restrictions</emphasis>
   Identifier -/- [a-z]
 <emphasis role="bold">context-free syntax</emphasis>
   Identifier    -&gt; Expr {<emphasis role="bold">cons</emphasis>("name")}
   Expr*         -&gt; List[[Param1]]
   "if" Expr "then" {Param2 ";"}+ "else" {Param2 ";"}+ "fi" -&gt; Param2
   "if" Expr "then" {Param2 ";"}+ "fi"                      -&gt; Param2 {<emphasis
                    role="bold">prefer</emphasis>}
 <emphasis role="bold">context-free syntax</emphasis>
   "if" | "then" | "fi"  -&gt; Identifier {<emphasis role="bold">reject</emphasis>}
 <emphasis role="bold">context-free priorities</emphasis>
   Expr "&amp;" Expr -&gt; Expr {<emphasis role="bold">left</emphasis>}  &gt;
   Expr "|" Expr -&gt; Expr {<emphasis role="bold">right</emphasis>}
<emphasis role="bold">hiddens</emphasis>
 <emphasis role="bold">variables</emphasis>
   "Id"[0-9\']* -&gt; Identifier
 <emphasis role="bold">lexical variables</emphasis>
   "Head" -&gt; [A-Z]
   "Tail" -&gt; [a-z]+</programlisting></entry>

              <entry><itemizedlist>
                  <listitem>
                    <para><link linkend="Modules">Module keyword, compound
                    module name and module parameters</link></para>
                  </listitem>

                  <listitem>
                    <para><link linkend="Modules">Importing a
                    module</link>.</para>
                  </listitem>

                  <listitem>
                    <para>Importing a module and binding its parameter</para>
                  </listitem>

                  <listitem>
                    <para>Importing a module and renaming on of its
                    sorts</para>
                  </listitem>

                  <listitem>
                    <para>...</para>
                  </listitem>

                  <listitem>
                    <para>Export section</para>
                  </listitem>

                  <listitem>
                    <para>Declaring sortnames (non-terminals).</para>
                  </listitem>

                  <listitem>
                    <para>Lexical syntax grammar</para>
                  </listitem>

                  <listitem>
                    <para>Character classes and list symbols</para>
                  </listitem>

                  <listitem>
                    <para>Follow restrictioons (a disambiguation
                    construct)</para>
                  </listitem>

                  <listitem>
                    <para>...</para>
                  </listitem>

                  <listitem>
                    <para>Context-free syntax grammar</para>
                  </listitem>

                  <listitem>
                    <para>A production with a cons attribute for defining
                    abstract syntax</para>
                  </listitem>

                  <listitem>
                    <para>Use of a nullable list symbol, and a parameterized
                    sort name</para>
                  </listitem>

                  <listitem>
                    <para>Use of separated list symbols, and use of the module
                    parameters</para>
                  </listitem>

                  <listitem>
                    <para>The prefer/avoid disambiguation construct</para>
                  </listitem>

                  <listitem>
                    <para>...</para>
                  </listitem>

                  <listitem>
                    <para>Reserving keyword using the reject disambiguation
                    construct</para>
                  </listitem>

                  <listitem>
                    <para>Priorities, a disambiguation construct for
                    expression grammars</para>
                  </listitem>

                  <listitem>
                    <para>Left associativity, another disambiguation
                    construct</para>
                  </listitem>

                  <listitem>
                    <para>Right associativity</para>
                  </listitem>

                  <listitem>
                    <para>Hiddens section</para>
                  </listitem>

                  <listitem>
                    <para>Declaration of meta variables for context-free
                    sorts/non-terminals</para>
                  </listitem>

                  <listitem>
                    <para>...</para>
                  </listitem>

                  <listitem>
                    <para>Use of character classes in productions for meta
                    variables</para>
                  </listitem>

                  <listitem>
                    <para>Declaration of meta variables for lexical
                    sorts/non-terminals</para>
                  </listitem>

                  <listitem>
                    <para>Definition of variables that range over character
                    classes</para>
                  </listitem>
                </itemizedlist></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section xml:id="Modules">
    <title xml:id="modules">Modules and Modular Structure</title>

    <para>An SDF specification consists of a number of module declarations.
    The <command>sdf2table</command> commandline tool takes a file with all
    modules concatenated and the word "definition" in front of them as input.
    The ASF+SDF Meta-Environment accepts the modules in separate files, each
    with the extension ".sdf". In that case, an SDF module must be in a file
    named exactly as the name of the module. </para>

    <para>Each module may define lexical syntax, context-free syntax and
    disambiguations. Modules may import other modules for reuse or seperation
    of concerns. A module may extend the definition of a non-terminal in
    another module. A module may compose the definition of a language by
    importing the parts of the language. <note>
        <para>SDF modules not hide names in principle, there is no
        "private/public" mechanism. So beware of name clashes. Later we will
        see how the renaming facility can be used to solve name clashes
        declaratively. There is an "hiddens/exports" mechanism however, but it
        does not only hide names, it also hides the complete definitions from
        importing modules. More on that mechanism later too.</para>
      </note>The basic structure of a module is this. The module keyword is
    followed by the module name, then a series of imports can be made,
    followed by the actual definition of the syntax:<programlisting><emphasis
          role="bold">module</emphasis> &lt;ModuleName&gt;
  &lt;ImportSection&gt;*
  &lt;ExportOrHiddenSection&gt;*</programlisting> </para>

    <para>A <literal>&lt;ModuleName&gt;</literal> is either a simple
    <literal>&lt;ModuleId&gt;</literal> or a
    <literal>&lt;ModuleId&gt;</literal> followed by zero or more parameter
    symbols, e.g., <literal>&lt;Module&gt;[&lt;Symbol&gt;*]</literal>, the
    symbols will be explained <link linkend="Symbols">later</link>. The
    <literal>&lt;ModuleId&gt;</literal> may be a compound module name (i.e.
    &lt;ModuleId&gt; separated by forward slashes), the
    <literal>ModuleId</literal> reflects the directory structure. For example
    <literal>basic/Booleans</literal> means that the module
    <literal>Booleans</literal> is found in the subdirectory
    <literal>basic</literal>.</para>

    <para>An <literal>&lt;ExportOrHiddenSection&gt;</literal> is either an
    <emphasis>export section</emphasis> or a <emphasis>hidden
    section</emphasis>. The former starts with the keyword
    <literal>exports</literal> and makes all entities in the section visible
    to other modules. The latter starts with the keyword
    <literal>hiddens</literal> and makes all entities in the section local to
    the module. So, hidden means that when another module imports that module,
    none of the hiddens sections will be present in the composition. The
    effect for parser generation is that only the hiddens sections of top
    module of an SDF specification contribute to the parser generation.</para>

    <para> An <literal>&lt;ExportOrHiddenSection&gt;</literal> has thus one of
    the two forms:<programlisting><emphasis role="bold">exports</emphasis> 
  &lt;Grammar&gt;+</programlisting>or<programlisting><emphasis role="bold">hiddens</emphasis>
  &lt;Grammar&gt;+
</programlisting> A <literal>&lt;Grammar&gt;</literal> can be a definition of
    one of the following:</para>

    <itemizedlist>
      <listitem>
        <para><link linkend="Imports">Imports</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="Aliases">Aliases</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="Sorts">Sorts</link>.</para>
      </listitem>

      <listitem>
        <para><link
        linkend="ContextFreeStartSymbols">Start-symbols</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="LexicalSyntax">Lexical syntax</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="ContextFreeSyntax">Context-free
        syntax</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="Priorities">Priorities</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="Variables">Variables</link>.</para>
      </listitem>
    </itemizedlist>

    <para>Each of these entities is described and illustrated in <link
    linkend="Grammars">Grammars</link>.</para>

    <para>Note that it is possible to have hidden imports as well, this means
    that the full definition of the import definition is copied in the hiddens
    section of the importing module. </para>

    <para>Modules can also be parameterized and the symbols they defined may
    be renamed, see <link linkend="ParametersRenamings">Parameterization and
    Renamings</link>. </para>

    <para>We will now first focus on <link linkend="Symbols">Symbols</link>,
    the basic building block of grammars.</para>
  </section>

  <section xml:id="Symbols">
    <title>Symbols</title>

    <para>The elementary building block of SDF syntax rules is the symbol. It
    is comparable to terminals and non-terminals in other grammar definition
    formalisms. The elementary symbols are: <emphasis>literal</emphasis>,
    <emphasis>sort</emphasis> and <emphasis>character class</emphasis>.
    </para>

    <para>Since there is no real separation between lexical syntax and
    context-free syntax in SDF, only character classes are real
    <emphasis>terminal</emphasis> symbols. Sorts are user-defined
    non-terminals. All other symbols are short-hands for non-terminals for
    which the productions are generated for you by SDF (i.e. not user-defined
    non-terminals). You may view these automatic symbols as macros that
    generate frequently used grammatical design patterns for you. </para>

    <para>Starting with the elementary symbols, more complex symbols can be
    constructed by way of recursive symbol application. Examples of the use of
    the various operators will be given in the section <link
    linkend="sdf_Examples">Examples</link>.</para>

    <para>Remember that complex symbols such as, parameterized sorts, lists
    and optionals are nothing but non-terminals. They carry no additional
    semantics from the SDF point of view. However, there are back-ends (tools
    applied after parsing) which attribute special semantics to these kinds of
    symbols. ASF+SDF as a rewriting language is an example of a back-end that
    provides additional semantics to SDF's symbols (but only after
    parsing).</para>

    <para>Symbols are an orthogonal feature of SDF. All symbols of SDF are
    allowed in both lexical and context-free syntax, priorities and other
    parts of SDF.</para>

    <section xml:id="Literal">
      <title>Literal</title>

      <para>A <emphasis>literal</emphasis> symbol defines a fixed length word.
      This usually corresponds to a terminal symbol in ordinary BNF grammars,
      e.g., <literal>"true"</literal> or <literal>"&amp;"</literal>. Literals
      must always be quoted, also the literals consisting of letters only. SDF
      generates automatically one production for each literal in order to
      define it in terms of terminal symbols.</para>

      <programlisting>lexical syntax
  "definition" -&gt; Definition</programlisting>

      <para>will generate:</para>

      <programlisting>[d][e][f][i][n][i][t][i][o][n] -&gt; "definition"</programlisting>

      <para>The above obviously generates a case-sensitive implementation of
      the defined literal. There are also case-insensitive literals. They are
      defined using single quotes as in 'true' and 'def-word'. SDF generates a
      different production to implement case insensitivity:</para>

      <programlisting>[dD][eE][fF][\-][wW][oO][rR][dD] -&gt; 'def-word'</programlisting>

      <para>In literals, the following characters are special and should be
      escaped:</para>

      <itemizedlist>
        <listitem>
          <para><literal>"</literal>: double quote (\")</para>
        </listitem>

        <listitem>
          <para><literal>\</literal>: escape character (\\).</para>
        </listitem>
      </itemizedlist>

      <warning>
        <para>TODO, lookup escaping conventions of literals and ci
        literals.</para>
      </warning>
    </section>

    <section xml:id="Sort">
      <title xml:id="sort">Sort</title>

      <para>A sort corresponds to a non-terminal, e.g.,
      <literal>Bool</literal>. Sort names always start with a capital letter
      and may be followed by letters and/or digits. Hyphens
      (<literal>-</literal>) may be embedded in a sort name. Sort names should
      be declared in a<link linkend="sorts"> <emphasis
      role="bold">sorts</emphasis> section</link> to allow some static
      consistency checking.</para>

      <para>Sort names can have parameters. Parameterized sorts can be used to
      implement grammar polymorphism, and to facilitate grammar reuse without
      clashing sort names. It provides a way of distinguishing a
      <literal>List</literal> of integers from a List of booleans, e.g.
      <literal>List[[Int]]</literal>, versus <literal>List[[Bool]]</literal>.
      The sort parameters are usually instantiated via the parameters of a
      module or via renaming. A parameterized sort may have several
      parameters, like <literal>List[[X,Y]]</literal>. See <link
      linkend="ParametersRenamings">Parameterization and Renamings</link> for
      more details. Parameterized sorts have the following
      form:<programlisting> &lt;Sort&gt;<emphasis role="bold">[[</emphasis>&lt;Symbol<subscript>1</subscript>&gt;, &lt;Symbol<subscript>2</subscript>&gt;, ... <emphasis
            role="bold">]]</emphasis></programlisting></para>
    </section>

    <section xml:id="CharacterClass">
      <title> Character Class</title>

      <para>Enumerations of characters occur frequently mostly in lexical
      definitions. They can be abbreviated by using <emphasis>character
      classes</emphasis> enclosed by <literal>[</literal> and
      <literal>]</literal>. A character class contains a list of zero or more
      characters (which stand for themselves) or character ranges such as, for
      instance, <literal>[0-9]</literal> as an abbreviation for the characters
      <literal>0</literal>, <literal>1</literal>, ..., <literal>9</literal>.
      In a character range of the form
      c<subscript>1</subscript><literal>-</literal>c<subscript>2</subscript>
      one of the following restrictions should apply:</para>

      <itemizedlist>
        <listitem>
          <para>c<subscript>1</subscript> and c<subscript>2</subscript> are
          both lower-case letters and c<subscript>2</subscript> follows
          c<subscript>1</subscript> in the alphabet, or</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>c<subscript>1</subscript> and c<subscript>2</subscript> are
          both upper-case letters and c<subscript>2</subscript> follows
          c<subscript>1</subscript> in the alphabet, or</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>c<subscript>1</subscript> and c<subscript>2</subscript> are
          both digits and the numeric value of c<subscript>2</subscript> is
          greater than that of c<subscript>1</subscript>, or</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>c<subscript>1</subscript> and c<subscript>2</subscript> are
          both escaped non-printable characters and the character code of
          c<subscript>2</subscript> is greater than that of
          c<subscript>1</subscript></para>
        </listitem>
      </itemizedlist>

      <para><emphasis role="bold">Escape Conventions</emphasis> Characters
      with a special meaning in SDF may cause problems when they are needed as
      ordinary characters in the lexical syntax. The backslash character
      (<literal>\</literal>) is used as escape character for the quoting of
      special characters. You should use
      <literal>\</literal><replaceable>c</replaceable> whenever you need
      special character <replaceable>c</replaceable> as ordinary character in
      a definition. All individual characters in character classes, except
      digits and letters, are <emphasis>always</emphasis> escaped with a
      backslash.</para>

      <para>You may use the following abbreviations in literals and in
      character classes:</para>

      <itemizedlist>
        <listitem>
          <para><literal>\n</literal>: newline character</para>
        </listitem>

        <listitem>
          <para><literal>\r</literal>: carriage return</para>
        </listitem>

        <listitem>
          <para><literal>\t</literal>: horizontal tabulation</para>
        </listitem>

        <listitem>
          <para><literal>\</literal><replaceable>x</replaceable>: a
          non-printable character with the decimal code
          <replaceable>x</replaceable>.</para>
        </listitem>
      </itemizedlist>

      <para><emphasis role="bold">Character Class Operators</emphasis> The
      following operators are available for character classes:</para>

      <itemizedlist>
        <listitem>
          <para><literal>~</literal>: complement of character class. Accepts
          all characters not in the original class.</para>
        </listitem>

        <listitem>
          <para><literal>/</literal>: difference of two character classes.
          Accepts all characters in the first class unless they are in the
          second class.</para>
        </listitem>

        <listitem>
          <para><literal>/\</literal>: intersection of two character classes.
          Accepts all characters that are accepted by both character
          classes.</para>
        </listitem>

        <listitem>
          <para><literal>\/</literal>: union of two character classes. Accepts
          all characters that are accepted by either character class.</para>
        </listitem>
      </itemizedlist>

      <para>The first operator is a unary operator, whereas the other three
      are left-associative binary operators. Note that the character class
      operators are not applicable to symbols in general.</para>
    </section>

    <section xml:id="OptionOperator">
      <title>Option</title>

      <para>The postfix option operator <literal>?</literal> describes an
      optional part in a syntax rule. For instance,
      <literal>ElsePart?</literal> defines zero or exactly one occurrence of
      <literal>ElsePart</literal>. SDF generates the following syntax:</para>

      <programlisting>          -&gt; ElsePart?
 ElsePart -&gt; ElsePart?</programlisting>
    </section>

    <section xml:id="SequenceOperator">
      <title>Sequence</title>

      <para>The sequence operator <literal>(...)</literal> describes the
      grouping of two or more symbols, e.g., <literal>(Bool
      "&amp;")</literal>. Sequences are mostly used to group symbols together
      to form a more complex symbol using one of the available operators,
      e.g., <literal>(Bool "&amp;")*</literal>. It has no effect to construct
      a sequence consisting of a single symbol, because then the (...)
      brackets are simply brackets. The empty sequence is a special symbol.
      SDF generates the following syntax for the <literal>(Bool
      "&amp;")</literal> symbol:</para>

      <programlisting>Bool "&amp;" -&gt; (Bool "&amp;")</programlisting>

      <para>For <literal>()</literal> it simply generates:</para>

      <programlisting> -&gt; ()</programlisting>
    </section>

    <section xml:id="RepetitionOperator">
      <title>Repetition</title>

      <para>Repetition operators express that a symbol should occur several
      times. In this way it is possible to construct flat lists and therefore
      we usually refer to repetitions as \emph{lists}. Repetition operators
      come in two flavors, with and without separators. Furthermore, it is
      possible to express the minimal number of repetitions of the symbol: at
      least zero times (<literal>*</literal>) or at least one time
      (<literal>+</literal>). Examples are:</para>

      <itemizedlist>
        <listitem>
          <para><literal>Bool*</literal> (a list of zero or more
          <literal>Bool</literal>s).</para>
        </listitem>

        <listitem>
          <para><literal>{Bool ","}+</literal> (a list of one or more
          <literal>Bool</literal>s separated by comma's).</para>
        </listitem>
      </itemizedlist>

      <para>Note that the separator may be an arbitrary symbol, but that some
      back-ends do not support parse trees that contain them. The sdf-checker
      of the ASF+SDF Meta-Environment will warn you if you use anything but a
      literal as a separator.</para>

      <para>Again, to implement lists SDF simply generates a few production
      for you, i.e.:</para>

      <programlisting>             -&gt; Bool*
 Bool+       -&gt; Bool*
 Bool        -&gt; Bool+
 Bool+ Bool+ -&gt; Bool+ {left}

                             -&gt; {Bool ","}*
 {Bool ","}+                 -&gt; {Bool ","}+
 Bool                        -&gt; {Bool ","}+
 {Bool ","}+ "," {Bool ","}+ -&gt; {Bool ","}+ {left}</programlisting>

      <para>Note that there are some more productions generated, but they are
      not shown here. SDF generates more productions to allow arbitrary
      compositions of * and + lists, and also adds disambiguation filters to
      deal with the ambiguity this introduces.</para>
    </section>

    <section xml:id="AlternativeOperator">
      <title>Alternative</title>

      <para>The alternative operator <literal>|</literal> expresses the choice
      between two symbols, e.g., <literal>"true" | "false"</literal>
      represents that either a <literal>"true"</literal> symbol or a
      <literal>"false"</literal> symbol may occur here. The alternative
      operator is right associative and binds stronger than any other operator
      on symbols. This is important because <literal>Bool "," | Bool ";"
      </literal>expresses <literal>Bool ("," | Bool) ";"</literal> instead of
      <literal>(Bool ",") | (Bool ";").</literal> So, in case of doubt use the
      sequence operator in combination with the alternative operator. </para>

      <para>For "," | ";" SDF generates:</para>

      <programlisting>"," -&gt; "," | ";"
";" -&gt; "," | ";"</programlisting>
    </section>

    <section xml:id="Labels">
      <title>Labels</title>

      <para>It is possible to decorate the symbols with labels. The labels
      have no semantics in SDF, and will be removed before parsetable
      generation. Other tools that take SDF definitions as input, such as API
      generators make use of the labels.</para>

      <para>So, labels are removed by replacing the labelled symbol with the
      symbol, as in:</para>

      <programlisting>mylist:{elem:Stat sep:";"}+
is replaced by
{Stat ";"}+</programlisting>
    </section>

    <section xml:id="TupleOperator">
      <title>Tuple</title>

      <para>The tuple operator describes the grouping of a sequence of symbols
      of a fixed length into a tuple. The notation for tuples is <literal>&lt;
      , , &gt;</literal>, i.e., a comma-separated list of elements enclosed in
      angle brackets. For example, <literal>&lt;Bool, Int, Id&gt;</literal>
      describes a tuple with three elements consisting of a
      <literal>Bool</literal>, an <literal>Int</literal> and an
      <literal>Id</literal> (in that order). For instance, <literal>&lt;true,
      3, x&gt;</literal> is a valid example of such a tuple. </para>

      <para>Tuple is one of the few symbols that actually introduce a fixed
      syntax, i.e. the angular brackets. You may consider them as an arbitrary
      shorthand. To define your own short hand, consider the use of
      parameterized sorts and module paramaters.</para>

      <para>For <literal>&lt;A,B&gt;</literal> SDF generates:</para>

      <programlisting>"&lt;" A "," B "&gt;" -&gt; &lt;A,B&gt;</programlisting>
    </section>

    <section xml:id="FunctionOperator">
      <title>Function</title>

      <para>The function operator <literal>(...=&gt;...)</literal> allows the
      definition of function types. Left of <literal>=&gt;</literal> zero or
      more symbols may occur, right of <literal>=&gt;</literal> exactly one
      symbol may occur. For example, <literal>(Bool Int) =&gt; Int</literal>
      represents a function with two argument (of types
      <literal>Bool</literal> and <literal>Int</literal>, respectively) and a
      result type <literal>Int</literal>. The function symbol may be used to
      mimick a higher order type system. The function symbol also introduces
      some arbitrary syntax (the ( ) brackets).</para>

      <para>SDF generates the following syntax for (<literal>A B =&gt;
      C</literal>):</para>

      <programlisting>(A B =&gt; C) "(" A B ")" -&gt; C</programlisting>

      <para>Read this as "something of type (A B =&gt; C) may be applied to A
      and B to become a C". Note that this is the only symbol that is not
      defined by generating productions with the defined symbol on the
      right-hand side. The user must still define the syntax for (A B =&gt; C)
      manually like:</para>

      <programlisting>"myfunction" -&gt; (A B =&gt; C)</programlisting>
    </section>

    <section xml:id="LiftingOperator">
      <title>Lifted Symbols</title>

      <para>The lifting operator <literal>`...`</literal> translates the name
      of an arbitrary complex symbol to a literal syntax definition of that
      name. It makes a symbol a part of the defined syntax. An example:
      <literal>`X?`</literal> defines the syntax <literal>("X" "?")</literal>.
      The lifting operator is typically used in combination with parameterized
      modules, and specifically for applications of SDF that implement
      concrete syntax. The lifting symbol is a reflexive operator, it
      generates different syntax for different operators. </para>

      <para>Note that the lifting operator is not implemented by defining it
      using production symbols. This operator is implemented by replacing it
      with another symbol. Examples:</para>

      <programlisting>`"foo"` is replaced by "\"foo\""
`A ?"` is replaced by ("A" "?")
`{A ","}+` is replaced by ("{" "A" "\",\"" "}" "+") </programlisting>
    </section>
  </section>

  <section xml:id="Grammars">
    <title>Grammars</title>

    <para>A grammar is the entity that can be defined in an export section or
    hidden section of a module. It is a catch-all notion that covers more than
    pure grammar productions and includes</para>

    <itemizedlist>
      <listitem>
        <para><link linkend="Imports">Imports</link>: include one module in
        another one.</para>
      </listitem>

      <listitem>
        <para><link linkend="Aliases">Aliases</link>: abbreviations for
        complex symbols.</para>
      </listitem>

      <listitem>
        <para><link linkend="Sorts">Sorts</link>: the non-terminals of the
        grammar.</para>
      </listitem>

      <listitem>
        <para><link linkend="ContextFreeStartSymbols">Start-symbols</link>:
        the start symbols of the grammar.</para>
      </listitem>

      <listitem>
        <para><link linkend="LexicalSyntax">Lexical syntax</link>: the lexical
        productions of the grammar.</para>
      </listitem>

      <listitem>
        <para><link linkend="ContextFreeSyntax">Context-free syntax</link>:
        the context-free productions of the grammar.</para>
      </listitem>

      <listitem>
        <para><link linkend="Priorities">Priorities</link>: the disambiguation
        rules.</para>
      </listitem>

      <listitem>
        <para><link linkend="Variables">Variables</link>: definitions of
        variables.</para>
      </listitem>
    </itemizedlist>

    <para>An SDF module may contain as many grammars of any time as you need.
    We will now describe all these elements in turn. Also see the Section
    <link linkend="sdf_Examples">Examples</link>.</para>

    <section xml:id="Imports">
      <title xml:id="imports">Imports</title>

      <!--\index{imports@{\tt imports}} \index{{\tt <ImportSection>}@{\tt <ImportSection>} -->

      <para>Each <literal>&lt;ImportSection&gt;</literal> starts with the
      keyword <literal>imports</literal> followed by zero or more module
      names: <programlisting><emphasis role="bold">imports</emphasis>
  &lt;ModuleName&gt;*</programlisting>Modules can be combined by importing one
      module in another. Imports can occur as
      <literal>&lt;ImportSection&gt;</literal> at the topmost level of a
      module or they can occur within an exports or hiddens section. When
      importing modules at the topmost level of a module or when the import
      section occurs within the scope of an exports keyword, all exported
      entities of the imported module (and of all modules that are imported
      indirectly by it) become available in the importing module. In addition,
      they are also exported by the importing module. However, if the import
      section occurs within the scope of a hiddens keyword, the exported
      entities are only visible in the importing module but they are not
      exported by the importing module. An imported module can be
      parameterized or decorated with <link
      linkend="SymbolRenaming">renamings</link>. The name of the imported
      module can also be a compound module name. In <link
      linkend="CODE_sdfcomment">the definition of the SDF comments</link> the
      imported module <literal>basic/Whitespace</literal> is an example of
      such a compound module name.</para>
    </section>

    <section xml:id="Aliases">
      <title>Aliases</title>

      <para>In ordinary programming it is good practice to use named constants
      to represent literals or constant values. In SDF it is good practice to
      give a name (alias') to complicated symbols that occur repeatedly in the
      specification. An alias is thus a named abbreviation for a complicated
      symbol and has the following form:</para>

      <programlisting><emphasis role="bold">aliases</emphasis>
  &lt;Sort<subscript>1</subscript>&gt; -&gt; &lt;Sort<subscript>2</subscript>&gt;</programlisting>

      <para>where the alias Sort<subscript>2</subscript> is given to
      Sort<subscript>1</subscript>.</para>

      <para>For example,<programlisting>aliases
  &lt;Bool, Int, Id&gt; -&gt; Tuple3</programlisting>introduces the alias
      Tuple3 for the symbol <literal>&lt;Bool, Int, Id&gt;</literal> and
      instead of using <literal>&lt;Bool, Int, Id&gt;</literal> one can use
      the alias <literal>Tuple3</literal>. During parse table generation the
      alias is replaced by the actual symbol. It is not allowed to give an
      alias for an alias or to redefine aliases. For example, the following
      definitions are illegal:<programlisting>aliases
  Tuple3          -&gt; SuperTuple
  &lt;Bool, Int, Id&gt; -&gt; Tuple3</programlisting>(Illegal, since an alias
      is defined for the alias {\tt Tuple3}.)<programlisting>aliases
  &lt;Bool, Int, Id&gt; -&gt; Tuple3
  &lt;Bool, Int&gt;     -&gt; Tuple3</programlisting>(Illegal, since the alias
      <literal>Tuple3</literal> is redefined.) Note, the aliases are a
      convenient short hand for more complex symbols, but a drawback is that
      during parse table generation the aliases completely disappear. They are
      replaced by the actual symbols. This can have some unexpected behaviour
      when parsing or reducing terms.</para>
    </section>

    <section xml:id="Sorts">
      <title>Sorts</title>

      <para>Sorts are declared by listing their name in a sorts section of the
      form:<programlisting><emphasis role="bold">sorts</emphasis>
  &lt;Symbol&gt;*</programlisting>Only plain <literal>Sort</literal>s and
      parameterized <literal>Sort</literal>s can be declared in the
      <literal>sorts</literal> section, but more complex
      <literal>Symbol</literal>s will be syntactically recognized, but the
      <link linkend="WellformednessSDF">sdf-checker</link> will generate a
      warning. It is required that all sorts that occur in some symbol in the
      specification are declared. Recall that a sort name should start with a
      capital letter and may be followed by letters and/or digits. Hyphens
      (<literal>-</literal>) may be embedded in sort names. There is one
      predefined sort name <literal>LAYOUT</literal>. It is described in <link
      linkend="LexicalSyntax">Lexical Syntax</link>. It is not allowed (or
      necessary) to define the sorts <literal>LAYOUT</literal> and
      <literal>CHAR</literal>. These two sorts are always available.</para>
    </section>

    <section xml:id="Productions">
      <title>Productions</title>

      <para>The basic building block of a grammar is the
      <emphasis>production</emphasis>. It consists of a left-hand side of zero
      or more symbols, an arrow symbol -&gt; and a right-hand side that
      contains a symbol and an optional list of attributes. This is summarized
      as follows:</para>

      <programlisting>&lt;Symbol&gt;* <emphasis role="bold">-&gt;</emphasis> &lt;Symbol&gt;</programlisting>

      <para>The symbols in a production can be arbitrarily complex but the
      implementation may impose some limitations on this. Productions are used
      to describe lexical as well as context-free syntax, variables and
      lexical variables. Productions also occur in priority grammars. All
      productions with the same result sort together define the alternatives
      for that symbol. </para>

      <para>The most striking (but also most trivial) difference between SDF
      and EBNF is the way the production rules are written in SDF. In EBNF one
      writes production rules as<programlisting> P ::= 'b' D S 'e'</programlisting>whereas
      in SDF this is written as <programlisting>  "b" D S "e" -&gt; P</programlisting>So,
      the left- and right-hand side of the production rules are swapped.
      </para>

      <section xml:id="Attributes">
        <title>Attributes</title>

        <para>The definition of a lexical, context-free productions and
        variables may be followed by <emphasis>attributes</emphasis> that
        define additional (syntactic or semantic) properties of that function.
        The attributes are written between curly brackets after the
        non-terminal in the right hand side. If a production rule has more
        than one attribute they are separated by commas. Productions with
        attributes have thus the following form:<programlisting>&lt;Symbol&gt;* <emphasis
              role="bold">-&gt;</emphasis> &lt;Symbol&gt; <emphasis
              role="bold">{</emphasis> &lt;Attribute1&gt;<emphasis role="bold">,</emphasis> &lt;Attribute2&gt;<emphasis
              role="bold">,</emphasis> ...<emphasis role="bold">}</emphasis></programlisting>
        The following syntax-related attributes exist:</para>

        <itemizedlist>
          <listitem>
            <para><literal>{bracket}</literal> is an attribute without a
            meaning. It is not used by SDF, but some back-ends use it. For
            example, the <command>restore-brackets</command> tool uses the
            bracket attribute to find productions to add to a parse tree
            before pretty printing (when the tree violates priority
            constraints).</para>
          </listitem>

          <listitem>
            <para><literal>{left</literal>, <literal>right</literal>,
            <literal>non-assoc</literal>, <literal>assoc}</literal> are used
            to define the associativity of productions (see <link
            linkend="Priorities">Priorities</link>).</para>
          </listitem>

          <listitem>
            <para><literal>{prefer}</literal> is used to indicate that the
            attributed function should always be preferred over other
            productions (without this attribute) in certain cases of syntactic
            ambiguity (see <link linkend="PreferAvoidReject">Preferring,
            Avoiding or Rejecting Parses</link>).</para>
          </listitem>

          <listitem>
            <para><literal>{avoid}</literal> is used to indicate that a
            function should only be used as a last resort in certain cases of
            syntactic ambiguity (see <link
            linkend="PreferAvoidReject">Preferring, Avoiding or Rejecting
            Parses}</link>).</para>
          </listitem>

          <listitem>
            <para><literal>{reject}</literal> can be used to explicitly forbid
            certain syntactic construct (see <link
            linkend="PreferAvoidReject">Preferring, Avoiding or Rejecting
            Parses</link>).</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>Arbitrary ATerms may also be used as attributes. Actually
            {bracket} is one example. Another frequently occuring non-SDF
            attribute is {cons("&lt;name&gt;")}. There are tools that use this
            cons attribute to construct abstract syntax trees or to generated
            API's in C or Java to manipulate syntax trees.</para>
          </listitem>
        </itemizedlist>

        <para>Not all combinations of attributes make sense. If one uses the
        attribute <literal>left</literal> in combination with
        <literal>right</literal>, <literal>assoc</literal> or
        <literal>non-assoc</literal>, this will result in an error message.
        The combination of <literal>avoid</literal> and
        <literal>prefer</literal> does not make sense either. </para>
      </section>

      <section xml:id="PrefixFunctions">
        <title>Prefix Functions</title>

        <para><emphasis>Prefix functions</emphasis> are a special kind of
        productions. They have a prefix syntax and are an abbreviation
        mechanism for productions written as expected. For instance the
        function <literal>f(X,Y) -&gt; Z</literal> is a prefix function. SDF
        automatically replaces all prefix productions by a normal productions.
        Example:</para>

        <programlisting>f(X,Y) -&gt; Z {cons("f")} 
is replaced by
"f" "(" X "," Y ")" -&gt; Z {cons("f")}</programlisting>
      </section>
    </section>

    <section xml:id="LexicalAndContextFreeSyntax">
      <title>Lexical and Context-free syntax</title>

      <para>Lexical syntax describes the low-level structure of text while
      context-free syntax describes the higher-level structure. In SDF, these
      two aspects of syntax are defined in a very uniform manner. In fact, the
      same production rules are used to describe lexical and concrete syntax.
      The only difference between the two is that lexical productions (i.e.,
      productions appearing in a lexical syntax section) accept only input
      text as described exactly by the elements in the production, while
      context-free productions accept input text in which layout may appear
      between the elements as described by the production.</para>

      <para>At the implementation level, both lexical and context-free syntax
      are implemented using a single parsing technique. Technically, there
      exist only <emphasis>syntax</emphasis> sections. Both lexical syntax
      sections and context-free syntax sections are transformed into such
      syntax sections after appropriate insertion of optional layout between
      the elements of context-free productions. In rare cases, the
      specification writer may want to control this process explicitly and
      write syntax sections directly.</para>

      <section>
        <title xml:id="LexicalSyntax">Lexical Syntax</title>

        <para>The lexical syntax describes the low level structure of text by
        means of <emphasis>lexical tokens</emphasis>. The lexical syntax also
        defines which substrings of the text are layout symbols or comments
        and are to be skipped. A lexical syntax consists of a list of
        <emphasis>productions</emphasis>.</para>

        <para>The sort name <literal>LAYOUT</literal> is predefined and may
        not be redeclared. <literal>LAYOUT</literal> defines which parts of
        the text are <emphasis>layout symbols</emphasis> (also known as
        <emphasis>white space</emphasis>) between lexical tokens and are to be
        skipped during lexical analysis. It may only be used as result sort of
        productions in a lexical syntax section. When a string is matched by
        both a <literal>LAYOUT</literal> function and by other
        non-<literal>LAYOUT</literal> productions, then the interpretation as
        layout symbol is ignored. <literal>LAYOUT</literal> is typically used
        for defining layout and comment conventions.</para>

        <para>For each production in a lexical syntax section, a
        <emphasis>lexical constructor function is automatically
        added</emphasis>. Lexical constructor productions are used to
        construct and deconstruct lexical syntax using patterns. For each
        production <literal>A B C -&gt; D</literal> in a lexical syntax
        section, the generated constructor function is of the form: <literal>d
        "(" A B C ")" -&gt; D</literal>. Here, <literal>d</literal> is the
        name of the sort <literal>D</literal> written in lowercase letters
        only. The lexical constructor functions are considerably different
        from previous versions, when SDF had <emphasis>flat lexical
        constructors</emphasis>. Since version 2.0 <emphasis>fully structured
        lexical constructors</emphasis> are supported.</para>

        <para>Lexical syntax is described as follows:</para>

        <programlisting><emphasis role="bold">lexical syntax</emphasis>
  &lt;Production&gt;*</programlisting>
      </section>

      <section xml:id="ContextFreeSyntax">
        <title>Context-free syntax</title>

        <para>The context-free syntax describes the concrete and abstract
        syntactic structure of sentences in a language. A context-free syntax
        contains a set of declarations for <emphasis>productions</emphasis>.
        Elements of the left-hand side of a context-free function are
        separated by an invisible non-terminal <literal>LAYOUT?</literal>
        (optional <literal>LAYOUT</literal>) in order to permit layout between
        these members. This optional layout non-terminal is automatically
        inserted. Context-free syntax has the form:</para>

        <programlisting><emphasis role="bold">context-free syntax</emphasis>
   &lt;Production&gt;*</programlisting>
      </section>
    </section>

    <section xml:id="ContextFreeStartSymbols">
      <title>Lexical and Context-free start-symbols</title>

      <para>Via the lexical or context-free start symbols section the symbols
      are explicitly defined which will serve as start symbols when parsing
      terms. If no start symbols are defined it is not possible to recognize
      terms. This has the effect that input sentences corresponding to these
      symbols can be parsed. So, if we want to recognize booleans terms we
      have to define explicitly the sort <literal>Boolean</literal> as a start
      symbol in the module <literal>Booleans</literal>. Any symbol, also
      lists, tuples, etc., can serve as a start-symbol. A definition of
      lexical start symbols looks like<programlisting><emphasis role="bold">lexical start-symbols</emphasis>
  &lt;Symbol&gt;*</programlisting></para>

      <para>while context-free start symbols are defined as</para>

      <para><programlisting><emphasis role="bold">context-free start-symbols</emphasis>
  &lt;Symbol&gt;*</programlisting>Lexical or context-free start-symbol
      sections can either be hidden or exported. The effect of defined symbols
      as start symbols for the grammar may lead to an explosion of start
      states for the parser and thus lead to performance loss. To prevent this
      it can be advisable to hide start-symbol sections. The symbols defined
      are only visible in the module containing this hidden start-symbols
      section, but not in modules importing this module.</para>
    </section>
  </section>

  <section xml:id="sdf_Examples">
    <title>Examples</title>

    <para>We will now give a sequence of small examples that illustrate the
    various constructs in SDF:</para>

    <itemizedlist>
      <listitem>
        <para><link linkend="EX_Drawing">A simple lexical
        syntax</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="EX_CharacterClasses">Using character
        classes</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="EX_Drawing">A simple drawing
        language</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="EX_Identifiers">Identifiers</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="EX_Numbers">Numbers</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="EX_Strings">Strings</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="EX_IdLists">Identifier lists</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="EX_Exp">An expression language</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="EX_Labels">Using labels in
        productions</link>.</para>
      </listitem>
    </itemizedlist>

    <para>In the Section <link linkend="EX_Tricky">Some tricky cases</link>,
    we give examples of definitions that may lead to some confusion.</para>

    <section xml:id="EX_SimpleLex">
      <title>A simple lexical syntax</title>

      <para><link linkend="CODE_simplelex">Below</link> we give an example of
      a simple lexical function definition for defining the first three words
      that Dutch children learn to read. The three sorts
      <literal>Aap</literal>, <literal>Noot</literal> and
      <literal>Mies</literal>, each recognize, respectively, the strings
      <literal>aap</literal>, <literal>noot</literal> and
      <literal>mies</literal>. The sort <literal>LeesPlank</literal> (a
      reading-desk used in primary education) recognizes the single string
      <literal>aapnootmies</literal>.</para>

      <example xml:id="CODE_simplelex">
        <title>Simple lexical productions</title>

        <para><programlisting>module LeesPlank

imports basic/Whitespace

exports
  context-free start-symbols LeesPlank
  sorts Aap Noot Mies LeesPlank
  lexical syntax
    "aap"         -&gt; Aap
    "noot"        -&gt; Noot
    "mies"        -&gt; Mies
    Aap Noot Mies -&gt; LeesPlank</programlisting></para>
      </example>
    </section>

    <section xml:id="EX_CharacterClasses">
      <title>Using Character Classes</title>

      <para>Definitions for lower-case letter (<literal>LCLetter</literal>),
      upper-case letters (<literal>UCLetter</literal>), lower-case and
      upper-case letters (<literal>Letter</literal>) and digits
      (<literal>Digit</literal>) are shown in the first example <link
      linkend="CODE_LettersDigits1">below</link>}.</para>

      <example xml:id="CODE_LettersDigits1">
        <title>Defining letter (lower-case and upper-case) and digit</title>

        <para><programlisting>module LettersDigits1

imports basic/Whitespace

exports
  context-free start-symbols Letter Digit
  sorts LCLetter UCLetter Letter Digit
  lexical syntax
    [a-z]    -&gt; LCLetter
    [A-Z]    -&gt; UCLetter
    [a-zA-Z] -&gt; Letter
    [0-9]    -&gt; Digit</programlisting></para>
      </example>

      <para>The <link linkend="CODE_LettersDigits2">next example</link> gives
      a definition of the sort <literal>LetterOrDigit</literal> that
      recognizes a single letter (upper-case or lower-case) or digit.</para>

      <example xml:id="CODE_LettersDigits2">
        <title>Defining a single letter or digit</title>

        <programlisting>module LettersDigits2
imports basic/Whitespace

exports
  context-free start-symbols LetterOrDigit
  sorts LetterOrDigit
  lexical syntax
    [a-z]    -&gt; LetterOrDigit
    [A-Z]    -&gt; LetterOrDigit
    [0-9]    -&gt; LetterOrDigit</programlisting>
      </example>

      <para>The example <link linkend="CODE_LettersDigits3">below</link> gives
      the definition of a single letter or digit using the alternative
      operator <literal>\/</literal>. This definition is equivalent to the one
      given <link linkend="CODE_LettersDigits2">above</link>.</para>

      <example xml:id="CODE_LettersDigits3">
        <title>Defining a single letter or digit using the alternative
        operator</title>

        <para><programlisting>module LettersDigits3
exports
  context-free start-symbols LetterOrDigit
  sorts LetterOrDigit
  lexical syntax
    [a-z] \/ [A-Z] \/ [0-9]   -&gt; LetterOrDigit</programlisting></para>
      </example>

      <para>Another example is shown <link
      linkend="CODE_charclasses">below</link>. This definition of characters
      contains all possible characters, either by means of the ordinary
      representation or via their decimal representation.</para>

      <example xml:id="CODE_charclasses">
        <title>Example of character classes</title>

        <para><programlisting>module Characters

imports basic/Whitespace

exports
  context-free start-symbols L-Char
  sorts AlphaNumericalEscChar DecimalEscChar EscChar L-Char
  lexical syntax
    "\\" ~[]                 -&gt; AlphaNumericalEscChar

    "\\" [01] [0-9] [0-9]    -&gt; DecimalEscChar
    "\\" "2" [0-4] [0-9]     -&gt; DecimalEscChar
    "\\" "2" "5" [0-5]       -&gt; DecimalEscChar

    AlphaNumericalEscChar    -&gt; EscChar
    DecimalEscChar           -&gt; EscChar

    ~[\0-\31\"\\] \/ [\t\n]  -&gt; L-Char
    EscChar                  -&gt; L-Char</programlisting></para>
      </example>
    </section>

    <section xml:id="EX_Drawing">
      <title>A simple Drawing Language</title>

      <para>Consider the language of coordinates and drawing commands
      presented <link linkend="CODE_simple-cf">below</link>.</para>

      <example xml:id="CODE_simple-cf">
        <title>Simple context-free syntax definition</title>

        <para><programlisting>module DrawingCommands

imports basic/Whitespace

exports
  context-free start-symbols CMND 
  sorts NAT COORD CMND 

  lexical syntax
    [0-9]+ -&gt; NAT 

  context-free syntax
    "(" NAT "," NAT ")" -&gt; COORD
    "line" "to" COORD   -&gt; CMND 
    "move" "to" COORD   -&gt; CMND</programlisting></para>
      </example>

      <para>An equivalent conventional BNF grammar (and not considering
      lexical syntax) of the <link linkend="CODE_simple-cf">above
      grammar</link> is <link linkend="CODE_simple-bnf">as
      follows</link>:</para>

      <example xml:id="CODE_simple-bnf">
        <title>BNF definition of simple grammar</title>

        <para><programlisting>&lt;COORD&gt; ::= "(" &lt;NAT&gt; "," &lt;NAT&gt; ")" 
&lt;CMND&gt;  ::= "line" "to" &lt;COORD&gt; | "move" "to" &lt;COORD&gt;
</programlisting></para>
      </example>

      <para>When a literal in a context-free function consists only of
      lower-case letters and digits and is not a keyword of ASF+SDF, it need
      not be surrounded by quotes. You may therefore write <literal>move to
      COORD -&gt; CMND</literal> instead of the <link
      linkend="CODE_simple-cf">previous definition</link>. But it is better to
      always write the quotes explicitly.</para>
    </section>

    <section xml:id="EX_Identifiers">
      <title>Identifiers</title>

      <!--\index{repetition operator@repetition operator}-->

      <para>Lexical tokens are often described by patterns that exhibit a
      certain repetition. The operator described in <link
      linkend="RepetitionOperator">Repetition</link> can be used to express
      repetitions. The example <link linkend="CODE_repetition">below</link>
      demonstrates the use of the repetition operator <literal>*</literal> for
      defining identifiers consisting of a letter followed by zero or more
      letters or digits.</para>

      <example xml:id="CODE_repetition">
        <title>Defining identifiers using the repetition operator
        <literal>*</literal></title>

        <para><programlisting>module Identifiers-repetition

imports basic/Whitespace

exports
  context-free start-symbols Id
  sorts Letter DigitLetter Id
  lexical syntax
    [a-z]       -&gt; Letter
    [a-z0-9]    -&gt; DigitLetter

    Letter DigitLetter* -&gt; Id</programlisting></para>
      </example>

      <!--\index{option operator@option operator}-->

      <para>If zero or exactly one occurrence of a lexical token is desired
      the option operator described in <link
      linkend="OptionOperator">Option</link> can be used. The use of the
      option operator is illustrated <link linkend="CODE_option">below</link>.
      Identifiers are defined consisting of one letter followed by one,
      optional, digit. This definition accepts <literal>a</literal> and
      <literal>z8</literal>, but rejects <literal>ab</literal> or
      <literal>z789</literal>.</para>

      <example xml:id="CODE_option">
        <title>Defining a letter followed by an optional number using the
        option operator <literal>?</literal></title>

        <para><programlisting>module Identifiers-optional

imports basic/Whitespace

exports
  context-free start-symbols Id
  sorts Letter Digit Id
  lexical syntax
    [a-z]  -&gt; Letter
    [0-9]  -&gt; Digit

    Letter Digit? -&gt; Id </programlisting></para>
      </example>

      <!--\index{alternative operator@alternative operator}-->

      <para>Productions with the same result sort together define the lexical
      syntax of tokens for that sort. The left-hand sides of these function
      definitions form the alternatives for this function. Sometimes, it is
      more convenient to list these alternatives explicitly in a single
      left-hand side or to list alternative parts inside a left-hand side.
      This is precisely the role of the <link
      linkend="AlternativeOperator">alternative operator</link>. The example
      <link linkend="CODE_alternative1">below</link> shows how this operator
      can be used. It describes identifiers starting with an upper-case letter
      followed by one of the following:</para>

      <itemizedlist>
        <listitem>
          <para>zero or more lower-case letters,</para>
        </listitem>

        <listitem>
          <para>zero or more upper-case letters, or</para>
        </listitem>

        <listitem>
          <para>zero or more digits.</para>
        </listitem>
      </itemizedlist>

      <para>According to this definition, <literal>Aap</literal>,
      <literal>NOOT</literal>, and <literal>B49</literal> are acceptable, but
      <literal>MiES</literal>, <literal>B49a</literal> and
      <literal>007</literal> are not.</para>

      <example xml:id="CODE_alternative1">
        <title>Example of alternative operator <literal>|</literal></title>

        <para><programlisting>module Identifiers-alternative1

imports basic/Whitespace

exports
  context-free start-symbols Id
  sorts LCLetter UCLetter Digit Id
  lexical syntax
    [A-Z]   -&gt; UCLetter
    [a-z]   -&gt; LCLetter
    [0-9]   -&gt; Digit

  UCLetter LCLetter* | UCLetter* | Digit* -&gt; Id</programlisting></para>
      </example>

      <para>Note that the relation between juxtaposition and alternative
      operator is best understood by looking at the line defining
      <literal>Id</literal>. A parenthesized version of this same line would
      read as follows:<programlisting> UCLetter (LCLetter* | UCLetter* | Digit*) -&gt; Id</programlisting>As
      an aside, note that moving the <literal>*</literal> outside the
      parentheses as in <programlisting> UCLetter (LCLetter | UCLetter | Digit)* -&gt; Id</programlisting>yields
      a completely different definition: it describes identifiers starting
      with an uppercase letter followed by zero or more lower-case letters,
      uppercase letters or digits. According to this definition
      <literal>MiES</literal>, <literal>B49a</literal> and
      <literal>Bond007</literal> would, for instance, be acceptable. A
      slightly more readable definition that is equivalent to the <link
      linkend="CODE_alternative1">previous one</link> is shown <link
      linkend="CODE_alternative2">below</link>. In any case, we recommend to
      use parentheses to make the scope of alternatives explicit.</para>

      <example xml:id="CODE_alternative2">
        <title>Example of alternative operator <literal>|</literal></title>

        <para><programlisting>module Identifiers-alternative2

imports basic/Whitespace

exports
  context-free start-symbols Id
  sorts UCLetter LCLetter Digit Id
  lexical syntax
    [A-Z]   -&gt; UCLetter
    [a-z]   -&gt; LCLetter
    [0-9]   -&gt; Digit

    (UCLetter LCLetter*) | (UCLetter UCLetter*) | (UCLetter Digit*) -&gt; Id</programlisting></para>
      </example>
    </section>

    <section xml:id="EX_Numbers">
      <title>Numbers</title>

      <para>Definitions of integers and real numbers are shown <link
      linkend="CODE_numbers">below</link>. Note the use of the alternative
      operator in the definitions of <literal>UnsignedInt</literal> and
      <literal>Number</literal>. Also note the use of the option operator in
      the definitions of <literal>SignedInt</literal> and
      <literal>UnsignedReal</literal>.</para>

      <example xml:id="CODE_numbers">
        <title>Lexical definition of Numbers</title>

        <para><programlisting>module Numbers

imports basic/Whitespace

exports
  context-free start-symbols Number
  sorts UnsignedInt SignedInt UnsignedReal Number 

  lexical syntax
    [0] | ([1-9][0-9]*)                           -&gt; UnsignedInt

    [\+\-]? UnsignedInt                           -&gt; SignedInt

    UnsignedInt "." UnsignedInt ([eE] SignedInt)? -&gt; UnsignedReal 
    UnsignedInt [eE] SignedInt                    -&gt; UnsignedReal

    UnsignedInt | UnsignedReal                    -&gt; Number  </programlisting></para>
      </example>
    </section>

    <section xml:id="EX_Strings">
      <title>Strings</title>

      <para>The specification <link linkend="CODE_string">below</link>, gives
      the lexical definition of strings which may contain escaped double quote
      characters. It defines a <literal>StringChar</literal> as either</para>

      <itemizedlist>
        <listitem>
          <para>zero or more arbitrary characters except double quote or
          newline, or</para>
        </listitem>

        <listitem>
          <para>an escaped double quote, i.e., <literal>\"</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>A string consists of zero or more <literal>StringChar</literal>s
      surrounded by double quotes.</para>

      <example xml:id="CODE_string">
        <title>Lexical definition of String</title>

        <para><programlisting>module Strings

imports basic/Whitespace

exports
  context-free start-symbols String
  sorts String StringChar

  lexical syntax
    ~[\"\n]               -&gt; StringChar
    [\\][\"]              -&gt; StringChar
    "\"" StringChar* "\"" -&gt; String</programlisting></para>
      </example>
    </section>

    <section xml:id="EX_IdLists">
      <title>Identifier Lists</title>

      <para>Context-free syntax often requires the description of the
      repetition of a syntactic notion or of list structures (with or without
      separators) containing a syntactic notion. The <link
      linkend="RepetitionOperator">repetition operator</link> can be used for
      this purpose. Lists may be used in both the left-hand side and
      right-hand side of a context-free function as well as in the right-hand
      side of a <link linkend="Variables">variable declaration</link>.</para>

      <para><link linkend="CODE_pascal-ids">Here</link> is an example of how
      lists can be used to define the syntax of a list of identifiers
      (occurring in a declaration in a Pascal-like language).</para>

      <example xml:id="CODE_pascal-ids">
        <title>Definition of a list of identifiers</title>

        <para><programlisting>module Decls

imports basic/Whitespace

exports
  context-free start-symbols Decl
  sorts Id Decl Type 

  lexical syntax
    [a-z]+ -&gt; Id 

  context-free syntax
    "decl" {Id ","}+ ":" Type -&gt; Decl
    "integer"                 -&gt; Type 
    "real"                    -&gt; Type
</programlisting></para>
      </example>
    </section>

    <section xml:id="EX_Exp">
      <title>An Expression Language with Chain Rules</title>

      <para>A context-free syntax may contain productions that do not add
      syntax, but serve the sole purpose of including a smaller syntactic
      notion into a larger one. This notion is also known as
      <emphasis>injections</emphasis>. Injections are productions
      <emphasis>without a name</emphasis> and with one argument sort
      like<literal> Id -&gt; Data</literal>. A typical example is the
      inclusion of identifiers in expressions or of natural numbers in reals.
      Such a <emphasis>chain function</emphasis> has one of the following
      forms:</para>

      <itemizedlist>
        <listitem>
          <para><literal>SMALL -&gt; BIG</literal></para>
        </listitem>

        <listitem>
          <para><literal>{SMALL SEP}* -&gt; BIG</literal></para>
        </listitem>

        <listitem>
          <para><literal>SMALL* -&gt; BIG</literal></para>
        </listitem>

        <listitem>
          <para><literal>{SMALL SEP}+ -&gt; BIG</literal></para>
        </listitem>

        <listitem>
          <para><literal>SMALL+ -&gt; BIG</literal></para>
        </listitem>
      </itemizedlist>

      <para>Chain productions are not represented in the syntax tree but
      correspond to a <emphasis>subsort relation</emphasis> between
      <literal>SMALL</literal> and <literal>BIG</literal>. If
      <literal>SORT-A</literal> is a subsort of <literal>SORT-B</literal> then
      in the abstract syntax tree a tree of sort <literal>SORT-A</literal> can
      be put wherever a tree of sort <literal>SORT-B</literal> is required. In
      the example <link linkend="CODE_inj-exp">below</link> the symbols
      <literal>Nat</literal> and <literal>Var</literal> are injected in
      <literal>Exp</literal>.</para>

      <example xml:id="CODE_inj-exp">
        <title>Definition of expressions that uses injections</title>

        <para><programlisting>module Exp

imports basic/Whitespace

exports
  context-free start-symbols Exp
  sorts Nat Var Exp

  lexical syntax
    [0-9]+   -&gt; Nat
    [XYZ]    -&gt; Var

  context-free syntax
    Nat                 -&gt; Exp
    Var                 -&gt; Exp
    Exp "+" Exp         -&gt; Exp</programlisting></para>
      </example>
    </section>

    <section xml:id="EX_Labels">
      <title>Using Labels in Productions</title>

      <para>See <link linkend="CODE_labels">below</link> for an example of an
      SDF specification containing labels.</para>

      <example xml:id="CODE_labels">
        <title>The module <literal>basic/Booleans</literal> decorated with
        labels</title>

        <para><programlisting>module Booleans

imports basic/Whitespace

exports
  context-free start-symbols Boolean
  sorts Boolean

  context-free syntax
    lhs:Boolean "|" rhs:Boolean -&gt; Boolean
    lhs:Boolean "&amp;" rhs:Boolean -&gt; Boolean</programlisting></para>
      </example>
    </section>

    <section xml:id="EX_Tricky">
      <title>Some Tricky Cases</title>

      <para>In <link linkend="Symbols">Symbols</link> a number of
      sophisticated operators, like alternative, option, function, sequence,
      and tuple are discussed. These operators allow a concise manner of
      defining grammars. There are, however, a number of issues to be taken
      into consideration when using this operators.</para>

      <section>
        <title>Definition of Lists</title>

        <para>In the example <link linkend="CODE_lists-usage">below</link>,
        two different lists are defined, <literal>List1</literal> represents a
        list of naturals separated by commas whereas <literal>List2</literal>
        represents a list of naturals separated by commas and terminated by a
        comma.</para>

        <example xml:id="CODE_lists-usage">
          <title>Definition of two list variants</title>

          <para><programlisting>module Lists

imports basic/Whitespace

exports
  context-free start-symbols List1 List2
  sorts Nat List1 List2

  lexical syntax
    [0-9]+   -&gt; Nat

  context-free syntax
    {Nat ","}+ -&gt; List1
    (Nat ",")+ -&gt; List2</programlisting></para>
        </example>
      </section>

      <section>
        <title>Alternative Alternatives</title>

        <para>The choice between two symbols can be defined in two different
        ways: by two separate syntax rules or by a single syntax rule using an
        alternative operator. Both styles are shown <link
        linkend="CODE_alternative-alternatives">below</link>. The definition
        of the binary operators <literal>|</literal> and
        <literal>&amp;</literal> can be made more concise as shown by
        <literal>Bool2</literal>, however, it is now impossible to express
        that <literal>&amp;</literal> has a higher priority than
        <literal>|</literal>, see <link linkend="Priorities">Priorities</link>
        for more details on priority definitions.</para>

        <example xml:id="CODE_alternative-alternatives">
          <title>Two ways of defining <literal>|</literal> and
          <literal>&amp;</literal></title>

          <para><programlisting>module Bool

imports basic/Whitespace

exports
  context-free start-symbols Bool1 Bool2
  sorts Bool1 Bool2

  context-free syntax
    "true"                  -&gt; Bool1
    "false"                 -&gt; Bool1
    Bool1 "|" Bool1         -&gt; Bool1 {left}
    Bool1 "&amp;" Bool1         -&gt; Bool1 {left}

    "true" | "false"        -&gt; Bool2
    Bool2 ("|" | "&amp;") Bool2 -&gt; Bool2 {left}</programlisting></para>
        </example>
      </section>

      <section>
        <title>Lists in combination with optionals or empty producing
        sorts</title>

        <para>The combination of lists and optionals or empty producing sorts
        leads to cycles in the parse tree. Cycles are considered parse errors.
        The parser will produce an error message whenever during parsing a
        cycle is detected. No parse tree is constructed in such a case. Cycles
        will not lead to non-termination during parsing. See <link
        linkend="CODE_listcycle">below</link> for an example of such a
        specification.</para>

        <example xml:id="CODE_listcycle">
          <title>Dangerous combination of lists and optionals}</title>

          <para><programlisting>module Cycle

imports basic/Whitespace

exports
  context-free start-symbols T
  sorts A P T

  context-free syntax
    "a"        -&gt; A
    A?         -&gt; P
    "[" P+ "]" -&gt; T</programlisting>Sometimes commenting out parts of a
          production rule may lead to cycles, because a non-terminal becomes
          an empty producing non-terminal. This in combination with lists may
          then produce unexpected cycles.</para>
        </example>
      </section>
    </section>
  </section>

  <section xml:id="Priorities">
    <title>Priorities</title>

    <!--\index{priorities@priorities}-->

    <para>The context-free syntax defined in an SDF specification may be
    ambiguous: there are sentences which have more than one associated tree.
    The common example is the arithmetic expression in which definitions of
    the priority or associativity of operators are missing. There are three
    mechanisms for defining associativity and priority:</para>

    <!--\index{associativity@associativity}-->

    <itemizedlist>
      <listitem>
        <para><link linkend="RelativePriorities">Relative priorities of
        productions </link>defined in the <literal>context-free
        priorities</literal> section.</para>
      </listitem>

      <listitem>
        <para><link linkend="AssociativeFunctions">Associativity of
        productions</link> defined as attributes following the function
        declaration.</para>
      </listitem>

      <listitem>
        <para><link linkend="GroupAssoc">Associativity of groups of
        productions</link> defined in the <literal>context-free
        priorities</literal> section.</para>
      </listitem>
    </itemizedlist>

    <para>Closely related with priorities are brackets that can be used to
    overrule priorities. We will first describe bracket productions, and then
    the various methods for defining priorities.</para>

    <section xml:id="BracketFunctions">
      <title>Bracket Productions</title>

      <!--\index{bracket Productions@bracket Productions}-->

      <para>A bracket function has the form:<programlisting>&lt;Open&gt; &lt;Sort&gt; &lt;Close&gt; <emphasis
            role="bold"><emphasis role="bold">-&gt;</emphasis></emphasis> <replaceable>&lt;</replaceable>Sort&gt;</programlisting></para>

      <para>where &lt;Open&gt; and &lt;Close&gt; are literals acting as
      opening and closing parenthesis for sort &lt;Sort&gt;. Examples are
      <literal>(</literal> and <literal>)</literal> in arithmetic expressions.
      In most cases, such brackets are only introduced for grouping and
      disambiguation, but have no further meaning. By adding the attribute
      <literal>bracket</literal> to the function declaration, it will not be
      included in the abstract syntax. The definition of a bracket function
      for the sort <literal>Expr</literal> is given <link
      linkend="CODE_bracket-expr">below</link>.</para>

      <example xml:id="CODE_bracket-expr">
        <title>Syntax definition with a bracket function</title>

        <para><programlisting>module BracketExpr

imports basic/Whitespace
imports basic/NatCon

exports
  context-free start-symbols E
  sorts E

  context-free syntax
    NatCon    -&gt; E
    "(" E ")" -&gt; E {bracket}</programlisting></para>
      </example>

      <para>Since brackets are necessary for overruling the priority and
      associativity of productions, it is required that bracket productions
      are declared for the argument and result sorts of</para>

      <itemizedlist>
        <listitem>
          <para>all productions appearing in priority declarations, and</para>
        </listitem>

        <listitem>
          <para>all productions having one of the attributes
          <literal>left</literal>, <literal>right</literal>,
          <literal>assoc</literal>, or <literal>non-assoc</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="RelativePriorities">
      <title>Relative Priorities</title>

      <!--\index{relative priorities@relative priorities}-->

      <para>The relative priority of two productions is defined in the
      <literal>context-free priorities</literal> section by
      including<replaceable> F</replaceable> <literal>&gt;</literal>
      <replaceable>G</replaceable>, where <replaceable>F</replaceable> and
      <replaceable>G</replaceable> are as written in the context-free grammar.
      Productions with a higher priority bind more strongly than productions
      with lower priorities and the nodes corresponding to them should thus
      appear at lower levels in the tree than nodes corresponding to
      productions with lower priorities. Lists of productions may be used in a
      priority declaration: <replaceable>F</replaceable> <literal>&gt;
      {</literal><replaceable>G</replaceable><literal>,</literal>
      <replaceable>H</replaceable><literal>}</literal> is an abbreviation for
      <replaceable>F</replaceable> <literal>&gt;
      </literal><replaceable>G</replaceable><literal>,</literal>
      <replaceable>F</replaceable> <literal>&gt;</literal>
      <replaceable>H</replaceable>. Note that this tells us nothing about the
      priority relation between <replaceable>G</replaceable> and
      <replaceable>H</replaceable>.</para>
    </section>

    <section xml:id="AssociativeFunctions">
      <title>Associative Productions</title>

      <!--\index{associativity productions@associativity productions}-->

      <para>Associativity attributes can be attached to binary productions of
      the form <replaceable>S</replaceable>
      <literal><replaceable>op</replaceable></literal>
      <replaceable>S</replaceable> <literal>-&gt;</literal>
      <replaceable>S</replaceable>, where
      <literal><replaceable>op</replaceable></literal> is a symbol or empty.
      Without associativity attributes, nested occurrences of such productions
      immediately lead to ambiguities, as is shown by the sentence
      <replaceable>S-string</replaceable>
      <literal><replaceable>op</replaceable></literal>
      <replaceable>S-string</replaceable>
      <literal><replaceable>op</replaceable></literal>
      <replaceable>S-string</replaceable> where
      <replaceable>S-string</replaceable> is a string produced by symbol
      <replaceable>S</replaceable>. The particular associativity associated
      with <replaceable>op</replaceable> determines the intended
      interpretation of such sentences. We call two occurrences of productions
      <replaceable>F</replaceable> and <replaceable>G</replaceable>
      <emphasis>related</emphasis>, when the node corresponding to
      <replaceable>F</replaceable> has a node corresponding to
      <replaceable>G</replaceable> as first or last child. The associativity
      attributes define how to accept or reject trees containing related
      occurrences of the same function, <replaceable>F</replaceable>:</para>

      <itemizedlist>
        <listitem>
          <para><literal>left</literal>: related occurrences of
          <replaceable>F</replaceable> associate from left to right.</para>
        </listitem>

        <listitem>
          <para><literal>right</literal>: related occurrences of
          <replaceable>F</replaceable> associate from right to left.</para>
        </listitem>

        <listitem>
          <para><literal>assoc</literal>: related occurrences of
          <replaceable>F</replaceable> associate from left to right.</para>
        </listitem>

        <listitem>
          <para><literal>non-assoc</literal>: related occurrences of
          <replaceable>F</replaceable> are not allowed.</para>
        </listitem>
      </itemizedlist>

      <para>Currently, there is no syntactic or semantic difference between
      <literal>left</literal> and <literal>assoc</literal>, but &#160;we may
      change the semantics of the assoc attribute in the future. <remark>Is
      this really true?</remark></para>

      <para><link linkend="CODE_simple-prio">Below</link> we give an example
      of a definition of simple arithmetic expressions with the usual
      priorities and associativities.</para>

      <example xml:id="CODE_simple-prio">
        <title>Simple context-free priority definition</title>

        <para><programlisting>module SimpleExpr

imports basic/Whitespace
imports basic/NatCon

exports
  context-free start-symbols E 
  sorts E 

  context-free syntax
    NatCon    -&gt; E
    E "+" E   -&gt; E {left}
    E "*" E   -&gt; E {left}
    "(" E ")" -&gt; E {bracket}

  context-free priorities
    E "*" E -&gt; E &gt; 
    E "+" E -&gt; E
</programlisting></para>
      </example>
    </section>

    <section xml:id="GroupAssoc">
      <title>Groups of Associative Productions</title>

      <para><!--\index{associativity groups@associativity groups}-->Groups of
      associative productions define how to accept or reject trees containing
      related occurrences of different productions with the same priority.
      They are defined by prefixing a list of context-free productions in a
      priority declaration with one of the following attributes:</para>

      <itemizedlist>
        <listitem>
          <para><literal>left</literal>: related occurrences of
          <replaceable>F</replaceable> and <replaceable>G</replaceable>
          associate from left to right.</para>
        </listitem>

        <listitem>
          <para><literal>right</literal>: related occurrences of
          <replaceable>F</replaceable> and <replaceable>G</replaceable>
          associate from right to left.</para>
        </listitem>

        <listitem>
          <para><literal>non-assoc</literal>: related occurrences of
          <replaceable>F</replaceable> and <replaceable>G</replaceable> are
          not allowed.</para>
        </listitem>
      </itemizedlist>

      <para>where <replaceable>F</replaceable> and
      <replaceable>G</replaceable> are productions appearing in the list.
      <link linkend="CODE_complex-prio">Below</link> is an example of the use
      of grouped associativity.</para>

      <example xml:id="CODE_complex-prio">
        <title>More complex associativity and priority definitions</title>

        <para><programlisting>module ComplexExpr

imports basic/Whitespace
imports basic/NatCon

exports
  context-free start-symbols E 

  sorts E 

  context-free syntax
    NatCon    -&gt; E
    E "+" E   -&gt; E {left}
    E "-" E   -&gt; E {non-assoc}
    E "*" E   -&gt; E {left}
    E "/" E   -&gt; E {non-assoc}
    E "^" E   -&gt; E {right}
    "(" E ")" -&gt; E {bracket}

  context-free priorities
    E "^" E -&gt; E &gt; 
    {non-assoc: E "*" E -&gt; E
                E "/" E -&gt; E} &gt;
    {left: E "+" E -&gt; E
           E "-" E -&gt; E} </programlisting></para>
      </example>
    </section>

    <section xml:id="Restrictions">
      <title>Restrictions</title>

      <!--\index{restrictions@restrictions} \index{lexical restrictions@lexical restrictions} \index{context-free restrictions@context-free restrictions} \index{{\tt -/-}@{\tt -/-}} \index{{\tt <Lookaheads>}@{\tt <Lookaheads>}}-->

      <para>Lexical syntax can be highly ambiguous. Consider a simple lexical
      definition for identifiers like the one given <link
      linkend="CODE_repetition">earlier</link>. When recognizing the text
      <literal>abc</literal>, what should we return: <literal>a</literal>,
      <literal>ab</literal> or, <literal>abc</literal>? We discuss the
      strategy <emphasis>Prefer Longest Match</emphasis> for resolving this
      kind of ambiguity in <link linkend="lex-ambiguity">Lexical
      Ambiguities</link>}. Here, we describe the notion of
      <emphasis>restrictions</emphasis> that enable the formulation of this
      and other lexical disambiguation strategies. A restriction limits the
      <emphasis>lookahead</emphasis> for a given symbol; it indicates that a
      symbol may not be followed by a character from a given character class.
      A lookahead may consist of more than one character class. Restrictions
      come in two flavors:</para>

      <itemizedlist>
        <listitem>
          <para>lexical restrictions;</para>
        </listitem>

        <listitem>
          <para>context-free restrictions.</para>
        </listitem>
      </itemizedlist>

      <para>The general form of a restriction is:<programlisting>&lt;Symbol&gt;+ <emphasis
            role="bold">-/-</emphasis> &lt;Lookaheads&gt;</programlisting>In
      case of lexical restrictions <literal>&lt;Symbol&gt;</literal> may be
      either a literal or sort. In case of context-free restrictions only a
      sort or symbol is allowed. The restriction operator
      <literal>-/-</literal> should be read as <emphasis>may not be followed
      by</emphasis>. Before the restriction operator <literal>-/-</literal> a
      list of symbols is given for which the restriction holds.</para>

      <para>In the example <link linkend="CODE_functional">below</link> both
      <literal>let</literal> and <literal>in</literal> may not be followed by
      a letter. This example shows how lexical restrictions can be used to
      prevent the recognition of erroneous expressions in a small functional
      language. The lexical restriction deals with the possible confusion
      between the reserved words <literal>let</literal> and
      <literal>in</literal> and variables (of sort <literal>Var</literal>). It
      forbids the recognition of, for instance, <literal>let</literal> as part
      of <literal>letter</literal>. Without this restriction
      <literal>letter</literal> would be recognized as the keyword
      <literal>let</literal> followed by the variable <literal>ter</literal>.
      The context-free restriction forbids that a variable is directly
      followed by a letter. It does not forbid layout characters between the
      letters, e.g. <literal>a b</literal> is a legal recognizable
      string.</para>

      <para></para>

      <example xml:id="CODE_functional">
        <title>Using restrictions in the definition of a simple functional
        language</title>

        <para><programlisting>module Functional

imports basic/Whitespace

exports
  context-free start-symbols Term 
  sorts Var Term
  lexical syntax
    [a-z]+ -&gt; Var
  context-free syntax
    Var                          -&gt; Term
    Term Term                    -&gt; Term {left}
    "let" Var "=" Term "in" Term -&gt; Term

  lexical restrictions
    "let" "in" -/- [a-z]

  context-free restrictions
    Var -/- [a-z]  </programlisting></para>
      </example>

      <para><literal>&lt;Lookaheads&gt;</literal> are slightly more complex.
      The most compact way is to give the SDF definition of the
      <literal>&lt;Lookaheads&gt;</literal> and illustrate their use by means
      of some examples:</para>

      <para><programlisting>context-free syntax
  CharClass                    -&gt; Lookahead
  CharClass "." Lookaheads     -&gt; Lookahead
  Lookahead                    -&gt; Lookaheads
  Lookaheads "|" Lookaheads    -&gt; Lookaheads {right}
  "(" Lookaheads ")"           -&gt; Lookaheads {bracket}
  "[[" {Lookahead ","}* "]]"   -&gt; Lookaheads 
</programlisting>The next example illustrates the use of restrictions to
      define a <emphasis>safe</emphasis> way of layout. <link
      linkend="LexicalSyntax">Recall</link> that optional layout, represented
      by the symbol<literal> LAYOUT?</literal>, may be recognized between the
      members of the left-hand side of a context-free syntax rule. However, if
      a such a member recognizes the empty string, this gives rise to a <link
      linkend="lex-ambiguity">lexical ambiguity</link>. This problem is
      avoided by the definition given <link
      linkend="CODE_safe-layout">below</link>: it simply forbids that optional
      layout is followed by layout characters.</para>

      <para><example xml:id="CODE_safe-layout">
          <title>Safe way of defining <literal>LAYOUT</literal></title>

          <para><programlisting>module basic/Whitespace

exports
  lexical syntax
    [\ \t\n] -&gt; LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n]</programlisting></para>
        </example></para>

      <para>The example shown <link linkend="CODE_c-comment">below</link>
      illustrates the use of restrictions to extend the previous layout
      definition with C-style comments. For readability we give here
      <emphasis>two</emphasis> restrictions whereas the first one is already
      imported from <link linkend="CODE_safe-layout">module
      basic/Whitespace</link>. The repetition of this first restriction is
      redundant and could be eliminated.<example xml:id="CODE_c-comment">
          <title>Definition of C comments</title>

          <para><programlisting>module Comment

imports basic/Whitespace

exports
  sorts ComWord Comment
  lexical syntax
    ~[\ \n\t\/]+ -&gt; ComWord

  context-free syntax
    "/*" ComWord* "*/" -&gt; Comment
    Comment            -&gt; LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n]
    LAYOUT? -/- [\/].[\*]</programlisting></para>
        </example></para>

      <para>A frequently asked question is when to use
      <emphasis>lexical</emphasis> restrictions and when to use
      <emphasis>context-free</emphasis> restrictions. In one of the <link
      linkend="CODE_functional">previous examples</link> the lexical
      restrictions on <filename>let</filename> and <literal>in</literal>
      cannot be defined using context-free restrictions because these keywords
      do not "live" at the context-free level. Is it possible to put a lexical
      restriction on <literal>Var</literal>? Yes, but it will have no effect,
      because internally the lexical <literal>Var</literal> is injected in the
      context-free <literal>Var</literal>. The general rule is to define the
      restrictions always on the context-free level and not on the lexical
      level unless a situation as will be discussed in the next paragraph
      occurs. The specification <link
      linkend="CODE_restrictedexpressions">below</link> is an example of an
      erroneous use of context-free expressions, because it prevents the
      recognition of <literal>(abc)def</literal>. If we want to enforce the
      correct restriction, it is necessary to transform this context-free
      restriction into a lexical restriction.</para>

      <para><example xml:id="CODE_restrictedexpressions">
          <title>Erroneous use of restrictions in the definition of simple
          expressions</title>

          <para><programlisting>module RestrictedExpressions

imports basic/Whitespace

exports
  context-free start-symbols Expr
  sorts Expr

  lexical syntax
    [a-z]+ -&gt; Expr

  context-free syntax
    Expr Expr    -&gt; Expr {left}
    "(" Expr ")" -&gt; Expr {bracket}

  context-free restrictions
    Expr -/- [a-z]</programlisting></para>
        </example></para>
    </section>

    <section xml:id="PreferAvoidReject">
      <title>Preferring, Avoiding or Rejecting Parses</title>

      <para>Priorities can be used to define a priority between two
      productions or between two groups of productions. In both cases the
      productions involved have to be listed explicitly in the priority
      declaration. In certain cases, however, it is desirable to define that a
      single rule has higher or lower priority than all other productions or
      to explicitly reject certain syntactic constructs. The former is
      achieved by the attributes <literal>prefer</literal> and
      <literal>avoid</literal>. The latter by the attribute
      <literal>reject</literal>. The use of the <literal>reject</literal>
      attribute leads also to improvements in the performance of the parser.
      If a function <replaceable>F</replaceable> is attributed with
      <literal>prefer</literal> and there is a syntactic ambiguity in which it
      is involved, only the parse using <replaceable>F</replaceable> will
      remain. If a function <replaceable>F</replaceable> is attributed with
      <literal>avoid</literal> and there is no ambiguity, then
      <replaceable>F</replaceable> will be used. If there is an ambiguity,
      then <replaceable>F</replaceable> will be immediately removed from the
      set of ambiguities. If a function <replaceable>F</replaceable> is
      attributed with <literal>reject</literal>, then independently of the
      number of ambiguities, the parse using <replaceable>F</replaceable> will
      be removed. While <link linkend="Restrictions">restrictions</link> only
      impose limitations on the immediate lookahead that follows a symbol, the
      reject mechanism can be used to eliminate complicated syntactic
      structures. Examples of the use of <literal>prefer</literal>,
      <literal>avoid</literal> and <literal>reject</literal> in order to solve
      lexical ambiguities are discussed in <link
      linkend="lex-ambiguity">Lexical Ambiguities</link>. In <link
      linkend="cf-ambiguity">Context-free Ambiguities</link> we will give
      examples of how to use these attributes to solve context-free
      ambiguities, such as the famous dangling else problem.</para>
    </section>
  </section>

  <section xml:id="Disambiguation">
    <title>Disambiguation</title>

    <section xml:id="lex-ambiguity">
      <title>Lexical Ambiguities</title>

      <para>SDF provides a number of elementary lexical disambiguation
      features but does not offer <emphasis>fully automated</emphasis> lexical
      disambiguation. As a result, the specification writer has to be aware of
      lexical ambiguities and has to specify disambiguation rules explicitly.
      We will discuss various approaches to lexical disambiguation and
      illustrate them by means of examples.</para>

      <formalpara>
        <title>Prefer Longest Match per Sort</title>

        <para>Reject all interpretations of the input text that are included
        in a longer interpretation of the same sort. Given a standard
        definition of identifiers, the input <literal>xyz</literal> will thus
        lead to recognition of the identifier <literal>xyz</literal> and not
        to either <literal>x</literal> or <literal>xy</literal>. This is
        achieved by defining a restriction on this lexical sort. This can be
        done using either lexical or context-free <link
        linkend="Restrictions">restrictions</link>. The specification <link
        linkend="CODE_restrict-id">below</link> shows how to enforce the
        longest match for the sort <literal>Id</literal>.</para>
      </formalpara>

      <example xml:id="CODE_restrict-id">
        <title>Using context-free restrictions to define a longest match for
        identifiers</title>

        <para><programlisting>module Identifiers-restrict

imports basic/Whitespace

exports
  context-free start-symbols Id
  sorts Id
  lexical syntax
    [a-zA-Z][a-zA-Z0-9]* -&gt; Id

  context-free restrictions
    Id -/- [a-zA-Z0-9]</programlisting></para>
      </example>

      <formalpara>
        <title>Prefer Literals</title>

        <para>In the left-hand side of a context-free syntax rule literals
        (keywords and/or operators) may be used. If these literals overlap
        with more general lexical tokens (such as identifier) this causes
        ambiguities. The strategy <emphasis>Prefer Literals</emphasis> gives
        preference to interpretation as a literal, over interpretation as a
        more general lexical token. For instance, the keyword
        <literal>begin</literal> may be recognized as an identifier given the
        lexical definition <link linkend="CODE_restrict-id">below</link>.
        There are two approaches to implement Prefer Literals. In the first
        approach, we can explicitly forbid the recognition of literals as
        tokens of a specific sort using the <link
        linkend="PreferAvoidReject">reject mechanism</link>. The idea is to
        define context-free grammar rules for all literals with the undesired
        lexical sort (e.g., <literal>Id</literal>) in the right-hand side
        followed by the attribute <literal>reject</literal>. This is
        illustrated <link linkend="CODE_restrict-id">below</link>. The
        <literal>reject</literal> attribute indicates here that the
        recognition of a keyword as a literal of the sort
        <literal>Id</literal> should be rejected. This approach has the major
        disadvantage that the addition of a literal in any context-free rule
        also requires the addition of a new reject rule for that
        literal.</para>
      </formalpara>

      <example xml:id="CODE_reject-id">
        <title>Using <literal>reject</literal> to implement Prefer
        Literals</title>

        <para><programlisting>module Identifiers-reject

imports basic/Whitespace

exports
  context-free start-symbols Id
  sorts Id

  lexical syntax
    [a-zA-Z][a-zA-Z0-9]* -&gt; Id

  context-free restrictions
    Id -/- [a-zA-Z0-9]  

  context-free syntax
    "begin" -&gt; Id {reject}   </programlisting></para>
      </example>

      <para>The second approach is more attractive. The lexical definition of
      the general notion that interferes with our literals is written in such
      a way that it is only used as a last resort. In other words, it is
      avoided as much as possible and is only used when no alternative exists.
      The attribute avoid defines precisely this behaviour <link
      linkend="PreferAvoidReject">Preferring, Avoiding or Rejecting
      Parses</link>. The <link linkend="CODE_avoid-id">next example</link>
      shows how the lexical definition of <literal>Id</literal> is attributed
      with <literal>avoid</literal>. Although the first approach is more
      tedious, it allows more flexibility than the second one.</para>

      <example xml:id="CODE_avoid-id">
        <title>Using <literal>avoid</literal> to implement Prefer
        Literals</title>

        <para><programlisting>module Identifiers-avoid

imports basic/Whitespace

exports
  context-free start-symbols Id
  sorts Id

  lexical syntax
    [a-zA-Z][a-zA-Z0-9]* -&gt; Id {avoid}

  context-free restrictions
    Id -/- [a-zA-Z0-9]</programlisting></para>
      </example>

      <formalpara>
        <title>Prefer Non-Layout</title>

        <para>If there are interpretations of the text as layout symbol and as
        non-layout symbol, eliminate all interpretations as layout symbol.
        This is built-in behaviour of ASF+SDF.</para>
      </formalpara>

      <formalpara>
        <title>Prefer Variables</title>

        <para>Give preference to interpretation as a variable (as defined in a
        variables section) over interpretation as a lexical token. Thus
        built-in behaviour of ASF+SDF. It is achieved by automatically
        extending each variable declaration with the attribute
        <literal>prefer</literal> (see <link
        linkend="PreferAvoidReject">Preferring, Avoiding or Rejecting
        Parses</link>.</para>
      </formalpara>
    </section>

    <section xml:id="cf-ambiguity">
      <title>Context-free Ambiguities</title>

      <para>Context-free grammars may be ambiguous and, as a result, the
      parser may yield different parses of a text. More precisely, the result
      of a parse is a single tree in which the ambiguities are explicitly
      marked. Each marked ambiguity consists of a set of different parse trees
      for that ambiguity. Many, but not all, of these different parses can be
      eliminated by the following strategies that are built-in in The
      Meta-Environment. These strategies use the priorities and
      associativities as defined in the specification. In addition, some
      standard heuristics are used.</para>

      <formalpara>
        <title>Associativity filtering</title>

        <para>The associativity filtering is performed during the generation
        of the parse table. Based on the associativity relations certain
        entries in the parse table are removed.</para>
      </formalpara>

      <formalpara>
        <title>Removing Trees containing Conflicts</title>

        <para>The simplest application of priority and associativity
        declarations is the elimination of trees that contain
        conflicts:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para>A parent node has a child with a lower priority than the
          parent itself.</para>
        </listitem>

        <listitem>
          <para>A parent has a first or last child that is in conflict wit an
          associativity relation between this parent and child.</para>
        </listitem>
      </itemizedlist>

      <para>Reconsidering the example of complex priorities shown <link
      linkend="CODE_complex-prio">earlier</link> we will give a number of
      example sentences and the interpretation given to them by that language
      definition.</para>

      <table border="1">
        <caption>Arithmetic expressions and their interpretation</caption>

        <tr>
          <td>Sentence</td>

          <td>Interpretation</td>
        </tr>

        <tr>
          <td><literal>1^2^3</literal></td>

          <td><literal>1^(2^3)</literal></td>
        </tr>

        <tr>
          <td><literal>1^2*3</literal></td>

          <td><literal>(1^2)*3</literal></td>
        </tr>

        <tr>
          <td><literal>1*2*3</literal></td>

          <td><literal>(1*2)*3</literal></td>
        </tr>

        <tr>
          <td><literal>1/2/3</literal></td>

          <td><emphasis>error</emphasis></td>
        </tr>

        <tr>
          <td><literal>1*2/3</literal></td>

          <td><emphasis>error</emphasis></td>
        </tr>

        <tr>
          <td><literal>1-2-3</literal></td>

          <td><emphasis>error</emphasis></td>
        </tr>

        <tr>
          <td><literal>1+2+3</literal></td>

          <td><literal>(1+2)+3</literal></td>
        </tr>

        <tr>
          <td><literal>1-2+3</literal></td>

          <td><literal>(1-2)+3</literal></td>
        </tr>

        <tr>
          <td><literal>1+2-3</literal></td>

          <td><literal>(1+2)-3</literal></td>
        </tr>
      </table>

      <formalpara>
        <title>Removing Trees using
        <literal>prefer</literal>/<literal>avoid</literal> Attributes at the
        Root</title>

        <para>The priority declarations are used to eliminate trees in three
        phases:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para>If there are trees of which the syntax rule at the top node
          has a <literal>prefer</literal> attribute, all other trees are
          removed.</para>
        </listitem>

        <listitem>
          <para>If there are trees of which the syntax rule at the top node
          has an <literal>avoid</literal> attribute and there are other trees
          without an <literal>avoid</literal> attribute at the root node, then
          all trees with <literal>avoid</literal> attribute are
          removed.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Removing Trees containing
        <literal>prefer</literal>/<literal>avoid</literal> Attributes</title>

        <para>After removing all trees containing conflicts, more than one
        tree may still remain. To further reduce this set of remaining trees,
        the number of context-free productions with
        <literal>prefer</literal>/<literal>avoid</literal> attributes is
        calculated and compared. A tree in the set is then rejected if there
        is another tree in the set with more {\tt prefer}s and less or equal
        <literal>avoid</literal>s, or with equal <literal>prefer</literal>s
        and more <literal>avoid</literal>s.</para>
      </formalpara>

      <formalpara>
        <title>Injection count</title>

        <para>Finally, the number of injections in each of the resulting trees
        is calculated, the tree with the smallest number of injections is
        preferred.</para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para>The following examples show how the interaction (and resulting
        ambiguities) between general context-free productions and special case
        productions can be described using <literal>prefer</literal>
        attribute.</para>
      </formalpara>

      <para>The <link linkend="CODE_eqn-exprs">first example</link> concerns
      expressions for describing subscripts and superscripts in the
      typesetting language EQN. The crucial point is that, for typesetting
      reasons, we want to treat a subscript followed by a superscript in a
      special way. Therefore, the special case <literal>E sub E sup E -&gt;
      E</literal> is introduced, which is preferred over a combination of the
      two productions <literal>E sub E -&gt; E </literal>and <literal>E sup E
      -&gt; E</literal>.</para>

      <example xml:id="CODE_eqn-exprs">
        <title>Syntax definition of EQN expressions</title>

        <para><programlisting>module Eqn

imports basic/Whitespace

exports
  context-free start-symbols E
  sorts E 

  context-free syntax
    E "sub" E         -&gt; E {left}
    E "sup" E         -&gt; E {left}
    E "sub" E "sup" E -&gt; E {prefer}
    "{" E "}"         -&gt; E {bracket}
    "a"               -&gt; E</programlisting></para>
      </example>

      <para>In the <link linkend="CODE_dangling-else">second example</link>
      the <literal>prefer</literal> attribute is used to solve the dangling
      else problem in a nice way. The input sentence <literal>if 0 then if 1
      then hi else ho</literal> can be parsed in two ways: <literal>if 0 then
      (if 1 then hi) else ho</literal> and <literal>if 0 then (if 1 then hi
      else ho)</literal>. We can select the latter derivation by adding the
      {\tt prefer} attribute to the production without the {\tt else} part.
      The parser will still construct an ambiguity node containing both
      derivations, namely, if 0 then (if 1 then hi {prefer}) else ho} and
      <literal>if 0 then (if 1 then hi else ho) {prefer}</literal>. But given
      the fact that the <emphasis>top</emphasis> node of the latter derivation
      tree has the prefer attribute this derivation is selected and the other
      tree is removed from the ambiguity node.</para>

      <example xml:id="CODE_dangling-else">
        <title>Syntax definition of conditionals</title>

        <para><programlisting>module DanglingElse

imports basic/Whitespace

exports
  context-free start-symbols S
  sorts E S

  context-free syntax
    "a"                      -&gt; E 
    "if" E "then" S          -&gt; S {prefer}
    "if" E "then" S "else" S -&gt; S
    "s"                      -&gt; S</programlisting></para>
      </example>
    </section>
  </section>

  <section xml:id="ParametersRenamings">
    <title>Parameterization and Renaming</title>

    <section xml:id="Parameterization">
      <title>Parameterization</title>

      <para>Module parameterization allows the definition of generic modules
      for lists, pairs, sets, etc. The operations defined in these modules are
      independent of a specific type. When importing a parameterized module
      and instantiating the formal by actual parameters the operations become
      sort specific. Modules can have formal parameters when defining them.
      The module name is then followed by a list of symbols, representing the
      formal parameters of this module. The specification <link
      linkend="CODE_generic-pairs">below</link> shows an example of a
      parameterized module. In this example the formal parameters are used in
      the parameterized sorts as well, in order to increase readability and to
      avoid name clashes between different instances of the same
      module.</para>

      <example xml:id="CODE_generic-pairs">
        <title>Definition of generic pairs</title>

        <para><programlisting>module Pair[X Y]

imports basic/Whitespace
imports basic/Booleans

hiddens
  sorts X Y

exports
  context-free start-symbols Pair[[X,Y]]
  sorts Pair[[X,Y]]

  context-free syntax
    "[" X "," Y "]"      -&gt; Pair[[X,Y]]

    make-pair(X, Y)      -&gt; Pair[[X,Y]]
    first(Pair[[X,Y]])   -&gt; X
    second(Pair[[X,Y]])  -&gt; Y
    is-pair(Pair[[X,Y]]) -&gt; Boolean</programlisting></para>
      </example>

      <para>When importing a parameterized module the formal parameters have
      to be replaced by actual parameters. The specification <link
      linkend="CODE_importing-pairs">below</link> shows an example of a rather
      complicated import of a parameterized module. The symbols
      <literal>Pair[[Boolean,Boolean]] </literal>and
      <literal>Pair[[Integer,Integer]]</literal> are the actual parameters of
      the module <literal>Pair[X Y]</literal> in the last import.</para>

      <example xml:id="CODE_importing-pairs">
        <title>Use of generic pair module</title>

        <para><programlisting>module TestPair

imports basic/Booleans 
imports basic/Integers 
imports Pair[Boolean Boolean]
imports Pair[Integer Integer]
imports Pair[Pair[[Boolean,Boolean]] Pair[[Integer,Integer]]]</programlisting></para>
      </example>
    </section>

    <section xml:id="SymbolRenaming">
      <title>Symbol Renaming</title>

      <para>Symbol renaming is in fact very similar to parameterization except
      that it is not necessary to add formal parameters to a module. The
      mechanism of symbol renaming allows the overriding of one symbol or a
      set of symbols by another symbol or symbols, respectively. It allows a
      flexible and concise way of adapting specifications. The specification
      <link linkend="CODE_pairs">below</link> shows an example of the
      <literal>Pair</literal> module without parameters. The idea is to
      achieve the same effect as parameterization by explicitly renaming
      <literal>X</literal> and <literal>Y</literal> to the desired names when
      <literal>Pair</literal> is imported.<example xml:id="CODE_pairs">
          <title>Definition of generic pairs</title>

          <para><programlisting>module Pair

imports basic/Whitespace
imports basic/Booleans

hiddens
  sorts X Y

exports
  context-free start-symbols Pair[[X,Y]]
  sorts Pair[[X,Y]]

  context-free syntax
    "[" X "," Y "]"      -&gt; Pair[[X,Y]]

    make-pair(X, Y)      -&gt; Pair[[X,Y]]
    first(Pair[[X,Y]])   -&gt; X
    second(Pair[[X,Y]])  -&gt; Y
    is-pair(Pair[[X,Y]]) -&gt; Boolean</programlisting></para>
        </example></para>

      <para>During import such module symbols can be renamed via symbol
      renaming. The specification <link
      linkend="CODE_renaming-pairs">below</link> shows an example of a rather
      complicated import of the module <literal>Pair</literal> using
      renamings. Renaming <literal>X</literal> to <literal>Boolean</literal>
      is, for instance, written as <literal>X =&gt; Boolean.</literal></para>

      <para><example xml:id="CODE_renaming-pairs">
          <title>Use of generic pair module</title>

          <para><programlisting>module TestPair

imports basic/Booleans 
imports basic/Integers 
imports Pair[X =&gt; Boolean Y =&gt; Boolean]
imports Pair[X =&gt; Integer  Y =&gt; Integer]
imports Pair[X =&gt; Pair[[Boolean,Boolean]] Y =&gt; Pair[[Integer,Integer]]]</programlisting></para>
        </example></para>
    </section>
  </section>

  <section xml:id="SdfComment">
    <title>SDF comment convention</title>

    <para><remark>This has a too prominent place; move it.</remark></para>

    <!--\index{Sdf comment@\sdf\ comment}-->

    <para>The comment convention within an SDF specification is that
    characters between <literal>%%</literal> and the end of line is comment as
    well as every character between two <literal>%</literal> characters
    including the newline character. An example of the use of comments is
    given <link linkend="CODE_sdfcomment">below</link>. This definition also
    defines the comment convention in SDF itself. More details on defining
    layout can be found in the section <link
    linkend="Restrictions">Restrictions</link>.</para>

    <example xml:id="CODE_sdfcomments">
      <title>SDF comments</title>

      <para><programlisting xml:id="CODE_sdfcomment">module basic/Comments

imports basic/Whitespace

%% In this module we define the 
%% comment convention for SDF.

exports
  lexical syntax
    "%%" ~[\n]* "\n" -&gt; LAYOUT
    "%" ~[\%]+ "%" -&gt; LAYOUT

  context-free restrictions
    LAYOUT? -/- [\%]</programlisting></para>
    </example>
  </section>

  <section xml:id="Variables">
    <title>Variables</title>

    <!--\index{variables@variables}-->

    <para>Variables are declared in the <literal>variables</literal> section
    of a module. Like all other entities in a module, except equations,
    variables may be exported (see section <link
    linkend="Modules">Modules</link>). A variables section consists of a list
    of variable names followed by a symbol. In fact, a variable declaration
    can define an infinite collection of variables by using a <emphasis>naming
    scheme</emphasis> instead of a simple variable name. A naming scheme is a
    regular expression like the ones allowed in the <link
    linkend="LexicalSyntax">lexical syntax</link> except that sorts are not
    allowed. A variable may represent any symbol. In the specification <link
    linkend="CODE_variables">below</link>, <literal>Id</literal>,
    <literal>Type3</literal>, and<literal> Id-list</literal> are examples of
    variables declared by the naming schemes in the
    <literal>variables</literal> section. Strings that occur in the left-hand
    side of variable declarations should <emphasis>always</emphasis> be
    quoted.</para>

    <example xml:id="CODE_variables">
      <title>Variable declarations using naming schemes</title>

      <para><programlisting>module VarDecls

imports basic/Whitespace

exports
  context-free start-symbols Decl
  sorts Id Decl Type 

  lexical syntax
    [a-z]+ -&gt; Id
 
  context-free syntax
    "decl" {Id ","}+ ":" Type -&gt; Decl 
    "integer"                 -&gt; Type 
    "real"                    -&gt; Type 

hiddens
  variables
    "Id"           -&gt; Id 
    "Type"[0-9]*   -&gt; Type 
    "Id-list"[\']* -&gt; {Id ","}* 
    "Id-ne-list"   -&gt; {Id ","}+</programlisting></para>
    </example>

    <para>Declared variables can only be used when defining equations. It is
    not allowed to use them in terms. Ambiguities due to variables are
    resolved by the <emphasis>Prefer Variables</emphasis> strategy that was
    discussed in <link linkend="lex-ambiguity">Lexical
    Ambiguities</link>.</para>
  </section>

  <section xml:id="WellformednessSDF">
    <title>Well-formedness of SDF</title>

    <para>In order to improve the quality of the written specifications, a
    number of checks are performed before an SDF specification is transformed
    into a parse table. The checks are performed on two levels: the first
    level are SDF specific checks, the second level are ASF+SDF specific
    checks. There are various categories of messages in The
    Meta-Environment</para>

    <itemizedlist>
      <listitem>
        <para>Parse errors.</para>
      </listitem>

      <listitem>
        <para>SDF type check warnings.</para>
      </listitem>

      <listitem>
        <para>SDF type check errors.</para>
      </listitem>
    </itemizedlist>

    <para>We will briefly discuss each of the error messages and indicate what
    is exactly wrong in the specification. Furthermore we will hint at how the
    error can be fixed.</para>

    <section>
      <title>Parse Errors</title>

      <para>There are three different types of parse errors:</para>

      <itemizedlist>
        <listitem>
          <para>A <emphasis>syntax error</emphasis>, which is reported by
          pinpointing the exact location in the file and a message like</para>

          <programlisting><literal>Parse error near cursor</literal></programlisting>

          <para>or</para>

          <programlisting>Parse error: character '<replaceable>c</replaceable>' unexpected</programlisting>

          <para>or</para>

          <programlisting>Parse error: eof unexpected</programlisting>

          <para>This means that the parser detected a syntax error in the text
          to be parsed and cannot proceed its parsing process. Clicking on the
          error in the <literal>Errors</literal> pane moves the cursor to the
          exact error location and launches if needed the editor.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>cycle</emphasis> is reported whenever the parser
          detects a non-terminating chain of reductions; the message is
          <programlisting><literal>Cycle: &lt;list_of_production_rules&gt;</literal></programlisting></para>
        </listitem>

        <listitem>
          <para>An <emphasis>ambiguity</emphasis> is reported whenever the
          parser was able to recognize a (part of) the input sentence in
          different ways and gives the message:</para>

          <programlisting><literal>Ambiguity: &lt;list_of_production_rules&gt;</literal></programlisting>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="PlainSDFwarnings">
      <title>Type check warnings for SDF</title>

      <warning>
        <para>It would be nice to rewrite this and the next section in the
        style:</para>

        <itemizedlist>
          <listitem>
            <para>Error message</para>
          </listitem>

          <listitem>
            <para>Explanation</para>
          </listitem>

          <listitem>
            <para>Example of error.</para>
          </listitem>

          <listitem>
            <para>Example of correction.</para>
          </listitem>
        </itemizedlist>
      </warning>

      <para>Warnings do not break the specification, but it is advisable to
      fix them anyway. Often they point out some not well-formed part in the
      specification.</para>

      <itemizedlist>
        <listitem>
          <para><literal>undeclared sorts</literal>: This warning indicates
          that a sort is used which is not explicitly declared, or it is
          declared but in a hidden section.</para>
        </listitem>

        <listitem>
          <para><literal>double declared sort</literal>: This warning points
          out that the sort is already declared somewhere in this module, or
          in one of the imported modules.</para>
        </listitem>

        <listitem>
          <para><literal>double declared start-symbol</literal>: This warning
          indicates that the start-symbol is previously defined as
          start-symbol as well. This can be in the current module or in one of
          the imported modules.</para>
        </listitem>

        <listitem>
          <para><literal>illegal attribute: {bracket, left, right, assoc,
          non-assoc}</literal>: This warning is generated because the
          syntactic form of the production rule and the attribute do not
          match. Given this mismatch the intended behaviour will not be
          effective.</para>
        </listitem>

        <listitem>
          <para><literal>used in priorities but undefined</literal>: This
          warning is generated whenever a production rule is used in a
          priority section which is not defined in this module or in one of
          the imported modules. It is possible that this production rule will
          be defined in one of the modules which imports this module.
          Normally, this indicates a typo.</para>
        </listitem>

        <listitem>
          <para><literal>inconsistent rhs in priorities</literal>: This
          warning is caused by a production rule which has not the same
          right-hand side as the other production rules in the priority
          relation. Whenever this occurs the effect of the expressed priority
          relation will be ignored. This check is performed modulo
          injections.</para>
        </listitem>

        <listitem>
          <para><literal>unknown constructor used in priorities</literal>:
          This warning indicates the use of a constructor which is not used in
          the corresponding set of production rules with the same right-hand
          side. This is a very weak check on consistent use of constructor
          information.</para>
        </listitem>

        <listitem>
          <para><literal>sort CHAR used in production rule</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>deprecated tuple notation</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>deprecated unquoted symbol notation</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>deprecated non-plain sort
          definition</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>aliased symbol already declared</literal>:</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="PlainSDFerrors">
      <title>Type check errors for SDF</title>

      <itemizedlist>
        <listitem>
          <para><literal>module not available</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>start-symbols in &lt;ModuleName&gt; not defined in
          any right-hand</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>literal in right-hand-side not
          allowed</literal></para>
        </listitem>

        <listitem>
          <para><literal>only sort allowed in right-hand-side of
          lexical-function</literal></para>
        </listitem>

        <listitem>
          <para><literal>double used label</literal>:</para>
        </listitem>

        <listitem>
          <para><literal>constructor has already been used</literal>:&#160;The
          combination of right-hand symbol and the constructor information
          should be unique. This warning points this out. It is advisable not
          to ignore this warning. In fact, for the parser these double
          constructors are no problem, but there are tools based on SDF for
          which this is problematic.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="sdf_HistoricalNotes">
    <title>Historical Notes</title>

    <para>The main publications on SDF are (in historical order):</para>

    <itemizedlist>
      <listitem>
        <para>J. Heering, P. Klint, A Syntax Definition Formalism, ESPRIT''86:
        Results and Achievements, North-Holland, 619--630, 1986.
        <emphasis>Describes the initial motivation and design of
        SDF</emphasis>.</para>
      </listitem>

      <listitem>
        <para>J. Heering, P. Hendriks, P. Klint and J. Rekers, <link
        xlink:href="http://www.acm.org/pubs/citations/proceedings/pldi/73141/p179-heering/">The
        syntax definition formalism SDF - reference manual</link>, SIGPLAN
        Notices <emphasis role="bold">24</emphasis>(11): 43-75, 1989.
        <emphasis>The first reference manual for SDF</emphasis>.</para>
      </listitem>

      <listitem>
        <para>E. Visser, <link
        xlink:href="http://homepages.cwi.nl/~paulk/dissertations/Visser.ps.gz">Syntax
        Definition for Language Prototyping</link>, dissertation, University
        of Amsterdam, 1997. <emphasis>A redesign of SDF that adds
        modularization (modeled after the modularization constructs of ASF),
        unifies lexical and concrete syntax, and proposes a normalisation
        procedure.</emphasis></para>
      </listitem>
    </itemizedlist>

    <para>The main publications on implementation techniques related to SDF
    are:</para>

    <itemizedlist>
      <listitem>
        <para>J. Heering, P. Klint and J. Rekers,<link
        xlink:href="http://www.acm.org/pubs/citations/proceedings/pldi/73141/p179-heering/">
        Incremental Generation of Parsers</link>, IEEE Transactions on
        Software Engineering, <emphasis
        role="bold">16</emphasis>(12):1344--1350, 1990. <emphasis>This and the
        next publication describe our variant of Generalized LR parsing as
        well as the just-in-time generation of scanners and
        parsers.</emphasis></para>
      </listitem>

      <listitem>
        <para>J. Heering, P. Klint and J. Rekers,<link
        xlink:href="http://www.acm.org/pubs/citations/journals/toplas/1992-14-4/p490-heering/">
        Incremental generation of lexical scanners</link>, ACM Transactions on
        Programming Languages and Systems <emphasis
        role="bold">14</emphasis>(4):490--520, October 1992.</para>
      </listitem>

      <listitem>
        <para>J. Rekers, <link
        xlink:href="http://homepages.cwi.nl/~paulk/dissertations/Rekers.ps.gz">Parser
        Generation for Interactive Environments</link>, dissertation,
        University of Amsterdam, 1992. <emphasis>Detailed description of the
        GLR algorithm.</emphasis></para>
      </listitem>

      <listitem>
        <para>M.G. J. van den Brand, J. Scheerder, J. J. Vinju and E. Visser,
        <link
        xlink:href="http://www.springerlink.com/content/03359k0cerupftfh/">Disambiguation
        Filters for Scannerless Generalized LR Parsers</link>, Proceedings of
        the 11th International Conference on Compiler Construction (CC'02),
        143--158, 2002. <emphasis>Describes current disambiguation methods
        that are used in combination with scannerless
        parsing.</emphasis></para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="sdf_ToDo">
    <title>To Do</title>

    <para>Needed:</para>

    <itemizedlist>
      <listitem>
        <para>Improve Disambiguation section</para>
      </listitem>

      <listitem>
        <para>Add explanatory text to error messages.</para>
      </listitem>

      <listitem>
        <para>Refer to the visualization of module structure, parse trees and
        ambiguities (may be in a separate MetaEnv sidebar).</para>
      </listitem>

      <listitem>
        <para>Remove all <remark>remarks</remark> from the text.</para>
      </listitem>
    </itemizedlist>

    <para>Optional:</para>

    <itemizedlist>
      <listitem>
        <para>Restructure sections on errors and add xamples.</para>
      </listitem>
    </itemizedlist>
  </section>
</article>