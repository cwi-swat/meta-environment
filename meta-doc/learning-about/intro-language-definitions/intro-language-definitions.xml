<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
]>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns6="http://www.w3.org/1999/xhtml"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>An Introduction to Language Definitions written in ASF+SDF</title>

    <pubdate>$Rev$ by $Author$ at $Date: 2007-08-22 17:27:53
    +0200 (Wed, 22 Aug 2007) $</pubdate>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <warning>
    <para>This document is work in progress. See <link
    linkend="fm_ToDo">ToDo</link> section.</para>
  </warning>

  <section xml:id="fm_Introduction">
    <title>Introduction</title>

    <para>You are interested in using ASF+SDF to define various aspects of a
    programming language or domain-specific language but you do now want to
    wade through all the details in the manual (The Language Specification
    Formalism ASF+SDF)? In that case, this article may be for you. We take the
    toy language Pico as starting point and walk you through its syntax,
    typechecking, formatting, execution and more. We do this while assuming
    zero knowledge of ASF+SDF or The ASF+SDF Meta-Environment.</para>

    <section>
      <title>What is the Global Picture?</title>

      <para>ASF+SDF can be used to define various aspects of programming
      langauges and The ASF+SDF Meta-Environment can be used to edit and run
      these specifications.</para>
    </section>

    <section>
      <title>ASF+SDF</title>

      <para>The goal of ASF+SDF is to define the syntax (form) and semantics
      (meaning) of programming languages and domain-specific languages. The
      Syntax Definition Formalism (SDF) is used to define syntactic aspects
      including:</para>

      <itemizedlist>
        <listitem>
          <para>Lexical syntax (keywords, comments, string constants, whiete
          space, ...).</para>
        </listitem>

        <listitem>
          <para>Context-free syntax (declarations, statements, ...).</para>
        </listitem>
      </itemizedlist>

      <para>The Algebraic Specification Formalism (ASF) is used to define
      semantic aspects such as:</para>

      <itemizedlist>
        <listitem>
          <para>Type checking (are the variables that are used declared and
          are they used in a type-correct way?).</para>
        </listitem>

        <listitem>
          <para>Formatting (display the original program using user-defined
          rules for indentation and formatting).</para>
        </listitem>

        <listitem>
          <para>Fact extraction (extract all procedure calls or all
          declarations and uses of variables).</para>
        </listitem>

        <listitem>
          <para>Execution (run the program with given input values).</para>
        </listitem>
      </itemizedlist>

      <para>By convention, all these language aspects are located in dedicated
      subdirectories:</para>

      <itemizedlist>
        <listitem>
          <para><filename>syntax</filename> (definitions for the
          syntax).</para>
        </listitem>

        <listitem>
          <para><filename>check</filename> (definitions for type
          checking).</para>
        </listitem>

        <listitem>
          <para><filename>format</filename> (definitions for
          formatting).</para>
        </listitem>

        <listitem>
          <para><filename>extract</filename> (definitions for fact
          extraction).</para>
        </listitem>

        <listitem>
          <para><filename>run</filename> (definitions for running a
          program).</para>
        </listitem>

        <listitem>
          <para><filename>debug</filename> (definitions for debugging a
          program).</para>
        </listitem>
      </itemizedlist>

      <para>Apart from giving a standard structure to all language
      definitions, this organization also enables the seamless integration of
      these aspects in the user-interface of The Meta-Environment.</para>
    </section>

    <section>
      <title>The ASF+SDF Meta-Environment</title>

      <para>The goal of The ASF+SDF Meta-Environment (or The Meta-Environment
      for short) is to provide an Interactive Development Environment for
      ASF+SDF specifications. It supports interactive editing, checking and
      execution of ASF+SDF specifications. Behind the scenes, this implies the
      following tasks:</para>

      <itemizedlist>
        <listitem>
          <para>Providing a graphical user-interface with editors and various
          visualization tools.</para>
        </listitem>

        <listitem>
          <para>Tracking changes to specification modules.</para>
        </listitem>

        <listitem>
          <para>Parsing and checking specification modules.</para>
        </listitem>

        <listitem>
          <para>Generating parsers for the syntax modules that have been
          changed.</para>
        </listitem>

        <listitem>
          <para>Generating rewriter engines for the equations modules that
          have been changed.</para>
        </listitem>

        <listitem>
          <para>Applying the ASF+SDF specification to programs in the language
          that is being defined by that specification.</para>
        </listitem>
      </itemizedlist>

      <para>The intended user experience of The Meta-Environment is the
      seamless automation of all these tasks.</para>
    </section>

    <section>
      <title>Learning more</title>

      <para>In <link linkend="fm_HistoricalNotes">Historical Notes</link>, we
      give background and key references.</para>
    </section>
  </section>

  <section>
    <title>Preparations</title>

    <para>The anatomies of a complete ASF+SDF specification as well as that of
    a single module are needed to understand any language definition.</para>

    <section>
      <title>Anatomy of an ASF+SDF specification</title>

      <para>An ASF+SDF specification consists of a collection of modules as
      shown inthe following <link linkend="Fig_modules">figure</link>. A
      module can import other modules and this can be understood as the
      textual inclusion of the imported modules.</para>

      <figure xml:id="Fig_modules">
        <title>Module structure of an ASF+SDF specification</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="modules.png" scale="100"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Anatomy of a single module</title>

      <para>A single module has the following structure:</para>

      <programlisting>module <replaceable>ModuleName</replaceable>            <co
          xml:id="mod.1" />
  <replaceable>ImportSection</replaceable>*             <co xml:id="mod.2" />
  <replaceable>ExportOrHiddenSection</replaceable>*     <co xml:id="mod.3" />
equations
  <replaceable>ConditionalEquation</replaceable>*       <co xml:id="mod.4" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="mod.1">
          <para>The name of this module. It may be followed by
          parameters.</para>
        </callout>

        <callout arearefs="mod.2">
          <para>Names of modules imported by this module.</para>
        </callout>

        <callout arearefs="mod.3">
          <para>The grammar elements (such as <literal>imports</literal>,
          <literal>aliases</literal>, <literal>sorts</literal>,
          <literal>lexical syntax</literal>, <literal>context-free
          syntax</literal>, <literal>priorities</literal> or
          <literal>variables</literal>) that are visible from the outside
          (defined by <literal>exports</literal>) or only insoide the module
          (defined by <literal>hiddens</literal>).</para>
        </callout>

        <callout arearefs="mod.4">
          <para>The equations of the module that define the meaning of the
          grammar elements. Equations come in two flavours. Unconditional:
          <programlisting><emphasis role="bold">[</emphasis>&lt;TagId&gt;<emphasis
                role="bold">]</emphasis> &lt;Term&gt; <emphasis role="bold">=</emphasis> &lt;Term&gt;</programlisting></para>

          <para>and conditional:<programlisting><emphasis role="bold">[</emphasis>&lt;TagId&gt;<emphasis
                role="bold">]</emphasis>  &lt;Condition<subscript>1</subscript>&gt;<emphasis
                role="bold">,</emphasis> &lt;Condition<subscript>2</subscript>&gt;<emphasis
                role="bold">,</emphasis> ... 
           <emphasis role="bold">===============================</emphasis>
                 &lt;Term<subscript>1</subscript>&gt; <emphasis role="bold">=</emphasis> &lt;Term<subscript>2</subscript>&gt;</programlisting></para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>An example: Booleans</title>

      <para>The Meta-Environment comes with a considerable library of built-in
      languages and datatypes. We explore the datatype
      <literal>basic/Booleans</literal> in the ASF+SDF library.</para>

      <section>
        <title>Opening basic/Booleans in The Meta-Environment</title>

        <para></para>
      </section>

      <section>
        <title>Modular structure</title>

        <para>The module structure of <literal>basic/Booleans</literal> is
        shown <link linkend="Fig_booleans_modules">below</link>.</para>

        <figure xml:id="Fig_booleans_modules">
          <title>Modular structure of
          <literal>basic/Booleans</literal></title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="booleans-modules.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title><literal>basic/BoolCon</literal></title>

        <para>Let' start with the Boolean constants:</para>

        <programlisting>module basic/BoolCon

exports

sorts BoolCon                             <co xml:id="boolcon.1" />
context-free syntax

    "true"  -&gt; BoolCon {cons("true")}     <co xml:id="boolcon.2" />
    "false" -&gt; BoolCon {cons("false")}    

hiddens
context-free start-symbols
  BoolCon                                 <co xml:id="boolcon.3" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="boolcon.1">
            <para>The sort of Boolean constants is defined as
            <literal>BoolCon</literal>. Sort names should always start with a
            capital letter.</para>
          </callout>

          <callout arearefs="boolcon.2">
            <para>The constants <literal>true</literal> and
            <literal>false</literal>. Such literals should always be
            quoted.</para>
          </callout>

          <callout arearefs="boolcon.3">
            <para>We add a start symbol (i.e., the syntactic notion from with
            all strings in this language are derived) for
            <literal>BoolCon</literal>. The net effect is that we can indeed
            parse these constants. Note that we hide this start symbol so that
            it can not proliferate to other modules (and cause undesired
            ambiguities). The <literal>cons</literal> attribute plays a role
            when generating external APIs and gives a name to this particular
            construct.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title><literal>basic/Whitespace</literal></title>

        <para>The module Whitespace defines what the spaces and newline
        are:</para>

        <programlisting>module basic/Whitespace

exports
  lexical syntax
    [\ \t\n\r] -&gt; LAYOUT {cons("whitespace")} <co xml:id="whitespace.1" />

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]                    <co xml:id="whitespace.2" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="whitespace.1">
            <para>A regular expression that defines space (<literal>\
            </literal>), tabulation (<literal>\t)</literal>, newline (\n) and
            carriage return (<literal>\r)</literal> as
            <literal>LAYOUT</literal> characters. <literal>LAYOUT</literal> is
            a predefined name that defines the layout characters that may
            optinally appear between the symbols in the context-free grammar
            (e.g., between the keyword <literal>if</literal> and the test in
            an if-statement).</para>
          </callout>

          <callout arearefs="whitespace.2">
            <para>Lexical syntax tends to become highly ambiguous.e.g., are
            two spaces one layout symbol or two consecutive ones? Context-free
            restrictions impose restrictions that resolve this. Here, optional
            layout (<literal>LAYOUT?</literal>) may not be followed by a
            layout character. In other words, the longest possible sequence of
            layout characters should be consider as one
            <literal>LAYOUT</literal> symbol.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title><literal>basic/Comments</literal></title>

        <para>The comment conventions is defines as follows:</para>

        <programlisting>module basic/Comments

imports
  basic/Whitespace

exports
  lexical syntax
    "%%" line:~[\n]* "\n"	-&gt; LAYOUT {cons("line"),category("Comment")}       <co
            xml:id="comments.1" />
    "%" content:~[\%\n]+ "%"	-&gt; LAYOUT {cons("nested"),category("Comment")}  <co
            xml:id="comments.2" />
  context-free restrictions
    LAYOUT? -/- [\%]                                                         <co
            xml:id="comments.3" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="comments.1">
            <para>Defines an line-based comment that starts with
            <literal>%%</literal> and ends at the end of the line. The
            <literal>category</literal> attribute defines the highlighting
            category to be used while editing texts that contain this
            comment.</para>
          </callout>

          <callout arearefs="comments.2">
            <para>Defines a comment that is contained within a single line
            between <literal>%</literal> and <literal>%</literal>.</para>
          </callout>

          <callout arearefs="comments.3">
            <para>Again a follow restriction that forces layout followed by a
            comment to be included in that comment.</para>
          </callout>
        </calloutlist>
      </section>

      <section xml:id="Sec_basic_Booleans">
        <title><literal>basic/Booleans</literal></title>

        <para>After these preparations, we can now should the syntax part of
        basic/Booleans:</para>

        <programlisting>module basic/Booleans

imports basic/BoolCon&#160;                                                      <co
            xml:id="booleans.1" />

exports
sorts Boolean                                                               <co
            xml:id="booleans.2" />

context-free syntax
  BoolCon                     -&gt; Boolean {cons("constant")}                 <co
            xml:id="booleans.3" />       
  lhs:Boolean "|" rhs:Boolean -&gt; Boolean {left, cons("or")}                 <co
            xml:id="booleans.4" />       
  lhs:Boolean "&amp;" rhs:Boolean -&gt; Boolean {left, cons("and")}                      
  "not" "(" Boolean ")"       -&gt; Boolean {cons("not")}                      <co
            xml:id="booleans.5" />     
  "(" Boolean ")"             -&gt; Boolean {bracket, cons("bracket")}         <co
            xml:id="booleans.6" />

context-free priorities
  Boolean "&amp;" Boolean -&gt; Boolean &gt;                                          <co
            xml:id="booleans.7" />
  Boolean "|" Boolean -&gt; Boolean

hiddens
context-free start-symbols
  Boolean                                                                   <co
            xml:id="booleans.8" />

imports basic/Comments                                                      <co
            xml:id="booleans.9" />

variables
  "Bool" [0-9]* -&gt; Boolean                                                  <co
            xml:id="booleans.10" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="booleans.1">
            <para>Import the Boolean constants <literal>true</literal> and
            <literal>false</literal> defined earlier.</para>
          </callout>

          <callout arearefs="booleans.2">
            <para>The sort of Boolean expressions.</para>
          </callout>

          <callout arearefs="booleans.3">
            <para>Each Boolean constant is also a Boolean expression. This is
            called an <emphasis>injection rule</emphasis> or a <emphasis>chain
            rule</emphasis>.</para>
          </callout>

          <callout arearefs="booleans.4">
            <para>The infix operators for Boolean or (<literal>|</literal>)
            and Boolean and (&amp;). Both are left-associative and this is
            indicated by the attribute <literal>left</literal>. Also note that
            the arguments get explicit names (<literal>lhs</literal> and
            <literal>rhs</literal>) and that a constructor is defined
            (<literal>or</literal>, respectively, <literal>and</literal>).
            This information is only relevant for generated APIs that are
            accessed by external tools.</para>
          </callout>

          <callout arearefs="booleans.5">
            <para>The prefix operator not.</para>
          </callout>

          <callout arearefs="booleans.6">
            <para><literal>(</literal> and <literal>)</literal> may be used as
            brackets in Boolean expressions.</para>
          </callout>

          <callout arearefs="booleans.7">
            <para>&amp; has a higher priority than |. The expression
            <literal>Bool &amp; Bool | Bool</literal> will thus be interpreted
            as (Bool &amp; Bool) | Bool.</para>
          </callout>

          <callout arearefs="booleans.8">
            <para>Define a (hidden) start symbol for Boolean
            expressions.</para>
          </callout>

          <callout arearefs="booleans.9">
            <para>Import <literal>basic/Comments</literal> for the benefit of
            writing equations for Booleans (see below). Observe the subtlety
            that this a <emphasis>hidden</emphasis> import: comments are only
            available locally in this module and are not exported. By strictly
            adhering to this convention, low-level comment conventions cannot
            <emphasis>pollute</emphasis> higher level modules and interfere
            with comment conventions defined at that level.</para>
          </callout>

          <callout arearefs="booleans.10">
            <para>Declares Boolean variables like <literal>Bool</literal>,
            <literal>Bool1</literal>, <literal>Bool2</literal>,
            <literal>Bool123</literal>, <literal>Bool'</literal>,
            <literal>Bool''</literal>, <literal>Bool1'</literal>, and the
            like.</para>
          </callout>
        </calloutlist>

        <para>Having covered all syntactic aspects of the Booleans, we can now
        trun our attention to the equations:</para>

        <programlisting>equations

[B1]   true  | Bool  = true       <co xml:id="booleans-eq.1" />
[B2]   false | Bool  = Bool

[B3]   true  &amp; Bool  = Bool       <co xml:id="booleans-eq.2" />
[B4]   false &amp; Bool  = false

[B5]   not ( false ) = true       <co xml:id="booleans-eq.3" />
[B6]   not ( true )  = false</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="booleans-eq.1">
            <para>Meaning of the or operator, in other words: with these two
            rules the <literal>|</literal> operator can be eliminated from any
            Boolean expression.</para>
          </callout>

          <callout arearefs="booleans-eq.2">
            <para>Meaning of and operator.</para>
          </callout>

          <callout arearefs="booleans-eq.3">
            <para>Meaning of not operator.</para>
          </callout>
        </calloutlist>

        <para>The syntax of ASF+SDF equations is not fixed but depends on the
        syntax rules. This can be seen by making the fixed ASF+SDF syntax
        <emphasis role="bold">bold</emphasis> and the syntax specific for
        Booleans <emphasis>italic</emphasis>:</para>

        <para><programlisting><emphasis role="bold">equations</emphasis>

<emphasis role="bold">[B1]</emphasis>   <emphasis>true  | Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>true</emphasis>       
<emphasis role="bold">[B2]</emphasis>   <emphasis>false | Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>Bool</emphasis>

<emphasis role="bold">[B3]</emphasis>   <emphasis>true  &amp; Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>Bool</emphasis>       
<emphasis role="bold">[B4]</emphasis>   <emphasis>false &amp; Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>false</emphasis>

<emphasis role="bold">[B5]</emphasis>   <emphasis>not ( false )</emphasis> <emphasis>=</emphasis> <emphasis>true</emphasis>       
<emphasis role="bold">[B6]</emphasis>   not ( true )  <emphasis role="bold">=</emphasis> <emphasis>false</emphasis></programlisting></para>

        <para>This mixture of syntaxes will become even more apparent when we
        discuss the Pico definitions later.</para>
      </section>

      <section>
        <title>Reducing a Boolean expression</title>

        <para>The Boolean term <literal>not(true &amp; not(false |
        true))</literal> should reduce to <literal>true</literal> (check this
        for yourself before looking at the figure <link
        linkend="Fig_boolean_reduction">below</link>).</para>

        <figure xml:id="Fig_boolean_reduction">
          <title>Reducing a Boolean term.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="boolean-reduction.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Running the Boolean example in The Meta-Environment</title>

        <para>By far the best steps to get acquainted with the
        Meta-Environment are:</para>

        <itemizedlist>
          <listitem>
            <para>Have a look at the Flash movie: <emphasis>Guided Tour:
            Playing with Booleans</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Read the explanations and screenshots below.</para>
          </listitem>

          <listitem>
            <para>Get hands-on experience with The Meta-Environment
            itself.</para>
          </listitem>
        </itemizedlist>

        <para></para>
      </section>

      <section>
        <title>Take home points</title>

        <para>The example of the Booleans illustrates the following important
        points that are also valifd for more complex examples:</para>

        <itemizedlist>
          <listitem>
            <para>Each module <emphasis>defines a language</emphasis>: in this
            case the language of Booleans. In other contexts one can also
            speak about the datatype of the Booleans. We will use language and
            datatype as synonyms.</para>
          </listitem>

          <listitem>
            <para>We can use this language definition to;</para>

            <itemizedlist>
              <listitem>
                <para>Create a syntax-directed editor for Boolean language and
                create Boolean terms.</para>
              </listitem>

              <listitem>
                <para>Apply the equations to this term and reduce it to a
                normal form (= a term that is not further reducible).</para>
              </listitem>

              <listitem>
                <para>Import it in another module; this makes the Boolean
                language available for the importing module.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section>
    <title>The Toy Language Pico</title>

    <para>The toy language Pico has a single purpose in life: being so simple
    that specifications of every possible language aspect are so simple that
    they fit on a few pages. It can be summarized as follows:</para>

    <itemizedlist>
      <listitem>
        <para>There are two types: natural numbers and strings.</para>
      </listitem>

      <listitem>
        <para>Variables have to be declared.</para>
      </listitem>

      <listitem>
        <para>Statements are assignment, if-then-else and while-do.</para>
      </listitem>

      <listitem>
        <para>Expressions may contain naturals, strings, addition
        (<literal>+</literal>), substraction (<literal>-</literal>) and
        concatenation (<literal>||</literal>).</para>
      </listitem>

      <listitem>
        <para>The operators <literal>+</literal> and <literal>-</literal> have
        operands of type natural and their result is natural.</para>
      </listitem>

      <listitem>
        <para>The operator <literal>||</literal> has operands of type string
        and its results is also of type string.</para>
      </listitem>

      <listitem>
        <para>Tests in if-then-else statement and while-statement should be of
        type natural.</para>
      </listitem>
    </itemizedlist>

    <para>Let's look at a simple Pico program that computes the factorial
    function:</para>

    <programlisting>begin declare input : natural,            <co
        xml:id="fac.1" />
              output : natural,           
              repnr : natural,
              rep : natural;
      input := 14;
      output := 1;
      while input - 1 do                  <co xml:id="fac.2" />
          rep := output;
          repnr := input;
          while repnr - 1 do
             output := output + rep;
             repnr := repnr - 1
          od;
          input := input - 1
      od
end</programlisting>

    <para>Notes:</para>

    <calloutlist>
      <callout arearefs="fac.1">
        <para>Pico programs do not have input/output statements, so we use
        variables for that purpose.</para>
      </callout>

      <callout arearefs="fac.2">
        <para>Pico has no multiplication operator so we have have to simulate
        it with repeated addition (yes, simplicity comes at a price!).</para>
      </callout>
    </calloutlist>
  </section>

  <section>
    <title>Define the syntax for Pico</title>

    <para>The import structure of the syntax definition of Pico is shown <link
    linkend="Fig_imports_pico_syntax">below</link>. The modules
    <literal>basic/NatCon</literal>, <literal>basic/StrCon</literal> and
    <literal>basic/Whitespace</literal> are reused from the ASF+SDF library.
    The modules <literal>languages/pico/syntax/Identifiers</literal>,
    <literal>languages/pico/syntax/Types</literal> and
    <literal>languages/pico/syntax/Pico</literal> are specified for Pico and
    are now discussed in more detail.</para>

    <figure xml:id="Fig_imports_pico_syntax">
      <title>Import structure of Pico syntax</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pico-modules.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>languages/pico/syntax/Types</title>

      <para>Variables can be declared in Pico programs with one of two types:
      "natural number" or "string". This defined as follows:</para>

      <programlisting>module languages/pico/syntax/Types

exports
  sorts TYPE                 <co xml:id="types.1" />
  context-free syntax
    "natural"     -&gt; TYPE    <co xml:id="types.2" />
    "string"      -&gt; TYPE
    "nil-type"    -&gt; TYPE    <co xml:id="types.3" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="types.1">
          <para><literal>TYPE</literal> is the sort of possible types in Pico
          programs.</para>
        </callout>

        <callout arearefs="types.2">
          <para>The constants <literal>natural</literal> and
          <literal>string</literal> represent types as they can be declared in
          a Pico program.</para>
        </callout>

        <callout arearefs="types.3">
          <para>The constant <literal>nil-type</literal> is used for handling
          error cases.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>languages/pico/syntax/Identifiers</title>

      <para>Identifiers are used for the names of variables in Pico programs.
      The are defined as follows:</para>

      <programlisting>module languages/pico/syntax/Identifiers

imports basic/Whitespace

exports
  sorts PICO-ID                  <co xml:id="id.1" />
  lexical syntax
    [a-z] [a-z0-9]* -&gt; PICO-ID   <co xml:id="id.2" /></programlisting>

      <caution>
        <para>Why importing basic/Whitespace?</para>
      </caution>

      <caution>
        <para>Why are the lexical restrictions missing?</para>
      </caution>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="id.1">
          <para><literal>PICO-ID</literal> is the sort of identifiers in Pico
          programs.</para>
        </callout>

        <callout arearefs="id.2">
          <para>PICO-ID is defined using a regular expression that contains
          the following elements:</para>

          <itemizedlist>
            <listitem>
              <para><literal>[a-z]</literal>: a character class that ranges
              over all lower case letters.</para>
            </listitem>

            <listitem>
              <para><literal>[a-z0-9]</literal>: a character class that ranges
              over all lower case letters and over all digits.</para>
            </listitem>

            <listitem>
              <para><literal>[a-z0-9]*</literal>: <emphasis>zero</emphasis> or
              more repetitions of the character class
              <literal>[a-z0-9]</literal>. In other cases the postfix
              <literal>+</literal> operator can be used that defines
              <emphasis>one</emphasis> or more repetitions of the preceeding
              construct.</para>
            </listitem>
          </itemizedlist>

          <para>The overall effect of this definition is that Pico identifiers
          start with a lower case letter that can be followed by lower case
          letters or by digits.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>languages/pico/syntax/Pico</title>

      <para>After these preparations we can present the syntax for
      Pico:</para>

      <programlisting>module languages/pico/syntax/Pico

imports languages/pico/syntax/Identifiers 
imports languages/pico/syntax/Types
imports basic/NatCon 
imports basic/StrCon 

hiddens
  context-free start-symbols                                                   <co
          xml:id="pico-syntax.1" />
    PROGRAM

exports

  sorts PROGRAM DECLS ID-TYPE STATEMENT EXP                                    <co
          xml:id="pico-syntax.2" />

  context-free syntax                                                          <co
          xml:id="pico-syntax.3" />
    
    "begin" DECLS {STATEMENT";" }* "end"                          -&gt; PROGRAM   <co
          xml:id="pico-syntax.4" />
    "declare" {ID-TYPE "," }*";"                                  -&gt; DECLS 
    PICO-ID ":" TYPE                                              -&gt; ID-TYPE

  context-free syntax                                                          <co
          xml:id="pico-syntax.5" />

    PICO-ID ":=" EXP                                              -&gt; STATEMENT
    "if" EXP "then" {STATEMENT";" }* "else" {STATEMENT";" }* "fi" -&gt; STATEMENT
    "while" EXP "do" {STATEMENT ";" }* "od"                       -&gt; STATEMENT
 
  context-free syntax                                                          <co
          xml:id="pico-syntax.6" />

    PICO-ID       -&gt; EXP                                                       <co
          xml:id="pico-syntax.7" />                                                
    NatCon        -&gt; EXP                                                       
    StrCon        -&gt; EXP                                                       
    EXP "+" EXP   -&gt; EXP {left}                                                <co
          xml:id="pico-syntax.8" />
    EXP "-" EXP   -&gt; EXP {left}
    EXP "||" EXP  -&gt; EXP {left}
    "(" EXP ")"   -&gt; EXP {bracket}                                             <co
          xml:id="pico-syntax.9" />

  context-free priorities                                                      <co
          xml:id="pico-syntax.10" />
    EXP "||" EXP -&gt; EXP &gt;
    EXP "-" EXP -&gt; EXP &gt;
    EXP "+" EXP -&gt; EXP</programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="pico-syntax.1">
          <para><literal>PROGRAM</literal> is the start symbol for this
          grammar, i.e., each Pico program is derived from it.</para>
        </callout>

        <callout arearefs="pico-syntax.2">
          <para>The sorts <literal>PROGRAM</literal>,
          <literal>DECLS</literal>, <literal>ID-TYPE</literal>,
          <literal>STATEMENT</literal> and <literal>EXP</literal> are declared
          here and are used (in addition to the sorts declared in the imported
          modules) to define the Pico grammar.</para>
        </callout>

        <callout arearefs="pico-syntax.3">
          <para>This first context-free syntax section declares the toplevel
          structure of a Pico program.</para>
        </callout>

        <callout arearefs="pico-syntax.4">
          <para>The rule for PROGRAM contains the list construct<literal>
          {STATEMENT ";"}*</literal>. It describes zero or more statements
          separated by a semicolon (<literal>;</literal>).</para>
        </callout>

        <callout arearefs="pico-syntax.5">
          <para>This section declares the syntax for statements.</para>
        </callout>

        <callout arearefs="pico-syntax.6">
          <para>This final context-free syntax section declares expression
          syntax.</para>
        </callout>

        <callout arearefs="pico-syntax.7">
          <para>These three rules define that natural Pico identifiers,
          natural constants and string constants may occur as
          expressions.</para>
        </callout>

        <callout arearefs="pico-syntax.8">
          <para>The syntax of the operators <literal>+</literal>,
          <literal>-</literal> and <literal>||</literal> is defined. Observe
          that all three are left-associative. This implies that an expression
          like <literal>1+2+3</literal> is considered to be of the form
          <literal>(1+2)+3</literal> and that the other interpretation
          <literal>1+(2+3)</literal> is rejected.</para>
        </callout>

        <callout arearefs="pico-syntax.9">
          <para><literal>(</literal> and <literal>)</literal> can be used as
          brackets in expressions.</para>
        </callout>

        <callout arearefs="pico-syntax.10">
          <para>Priorities define the relative ordering of operators and are
          used to disambiguate text when more interpretations are possible.
          The higher the priority, the stronger the binding. The expression
          <literal>1-2+3</literal> will thus be interpreted as
          <literal>(1-2)+3</literal>.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>Using the Pico syntax in the Meta-Environment</title>

      <para></para>
    </section>

    <section>
      <title>Take home points</title>

      <para>The syntax of Pico illustrates the following important
      points:</para>

      <itemizedlist>
        <listitem>
          <para>All modules for a syntax definition reside in a subdirectory
          named <literal>syntax</literal>.</para>
        </listitem>

        <listitem>
          <para>The main module of the syntax definition has the same name as
          the language (with an uppercase, since all module names start with
          an uppercase letter).</para>
        </listitem>

        <listitem>
          <para>The modules languages/pico/syntax/Identifiers,
          languages/pico/syntax/Types and languages/pico/syntax/Pico define
          (together with the modules they import) the syntax of the Pico
          language.</para>
        </listitem>

        <listitem>
          <para>This syntax can be used to:</para>

          <itemizedlist>
            <listitem>
              <para>Generate a parser that can parse Pico programs.</para>
            </listitem>

            <listitem>
              <para>Generate a syntax-directed editor for Pico
              programs.</para>
            </listitem>

            <listitem>
              <para>Generate a parser that can parse equations containing
              fragments of Pico programs. This is similar to the use of
              different syntaxes in the definition of the <link
              linkend="Sec_basic_Booleans">Booleans</link> and is used for
              program analysis and transformation.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Define a typechecker for Pico</title>

    <para>The typechecking rules for the Pico language are very simple:</para>

    <itemizedlist>
      <listitem>
        <para>The only types are <literal>natural</literal> and
        <literal>string</literal>.</para>
      </listitem>

      <listitem>
        <para>All variables should be declared before use.</para>
      </listitem>

      <listitem>
        <para>Left-hand side and Right-hand side of an assignment statement
        should have equal type.</para>
      </listitem>

      <listitem>
        <para>The test in while statement and if-statement should be
        <literal>natural</literal>.</para>
      </listitem>

      <listitem>
        <para>Operands of <literal>+</literal> and <literal>-</literal> should
        be <literal>natural</literal>; their result is also
        <literal>natural</literal>.</para>
      </listitem>

      <listitem>
        <para>Operands of <literal>||</literal> should be
        <literal>string</literal>; the result is also
        <literal>string</literal>.</para>
      </listitem>
    </itemizedlist>

    <para>The task of a typechecker for Pico is to assert that a given Pico
    program complies with the above rules.</para>

    <section>
      <title>languages/pico/check/Type-environments</title>

      <para></para>

      <programlisting>module languages/pico/check/Type-environments

imports languages/pico/syntax/Identifiers 
imports containers/Table[PICO-ID TYPE]

exports 
  sorts TENV TYPE 

  aliases
    Table[[PICO-ID,TYPE]] -&gt; TENV
</programlisting>
    </section>

    <section>
      <title>languages/pico/check/Pico</title>

      <para>First consider the syntax part of the Pico typechecker:</para>

      <programlisting>module languages/pico/check/Pico

imports basic/Booleans
imports basic/Errors
imports languages/pico/syntax/Pico
imports languages/pico/check/Type-environments
imports utilities/PosInfo[EXP]
imports utilities/PosInfo[PICO-ID]
imports utilities/PosInfo[PROGRAM]

exports
context-free syntax
  "tcp"(PROGRAM) -&gt; {Error ","}*  

hiddens
context-free syntax
  "tcd"(DECLS)                  -&gt; TENV          
  "tcits"({ID-TYPE ","}*, TENV) -&gt; TENV          
  "tcit"(ID-TYPE, TENV)         -&gt; TENV          
  "tcs"({STATEMENT ";"}*, TENV) -&gt; {Error ","}*  
  "tcst"(STATEMENT, TENV)       -&gt; {Error ","}*  
  "tce"(EXP, TYPE, TENV)        -&gt; {Error ","}*  

context-free start-symbols
  Summary PROGRAM {Error ","}*

variables
  "Message"          -&gt; StrCon            
  "Error*" [0-9\']*  -&gt; {Error ","}*      
  "Decls" [0-9\']*   -&gt; DECLS             
  "Exp" [0-9\']*     -&gt; EXP               
  "Id" [0-9\']*      -&gt; PICO-ID           
  "Id-type*" [0-9]*  -&gt; {ID-TYPE ","}*    
  "Nat-con" [0-9\']* -&gt; NatCon            
  "Series" [0-9\']*  -&gt; {STATEMENT ";"}+  
  "Stat" [0-9\']*    -&gt; STATEMENT         
  "Stat*" [0-9\']*   -&gt; {STATEMENT ";"}*  
  "Str-con" [0-9\']* -&gt; StrCon            
  "Tenv" [0-9\']*    -&gt; TENV              
  "Type" [0-9\']*    -&gt; TYPE              
  "Program" [0-9\']* -&gt; PROGRAM         </programlisting>

      <para>Now let's turn our attention to the equations part of the Pico
      typechecker:</para>

      <programlisting>equations

[Main] start(PROGRAM, Program) = start(Summary, summary("pico-check",get-filename(get-location(Program)), [tcp(Program)]))

equations

[Tc1]  tcp(begin Decls Series end) = tcs(Series, tcd(Decls))

equations

[Tc2]  tcd(declare Id-type*;) = tcits(Id-type*, new-table)

equations

[Tc3a] tcits(Id:Type, Id-type*, Tenv) = tcits(Id-type*, tcit(Id:Type, Tenv))

[Tc3b] tcits(,Tenv) = Tenv

equations

[Tc4a] lookup(Tenv, Id) == not-in-table
       ===========================================
       tcit(Id:Type, Tenv) = store(Tenv, Id, Type)

[default] tcit(Id:Type, Tenv) = Tenv

equations

[Tc5a] tcs(Stat ; Stat*, Tenv) =
       tcst(Stat,Tenv), tcs(Stat*,Tenv)

[Tc5b] tcs(,Tenv) = 

equations

[Tc6a]
    not-in-table == lookup(Tenv, Id)
    ==========================================================================================
    tcst(Id := Exp, Tenv) = error("Variable not declared", [localized("Id", get-location(Id))])

[default] tcst(Id := Exp, Tenv) = tce(Exp, lookup(Tenv, Id), Tenv) 

[Tc6b]  tcst(if Exp then Series1 else Series2 fi, Tenv) =
        tce(Exp, natural, Tenv), tcs(Series1, Tenv), tcs(Series2, Tenv)

[Tc6c]  tcst(while Exp do Series od, Tenv) = 
        tce(Exp, natural, Tenv), tcs(Series, Tenv)

equations

[default] tce(Exp, natural, Tenv) = error("Expression should be of type natural", [localized("Expression", get-location(Exp))])
[default] tce(Exp, string, Tenv) = error("Expression should be of type string", [localized("Expression", get-location(Exp))])

[Tc7a]  tce(Id, Type, Tenv) = when Type == lookup(Tenv, Id)
[Tc7b]  tce(Nat-con, natural, Tenv) = 
[Tc7c]  tce(Str-con, string, Tenv) = 
[Tc7d]  tce(Exp1 || Exp2, string, Tenv) = tce(Exp1, string, Tenv), tce(Exp2, string, Tenv)
[Tc7d]  tce(Exp1 + Exp2, natural, Tenv) = tce(Exp1, natural, Tenv), tce(Exp2, natural, Tenv)
[Tc7d]  tce(Exp1 - Exp2, natural, Tenv) = tce(Exp1, natural, Tenv), tce(Exp2, natural, Tenv)</programlisting>
    </section>

    <section>
      <title>Using the Pico typecheker in The Meta-Environment</title>

      <para></para>
    </section>

    <section>
      <title>Take home points</title>

      <para></para>
    </section>
  </section>

  <section xml:id="fm_HistoricalNotes">
    <title>Historical Notes</title>

    <para></para>
  </section>

  <section>
    <title></title>

    <para></para>
  </section>

  <section>
    <title></title>

    <para></para>
  </section>

  <section>
    <title></title>

    <para></para>
  </section>

  <section xml:id="fm_ToDo">
    <title>To Do</title>

    <itemizedlist>
      <listitem>
        <para>Examples section</para>
      </listitem>

      <listitem>
        <para>Add links to Historical notes section</para>
      </listitem>
    </itemizedlist>
  </section>
</article>