<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
]>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns6="http://www.w3.org/1999/xhtml"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>An Introduction to Language Definitions written in ASF+SDF</title>

    <pubdate>$Rev$ by $Author$ at $Date: 2007-08-22 17:27:53
    +0200 (Wed, 22 Aug 2007) $</pubdate>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <warning>
    <para>This document is work in progress. See <link
    linkend="fm_ToDo">ToDo</link> section.</para>
  </warning>

  <section xml:id="fm_Introduction">
    <title>Introduction</title>

    <para>You are interested in using ASF+SDF to define various aspects of a
    programming language or domain-specific language but you do now want to
    wade through all the details in the manual (The Language Specification
    Formalism ASF+SDF)? In that case, this article may be for you. We take the
    toy language Pico as starting point and walk you through its syntax,
    typechecking, formatting, execution and more. We do this while assuming
    zero knowledge of ASF+SDF or The ASF+SDF Meta-Environment.</para>

    <section>
      <title>What is the Global Picture?</title>

      <para>ASF+SDF can be used to define various aspects of programming
      langauges and The ASF+SDF Meta-Environment can be used to edit and run
      these specifications.</para>
    </section>

    <section>
      <title>ASF+SDF</title>

      <para>The goal of ASF+SDF is to define the syntax (form) and semantics
      (meaning) of programming languages and domain-specific languages. The
      Syntax Definition Formalism (SDF) is used to define syntactic aspects
      including:</para>

      <itemizedlist>
        <listitem>
          <para>Lexical syntax (keywords, comments, string constants, whiete
          space, ...).</para>
        </listitem>

        <listitem>
          <para>Context-free syntax (declarations, statements, ...).</para>
        </listitem>
      </itemizedlist>

      <para>The Algebraic Specification Formalism (ASF) is used to define
      semantic aspects such as:</para>

      <itemizedlist>
        <listitem>
          <para>Type checking (are the variables that are used declared and
          are they used in a type-correct way?).</para>
        </listitem>

        <listitem>
          <para>Formatting (display the original program using user-defined
          rules for indentation and formatting).</para>
        </listitem>

        <listitem>
          <para>Fact extraction (extract all procedure calls or all
          declarations and uses of variables).</para>
        </listitem>

        <listitem>
          <para>Execution (run the program with given input values).</para>
        </listitem>
      </itemizedlist>

      <para>By convention, all these language aspects are located in dedicated
      subdirectories:</para>

      <itemizedlist>
        <listitem>
          <para><filename>syntax</filename> (definitions for the
          syntax).</para>
        </listitem>

        <listitem>
          <para><filename>check</filename> (definitions for type
          checking).</para>
        </listitem>

        <listitem>
          <para><filename>format</filename> (definitions for
          formatting).</para>
        </listitem>

        <listitem>
          <para><filename>extract</filename> (definitions for fact
          extraction).</para>
        </listitem>

        <listitem>
          <para><filename>run</filename> (definitions for running a
          program).</para>
        </listitem>

        <listitem>
          <para><filename>debug</filename> (definitions for debugging a
          program).</para>
        </listitem>
      </itemizedlist>

      <para>Apart from giving a standard structure to all language
      definitions, this organization also enables the seamless integration of
      these aspects in the user-interface of The Meta-Environment.</para>
    </section>

    <section>
      <title>The ASF+SDF Meta-Environment</title>

      <para>The goal of The ASF+SDF Meta-Environment (or The Meta-Environment
      for short) is to provide an Interactive Development Environment for
      ASF+SDF specifications. It supports interactive editing, checking and
      execution of ASF+SDF specifications. Behind the scenes, this implies the
      following tasks:</para>

      <itemizedlist>
        <listitem>
          <para>Providing a graphical user-interface with editors and various
          visualization tools.</para>
        </listitem>

        <listitem>
          <para>Tracking changes to specification modules.</para>
        </listitem>

        <listitem>
          <para>Parsing and checking specification modules.</para>
        </listitem>

        <listitem>
          <para>Generating parsers for the syntax modules that have been
          changed.</para>
        </listitem>

        <listitem>
          <para>Generating rewriter engines for the equations modules that
          have been changed.</para>
        </listitem>

        <listitem>
          <para>Applying the ASF+SDF specification to programs in the language
          that is being defined by that specification.</para>
        </listitem>
      </itemizedlist>

      <para>The intended user experience of The Meta-Environment is the
      seamless automation of all these tasks.</para>
    </section>

    <section>
      <title>Learning more</title>

      <para>In <link linkend="fm_HistoricalNotes">Historical Notes</link>, we
      give background and key references.</para>
    </section>
  </section>

  <section>
    <title>Preparations</title>

    <para>The anatomies of a complete ASF+SDF specification as well as that of
    a single module are needed to understand any language definition.</para>

    <section>
      <title>Anatomy of an ASF+SDF specification</title>

      <para>An ASF+SDF specification consists of a collection of modules as
      shown inthe following <link linkend="Fig_modules">figure</link>. A
      module can import other modules and this can be understood as the
      textual inclusion of the imported modules.</para>

      <figure xml:id="Fig_modules">
        <title>Module structure of an ASF+SDF specification</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="modules.png" scale="100"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Anatomy of a single module</title>

      <para>A single module has the following structure:</para>

      <programlisting>module <replaceable>ModuleName</replaceable>            <co
          xml:id="mod.1" />
  <replaceable>ImportSection</replaceable>*             <co xml:id="mod.2" />
  <replaceable>ExportOrHiddenSection</replaceable>*     <co xml:id="mod.3" />
equations
  <replaceable>ConditionalEquation</replaceable>*       <co xml:id="mod.4" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="mod.1">
          <para>The name of this module. It may be followed by
          parameters.</para>
        </callout>

        <callout arearefs="mod.2">
          <para>Names of modules imported by this module.</para>
        </callout>

        <callout arearefs="mod.3">
          <para>The grammar elements (such as <literal>imports</literal>,
          <literal>aliases</literal>, <literal>sorts</literal>,
          <literal>lexical syntax</literal>, <literal>context-free
          syntax</literal>, <literal>priorities</literal> or
          <literal>variables</literal>) that are visible from the outside
          (defined by <literal>exports</literal>) or only insoide the module
          (defined by <literal>hiddens</literal>).</para>
        </callout>

        <callout arearefs="mod.4">
          <para>The equations of the module that define the meaning of the
          grammar elements. Equations come in two flavours. Unconditional:
          <programlisting><emphasis role="bold">[</emphasis>&lt;TagId&gt;<emphasis
                role="bold">]</emphasis> &lt;Term&gt; <emphasis role="bold">=</emphasis> &lt;Term&gt;</programlisting></para>

          <para>and conditional:<programlisting><emphasis role="bold">[</emphasis>&lt;TagId&gt;<emphasis
                role="bold">]</emphasis>  &lt;Condition<subscript>1</subscript>&gt;<emphasis
                role="bold">,</emphasis> &lt;Condition<subscript>2</subscript>&gt;<emphasis
                role="bold">,</emphasis> ... 
           <emphasis role="bold">===============================</emphasis>
                 &lt;Term<subscript>1</subscript>&gt; <emphasis role="bold">=</emphasis> &lt;Term<subscript>2</subscript>&gt;</programlisting></para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>An example: Booleans</title>

      <para>The Meta-Environment comes with a considerable library of built-in
      languages and datatypes. We explore the datatype
      <literal>basic/Booleans</literal> in the ASF+SDF library.</para>

      <section>
        <title>Opening basic/Booleans in The Meta-Environment</title>

        <para></para>
      </section>

      <section>
        <title>Modular structure</title>

        <para>The module structure of <literal>basic/Booleans</literal> is
        shown <link linkend="Fig_booleans_modules">below</link>.</para>

        <figure xml:id="Fig_booleans_modules">
          <title>Modular structure of
          <literal>basic/Booleans</literal></title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="booleans-modules.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title><literal>basic/BoolCon</literal></title>

        <para>Let' start with the Boolean constants:</para>

        <programlisting>module basic/BoolCon

exports

sorts BoolCon                             <co xml:id="boolcon.1" />
context-free syntax

    "true"  -&gt; BoolCon {cons("true")}     <co xml:id="boolcon.2" />
    "false" -&gt; BoolCon {cons("false")}    

hiddens
context-free start-symbols
  BoolCon                                 <co xml:id="boolcon.3" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="boolcon.1">
            <para>The sort of Boolean constants is defined as
            <literal>BoolCon</literal>. Sort names should always start with a
            capital letter.</para>
          </callout>

          <callout arearefs="boolcon.2">
            <para>The constants <literal>true</literal> and
            <literal>false</literal>. Such literals should always be
            quoted.</para>
          </callout>

          <callout arearefs="boolcon.3">
            <para>We add a start symbol (i.e., the syntactic notion from with
            all strings in this language are derived) for
            <literal>BoolCon</literal>. The net effect is that we can indeed
            parse these constants. Note that we hide this start symbol so that
            it can not proliferate to other modules (and cause undesired
            ambiguities). The <literal>cons</literal> attribute plays a role
            when generating external APIs and gives a name to this particular
            construct.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title><literal>basic/Whitespace</literal></title>

        <para>The module Whitespace defines what the spaces and newline
        are:</para>

        <programlisting>module basic/Whitespace

exports
  lexical syntax
    [\ \t\n\r] -&gt; LAYOUT {cons("whitespace")} <co xml:id="whitespace.1" />

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]                    <co xml:id="whitespace.2" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="whitespace.1">
            <para>A regular expression that defines space (<literal>\
            </literal>), tabulation (<literal>\t)</literal>, newline (\n) and
            carriage return (<literal>\r)</literal> as
            <literal>LAYOUT</literal> characters. <literal>LAYOUT</literal> is
            a predefined name that defines the layout characters that may
            optinally appear between the symbols in the context-free grammar
            (e.g., between the keyword <literal>if</literal> and the test in
            an if-statement).</para>
          </callout>

          <callout arearefs="whitespace.2">
            <para>Lexical syntax tends to become highly ambiguous.e.g., are
            two spaces one layout symbol or two consecutive ones? Context-free
            restrictions impose restrictions that resolve this. Here, optional
            layout (<literal>LAYOUT?</literal>) may not be followed by a
            layout character. In other words, the longest possible sequence of
            layout characters should be consider as one
            <literal>LAYOUT</literal> symbol.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title><literal>basic/Comments</literal></title>

        <para>The comment conventions is defines as follows:</para>

        <programlisting>module basic/Comments

imports
  basic/Whitespace

exports
  lexical syntax
    "%%" line:~[\n]* "\n"	-&gt; LAYOUT {cons("line"),category("Comment")}       <co
            xml:id="comments.1" />
    "%" content:~[\%\n]+ "%"	-&gt; LAYOUT {cons("nested"),category("Comment")}  <co
            xml:id="comments.2" />
  context-free restrictions
    LAYOUT? -/- [\%]                                                         <co
            xml:id="comments.3" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="comments.1">
            <para>Defines an line-based comment that starts with
            <literal>%%</literal> and ends at the end of the line. The
            <literal>category</literal> attribute defines the highlighting
            category to be used while editing texts that contain this
            comment.</para>
          </callout>

          <callout arearefs="comments.2">
            <para>Defines a comment that is contained within a single line
            between <literal>%</literal> and <literal>%</literal>.</para>
          </callout>

          <callout arearefs="comments.3">
            <para>Again a follow restriction that forces layout followed by a
            comment to be included in that comment.</para>
          </callout>
        </calloutlist>
      </section>

      <section xml:id="Sec_basic_Booleans">
        <title><literal>basic/Booleans</literal></title>

        <para>After these preparations, we can now should the syntax part of
        basic/Booleans:</para>

        <programlisting>module basic/Booleans

imports basic/BoolCon&#160;                                                      <co
            xml:id="booleans.1" />

exports
sorts Boolean                                                               <co
            xml:id="booleans.2" />

context-free syntax
  BoolCon                     -&gt; Boolean {cons("constant")}                 <co
            xml:id="booleans.3" />       
  lhs:Boolean "|" rhs:Boolean -&gt; Boolean {left, cons("or")}                 <co
            xml:id="booleans.4" />       
  lhs:Boolean "&amp;" rhs:Boolean -&gt; Boolean {left, cons("and")}                      
  "not" "(" Boolean ")"       -&gt; Boolean {cons("not")}                      <co
            xml:id="booleans.5" />     
  "(" Boolean ")"             -&gt; Boolean {bracket, cons("bracket")}         <co
            xml:id="booleans.6" />

context-free priorities
  Boolean "&amp;" Boolean -&gt; Boolean &gt;                                          <co
            xml:id="booleans.7" />
  Boolean "|" Boolean -&gt; Boolean

hiddens
context-free start-symbols
  Boolean                                                                   <co
            xml:id="booleans.8" />

imports basic/Comments                                                      <co
            xml:id="booleans.9" />

variables
  "Bool" [0-9]* -&gt; Boolean                                                  <co
            xml:id="booleans.10" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="booleans.1">
            <para>Import the Boolean constants <literal>true</literal> and
            <literal>false</literal> defined earlier.</para>
          </callout>

          <callout arearefs="booleans.2">
            <para>The sort of Boolean expressions.</para>
          </callout>

          <callout arearefs="booleans.3">
            <para>Each Boolean constant is also a Boolean expression. This is
            called an <emphasis>injection rule</emphasis> or a <emphasis>chain
            rule</emphasis>.</para>
          </callout>

          <callout arearefs="booleans.4">
            <para>The infix operators for Boolean or (<literal>|</literal>)
            and Boolean and (&amp;). Both are left-associative and this is
            indicated by the attribute <literal>left</literal>. Also note that
            the arguments get explicit names (<literal>lhs</literal> and
            <literal>rhs</literal>) and that a constructor is defined
            (<literal>or</literal>, respectively, <literal>and</literal>).
            This information is only relevant for generated APIs that are
            accessed by external tools.</para>
          </callout>

          <callout arearefs="booleans.5">
            <para>The prefix operator not.</para>
          </callout>

          <callout arearefs="booleans.6">
            <para><literal>(</literal> and <literal>)</literal> may be used as
            brackets in Boolean expressions.</para>
          </callout>

          <callout arearefs="booleans.7">
            <para>&amp; has a higher priority than |. The expression
            <literal>Bool &amp; Bool | Bool</literal> will thus be interpreted
            as (Bool &amp; Bool) | Bool.</para>
          </callout>

          <callout arearefs="booleans.8">
            <para>Define a (hidden) start symbol for Boolean
            expressions.</para>
          </callout>

          <callout arearefs="booleans.9">
            <para>Import <literal>basic/Comments</literal> for the benefit of
            writing equations for Booleans (see below). Observe the subtlety
            that this a <emphasis>hidden</emphasis> import: comments are only
            available locally in this module and are not exported. By strictly
            adhering to this convention, low-level comment conventions cannot
            <emphasis>pollute</emphasis> higher level modules and interfere
            with comment conventions defined at that level.</para>
          </callout>

          <callout arearefs="booleans.10">
            <para>Declares Boolean variables like <literal>Bool</literal>,
            <literal>Bool1</literal>, <literal>Bool2</literal>,
            <literal>Bool123</literal>, <literal>Bool'</literal>,
            <literal>Bool''</literal>, <literal>Bool1'</literal>, and the
            like.</para>
          </callout>
        </calloutlist>

        <para>Having covered all syntactic aspects of the Booleans, we can now
        trun our attention to the equations:</para>

        <programlisting>equations

[B1]   true  | Bool  = true       <co xml:id="booleans-eq.1" />
[B2]   false | Bool  = Bool

[B3]   true  &amp; Bool  = Bool       <co xml:id="booleans-eq.2" />
[B4]   false &amp; Bool  = false

[B5]   not ( false ) = true       <co xml:id="booleans-eq.3" />
[B6]   not ( true )  = false</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="booleans-eq.1">
            <para>Meaning of the or operator, in other words: with these two
            rules the <literal>|</literal> operator can be eliminated from any
            Boolean expression.</para>
          </callout>

          <callout arearefs="booleans-eq.2">
            <para>Meaning of and operator.</para>
          </callout>

          <callout arearefs="booleans-eq.3">
            <para>Meaning of not operator.</para>
          </callout>
        </calloutlist>

        <para>The syntax of ASF+SDF equations is not fixed but depends on the
        syntax rules. This can be seen by making the fixed ASF+SDF syntax
        <emphasis role="bold">bold</emphasis> and the syntax specific for
        Booleans <emphasis>italic</emphasis>:</para>

        <para><programlisting><emphasis role="bold">equations</emphasis>

<emphasis role="bold">[B1]</emphasis>   <emphasis>true  | Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>true</emphasis>       
<emphasis role="bold">[B2]</emphasis>   <emphasis>false | Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>Bool</emphasis>

<emphasis role="bold">[B3]</emphasis>   <emphasis>true  &amp; Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>Bool</emphasis>       
<emphasis role="bold">[B4]</emphasis>   <emphasis>false &amp; Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>false</emphasis>

<emphasis role="bold">[B5]</emphasis>   <emphasis>not ( false )</emphasis> <emphasis>=</emphasis> <emphasis>true</emphasis>       
<emphasis role="bold">[B6]</emphasis>   not ( true )  <emphasis role="bold">=</emphasis> <emphasis>false</emphasis></programlisting></para>

        <para>This mixture of syntaxes will become even more apparent when we
        discuss the Pico definitions later.</para>
      </section>

      <section>
        <title>Reducing a Boolean expression</title>

        <para>The Boolean term <literal>not(true &amp; not(false |
        true))</literal> should reduce to <literal>true</literal> (check this
        for yourself before looking at the figure <link
        linkend="Fig_boolean_reduction">below</link>).</para>

        <figure xml:id="Fig_boolean_reduction">
          <title>Reducing a Boolean term.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="boolean-reduction.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Running the Boolean example in The Meta-Environment</title>

        <para>By far the best steps to get acquainted with the
        Meta-Environment are:</para>

        <itemizedlist>
          <listitem>
            <para>Have a look at the Flash movie: <emphasis>Guided Tour:
            Playing with Booleans</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Read the explanations and screenshots below.</para>
          </listitem>

          <listitem>
            <para>Get hands-on experience with The Meta-Environment
            itself.</para>
          </listitem>
        </itemizedlist>

        <para></para>
      </section>

      <section>
        <title>Take home points</title>

        <para>The example of the Booleans illustrates the following important
        points that are also valifd for more complex examples:</para>

        <itemizedlist>
          <listitem>
            <para>Each module <emphasis>defines a language</emphasis>: in this
            case the language of Booleans. In other contexts one can also
            speak about the datatype of the Booleans. We will use language and
            datatype as synonyms.</para>
          </listitem>

          <listitem>
            <para>We can use this language definition to;</para>

            <itemizedlist>
              <listitem>
                <para>Create a syntax-directed editor for Boolean language and
                create Boolean terms.</para>
              </listitem>

              <listitem>
                <para>Apply the equations to this term and reduce it to a
                normal form (= a term that is not further reducible).</para>
              </listitem>

              <listitem>
                <para>Import it in another module; this makes the Boolean
                language available for the importing module.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section>
    <title>The Toy Language Pico</title>

    <para>The toy language Pico has a single purpose in life: being so simple
    that specifications of every possible language aspect are so simple that
    they fit on a few pages. It can be summarized as follows:</para>

    <itemizedlist>
      <listitem>
        <para>There are two types: natural numbers and strings.</para>
      </listitem>

      <listitem>
        <para>Variables have to be declared.</para>
      </listitem>

      <listitem>
        <para>Statements are assignment, if-then-else and while-do.</para>
      </listitem>

      <listitem>
        <para>Expressions may contain naturals, strings, addition
        (<literal>+</literal>), substraction (<literal>-</literal>) and
        concatenation (<literal>||</literal>).</para>
      </listitem>

      <listitem>
        <para>The operators <literal>+</literal> and <literal>-</literal> have
        operands of type natural and their result is natural.</para>
      </listitem>

      <listitem>
        <para>The operator <literal>||</literal> has operands of type string
        and its results is also of type string.</para>
      </listitem>

      <listitem>
        <para>Tests in if-then-else statement and while-statement should be of
        type natural.</para>
      </listitem>
    </itemizedlist>

    <para>Let's look at a simple Pico program that computes the factorial
    function:</para>

    <programlisting>begin declare input : natural,            <co
        xml:id="fac.1" />
              output : natural,           
              repnr : natural,
              rep : natural;
      input := 14;
      output := 1;
      while input - 1 do                  <co xml:id="fac.2" />
          rep := output;
          repnr := input;
          while repnr - 1 do
             output := output + rep;
             repnr := repnr - 1
          od;
          input := input - 1
      od
end</programlisting>

    <para>Notes:</para>

    <calloutlist>
      <callout arearefs="fac.1">
        <para>Pico programs do not have input/output statements, so we use
        variables for that purpose.</para>
      </callout>

      <callout arearefs="fac.2">
        <para>Pico has no multiplication operator so we have have to simulate
        it with repeated addition (yes, simplicity comes at a price!).</para>
      </callout>
    </calloutlist>
  </section>

  <section>
    <title>Define the syntax for Pico</title>

    <para>The import structure of the syntax definition of Pico is shown <link
    linkend="Fig_imports_pico_syntax">below</link>. The modules
    <literal>basic/NatCon</literal>, <literal>basic/StrCon</literal> and
    <literal>basic/Whitespace</literal> are reused from the ASF+SDF library.
    The modules <literal>languages/pico/syntax/Identifiers</literal>,
    <literal>languages/pico/syntax/Types</literal> and
    <literal>languages/pico/syntax/Pico</literal> are specified for Pico and
    are now discussed in more detail.</para>

    <figure xml:id="Fig_imports_pico_syntax">
      <title>Import structure of Pico syntax</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pico-modules.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>languages/pico/syntax/Types</title>

      <para>Variables can be declared in Pico programs with one of two types:
      "natural number" or "string". This defined as follows:</para>

      <programlisting>module languages/pico/syntax/Types

exports
  sorts TYPE                 <co xml:id="types.1" />
  context-free syntax
    "natural"     -&gt; TYPE    <co xml:id="types.2" />
    "string"      -&gt; TYPE
    "nil-type"    -&gt; TYPE    <co xml:id="types.3" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="types.1">
          <para><literal>TYPE</literal> is the sort of possible types in Pico
          programs.</para>
        </callout>

        <callout arearefs="types.2">
          <para>The constants <literal>natural</literal> and
          <literal>string</literal> represent types as they can be declared in
          a Pico program.</para>
        </callout>

        <callout arearefs="types.3">
          <para>The constant <literal>nil-type</literal> is used for handling
          error cases.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>languages/pico/syntax/Identifiers</title>

      <para>Identifiers are used for the names of variables in Pico programs.
      The are defined as follows:</para>

      <programlisting>module languages/pico/syntax/Identifiers

imports basic/Whitespace

exports
  sorts PICO-ID                  <co xml:id="id.1" />
  lexical syntax
    [a-z] [a-z0-9]* -&gt; PICO-ID   <co xml:id="id.2" /></programlisting>

      <caution>
        <para>Why importing basic/Whitespace?</para>
      </caution>

      <caution>
        <para>Why are the lexical restrictions missing?</para>
      </caution>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="id.1">
          <para><literal>PICO-ID</literal> is the sort of identifiers in Pico
          programs.</para>
        </callout>

        <callout arearefs="id.2">
          <para>PICO-ID is defined using a regular expression that contains
          the following elements:</para>

          <itemizedlist>
            <listitem>
              <para><literal>[a-z]</literal>: a character class that ranges
              over all lower case letters.</para>
            </listitem>

            <listitem>
              <para><literal>[a-z0-9]</literal>: a character class that ranges
              over all lower case letters and over all digits.</para>
            </listitem>

            <listitem>
              <para><literal>[a-z0-9]*</literal>: <emphasis>zero</emphasis> or
              more repetitions of the character class
              <literal>[a-z0-9]</literal>. In other cases the postfix
              <literal>+</literal> operator can be used that defines
              <emphasis>one</emphasis> or more repetitions of the preceeding
              construct.</para>
            </listitem>
          </itemizedlist>

          <para>The overall effect of this definition is that Pico identifiers
          start with a lower case letter that can be followed by lower case
          letters or by digits.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>languages/pico/syntax/Pico</title>

      <para>After these preparations we can present the syntax for
      Pico:</para>

      <programlisting>module languages/pico/syntax/Pico

imports languages/pico/syntax/Identifiers 
imports languages/pico/syntax/Types
imports basic/NatCon 
imports basic/StrCon 

hiddens
  context-free start-symbols                                                   <co
          xml:id="pico-syntax.1" />
    PROGRAM

exports

  sorts PROGRAM DECLS ID-TYPE STATEMENT EXP                                    <co
          xml:id="pico-syntax.2" />

  context-free syntax                                                          <co
          xml:id="pico-syntax.3" />
    
    "begin" DECLS {STATEMENT";" }* "end"                          -&gt; PROGRAM   <co
          xml:id="pico-syntax.4" />
    "declare" {ID-TYPE "," }*";"                                  -&gt; DECLS 
    PICO-ID ":" TYPE                                              -&gt; ID-TYPE

  context-free syntax                                                          <co
          xml:id="pico-syntax.5" />

    PICO-ID ":=" EXP                                              -&gt; STATEMENT
    "if" EXP "then" {STATEMENT";" }* "else" {STATEMENT";" }* "fi" -&gt; STATEMENT
    "while" EXP "do" {STATEMENT ";" }* "od"                       -&gt; STATEMENT
 
  context-free syntax                                                          <co
          xml:id="pico-syntax.6" />

    PICO-ID       -&gt; EXP                                                       <co
          xml:id="pico-syntax.7" />                                                
    NatCon        -&gt; EXP                                                       
    StrCon        -&gt; EXP                                                       
    EXP "+" EXP   -&gt; EXP {left}                                                <co
          xml:id="pico-syntax.8" />
    EXP "-" EXP   -&gt; EXP {left}
    EXP "||" EXP  -&gt; EXP {left}
    "(" EXP ")"   -&gt; EXP {bracket}                                             <co
          xml:id="pico-syntax.9" />

  context-free priorities                                                      <co
          xml:id="pico-syntax.10" />
    EXP "||" EXP -&gt; EXP &gt;
    EXP "-" EXP -&gt; EXP &gt;
    EXP "+" EXP -&gt; EXP</programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="pico-syntax.1">
          <para><literal>PROGRAM</literal> is the start symbol for this
          grammar, i.e., each Pico program is derived from it.</para>
        </callout>

        <callout arearefs="pico-syntax.2">
          <para>The sorts <literal>PROGRAM</literal>,
          <literal>DECLS</literal>, <literal>ID-TYPE</literal>,
          <literal>STATEMENT</literal> and <literal>EXP</literal> are declared
          here and are used (in addition to the sorts declared in the imported
          modules) to define the Pico grammar.</para>
        </callout>

        <callout arearefs="pico-syntax.3">
          <para>This first context-free syntax section declares the toplevel
          structure of a Pico program.</para>
        </callout>

        <callout arearefs="pico-syntax.4">
          <para>The rule for PROGRAM contains the list construct<literal>
          {STATEMENT ";"}*</literal>. It describes zero or more statements
          separated by a semicolon (<literal>;</literal>).</para>
        </callout>

        <callout arearefs="pico-syntax.5">
          <para>This section declares the syntax for statements.</para>
        </callout>

        <callout arearefs="pico-syntax.6">
          <para>This final context-free syntax section declares expression
          syntax.</para>
        </callout>

        <callout arearefs="pico-syntax.7">
          <para>These three rules define that natural Pico identifiers,
          natural constants and string constants may occur as
          expressions.</para>
        </callout>

        <callout arearefs="pico-syntax.8">
          <para>The syntax of the operators <literal>+</literal>,
          <literal>-</literal> and <literal>||</literal> is defined. Observe
          that all three are left-associative. This implies that an expression
          like <literal>1+2+3</literal> is considered to be of the form
          <literal>(1+2)+3</literal> and that the other interpretation
          <literal>1+(2+3)</literal> is rejected.</para>
        </callout>

        <callout arearefs="pico-syntax.9">
          <para><literal>(</literal> and <literal>)</literal> can be used as
          brackets in expressions.</para>
        </callout>

        <callout arearefs="pico-syntax.10">
          <para>Priorities define the relative ordering of operators and are
          used to disambiguate text when more interpretations are possible.
          The higher the priority, the stronger the binding. The expression
          <literal>1-2+3</literal> will thus be interpreted as
          <literal>(1-2)+3</literal>.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>Using the Pico syntax in the Meta-Environment</title>

      <para></para>
    </section>

    <section>
      <title>Take home points</title>

      <para>The syntax of Pico illustrates the following important
      points:</para>

      <itemizedlist>
        <listitem>
          <para>All modules for a syntax definition reside in a subdirectory
          named <literal>syntax</literal>.</para>
        </listitem>

        <listitem>
          <para>The main module of the syntax definition has the same name as
          the language (with an uppercase, since all module names start with
          an uppercase letter).</para>
        </listitem>

        <listitem>
          <para>The modules languages/pico/syntax/Identifiers,
          languages/pico/syntax/Types and languages/pico/syntax/Pico define
          (together with the modules they import) the syntax of the Pico
          language.</para>
        </listitem>

        <listitem>
          <para>This syntax can be used to:</para>

          <itemizedlist>
            <listitem>
              <para>Generate a parser that can parse Pico programs.</para>
            </listitem>

            <listitem>
              <para>Generate a syntax-directed editor for Pico
              programs.</para>
            </listitem>

            <listitem>
              <para>Generate a parser that can parse equations containing
              fragments of Pico programs. This is similar to the use of
              different syntaxes in the definition of the <link
              linkend="Sec_basic_Booleans">Booleans</link> and is used for
              program analysis and transformation.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Define a typechecker for Pico</title>

    <para>The typechecking rules for the Pico language are very simple:</para>

    <itemizedlist>
      <listitem>
        <para>The only types are <literal>natural</literal> and
        <literal>string</literal>.</para>
      </listitem>

      <listitem>
        <para>All variables should be declared before use.</para>
      </listitem>

      <listitem>
        <para>Left-hand side and Right-hand side of an assignment statement
        should have equal type.</para>
      </listitem>

      <listitem>
        <para>The test in while statement and if-statement should be
        <literal>natural</literal>.</para>
      </listitem>

      <listitem>
        <para>Operands of <literal>+</literal> and <literal>-</literal> should
        be <literal>natural</literal>; their result is also
        <literal>natural</literal>.</para>
      </listitem>

      <listitem>
        <para>Operands of <literal>||</literal> should be
        <literal>string</literal>; the result is also
        <literal>string</literal>.</para>
      </listitem>
    </itemizedlist>

    <para>The task of a typechecker for Pico is to assert that a given Pico
    program complies with the above rules. The typecheker can be seen as a
    transformation from a Pico program to an error report.</para>

    <para>The import structure of the Pico typechecker is shown <link
    linkend="Fig_Pico_typechcker_modules">below</link>.</para>

    <figure xml:id="Fig_Pico_typechcker_modules">
      <title>Import structure of Pico typechecker</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pico-typecheck-modules.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section xml:id="Sec_Type-environments">
      <title>languages/pico/check/Type-environments</title>

      <para>The purpose of type environments is to maintain a mapping between
      identifiers and their type. This is done as follows:</para>

      <programlisting>module languages/pico/check/Type-environments

imports languages/pico/syntax/Identifiers 
imports containers/Table[PICO-ID TYPE]          <co xml:id="type-env.1" />

exports 
  sorts TENV TYPE 

  aliases
    Table[[PICO-ID,TYPE]] -&gt; TENV               <co xml:id="type-env.2" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="type-env.1">
          <para>Import the library module <literal>containers/Table</literal>.
          It is a parameterized module with first parameter denoting the sort
          of the keys in the table and the second parameter denoting the sort
          of the values to be stored in the table. After this import, the sort
          <literal>Table[[PICO-ID,TYPE]]</literal> (sorry about the double
          square brackets!) can be used as any other sort in the
          specification.</para>
        </callout>

        <callout arearefs="type-env.2">
          <para>It is pragmatic to give a more descriptive name to
          Table[[PICO-ID,TYPE]] and we use the <literal>alias</literal>
          construct for this. From now on, TENV is an alias (= an
          abbreviation) for Table[[PICO-ID,TYPE]].</para>
        </callout>
      </calloutlist>

      <para>For convenience, we list the most functions of Tables here:</para>

      <programlisting>module containers/Table[Key Value]
...
context-free syntax
  "not-in-table"                        -&gt; Value              {constructor} 
  "new-table"                           -&gt; Table[[Key,Value]]               
  lookup(Table[[Key,Value]], Key)       -&gt; Value                            
  store(Table[[Key,Value]], Key, Value) -&gt; Table[[Key,Value]]               
  delete(Table[[Key,Value]], Key)       -&gt; Table[[Key,Value]]               
  element(Table[[Key,Value]], Key)      -&gt; Boolean                          
  keys(Table[[Key,Value]])              -&gt; List[[Key]]                      
  values(Table[[Key,Value]])            -&gt; List[[Value]]
...</programlisting>

      <para>In the case of <literal>Type-environments</literal>, the formal
      parameter <literal>Key</literal> is bound to <literal>PICO-ID</literal>
      and <literal>Value</literal> is bound to <literal>TYPE</literal>.</para>
    </section>

    <section>
      <title>languages/pico/check/Pico</title>

      <para>The central idea of the Pico typechecker is to visit all language
      constructs in a given Pico program while maintaining a type environment
      that maps identifiers to their declared type. Whenever an identifier is
      used, the type correctness of that use in the given context is checked
      against its declared type that is given by the type environment. An
      error message is generated when any violation of the type rules is
      detected. The following type checker is realistic in the following
      sense:</para>

      <itemizedlist>
        <listitem>
          <para>It discovers all errors.</para>
        </listitem>

        <listitem>
          <para>It generates a message for each error.</para>
        </listitem>

        <listitem>
          <para>The error message contains the source code location of the
          pico construct that violates the type rules.</para>
        </listitem>

        <listitem>
          <para>The type checker can be directly embedded in and used from The
          Meta-Environment.</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>Syntax part</title>

        <para>First consider the syntax part of the Pico typechecker:</para>

        <programlisting>module languages/pico/check/Pico

imports basic/Booleans
imports basic/Errors                                    <co xml:id="pico-tc.1" />
imports languages/pico/syntax/Pico
imports languages/pico/check/Type-environments
imports utilities/PosInfo[EXP]                          <co xml:id="pico-tc.2" />
imports utilities/PosInfo[PICO-ID]
imports utilities/PosInfo[PROGRAM]

exports
context-free syntax
  "tcp"(PROGRAM) -&gt; {Error ","}*                        <co
            xml:id="pico-tc.3" />

hiddens
context-free syntax                                     <co xml:id="pico-tc.4" />
  "tcd"(DECLS)                  -&gt; TENV          
  "tcits"({ID-TYPE ","}*, TENV) -&gt; TENV          
  "tcit"(ID-TYPE, TENV)         -&gt; TENV          
  "tcs"({STATEMENT ";"}*, TENV) -&gt; {Error ","}*  
  "tcst"(STATEMENT, TENV)       -&gt; {Error ","}*  
  "tce"(EXP, TYPE, TENV)        -&gt; {Error ","}*  

context-free start-symbols
  Summary PROGRAM {Error ","}*

variables
  "Message"          -&gt; StrCon            
  "Error*" [0-9\']*  -&gt; {Error ","}*      
  "Decls" [0-9\']*   -&gt; DECLS             
  "Exp" [0-9\']*     -&gt; EXP               
  "Id" [0-9\']*      -&gt; PICO-ID           
  "Id-type*" [0-9]*  -&gt; {ID-TYPE ","}*    
  "Nat-con" [0-9\']* -&gt; NatCon            
  "Series" [0-9\']*  -&gt; {STATEMENT ";"}+  
  "Stat" [0-9\']*    -&gt; STATEMENT         
  "Stat*" [0-9\']*   -&gt; {STATEMENT ";"}*  
  "Str-con" [0-9\']* -&gt; StrCon            
  "Tenv" [0-9\']*    -&gt; TENV              
  "Type" [0-9\']*    -&gt; TYPE              
  "Program" [0-9\']* -&gt; PROGRAM         </programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="pico-tc.1">
            <para>The library module basic/Errors describes an error format
            that is ubiquitous in The Meta-Environment. There are four
            categories of errors: <literal>info</literal>,
            <literal>warning</literal>, <literal>error</literal> and
            <literal>fatal</literal>. Each error contains a text that
            describes the error and a list of subjects where the error
            occurred. Each subject consists of a description and actual source
            code locations. All error messages detected by some tool are
            collected in a <literal>summary that contains an identifier for
            the tool, an identifier for this error summary and a list of
            errors. In the next subsection, various examples will be
            shown.</literal></para>
          </callout>

          <callout arearefs="pico-tc.2">
            <para>The library module <literal>utilities/PosInfo</literal>
            defines functions to get the source code location of any part of
            the input program.</para>
          </callout>

          <callout arearefs="pico-tc.3">
            <para><literal>tcp</literal> is the main type check function for
            complete Pico programs.</para>
          </callout>

          <callout arearefs="pico-tc.4">
            <para>Several auxiliary functions are defined that are used in the
            definition of <literal>tcp</literal>. Note how some of these
            functions take a TENV (type environment) as one of their arguments
            and return a possibly modified TENV as result. Other functions
            only use the TENV argument and directly produce error
            messages.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title>Equations part</title>

        <para>Now let's turn our attention to the equations part of the Pico
        typechecker:</para>

        <programlisting>equations

[Main] start(PROGRAM, Program) = start(Summary, summary("pico-check",get-filename(get-location(Program)), [tcp(Program)]))
                                                                                <co
            xml:id="pico-tc-eq.1" />

equations

[Tc1]  tcp(begin Decls Series end) = tcs(Series, tcd(Decls))                    <co
            xml:id="pico-tc-eq.2" />

equations

[Tc2]  tcd(declare Id-type*;) = tcits(Id-type*, new-table)                      <co
            xml:id="pico-tc-eq.3" />

equations

[Tc3a] tcits(Id:Type, Id-type*, Tenv) = tcits(Id-type*, tcit(Id:Type, Tenv))    <co
            xml:id="pico-tc-eq.4" />

[Tc3b] tcits(,Tenv) = Tenv                                                      <co
            xml:id="pico-tc-eq.5" />

equations

[Tc4a] lookup(Tenv, Id) == not-in-table
       ===========================================                              <co
            xml:id="pico-tc-eq.6" />
       tcit(Id:Type, Tenv) = store(Tenv, Id, Type)

[default] tcit(Id:Type, Tenv) = Tenv

equations

[Tc5a] tcs(Stat ; Stat*, Tenv) =                                                <co
            xml:id="pico-tc-eq.7" />
       tcst(Stat,Tenv), tcs(Stat*,Tenv)

[Tc5b] tcs(,Tenv) = 

equations

[Tc6a]
    not-in-table == lookup(Tenv, Id)
    ===================================================================         <co
            xml:id="pico-tc-eq.8" />
    tcst(Id := Exp, Tenv) = 
    error("Variable not declared", [localized("Id", get-location(Id))])

[default] tcst(Id := Exp, Tenv) = tce(Exp, lookup(Tenv, Id), Tenv)              <co
            xml:id="pico-tc-eq.9" />

[Tc6b]  tcst(if Exp then Series1 else Series2 fi, Tenv) =                       <co
            xml:id="pico-tc-eq.10" />
        tce(Exp, natural, Tenv), tcs(Series1, Tenv), tcs(Series2, Tenv)

[Tc6c]  tcst(while Exp do Series od, Tenv) = 
        tce(Exp, natural, Tenv), tcs(Series, Tenv)

equations

[default] tce(Exp, natural, Tenv) =                                            <co
            xml:id="pico-tc-eq.11" />
          error("Expression should be of type natural", [localized("Expression", get-location(Exp))])
[default] tce(Exp, string, Tenv) = 
          error("Expression should be of type string", [localized("Expression", get-location(Exp))])

[Tc7a]  tce(Id, Type, Tenv) = 
        when Type == lookup(Tenv, Id)                                          <co
            xml:id="pico-tc-eq.12" />
[Tc7b]  tce(Nat-con, natural, Tenv) =                                          <co
            xml:id="pico-tc-eq.13" />
[Tc7c]  tce(Str-con, string, Tenv) = 
[Tc7d]  tce(Exp1 || Exp2, string, Tenv) = tce(Exp1, string, Tenv), tce(Exp2, string, Tenv)   <co
            xml:id="pico-tc-eq.14" />
[Tc7d]  tce(Exp1 + Exp2, natural, Tenv) = tce(Exp1, natural, Tenv), tce(Exp2, natural, Tenv)
[Tc7d]  tce(Exp1 - Exp2, natural, Tenv) = tce(Exp1, natural, Tenv), tce(Exp2, natural, Tenv)</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="pico-tc-eq.1">
            <para>The first equation of this module is probably also the most
            intimidating one. Its role is similar to the
            <literal>main</literal> function in C programs or the
            <literal>main</literal> method in Java programs; it is an entry
            point for execution and indicates with which function execution
            starts. Here, we want to establish a connection between the
            ordinary ASF+SDF functions defined in a module and the calling
            context of The Meta-Environment. Typically, you are editing a Pico
            program and on the push of a button you want the typecheck
            function to be applied to it. The left-hand side
            <literal>start(PROGRAM, Program)</literal> defines that execution
            operates on something of the sort <literal>PROGRAM</literal>. That
            "something" is given as value of the variable
            <literal>Program</literal>. The right-hand side
            <literal>start(Summary,
            summary("pico-check",get-filename(get-location(Program)),
            [tcp(Program)]))</literal> defines in a similar fashion that the
            result sort of execution is <literal>Summary</literal> and a
            recipe how to compute that result.</para>
          </callout>

          <callout arearefs="pico-tc-eq.2">
            <para>Type checking a complete program amounts to typechecking its
            declarations (this yields a type environment) and checking its
            statements in that environment.</para>
          </callout>

          <callout arearefs="pico-tc-eq.3">
            <para>To type check declarations create a new type environment
            (<literal>new-table</literal>) and visit all identifier-type pairs
            in the declaration.</para>
          </callout>

          <callout arearefs="pico-tc-eq.4">
            <para>To check a list of identifier-type pairs, we have to visit
            each pair in the list. We use <emphasis>list matching</emphasis>
            to achieve this: in the left-hand side <literal>tcits(Id:Type,
            Id-type*, Tenv)</literal> the first argument of tcits (the list of
            identifier-type pairs) is decomposed into three values that are
            assigned to variables. The first pair is decomposed into an
            identifier (<literal>Id</literal>) and a type
            (<literal>Type</literal>). The remainder of the list is assigned
            to the variable<literal> Id-type*</literal> (note that we use the
            naming convention that variables that have lists of zero or more
            elements as value end on <literal>*</literal> and, similarly,
            variables that have one or more elements as value end on
            <literal>+</literal>). In the right-hand side of this equation,
            the contribution of the first pair to the type-environment is
            computed (using tcit) and the remainder of the list of
            identifier-type pairs is checked recursively.</para>
          </callout>

          <callout arearefs="pico-tc-eq.5">
            <para>The left-hand side <literal>tcits(,Tenv)</literal> looks
            like a type but it is not. An empty list of identifier-type pairs
            is really denoted by the empty text!</para>
          </callout>

          <callout arearefs="pico-tc-eq.6">
            <para>An identifier that does not yet occur in the type
            environment is stored in the type environment together with its
            type.</para>
          </callout>

          <callout arearefs="pico-tc-eq.7">
            <para>Again, list matching to decompose a list of statements into
            a first statement and a list of remaining statements. Next, check
            the first statement and the remining statements.</para>
          </callout>

          <callout arearefs="pico-tc-eq.8">
            <para>Check an assignment statement and discover that the
            identifier on the left-hand side of the assignment is not
            declared. Return an error.</para>
          </callout>

          <callout arearefs="pico-tc-eq.9">
            <para>Otherwise, check the type of the expression on the
            right-hand side of the assignment. The declared type of the
            variable on the left-hand side and the derived type of the
            expression on the right-hand side should be the same. Note that
            the <literal>[default]</literal> label in front of this equation
            characterizes it as a <emphasis>default equation</emphasis> that
            is applied after all other equations have been tried. Default
            equations serve to catch all cases that are not handled by other
            equations.</para>
          </callout>

          <callout arearefs="pico-tc-eq.10">
            <para>Checking if-statements and while-statements amounts to
            checking that the test is of type
            <literal>natural</literal>.</para>
          </callout>

          <callout arearefs="pico-tc-eq.11">
            <para>Two default equations that generate an error message when
            the expected type and the actual type of an expression are
            unequal.</para>
          </callout>

          <callout arearefs="pico-tc-eq.12">
            <para>When the declared type of an identifier is equal to the
            expected type, we generate an empty list of errors.</para>
          </callout>

          <callout arearefs="pico-tc-eq.13">
            <para>Similarly, natural constants and string constants satisfy
            the expected types natural, respectively, string.</para>
          </callout>

          <callout arearefs="pico-tc-eq.14">
            <para>For operators, the operands are checked separately.</para>
          </callout>
        </calloutlist>
      </section>
    </section>

    <section>
      <title>Using the Pico typecheker in The Meta-Environment</title>

      <para></para>
    </section>

    <section>
      <title>Take home points</title>

      <para>The Pico typechecker illustrates the following points:</para>

      <itemizedlist>
        <listitem>
          <para>ASF+SDF can be used to define a type checker.</para>
        </listitem>

        <listitem>
          <para>ASF+SDF provides support for error messages and source code
          locations.</para>
        </listitem>

        <listitem>
          <para>All modules for a typechecker reside in a subdirectory named
          <literal>check</literal>.</para>
        </listitem>

        <listitem>
          <para>A typechecker can be integrated with The
          Meta-Environment.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Defining an evaluator for Pico</title>

    <para>The evaluation rules for the Pico language are simple as
    well:</para>

    <itemizedlist>
      <listitem>
        <para>Variables of type <literal>natural</literal> are initialized to
        0.</para>
      </listitem>

      <listitem>
        <para>Variables of type string are initalized to the empty
        string.</para>
      </listitem>

      <listitem>
        <para>A variable evaluates to its current value.</para>
      </listitem>

      <listitem>
        <para>The variable on the left-hand side of an assignment statement
        gets as value the value of the expression on the right-hand side of
        the assignment.</para>
      </listitem>

      <listitem>
        <para>If the test in an if-statement or while-statement evaluates to
        0, this is interpreted as <emphasis>false</emphasis>.</para>
      </listitem>

      <listitem>
        <para>Conversely, if the test in an if-statement or while-statement
        evaluates to 0, this is interpreted as
        <emphasis>true</emphasis>.</para>
      </listitem>

      <listitem>
        <para>The statements in a list of statements are evaluated in
        sequential order.</para>
      </listitem>
    </itemizedlist>

    <para>The task of the Pico evaluator is to reduce a Pico program to the
    output it generates, in this case a value environment. The Pico evaluator
    can be seen as a transformation from a Pico program to its output.</para>

    <para>The import structure of the Pico evaluator is shown <link
    linkend="Fig_pico_eval_modules">below</link>.</para>

    <figure xml:id="Fig_pico_eval_modules">
      <title>Import structure of Pico evaluator</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pico-eval-modules.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>languages/pico/run/Values</title>

      <para>The sort <literal>VALUE</literal> is simply a container for
      integer and string constants and is defined as follows:</para>

      <programlisting>module languages/pico/run/Values

imports basic/Integers basic/StrCon

exports
  sorts VALUE
  context-free syntax
    Integer     -&gt; VALUE
    StrCon      -&gt; VALUE
    "nil-value" -&gt; VALUE  <co xml:id="value.1" /></programlisting>

      <caution>
        <para>Why Integer and not IntCon?</para>
      </caution>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="value.1">
          <para>The constant <literal>nil-value</literal> denotes error
          values.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>languages/pico/run/Value-environments</title>

      <para>The purpose of value environments is to maintain a mapping between
      identifiers and their current value. This is done as follows:</para>

      <programlisting>module languages/pico/run/Value-environments

imports languages/pico/syntax/Identifiers 
imports languages/pico/run/Values 
imports containers/Table[PICO-ID VALUE]
    
exports
  sorts VENV 
  aliases
    Table[[PICO-ID, VALUE]] -&gt; VENV</programlisting>

      <para>After the discussion of <link
      linkend="Sec_Type-environments">Type-environments</link>, this
      definition should be easy to follow.</para>
    </section>

    <section>
      <title>languages/pico/run/Pico</title>

      <para>The central idea of the Pico evaluator is to first visit the
      declarations and initialise the declared variables. Next, the statements
      are visited one-by-one and their effect on the value environment is
      computed. The final value environment is then retruned as the result of
      evaluation.</para>

      <section>
        <title>Syntax part</title>

        <para>The syntax part of the Pico evaluator looks as follows:</para>

        <programlisting>module languages/pico/run/Pico

imports languages/pico/syntax/Pico
imports languages/pico/run/Value-environments
imports basic/Strings

exports
  sorts VALUE-ENV

  context-free syntax
    VENV                          -&gt; VALUE-ENV

  context-free syntax
    "evp"(PROGRAM)                -&gt; VALUE-ENV

  context-free syntax
    "evd"(DECLS)                  -&gt; VENV
    "evits"({ID-TYPE  ","}*)      -&gt; VENV
    "evs"({STATEMENT ";"}*, VENV) -&gt; VENV
    "evst"(STATEMENT, VENV)       -&gt; VENV
    "eve"(EXP, VENV)              -&gt; VALUE

hiddens
  imports basic/Comments
  context-free start-symbols
    VALUE-ENV PROGRAM

  variables
    "Decls"[0-9\']*   -&gt; DECLS
    "Exp"[0-9\']*     -&gt; EXP
    "Id"[0-9]*        -&gt; PICO-ID
    "Id-type*"[0-9]*  -&gt; {ID-TYPE ","}*
    "Nat"[0-9\']*     -&gt; Integer 
    "Nat-con"[0-9\']* -&gt; NatCon
    "Series"[0-9\']*  -&gt; {STATEMENT ";"}+
    "Stat"[0-9\']*    -&gt; STATEMENT
    "Stat*"[0-9\']*   -&gt; {STATEMENT ";"}*
    "Str" "-con"? [0-9\']* -&gt; StrCon
    "Value"[0-9\']*   -&gt; VALUE
    "Venv"[0-9\']*    -&gt; VENV
    "Program"[0-9\']* -&gt; PROGRAM</programlisting>

        <caution>
          <para>Why VENV and VALUE-ENV?</para>
        </caution>

        <para>Here again, having seen the syntax part of the Pico typechecker
        there are no surprises here. The toplevel function
        <literal>evp</literal> maps programs to value environments and needs
        some auxiliary functions to achieve this.</para>
      </section>

      <section>
        <title>Equations part</title>

        <para>The equations part:</para>

        <programlisting>equations

[Main] start(PROGRAM, Program) = start(VALUE-ENV, evp(Program))       <co
            xml:id="pico-eval.1" />

equations
[Ev1]  evp(begin Decls Series end) = evs(Series, evd(Decls))

[Ev2]  evd(declare Id-type*;) = evits(Id-type*)

[Ev3a] evits(Id:natural, Id-type*) = store(evits(Id-type*), Id, 0)    <co
            xml:id="pico-eval.2" />

[Ev3b]  evits(Id:string, Id-type*) = store(evits(Id-type*), Id, "")

[Ev3c]  evits() = []

[Ev4a]   Venv' := evst(Stat, Venv), Venv'' := evs(Stat*, Venv')
        =====================================================        <co
            xml:id="pico-eval.3" />
           evs(Stat ; Stat*, Venv) =  Venv''

[Ev4b]  evs( , Venv) = Venv

[Ev5a]  evst(Id := Exp, Venv) = store(Venv, Id, eve(Exp, Venv))

[Ev5b]             eve(Exp, Venv) != 0
        ====================================================         <co
            xml:id="pico-eval.4" />
        evst(if Exp then Series1 else Series2 fi, Venv) = evs(Series1, Venv)

[Ev5c]             eve(Exp, Venv) == 0
        ====================================================         <co
            xml:id="pico-eval.5" />
        evst(if Exp then Series1 else Series2 fi, Venv) = evs(Series2, Venv)

[Ev5d]           eve(Exp, Venv) == 0
        ==========================================                   <co
            xml:id="pico-eval.6" />
        evst(while Exp do Series od, Venv) =  Venv

[Ev5e]  eve(Exp, Venv) != 0,  Venv' := evs(Series, Venv)
        ===============================================              <co
            xml:id="pico-eval.7" />
        evst(while Exp do Series od, Venv) =
                           evst(while Exp do Series od, Venv')

[Ev6a]  eve(Id, Venv) = lookup(Venv, Id)                             <co
            xml:id="pico-eval.8" />
[Ev6b]  eve(Nat-con, Venv) = Nat-con                                 <co
            xml:id="pico-eval.9" />
[Ev6c]  eve(Str-con, Venv) = Str-con

[Ev6d]  Nat1 := eve(Exp1, Venv),
        Nat2 := eve(Exp2, Venv)
        ======================                                       <co
            xml:id="pico-eval.10" />
        eve(Exp1 + Exp2, Venv) = Nat1 + Nat2

[Ev6e]  Nat1 := eve(Exp1, Venv),
        Nat2 := eve(Exp2, Venv)
        ======================
        eve(Exp1 - Exp2, Venv) =  Nat1 -/ Nat2

[Ev6f]  Str1 := eve(Exp1, Venv),
        Str2 := eve(Exp2, Venv),
        Str3 := concat(Str1, Str2)
        ======================
        eve(Exp1 || Exp2, Venv) = Str3

[default-Ev6]  eve(Exp,Venv) = nil-value
</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="pico-eval.1">
            <para>A start equations that connects the functions defined here
            to The Meta-Environment: given a program, a value environment is
            returned and this computed by applying the function
            <literal>evp</literal> to the program.</para>
          </callout>

          <callout arearefs="pico-eval.2">
            <para>Here declared variables are initalized.</para>
          </callout>

          <callout arearefs="pico-eval.3">
            <para>Evaluation of a series of statements. Observe how the value
            environment <literal>Venv'</literal> that is modified by executing
            the first statement is used to evaluate the remaining statements.
            In this way, the assignments made by the first statement become
            available for the remaining statements.</para>
          </callout>

          <callout arearefs="pico-eval.4">
            <para>Evaluation of if statement; the true case.</para>
          </callout>

          <callout arearefs="pico-eval.5">
            <para>Evaluation of if statement; the false case.</para>
          </callout>

          <callout arearefs="pico-eval.6">
            <para>Evaluation of while statement; the false case.</para>
          </callout>

          <callout arearefs="pico-eval.7">
            <para>Evaluation of while statement; the true case. Note that the
            body of the while statement is evaluated and that the resulting
            value environment <literal>Venv'</literal> is used to evaluate the
            next iteration of the while statement.</para>
          </callout>

          <callout arearefs="pico-eval.8">
            <para>A varaible evaluates to its current value.</para>
          </callout>

          <callout arearefs="pico-eval.9">
            <para>Constants evaluate to themselves.</para>
          </callout>

          <callout arearefs="pico-eval.10">
            <para>Operators are evaluated by first evaluating their argument
            and then applying the relevant operator to them. Observe that the
            <literal>+</literal> in the Pico expression <literal>Exp1 +
            Exp2</literal> is the plus operator as defined by Pico. The
            <literal>+</literal> operator in <literal>Nat1 + Nat2</literal> is
            the addition on integers as defined in basic/Integers. So we reuse
            the definition of addition on integers to define addition in
            Pico.</para>
          </callout>
        </calloutlist>
      </section>
    </section>

    <section>
      <title>Using the Pico evaluator in the Meta-Environment</title>

      <para></para>
    </section>

    <section>
      <title>Take home points</title>

      <para>The Pico evaluator has revealed the following points:</para>

      <itemizedlist>
        <listitem>
          <para>ASF+SDF can be used to define an evaluator.</para>
        </listitem>

        <listitem>
          <para>All modules for an evaluator reside in a subdirectory named
          <literal>run</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Defining a compiler for Pico</title>

    <para></para>

    <figure>
      <title>Import structure Pico compiler</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pico-compile-modules.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>languages/pico/compileAsssemblyLanguage</title>

      <para></para>

      <programlisting>module languages/pico/compile/AssemblyLanguage

imports basic/Integers basic/Strings 
imports languages/pico/syntax/Identifiers

exports 
  sorts Label Instr
  lexical syntax
    [a-z0-9]+         -&gt; Label 
  context-free syntax
    "dclnat" PICO-ID  -&gt; Instr
    "dclstr" PICO-ID  -&gt; Instr

    "push" NatCon     -&gt; Instr
    "push" StrCon     -&gt; Instr
    "rvalue" PICO-ID  -&gt; Instr 
    "lvalue" PICO-ID  -&gt; Instr 
    "assign"          -&gt; Instr 
    "add"             -&gt; Instr 
    "sub"             -&gt; Instr 
    "conc"            -&gt; Instr 
    "label" Label     -&gt; Instr 
    "goto" Label      -&gt; Instr 
    "gotrue" Label    -&gt; Instr 
    "gofalse" Label   -&gt; Instr
    "noop"            -&gt; Instr

  sorts Instrs
context-free syntax
    {Instr";"}+       -&gt; Instrs</programlisting>
    </section>

    <section>
      <title>languages/pico/compile/NextLabel</title>

      <programlisting>module languages/pico/compile/NextLabel

imports languages/pico/compile/AssemblyLanguage

exports
context-free syntax
  "nextlabel" "(" Label ")" -&gt; Label  

hiddens
lexical variables
  "Char+" [0-9]* -&gt; [a-z0-9]+  </programlisting>

      <para></para>

      <programlisting>equations

 [1] nextlabel(label(Char+)) = label(Char+ x)</programlisting>
    </section>

    <section>
      <title>languages/pico/compile/Pico</title>

      <para></para>

      <section>
        <title>Syntax part</title>

        <para></para>

        <programlisting>module languages/pico/compile/Pico

imports languages/pico/syntax/Pico
imports languages/pico/compile/AssemblyLanguage 
imports languages/pico/compile/NextLabel 

  
exports
  context-free syntax
    trp( PROGRAM ) -&gt; Instrs
  
hiddens
  context-free start-symbols
    PROGRAM Instrs
  context-free syntax
    trd(DECLS)                    -&gt; {Instr ";"}+
    trits({ID-TYPE  ","}*)        -&gt; {Instr ";"}+ 
    trs({STATEMENT ";"}*, Label)  -&gt; &lt;{Instr ";"}+ , Label&gt;
    trst(STATEMENT, Label)        -&gt; &lt;{Instr ";"}+ , Label &gt;
    tre(EXP)                      -&gt; {Instr ";"}+

hiddens
  variables
    "Decls"[0-9\']*   -&gt; DECLS
    "Exp"[0-9\']*     -&gt; EXP
    "Id"[0-9]*        -&gt; PICO-ID
    "Id-type*"[0-9]*  -&gt; {ID-TYPE ","}*
    "Nat-con"[0-9\']* -&gt; NatCon
    "Series"[0-9\']*  -&gt; {STATEMENT ";"}+
    "Stat"[0-9\']*    -&gt; STATEMENT
    "Stat*"[0-9\']*   -&gt; {STATEMENT ";"}*
    "Str-con"[0-9\']* -&gt; StrCon
    "Str"[0-9\']*     -&gt; String

    "Instr*"[0-9\']*  -&gt; {Instr ";"}+
    "Label" [0-9\']*  -&gt; Label
    "Program" -&gt; PROGRAM</programlisting>
      </section>

      <section>
        <title>Equations part</title>

        <para></para>

        <programlisting>equations

[main] start(PROGRAM, Program) = start(Instrs, trp(Program))

equations 

[Tr1]  Instr*1 := trd(Decls),
       &lt;Instr*2, Label&gt; := trs(Series, x)
       =================================
       trp(begin Decls Series end) = Instr*1; Instr*2

[Tr2]  trd(declare Id-type*;) = trits(Id-type*)
 
[Tr3a] trits(Id:natural, Id-type*) = 
       dclnat Id;
       trits(Id-type*)
 
[Tr3b] trits(Id:string, Id-type*) = 
       dclstr Id; 
       trits(Id-type*)
 
[Tr3c] trits() = noop

[Tr4a] &lt;Instr*1, Label'&gt; := trst(Stat, Label), 
       &lt;Instr*2, Label''&gt; := trs(Stat*, Label')
       =======================================
       trs(Stat ; Stat*, Label) = 
       &lt; Instr*1;
         Instr*2
       , 
         Label'' &gt;

[Tr4b] trs( , Label) = &lt;noop, Label&gt;

[Tr5a] Instr* := tre(Exp)
       ================= 
       trst(Id := Exp, Label) = 
       &lt; lvalue Id;
         Instr*; 
         assign
       , 
         Label &gt;

[Tr5b] Instr* := tre(Exp), 
       &lt;Instr*1, Label'&gt; := trs(Series1, Label),
       &lt;Instr*2, Label''&gt; := trs(Series2, Label'),
       Label1 := nextlabel(Label''), 
       Label2 := nextlabel(Label1) 
       ========================================================== 
       trst(if Exp then Series1  else Series2 fi, Label) =
       &lt; Instr*; 
         gofalse Label1; 
         Instr*1;
         goto Label2; 
         label Label1; 
         Instr*2;
 	 label Label2
       , 
         Label2 &gt;

[Tr5c] Instr*1 := tre(Exp), &lt;Instr*2, Label'&gt; := trs(Series, Label),
       Label1 := nextlabel(Label'), Label2 := nextlabel(Label1) 
       =========================================================== 
       trst(while Exp do Series od, Label) =
       &lt; label Label1; 
         Instr*1; 
         gofalse Label2; 
         Instr*2;
         goto Label1; 
         label Label2
       , 
         Label2 &gt;

[Tr6a] tre(Nat-con) = push Nat-con

[Tr6b] tre(Str-con) = push Str-con

[Tr6c] tre(Id) = rvalue Id

[Trcd] Instr*1 := tre(Exp1), Instr*2 := tre(Exp2)
       ======================================== 
       tre(Exp1 + Exp2) = Instr*1; Instr*2; add

[Tr6e] Instr*1 := tre(Exp1), Instr*2 := tre(Exp2)
       ======================================== 
       tre(Exp1 - Exp2) = Instr*1; Instr*2; sub

[Tr6f] Instr*1 := tre(Exp1), Instr*2 := tre(Exp2)
       ========================================== 
       tre(Exp1 || Exp2) = Instr*1; Instr*2; conc

</programlisting>
      </section>
    </section>

    <section>
      <title>Using the Pico compiler in the Meta-Environment</title>

      <para></para>
    </section>

    <section>
      <title>Take home points</title>

      <para></para>
    </section>
  </section>

  <section xml:id="fm_HistoricalNotes">
    <title>Historical Notes</title>

    <para></para>
  </section>

  <section>
    <title></title>

    <para></para>
  </section>

  <section>
    <title></title>

    <para></para>
  </section>

  <section>
    <title></title>

    <para></para>
  </section>

  <section xml:id="fm_ToDo">
    <title>To Do</title>

    <itemizedlist>
      <listitem>
        <para>Examples section</para>
      </listitem>

      <listitem>
        <para>Add links to Historical notes section</para>
      </listitem>
    </itemizedlist>
  </section>
</article>