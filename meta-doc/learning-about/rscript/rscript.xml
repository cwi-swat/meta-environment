<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
]>
<chapter version="5.0" xml:id="rscript" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns6="http://www.w3.org/1999/xhtml"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>Rscript --- a Relational Approach to Software Analysis</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>
    </authorgroup>

    <pubdate>to be filled in</pubdate>
  </info>

  <warning>
    <para>This document is in the process of being converted to
    DocBook.</para>
  </warning>

  <section xml:id="section.introduction">
    <title>Introduction</title>

    <formalpara>
      <title>Extract-Enrich-View paradigm</title>

      <para>Rscript is a small scripting language based on the relational
      calculus. It is intended for analyzing and querying the source code of
      software systems: from finding uninitialized variables in a single
      program to formulating queries about the architecture of a complete
      software system. Rscript fits well in the extract-enrich-view paradigm
      shown in <xref linkend="figure.paradigm" />.</para>
    </formalpara>

    <formalpara>
      <title>Extract</title>

      <para>Given the source text, extract relevant information from it in the
      form of relations. Examples are the CALLS relation that describes direct
      calls between procedures, the USE relation that relates statements with
      the variables that are used in the statements, and the PRED relation
      that relates a statement with its predecessors in the control flow
      graph. The extraction phase is outside the scope of Rscript but may, for
      instance, be implemented using ASF+SDF and we will give examples how to
      do this.</para>
    </formalpara>

    <formalpara>
      <title>Enrich</title>

      <para>Derive additional information from the relations extracted from
      the source text. For instance, use CALLS to compute procedures that can
      also call each other indirectly (using transitive closure). Here is
      where Rscript shines.</para>
    </formalpara>

    <formalpara>
      <title>View</title>

      <para>The result of the enrichment phase are again bags and relations.
      These can be displayed with various tools like, Dot <xref
      linkend="Dot96" />, Rigi <xref linkend="Mueller88" /> and others.
      Rscript is not concerned with viewing but we will give some examples
      anyway.</para>
    </formalpara>

    <figure xml:id="figure.paradigm">
      <title>The extract-enrich-view paradigm</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="paradigm.png" scale="50"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <formalpara>
      <title>Application of Relations to Program Analysis</title>

      <para>Many algorithms for program analysis are usually presented as
      <emphasis>graph</emphasis> algorithms and this seems to be at odds with
      the extensive experience of using <emphasis>term</emphasis> rewriting
      for tasks as type checking, fact extraction, analysis and
      transformation. The major obstacle is that graphs can and terms cannot
      contain cycles. Fortunately, every graph can be represented as a
      relation and it is therefore natural to have a look at the combination
      of relations and term rewriting. Once you start considering problems
      from a relational perspective, elegant and concise solutions start to
      appear. Some examples are:</para>
    </formalpara>

    <itemizedlist>
      <listitem>
        <para>Analysis of call graphs and the structure of software
        architectures.</para>
      </listitem>

      <listitem>
        <para>Detailed analysis of the control flow or dataflow of
        programs.</para>
      </listitem>

      <listitem>
        <para>Program slicing.</para>
      </listitem>

      <listitem>
        <para>Type checking.</para>
      </listitem>

      <listitem>
        <para>Constraint problems.</para>
      </listitem>
    </itemizedlist>

    <formalpara>
      <title>What's new in Rscript?</title>

      <para>Given the considerable amount of related work to be discussed
      below, it is necessary to clearly establish what is and what is not new
      in our approach:</para>
    </formalpara>

    <itemizedlist>
      <listitem>
        <para>We use sets and relations like Rigi<xref linkend="Mueller88" />
        and GROK <xref linkend="Holt96" /> do. After extensive experimentation
        we have decided <emphasis>not</emphasis> to use bags and
        multi-relations like in RPA <xref
        linkend="FeijsKrikhaarOmmering98" />.</para>
      </listitem>

      <listitem>
        <para>Unlike several other systems we allow
        <emphasis>nested</emphasis> sets and relations and also support
        <replaceable>n</replaceable>-ary relations as opposed to just binary
        relations but don't support the complete repertoire of
        <replaceable>n</replaceable>-ary relations as in SQL.</para>
      </listitem>

      <listitem>
        <para>We offer a strongly typed language with user-defined
        types.</para>
      </listitem>

      <listitem>
        <para>Unlike Rigi <xref linkend="Mueller88" />, GROK <xref
        linkend="Holt96" /> and RPA <xref
        linkend="FeijsKrikhaarOmmering98" />we provide a relational
        <emphasis>calculus</emphasis> as opposed to a relational algebra.
        Although the two have the same expressive power, a calculus increases,
        in our opinion, the readability of relational expressions because they
        allow the introduction of variables to express intermediate
        results.</para>
      </listitem>

      <listitem>
        <para>We integrate an equation solver in a relational language. In
        this way dataflow problems can be expressed.</para>
      </listitem>

      <listitem>
        <para>We introduce an <emphasis>location</emphasis> datatype with
        associated operations to easily manipulate references to source
        code.</para>
      </listitem>

      <listitem>
        <para>There is some innovation in syntactic notation and specific
        built-in functions.</para>
      </listitem>

      <listitem>
        <para>We introduce the notion of an Rstore that generalizes the RSF
        tuple format of Rigi. An Rstore consists of name/value pairs, where
        the values may be arbitrary nested bags or relations. An Rstore is a
        language-independent exchange format and can be used to exchange
        complex relational data between programs written in different
        languages.</para>

        <para></para>

        <!--\section{Background}


\paragraph{Relation-oriented Languages}
There is a long tradition in Computer Science to organize languages around one
a more prominent data types such as lists (Lisp), strings (SNOBOL), arrays
(APL) or sets (SETL).  We use sets and relations as primary datatypes and the
sets and set formers in SETL~\cite{SETL} are the best historic reference for
them. Set formers have later on be popularized in various functional languages
since they were introduced in KRC~\cite{Turner82}.  An overview of languages
centered around collection types such as sets and bags is given in
~\cite{Tannen94}.  Database languages in general and SQL in particular are
described in~\cite{Ullman82}.  The connection between comprehensions and
relational algebra is described in~\cite{WadlerLists87,Trinder89}. A further
analysis of this topic is given in~\cite{Buneman94}.

Systems supporting relational programming include RELVIEW~\cite{RELVIEW98}
(intended for the interactive creation and visualization of relations
and the prototyping of graph algorithms), ...

\paragraph{Relations and Program Analysis}

The idea to represent relational views of programs is already quite old.  For
instance, in~\cite{Linton84} all syntactic as well as semantic aspects of a
program were represented by relations and SQL was used to query them. Due to
the lack of expressiveness of SQL (notably the lack of transitive closures)
and the performance problems encountered, this approach has not seen wider
use.  In Rigi~\cite{Mueller88}, a tuple format (RSF) is introduced to
represent relations and a language (RCL) to manipulate them.
In~\cite{PaulPrakash94} a \emph{source code algebra} is described that can be
used to express relational queries on source text.  In~\cite{BKV96b} a
\emph{query algebra} is formulated to express direct queries on the syntax
tree. It also allows the querying of information that is attached to the
syntax tree via annotations.  Relational algebra is used in GROK~\cite{Holt96}
and Relation Partition Algebra
(RPA)~\cite{FeijsKrikhaarOmmering98,Feijs99,Krikhaar99} to represent basic
facts about software systems and to query them.  In GUPRO~\cite{GUPRO98}
graphs are used to represent programs and to query them. In
F(p) $\ell$~\cite{CanforRaEtAl99} a Prolog database and a special-purpose
language are used to represent and query program facts.

The requirements for a query language for reverse engineering are discussed
in~\cite{holt-towards}.



\section{Plan for this Tutorial}

In Chapter~\ref{SEC:motivating-example} we first provide a motivating example
of our relational approach.
In Chapter~\ref{SEC:rscript-language} follows a complete description
of all the features in \rscript.
In the following Chapters~\ref{SEC:operators} and \ref{SEC:functions}
all built-in operators and functions are described.
The most interesting part of this tutorial is probably
Chapter~\ref{SEC:larger-examples} where we present a menagerie of larger
examples ranging from computing the McCabe complexity of code, analyzing the
component structure of systems, to program slicing.
Chapter~\ref{SEC:running-rscript} describes how to run an \rscript.
Two appendices complete this tutorial:
Appendix~\ref{AP:operators} summarizes all built-in operators
and Appendix~\ref{AP:functions} summarizes all built-in functions.-->
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="section.motivating-example">
    <title>A Motivating Example</title>

    <para>Suppose a mystery box ends up on your desk. When you open it, it
    contains a huge software system with several questions attached to
    it:</para>

    <itemizedlist>
      <listitem>
        <para>How many procedure calls occur in this system?</para>
      </listitem>

      <listitem>
        <para>How many procedures contains it?</para>
      </listitem>

      <listitem>
        <para>What are the entry points for this system, i.e., procedures that
        call others but are not called themselves?</para>
      </listitem>

      <listitem>
        <para>What are the leaves of this application, i.e., procedures that
        are called but do not make any calls themselves?</para>
      </listitem>

      <listitem>
        <para>Which procedures call each other indirectly?</para>
      </listitem>

      <listitem>
        <para>Which procedures are called directly or indirectly from each
        entry point?</para>
      </listitem>

      <listitem>
        <para>Which procedures are called from all entry points?</para>
      </listitem>
    </itemizedlist>

    <para>There are now two possibilities. Either you have this superb
    programming environment or tool suite that can immediately answer all
    these questions for you or you can use Rscript.</para>

    <section>
      <title>Preparations</title>

      <para>To illustrate this process consider the workflow in <xref
      linkend="figure.calls-workflow" />. First we have to extract the calls
      from the source code. Recall that Rscript does not consider fact
      extraction <emphasis>per se</emphasis> so we assume that this call graph
      has been extracted from the software by some other tool. Also keep in
      mind that a real call graph of a real application will contain thousands
      and thousands of calls. Drawing it in the way we do later on in <xref
      linkend="figure.calls" /> makes no sense since we get a uniformly black
      picture due to all the call dependencies. After the extraction phase, we
      try to understand the extracted facts by writing queries to explore
      their properties. For instance, we may want to know <emphasis>how many
      calls</emphasis> there are, or <emphasis>how many procedures</emphasis>.
      We may also want to enrich these facts, for instance, by computing who
      calls who in more than one step. Finally, we produce a simple textual
      report giving answers to the questions we are interested in.<figure
          xml:id="figure.calls-workflow">
          <title>Workflow for analyzing mystery box</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="calls-workflow.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>

          <para>Now consider the call graph shown in <xref
          linkend="figure.calls" />. This section is intended to give you a
          first impression what can be done with Rscript. Please return to
          this example when you have digested the detailed description of
          Rscript in <xref linkend="section.rscipt-language" />, <xref
          linkend="section.operators" /> and <xref
          linkend="section.functions" />.</para>
        </figure><figure xml:id="figure.calls">
          <title>Graphical representation of the <literal>calls</literal>
          relation</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="calls.png" scale="50"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Rscript supports some basic data types like integers and strings
      which are sufficient to formulate and answer the questions at hand.
      However, we can gain readability by introducing separately named types
      for the items we are describing. First, we introduce therefore a new
      type <literal>proc</literal> (an alias for strings) to denote
      procedures:</para>

      <programlisting>type proc = str</programlisting>

      <para>Suppose that the following facts have been extracted from the
      source code and are represented by the relation
      <literal>Calls</literal>:</para>

      <programlisting>rel[proc , proc] Calls = 
   { &lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, &lt;"d", "c"&gt;, &lt;"d","e"&gt;, 
     &lt;"f", "e"&gt;, &lt;"f", "g"&gt;, &lt;"g", "e"&gt;
   }</programlisting>

      <para>This concludes the preparatory steps and now we move on to answer
      the questions.</para>
    </section>

    <section>
      <title>Questions</title>

      <section>
        <title>How many procedure calls occur in this system?</title>

        <para>To determine the numbers of calls, we simply determine the
        number of tuples in the <literal>Calls</literal> relation, as
        follows:</para>

        <para><programlisting>int nCalls = # Calls</programlisting>The
        operator <literal>#</literal> determines the number of elements in a
        set or relation and is explained in <xref
        linkend="section.builtin-operator-misc" />. In this example,
        <literal>nCalls</literal> will get the value
        <literal>8</literal>.</para>
      </section>

      <section>
        <title>How many procedures contains it?</title>

        <para>We get the number of procedures by determining which names occur
        in the tuples in the relation <literal>Calls</literal> and then
        determining the number of names:</para>

        <programlisting>set[proc] procs = carrier(Calls)
int nprocs = # procs</programlisting>

        <para>The built-in function <literal>carrier</literal> determines all
        the values that occur in the tuples of a relation. In this case,
        <literal>procs</literal> will get the value <literal>{"a", "b", "c",
        "d", "e", "f", "g"}</literal> and <literal>nprocs</literal> will thus
        get value <literal>7</literal>. A more concise way of expressing this
        would be to combine both steps:</para>

        <programlisting>int nprocs = # carrier(Calls)</programlisting>
      </section>

      <section>
        <title>What are the entry points for this system?</title>

        <para>The next step in the analysis is to determine which
        <emphasis>entry points</emphasis> this application has, i.e.,
        procedures which call others but are not called themselves. Entry
        points are useful since they define the external interface of a system
        and may also be used as guidance to split a system in parts. The
        <literal>top</literal> of a relation contains those left-hand sides of
        tuples in a relation that do not occur in any right-hand side. When a
        relation is viewed as a graph, its top corresponds to the root nodes
        of that graph. Similarly, the <literal>bottom</literal> of a relation
        corresponds to the leaf nodes of the graph. See <xref
        linkend="section.builtin-function-bottom" /> for more details. Using
        this knowledge, the entry points can be computed by determining the
        top of the <literal>Calls</literal> relation:</para>

        <programlisting>set[proc] entryPoints = top(Calls)</programlisting>

        <para>In this case, <literal>entryPoints</literal> is equal to
        <literal>{"a", "f"}</literal>. In other words, procedures
        <literal>"a"</literal> and <literal>"f"</literal> are the entry points
        of this application.</para>
      </section>

      <section>
        <title>What are the leaves of this application?</title>

        <para>In a similar spirit, we can determine the
        <emphasis>leaves</emphasis> of this application, i.e., procedures that
        are being called but do not make any calls themselves:</para>

        <programlisting>set[proc] bottomCalls = bottom(Calls)</programlisting>

        <para>In this case, <literal>bottomCalls</literal> is equal to
        <literal>{"c", "e"}</literal>.</para>
      </section>

      <section>
        <title>Which procedures call each other indirectly?</title>

        <para>We can also determine the <emphasis>indirect calls</emphasis>
        between procedures, by taking the transitive closure of the
        <literal>Calls</literal> relation:</para>

        <programlisting>rel[proc, proc] closureCalls = Calls+</programlisting>

        <para>In this case, <literal>closureCalls</literal> is equal to</para>

        <programlisting>{&lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, &lt;"d", "c"&gt;, &lt;"d","e"&gt;, 
 &lt;"f", "e"&gt;, &lt;"f", "g"&gt;, &lt;"g", "e"&gt;, &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, 
 &lt;"b", "e"&gt;, &lt;"a", "e"&gt;
}</programlisting>
      </section>

      <section>
        <title>Which procedures are called directly or indirectly from each
        entry point?</title>

        <para>We know now the entry points for this application (<literal>"a"
        </literal>and <literal>"f"</literal>) and the indirect call relations.
        Combining this information, we can determine which procedures are
        called from each entry point. This is done by taking the
        <emphasis>right image</emphasis> of <literal>closureCalls</literal>.
        The right image operator determines yields all right-hand sides of
        tuples that have a given value as left-hand side:</para>

        <programlisting>set[proc] calledFromA = closureCalls["a"]</programlisting>

        <para>yields <literal>{"b", "c", "d", "e"}</literal> and</para>

        <programlisting>set[proc] calledFromF = closureCalls["f"]</programlisting>

        <para>yields <literal>{"e", "g"}</literal>.</para>
      </section>

      <section>
        <title>Which procedures are called from all entry points?</title>

        <para>Finally, we can determine which procedures are called from both
        entry points by taking the intersection of the two sets
        <literal>calledFromA</literal> and
        <literal>calledFromF</literal></para>

        <para><programlisting>set[proc] commonProcs = calledFromA inter calledFromF</programlisting></para>

        <para>which yields <literal>{"e"}</literal>. In other words, the
        procedures called from both entry points are mostly disjoint except
        for the common procedure <literal>"e"</literal>.</para>
      </section>

      <section>
        <title>Wrap-up</title>

        <para>These findings can be verified by inspecting a graph view of the
        calls relation as shown in <xref linkend="figure.calls" />. Such a
        visual inspection does <emphasis>not</emphasis> scale very well to
        large graphs and this makes the above form of analysis particularly
        suited for studying large systems.</para>
      </section>
    </section>
  </section>

  <section xml:id="section.rscipt-language">
    <title>The Rscript Language</title>

    <para>Rscript is based on <emphasis>binary relations</emphasis> only and
    has no direct support for <replaceable>n</replaceable>-ary relations with
    labeled columns as usual in a general database language. However, some
    syntactic support for <replaceable>n</replaceable>-ary relations exists.
    We will explain this further below. An Rscript consists of a sequence of
    declarations for variables and/or functions. Usually, the value of one of
    these variables is what the writer of the script is interested in. The
    language has scalar types (Boolean, integer, string, location) and
    composite types (set and relation). Expressions are constructed from
    comprehensions, function invocations and operators. These are all
    described below.}</para>

    <section xml:id="section.types-and-values">
      <title>Types and Values</title>

      <section xml:id="section.elementary-types">
        <title>Elementary Types and Values</title>

        <formalpara>
          <title>Booleans</title>

          <para>The Booleans are represented by the type
          <literal>bool</literal> and have two values: <literal>true</literal>
          and <literal>false</literal>.</para>
        </formalpara>

        <formalpara>
          <title>Integers</title>

          <para>The integer values are represented by the type
          <literal>int</literal> and are written as usual, e.g.,
          <literal>0</literal>, <literal>1</literal>, or
          <literal>123</literal>.</para>
        </formalpara>

        <formalpara>
          <title>Strings</title>

          <para>The string values are represented by the type
          <literal>str</literal> and consist of character sequences surrounded
          by double quotes. e.g., <literal>"a"</literal> or <literal>"a\ long\
          string"</literal>.</para>
        </formalpara>

        <formalpara>
          <title>Locations</title>

          <para>Location values are represented by the type
          <literal>loc</literal> and serve as text coordinates in a specific
          source file. They should <emphasis>always</emphasis> be generated
          automatically but for the curious here is an example how they look
          like: <literal>area-in-file("/home/paulk/example.pico", area(6, 17,
          6, 18, 131, 1))</literal>.</para>
        </formalpara>
      </section>
    </section>

    <section>
      <title>Tuples, Sets and relations</title>

      <formalpara>
        <title>Tuples</title>

        <para>Tuples are represented by the type
        <literal>&lt;</literal><replaceable>T</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>T</replaceable><subscript>2</subscript><literal>&gt;</literal>,
        where <replaceable>T</replaceable><subscript>1</subscript> and
        <replaceable>T</replaceable><subscript>2</subscript> are arbitrary
        types. An example of a tuple type is <literal>&lt;int,
        str&gt;</literal>. Rscript directly supports tuples consisting of two
        elements (also know as <emphasis>pairs</emphasis>). For convenience,
        <replaceable>n</replaceable>-ary tuples are also allowed, but there
        are some restrictions on their use, see the paragraph Relations below.
        Examples are:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>&lt;1, 2&gt;</literal> is of type <literal>&lt;int,
          int&gt;</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>&lt;1, 2, 3&gt;</literal> is of type
          <literal>&lt;int, int, int&gt;</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>&lt;1, "a", 3&gt;</literal> is of type
          <literal>&lt;int, str, int&gt;</literal>,</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Sets</title>

        <para>Sets are represented by the type
        <literal>set[</literal><replaceable>T</replaceable><literal>]</literal>,
        where <replaceable>T</replaceable> is an arbitrary type. Examples are
        <literal>set[int]</literal>, <literal>set[&lt;int,int&gt;]</literal>
        and <literal>set[set[str]]</literal>. Sets are denoted by a list of
        elements, separated by comma's and enclosed in braces as in
        <literal>{</literal><replaceable>E</replaceable><subscript>1</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>2</subscript><literal>,
        ...,</literal>
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript><literal>}</literal>,
        where the
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript>
        (1 &lt;= <replaceable>i </replaceable>&lt;=
        <replaceable>n</replaceable>) are expressions that yield the desired
        element type. For example,</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>{1, 2, 3}</literal> is of type
          <literal>set[int]</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}</literal>
          is of type <literal>set[&lt;int,int&gt;]</literal>,</para>
        </listitem>

        <listitem>
          <para><literal>{&lt;"a",10&gt;, &lt;"b",20&gt;,
          &lt;"c",30&gt;}</literal> is of type
          <literal>set[&lt;str,int&gt;]</literal>, and</para>
        </listitem>

        <listitem>
          <para><literal>{{"a", "b"}, {"c", "d", "e"}}</literal> is of type
          <literal>set[set[str]]</literal>.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Relations</title>

        <para>Relations are nothing more than sets of tuples, but since they
        are used so often we provide some shorthand notation for them.
        Relations are represented by the type
        <literal>rel[<replaceable>T</replaceable><subscript>1</subscript>,<replaceable>T</replaceable><subscript>2</subscript>]</literal>,
        where
        <replaceable><replaceable>T</replaceable><subscript>1</subscript></replaceable>
        and <replaceable>T</replaceable><subscript>2</subscript> are arbitrary
        types; it is a shorthand for
        <literal>set[&lt;<replaceable>T</replaceable><subscript>1</subscript>,
        <replaceable>T</replaceable><subscript>2</subscript>&gt;]</literal>.
        Examples are <literal>rel[int,str]</literal> and
        <literal>rel[int,set[str]]</literal>. Relations are denoted by
        <literal>{&lt;</literal><replaceable>E</replaceable><subscript>11</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript>12</subscript><literal>&gt;,
        &lt;</literal><replaceable>E</replaceable><subscript>21</subscript>,
        <replaceable>E</replaceable><subscript>22</subscript><literal>&gt;,
        ...,
        &lt;</literal><replaceable>E</replaceable><subscript><replaceable>n</replaceable>1</subscript><literal>,</literal>
        <replaceable>E</replaceable><subscript><replaceable>n</replaceable>2</subscript><literal>&gt;}</literal>,
        where the
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable><replaceable>j</replaceable></subscript>
        are expressions that yield the desired element type. For example,
        <literal>{&lt;1, "a"&gt;, &lt;2, "b"&gt;, &lt;3,"c"&gt;}</literal> is
        of type <literal>rel[int, str]</literal>. Not surprisingly,
        <replaceable>n</replaceable>-ary relations are represented by the type
        <literal>rel[<replaceable>T</replaceable><subscript>1</subscript>,
        <replaceable>T</replaceable><subscript>2</subscript>, ...,
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>]</literal>
        which is a shorthand for
        <literal>set[&lt;<replaceable>T</replaceable><subscript>1</subscript>,
        <replaceable>T</replaceable><subscript>2</subscript>, ...,
        <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript>&gt;]</literal>.
        Most built-in operators and functions require binary relations as
        arguments. It is, however, perfectly possible to use
        <replaceable>n</replaceable>-ary relations as values, or as arguments
        or results of functions. Examples are:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;}</literal>
          is of type <literal>rel[int,int]</literal> (yes indeed, you saw this
          same example before and then we gave
          <literal>set[&lt;int,int&gt;]</literal> as its type; remember that
          these types are interchangeable.),</para>
        </listitem>

        <listitem>
          <para><literal>{&lt;"a",10&gt;, &lt;"b",20&gt;,
          &lt;"c",30&gt;}</literal> is of type
          <literal>rel[str,int]</literal>, and</para>
        </listitem>

        <listitem>
          <para><literal>{{"a", 1, "b"}, {"c", 2, "d"}}</literal> is of type
          <literal>rel[str,int,str]</literal>.</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>User-defined Types and Values</title>

        <formalpara>
          <title>Alias types</title>

          <para>Everything can be expressed using the elementary types and
          values that are provided by Rscript. However, for the purpose of
          documentation and readability it is sometimes better to use a
          descriptive name as type indication, rather than an elementary type.
          The type declaration</para>
        </formalpara>

        <programlisting>type <replaceable>T</replaceable><subscript>1</subscript> = <replaceable>T</replaceable><subscript>2</subscript></programlisting>

        <para>states that the new type name
        <replaceable>T</replaceable><subscript>1</subscript> can be used
        everywhere instead of the already defined type name
        <replaceable>T</replaceable><subscript>2</subscript>. For
        instance,</para>

        <programlisting>type ModuleId = str
type Frequency = int</programlisting>

        <para>introduces two new type names <literal>ModuleId</literal> and
        <literal>Frequency</literal>, both an alias for the type
        <literal>str</literal>. The use of type aliases is a good way to hide
        representation details.</para>

        <formalpara>
          <title>Composite Types and Values</title>

          <para>In ordinary programming languages record types or classes
          exist to introduce a new type name for a collection of related,
          named, values and to provide access to the elements of such a
          collection through their name. In Rscript, tuples with named
          elements provide this facility. The type declaration</para>
        </formalpara>

        <programlisting>type T = &lt;<replaceable>T</replaceable><subscript>1</subscript> <replaceable>F</replaceable><subscript>1</subscript> ,..., <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript> <replaceable>F</replaceable><subscript><replaceable>n</replaceable></subscript>&gt;</programlisting>

        <para>introduces a new composite type <replaceable>T</replaceable>,
        with <replaceable>n</replaceable> elements. The
        <replaceable>i</replaceable>-th
        element<replaceable>T</replaceable><subscript><replaceable>i</replaceable></subscript>
        <replaceable>F</replaceable><subscript><replaceable>i</replaceable></subscript>
        has type
        <replaceable>T</replaceable><subscript><replaceable>i</replaceable></subscript>
        and field name
        <replaceable>F</replaceable><subscript><replaceable>i</replaceable></subscript>.
        The common dot notation for field access is used to address an element
        of a composite type. If <replaceable>V</replaceable> is a variable of
        type <replaceable>T</replaceable>, then the
        <replaceable>i</replaceable>-th element can be accessed by
        <replaceable>V</replaceable><literal>.</literal><replaceable>F</replaceable><subscript><replaceable>i</replaceable></subscript>.
        For instance,\footnote{The variable declarations that appear on lines
        2 and 3 of this example are explained fully in <xref
        linkend="section.declarations" />.</para>

        <programlisting>type Triple = &lt;int left, str middle, bool right&gt;
Triple TR = &lt;3, "a", true&gt;
str S = TR.middle</programlisting>

        <para>first introduces the composite type <literal>Triple</literal>
        and defines the <literal>Triple</literal> variable
        <literal>TR</literal>. Next, the field selection
        <literal>TR.middle</literal> is used to define the string
        <literal>S</literal>.</para>

        <formalpara>
          <title>Implementation Note</title>

          <para>The current implementation severely restricts the re-use of
          field names in different type declarations. The only re-use that is
          allowed are fields with the same name and the same type that appear
          at the same position in different type declarations.</para>
        </formalpara>

        <formalpara>
          <title>Type Equivalence</title>

          <para>An Rscript should be <emphasis>well-typed</emphasis>, this
          means above all that identifiers that are used in expressions have
          been declared, and that operations and functions should have
          operands of the required type. We use <emphasis>structural
          equivalence</emphasis> between types as criterion for type equality.
          The equivalence of two types
          <replaceable>T</replaceable><subscript>1</subscript> and
          <replaceable>T</replaceable><subscript>2</subscript> can be
          determined as follows:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>Replace in both
            <replaceable>T</replaceable><subscript>1</subscript> and
            <replaceable>T</replaceable><subscript>2</subscript> all
            user-defined types by their definition until all user-defined
            types have been eliminated. This may require repeated
            replacements. This gives, respectively,
            <replaceable>T</replaceable><subscript>1</subscript>' and
            <replaceable>T</replaceable><subscript>2</subscript>'.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>T</replaceable><subscript>1</subscript>' and
            <replaceable>T</replaceable><subscript>2</subscript>' are
            identical, then
            <replaceable>T</replaceable><subscript>1</subscript> and
            <replaceable>T</replaceable><subscript>2</subscript> are
            equal.</para>
          </listitem>

          <listitem>
            <para>Otherwise
            <replaceable>T</replaceable><subscript>1</subscript> and
            <replaceable>T</replaceable><subscript>2</subscript> are not
            equal.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Comprehensions</title>

      <para>We will use the familiar notation<programlisting>{<replaceable>E</replaceable><subscript>1</subscript>, ..., <replaceable>E</replaceable><subscript><replaceable>m</replaceable></subscript> | <replaceable>G</replaceable><subscript>1</subscript>, ..., <replaceable>G</replaceable><subscript><replaceable>n</replaceable></subscript>}</programlisting></para>

      <para>to denote the construction of a set consisting of the union of
      successive values of the expressions
      <replaceable>E</replaceable><subscript>1</subscript> ,...,
      <replaceable>E</replaceable><subscript><replaceable>m</replaceable></subscript>.
      The values and the generated set are determined by
      <replaceable>E</replaceable><subscript>1</subscript> ,...,
      <replaceable>E</replaceable><subscript><replaceable>m</replaceable></subscript>
      and the <emphasis>generators</emphasis>
      <replaceable>G</replaceable><subscript>1</subscript> ,...,
      <replaceable>G</replaceable><subscript><replaceable>n</replaceable></subscript>.
      <replaceable>E</replaceable> is computed for all possible combinations
      of values produced by the generators. Each generator may introduce new
      variables that can be used in subsequent generators as well as in the
      expressions <replaceable>E</replaceable><subscript>1</subscript> ,...,
      <replaceable>E</replaceable><subscript><replaceable>m</replaceable></subscript>.
      A generator can use the variables introduced by preceding generators.
      Generators may enumerate all the values in a set or relation, they may
      perform a test, or they may assign a value to variables.</para>

      <section>
        <title>Generators</title>

        <formalpara>
          <title>Enumerator</title>

          <para>Enumerators generate all the values in a given set or
          relation. They come in two flavors:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para><replaceable>T</replaceable> <replaceable>V</replaceable>
            <literal>:</literal> <replaceable>E</replaceable>: the elements of
            the set <replaceable>S</replaceable> (of type
            <literal>set[<replaceable>T</replaceable>]</literal>) that results
            from the evaluation of expression <replaceable>E</replaceable> are
            enumerated and subsequently assigned to the new variable
            <replaceable>V</replaceable> of type <replaceable>T</replaceable>.
            Examples are:</para>

            <itemizedlist>
              <listitem>
                <para><literal>int N : {1, 2, 3, 4, 5}</literal>,</para>
              </listitem>

              <listitem>
                <para><literal>str K : KEYWORDS</literal>, where
                <literal>KEYWORDS</literal> should evaluate to a value of
                <literal>set[str]</literal>.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><literal>&lt;<replaceable>D</replaceable><subscript>1</subscript>,
            ...,
            <replaceable>D</replaceable><subscript><replaceable>n</replaceable></subscript>&gt;
            : <replaceable>E</replaceable></literal>: the elements of the
            relation <replaceable>R</replaceable> (of type
            <literal>rel</literal>[<replaceable>T</replaceable>'<subscript>1</subscript>,...,<replaceable>T</replaceable>'<subscript><replaceable>n</replaceable></subscript>],
            where
            <replaceable>T</replaceable>'<subscript><replaceable>i</replaceable></subscript>
            is determined by the type of each target
            <replaceable>D</replaceable><subscript><replaceable>i</replaceable></subscript>,
            see below) that results from the evaluation of expression
            <replaceable>E</replaceable> are enumerated. The
            <replaceable>i</replaceable>-the element
            (<replaceable>i</replaceable>=1,...,<replaceable>n</replaceable>)
            of the resulting <replaceable>n</replaceable>-tuple is
            subsequently combined with each target
            <replaceable>D</replaceable><subscript><replaceable>i</replaceable></subscript>
            as follows:</para>

            <itemizedlist>
              <listitem>
                <para>If
                <replaceable>D</replaceable><subscript><replaceable>i</replaceable></subscript>
                is a variable declaration of the form
                <replaceable>T</replaceable><subscript><replaceable>i</replaceable></subscript>
                <replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript>,
                then the <replaceable>i</replaceable>-th element is assigned
                to
                <replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript>.</para>
              </listitem>

              <listitem>
                <para>If
                <replaceable>D</replaceable><subscript><replaceable>i</replaceable></subscript>
                is an arbitrary expression
                <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>,
                then the value of the <replaceable>i</replaceable>-th element
                should be equal to the value of
                <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>.
                If they are unequal, computation continues with enumerating
                the next tuple in the relation
                <replaceable>R</replaceable>.</para>
              </listitem>
            </itemizedlist>

            <para>Examples are:</para>

            <itemizedlist>
              <listitem>
                <para><literal>&lt;str K, int N&gt; : {&lt;"a",10&gt;,
                &lt;"b",20&gt;, &lt;"c",30&gt;}</literal>.</para>
              </listitem>

              <listitem>
                <para><literal>&lt;str K, int N&gt; : FREQUENCIES</literal>,
                where <literal>FREQUENCIES</literal> should evaluate to a
                value of type <literal>rel[str,int]</literal>.</para>
              </listitem>

              <listitem>
                <para><literal>&lt;str K, 10&gt; : FREQUENCIES</literal>, will
                only generate pairs with <literal>10</literal> as second
                element.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <formalpara>
          <title>Test</title>

          <para>A test is a boolean-valued expression. If the evaluation
          yields <literal>true</literal> this indicates that the current
          combination of generated values up to this test is still as desired
          and execution continues with subsequent generators. If the
          evaluation yields <literal>false</literal> this indicates that the
          current combination of values is undesired, and that another
          combination should be tried. Examples:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para><literal>N &gt;= 3</literal> tests whether
            <literal>N</literal> has a value greater than or equal
            <literal>3</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>S == "coffee"</literal> tests whether
            <literal>S</literal> is equal to the string
            <literal>"coffee"</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>In both examples, the variable (<literal>N</literal>,
        respectively, <literal>S</literal>) should have been introduced by a
        generator that occurs earlier in the enclosing comprehension.</para>

        <formalpara>
          <title>Assignment</title>

          <para>Assignments assign a value to one or more variables and also
          come in two flavors:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para><literal><replaceable>T</replaceable>
            <replaceable>V</replaceable> &lt;-
            <replaceable>E</replaceable></literal>: assigns the value of
            expression <replaceable>E</replaceable> to the new variable
            <replaceable>V</replaceable> of type
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>&lt;<replaceable>R</replaceable><subscript>1</subscript>,
            ...,
            <replaceable>R</replaceable><subscript><replaceable>n</replaceable></subscript>&gt;
            &lt;- <replaceable>E</replaceable></literal>: combines the
            elements of the <replaceable>n</replaceable>-tuple resulting from
            the evaluation of expression <replaceable>E</replaceable> with
            each
            <replaceable>T</replaceable><subscript><replaceable>i</replaceable></subscript>
            as follows:</para>

            <itemizedlist>
              <listitem>
                <para>If
                <replaceable>R</replaceable><subscript><replaceable>i</replaceable></subscript>
                is a variable declaration of the form
                <literal><replaceable>T</replaceable><subscript><replaceable>i</replaceable></subscript>
                <replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript></literal>,
                then the <replaceable>i</replaceable>-th element is assigned
                to
                <literal><replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript></literal>.</para>
              </listitem>

              <listitem>
                <para>If
                <replaceable>R</replaceable><subscript><replaceable>i</replaceable></subscript>
                is an arbitrary expression
                <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>,
                then the value of the <replaceable>i</replaceable>-th element
                should be equal to the value of
                <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>.
                If they are unequal, the assignment acts as a test that fails
                (see above).</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>Examples of assignments are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>rel[str,str] ALLCALLS &lt;- CALLS+</literal>
            assigns the transitive closure of the relation
            <literal>CALLS</literal> to the variable
            <literal>ALLCALLS</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>bool Smaller &lt;- A &lt;= B</literal> assigns the
            result of the test <literal>A &lt;= B</literal> to the Boolean
            variable <literal>Smaller</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>&lt;int N, str S, 10&gt; &lt;- E</literal>
            evaluates expression <literal>E</literal> (which should yield a
            tuple of type <literal>&lt;int, str, int&gt;</literal>) and
            performs a tuple-wise assignment to the new variables
            <literal>N</literal> and <literal>S</literal>
            <emphasis>provided</emphasis> that the third element of the result
            is equal to <literal>10</literal>. Otherwise the assignment acts
            as a test that fails.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Examples of Comprehensions</title>

        <itemizedlist>
          <listitem>
            <para><literal>{X | int X : {1, 2, 3, 4, 5}, X &gt;= 3}</literal>
            yields the set <literal>{3,4,5}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{&lt;X, Y&gt; | int X : {1, 2, 3}, int Y : {2, 3,
            4}, X &gt;= Y}</literal> yields the relation <literal>{&lt;2,
            2&gt;, &lt;3, 2&gt;, &lt;3, 3&gt;}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{&lt;Y, X&gt; | &lt;int X, int Y&gt; :
            {&lt;1,10&gt;, &lt;2,20&gt;}}</literal> yields the inverse of the
            given relation: <literal>{&lt;10,1&gt;,
            &lt;20,2&gt;}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{X, X * X | X : {1, 2, 3, 4, 5}, X &gt;=
            3}</literal> yields the set
            <literal>{3,4,5,9,16,25}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="section.declarations">
      <title>Declarations</title>

      <section>
        <title>Variable Declarations</title>

        <para>A variable declaration has the form<programlisting><replaceable>T</replaceable> <replaceable>V</replaceable> = <replaceable>E</replaceable></programlisting>
        where <replaceable>T</replaceable> is a type,
        <replaceable>V</replaceable> is a variable name, and
        <replaceable>E</replaceable> is an expression that should have type
        <replaceable>T</replaceable>. The effect is that the value of
        expression <replaceable>E</replaceable> is assigned to
        <replaceable>V</replaceable> and can be used later on as
        <replaceable>V</replaceable>'s value. Double declarations are not
        allowed. As a convenience, also declarations without an initialization
        expression are permitted and have the form <programlisting><replaceable>T</replaceable> <replaceable>V</replaceable> </programlisting>and
        only introduce the variable <replaceable>V</replaceable>.
        Examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>int max = 100</literal> declares the integer
            variable <literal>max</literal> with value
            <literal>100</literal>.</para>
          </listitem>

          <listitem>
            <para>The definition<programlisting>rel[str,int] day = {&lt;"mon", 1&gt;, &lt;"tue", 2&gt;, &lt;"wed",3&gt;, 
                    &lt;"thu", 4&gt;, &lt;"fri", 5&gt;, &lt;"sat",6&gt;, &lt;"sun",7&gt;}</programlisting>declares
            the variable <literal>day</literal>, a relation that maps strings
            to integers.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Local Variable Declarations</title>

        <para>Local variables can be introduced as follows:<programlisting><replaceable>E</replaceable> where <literal><replaceable>T</replaceable></literal><subscript>1</subscript> <replaceable>V</replaceable><subscript>1</subscript> = <replaceable>E</replaceable><subscript>1</subscript>, ..., <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript> <replaceable>V</replaceable><replaceable><subscript>n</subscript></replaceable> = <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript> end where</programlisting>First
        the local variables
        <replaceable>V</replaceable><replaceable><subscript>i</subscript></replaceable>
        are bound to their respective values
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>,
        and then the value of expression <replaceable>E </replaceable>is
        yielded.</para>
      </section>

      <section>
        <title>Function Declarations</title>

        <para>A function declaration has the form<programlisting><replaceable>T</replaceable> <replaceable>F</replaceable>(<literal><replaceable>T</replaceable></literal><subscript>1</subscript> <replaceable>V</replaceable><subscript>1</subscript>, ..., <replaceable>T</replaceable><subscript><replaceable>n</replaceable></subscript> <replaceable>V</replaceable><replaceable><subscript>n</subscript></replaceable>) = <replaceable>E</replaceable></programlisting>Here
        <replaceable>T</replaceable> is the result type of the function and
        this should be equal to the type of the associated expression
        <replaceable>E</replaceable>. Each
        <replaceable>T</replaceable><subscript><replaceable>i</replaceable></subscript>
        <replaceable>V</replaceable><replaceable><subscript>i</subscript></replaceable>
        represents a typed formal parameter of the function. The formal
        parameters may occur in <replaceable>E</replaceable> and get their
        value when <replaceable>F</replaceable> is invoked from another
        expression. Example:</para>

        <itemizedlist>
          <listitem>
            <para>The function declaration<programlisting>rel[int, int] invert(rel[int,int] R) = 
   {&lt;Y, X&gt; | &lt;int X, int Y&gt; : R }</programlisting>yields the
            inverse of the argument relation R. For instance,
            <literal>invert({&lt;1,10&gt;, &lt;2,20&gt;})</literal> yields
            <literal>{&lt;10,1&gt;, &lt;20,2&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>

        <formalpara>
          <title>Parameterized types in function declarations</title>

          <para>The types that occur in function declarations may also contain
          <emphasis>type variables</emphasis> that are written as
          <literal>&amp;</literal> followed by an identifier. In this way
          functions can be defined for arbitrary types. Examples:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>The declaration<programlisting>rel[&amp;T2, &amp;T1] invert2(rel[&amp;T1,&amp;T2] R) = 
   {&lt;Y, X&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R }</programlisting>yields
            an inversion function that is applicable to any binary relation.
            For instance,</para>

            <itemizedlist>
              <listitem>
                <para><literal>invert2({&lt;1,10&gt;, &lt;2,20&gt;})</literal>
                yields <literal>{&lt;10,1&gt;, &lt;20,2&gt;}</literal>,</para>
              </listitem>

              <listitem>
                <para><literal>invert2({&lt;"mon", 1&gt;, &lt;"tue",
                2&gt;})</literal> yields <literal>{&lt;1, "mon"&gt;, &lt;2,
                "tue"&gt;}</literal>.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>The function<programlisting>&lt;&amp;T2, &amp;T1&gt; swap(&amp;T1 A, &amp;T2 B) = &lt;B, A&gt;</programlisting>can
            be used to swap the elements of pairs of arbitrary types. For
            instance,</para>

            <itemizedlist>
              <listitem>
                <para><literal>swap(&lt;1, 2&gt;)</literal> yields
                <literal>&lt;2,1&gt;</literal> and</para>
              </listitem>

              <listitem>
                <para><literal>swap(&lt;"wed", 3&gt;)</literal> yields
                <literal>&lt;3, "wed"&gt;</literal>.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Assertions</title>

        <para>An assert statement may occur everywhere where a declaration is
        allowed. It has the form<programlisting>assert <replaceable>L</replaceable>: <replaceable>E</replaceable></programlisting>where
        <replaceable>L</replaceable> is a string that serves as a label for
        this assertion, and <replaceable>E</replaceable> is a boolean-value
        expression. During execution, a list of true and false assertions is
        maintained. When the script is executed as a <emphasis>test
        suite</emphasis> a summary of this information is shown to the user.
        When the script is executed in the standard fashion, the assert
        statement has no affect. Example:</para>

        <itemizedlist>
          <listitem>
            <para><programlisting>assert "Equality on Sets 1": {1, 2, 3, 1} == {3, 2, 1, 1}</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Equations</title>

        <para>It is also possible to define mutually dependent sets of
        equations:<programlisting>equations
       initial
          <literal><replaceable>T</replaceable></literal><subscript>1</subscript> <replaceable>V</replaceable><subscript>1</subscript> init <replaceable>I</replaceable><subscript>1</subscript>
          ...
          <literal><replaceable>T</replaceable></literal><subscript><replaceable>n</replaceable></subscript> <replaceable>V</replaceable><subscript><replaceable>n</replaceable></subscript> init <replaceable>I</replaceable><subscript><replaceable>n</replaceable></subscript>
       satisfy
          <replaceable>V</replaceable><subscript>1</subscript> = <replaceable>E</replaceable><subscript>1</subscript>
          ...
          <replaceable>V</replaceable><subscript><replaceable>n</replaceable></subscript> = <replaceable>E</replaceable><subscript><replaceable>n</replaceable></subscript>
end equations</programlisting></para>

        <para>In the <literal>initial</literal> section, the variables
        <replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript>
        are declared and initialized. In the <literal>satisfy</literal>
        section, the actual set of equations is given. The expressions
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>
        may refer to any of the variables
        <replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript>
        (and to any variables declared earlier). This set of equations is
        solved by evaluating the expressions
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>,
        assigning their value to the corresponding variables
        <replaceable>V</replaceable><subscript><replaceable>i</replaceable></subscript>,
        and repeating this as long as the value of one of the variables was
        changed. This is typically used for solving a set of dataflow
        equations. Example:</para>

        <itemizedlist>
          <listitem>
            <para>Although transitive closure is provided as a built-in
            operator, we can use equations to define the transitive closure of
            a relation. Recall that \[R+ = R \cup (R \circ R) \cup (R \circ R
            \circ R) \cup ... .\] This can be expressed as follows.<warning>
                <para>Fix expression.</para>
              </warning></para>

            <para><programlisting>rel[int,int] R =  {&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;}

equations
  initial
     rel[int,int] T init R
  satisfy
     T = T union (T o R)
end equations</programlisting></para>

            <para>The resulting value of <literal>T</literal> is as
            expected:<programlisting>{&lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, &lt;1, 3&gt;, &lt;2, 4&gt;, &lt;1, 4&gt;}</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section xml:id="section.operators">
    <title>Built-in Operators</title>

    <para>The built-in operators can be subdivided in several broad
    categories:</para>

    <itemizedlist>
      <listitem>
        <para>Operations on Booleans (<xref
        linkend="section.builtin-operator-bool" />): logical operators (
        <literal>and</literal>, <literal>or</literal>,
        <literal>implies</literal> and <literal>not</literal>).</para>
      </listitem>

      <listitem>
        <para>Operations on integers (<xref
        linkend="section.builtin-operator-int" />): arithmetic operators
        (<literal>+</literal>, <literal>-</literal>, <literal>*</literal>, and
        <literal>/</literal>) and comparison operators (<literal>==</literal>,
        <literal>!=</literal>, <literal>&lt;</literal>,
        <literal>&lt;=</literal>, <literal>&gt;</literal>, and
        <literal>&gt;=</literal>).</para>
      </listitem>

      <listitem>
        <para>Operations on strings (<xref
        linkend="section.builtin-operator-str" />): comparison operators
        (<literal>==</literal>, <literal>!=</literal>,
        <literal>&lt;</literal>, <literal>&lt;=</literal>,
        <literal>&gt;</literal>, and <literal>&gt;=</literal>).</para>
      </listitem>

      <listitem>
        <para>Operations on locations (<xref
        linkend="section.builtin-operator-loc" />). comparison operators
        (<literal>==</literal>, <literal>!=</literal>,
        <literal>&lt;</literal>, <literal>&lt;=</literal>,
        <literal>&gt;</literal>, and <literal>&gt;=</literal>).</para>
      </listitem>

      <listitem>
        <para>Operations on sets or relations (<xref
        linkend="section.builtin-operator-set-or-rel" />): membership tests
        (<literal>in</literal>, <literal>notin</literal>), comparison
        operators (<literal>==</literal>, <literal>!=</literal>,
        <literal>&lt;</literal>, <literal>&lt;=</literal>,
        <literal>&gt;</literal>, and <literal>&gt;=</literal>), and
        construction operators (<literal>union</literal>,
        <literal>inter</literal>, <literal>diff</literal>).</para>
      </listitem>

      <listitem>
        <para>Operations on relations (<xref
        linkend="section.builtin-operator-relations" />): composition
        (<literal>o</literal>), Cartesian product (<literal>x</literal>), left
        and right image operators, and transitive closures
        (<literal>+</literal>, <literal>*</literal>).</para>
      </listitem>
    </itemizedlist>

    <para>The following sections give detailed descriptions and examples of
    all built-in operators.</para>

    <section xml:id="section.builtin-operator-bool">
      <title>Operations on Booleans</title>

      <table>
        <title>Operations on Booleans</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

          <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>and</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments have the
              value true and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>and</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if either argument has the
              value true and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>bool</replaceable><subscript>1</subscript>
              <literal>implies</literal>
              <replaceable>bool</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>false</literal> if
              <replaceable>bool</replaceable><subscript>1</subscript> has the
              value <literal>true</literal> and
              <replaceable>bool</replaceable><subscript>2</subscript> has
              value <literal>false</literal>, and <literal>true</literal>
              otherwise</entry>
            </row>

            <row>
              <entry><literal>not</literal>
              <replaceable>bool</replaceable></entry>

              <entry>yields true if bool is false and true otherwise</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.builtin-operator-int">
      <title>Operations on Integers</title>

      <table>
        <title>Operations on Integers</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

          <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments are
              numerically equal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments are
              numerically unequal and <literal>false</literal>
              otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>int</replaceable><subscript>1</subscript> is
              numerically less than or equal to
              <replaceable>int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>int</replaceable><subscript>1</subscript> is
              numerically less than
              <replaceable>int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>int</replaceable><subscript>1</subscript> is
              numerically greater than or equal than
              <replaceable>int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>int</replaceable><subscript>1</subscript> is
              numerically greater than
              <replaceable>int</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>+</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields the arithmetic sum of
              <replaceable>int</replaceable><subscript>1</subscript> and
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>-</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields the arithmetic difference of
              <replaceable>int</replaceable><subscript>1</subscript> and
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>*</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields the arithmetic product of
              <replaceable>int</replaceable><subscript>1</subscript> and
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><replaceable>int</replaceable><subscript>1</subscript>
              <literal>/</literal>
              <replaceable>int</replaceable><subscript>2</subscript></entry>

              <entry>yields the arithmetic division of
              <replaceable>int</replaceable><subscript>1</subscript> and
              <replaceable>int</replaceable><subscript>2</subscript></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.builtin-operator-str">
      <title>Operations on Strings</title>

      <table>
        <title>Operations on Strings</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

          <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments are
              equal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments are
              unequal and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>str</replaceable><subscript>1</subscript> is
              lexicographically less than or equal to
              <replaceable>str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>str</replaceable><subscript>1</subscript> is
              lexicographically less than
              <replaceable>str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>str</replaceable><subscript>1</subscript> is
              lexicographically greater than or equal to
              <replaceable>str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>str</replaceable><subscript>1</subscript>
              <literal>&gt;</literal>
              <replaceable>str</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>str</replaceable><subscript>1</subscript> is
              lexicographically greater than
              <replaceable>str</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="section.builtin-operator-loc">
      <title>Operations on Locations</title>

      <table>
        <title>Operations on Locations</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

          <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>==</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments are
              identical and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>!=</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if both arguments are not
              identical and <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>&lt;=</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>loc</replaceable><subscript>1</subscript> is
              textually contained in or equal to
              <replaceable>loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>&lt;</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>loc</replaceable><subscript>1</subscript> is
              strictly textually contained in
              <replaceable>loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>loc</replaceable><subscript>1</subscript> is
              textually encloses or is equal to
              <replaceable>loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>

            <row>
              <entry><replaceable>loc</replaceable><subscript>1</subscript>
              <literal>&gt;=</literal>
              <replaceable>loc</replaceable><subscript>2</subscript></entry>

              <entry>yields <literal>true</literal> if
              <replaceable>loc</replaceable><subscript>1</subscript> is
              textually encloses
              <replaceable>loc</replaceable><subscript>2</subscript> and
              <literal>false</literal> otherwise</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <formalpara>
        <title>Examples</title>

        <para>In the following examples the offset and length part of a
        location are set to <literal>0</literal>; they are not used when
        determining the outcome of the comparison operators.</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>area-in-file("f", area(11, 1, 11, 9, 0, 0)) &lt;
          area-in-file("f", area(10, 2, 12, 8, 0, 0))</literal> yields
          <literal>true</literal>.</para>
        </listitem>

        <listitem>
          <para><literal>area-in-file("f", area(10, 3, 11, 7, 0,0)) &lt;
          area-in-file("f", area(10, 2, 11, 8, 0, 0))</literal> yields
          <literal>true</literal>.</para>
        </listitem>

        <listitem>
          <para><literal>area-in-file("f", area(10, 3, 11, 7, 0, 0)) &lt;
          area-in-file("g", area(10, 3, 11, 7, 0, 0))</literal> yields
          <literal>false</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.builtin-operator-set-or-rel">
      <title>Operations on Sets or Relations</title>

      <section xml:id="section.builtin-operator-member">
        <title>Membership Tests</title>

        <table>
          <title>Membership Tests</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

            <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>any</replaceable> <literal>in</literal>
                <replaceable>set</replaceable></entry>

                <entry>yields <literal>true</literal> if
                <replaceable>any</replaceable> occurs as element in
                <replaceable>set</replaceable> and <literal>false</literal>
                otherwise</entry>
              </row>

              <row>
                <entry><replaceable>any</replaceable> <literal>notin</literal>
                <replaceable>set</replaceable></entry>

                <entry>yields <literal>false</literal> if
                <replaceable>any</replaceable> occurs as element in
                <replaceable>set</replaceable> and <literal>false</literal>
                otherwise</entry>
              </row>

              <row>
                <entry><replaceable>tuple</replaceable> <literal>in</literal>
                <replaceable>rel</replaceable></entry>

                <entry>yields <literal>true</literal> if
                <replaceable>tuple</replaceable> occurs as element in
                <replaceable>rel</replaceable> and <literal>false</literal>
                otherwise</entry>
              </row>

              <row>
                <entry><replaceable>tuple</replaceable>
                <literal>notin</literal>
                <replaceable>rel</replaceable></entry>

                <entry>yields <literal>false</literal> if
                <replaceable>tuple</replaceable> occurs as element in
                <replaceable>rel</replaceable> and <literal>false</literal>
                otherwise</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <formalpara>
          <title>Examples</title>

          <para></para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para><literal>3 in {1, 2, 3}</literal> yields
            <literal>true</literal>.</para>
          </listitem>

          <listitem>
            <para>4 in {1, 2, 3} yields <literal>false</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>3 notin {1, 2, 3}</literal> yields
            <literal>false</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>4 notin {1, 2, 3}</literal> yields
            <literal>true</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>&lt;2,20&gt; in {&lt;1,10&gt;, &lt;2,20&gt;,
            &lt;3,30&gt;}</literal> yields <literal>true</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>&lt;4,40&gt; notin {&lt;1,10&gt;, &lt;2,20&gt;,
            &lt;3,30&gt;}</literal> yields <literal>true</literal>.</para>
          </listitem>
        </itemizedlist>

        <formalpara>
          <title>Note</title>

          <para>If the first argument of these operators has type
          <replaceable>T</replaceable>, then the second argument should have
          type <literal>set[<replaceable>T</replaceable>]</literal>.</para>
        </formalpara>
      </section>

      <section xml:id="section.builtin-operator-set-comp">
        <title>Comparisons</title>

        <para><table>
            <title>Comparisons</title>

            <tgroup cols="2">
              <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

              <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

              <thead>
                <row>
                  <entry>Operator</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><replaceable>set</replaceable><subscript>1</subscript>
                  <literal>==</literal>
                  <replaceable>set</replaceable><subscript>2</subscript></entry>

                  <entry>yields <literal>true</literal> if both arguments are
                  equal sets and <literal>false</literal> otherwise</entry>
                </row>

                <row>
                  <entry><replaceable>set</replaceable><subscript>1</subscript>
                  <literal>!=</literal>
                  <replaceable>set</replaceable><subscript>2</subscript></entry>

                  <entry>yields <literal>true</literal> if both arguments are
                  unequal sets and <literal>false</literal> otherwise</entry>
                </row>

                <row>
                  <entry><replaceable>set</replaceable><subscript>1</subscript>
                  <literal>&lt;=</literal>
                  <replaceable>set</replaceable><subscript>2</subscript></entry>

                  <entry>yields <literal>true</literal> if
                  <replaceable>set</replaceable><subscript>1</subscript> is a
                  subset of
                  <replaceable>set</replaceable><subscript>2</subscript> and
                  <literal>false</literal> otherwise</entry>
                </row>

                <row>
                  <entry><replaceable>set</replaceable><subscript>1</subscript>
                  <literal>&lt;</literal>
                  <replaceable>set</replaceable><subscript>2</subscript></entry>

                  <entry>yields <literal>true</literal> if
                  <replaceable>set</replaceable><subscript>1</subscript> is a
                  strict subset of
                  <replaceable>set</replaceable><subscript>2</subscript> and
                  <literal>false</literal> otherwise</entry>
                </row>

                <row>
                  <entry><replaceable>set</replaceable><subscript>1</subscript>
                  <literal>&gt;=</literal>
                  <replaceable>set</replaceable><subscript>2</subscript></entry>

                  <entry>yields <literal>true</literal> if
                  <replaceable>set</replaceable><subscript>1</subscript> is a
                  superset of
                  <replaceable>set</replaceable><subscript>2</subscript> and
                  <literal>false</literal> otherwise</entry>
                </row>

                <row>
                  <entry><replaceable>set</replaceable><subscript>1</subscript>
                  <literal>&gt;</literal>
                  <replaceable>set</replaceable><subscript>2</subscript></entry>

                  <entry>Yields <literal>true</literal> if
                  <replaceable>set</replaceable><subscript>1</subscript> is a
                  strict superset of
                  <replaceable>set</replaceable><subscript>2</subscript> and
                  <literal>false</literal> otherwise</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.builtin-operator-set-cons">
        <title>Construction</title>

        <para></para>

        <table>
          <title>Construction</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

            <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><replaceable>set</replaceable><subscript>1</subscript>
                <literal>union</literal>
                <replaceable>set</replaceable><subscript>2</subscript></entry>

                <entry>yields the set resulting from the union of the two
                arguments</entry>
              </row>

              <row>
                <entry><replaceable>set</replaceable><subscript>1</subscript>
                <literal>inter</literal>
                <replaceable>set</replaceable><subscript>2</subscript></entry>

                <entry>yields the set resulting from the intersection of the
                two arguments</entry>
              </row>

              <row>
                <entry><replaceable>set</replaceable><subscript>1</subscript>
                <literal>\</literal>
                <replaceable>set</replaceable><subscript>2</subscript></entry>

                <entry>yields the set resulting from the difference of the two
                arguments</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <formalpara>
          <title>Examples</title>

          <para></para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para><literal>{1, 2, 3} union {4, 5, 6}</literal> yields
            <literal>{1, 2, 3, 4, 5, 6}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{1, 2, 3} union {1, 2, 3}</literal> yields
            <literal>{1, 2, 3}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{1, 2, 3} union {4, 5, 6}</literal> yields
            <literal>{1, 2, 3, 4, 5, 6}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{1, 2, 3} inter {4, 5, 6}</literal> yields
            <literal>{ }</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{1, 2, 3} inter {1, 2, 3}</literal> yields
            <literal>{1, 2, 3}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{1, 2, 3, 4} \ {1, 2, 3}</literal> yields
            <literal>{4}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>{1, 2, 3} \ {4, 5, 6}</literal> yields <literal>{1,
            2, 3}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-operator-misc">
        <title>Miscellaneous</title>

        <table>
          <title>Miscellaneous</title>

          <tgroup cols="2">
            <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

            <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>#</literal>
                <replaceable>set</replaceable></entry>

                <entry>yields the number of elements in
                <replaceable>set</replaceable></entry>
              </row>

              <row>
                <entry><literal>#</literal>
                <replaceable>rel</replaceable></entry>

                <entry>yields the number of elements in
                <replaceable>rel</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <formalpara>
          <title>Examples</title>

          <para></para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para><literal>#{1, 2, 3}</literal> yields
            <literal>3</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>#{&lt;1,10&gt;, &lt;2,20&gt;,
            &lt;3,30&gt;}</literal> yields <literal>3</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="section.builtin-operator-relations">
      <title>Operations on Relations</title>

      <para></para>

      <table>
        <title>Operations on Relations</title>

        <tgroup cols="2">
          <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

          <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><replaceable>rel</replaceable><subscript>1</subscript>
              <literal>o</literal>
              <replaceable>rel</replaceable><subscript>2</subscript></entry>

              <entry>yields the relation resulting from the composition of the
              two arguments</entry>
            </row>

            <row>
              <entry><replaceable>set</replaceable><subscript>1</subscript>
              <literal>x</literal>
              <replaceable>set</replaceable><subscript>2</subscript></entry>

              <entry>yields the relation resulting from the Cartesian product
              of the two arguments</entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable> <literal>[-,</literal>
              <replaceable>set</replaceable> <literal>]</literal></entry>

              <entry>yields the left image of
              <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable> <literal>[-,</literal>
              <replaceable>elem</replaceable> <literal>]</literal></entry>

              <entry>yields the left image of
              <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable> <literal>[</literal>
              <replaceable>set</replaceable> <literal>, -]</literal></entry>

              <entry>yields the right image of
              <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable> <literal>[</literal>
              <replaceable>elem</replaceable> <literal>, -]</literal></entry>

              <entry>yields the right image of
              <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable> <literal>[</literal>
              <replaceable>elem</replaceable> <literal>]</literal></entry>

              <entry>yields the right image of
              <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable> <literal>[</literal>
              <replaceable>set</replaceable> <literal>]</literal></entry>

              <entry>yields the right image of
              <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable>
              <literal>+</literal></entry>

              <entry>yields the relation resulting from the transitive closure
              of <replaceable>rel</replaceable></entry>
            </row>

            <row>
              <entry><replaceable>rel</replaceable>
              <literal>*</literal></entry>

              <entry>yields the relation resulting from the reflexive
              transitive closure of <replaceable>rel</replaceable></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <formalpara>
        <title>Composition: <literal>o</literal></title>

        <para>The composition operator combines two relations and can be
        defined as follows:</para>
      </formalpara>

      <programlisting>rel[&amp;T1,&amp;T3] compose(rel[&amp;T1,&amp;T2] R1, rel[&amp;T2,&amp;T3] R2) =
   {&lt;V, Y&gt; | &lt;&amp;T1 V, &amp;T2 W&gt; : R1, &lt;&amp;T2 X, &amp;T3 Y&gt; : R2, W == X }</programlisting>

      <formalpara>
        <title>Example</title>

        <para></para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,15&gt;} o
          {&lt;10,100&gt;, &lt;20,200&gt;}</literal> yields
          <literal>{&lt;1,100&gt;, &lt;2,200&gt;}</literal>.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Carthesian product: <literal>x</literal></title>

        <para>The product operator combines two sets into a relation and can
        be defined as follows:<programlisting>rel[&amp;T1,&amp;T2] product(set[&amp;T1] S1, set[&amp;T2] S2) = 
   {&lt;V, W&gt; | &amp;T1 V : S1, &amp;T2 W : S2 }</programlisting></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para></para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>{1, 2, 3} x {9}</literal> yields <literal>{&lt;1,
          9&gt;, &lt;2, 9&gt;, &lt;3, 9&gt;}</literal>.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Left image: <literal>[-, ]</literal></title>

        <para>Taking the left image of a relation amounts to selecting some
        elements from the domain of a relation. The <emphasis>left</emphasis>
        image operator takes a relation and an element
        <replaceable>E</replaceable> and produces a set consisting of all
        elements
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>
        in the domain of the relation that occur in tuples of the form
        <literal>&lt;<replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>,
        <replaceable>E</replaceable>&gt;</literal>. It can be defined as
        follows:<programlisting>set[&amp;T1] left-image(rel[&amp;T1,&amp;T2] R, &amp;T2 E) = 
   { V | &lt;&amp;T1 V, &amp;T2 W&gt; : R, W == E }</programlisting></para>
      </formalpara>

      <para>The left image operator can be extended to take a set of elements
      as second element instead of a single element:<programlisting>set[&amp;T1] left-image(rel[&amp;T1,&amp;T2] R, set[&amp;T2] S) = 
   { V | &lt;&amp;T1 V, &amp;T2 W&gt; : R, W in S }</programlisting></para>

      <formalpara>
        <title>Examples</title>

        <para>Assume that <literal>Rel</literal> has value
        <literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;1,11&gt;, &lt;3,30&gt;,
        &lt;2,21&gt;}</literal> in the following examples.</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>Rel[-,10]</literal> yields
          <literal>{1}</literal>.</para>
        </listitem>

        <listitem>
          <para><literal>Rel[-,{10}]</literal> yields
          <literal>{1}</literal>.</para>
        </listitem>

        <listitem>
          <para><literal>Rel[-,{10, 20}]</literal> yields <literal>{1,
          2}</literal>.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Right image: <literal>[ ]</literal> and <literal>[
        ,-]</literal></title>

        <para>Taking the right image of a relation amounts to selecting some
        elements from the range of a relation. The <emphasis>right</emphasis>
        image operator takes a relation and an element
        <replaceable>E</replaceable> and produces a set consisting of all
        elements
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>
        in the range of the relation that occur in tuples of the form
        <literal>&lt;<replaceable>E</replaceable>,
        <replaceable>E</replaceable><subscript><replaceable>i</replaceable></subscript>
        &gt;</literal>. It can be defined as follows:<programlisting>set[&amp;T2] right-image(rel[&amp;T1,&amp;T2] R, &amp;T1 E) = 
   { W | &lt;&amp;T1 V, &amp;T2 W&gt; : R, V == E }</programlisting></para>
      </formalpara>

      <para>The right image operator can be extended to take a set of elements
      as second element instead of a single element:</para>

      <programlisting>set[&amp;T2] right-image(rel[&amp;T1,&amp;T2] R, set[&amp;T1] S) = 
   { W | &lt;&amp;T1 V, &amp;T2 W&gt; : R, V in S}</programlisting>

      <formalpara>
        <title>Examples</title>

        <para>Assume that <literal>Rel</literal> has value
        <literal>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;1,11&gt;, &lt;3,30&gt;,
        &lt;2,21&gt;}</literal> in the following examples.</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para><literal>Rel[1]</literal> yields <literal>{10,
          11}</literal>.</para>
        </listitem>

        <listitem>
          <para><literal>Rel[{1}]</literal> yields {10, 11}.</para>
        </listitem>

        <listitem>
          <para><literal>Rel[{1, 2}]</literal> yields <literal>{10, 11, 20,
          21}</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>These expressions are abbreviations for, respectively
      <literal>Rel[1,-]</literal>, <literal>Rel[{1},-]</literal>, and
      <literal>Rel[{1, 2},-]</literal>.</para>
    </section>
  </section>

  <section xml:id="section.functions">
    <title>Built-in Functions</title>

    <para>The built-in functions can be subdivided in several broad
    categories:</para>

    <itemizedlist>
      <listitem>
        <para>Elementary functions on sets and relations (<xref
        linkend="section.elementary-functions-and-relations" />): identity
        (<literal>id</literal>), inverse (<literal>inv</literal>), complement
        (<literal>compl</literal>), and powerset (<literal>power0</literal>,
        <literal>power1</literal>).</para>
      </listitem>

      <listitem>
        <para>Extraction from relations (<xref
        linkend="section.extraction-from-relations" />): domain
        (<literal>domain</literal>), range (<literal>range</literal>), and
        carrier (<literal>carrier</literal>).</para>
      </listitem>

      <listitem>
        <para>Restrictions and exclusions on relations (<xref
        linkend="section.restrictions-on-relations" />): domain restriction
        (<literal>domainR</literal>), range restriction
        (<literal>rangeR</literal>), carrier restriction
        (<literal>carrierR</literal>), domain exclusion
        (<literal>domainX</literal>), range exclusion
        (<literal>rangeX</literal>), and carrier exclusion
        (<literal>carrierX</literal>).</para>
      </listitem>

      <listitem>
        <para>Functions on tuples (<xref linkend="section.tuples" />): first
        element (<literal>first</literal>), and second element
        (<literal>second</literal>).</para>
      </listitem>

      <listitem>
        <para>Relations viewed as graphs (<xref
        linkend="section.relations-as-graphs" />): the root elements
        (<literal>top</literal>), the leaf elements
        (<literal>bottom</literal>), reachability with restriction
        (<literal>reachR</literal>), and reachability with exclusion
        (<literal>reachX</literal>).</para>
      </listitem>

      <listitem>
        <para>Functions on locations (<xref linkend="section.locations" />):
        file name (<literal>filename</literal>), beginning line
        (<literal>beginline</literal>), first column
        (<literal>begincol</literal>), ending line
        (<literal>endline</literal>), and ending column
        (<literal>endcol</literal>).</para>
      </listitem>

      <listitem>
        <para>Functions on sets of integers (<xref
        linkend="section.sets-of-integers" />): sum (<literal>sum</literal>),
        average (<literal>average</literal>), maximum
        (<literal>max</literal>), and minimum (<literal>min</literal>).</para>
      </listitem>
    </itemizedlist>

    <para>The following sections give detailed descriptions and examples of
    all built-in functions.</para>

    <section xml:id="section.elementary-functions-and-relations">
      <title>Elementary Functions on Sets and Relations</title>

      <section xml:id="section.builtin-function-id">
        <title>Identity Relation: <literal>id</literal></title>

        <para>Definition:<programlisting>rel[&amp;T, &amp;T] id(set[&amp;T] S) = 
   { &lt;X, X&gt; | &amp;T X : S}</programlisting>Yields the relation that
        results from transforming each element in <literal>S</literal> into a
        pair with that element as first and second element. Examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>id({1,2,3})</literal> yields <literal>{&lt;1,1&gt;,
            &lt;2,2&gt;, &lt;3,3&gt;}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>id({"mon", "tue", "wed"})</literal> yields
            <literal>{&lt;"mon","mon"&gt;, &lt;"tue","tue"&gt;,
            &lt;"wed","wed"&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-unique">
        <title>Deprecated: Set with unique elements:
        <literal>unique</literal></title>

        <para>Definition:<programlisting>set[&amp;T] unique(set[&amp;T] S) = 
   primitive</programlisting>Yields the set (actually the set) that results
        from removing all duplicate elements from <literal>S</literal>. This
        function stems from previous versions when we used bags instead of
        sets. It now acts as the identity function and is deprecated.
        Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>unique({1,2,1,3,2})</literal> yields
            <literal>{1,2,3}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-inv">
        <title>Inverse of Relation: <literal>inv</literal></title>

        <para>Definition:<programlisting>rel[&amp;T2, &amp;T1] inv (rel[&amp;T1, &amp;T2] R) = 
   { &lt;Y, X&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R }</programlisting>Yields
        the relation that is the inverse of the argument relation
        <literal>R</literal>, i.e. the relation in which the elements of all
        tuples in <literal>R</literal> have been interchanged. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>inv({&lt;1,10&gt;, &lt;2,20&gt;})</literal> yields
            <literal>{&lt;10,1&gt;,&lt;20,2&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-compl">
        <title>Complement of a Relation: <literal>compl</literal></title>

        <para>Definition:</para>

        <para><programlisting>rel[&amp;T1, &amp;T2] compl(rel[&amp;T1, &amp;T2] R) = 
   (domain(R) x range(R)) \ R}</programlisting>Yields the relation that is the
        complement of the argument relation <literal>R</literal>, using the
        carrier set of <literal>R</literal> as universe. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>compl({&lt;1,10&gt;}</literal> yields
            <literal>{&lt;1, 1&gt;, &lt;10, 1&gt;, &lt;10,
            10&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-power0">
        <title>Powerset of a Set: <literal>power0</literal></title>

        <para>Definition:<programlisting>set[set[&amp;T]] power0(set[&amp;T] S) = 
   primitive</programlisting>Yields the powerset of set <literal>S</literal>
        (including the empty set). Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>power0({1, 2, 3, 4})</literal>
            yields<programlisting>{ {}, {1}, {2}, {3}, {4},{1,2}, {1,3}, {1,4}, {2,3}, {2,4}, 
  {3,4}, {1,2,3}, {1,2,4}, {1,3,4}, {2,3,4}, {1,2,3,4}
}</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-power1">
        <title>Powerset of a Set: <literal>power1</literal></title>

        <para>Definition:<programlisting>set[set[&amp;T]] power1(set[&amp;T] S) = 
   primitive</programlisting>Yields the powerset of set <literal>S</literal>
        (excluding the empty set).} Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>power1({1, 2, 3, 4})</literal>
            yields<programlisting>{ {1}, {2}, {3}, {4},{1,2}, {1,3}, {1,4}, {2,3}, {2,4}, 
  {3,4}, {1,2,3}, {1,2,4}, {1,3,4}, {2,3,4}, {1,2,3,4}
}</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="section.extraction-from-relations">
      <title>Extraction from Relations</title>

      <section xml:id="section.builtin-function-domain">
        <title>Domain of a Relation: <literal>domain</literal></title>

        <para>Definition:<programlisting>set[&amp;T1] domain (rel[&amp;T1,&amp;T2] R) = 
   { X | &lt;&amp;T1 X, &amp;T2 Y&gt; : R }</programlisting>Yields the set
        that results from taking the first element of each tuple in relation
        <literal>R</literal>. Examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>domain({&lt;1,10&gt;, &lt;2,20&gt;})</literal>
            yields <literal>{1, 2}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>domain({&lt;"mon", 1&gt;, &lt;"tue",
            2&gt;})</literal> yields <literal>{"mon", "tue"}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-range">
        <title>Range of a Relation: <literal>range</literal></title>

        <para>Definition:<programlisting>set[&amp;T2] range (rel[&amp;T1,&amp;T2] R) = 
   { Y | &lt;&amp;T1 X, &amp;T2 Y&gt; : R }</programlisting>Yields the set
        that results from taking the second element of each tuple in relation
        <literal>R</literal>. Examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>range({&lt;1,10&gt;, &lt;2,20&gt;})</literal>
            yields <literal>{10, 20}</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>range({&lt;"mon", 1&gt;, &lt;"tue",
            2&gt;})</literal> yields <literal>{1, 2}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-carrier">
        <title>Carrier of a Relation: <literal>carrier</literal></title>

        <para>Definition:<programlisting>set[&amp;T]  carrier (rel[&amp;T,&amp;T] R) = 
   domain(R) union range(R)</programlisting>Yields the set that results from
        taking the first and second element of each tuple in the relation
        <literal>R</literal>. Note that the domain and range type of
        <literal>R</literal> should be the same. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>carrier({&lt;1,10&gt;, &lt;2,20&gt;})</literal>
            yields <literal>{1, 10, 2, 20}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="section.restrictions-on-relations">
      <title>Restrictions and Exclusions on Relations</title>

      <section xml:id="section.builtin-function-domainR">
        <title>Domain Restriction of a Relation:
        <literal>domainR</literal></title>

        <para>Definition:<programlisting>rel[&amp;T1,&amp;T2] domainR (rel[&amp;T1,&amp;T2] R, set[&amp;T1] S) =
   { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, X in S }</programlisting>Yields
        a relation identical to the relation <literal>R</literal> but only
        containing tuples whose first element occurs in set
        <literal>S</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>domainR({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;},
            {3, 1})</literal> yields <literal>{&lt;1,10&gt;,
            &lt;3,30&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-rangeR">
        <title>Range Restriction of a Relation:
        <literal>rangeR</literal></title>

        <para>Definition:<programlisting>rel[&amp;T1,&amp;T2] rangeR (rel[&amp;T1,&amp;T2] R, set[&amp;T2] S) =
   { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, Y in S }</programlisting>Yields
        a relation identical to relation <literal>R</literal> but only
        containing tuples whose second element occurs in set
        <literal>S</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>rangeR({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;},
            {30, 10})</literal> yields <literal>{&lt;1,10&gt;,
            &lt;3,30&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-carrierR">
        <title>Carrier Restriction of a Relation:
        <literal>carrierR</literal></title>

        <para>Definition:<programlisting>rel[&amp;T,&amp;T] carrierR (rel[&amp;T,&amp;T] R, set[&amp;T] S) = 
   { &lt;X, Y&gt; | &lt;&amp;T X, &amp;T Y&gt; : R, X in S, Y in S }</programlisting>Yields
        a relation identical to relation <literal>R</literal> but only
        containing tuples whose first and second element occur in set
        <literal>S</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>carrierR({&lt;1,10&gt;, &lt;2,20&gt;,
            &lt;3,30&gt;}, {10, 1, 20})</literal> yields
            <literal>{&lt;1,10&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-domainX">
        <title>Domain Exclusion of a Relation:
        <literal>domainX</literal></title>

        <para>Definition:<programlisting>rel[&amp;T1,&amp;T2] domainX (rel[&amp;T1,&amp;T2] R, set[&amp;T1] S) =
   { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, X notin S }</programlisting>Yields
        a relation identical to relation <literal>R</literal> but with all
        tuples removed whose first element occurs in set <literal>S</literal>.
        Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>domainX({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;},
            {3, 1})</literal> yields <literal>{&lt;2,
            20&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-rangeX">
        <title>Range Exclusion of a Relation:
        <literal>rangeX</literal></title>

        <para>Definition:<programlisting>rel[&amp;T1,&amp;T2] rangeX (rel[&amp;T1,&amp;T2] R, set[&amp;T2] S) =
   { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, Y notin S }</programlisting>Yields
        a relation identical to relation <literal>R</literal> but with all
        tuples removed whose second element occurs in set
        <literal>S</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>rangeX({&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;},
            {30, 10})</literal> yields <literal>{&lt;2,
            20&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-carrierX">
        <title>Carrier Exclusion of a Relation: carrierX</title>

        <para>Definition:<programlisting>rel[&amp;T,&amp;T] carrierX (rel[&amp;T,&amp;T] R, set[&amp;T] S) =
   { &lt;X, Y&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; : R, X notin S, Y notin S }</programlisting>Yields
        a relation identical to relation <literal>R</literal> but with all
        tuples removed whose first or second element occurs in set
        <literal>S</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>carrierX({&lt;1,10&gt;, &lt;2,20&gt;,
            &lt;3,30&gt;}, {10, 1, 20})</literal> yields
            <literal>{&lt;3,30&gt;}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="section.tuples">
      <title>Tuples</title>

      <section xml:id="section.builtin-function-first">
        <title>First Element of a Tuple: <literal>first</literal></title>

        <para>Definition:<programlisting>&amp;T1 first(&lt;&amp;T1, &amp;T2&gt; P) = 
   primitive</programlisting>Yields the first element of the tuple
        <literal>P</literal>. Examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>first(&lt;1, 10&gt;)</literal> yields
            <literal>1</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>first(&lt;"mon", 1&gt;)</literal> yields
            <literal>"mon"</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-second">
        <title>Second Element of a Tuple: <literal>second</literal></title>

        <para>Definition:<programlisting>&amp;T2 second(&lt;&amp;T1, &amp;T2&gt; P) = 
   primitive</programlisting>Yields the second element of the tuple
        <literal>P</literal>. Examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>second(&lt;1, 10&gt;)</literal> yields
            <literal>10</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>second(&lt;"mon", 1&gt;)</literal> yields
            <literal>1</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="section.relations-as-graphs">
      <title>Relations viewed as graphs</title>

      <section xml:id="section.builtin-function-top">
        <title>Top of a Relation: <literal>top</literal></title>

        <para>Definition:<programlisting>set[&amp;T] top(rel[&amp;T, &amp;T] R) = 
   unique(domain(R)) \ range(R)</programlisting>Yields the set of all roots
        when the relation <literal>R</literal> is viewed as a graph. Note that
        the domain and range type of <literal>R</literal> should be the same.
        Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>top({&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;,
            &lt;3,4&gt;})</literal> yields <literal>{1}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-bottom">
        <title>Bottom of a Relation: <literal>bottom</literal></title>

        <para>Definition:<programlisting>set[&amp;T] bottom(rel[&amp;T,&amp;T] R) = 
   unique(range(R)) \ domain(R)</programlisting>Yields the set of all leaves
        when the relation <literal>R</literal> is viewed as a graph. Note that
        the domain and range type of <literal>R</literal> should be the same.
        Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>bottom({&lt;1,2&gt;, &lt;1,3&gt;, &lt;2,4&gt;,
            &lt;3,4&gt;})</literal> yields <literal>{4}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-reachR">
        <title>Reachability with Restriction:
        <literal>reachR</literal></title>

        <para>Definition:<programlisting>set[&amp;T] reachR( set[&amp;T] Start, set[&amp;T] Restr, rel[&amp;T,&amp;T] Rel) =
   range(domainR(Rel, Start) o carrierR(Rel, Restr)+)</programlisting>Yields
        the elements that can be reached from set <literal>Start</literal>
        using the relation <literal>Rel</literal>, such that only elements in
        set <literal>Restr</literal> are used. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>reachR({1}, {1, 2, 3}, {&lt;1,2&gt;, &lt;1,3&gt;,
            &lt;2,4&gt;, &lt;3,4&gt;})</literal> yields <literal>{2,
            3}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-reachX">
        <title>Reachability with Exclusion: <literal>reachX</literal></title>

        <para>Definition:<programlisting>set[&amp;T] reachX( set[&amp;T] Start, set[&amp;T] Excl, rel[&amp;T,&amp;T] Rel) =
   range(domainR(Rel, Start) o carrierX(Rel, Excl)+)</programlisting>Yields
        the elements that can be reached from set <literal>Start</literal>
        using the relation <literal>Rel</literal>, such that no elements in
        set <literal>Excl</literal> are used. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>reachX({1}, {2}, {&lt;1,2&gt;, &lt;1,3&gt;,
            &lt;2,4&gt;, &lt;3,4&gt;})</literal> yields <literal>{3,
            4}</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="section.locations">
      <title>Functions on Locations</title>

      <section xml:id="section.builtin-function-filename">
        <title>File Name of a Location: <literal>filename</literal></title>

        <para>Definition:<programlisting>str filename(loc A) = 
    primitive</programlisting>Yields the file name of location
        <literal>A</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>filename(area-in-file("pico1.trm",area(5,2,6,8,0,0)))</literal>
            yields <literal>"pico1.trm"</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-beginline">
        <title>Beginning Line of a Location:
        <literal>beginline</literal></title>

        <para>Definition:<programlisting>int beginline(loc A) = 
    primitive</programlisting>Yields the first line of location
        <literal>A</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>beginline(area-in-file("pico1.trm",area(5,2,6,8,0,0)))</literal>
            yields <literal>5</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-begincol">
        <title>First Column of a Location: <literal>begincol</literal></title>

        <para>Definition:<programlisting>int begincol(loc A) = 
    primitive</programlisting>Yields the first column of location
        <literal>A</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>begincol(area-in-file("pico1.trm",area(5,2,6,8,0,0)))</literal>
            yields <literal>2</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-endline">
        <title>Ending Line of a Location: <literal>endline</literal></title>

        <para>Definition:<programlisting>int endline(loc A) = 
    primitive</programlisting>Yields the last line of location
        <literal>A</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>endline(area-in-file("pico1.trm",area(5,2,6,8,0,0)))</literal>
            yields <literal>6</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-endcol">
        <title>Ending Column of a Location: <literal>endcol</literal></title>

        <para>Definition:<programlisting>int endcol(loc A) = 
    primitive</programlisting>Yields the last column of location
        <literal>A</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>endcol(area-in-file("pico1.trm",area(5,2,6,8,0,0)))</literal>
            yields <literal>8</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="section.sets-of-integers">
      <title>Functions on Sets of Integers</title>

      <para>The functions in this section operate on sets of integers. Some
      functions (i.e., <literal>sum-domain</literal>,
      <literal>sum-range</literal>, <literal>average-domain</literal>,
      <literal>average-range</literal>) exist to solve the problem that we can
      only provide sets of integers and cannot model bags that may contain
      repeated occurrences of the same integer. For some calculations it is
      important to include these repetitions in the calculation (e.g.,
      computing the average length of class methods given a relation from
      methods names to number of lines in the method.)</para>

      <section xml:id="section.builtin-function-sum">
        <title>Sum of a Set of Integers: <literal>sum</literal></title>

        <para>Definition:<programlisting>int sum(set[int] S) = 
    primitive</programlisting>Yields the sum of the integers in set
        <literal>S</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>sum({1, 2, 3})</literal> yields
            <literal>6</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-sum-domain">
        <title>Sum of First Elements of Tuples in a Relation:
        <literal>sum-domain</literal></title>

        <para>Definition:<programlisting>int sum-domain(rel[int,&amp;T] R) = 
    primitive</programlisting>Yields the sum of the integers that appear in
        the first element of the tuples of <literal>R</literal>.
        Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>sum-domain({&lt;1,"a"&gt;, &lt;2,"b"&gt;,
            &lt;1,"c"&gt;})</literal> yields <literal>4</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>Be aware that <literal>sum(domain({&lt;1,"a"&gt;,
        &lt;2,"b""&gt;, &lt;1, "c"&gt;}))</literal> would be equal to
        <literal>3</literal> because the function <literal>domain</literal>
        creates a <emphasis>set</emphasis> (as opposed to a bag) and its
        result would thus contain only one occurrence of
        <literal>1</literal>.</para>
      </section>

      <section xml:id="section.builtin-function-sum-range">
        <title>Sum of Second Elements of Tuples in a Relation:
        <literal>sum-range</literal></title>

        <para>Definition:<programlisting>int sum-range(set[int] S) = 
    primitive</programlisting>Yields the sum of the integers that appear in
        the second element of the tuples of <literal>R</literal>.
        Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>sum-range({&lt;"a",1&gt;, &lt;"b",2&gt;,
            &lt;"c",1&gt;})</literal> yields <literal>4</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-average">
        <title>Average of a Set of Integers:
        <literal>average</literal></title>

        <para>Definition:<programlisting>int average(set[int] S) = 
    sum(S)/(#S)</programlisting>Yields the average of the integers in set
        <literal>S</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>average({1, 2, 3})</literal> yields
            <literal>3</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-average-domain">
        <title>Average of First Elements of Tuples in a Relation:
        <literal>average-domain</literal></title>

        <para>Definition:<programlisting>int average-domain(rel[int,&amp;T] R) = 
    sum-domain(R)/(#R)</programlisting>Yields the average of the integers that
        appear in the first element of the tuples of <literal>R</literal>.
        Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>average-domain({&lt;1,"a"&gt;, &lt;2,"b"&gt;,
            &lt;3,"c"&gt;})</literal> yields <literal>2</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-average-range">
        <title>Average of Second Elements of Tuples in a Relation:
        <literal>average-range</literal></title>

        <para>Definition:<programlisting>int average-range(rel[int,&amp;T] R) = 
    sum-range(R)/(#R)</programlisting>Yields the average of the integers that
        appear in the second element of the tuples of <literal>R</literal>.
        Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>average-range({&lt;"a",1&gt;, &lt;"b",2&gt;,
            &lt;"c",3&gt;})</literal> yields <literal>2</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-max">
        <title>Maximum of a Set of Integers: <literal>max</literal></title>

        <para>Definition:<programlisting>int max(set[int] S) = 
    primitive</programlisting>Yields the largest integer in set
        <literal>S</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>max({1, 2, 3})</literal> yields
            <literal>3</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.builtin-function-min">
        <title>Minimum of a Set of Integers: <literal>min</literal></title>

        <para>Definition: <programlisting>int min(set[int] S) = 
    primitive</programlisting>Yields the largest integer in set
        <literal>S</literal>. Example:</para>

        <itemizedlist>
          <listitem>
            <para><literal>min({1, 2, 3})</literal> yields
            <literal>31</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section xml:id="section.larger-examples">
    <title>Larger Examples</title>

    <para>Now we will have a closer look at some larger applications of
    Rscript. We start by analyzing the global structure of a software system.
    You may now want to reread the example of call graph analysis given
    earlier in <xref linkend="section.motivating-example" /> as a reminder.
    The component structure of an application is analyzed in <xref
    linkend="section.analyzing-components" /> and Java systems are analyzed in
    <xref linkend="section.analyzing-java" />. Next we move on to the
    detection of initialized variables in <xref
    linkend="section.unitialized-variables" /> and we explain how source code
    locations can be included in a such an analysis (<xref
    linkend="section.using-locations" />). As an example of computing code
    metrics, we describe the calculation of McCabe's cyclomatic complexity in
    <xref linkend="section.McCabe" />. Several examples of dataflow analysis
    follow in <xref linkend="section.dataflow" />. A description of program
    slicing concludes the chapter (<xref
    linkend="section.program-slicing" />).</para>

    <section xml:id="section.analyzing-components">
      <title>Analyzing the Component Structure of an Application</title>

      <para>A frequently occurring problem is that we know the call relation
      of a system but that we want to understand it at the component level
      rather than at the procedure level. If it is known to which component
      each procedure belongs, it is possible to <emphasis>lift</emphasis> the
      call relation to the component level as proposed in <xref
      linkend="Krikhaar99" />. First, introduce new types to denote procedure
      calls as well as components of a system:<programlisting>type proc = str
type comp = str</programlisting>Given a calls relation
      <literal>Calls2</literal>, the next step is to define the components of
      the system and to define a <literal>PartOf</literal> relation between
      procedures and components.<programlisting>rel[proc,proc] Calls = {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, 
                         &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, &lt;"b", "d"&gt;
                       }

set[comp] Components = {"Appl", "DB", "Lib"}

rel[proc, comp] PartOf = {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, 
                          &lt;"b", "DB"&gt;, &lt;"c", "Lib"&gt;, &lt;"d", "Lib"&gt;
                         }</programlisting>Actual lifting, amounts to
      translating each call between procedures by a call between components.
      This is achieved by the following function
      <literal>lift</literal>:<programlisting>rel[comp,comp] lift(rel[proc,proc] aCalls, rel[proc,comp] aPartOf)=
   { &lt;C1, C2&gt; | &lt;proc P1, proc P2&gt; : aCalls, 
                &lt;comp C1, comp C2&gt; : aPartOf[P1] x aPartOf[P2]
   }</programlisting>In our example, the lifted call relation between
      components is obtained by<programlisting>rel[comp,comp] ComponentCalls = lift(Calls2, PartOf)</programlisting>and
      has as value:<programlisting>{&lt;"DB", "Lib"&gt;, &lt;"Appl", "Lib"&gt;, &lt;"Appl", "DB"&gt;, &lt;"Appl", "Appl"&gt;}</programlisting>The
      relevant relations for this example are shown in <xref
      linkend="figure.parts" />.</para>

      <figure xml:id="figure.parts">
        <title>(a) <literal>Calls2</literal>; (b) <literal>PartOf</literal>;
        (c) <literal>ComponentCalls</literal>.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="parts.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="section.analyzing-java">
      <title>Analyzing the Structure of Java Systems</title>

      <para>Now we consider the analysis of Java systems (inspired by <xref
      linkend="BNL03" />. Suppose that the type <literal>class</literal> is
      defined as follows<programlisting>type class = str</programlisting>and
      that the following relations are available about a Java
      application:</para>

      <itemizedlist>
        <listitem>
          <para><literal>rel[class,class] CALL</literal>: If
          <literal>&lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt;</literal>
          is an element of <literal>CALL</literal>, then some method of
          <replaceable>C</replaceable><subscript>2</subscript> is called from
          <replaceable>C</replaceable><subscript>1</subscript>.</para>
        </listitem>

        <listitem>
          <para><literal>rel[class,class] INHERITANCE</literal>: If
          <literal>&lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt;</literal>
          is an element of <literal>INHERITANCE</literal>, then class
          <replaceable>C</replaceable><subscript>1</subscript> either extends
          class <replaceable>C</replaceable><subscript>2</subscript> or
          <replaceable>C</replaceable><subscript>1</subscript> implements
          interface
          <replaceable>C</replaceable><subscript>2</subscript>.</para>
        </listitem>

        <listitem>
          <para><literal>rel[class,class] CONTAINMENT</literal>: If
          &lt;<replaceable>C</replaceable><subscript>1</subscript>,
          <replaceable>C</replaceable><subscript>2</subscript>&gt; is an
          element of <literal>CONTAINMENT</literal>, then one of the
          attributes of class
          <replaceable>C</replaceable><subscript>1</subscript> is of type
          <replaceable>C</replaceable><subscript>2</subscript>.</para>
        </listitem>
      </itemizedlist>

      <para>To make this more explicit, consider the class
      <literal>LocatorHandle</literal> from the JHotDraw application (version
      5.2) as shown here:</para>

      <para><programlisting>package CH.ifa.draw.standard;

import java.awt.Point;
import CH.ifa.draw.framework.*;
/**
 * A LocatorHandle implements a Handle by delegating the 
 * location requests to a Locator object.
 */
public class LocatorHandle extends AbstractHandle {
    private Locator       fLocator;
    /**
     * Initializes the LocatorHandle with the given Locator.
     */
    public LocatorHandle(Figure owner, Locator l) {
        super(owner);
        fLocator = l;
    }
    /**
     * Locates the handle on the figure by forwarding the request
     * to its figure.
     */
    public Point locate() {
        return fLocator.locate(owner());
    }
}</programlisting></para>

      <para>It leads to the addition to the above relations of the following
      tuples:</para>

      <itemizedlist>
        <listitem>
          <para>To <literal>CALL</literal> the pairs
          <literal>&lt;"LocatorHandle", "AbstractHandle"&gt;</literal> and
          <literal>&lt;"LocatorHandle", "Locator"&gt;</literal> will be
          added.</para>
        </listitem>

        <listitem>
          <para>To <literal>INHERITANCE</literal> the pair
          <literal>&lt;"LocatorHandle", "AbstractHandle"&gt;</literal> will be
          added.</para>
        </listitem>

        <listitem>
          <para>To <literal>CONTAINMENT</literal> the pair
          <literal>&lt;"LocatorHandle", "Locator"&gt;</literal> will be
          added.</para>
        </listitem>
      </itemizedlist>

      <para>Cyclic structures in object-oriented systems makes understanding
      hard. Therefore it is interesting to spot classes that occur as part of
      a cyclic dependency. Here we determine cyclic uses of classes that
      include calls, inheritance and containment. This is achieved as
      follows:<programlisting>rel[class,class] USE = CALL union CONTAINMENT union INHERITANCE
set[str] ClassesInCycle =
   {C1 | &lt;class C1, class C2&gt; : USE+, C1 == C2}</programlisting>First,
      we define the <literal>USE</literal> relation as the union of the three
      available relations <literal>CALL</literal>,
      <literal>CONTAINMENT</literal> and <literal>INHERITANCE</literal>. Next,
      we consider all pairs
      &lt;<replaceable>C</replaceable><subscript>1</subscript>,
      <replaceable>C</replaceable><subscript>2</subscript>&gt; in the
      transitive closure of the <literal>USE</literal> relation such that
      <replaceable>C</replaceable><subscript>1</subscript> and
      <replaceable>C</replaceable><subscript>2</subscript> are equal. Those
      are precisely the cases of a class with a cyclic dependency on itself.
      Probably, we do not only want to know which classes occur in a cyclic
      dependency, but we also want to know which classes are involved in such
      a cycle. In other words, we want to associate with each class a set of
      classes that are responsible for the cyclic dependency. This can be done
      as follows.<programlisting>rel[class,class] USE = CALL union CONTAINMENT union INHERITANCE
set[class] CLASSES = carrier(USE)
rel[class,class] USETRANS = USE+
rel[class,set[class]] ClassCycles = 
   {&lt;C, USETRANS[C]&gt; | class C : CLASSES, &lt;C, C&gt; in USETRANS }</programlisting>First,
      we introduce two new shorthands: <literal>CLASSES</literal> and
      <literal>USETRANS</literal>. Next, we consider all classes
      <literal>C</literal> with a cyclic dependency and add the pair
      <literal>&lt;C, USETRANS[C]&gt;</literal> to the relation
      <literal>ClassCycles</literal>. Note that <literal>USETRANS[C]</literal>
      is the right image of the relation <literal>USETRANS</literal> for
      element <literal>C</literal>, i.e., all classes that can be called
      transitively from class <literal>C</literal>.</para>
    </section>

    <section xml:id="section.unitialized-variables">
      <title>Finding Uninitialized and Unused Variables in a Program</title>

      <para>Consider the following program in the toy language Pico: (This is
      an extended version of the example presented earlier in <xref
      linkend="KlintIWPC03" />.)<programlisting>[ 1] begin declare x : natural, y : natural,
[ 2]              z : natural, p : natural;
[ 3]  x := 3;
[ 4]  p := 4;
[ 5]  if q then
[ 6]        z := y + x
[ 7]  else
[ 8]        x := 4
[ 9]  fi;
[10]  y := z
[11] end</programlisting>Inspection of this program learns that some of the
      variables are being used before they have been initialized. The
      variables in question are <literal>q</literal> (line 5),
      <literal>y</literal> (line 6), and <literal>z</literal> (line 10). It is
      also clear that variable <literal>p</literal> is initialized (line 4),
      but is never used. How can we automate these kinds of analysis? Recall
      from <xref linkend="section.introduction" /> that we follow
      extract-enrich-view paradigm to approach such a problem. The first step
      is to determine which elementary facts we need about the program. For
      this and many other kinds of program analysis, we need at least the
      following:</para>

      <itemizedlist>
        <listitem>
          <para>The <emphasis>control flow graph</emphasis> of the program. We
          represent it by a relation <literal>PRED</literal> (for predecessor)
          which relates each statement with each predecessors.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>definitions</emphasis> of each variable, i.e.,
          the program statements where a value is assigned to the variable. It
          is represented by the relation <literal>DEFS</literal>.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>uses</emphasis> of each variable, i.e., the
          program statements where the value of the variable is used. It is
          represented by the relation <literal>USES</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>In this example, we will use line numbers to identify the
      statements in the program. (In <xref
      linkend="section.using-locations" />, we will use locations to represent
      statements.) Assuming that there is a tool to extract the above
      information from a program text, we get the following for the above
      example:<programlisting>type expr = int
type varname = str
expr ROOT = 1
rel[expr,expr] PRED = { &lt;1,3&gt;, &lt;3,4&gt;, &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,8&gt;, 
                        &lt;6,10&gt;, &lt;8,10&gt; 
                      }
rel[expr,varname] DEFS = { &lt;3,"x"&gt;, &lt;4,"p"&gt;, &lt;6,"z"&gt;, 
                           &lt;8,"x"&gt;, &lt;10,"y"&gt;
                         }
rel[expr,varname] USES = { &lt;5,"q"&gt;, &lt;6,"y"&gt;, &lt;6,"x"&gt;, &lt;10,"z"&gt; }</programlisting>This
      concludes the extraction phase. Next, we have to enrich these basic
      facts to obtain the initialized variables in the program. So, when is a
      variable <replaceable>V</replaceable> in some statement
      <replaceable>S</replaceable> initialized? If we execute the program
      (starting in <literal>ROOT</literal>), there may be several possible
      execution path that can reach statement <replaceable>S</replaceable>.
      All is well if <emphasis>all</emphasis> these execution path contain a
      definition of <replaceable>V</replaceable>. However, if one or more of
      these path do <emphasis>not</emphasis> contain a definition of
      <replaceable>V</replaceable>, then <replaceable>V</replaceable> may be
      uninitialized in statement <replaceable>S</replaceable>. This can be
      formalized as follows:<programlisting>rel[expr,varname] UNINIT = 
   { &lt;E, V&gt; | &lt;expr E, varname V&gt;: USES, 
              E in reachX({ROOT}, DEFS[-,V], PRED)
   }</programlisting></para>

      <para>We analyze this definition in detail:</para>

      <itemizedlist>
        <listitem>
          <para><literal>&lt;expr E, varname V&gt; : USES</literal> enumerates
          all tuples in the <literal>USES</literal> relation. In other words,
          we consider the use of each variable in turn.</para>
        </listitem>

        <listitem>
          <para><literal>E in reachX({ROOT}, DEFS[-,V], PRED) </literal>is a
          test that determines whether statement <replaceable>S</replaceable>
          is reachable from the <literal>ROOT</literal> without encountering a
          definition of variable <replaceable>V</replaceable>.</para>

          <itemizedlist>
            <listitem>
              <para><literal>{ROOT}</literal> represents the initial set of
              nodes from which all path should start.</para>
            </listitem>

            <listitem>
              <para><literal>DEFS[-,V]</literal> yields the set of all
              statements in which a definition of variable
              <literal>V</literal> occurs. These nodes form the exclusion set
              for <literal>reachX</literal>: no path will be extended beyond
              an element in this set.</para>
            </listitem>

            <listitem>
              <para><literal>PRED</literal> is the relation for which the
              reachability has to be determined.</para>
            </listitem>

            <listitem>
              <para>The result of <literal>reachX({ROOT}, DEFS[-,V], PRED)
              </literal>is a set that contains all nodes that are reachable
              from the <literal>ROOT</literal> (as well as all intermediate
              nodes on each path).</para>
            </listitem>

            <listitem>
              <para>Finally, <literal>E in reachX({ROOT}, DEFS[-,V], PRED)
              </literal>tests whether expression <literal>E</literal> can be
              reached from the <literal>ROOT</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The net effect is that <literal>UNINIT</literal> will only
          contain pairs that satisfy the test just described.</para>
        </listitem>
      </itemizedlist>

      <para>When we execute the resulting Rscript (i.e., the declarations of
      <literal>ROOT</literal>, <literal>PRED</literal>,
      <literal>DEFS</literal>, <literal>USES</literal> and
      <literal>UNINIT</literal>), we get as value for
      <literal>UNINIT</literal>:<programlisting>{&lt;5, "q"&gt;, &lt;6, "y"&gt;, &lt;10, "z"&gt;}</programlisting>and
      this is in concordance with the informal analysis given at the beginning
      of this example.</para>

      <para>As a bonus, we can also determine the <emphasis>unused</emphasis>
      variables in a program, i.e., variables that are defined but are used
      nowhere. This is done as follows:<programlisting>set[var] UNUSED = range(DEFS) \ range(USES)</programlisting>Taking
      the range of the relations <literal>DEFS</literal> and
      <literal>USES</literal> yields the variables that are defined,
      respectively, used in the program. The difference of these two sets
      yields the unused variables, in this case
      <literal>{"p"}</literal>.</para>
    </section>

    <section xml:id="section.using-locations">
      <title>Using Locations to Represent Program Fragments</title>

      <para><warning>
          <para>Fix the following</para>
        </warning>\begin{figure}[tb] \begin{center}
      \epsfig{figure=figs/meta-pico.eps,width=6cm} \hspace*{0.5cm}
      \epsfig{figure=figs/pico-example.eps,width=6cm} \end{center} \hrulefill
      \caption{\label{FIG:meta-pico}Checking undefined variables in Pico
      programs using the ASF+SDF Meta-Environment. On the left, main window of
      Meta-Environment with error messages related to Pico program shown on
      the right.{\bf THIS FIGURE IS OUTDATED}} \end{figure}</para>

      <para>One aspect of the example we have just seen is artificial: where
      do these line numbers come from that we used to indicate expressions in
      the program? One solution is to let the extraction phase generate
      <emphasis>locations</emphasis> to precisely indicate relevant places in
      the program text. Recall from <xref
      linkend="section.elementary-types" />, that a location consists of a
      file name, a begin line, a begin position, an end line, and an end
      position. Also recall that locations can be compared: a location
      <replaceable>A</replaceable><subscript>1</subscript> is smaller than
      another location <replaceable>A</replaceable><subscript>2</subscript>,
      if <replaceable>A</replaceable><subscript>1</subscript> is textually
      contained in <replaceable>A</replaceable><subscript>2</subscript>. By
      including locations in the final answer of a relational expression,
      external tools will be able to highlight places of interest in the
      source text.</para>

      <para>The first step, is to define the type <literal>expr</literal> as
      aliases for <literal>loc</literal> (instead of
      <literal>int</literal>):</para>

      <para><programlisting>type expr = loc
type varname = str </programlisting></para>

      <para>Of course, the actual relations are now represented differently.
      For instance, the <literal>USES</literal> relation may now look
      like</para>

      <para><programlisting>{ &lt;area-in-file("/home/paulk/example.pico", 
                area(5,5,5,6,106,1)), "q"&gt;, 
  &lt;area-in-file("/home/paulk/example.pico", 
                area(6,13,6,14,127,1)), "y"&gt;, 
  &lt;area-in-file("/home/paulk/example.pico", 
                area(6,17,6,18,131,1)), "x"&gt;, 
  &lt;area-in-file("/home/paulk/example.pico", 
                area(10,7,10,8,168,1)), "z"&gt; 
} </programlisting></para>

      <para>The definition of <literal>UNINIT</literal> can be nearly reused
      as is. The only thing that remains to be changed is to map the
      (expression, variable-name) tuples to (variable-name,
      variable-occurrence) tuples, for the benefit of the precise highlighting
      of the relevant variables. We define a new type <literal>var</literal>
      to represent variable occurrences and an auxiliary set that
      <literal>VARNAMES</literal> that contains all variable names:</para>

      <para><programlisting>type var = loc
set[varname] VARNAMES = range(DEFS) union range(USES)</programlisting></para>

      <para>Remains the new definition of <literal>UNINIT</literal>:</para>

      <para><programlisting>rel[var, varname] UNINIT = 
   { &lt;V, VN&gt;| var-name VN : VARNAMES, 
              var V : USES[-,VN], 
              expr E : reachX({ROOT}, DEFS[-,VN], PRED), 
              V &lt;= E 
   }</programlisting></para>

      <para>This definition can be understood as follows:</para>

      <itemizedlist>
        <listitem>
          <para><literal>var-name VN : VARNAMES</literal> generates all
          variable names.</para>
        </listitem>

        <listitem>
          <para><literal>var V : USES[-,VN]</literal> generates all variable
          uses <literal>V</literal> for variables with name
          <literal>VN</literal>.</para>
        </listitem>

        <listitem>
          <para>As before, <literal>expr E : reachX({ROOT}, DEFS[-,VN],
          PRED)</literal> generates all expressions <literal>E</literal> that
          can be reached from the start of the program without encountering a
          definition for variables named <literal>VN</literal>.</para>
        </listitem>

        <listitem>
          <para>V<literal> &lt;= E</literal> tests whether variable use
          <literal>V</literal> is enclosed in that expression (using a
          comparison on locations). If so, we have found an uninitialized
          occurrence of the variable named <literal>VN</literal>.</para>
        </listitem>
      </itemizedlist>

      <para><warning>
          <para>Fix reference</para>
        </warning>In Figure~\ref{FIG:meta-pico} it is shown how checking of
      Pico programs in the ASF+SDF Meta-Environment looks like.</para>
    </section>

    <section xml:id="section.McCabe">
      <title>McCabe Cyclomatic Complexity</title>

      <para>The <emphasis>cyclomatic complexity</emphasis> of a program is
      defined as <replaceable>e</replaceable> - <replaceable>n</replaceable> +
      2, where <replaceable>e</replaceable> and <replaceable>n</replaceable>
      are the number of edges and nodes in the control flow graph,
      respectively. It was proposed by McCabe <xref linkend="McCabe76" /> as a
      measure of program complexity. Experiments have shown that programs with
      a higher cyclomatic complexity are more difficult to understand and test
      and have more errors. It is generally accepted that a program, module or
      procedure with a cyclomatic complexity larger than 15 is <emphasis>too
      complex</emphasis>. Essentially, cyclomatic complexity measures the
      number of decision points in a program and can be computed by counting
      all if statement, case branches in switch statements and the number of
      conditional loops. Given a control flow in the form of a predecessor
      relation <literal>rel[stat,stat] PRED</literal> between statements, the
      cyclomatic complexity can be computed in an Rscript as follows:
      <programlisting>int cyclomatic-complexity(rel[stat,stat] PRED) = 
    #PRED - #carrier(PRED) + 2</programlisting> The number of edges
      <replaceable>e</replaceable> is equal to the number of tuples in
      <literal>PRED</literal>. The number of nodes
      <replaceable>n</replaceable> is equal to the number of elements in the
      carrier of PRED, i.e., all elements that occur in a tuple in
      <literal>PRED</literal>.</para>
    </section>

    <section xml:id="section.dataflow">
      <title>Dataflow Analysis</title>

      <para><emphasis>Dataflow analysis</emphasis> is a program analysis
      technique that forms the basis for many compiler optimizations. It is
      described in any text book on compiler construction, e.g. <xref
      linkend="AhoSethiUllman86" />. The goal of dataflow analysis is to
      determine the effect of statements on their surroundings. Typical
      examples are:</para>

      <itemizedlist>
        <listitem>
          <para>Dominators (<xref linkend="section.dominators" />): which
          nodes in the flow dominate the execution of other nodes?</para>
        </listitem>

        <listitem>
          <para>Reaching definitions (<xref
          linkend="section.reaching-definitions" />): which definitions of
          variables are still valid at each statement?</para>
        </listitem>

        <listitem>
          <para>Live variables (<xref linkend="section.live-variables" />): of
          which variables will the values be used by successors of a
          statement?</para>
        </listitem>

        <listitem>
          <para>Available expressions: an expression is available if it is
          computed along each path from the start of the program to the
          current statement.</para>
        </listitem>
      </itemizedlist>

      <section xml:id="section.dominators">
        <title>Dominators</title>

        <para>A node <replaceable>d</replaceable> of a flow graph
        <emphasis>dominates</emphasis> a node <replaceable>n</replaceable>, if
        every path from the initial node of the flow graph to
        <replaceable>n</replaceable> goes through <replaceable>d</replaceable>
        <xref linkend="AhoSethiUllman86" /> (Section 10.4). Dominators play a
        role in the analysis of conditional statements and loops. The function
        <literal>dominators</literal> that computes the dominators for a given
        flow graph <literal>PRED</literal> and an entry node
        <literal>ROOT</literal> is defined as follows:</para>

        <para><programlisting>rel[stat,stat] dominators(rel[stat,stat] PRED, int ROOT) = 
   DOMINATES
where
    set[int] VERTICES = carrier(PRED)

    rel[int,set[int]] DOMINATES =
    { &lt;V,  VERTICES \ {V, ROOT} \ reachX({ROOT}, {V}, PRED)&gt; |  
      int V : VERTICES }
endwhere</programlisting></para>

        <para>First, the auxiliary set <literal>VERTICES</literal> (all the
        statements) is computed. The relation <literal>DOMINATES</literal>
        consists of all pairs <literal>&lt;<replaceable>S</replaceable>,
        {<replaceable>S</replaceable><subscript>1</subscript>,...,<replaceable>S</replaceable><subscript><replaceable>n</replaceable></subscript>}&gt;</literal>
        such that</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>S</replaceable><subscript><replaceable>i</replaceable></subscript>
            is not an initial node or equal to
            <replaceable>S</replaceable>.</para>
          </listitem>

          <listitem>
            <para><replaceable>S</replaceable><subscript><replaceable>i</replaceable></subscript>
            cannot be reached from the initial node without going through
            <replaceable>S</replaceable>.</para>
          </listitem>
        </itemizedlist>

        <para>Consider the flow graph<programlisting>rel[int,int] PRED = {
&lt;1,2&gt;, &lt;1,3&gt;,
&lt;2,3&gt;,
&lt;3,4&gt;,
&lt;4,3&gt;,&lt;4,5&gt;, &lt;4,6&gt;,
&lt;5,7&gt;,
&lt;6,7&gt;,
&lt;7,4&gt;,&lt;7,8&gt;,
&lt;8,9&gt;,&lt;8,10&gt;,&lt;8,3&gt;,
&lt;9,1&gt;,
&lt;10,7&gt;
}</programlisting>It is illustrated in<xref
        linkend="figure.flow-graph" /><figure xml:id="figure.flow-graph">
            <title>Flow graph</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="dominators.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure>The result of applying <literal>dominators</literal> to it
        is as follows:<programlisting>{&lt;1, {2, 3, 4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;2, {}&gt;, 
&lt;3, {4, 5, 6, 7, 8, 9, 10}&gt;, 
&lt;4, {5, 6, 7, 8, 9, 10}&gt;, 
&lt;5, {}&gt;, 
&lt;6, {}&gt;, 
&lt;7, {8, 9, 10}&gt;, 
&lt;8, {9, 10}&gt;, 
&lt;9, {}&gt;, 
&lt;10, {}&gt;}</programlisting>The resulting <emphasis>dominator
        tree</emphasis> is shown in <xref linkend="figure.dominator-tree" />.
        The dominator tree has the initial node as root and each node
        <replaceable>d</replaceable> in the tree only dominates its
        descendants in the tree.</para>

        <para><figure xml:id="figure.dominator-tree">
            <title>Dominator tree</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="dominator-tree.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section xml:id="section.reaching-definitions">
        <title>Reaching Definitions</title>

        <para>We illustrate the calculation of reaching definitions using the
        example in <xref linkend="figure.dataflow-graph" /> which was inspired
        by <xref linkend="AhoSethiUllman86" /> (Example 10.15).</para>

        <para><figure xml:id="figure.dataflow-graph">
            <title>Flow graph for various dataflow problems</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="df-graph.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>As before, we assume the following basic relations
        <literal>PRED</literal>, <literal>DEFS</literal> and
        <literal>USES</literal> about the program:<programlisting>type stat = int
type var = str
rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, &lt;4,5&gt;, &lt;5,6&gt;, 
                        &lt;5,7&gt;, &lt;6,7&gt;, &lt;7,4&gt;
                      }
rel[stat, var] DEFS = { &lt;1, "i"&gt;, &lt;2, "j"&gt;, &lt;3, "a"&gt;, &lt;4, "i"&gt;, 
                       &lt;5, "j"&gt;, &lt;6, "a"&gt;, &lt;7, "i"&gt;
                      }
rel[stat, var] USES = { &lt;1, "m"&gt;, &lt;2, "n"&gt;, &lt;3, "u1"&gt;, &lt;4, "i"&gt;, 
                        &lt;5, "j"&gt;, &lt;6, "u2"&gt;, &lt;7, "u3"&gt;
                      }</programlisting></para>

        <para>For convenience, we introduce a notion <literal>def</literal>
        that describes that a certain statement defines some variable and we
        revamp the basic relations into a more convenient format using this
        new type:<programlisting>type def  = &lt;stat theStat, var theVar&gt;

rel[stat, def] DEF = {&lt;S, &lt;S, V&gt;&gt; | &lt;stat S, var V&gt; : DEFS}
rel[stat, def] USE = {&lt;S, &lt;S, V&gt;&gt; | &lt;stat S, var V&gt; : USES}</programlisting>The
        new <literal>DEF</literal> relation gets as value:<programlisting>{ &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, &lt;3, &lt;3, "a"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
  &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, &lt;7, &lt;7, "i"&gt;&gt;
}</programlisting>and <literal>USE</literal> gets as value:<programlisting>{ &lt;1, &lt;1, "m"&gt;&gt;, &lt;2, &lt;2, "n"&gt;&gt;, &lt;3, &lt;3, "u1"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, 
  &lt;5, &lt;5, "j"&gt;&gt;, &lt;6, &lt;6, "u2"&gt;&gt;, &lt;7, &lt;7, "u3"&gt;&gt;
}</programlisting></para>

        <para>Now we are ready to define an important new relation
        <literal>KILL</literal>. <literal>KILL</literal> defines which
        variable definitions are undone (killed) at each statement and is
        defined as follows:<programlisting>rel[stat, def] KILL = 
   {&lt;S1, &lt;S2, V&gt;&gt; | &lt;stat S1, var V&gt; : DEFS, 
                    &lt;stat S2, V&gt; : DEFS, 
                    S1 != S2
   }</programlisting>In this definition, all variable definitions are compared
        with each other, and for each variable definition all
        <emphasis>other</emphasis> definitions of the same variable are placed
        in its kill set. In the example, <literal>KILL</literal> gets the
        value <programlisting>{ &lt;1, &lt;4, "i"&gt;&gt;, &lt;1, &lt;7, "i"&gt;&gt;, &lt;2, &lt;5, "j"&gt;&gt;, &lt;3, &lt;6, "a"&gt;&gt;, 
  &lt;4, &lt;1, "i"&gt;&gt;, &lt;4, &lt;7, "i"&gt;&gt;, &lt;5, &lt;2, "j"&gt;&gt;, &lt;6, &lt;3, "a"&gt;&gt;, 
  &lt;7, &lt;1, "i"&gt;&gt;, &lt;7, &lt;4, "i"&gt;&gt;
}</programlisting>and, for instance, the definition of variable
        <literal>i</literal> in statement <literal>1</literal> kills the
        definitions of <literal>i</literal> in statements <literal>4</literal>
        and <literal>7</literal>. Next, we introduce the collection of
        statements<programlisting>set[stat] STATEMENTS = carrier(PRED)</programlisting>which
        gets as value <literal>{1, 2, 3, 4, 5, 6, 7}</literal> and two
        convenience functions to obtain the predecessor, respectively, the
        successor of a statement:</para>

        <para><programlisting>set[stat] predecessor(stat S) = PRED[-,S] 
set[stat] successor(stat S) = PRED[S,-]</programlisting></para>

        <para>After these preparations, we are ready to formulate the reaching
        definitions problem in terms of two relations <literal>IN</literal>
        and <literal>OUT</literal>. <literal>IN</literal> captures all the
        variable definitions that are valid at the entry of each statement and
        <literal>OUT</literal> captures the definitions that are still valid
        after execution of each statement. Intuitively, for each statement
        <literal>S</literal>, <literal>IN[S]</literal> is equal to the union
        of the <literal>OUT</literal> of all the predecessors of
        <literal>S</literal>. <literal>OUT[S]</literal>, on the other hand, is
        equal to the definitions generated by <literal>S</literal> to which we
        add <literal>IN[S]</literal> minus the definitions that are killed in
        <literal>S</literal>. Mathematically, the following set of equations
        captures this idea for each statement:</para>

        <para><warning>
            <para>Fix expression</para>
          </warning></para>

        <para>[ IN[S] = \bigcup_{P \in predecessor of S} OUT[P] \]</para>

        <para>\[ OUT[S] = DEF[S] \cup (IN[S] - KILL[S]) \]</para>

        <para></para>

        <para>This idea can be expressed in Rscript quite
        literally:<programlisting>equations
  initial
        rel[stat,def] IN init {}
        rel[stat,def] OUT init DEF
  satisfy
        IN  = {&lt;S, D&gt; | stat S : STATEMENTS, 
                        stat P : predecessor(S), 
                        def D : OUT[P]}
        OUT = {&lt;S, D&gt; | stat S : STATEMENTS, 
                        def D : DEF[S] union (IN[S] \ KILL[S])}
end equations</programlisting>First, the relations <literal>IN</literal> and
        <literal>OUT</literal> are declared and initialized. Next, two
        equations are given that very much resemble the ones given
        above.</para>

        <para><figure xml:id="figure.reaching-definitions">
            <title>Reaching definitions for flow graph in <xref
            linkend="figure.dataflow-graph" /></title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="reach.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure> For our running example (<xref
        linkend="figure.reaching-definitions" />) the results are as follows
        (see <xref linkend="figure.reaching-definitions" />). Relation
        <literal>IN</literal> has as value:<programlisting>{ &lt;2, &lt;1, "i"&gt;&gt;, &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, &lt;4, &lt;3, "a"&gt;&gt;, 
  &lt;4, &lt;2, "j"&gt;&gt;, &lt;4, &lt;1, "i"&gt;&gt;, &lt;4, &lt;7, "i"&gt;&gt;, &lt;4, &lt;5, "j"&gt;&gt;, 
  &lt;4, &lt;6, "a"&gt;&gt;, &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;2, "j"&gt;&gt;, 
  &lt;5, &lt;5, "j"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, &lt;6, &lt;5, "j"&gt;&gt;, &lt;6, &lt;4, "i"&gt;&gt;, 
  &lt;6, &lt;3, "a"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, &lt;7, &lt;5, "j"&gt;&gt;, &lt;7, &lt;4, "i"&gt;&gt;, 
  &lt;7, &lt;3, "a"&gt;&gt;, &lt;7, &lt;6, "a"&gt;&gt;
}</programlisting></para>

        <para>If we consider statement <literal>3</literal>, then the
        definitions of variables <literal>i</literal> and <literal>j</literal>
        from the preceding two statements are still valid. A more interesting
        case are the definitions that can reach statement
        <literal>4</literal>:</para>

        <itemizedlist>
          <listitem>
            <para>The definitions of variables <literal>a</literal>,
            <literal>j</literal> and <literal>i</literal> from, respectively,
            statements <literal>3</literal>, <literal>2</literal> and
            <literal>1</literal>.</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>i</literal> from
            statement <literal>7</literal> (via the backward control flow path
            from <literal>7</literal> to <literal>4</literal>).</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>j</literal> from
            statement <literal>5</literal> (via the path <literal>5</literal>,
            <literal>7</literal>, <literal>4</literal>).</para>
          </listitem>

          <listitem>
            <para>The definition of variable <literal>a</literal> from
            statement <literal>6</literal> (via the path <literal>6</literal>,
            <literal>7</literal>, <literal>4</literal>).</para>
          </listitem>
        </itemizedlist>

        <para>Relation <literal>OUT</literal> has as value:<programlisting>{ &lt;1, &lt;1, "i"&gt;&gt;, &lt;2, &lt;2, "j"&gt;&gt;, &lt;2, &lt;1, "i"&gt;&gt;, &lt;3, &lt;3, "a"&gt;&gt;, 
  &lt;3, &lt;2, "j"&gt;&gt;, &lt;3, &lt;1, "i"&gt;&gt;, &lt;4, &lt;4, "i"&gt;&gt;, &lt;4, &lt;3, "a"&gt;&gt;, 
  &lt;4, &lt;2, "j"&gt;&gt;, &lt;4, &lt;5, "j"&gt;&gt;, &lt;4, &lt;6, "a"&gt;&gt;, &lt;5, &lt;5, "j"&gt;&gt;, 
  &lt;5, &lt;4, "i"&gt;&gt;, &lt;5, &lt;3, "a"&gt;&gt;, &lt;5, &lt;6, "a"&gt;&gt;, &lt;6, &lt;6, "a"&gt;&gt;, 
  &lt;6, &lt;5, "j"&gt;&gt;, &lt;6, &lt;4, "i"&gt;&gt;, &lt;7, &lt;7, "i"&gt;&gt;, &lt;7, &lt;5, "j"&gt;&gt;, 
  &lt;7, &lt;3, "a"&gt;&gt;, &lt;7, &lt;6, "a"&gt;&gt;
}</programlisting>Observe, again for statement <literal>4</literal>, that all
        definitions of variable <literal>i</literal> are missing in
        <literal>OUT[4]</literal> since they are killed by the definition of
        <literal>i</literal> in statement <literal>4</literal> itself.
        Definitions for <literal>a</literal> and <literal>j</literal> are,
        however, contained in <literal>OUT[4]</literal>. The result of
        reaching definitions computation is illustrated in <xref
        linkend="figure.reaching-definitions" />. The above definitions are
        used to formulate the function
        <literal>reaching-definitions</literal>. It assumes appropriate
        definitions for the types <literal>stat</literal> and
        <literal>var</literal>. It also assumes more general versions of
        <literal>predecessor</literal> and <literal>successor</literal>. We
        will use it later on in <xref linkend="section.program-slicing" />
        when defining program slicing. Here is the definition of
        <literal>reaching-definitions</literal>:<programlisting>type def  = &lt;stat theStat, var theVar&gt;
type use  = &lt;stat theStat, var theVar&gt;

set[stat] predecessor(rel[stat,stat] P, stat S) = P[-,S]

set[stat] successor(rel[stat,stat] P, stat S) = P[S,-]

rel[stat, def] reaching-definitions(rel[stat,var] DEFS, 
                                    rel[stat,stat] PRED) = 
   IN
where
    set[stat] STATEMENT = carrier(PRED)

    rel[stat,def] DEF  = {&lt;S,&lt;S,V&gt;&gt; | &lt;stat S, var V&gt; : DEFS}

    rel[stat,def] KILL = 
        {&lt;S1, &lt;S2, V&gt;&gt; | &lt;stat S1, var V&gt; : DEFS, 
                         &lt;stat S2, V&gt; : DEFS, 
                         S1 != S2
        }

    equations 
       initial
           rel[stat,def] IN init {}
           rel[stat,def] OUT init DEF
       satisfy
           IN  =  {&lt;S, D&gt; | int S : STATEMENT, 
                            stat P : predecessor(PRED,S), 
                            def D : OUT[P]}
           OUT = {&lt;S, D&gt; |  int S : STATEMENT, 
                            def D : DEF[S] union (IN[S] \ KILL[S])}
    end equations
end where</programlisting></para>
      </section>

      <section xml:id="section.live-variables">
        <title>Live Variables</title>

        <para>The live variables of a statement are those variables whose
        value will be used by the current statement or some successor of it.
        The mathematical formulation of this problem is as follows:<warning>
            <para>Fix expression</para>
          </warning></para>

        <para>\[ IN[S] =USE[S] \cup (OUT[S] - DEF[S]) \]</para>

        <para>\[ OUT[S] = \bigcup_{S' \in successor of S} IN[S'] \]</para>

        <para>The first equation says that a variable is live coming into a
        statement if either it is used before redefinition in that statement
        or it is live coming out of the statement and is not redefined in it.
        The second equation says that a variable is live coming out of a
        statement if and only if it is live coming into one of its
        successors.</para>

        <para>This can be expressed in Rscript as follows:<programlisting>equations
  initial
      rel[stat,def] LIN init {}
      rel[stat,def] LOUT init DEF
  satisfy
      LIN = { &lt; S, D&gt; | stat S : STATEMENTS,  
                        def D : USE[S] union (LOUT[S] \ (DEF[S]))
            }
      LOUT= { &lt; S, D&gt; | stat S : STATEMENTS,  
                        stat Succ : successor(S), 
                        def D : LIN[Succ] 
            }
end equations</programlisting>The results of live variable analysis for our
        running example are illustrated in <xref
        linkend="figure.live-variables" />.</para>

        <para><figure xml:id="figure.live-variables">
            <title>Live variables for flow graph in <xref
            linkend="figure.dataflow-graph" /></title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="live.png" scale="50"></imagedata>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>
    </section>

    <section xml:id="section.program-slicing">
      <title>Program Slicing</title>

      <para>Program slicing is a technique proposed by Weiser <xref
      linkend="Weiser84" /> for automatically decomposing programs in parts by
      analyzing their data flow and control flow. Typically, a given statement
      in a program is selected as the <emphasis>slicing criterion</emphasis>
      and the original program is reduced to an independent subprogram, called
      a <emphasis>slice</emphasis>, that is guaranteed to represent faithfully
      the behavior of the original program at the slicing criterion. An
      example will illustrate this:</para>

      <para><programlisting xml:id="programlisting.slice-example">[ 1] read(n)            [ 1] read(n)           [ 1] read(n)
[ 2] i := 1             [ 2] i := 1            [ 2] i := 1
[ 3] sum := 0           [ 3] sum := 0         
[ 4] product := 1                              [ 4] product := 1
[ 5] while i&lt;= n do     [ 5] while i&lt;= n do    [ 5] while i&lt;= n do
     begin                   begin                  begin
[ 6]   sum := sum + i   [ 6]   sum := sum + i
[ 7]   product :=                              [ 7]   product := 
         product * i                                    product * i
[ 8]   i := i + 1       [ 8]  i := i + 1       [ 8]   i := i + 1
     end                     end                    end
[ 9] write(sum)         [ 9] write(sum)
[10] write(product)                            [10] write(product)

<emphasis role="bold">(a)</emphasis> Sample program     <emphasis role="bold"> (b)</emphasis> Slice for          <emphasis
            role="bold">(c)</emphasis> Slice for
                           statement [9]           statement [10]</programlisting></para>

      <para>The initial program is given as (a). The slice with statement [9]
      as slicing criterion is shown in (b): statements <literal>[4]</literal>
      and <literal>[7]</literal> are irrelevant for computing statement
      <literal>[9]</literal> and do not occur in the slice. Similarly, (c)
      shows the slice with statement <literal>[10]</literal> as slicing
      criterion. This particular form of slicing is called <emphasis>backward
      slicing</emphasis>. Slicing can be used for debugging and program
      understanding, optimization and more. An overview of slicing techniques
      and applications can be found in <xref linkend="Tip95" />. Here we will
      explore a relational formulation of slicing adapted from a proposal in
      <xref linkend="JacksonRollins94" />J. The basic ingredients of the
      approach are as follows:</para>

      <itemizedlist>
        <listitem>
          <para>We assume the relations <literal>PRED</literal>,
          <literal>DEFS</literal> and <literal>USES</literal> as
          before.</para>
        </listitem>

        <listitem>
          <para>We assume an additional set
          <literal>CONTROL-STATEMENT</literal> that defines which statements
          are control statements.</para>
        </listitem>

        <listitem>
          <para>To tie together dataflow and control flow, three auxiliary
          variables are introduced:</para>

          <itemizedlist>
            <listitem>
              <para>The variable <literal>TEST</literal> represents the
              outcome of a specific test of a conditional statement. The
              conditional statement defines <literal>TEST</literal> and all
              statements that are control dependent on this conditional
              statement will use <literal>TEST</literal>.</para>
            </listitem>

            <listitem>
              <para>The variable <literal>EXEC</literal> represents the
              potential execution dependence of a statement on some
              conditional statement. The dependent statement defines
              <literal>EXEC</literal> and an explicit (control) dependence is
              made between <literal>EXEC</literal> and the corresponding
              <literal>TEST</literal>.</para>
            </listitem>

            <listitem>
              <para>The variable <literal>CONST</literal> represents an
              arbitrary constant.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>The calculation of a (backward) slice now proceeds in six
      steps:</para>

      <itemizedlist>
        <listitem>
          <para>Compute the relation <literal>rel[use,def] use-def</literal>
          that relates all uses to their corresponding definitions. The
          function <literal>reaching-definitions</literal> as shown earlier in
          <xref linkend="section.reaching-definitions" />does most of the
          work.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[def,use]
          def-use-per-stat</literal> that relates the
          <emphasis>internal</emphasis> definitions and uses of a
          statement.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[def,use]
          control-dependence</literal> that links all <literal>EXEC</literal>s
          to the corresponding <literal>TEST</literal>s.</para>
        </listitem>

        <listitem>
          <para>Compute the relation <literal>rel[use,def]
          use-control-def</literal> combines use/def dependencies with control
          dependencies.</para>
        </listitem>

        <listitem>
          <para>After these preparations, compute the relation
          <literal>rel[use,use] USE-USE</literal> that contains dependencies
          of uses on uses.</para>
        </listitem>

        <listitem>
          <para>The backward slice for a given slicing criterion (a use) is
          now simply the projection of <literal>USE-USE</literal> for the
          slicing criterion.</para>
        </listitem>
      </itemizedlist>

      <para>This informal description of backward slicing can now be expressed
      in Rscript:</para>

      <para><programlisting>set[use] BackwardSlice(
    set[stat] CONTROL-STATEMENT, 
    rel[stat,stat] PRED,
    rel[stat,var] USES,
    rel[stat,var] DEFS,    
    use Criterion) 
= USE-USE[Criterion]

where
    rel[stat, def] REACH = reaching-definitions(DEFS, PRED)

    rel[use,def] use-def = 
       { &lt;&lt;S1,V&gt;, &lt;S2,V&gt;&gt; | &lt;stat S1, var V&gt; : USES, 
                            &lt;stat S2, V&gt; : REACH[S1]
       }

    rel[def,use] def-use-per-stat  = 
       {&lt;&lt;S,V1&gt;, &lt;S,V2&gt;&gt; | &lt;stat S, var V1&gt; : DEFS, 
                           &lt;S, var V2&gt; : USES
       }
             union
       {&lt;&lt;S,V&gt;, &lt;S,"EXEC"&gt;&gt; | &lt;stat S, var V&gt; : DEFS}
             union
       {&lt;&lt;S,"TEST"&gt;,&lt;S,V&gt;&gt; | stat S : CONTROL-STATEMENT, 
                             &lt;S, var V&gt; : domainR(USES, {S})
       }

    rel[stat, stat] CONTROL-DOMINATOR = 
       domainR(dominators(PRED), CONTROL-STATEMENT)

    rel[def,use] control-dependence  =
       { &lt;&lt;S2, "EXEC"&gt;,&lt;S1,"TEST"&gt;&gt; | 
         &lt;stat S1, stat S2&gt; : CONTROL-DOMINATOR
       }

    rel[use,def] use-control-def = use-def union control-dependence

    rel[use,use] USE-USE = (use-control-def o def-use-per-stat)*

endwhere</programlisting></para>

      <para>Let's apply this to the example from the start of this section and
      assume the following:<programlisting>rel[stat,stat] PRED = { &lt;1,2&gt;, &lt;2,3&gt;, &lt;3,4&gt;, &lt;4,5&gt;, &lt;5,6&gt;, &lt;5,9&gt;, 
                        &lt;6,7&gt;, &lt;7,8&gt;,&lt;8,5&gt;, &lt;8,9&gt;, &lt;9,10&gt;
                      }

rel[stat,var] DEFS  = { &lt;1, "n"&gt;, &lt;2, "i"&gt;, &lt;3, "sum"&gt;, 
                        &lt;4,"product"&gt;, &lt;6, "sum"&gt;, &lt;7, "product"&gt;, 
                        &lt;8, "i"&gt;
                      }

rel[stat,var] USES  = { &lt;5, "i"&gt;, &lt;5, "n"&gt;, &lt;6, "sum"&gt;, &lt;6,"i"&gt;,
                        &lt;7, "product"&gt;, &lt;7, "i"&gt;, &lt;8, "i"&gt;, 
                        &lt;9, "sum"&gt;, &lt;10, "product"&gt;
                      }

set[int] CONTROL-STATEMENT = { 5 }</programlisting> The result of the
      slice<programlisting>BackwardSlice(CONTROL-STATEMENT, PRED, USES, DEFS, &lt;9, "sum"&gt;)</programlisting>will
      then be<programlisting> { &lt;1, "EXEC"&gt;, &lt;2, "EXEC"&gt;,  &lt;3, "EXEC"&gt;, &lt;5, "i"&gt;, &lt;5, "n"&gt;,  
   &lt;6, "sum"&gt;, &lt;6, "i"&gt;, &lt;6, "EXEC"&gt;, &lt;8, "i"&gt;, &lt;8, "EXEC"&gt;, 
   &lt;9, "sum"&gt; }</programlisting> Take the domain of this result and we
      get exactly the statements in (b) of the example.</para>
    </section>
  </section>

  <section xml:id="section-extracting-facts">
    <title>Extracting Facts from Source Code</title>

    <para>In this tutorial we have, so far, concentrated on querying and
    enriching facts that have been extracted from source code. As we have seen
    from the examples, once these facts are available, a concise Rscript
    suffices to do the required processing. But how is fact extraction
    achieved and how difficult is it? To answer these questions we first
    describe the workflow of the fact extraction process (<xref
    linkend="section.workflow-fact-extraction" />) and give strategies for
    fact extraction (<xref
    linkend="section.strategies-fact-extraction" />).</para>

    <para><figure xml:id="figure.extract-workflow">
        <title>Workflow for fact extraction</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="extract-workflow.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure></para>

    <section xml:id="section.workflow-fact-extraction">
      <title>Workflow for Fact Extraction</title>

      <para><xref linkend="figure.extract-workflow" /> shows a typical
      workflow for fact extraction for a <emphasis>System Under
      Investigation</emphasis> (SUI). It assumes that the SUI uses only
      <emphasis>one</emphasis> programming language and that you need only one
      grammar. In realistic cases, however, several such grammars may be
      needed. The workflow consists of three main phases:</para>

      <itemizedlist>
        <listitem>
          <para>Grammar: Obtain and improve the grammar for the source
          language of the SUI.</para>
        </listitem>

        <listitem>
          <para>Facts: Obtain and improve facts extracted from the SUI.</para>
        </listitem>

        <listitem>
          <para>Queries: Write and improve queries that give the desired
          answers.</para>
        </listitem>
      </itemizedlist>

      <para>Of course, it may happen that you have a lucky day and that
      extracted facts are readily available or that you can reuse a good
      quality fact extractor that you can apply to the SUI. On ordinary days
      you have the above workflow as fall-back. It may come as a surprise that
      there is such a strong emphasis on validation in this workflow. The
      reason is that the SUI is usually a huge system that defeats manual
      inspection. Therefore we must be very careful that we validate the
      outcome of each phase.</para>

      <formalpara>
        <title>Grammar</title>

        <para>In many cases there is no canned grammar available that can be
        used to parse the programming language dialect used in the SUI.
        Usually an existing grammar can be adjusted to that dialect, but then
        it is then mandatory to validate that the adjusted grammar can be used
        to parse the sources of the SUI.</para>
      </formalpara>

      <formalpara>
        <title>Facts</title>

        <para>It may happen that the facts extracted from the source code are
        <emphasis>wrong</emphasis>. Typical error classes are:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para>Extracted facts are <emphasis>wrong</emphasis>: the extracted
          facts incorrectly state that procedure <literal>P</literal> calls
          procedure <literal>Q</literal> but this is contradicted by a source
          code inspection.</para>
        </listitem>

        <listitem>
          <para>Extracted facts are <emphasis>incomplete</emphasis>: the
          inheritance between certain classes in Java code is missing.</para>
        </listitem>
      </itemizedlist>

      <para>The strategy to validate extracted facts differ per case but here
      are three strategies:</para>

      <itemizedlist>
        <listitem>
          <para>Postprocess the extracted facts (using Rscript, of course) to
          obtain trivial facts about the source code such as total lines of
          source code and number of procedures, classes, interfaces and the
          like. Next validate these trivial facts with tools like
          <literal>wc</literal> (word and line count), <literal>grep</literal>
          (regular expression matching) and others.</para>
        </listitem>

        <listitem>
          <para>Do a manual fact extraction on a small subset of the code and
          compare this with the automatically extracted facts.</para>
        </listitem>

        <listitem>
          <para>Use another tool on the same source and compare results
          whenever possible. A typical example is a comparison of a call
          relation extracted with different tools.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Queries</title>

        <para>For the validation of the answers to the queries essentially the
        same approach can be used as for validating the facts. Manual checking
        of answers on random samples of the SUI may be mandatory. It also
        happens frequently that answers inspire new queries that lead to new
        answers, and so on.</para>
      </formalpara>
    </section>

    <section xml:id="section.strategies-fact-extraction">
      <title>Strategies for Fact Extraction</title>

      <para>The following global scenario's are available when writing a fact
      extractor:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Dump-and-Merge</emphasis>: Parse each source file,
          extract the relevant facts, and return the resulting (partial)
          Rstore. In a separate phase, merge all the partial Rstores into a
          complete Rstore for the whole SUI. The tool {\tt merge-rstores} is
          available for this.</para>
        </listitem>

        <listitem>
          <para><emphasis>Extract-and-Update</emphasis>: Parse each source
          file, extract the relevant facts, and add these directly to the
          partial Rstore that has been constructed for previous source
          files.</para>
        </listitem>
      </itemizedlist>

      <para>The experience is that the <emphasis>Extract-and-Update</emphasis>
      is more efficient. A second consideration is the scenario used for the
      fact extraction per file. Here there are again two possibilities:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>All-in-One</emphasis>: Write one function that
          extracts all facts in one traversal of the source file. Typically,
          this function has an Rstore as argument and returns an Rstore as
          well. During the visit of specific language constructs additions are
          made to named sets or relations in the Rstore.</para>
        </listitem>

        <listitem>
          <para><emphasis>Separation-of-Concerns</emphasis>: Write a separate
          function for each fact you want to extract. Typically, each function
          takes a set or relation as argument and returns an updated version
          of it. At the top level all these functions are called and their
          results are put into an Rstore. This strategy is illustrated in
          <xref linkend="figure.separation-of-concerns" />.</para>
        </listitem>
      </itemizedlist>

      <para>The experience here is that everybody starts with the
      <emphasis>All-in-One</emphasis> strategy but that the complexities of
      the interactions between the various fact extraction concerns soon start
      to hurt. The advice is therefore to use the
      <emphasis>Separation-of-Concerns</emphasis> strategy even if it may be
      seem to be less efficient since it requires a traversal of the source
      program for each extracted set or relation.</para>

      <figure xml:id="figure.separation-of-concerns">
        <title>Separation-of-Concerns strategy for fact extraction</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="sep-of-concerns.png" scale="50"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="section.fact-extraction-asf-sdf">
      <title>Fact Extraction using ASF+SDF</title>

      <para>Although facts can be extracted in many ways, ASF+SDF is the tool
      of preference to do this. Examples are given In XXX.<warning>
          <para>Fix reference</para>
        </warning></para>

      <para><!--\section{Fact Extraction using ASF+SDF} \label{SEC:ASF+SDF-extraction}



\subsection{Extracting Facts for Pico}


\begin{figure}[tb]
{\small
\begin{verbatim}
module PicoFactExtraction
imports Pico-syntax
imports basic/Integers
imports Rstore
imports utilities/PosInfo[PROGRAM] utilities/PosInfo[STATEMENT]
        utilities/PosInfo[EXP] utilities/PosInfo[PICO-ID]
exports
  context-free syntax
    cflow({ STATEMENT ";"}*)     -> <Set[[Elem]], Rel[[Elem]], Set[[Elem]]>

    uses(PROGRAM, Rel[[Elem]])   -> Rel[[Elem]] {traversal(accu,top-down,continue)}
    uses(EXP, Rel[[Elem]])       -> Rel[[Elem]] {traversal(accu,top-down,continue)}

    defs(PROGRAM, Rel[[Elem]])   -> Rel[[Elem]] {traversal(accu,top-down,break)}
    defs(STATEMENT, Rel[[Elem]]) -> Rel[[Elem]] {traversal(accu,top-down,break)}

    id2str(PICO-ID)              -> String
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction.sdf}Syntax of functions for Pico fact extraction}
\end{figure}

After all these mental preparations, we are now ready to delve into the details
of a Pico fact extractor. Figure~\ref{FIG:PicoFactExtraction.sdf} shows the
syntax of the functions that we will need for Pico fact extraction. There are
some things to observe:
\begin{itemize}
\item Module {\tt Pico-syntax} is imported to make available the Pico
  grammar.
\item Module {\tt Rstore} is imported to get access to all functions on
  Rstores.
\item The module {\tt PosInfo} is imported with various sort names as
  parameter. For all these sorts, the function {\tt get-location} will be
  defined that extracts the source text location from a given language
  construct.
\item The function {\tt cflow} will extract the control flow from Pico
  programs.
\item The functions {\tt uses} and {\tt defs} extracts the uses and
  definitions of variables from the source text.
\item {\tt id2str} is an auxiliary function that converts Pico identifiers to
  strings that can be included in an Rstore.
\item We have omitted all declarations for ASF+SDF variables to be used in the
  specification. The convention is that such variables all start with a dollar
  sign ({\tt \$}).
\end{itemize}

\begin{figure}[tb]
{\small 
\begin{verbatim}
%%  control flow of statement lists
[cf1] <$Entry1, $Rel1, $Exit1> := cflow($Stat),
      <$Entry2, $Rel2, $Exit2> := cflow($Stat+)
       ==========================================================
       cflow($Stat ; $Stat+) =
       < $Entry1,
         $Rel1 union $Rel2 union ($Exit1 x $Entry2),
         $Exit2
       >
[cf2] cflow() = <{}, {}, {}>

%%  control flow of individual statements
[cf3]  <$Entry, $Rel, $Exit> := cflow($Stat*),
       $Control := get-location($Exp)
       =========================================================
       cflow(while $Exp do $Stat* od) =
       < {$Control},
         ({$Control} x $Entry) union $Rel union ($Exit x {$Control}),
         {$Control}
       >

[cf4]  <$Entry1, $Rel1, $Exit1> := cflow($Stat*1),
       <$Entry2, $Rel2, $Exit2> := cflow($Stat*2),
       $Control := get-location($Exp)
       =========================================================
       cflow(if $Exp then $Stat*1 else $Stat*2 fi) =
       < {$Control},
         ({$Control} x $Entry1) union ({$Control} x $Entry2) 
                                union  $Rel1 union $Rel2,
         $Exit1 union $Exit2
       >
[default-cf]
        $Loc := get-location($Stat)
       =========================================================
        cflow($Stat) = < {$Loc}, {}, {$Loc} >
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction-cflow}Equations for {\tt cflow}: computing control flow}
\end{figure}

\begin{figure}[tb]
{\small
\begin{verbatim}

%%  Variable definitions: <expression-location, var-name>

[vd1]  $Id := $Exp := $Stat
       ==========================================================
       defs($Stat, $Rel) = $Rel union {<get-location($Stat), id2str($Id)>}

%%  Variable uses <var-location, var-name>

[vu1]  $Id := $Exp
       ==========================================================
       uses($Exp, $Rel) = $Rel union  {<get-location($Id), id2str($Id)>}

%%  utilities

[i2s] id2str(pico-id($Char*)) = strcon(""" $Char* """)

\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction-defs-uses}Equations for {\tt defs}, {\tt uses} and
  {\tt id2str}}
\end{figure}


\begin{figure}[tb]
{\small
\begin{verbatim}
module PicoQuery
imports RscriptCalculator
imports PicoFactExtraction
imports basic/Errors

exports
  start-symbols Summary
  context-free syntax
     extractRelations(PROGRAM)                   -> RSTORE
     pico-query(RSCRIPT, RSTORE, StrCon, StrCon) -> Summary
     uninit(PROGRAM)                             -> Summary
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoQuery.sdf}Syntax of function for two styles of querying}
\end{figure}

\begin{figure}[tb]
{\small
\begin{verbatim}
%%  extractRelations

[er-1] begin $Decls $Stat+ end := $Program,
       $Start := get-location($Program),
       <$Entry, $Rel, $Exit> := cflow($Stat+),

       $Loc :=  get-location($Program),
       $Rstore1 := assign(ROOT, expr, $Loc, rstore()),
       $Rstore2 := assign(PRED, rel[expr,expr],
                                $Rel union ({$Start} x $Entry), $Rstore1),
       $Rstore3 := assign(DEFS, rel[expr,varname], defs($Program, {}), $Rstore2),
       $Rstore4 := assign(USES, rel[var,varname], uses($Program, {}), $Rstore3)
       ==========================================================================
       extractRelations($Program) = $Rstore4

%%  pico-query

[pq1]  pico-query($Script, $Rstore, $StrCon1, $StrCon2) =
       convert2summary(
          $StrCon2,
          eval-rscript-with-rstore-and-yield($Script, $Rstore, $StrCon1)
       )
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction-extractRelations}Build an Rstore with
  {\tt extractRelations} and apply it using {\tt pico-query}}
\end{figure}

\begin{figure}[tb]
{\small
\begin{verbatim}
[ui-1] begin $Decls $Stat+ end := $Program,
       $Start := get-location($Program),
       <$Entry, $Rel, $Exit> := cflow($Stat+),
       $Rel1 := $Rel union ({$Start} x $Entry),
       $Rval := [| type expr = loc
                   type var  = loc
                   type varname = str

                   expr ROOT = $Start

                   rel[expr,expr] PRED = $Rel1
                   rel[expr,varname] DEFS  = defs($Program, {})
                   rel[var,varname] USES  = uses($Program, {})
                   set[varname] VARNAMES  = range(DEFS) union range(USES)

                   rel[var, varname] UNINIT =
                   { <V, VN>| var-name VN : VARNAMES,
                              var V : USES[-,VN],
                              expr E : reachX({ROOT}, DEFS[-,VN], PRED),
                              V <= E
                   }

                |] yield UNINIT
       ===================================================================
       uninit($Program) = convert2summary("Uninitialized variable", $Rval)            
\end{verbatim}
}
\hrulefill
\caption{\label{FIG:PicoFactExtraction-uninit}Combined fact extraction and
  query processing}
\end{figure}

\paragraph{Extracting control flow}
The function {\tt cflow} extracts the control flow from Pico programs. It
takes a list of statements as input and returns a triple as output:
\begin{itemize}
\item A set of program elements that may enter a construct.
\item A relation between the entries and exits of a construct.
\item A set of program elements that form the exits from the construct.
\end{itemize}
For instance, the test in an if-then-else statement forms the entry of the
statement, it is connected to the entry of the first statement of the then and
the else branch. The exits of the if-then-else statement are the exits of the
last statement in the then and the else branch. The purpose of {\tt cflow} is
to determine this information for individual statements and to combine this
information for compound statements. Its definition is shown in
Figure~\ref{FIG:PicoFactExtraction-cflow}.

\paragraph{Extracting uses and defs}
The functions {\tt defs} and {\tt uses} are shown in
Figure~\ref{FIG:PicoFactExtraction-defs-uses}.  They extract the definition,
respectively, the use of variables from the source code. Both functions are
defined by means of an ASF+SDF \emph{traversal function} which silently visits
all constructs in a tree, and only performs an action for the constructs for
which the specification contains an equation. In the case of {\tt defs},
equation {\tt [vd1]} operations on assignment statements and extracts a pair
that relates the location of the complete statement to the name of the
variable on the left-hand side. For the function {\tt uses}, equation {\tt
[vu1]} acts on all uses of variables. For completeness sake, the figure also
show the definition of utility function {\tt id2str}.

\paragraph{Queries}
Figure~\ref{FIG:PicoQuery.sdf} shows the syntax of the functions we will use
for querying. In fact, we will demonstrate two styles of definition.  In the
first style, the function {\tt extractRelation} extracts facts from a Pico
program and yields an Rstore. This can be used by {\tt pico-query} to run an
arbitrary \rscript on that Rstore. In the second style, fact extraction and
running an \rscript are done in a single function.

Figure~\ref{FIG:PicoFactExtraction-extractRelations} shows the first
definition style. In equation {\tt [er1]}, we see a step-by-step construction
of an Rstore that contains all the information gathered by the extraction
functions. An Rstore that contains all this information is returned as result
of {\tt extractRelations}. The function {\tt pico-query} can then be used to
run an \rscript for a given Rstore.

The second definition style is shown in
Figure~\ref{FIG:PicoFactExtraction-uninit}.  In this case, we see that all
work is done in a single (indeed large) equation. The construct {\tt [| ... |]
yield UNINIT} is particularly noteworthy since it allows the embedding of a
complete \rscript in an ASF+SDF equation. Also pay attention to the following:

\begin{itemize}

\item The \rscript is first simplified as much as possible according to
  ordinary ASF+SDF simplification rules. This implies that variables like {\tt
  \$Start}, {\tt \$Rel1}, and {\tt \$Program} are replaced by their respective
  values. This is also the case for the functions {\tt defs} and {\tt uses}
  that occur in the \rscript.

\item The  effect of the {\tt [| ... |] yield UNINIT} construct is that the
  \rscript is evaluated and that the value of {\tt UNINIT} is returned as
  result.

\item The definition of the function {\tt convert2summary} is not shown: it
  performs a straightforward conversion of {\tt UNINIT}'s value to the message
  format ({\tt Summary}) that is used by the Meta-Environment.

\end{itemize}--></para>
    </section>

    <section>
      <title>Concluding remarks</title>

      <para>It is not unusual that the effort that is needed to write a fact
      extractor is much larger than the few lines of Rscript that are
      sufficient for the further processing of these facts. What can we learn
      from this observation? First, that even in simple cases fact extraction
      is more complicated than the processing of these facts. This may be due
      to the following:</para>

      <itemizedlist>
        <listitem>
          <para>The facts we are interested in may be scattered over different
          language constructs. This implies that the fact extractor has to
          cover all these cases.</para>
        </listitem>

        <listitem>
          <para>The extracted facts are completely optimized for relational
          processing but places a burden on the fact extractor to perform this
          optimization.</para>
        </listitem>
      </itemizedlist>

      <para>Second, that several research questions remain unanswered:</para>

      <itemizedlist>
        <listitem>
          <para>Is it possible to solve (parts of) the fact extraction in a
          language-parametric way. In other words, is it possible to define
          generic extraction methods that apply to multiple languages?</para>
        </listitem>

        <listitem>
          <para>Is a further integration of fact extraction with relational
          processing desirable? Is it, for instance, useful to bring some of
          the syntactic program domains like expressions and statements to the
          relational domain?</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.table-builtin-operators">
    <title>Table of Built-in Operators</title>

    <para><table>
        <title>Table of Built-in Operators</title>

        <?dbfo keep-together="auto" ?>

        <tgroup cols="3">
          <colspec align="left" />

          <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

          <colspec align="left" colname="col2" colnum="2" colwidth="3*" />

          <colspec align="left" colname="col3" colnum="3" colwidth="1*" />

          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Description</entry>

              <entry>Section</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>and</literal></entry>

              <entry>Boolean and</entry>

              <entry><xref linkend="section.builtin-operator-bool"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>implies</literal></entry>

              <entry>Boolean implication</entry>

              <entry><xref linkend="section.builtin-operator-bool"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>in</literal></entry>

              <entry>Membership test on sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>inter</literal></entry>

              <entry>Intersection of sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>not</literal></entry>

              <entry>Boolean negation</entry>

              <entry><xref linkend="section.builtin-operator-bool"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>notin</literal></entry>

              <entry>Non-membership test on sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>or</literal></entry>

              <entry>Boolean or</entry>

              <entry><xref linkend="section.builtin-operator-bool"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>union</literal></entry>

              <entry>Union of sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>==</literal></entry>

              <entry>Equality of integers</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>==</literal></entry>

              <entry>Equality of strings</entry>

              <entry><xref linkend="section.builtin-operator-str"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>==</literal></entry>

              <entry>Equality of locations</entry>

              <entry><xref linkend="section.builtin-operator-loc"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>==</literal></entry>

              <entry>Equality of sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>!=</literal></entry>

              <entry>Inequality of integers</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>!=</literal></entry>

              <entry>Inequality of strings</entry>

              <entry><xref linkend="section.builtin-operator-str"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>!=</literal></entry>

              <entry>Inequality of locations</entry>

              <entry><xref linkend="section.builtin-operator-loc"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>!=</literal></entry>

              <entry>Inequality of sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&lt;=</literal></entry>

              <entry>Less than or equal of integers</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&lt;=</literal></entry>

              <entry>Less than or equal of strings</entry>

              <entry><xref linkend="section.builtin-operator-str"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&lt;=</literal></entry>

              <entry>Textual inclusion of locations</entry>

              <entry><xref linkend="section.builtin-operator-loc"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&lt;=</literal></entry>

              <entry>Subset of sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&lt;</literal></entry>

              <entry>Less than of integers</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&lt;</literal></entry>

              <entry>Less than of strings</entry>

              <entry><xref linkend="section.builtin-operator-str"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&lt;</literal></entry>

              <entry>Strict textual inclusion of locations</entry>

              <entry><xref linkend="section.builtin-operator-loc"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&lt;</literal></entry>

              <entry>Strict subset of sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&gt;=</literal></entry>

              <entry>Greater than or equal of integer</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&gt;=</literal></entry>

              <entry>Greater than or equal of strings</entry>

              <entry><xref linkend="section.builtin-operator-str"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&gt;=</literal></entry>

              <entry>Textual containment of locations</entry>

              <entry><xref linkend="section.builtin-operator-loc"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&gt;=</literal></entry>

              <entry>Superset of sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&gt;</literal></entry>

              <entry>Greater than of integers</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&gt;</literal></entry>

              <entry>Greater than of strings</entry>

              <entry><xref linkend="section.builtin-operator-str"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&gt;</literal></entry>

              <entry>Strict textual containment of locations</entry>

              <entry><xref linkend="section.builtin-operator-loc"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>&gt;</literal></entry>

              <entry>Strict superset of sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>+</literal></entry>

              <entry>Addition of integers</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>_</literal></entry>

              <entry>Subtraction of integers</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>*</literal></entry>

              <entry>Multiplication of integers</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>/</literal></entry>

              <entry>Division of integers</entry>

              <entry><xref linkend="section.builtin-operator-int"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>\</literal></entry>

              <entry>Difference of sets/relations</entry>

              <entry><xref linkend="section.builtin-operator-set-or-rel"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>o</literal></entry>

              <entry>Composition of relations</entry>

              <entry><xref linkend="section.builtin-operator-relations"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>x</literal></entry>

              <entry>Carthesian product of sets</entry>

              <entry><xref linkend="section.builtin-operator-relations"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>#</literal></entry>

              <entry>Number of elements of set/relation</entry>

              <entry><xref linkend="section.builtin-operator-misc"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>[-, ]</literal></entry>

              <entry>Left image of relation</entry>

              <entry><xref linkend="section.builtin-operator-relations"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>[ ,-]</literal></entry>

              <entry>Right image of relation</entry>

              <entry><xref linkend="section.builtin-operator-relations"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>[ ]</literal></entry>

              <entry>Right image of relation</entry>

              <entry><xref linkend="section.builtin-operator-relations"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>+</literal></entry>

              <entry>Transitive closure of a relation</entry>

              <entry><xref linkend="section.builtin-operator-relations"
              xrefstyle="template:%n" /></entry>
            </row>

            <row>
              <entry><literal>*</literal></entry>

              <entry>Reflexive transitive closure of a relation</entry>

              <entry><xref linkend="section.builtin-operator-relations"
              xrefstyle="template:%n" /></entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <para></para>

    <para></para>
  </section>

  <section xml:id="section.table-builtin-functions">
    <title>Table of Built-in Functions</title>

    <para></para>

    <table>
      <title>Table of Built-in Functions</title>

      <?dbfo keep-together="auto" keep-column-together="auto"?>

      <tgroup cols="3">
        <colspec align="left" />

        <colspec align="left" colname="col1" colnum="1" colwidth="1*" />

        <colspec align="left" colname="col2" colnum="2" colwidth="2*" />

        <colspec align="left" colname="col3" colnum="3" colwidth="1*" />

        <thead>
          <row>
            <entry>Function</entry>

            <entry>Description</entry>

            <entry>Section</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>average</literal></entry>

            <entry>Average of a set of integers</entry>

            <entry><xref linkend="section.builtin-function-average"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>average-domain</literal></entry>

            <entry>Average of first elements of tuples in relation</entry>

            <entry><xref linkend="section.builtin-function-average-domain"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>average-range</literal></entry>

            <entry>Average of second elements of tuples in relation</entry>

            <entry><xref linkend="section.builtin-function-average-domain"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>begincol</literal></entry>

            <entry>First column of a location</entry>

            <entry><xref linkend="section.builtin-function-begincol"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>beginline</literal></entry>

            <entry>Beginning line of a location</entry>

            <entry><xref linkend="section.builtin-function-beginline"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>bottom</literal></entry>

            <entry>Bottom of a relation</entry>

            <entry><xref linkend="section.builtin-function-bottom"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>carrier</literal></entry>

            <entry>Carrier of a relation</entry>

            <entry><xref linkend="section.builtin-function-carrier"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>carrierR</literal></entry>

            <entry>Carrier restriction of a relation</entry>

            <entry><xref linkend="section.builtin-function-carrierR"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>carrierX</literal></entry>

            <entry>Carrier exclusion of a relation</entry>

            <entry><xref linkend="section.builtin-function-carrierX"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>compl</literal></entry>

            <entry>Complement of a relation</entry>

            <entry><xref linkend="section.builtin-function-compl"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>endcol</literal></entry>

            <entry>Last column of a location</entry>

            <entry><xref linkend="section.builtin-function-endcol"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>endline</literal></entry>

            <entry>Ending line of a location</entry>

            <entry><xref linkend="section.builtin-function-endline"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>filename</literal></entry>

            <entry>File name of a location</entry>

            <entry><xref linkend="section.builtin-function-filename"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>first</literal></entry>

            <entry>First element of a tuple</entry>

            <entry><xref linkend="section.builtin-function-first"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>id</literal></entry>

            <entry>Identity relation</entry>

            <entry><xref linkend="section.builtin-function-id"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>inv</literal></entry>

            <entry>Inverse of a relation</entry>

            <entry><xref linkend="section.builtin-function-inv"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>domain</literal></entry>

            <entry>Domain of a relation</entry>

            <entry><xref linkend="section.builtin-function-domain"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>domainR</literal></entry>

            <entry>Domain restriction of a relation</entry>

            <entry><xref linkend="section.builtin-function-domainR"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>domainX</literal></entry>

            <entry>Domain exclusion of a relation</entry>

            <entry><xref linkend="section.builtin-function-domainX"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>min</literal></entry>

            <entry>Minimum of a set of integers</entry>

            <entry><xref linkend="section.builtin-function-min"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>max</literal></entry>

            <entry>Maximum of a set of integers</entry>

            <entry><xref linkend="section.builtin-function-max"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>power0</literal></entry>

            <entry>Powerset of a set</entry>

            <entry><xref linkend="section.builtin-function-power0"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>power1</literal></entry>

            <entry>Powerset of a set</entry>

            <entry><xref linkend="section.builtin-function-power1"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>range</literal></entry>

            <entry>Range of a relation</entry>

            <entry><xref linkend="section.builtin-function-range"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>rangeR</literal></entry>

            <entry>Range restriction of a relation</entry>

            <entry><xref linkend="section.builtin-function-rangeR"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>rangeX</literal></entry>

            <entry>Range exclusion of a relation</entry>

            <entry><xref linkend="section.builtin-function-rangeX"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>reachR</literal></entry>

            <entry>Reachability with restriction</entry>

            <entry><xref linkend="section.builtin-function-reachR"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>reachX</literal></entry>

            <entry>Reachability with exclusion</entry>

            <entry><xref linkend="section.builtin-function-reachX"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>second</literal></entry>

            <entry>Second element of a tuple</entry>

            <entry><xref linkend="section.builtin-function-second"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>sum</literal></entry>

            <entry>Sum of a set of integers</entry>

            <entry><xref linkend="section.builtin-function-sum"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>sum-domain</literal></entry>

            <entry>Sum of first elements of tuples in relation</entry>

            <entry><xref linkend="section.builtin-function-sum-domain"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>sum-range</literal></entry>

            <entry>Sum of a first elements of tuples in relation</entry>

            <entry><xref linkend="section.builtin-function-sum-range"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>top</literal></entry>

            <entry>Top of a relation</entry>

            <entry><xref linkend="section.builtin-function-top"
            xrefstyle="template:%n" /></entry>
          </row>

          <row>
            <entry><literal>unique</literal></entry>

            <entry>Deprecated: Set with unique elements</entry>

            <entry><xref linkend="section.builtin-function-unique"
            xrefstyle="template:%n" /></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para></para>
  </section>

  <section xml:id="section.rscript-bibliography">
    <title>Bibliography</title>

    <para><bibliolist>
        <bibliomixed xml:id="AhoSethiUllman86"></bibliomixed>

        <bibliomixed xml:id="BNL03"></bibliomixed>

        <bibliomixed xml:id="Dot96"></bibliomixed>

        <bibliomixed xml:id="FeijsKrikhaarOmmering98"></bibliomixed>

        <bibliomixed xml:id="Holt96"></bibliomixed>

        <bibliomixed xml:id="JacksonRollins94"></bibliomixed>

        <bibliomixed xml:id="KlintIWPC03"></bibliomixed>

        <bibliomixed xml:id="Krikhaar99"></bibliomixed>

        <bibliomixed xml:id="McCabe76"></bibliomixed>

        <bibliomixed xml:id="Mueller88"></bibliomixed>

        <bibliomixed xml:id="Tip95"></bibliomixed>

        <bibliomixed xml:id="Weiser84"></bibliomixed>
      </bibliolist></para>
  </section>

  <!--




\chapter{Installing and Running \rscript} \label{SEC:running-rscript}

\begin{figure}[h]
\begin{center}
\epsfig{figure=figs/ruhmkorff.ps,width=15cm} \label{FIG:ruhmkorff}
\end{center}
\end{figure}

\section{Warning}
The information in the current chapter is outdated. As of august 2007, the
most convenient way to use \rscript is to use \texttt{rscript-meta}, an
instance of The Meta-Environment specialized for \rscript. It can be
downloaded (in binary and source form) from
\url{http://www.meta-environment.org}.

\section{Installing \rscript}
\rscript is available\footnote{\url{www.cwi.nl/projects/MetaEnv/...}}
as \texttt{relation-calculus-0.4.tar.gz} (or a newer version).  It
requires a recent version (e.g. at least 1.5.3) of the ASF+SDF
Meta-Environment to run.  A typical installation session on a typical
Unix/Linux system consists of the following steps:

\begin{itemize}

\item Extract all files from the distribution:
  \texttt{tar zxvf relation-calculus-0.4.tar.gz}
This command uncompresses the distribution file, creates a subdirectory
\texttt{relation-calculus-0.4} and places all directories and files
from the distribution in it.

\item Change to the new directory:
  \texttt{cd relation-calculus-0.4}
\item Configure the sources: \texttt{./configure}

\item Build and install application: \texttt{make install}

\end{itemize}

See the files \texttt{INSTALL} and \texttt{README} for more specific
installation instructions.


\section{Running \rscript from the command line} \label{SEC:running-commandline}

\subsection{File extensions}
The following file extensions are used by the command line tools:

\begin{itemize}

\item \texttt{.rscript} is the required file name extension for files that contain an \rscript.

\item \texttt{.rstore} is the required file name extension for files
that contain an rstore.  As intermediate result rstores also occur in
parsed form and then have the extension \texttt{.rstore.pt}. The tools
transparently accept rstores in both forms.

\item \texttt{.rviz} is the required file name extension for files that
contain relational data that are to be visualized (see
Chapter~\ref{SEC:Visualization}).

\end{itemize}

\subsection{\texttt{rscript}: check and execute an rscript}
The command \texttt{rscript} takes care of parsing, typechecking, and
executing an \rscript. Optionally, the script can only be checked, can
use a given rstore, be executed as test suite, or yield the value of a
given variable from the resulting rstore.

\begin{itemize}

\item \texttt{-c} or \texttt{-check-only}:
Only check the rscript for syntactic errors or typechecking errors
but do not execute it.

\item \texttt{-h} or \texttt{-help}; print help information.

\item \texttt{-i} \emph{name} or \texttt{-input} \emph{name}:
The \rscript to be processed is on file \emph{name}.
By default, the script is assumed to be on standard input.

\item \texttt{-o} \emph{name} or \texttt{-output-parse-tree} \emph{name}:
The result of the execution of the \rscript is an rstore and is written to file \emph{name}.
Note that this rstore is in the form of a parse tree.
By default, the resulting rstore is printed in textual form to standard output.

\item \texttt{-s} \emph{name} or \texttt{-store} \emph{name}:
The \rscript is executed using an initial rstore taken from file \emph{name}.
By default, the initial rstore is empty.


\item \texttt{-t} or \texttt{-testsuite}:
Execute the \rscript as a testsuite, i.e., execute all \texttt{assert} statements and report
which ones failed.

\item \texttt{-v} or \texttt{-verbose}: give verbose output.

\item \texttt{-y} \emph{name} or \texttt{-yield} \emph{name}:
Instead of producing a complete rstore as the result of executing the rscript,
only return the value of the variable \emph{name}.r
\end{itemize}

The following examples illustrate the use of the \texttt{rscript} command:

\begin{itemize}

\item  \texttt{rscript query.rscript} executes the script \texttt{query.rscript}
and prints the resulting rstore on standard output.

\item \texttt{rscript -i query.rscript -s previous.rstore -o result.rstore.pt}:
executes the same script, but uses \texttt{previous.rstore} as initial rstore
and writes the resulting store to \texttt{result.rstore.pt}>

\item \texttt{rscript -y nCalls calls.rscript}:
executes the script \texttt{calls.rscript} and prints the value of the variable \texttt{nCalls}
in the resulting rstore.

\item \texttt{rscript -t tests1.rscript}:
executes \texttt{tests2.rscript} as test suite and reports which assert
statements failed (if any).
\end{itemize}

\subsection{\texttt{extract-relations}: extract relations from source files} \label{SEC:extract-relations}

The command \texttt{extract-relations} provides a common framework for
\asfsdf-based fact extraction and has the following form:

\begin{exam}
\texttt{extract-relations [options] <input-files>}
\end{exam}

\noindent The following optional arguments are supported:

\begin{itemize}

\item \texttt{-h} or \texttt{-help}; print help information.

\item \texttt{-o} \emph{file} or \texttt{-output} \emph{file}: the name of
  the resulting rstore 
(default: \texttt{result.rstore.pt}).

\item \texttt{-e} \emph{program} or \texttt{-executable} \emph{program}: the
executable \emph{program} for performing extraction (default: none). This is most
likely to be a compiled \asfsdf specification.

\item \texttt{-s} \emph{sort} or \texttt{-sort} \emph{sort}:
\emph{sort} is the sort used for parsing each input file (default:
none). In other words, each input file should conform to the syntax of \emph{sort}.
Example: \texttt{CompilationUnit}.

\item \texttt{-f} \emph{name} or \texttt{-function} \emph{name}: the extraction function to be applied 
to each source file (default: \texttt{extractRelations}). The definition of
this function should conform to:
\begin{exam}
\texttt{extractRelations(}\emph{sort}\texttt{) -> RSTORE}
\end{exam}
where \emph{sort} is the sort of each input file as defined above.

\item \texttt{-p} \emph{file} or \texttt{-parse-table} \emph{file}: the parse table \emph{file} used for parsing input files (default: none).

\end{itemize}

\noindent The following examples illustrate the use of the \texttt{extract-relations} command:

\begin{itemize}

\item \texttt{extract-relations -e JavaAnalysis -s CompilationUnit -o
  jhotdraw.rstore.pt -p Java.trm.tbl dir/*.java}: extract relations from Java source
  code in the files \texttt{dir/*.java}. Use executable \texttt{JavaAnalysis}, each input file is of sort
  \texttt{CompilationUnit}, use parse table  \texttt{Java.trm.tbl}, and
  produce as output an rstore \texttt{jhotdraw.rstore.pt}.

\item
  \texttt{extract-relations -e TBExtr -s Tscript -p Tscript.trm.tbl *.tb}:
  extract relations from \TB source files. Use executable \texttt{TBExtr}, each input file is of
  sort \texttt{Tscript}, use parse table \texttt{Tscript.trm.tbl} and extract
  from the source files \texttt{*.tb}.

\end{itemize}


\subsection{\texttt{merge-rstores}: combine several rstores}

The command \texttt{merge-rstores} merges several rstores into a new
rstore.  This command is used in a scenario where an extraction tool
extracts facts from each source file in a software portfolio to be
analyzed and deposits these facts in a separate rstore per source
file.  When the complete portfolio is to be analyzed, the separate
rstores have to be merged into a single one. This merged rstore is then
used as initial rstore for the execution of some rscript.

The command has as arguments, a list of names of rstores to be merged.

The following optional arguments are supported:

\begin{itemize}
\item \texttt{-h} or \texttt{-help}: print help information.

\item \texttt{-o} \emph{name} or \texttt{-output} \emph{name}:
the name of the merged rstore is \emph{name}.
By default, the output is \texttt{result.rstore.pt}.
\note{tool should check for right output form}

\item \texttt{-v} or \texttt{-verbose}: give verbose output.

\end{itemize}

\section{Running \rscript Interactively} \label{SEC:running-interactive}
You can also edit and run Rscripts interactively:
\begin{itemize}
\item Change directory to your checked out copy of the directory {\tt relation-calculus/spec}.
\item Start the ASF+SDF Meta-Environment with the command {\tt meta}.
\item Open the module {\tt Rscript.sdf}.
\item Open your own term, using the {\tt Rscript} module.
\item Observe that a new menu with the name {\tt Rscript} appears in the menu bar.
\item Click the parse button in the {\tt Actions} menu of the editor:
now we know whether there are syntax errors. If so, correct them.

\item Click the {\tt Check} button in the {\tt Rscript} menu: this will
  perform a type check of your script. If there are type errors, correct them.

\item Click the {\tt Run} button in the {\tt Rscript} menu to execute your script: a new
editor pops up which shows all the variables at the end of the execution.
{\tt Run} also performs a type of your script so you may skip the previous step.

\item Click the {\tt Run with Rstore} button if you want to execute your
  \rscript with an existing ``Rstore'': a collection of relations that are the
  result of previous extraction phase. Currently, a fixed name is used for
  this Rstore: {\tt RSTORE.rstore}.

\end{itemize}

\paragraph{Running a Test suite} \label{running}
Same as above but use {\tt Testsuite} button instead of the {\tt Execute}
button in the {\tt Rscript} menu.  The effect is that the script is executed
and that a summary is printed of {\tt assert} statement that succeeded or
failed.

\section{Other Tools and Demos}

\subsection{Examples}

The subdirectory {\tt rscripts} contains several sample scripts.  See, for instance, {\tt
tests1.rscript} and {\tt tests2.rscript} for examples of the use of built-in
operators and functions.

\subsection{The Pico Demo}

The subdirectory {\tt demo/pico} contains in a single directory the
Pico syntax, Pico fact extraction (discussed in
Section~\ref{SEC:ASF+SDF-extraction}) and the test on uninitialized
variables presented in Section~\ref{SEC:uninit}.

\begin{itemize}

\item Change directory to \texttt{demo/pico}: \texttt{cd demo/pico}.

\item Start the \asfsdf Meta-Environment: \texttt{meta -m Pico-syntax.sdf}.

\item Open the term \texttt{exam.pico} over module \texttt{Pico-syntax.sdf}.

\item Under the \texttt{Pico} menu two styles of checking are available:
  \begin{itemize}
  \item Extract Relations: this extracts relations from the current Pico program.
  \item Uninitialized Vars (Style 1): uses the extracted facts and
  executes the \rscript \texttt{uninit.rscript}, see
  Figure~\ref{FIG:PicoFactExtraction-extractRelations}.
  \item Uninitialized Vars (Style 2): performs combined facts extraction and 
   query processing, see Figure~\ref{FIG:PicoFactExtraction-uninit}.
  \end{itemize}
  See Figure~\ref{FIG:meta-pico} for a screen dump.

\end{itemize}

\subsection{The Java Demo}

The Java demo consists of the following parts:

\begin{itemize}

\item \texttt{java/grammar}: Contains a SDF grammar for Java.

\item 
\begin{sloppypar}
\texttt{java/extraction}: defines \texttt{JavaAnalysis}, that
performs basic fact extraction from Java source code. It also defines the
command \texttt{extract-java}, a specialized version of
\texttt{extract-relations} (see Section~\ref{SEC:extract-relations}):
\end{sloppypar}

\item \texttt{java/rscripts}: defines a script \texttt{Enrich.rscript} enrich
  the facts extracted by JavaAnalysis. It also defines some sample scripts
that operate on the enriched rstores.

\item \texttt{java/example-hotdraw}: gives data for the JhotDraw example.

\end{itemize}

The command \texttt{extract-java} provides a common framework for
\asfsdf-based fact extraction from Java programs and has the following form:

\begin{exam}
\texttt{extract-java [options]}
\end{exam}

\noindent The following optional arguments are supported:

\begin{itemize}

\item \texttt{-h} or \texttt{-help}; print help information.

\item \texttt{-i} \emph{dir} or \texttt{-input} \emph{dir}: the name a
  directory \emph{dir} that contains the Java source code. All Java source
  files appearing in (subdirectories of) \emph{dir} will be used as input.
  (default: current directory).

\item \texttt{-o} \emph{file} or \texttt{-output} \emph{file}: the name of
  the resulting rstore 
(default: \texttt{result.rstore.pt}).

\item \texttt{-e} \emph{program} or \texttt{-executable} \emph{program}: the
executable \emph{program} for performing extraction (default: \texttt{JavaAnalysis}). This is most
likely to be a compiled \asfsdf specification.

\item \texttt{-f} \emph{name} or \texttt{-function} \emph{name}: the extraction function to be applied 
to each source file (default: \texttt{extractRelations}). The definition of
this function should conform to:
\begin{exam}
\texttt{extractRelations(CompilationUnit) -> RSTORE}
\end{exam}

\end{itemize}

\noindent The following examples illustrate the use of the
\texttt{extract-relations} command:
\begin{exam}
\texttt{extract-java -i JHotDraw5.2-sources -o jhotdraw.rstore.pt}
\end{exam}

Here is a scenario to go all the way from Java source code to the
visualization of the extracted and enriched facts:
{\footnotesize
\begin{verbatim}
cd example-hotdraw
extract-java -i /ufs/paulk/software/source/JHotDraw -o jhotdraw.rstore.pt
rscript -i ../rscripts/Enrich.rscript -s jhotdraw.rstore.pt -o enr.jhotdraw.rstore.pt
rscript -i validate.rscript -s enr.jhotdraw.rstore.pt
rstore2rviz -i enr.jhotdraw.rstore.pt -o jhotdraw.rviz
rviz jhotdraw.rviz
\end{verbatim}
}

\noindent In the next chapter, we will further explain this scenario.

\chapter{Visualization of Rstores} \label{SEC:Visualization}

\fbox{\epsfig{figure=figs/camera-obscura.ps,width=8cm}} \label{FIG:camera-obscura}
\hspace*{0.5cm}\parbox[b]{6cm}{ The sets and relations constructed for all but
the most trivial problems are voluminous and their textual representation is
hard to grasp for the human eye. This is where information visualization
techniques (**) come to our rescue.  In this chapter we present some initial
experiments to visualize the contents of an Rstore. This is a multi-stage
process described in Section~\ref{SEC:visualize-workflow}.
First facts are extracted from the source
(Section~\ref{SEC:ExtractingFactsAgain})
and are further enriched (Section~\ref{SEC:EnrichingFacts}).
Next the Rstore is converted to the \texttt{.rviz} format that is more
amenable as input for a visualization tool. This format is described in
Section~\ref{SEC:rvizformat} and the conversion from Rstore to this format is
discussed in Section~\ref{SEC:rstore2rviz}. Next, the \texttt{.rviz} file can
be visualized and explored. This is the topic of Section~\ref{SEC:rviz} }

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/visualize-workflow.eps,width=10cm}
\vspace*{-0cm}
\end{center}
\hrulefill
\caption{\label{FIG:visualize-workflow}Workflow for visualization of System Under Investigation}
\end{figure}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/rviz1.ps,width=15cm}
\end{center}
\hrulefill
\caption{\label{FIG:rviz1}File view}
\end{figure}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/rviz2.ps,width=15cm}
\end{center}
\hrulefill
\caption{\label{FIG:rviz2}Tree map view}
\end{figure}


\section{Warning}
The ideas described here remain relevant but their specific implementation is
 outdated. The interactive \rscript environment (\texttt{rscript-meta}) contains
built-in visualization techniques for Rstores.

\section{The visualization workflow} \label{SEC:visualize-workflow}

The process of achieving a visualization of a System under Investigation (SUI) is shown in
Figure~\ref{FIG:visualize-workflow} and consists of the following steps:
\begin{itemize}
\item Extract facts from a source code directory \texttt{SUISrcDir} and
  produce an Rstore \texttt{SUI.rstore.pt}.
\item \begin{sloppypar} Enrich this Rstore by running an rscript \texttt{enr.rscript} on it,
  with resulting enriched Rstore \texttt{enr.rstore.pt}. \end{sloppypar}
\item Convert the enriched Rstore to the the visualization format
  \texttt{.rviz}.
\item Run the visualization tool \texttt{rviz} on these data.
\end{itemize}
\noindent The details of this process are now further explained.

\section{Extracting Facts} \label{SEC:ExtractingFactsAgain}
In Chapter~\ref{SEC:ExtractingFacts} we have already seen how fact extraction can
be organized and implemented. For the current presentation it is sufficient to
assume that there exists an \texttt{extract} tool that can be used:
\begin{exam}
\texttt{extract -i SUISrcDir -o SUI.rstore.pt}
\end{exam}
where \texttt{SUISrcDir} is the source directory where the source of the SUI
can be found. In the distribution a tool \texttt{extract-java} is available with precisely
this behavior for Java programs.

\section{Enriching Facts} \label{SEC:EnrichingFacts}
Given the Rstore  \texttt{SUI.rstore.pt} we enrich it by writing and executing
an \rscript
\texttt{enr.rscript} that extends the extracted facts as required by the goal
we want to achieve:
\begin{exam}
\texttt{rscript enr.rscript -s SUI.rstore.pt -o enr.SUI.rstore.pt}
\end{exam}

\section{The \texttt{.rviz} Format} \label{SEC:rvizformat}

Before explaining the conversion to the rviz format, it is helpful to
understand this format first.
Only two forms of data definitions can currently appear in an rviz file.
\emph{Elements} are values that can occur in relations and are defined by the
keyword \texttt{elm}.  \emph{Tuples} are defined by the keyword
\texttt{tup}. The definition of an \emph{element} has the following form:

\begin{exam}
\texttt{elm} \emph{Type} \emph{Name} \emph{File} \emph{BeginLine} \emph{BeginCol} \emph{EndLine} \emph{EndCol}
\end{exam}

\noindent \emph{Type} is the type as declared in the \rscript, \emph{Name} is
the textual name of the element, and the subsequent file and location
information characterize the precise coordinates of the element in the source
text. An example of an element definition is:

\begin{exam}
\texttt{elm "ClassName" "PolyLineFigure" ".../PolyLineFigure.java" 21 0 339 1}
\end{exam}

The definition of a \emph{tuple} has the following form:
\begin{exam}
\texttt{tup} \emph{RelName} \emph{Type1} \emph{Value1} \emph{Type2} \emph{Value2}
\end{exam}
\noindent \emph{RelName} is the name of the relation to which the tuple belongs.
It is followed two type/value pairs that define the two items in the tuple.
An example of a tuple definition is:

\begin{exam}
\texttt{tup IMPLEMENTS "ClassName" "AbstractHandle" "InterfaceName" "Handle"}
\end{exam}

\paragraph{Discussion} Observe that the current visualization format is very simple and does not 
allow the representation of all data that may be present in an Rstore. In particular, sets and
$n$-ary relations ($n > 2$) are not represented. Clearly, this format will further evolve.

\section{\texttt{rstore2rviz}: Convert Rstore to Visualization Format} \label{SEC:rstore2rviz}
The command \texttt{rstore2rviz} takes an rstore as input and converts it
to the \texttt{.rviz} format that is accepted by the visualization tool \texttt{rviz}.

\begin{itemize}

\item \texttt{-h} or \texttt{-help}: print help information.

\item \texttt{-i} \emph{name} or \texttt{-input} \emph{name}:
rstore comes from file \emph{name}. By default: standard input.

\item \texttt{-o} \emph{name} or \texttt{-output} \emph{name}:
the result is written to file \emph{name}. By default, this is
a file named \texttt{result.rviz}.

\item \texttt{-v} or \texttt{-verbose}: give verbose output.

\end{itemize}
Example:
   \texttt{rstore2rviz -i enr.SUI.rstore.pt -o SUI.rviz}

\section{\texttt{rviz}: Visualize an Rstore} \label{SEC:rviz}


Visualization is simply started by the command \texttt{rviz} with the
given visualization data as input, as in:

\begin{exam}
\texttt{rviz SUI.rviz}
\end{exam}

\noindent The result is a window as shown in Figure~\ref{FIG:rviz1} which
consists of several panes.  On the left-hand side three panes occur. On top is
the \emph{Relations} pane that lists the relations that are available.  One of
these relations can be selected and its elements will be displayed.  In the
middle appears an \emph{Element Type} pane that shows the element types that
are available for the selected relation.  Selecting one of these types lists
in the the bottom all \emph{Elements} that occur in the selected relation and
are of the selected type. By selecting one element from the \emph{Elements}
pane, that element (and all elements it is associated with by the selected
relation) will be highlighted in the large graphical pane on the right.

There are two visualization methods available that can be selected by the button
at the bottom left that is alternatively labeled as \texttt{View as Files} or
\texttt{View as TreeMap}. In the former case, files are shown as rectangles
with a a pattern of horizontal lines inside that reflect their textual
structure. In the latter case, a tree map is shown of the directory structure
of all files.

Figure Figure~\ref{FIG:rviz1} shows the visualization of facts extracted from
the JHotDraw application. The relation \texttt{IMPLEMENTS} has been selected,
and of the two possible element types \texttt{ClassName} has been chosen.
From the list of possible class names, \texttt{AbstractHandle} has been selected.
The result is that the element itself is shown in the file view (with all lines of its definition displayed in blue),
and all its ``related'' elements (e.g., the interfaces it implements) shown in red.

Figure Figure~\ref{FIG:rviz2} shows the same selection, but this time in the tree map view.

\vspace*{3cm}
\begin{figure}[b]
\begin{center}
\vspace*{-3cm}
\epsfig{figure=figs/teleskoop.ps,width=8cm} \label{FIG:teleskoop}

\end{center}
\end{figure}




%%\begin{figure}[h]
%%\begin{center}
%%\epsfig{figure=figs/sonometer.ps,width=15cm}
%%\end{center}
%%\end{figure}



%% \newpage
\section*{Acknowledgments}
Thanks to Tijs van der Storm for many useful discussions and experiments.
Thanks to Murat Ahat, Jan van Eijck, Taeke Kooiker, Tijs van der Storm, Ivan Vankov,
and Jurgen Vinju for comments on this tutorial.

\section*{Illustrations}

Most illustrations used in this tutorial concern physical instruments for
  measurement or observation and are taken from H. van de Stadt, \emph{Beknopt
  Leerboek der Natuurkunde} (Concise Text-book of Physics) Tjeenk Willink,
  Zwolle, 1902.
On the front page appears a windlass that amplifies manual power and is used in
water wells, drilling devices, and wind mills.
Page~\pageref{FIG:balloon}  shows a hot air balloon combined with a parachute
(circa 1900).
On page~\pageref{FIG:microscope} appears a composite microscope as proposed by
Drebbel (1621).
On page~\pageref{FIG:declinatorium} appears a \emph{declinatorium} used to
measure the difference between the magnetic and geographic north pole.
On page~\pageref{FIG:vuurtoren} the cross section is shown of a lighthouse as used along
the Dutch cost.
The spectroscope on page~\pageref{FIG:spektroskoop} is a design using four
prisms by Steinheil
and is used for the improved dispersion and analysis of the light emitted by
sodium vapor.
On page~\pageref{FIG:ruhmkorff} appears Ruhmkorff's induction-coil (1851) used
to create high-Voltage electric currents. 
Page \pageref{FIG:camera-obscura} shows a variation of the \emph{camera obscura} as
used for producing realistic drawings of a landscape.
Lassell's telescope (1863) appears on page~\pageref{FIG:teleskoop}.

 The photograph on page~\pageref{FIG:caruso} is the ``Caruso'' loudspeaker and
  appeared in an advertisement in J. Corver, \emph{Het Draadloos
  Amateurstation} (The Wireless Amateur (Radio) Station), Veenstra, 's
  Gravenhage, 1928.
The sign alphabet on page~\pageref{FIG:signalpha} has been taken from
\url{ www.inquiry.net/outdoor/skills/b-p/signaling.htm}
\bibliographystyle{plain} \bibliography{iwpc,tutorial}

%%\chapter{TO DO}
%%\begin{itemize}
%%\item {\tt all-path-to}, {\tt sort} not described.
%%\item $n$-ary relations
%%\item Termination criteria for solving equations
%%\item Access functions for $n$-ary tuples.
%%\item Describe Rstores
%%\item Give Rscript grammar
%%\item Yield
%%\item Make an index.

%%\end{itemize}

\end{document
}
-->
</chapter>