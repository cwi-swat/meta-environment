<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
]>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns6="http://www.w3.org/1999/xhtml"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook"
         xml:id="language-definitions"
>
  <info>
    <title>Writing Language Definitions in ASF+SDF</title>

    <pubdate>$Rev$ by $Author$ at $Date: 2007-08-22 17:27:53
    +0200 (Wed, 22 Aug 2007) $</pubdate>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <warning>
    <para>This document is work in progress. See <link
    linkend="section.todo">ToDo</link> section.</para>
  </warning>

  <section xml:id="section.langdef-introduction">
    <title>Introduction</title>

    <para>You are interested in using ASF+SDF to define various aspects of a
    programming language or domain-specific language but you do now want to
    wade through all the details in the manual (The Language Specification
    Formalism ASF+SDF)? In that case, this article may be for you. We take the
    toy language Pico as starting point and walk you through its syntax,
    typechecking, formatting, execution and more. We do this while assuming
    zero knowledge of ASF+SDF or The ASF+SDF Meta-Environment.</para>

    <section>
      <title>What is the Global Picture?</title>

      <para>ASF+SDF can be used to define various aspects of programming
      langauges and The ASF+SDF Meta-Environment can be used to edit and run
      these specifications.</para>
    </section>

    <section>
      <title>ASF+SDF</title>

      <para>The goal of ASF+SDF is to define the syntax (form) and semantics
      (meaning) of programming languages and domain-specific languages. The
      Syntax Definition Formalism (SDF) is used to define syntactic aspects
      including:</para>

      <itemizedlist>
        <listitem>
          <para>Lexical syntax (keywords, comments, string constants, whiete
          space, ...).</para>
        </listitem>

        <listitem>
          <para>Context-free syntax (declarations, statements, ...).</para>
        </listitem>
      </itemizedlist>

      <para>The Algebraic Specification Formalism (ASF) is used to define
      semantic aspects such as:</para>

      <itemizedlist>
        <listitem>
          <para>Type checking (are the variables that are used declared and
          are they used in a type-correct way?).</para>
        </listitem>

        <listitem>
          <para>Formatting (display the original program using user-defined
          rules for indentation and formatting).</para>
        </listitem>

        <listitem>
          <para>Fact extraction (extract all procedure calls or all
          declarations and uses of variables).</para>
        </listitem>

        <listitem>
          <para>Execution (run the program with given input values).</para>
        </listitem>
      </itemizedlist>

      <para>By convention, all these language aspects are located in dedicated
      subdirectories of a language definition:</para>

      <itemizedlist>
        <listitem>
          <para><filename>syntax</filename> (definitions for the
          syntax).</para>
        </listitem>

        <listitem>
          <para><filename>check</filename> (definitions for type
          checking).</para>
        </listitem>

        <listitem>
          <para><filename>format</filename> (definitions for
          formatting).</para>
        </listitem>

        <listitem>
          <para><filename>extract</filename> (definitions for fact
          extraction).</para>
        </listitem>

        <listitem>
          <para><filename>run</filename> (definitions for running a
          program).</para>
        </listitem>

        <listitem>
          <para><filename>debug</filename> (definitions for debugging a
          program).</para>
        </listitem>
      </itemizedlist>

      <para>Apart from giving a standard structure to all language
      definitions, this organization also enables the seamless integration of
      these aspects in the user-interface of The Meta-Environment.</para>
    </section>

    <section>
      <title>The ASF+SDF Meta-Environment</title>

      <para>The goal of The ASF+SDF Meta-Environment (or The Meta-Environment
      for short) is to provide an Interactive Development Environment for
      ASF+SDF specifications. It supports interactive editing, checking and
      execution of ASF+SDF specifications. Behind the scenes, this implies the
      following tasks:</para>

      <itemizedlist>
        <listitem>
          <para>Providing a graphical user-interface with editors and various
          visualization tools.</para>
        </listitem>

        <listitem>
          <para>Tracking changes to specification modules.</para>
        </listitem>

        <listitem>
          <para>Parsing and checking specification modules.</para>
        </listitem>

        <listitem>
          <para>Generating parsers for the syntax modules (SDF) that have been
          changed.</para>
        </listitem>

        <listitem>
          <para>Generating rewriter engines for the equations modules (ASF)
          that have been changed.</para>
        </listitem>

        <listitem>
          <para>Applying the ASF+SDF specification to programs in the language
          that is being defined by that specification.</para>
        </listitem>
      </itemizedlist>

      <para>The intended user experience of The Meta-Environment is the
      seamless automation of all these tasks.</para>
    </section>

    <section>
      <title>Learning more</title>

      <para>This article guides you through the various stages of writing
      language definitions in ASF+SDF. The following documents (all available
      at <uri>http://www.meta-environment.org</uri>) will help you to learn
      more:</para>

      <itemizedlist>
        <listitem>
          <para>The basic concepts of syntax analysis are given in the article
          "Syntax Analysis".</para>
        </listitem>

        <listitem>
          <para>The basic concepts of term rewriting are discussed in the
          article "Term Rewriting".</para>
        </listitem>

        <listitem>
          <para>"The Syntax Definition Formalism SDF" is the reference manual
          for the SDF formalism.</para>
        </listitem>

        <listitem>
          <para>"The Language Specification Formalism ASF+SDF" is the
          reference manual for the ASF+SDF formalism.</para>
        </listitem>

        <listitem>
          <para>"Guided tour: Playing with Booleans" is a flash movie that
          gives you a quick overview of the user-interface of the
          Meta-Environment.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Preparations</title>

    <para>The anatomies of a complete ASF+SDF specification as well as that of
    a single module are needed to understand any language definition.</para>

    <section>
      <title>Anatomy of an ASF+SDF specification</title>

      <para>An ASF+SDF specification consists of a collection of modules as
      shown in the following <xref linkend="figure.modules" />. A module can
      import other modules and this can be understood as the textual inclusion
      of the imported modules. In this example, the text of modules
      <literal>B</literal>, <literal>C</literal> and <literal>D</literal> is
      literally inserted in module <literal>A</literal>.</para>

      <figure xml:id="figure.modules">
        <title>Module structure of an ASF+SDF specification</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="modules.png" scale="100"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Anatomy of a single module</title>

      <para>A single module has the following structure:</para>

      <programlisting>module <replaceable>ModuleName</replaceable> <co
          xml:id="mod.1" />
  <replaceable>ImportSection</replaceable>*  <co xml:id="mod.2" />
  <replaceable>ExportOrHiddenSection</replaceable>* <co xml:id="mod.3" />
equations
  <replaceable>ConditionalEquation</replaceable>* <co xml:id="mod.4" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="mod.1">
          <para>The name of this module. It may be followed by
          parameters.</para>
        </callout>

        <callout arearefs="mod.2">
          <para>Zero or more sections that describe modules to be imported by
          this module.</para>
        </callout>

        <callout arearefs="mod.3">
          <para>The grammar elements (such as <literal>imports</literal>,
          <literal>aliases</literal>, <literal>sorts</literal>,
          <literal>lexical syntax</literal>, <literal>context-free
          syntax</literal>, <literal>priorities</literal> or
          <literal>variables</literal>) that are visible from the outside
          (defined by <literal>exports</literal>) or only inside the module
          (defined by <literal>hiddens</literal>).</para>
        </callout>

        <callout arearefs="mod.4">
          <para>The equations of the module that define the meaning of the
          grammar elements. Equations come in two flavours. Unconditional:
          <programlisting><emphasis role="bold">[</emphasis>&lt;TagId&gt;<emphasis
                role="bold">]</emphasis> &lt;Term<subscript>1</subscript>&gt; <emphasis
                role="bold">=</emphasis> &lt;Term<subscript>2</subscript>&gt;</programlisting></para>

          <para>and conditional:<programlisting><emphasis role="bold">[</emphasis>&lt;TagId&gt;<emphasis
                role="bold">]</emphasis>  &lt;Condition<subscript>1</subscript>&gt;<emphasis
                role="bold">,</emphasis> &lt;Condition<subscript>2</subscript>&gt;<emphasis
                role="bold">,</emphasis> ... 
           <emphasis role="bold">===============================</emphasis>
                 &lt;Term<subscript>1</subscript>&gt; <emphasis role="bold">=</emphasis> &lt;Term<subscript>2</subscript>&gt;</programlisting></para>

          <para>In the unconditional case, an attempt is made to match
          Term<subscript>1</subscript> and if this succeeds it is replaced by
          Term<subscript>2</subscript> (after proper replacement of variables
          that result from the match). In the conditional case, an attempt is
          made to match Term<subscript>1</subscript> and if this succeeds the
          conditions are evaluated. If all conditions are true,
          Term<subscript>1</subscript> is replaced by
          Term<subscript>2</subscript> (again after proper replacement of
          variables that may in this case result both from the match and from
          the evaluation of the conditions.).</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>An example: Booleans</title>

      <para>The Meta-Environment comes with a considerable library of built-in
      languages and datatypes. We explore here the datatype
      <literal>basic/Booleans</literal> in the ASF+SDF library.</para>

      <section>
        <title>Modular structure</title>

        <para>The module structure of <literal>basic/Booleans</literal> is
        shown in <xref linkend="figure.booleans-modules" />.</para>

        <figure xml:id="figure.booleans-modules">
          <title>Modular structure of
          <literal>basic/Booleans</literal></title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="booleans-modules.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>We will now discuss all these modules in turn.</para>
      </section>

      <section>
        <title><literal>basic/BoolCon</literal></title>

        <para>Let' start with the Boolean constants:</para>

        <programlisting>module basic/BoolCon

exports

sorts BoolCon  <co xml:id="boolcon.1" />
context-free syntax

    "true"  -&gt; BoolCon {cons("true")} <co xml:id="boolcon.2" />
    "false" -&gt; BoolCon {cons("false")}    

hiddens
context-free start-symbols
  BoolCon <co xml:id="boolcon.3" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="boolcon.1">
            <para>The sort of Boolean constants is defined as
            <literal>BoolCon</literal>. Sort names should always start with a
            capital letter.</para>
          </callout>

          <callout arearefs="boolcon.2">
            <para>The constants <literal>true</literal> and
            <literal>false</literal>. Such literals should always be quoted.
            The <literal>cons</literal> attribute plays only a role when
            generating external APIs and gives a name to this particular
            construct. In the current presentation it can be ignored.</para>
          </callout>

          <callout arearefs="boolcon.3">
            <para>We add a start symbol (i.e., the syntactic notion from with
            all strings in this language are derived) for
            <literal>BoolCon</literal>. The net effect is that we can indeed
            parse these constants. Note that we hide this start symbol so that
            it can not proliferate to other modules (and cause undesired
            ambiguities).</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title><literal>basic/Whitespace</literal></title>

        <para>The module Whitespace defines what the spaces and newline
        are:</para>

        <programlisting>module basic/Whitespace

exports
  lexical syntax
    [\ \t\n\r] -&gt; LAYOUT {cons("whitespace")} <co xml:id="whitespace.1" />

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]  <co xml:id="whitespace.2" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="whitespace.1">
            <para>A regular expression that defines space (<literal>\
            </literal>), tabulation (<literal>\t)</literal>, newline
            (<literal>\n</literal>) and carriage return
            (<literal>\r)</literal> as <literal>LAYOUT</literal> characters.
            <literal>LAYOUT</literal> is a predefined name that defines the
            layout characters that may optionally appear between the symbols
            in the context-free grammar (e.g., between the keyword
            <literal>if</literal> and the test in an if-statement).</para>
          </callout>

          <callout arearefs="whitespace.2">
            <para>Lexical syntax tends to become highly ambiguous, e.g., are
            two spaces one layout symbol or two consecutive ones? Context-free
            restrictions impose restrictions that resolve this. Here, optional
            layout (<literal>LAYOUT?</literal>) may not be followed by a
            layout character. In other words, the longest possible sequence of
            layout characters should be considered as one
            <literal>LAYOUT</literal> symbol.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title><literal>basic/Comments</literal></title>

        <para>The comment conventions are defined as follows:</para>

        <programlisting>module basic/Comments

imports
  basic/Whitespace

exports
  lexical syntax
    "%%" line:~[\n]* "\n"    -&gt; LAYOUT
                                {cons("line"),
                                 category("Comment")}  <co xml:id="comments.1" />
    "%" content:~[\%\n]+ "%" -&gt; LAYOUT 
                                {cons("nested"),
                                 category("Comment")}  <co xml:id="comments.2" />
  context-free restrictions
    LAYOUT? -/- [\%] <co xml:id="comments.3" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="comments.1">
            <para>Defines a line-based comment that starts with
            <literal>%%</literal> and ends at the end of the line. The
            <literal>category</literal> attribute defines the highlighting
            category to be used while editing texts that contain this
            comment.</para>
          </callout>

          <callout arearefs="comments.2">
            <para>Define a comment that is contained within a single line
            between <literal>%</literal> and <literal>%</literal>.</para>
          </callout>

          <callout arearefs="comments.3">
            <para>Again a follow restriction that forces layout followed by a
            comment to be included in that comment.</para>
          </callout>
        </calloutlist>
      </section>

      <section xml:id="section.basic-Booleans">
        <title><literal>basic/Booleans</literal></title>

        <para>After these preparations, we can now discuss the syntax part of
        <literal>basic/Booleans</literal>:</para>

        <programlisting>module basic/Booleans

imports basic/BoolCon&#160;<co xml:id="booleans.1" />

exports
sorts Boolean <co xml:id="booleans.2" />

context-free syntax
  BoolCon                     -&gt; Boolean 
                                 {cons("constant")}  <co xml:id="booleans.3" />       
  lhs:Boolean "|" rhs:Boolean -&gt; Boolean 
                                 {left, cons("or")}  <co xml:id="booleans.4" />       
  lhs:Boolean "&amp;" rhs:Boolean -&gt; Boolean 
                                 {left, cons("and")}                  
  "not" "(" Boolean ")"       -&gt; Boolean 
                                 {cons("not")} <co xml:id="booleans.5" />     
  "(" Boolean ")"             -&gt; Boolean 
                                 {bracket, 
                                  cons("bracket")} <co xml:id="booleans.6" />

context-free priorities
  Boolean "&amp;" Boolean -&gt; Boolean &gt; <co xml:id="booleans.7" />
  Boolean "|" Boolean -&gt; Boolean

hiddens
context-free start-symbols
  Boolean <co xml:id="booleans.8" />

imports basic/Comments <co xml:id="booleans.9" />

variables
  "Bool" [0-9]* -&gt; Boolean <co xml:id="booleans.10" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="booleans.1">
            <para>Import the Boolean constants <literal>true</literal> and
            <literal>false</literal> defined earlier.</para>
          </callout>

          <callout arearefs="booleans.2">
            <para>The sort <literal>Boolean</literal> will represent Boolean
            expressions.</para>
          </callout>

          <callout arearefs="booleans.3">
            <para>Each Boolean constant is also a Boolean expression. This is
            called an <emphasis>injection rule</emphasis> or a <emphasis>chain
            rule</emphasis>.</para>
          </callout>

          <callout arearefs="booleans.4">
            <para>The infix operators for Boolean or (<literal>|</literal>)
            and Boolean and (<literal>&amp;</literal>). Both are
            left-associative and this is indicated by the attribute
            <literal>left</literal>. Also note that the arguments get explicit
            names (<literal>lhs</literal> and <literal>rhs</literal>) and that
            a constructor is defined (<literal>or</literal>, respectively,
            <literal>and</literal>). This information is only relevant for
            generated APIs that are accessed by external tools.</para>
          </callout>

          <callout arearefs="booleans.5">
            <para>The prefix operator <literal>not</literal>.</para>
          </callout>

          <callout arearefs="booleans.6">
            <para>The parentheses <literal>(</literal> and
            <literal>)</literal> may be used as brackets in Boolean
            expressions.</para>
          </callout>

          <callout arearefs="booleans.7">
            <para><literal>&amp;</literal> has a higher priority than
            <literal>|</literal>. The expression <literal>Bool &amp; Bool |
            Bool</literal> will thus be interpreted as <literal>(Bool &amp;
            Bool) | Bool</literal>.</para>
          </callout>

          <callout arearefs="booleans.8">
            <para>Define a (hidden) start symbol for Boolean
            expressions.</para>
          </callout>

          <callout arearefs="booleans.9">
            <para>Import <literal>basic/Comments</literal> for the benefit of
            writing equations for Booleans (see below). Observe the subtlety
            that this is a <emphasis>hidden</emphasis> import: comments are
            only available locally in this module and are not exported. By
            strictly adhering to this convention, low-level comment
            conventions cannot <emphasis>pollute</emphasis> higher level
            modules and interfere with comment conventions defined at that
            level.</para>
          </callout>

          <callout arearefs="booleans.10">
            <para>Declares Boolean variables like <literal>Bool</literal>,
            <literal>Bool1</literal>, <literal>Bool2</literal>,
            <literal>Bool123</literal>, <literal>Bool'</literal>,
            <literal>Bool''</literal>, and <literal>Bool1'</literal>.</para>
          </callout>
        </calloutlist>

        <para>Having covered all syntactic aspects of the Booleans, we can now
        turn our attention to the equations:</para>

        <programlisting>equations

[B1]   true  | Bool  = true  <co xml:id="booleans-eq.1" />
[B2]   false | Bool  = Bool

[B3]   true  &amp; Bool  = Bool  <co xml:id="booleans-eq.2" />
[B4]   false &amp; Bool  = false

[B5]   not ( false ) = true  <co xml:id="booleans-eq.3" />
[B6]   not ( true )  = false</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="booleans-eq.1">
            <para>Meaning of the <literal>|</literal> operator, in other
            words: with these two rules the <literal>|</literal> operator can
            be eliminated from any Boolean expression.</para>
          </callout>

          <callout arearefs="booleans-eq.2">
            <para>Meaning of <literal>&amp;</literal> operator.</para>
          </callout>

          <callout arearefs="booleans-eq.3">
            <para>Meaning of <literal>not</literal> operator.</para>
          </callout>
        </calloutlist>

        <para>The syntax of ASF+SDF equations is not fixed but depends on the
        syntax rules. This can be seen by making the fixed ASF+SDF syntax
        <emphasis role="bold">bold</emphasis> and the syntax specific for
        Booleans <emphasis>italic</emphasis>:</para>

        <para><programlisting><emphasis role="bold">equations</emphasis>

<emphasis role="bold">[B1]</emphasis>   <emphasis>true  | Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>true</emphasis>       
<emphasis role="bold">[B2]</emphasis>   <emphasis>false | Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>Bool</emphasis>

<emphasis role="bold">[B3]</emphasis>   <emphasis>true  &amp; Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>Bool</emphasis>       
<emphasis role="bold">[B4]</emphasis>   <emphasis>false &amp; Bool</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>false</emphasis>

<emphasis role="bold">[B5]</emphasis>   <emphasis>not ( false )</emphasis> <emphasis
              role="bold">=</emphasis> <emphasis>true</emphasis>       
<emphasis role="bold">[B6]</emphasis>   <emphasis>not ( true )</emphasis>  <emphasis
              role="bold">=</emphasis> <emphasis>false</emphasis></programlisting></para>

        <para>This mixture of syntaxes will become even more apparent when we
        discuss the Pico definitions later.</para>
      </section>

      <section>
        <title>Reducing a Boolean expression</title>

        <para>The Boolean term <literal>not(true &amp; not(false |
        true))</literal> should reduce to <literal>true</literal> (check this
        for yourself before looking at <xref
        linkend="figure.boolean-reduction" />).</para>

        <figure xml:id="figure.boolean-reduction">
          <title>Reducing a Boolean term.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="boolean-reduction.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Running the Boolean example in The Meta-Environment</title>

        <para>The flash movie "Guided tour: Playing with Booleans" gives you a
        quick overview of the user-interface of The Meta-Environment. Here we
        give you only some quick hints to get started. After installation, the
        The Meta-Environment is available as the command:
        <command>asfsdf-meta</command>. Typing this command results in the
        screen shown in <xref linkend="figure.initial-screen" />.</para>

        <figure pgwide="1" xml:id="figure.initial-screen">
          <title>Initial screen of The Meta-Environment</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screen-initial.png" scale="55" scalefit="1"
                         width=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Opening the module <literal>basic/Booleans</literal> is achieved
        as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Press the menu <guimenu>Module</guimenu> and select the
            button <guimenuitem>Open...</guimenuitem>.</para>
          </listitem>

          <listitem>
            <para>An <guilabel>Open Module</guilabel> dialog appears that asks
            for the directory to <guilabel>Look in</guilabel>.</para>
          </listitem>

          <listitem>
            <para>Select the entry ASF+SDF library and a list of choices
            appears.</para>
          </listitem>

          <listitem>
            <para>Select the subdirectory <filename>basic</filename> and
            select <literal>Booleans.sdf</literal> in the list of modules that
            is provided. The progress so far, is shown in <xref
            linkend="figure.open-basic-Booleans" />.</para>
          </listitem>

          <listitem>
            <para>Now pushing the <guibutton>Open Module</guibutton> button
            will open <literal>basic/Booleans</literal> and all its imported
            modules. The result is shown in <xref
            linkend="figure.Booleans-opened" />.</para>
          </listitem>
        </itemizedlist>

        <figure xml:id="figure.open-basic-Booleans">
          <title>Selecting <literal>basic/Booleans.sdf</literal></title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screen-open-module.png" scale="55"
                         scalefit="1"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <figure pgwide="1" xml:id="figure.Booleans-opened">
          <title>After opening <literal>basic/Booleans</literal></title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screen-Booleans-opened.png" scale="55"
                         scalefit="1" width=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Now that the Booleans have been opened, you may want to inspect
        their definition yourself. There are two ways to achieve this:</para>

        <itemizedlist>
          <listitem>
            <para>Right click (= click with the right-most mouse button) on
            <literal>Booleans</literal> in the <guilabel>Modules</guilabel>
            pane on the left, or</para>
          </listitem>

          <listitem>
            <para>Right click on the oval labelled <literal>Booleans</literal>
            in the <guilabel>Import Graph</guilabel> pane on the right.</para>
          </listitem>
        </itemizedlist>

        <para>In both cases, a hierarchical pop-up menu will appear:</para>

        <itemizedlist>
          <listitem>
            <para>Select the menu entry <guimenuitem>Editing...</guimenuitem>.
            A new pop-up menu will appear.</para>
          </listitem>

          <listitem>
            <para>Select the menu entry <guimenuitem>Syntax</guimenuitem>, and
            the syntax part of module Booleans will appear in an editor pane.
            The result is shown in <xref
            linkend="figure.Booleans-syntax" />.</para>
          </listitem>
        </itemizedlist>

        <figure pgwide="1" xml:id="figure.Booleans-syntax">
          <title>Opening the syntax of module Booleans</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screen-Booleans-syntax.png" scale="55"
                         scalefit="1" width=""></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>After these initial steps, viewing the equations and opening and
        reducing a Boolean term will require similar interactions with The
        Meta-Environment.</para>

        <important>
          <para>There is no substitute for trying this out yourself.</para>
        </important>
      </section>

      <section>
        <title>Take home points</title>

        <para>The example of the Booleans illustrates the following points
        that are also valid for more complex examples:</para>

        <itemizedlist>
          <listitem>
            <para>Each module <emphasis>defines a language</emphasis>: in this
            case the language of Booleans. In other contexts one can also
            speak about the datatype of the Booleans. We will use language and
            datatype as synonyms. Other examples of languages are integers,
            stacks, C, and Java. We treat them all in a uniform
            fashion.</para>
          </listitem>

          <listitem>
            <para>We can use the language definition for Booleans (and by
            implication for any language) to:</para>

            <itemizedlist>
              <listitem>
                <para>Create a syntax-directed editor for the Boolean language
                and create Boolean terms. In the context of, for instance,
                Java, it would be more common to say: create a syntax-directed
                editor for Java and create Java programs.</para>
              </listitem>

              <listitem>
                <para>Apply the equations to this term and reduce it to a
                <emphasis>normal form</emphasis> (= a term that is not further
                reducible).</para>
              </listitem>

              <listitem>
                <para>Import it in another module; this makes the Boolean
                language available for the importing module.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section>
    <title>The toy language Pico</title>

    <para>The toy language Pico has a single purpose in life: being so simple
    that specifications of every possible language aspect are so simple that
    they fit on a few pages. It can be summarized as follows:</para>

    <itemizedlist>
      <listitem>
        <para>There are two types: natural numbers and strings.</para>
      </listitem>

      <listitem>
        <para>Variables have to be declared.</para>
      </listitem>

      <listitem>
        <para>Statements are assignment, if-then-else and while-do.</para>
      </listitem>

      <listitem>
        <para>Expressions may contain naturals, strings, variables, addition
        (<literal>+</literal>), subtraction (<literal>-</literal>) and
        concatenation (<literal>||</literal>).</para>
      </listitem>

      <listitem>
        <para>The operators <literal>+</literal> and <literal>-</literal> have
        operands of type natural and their result is natural.</para>
      </listitem>

      <listitem>
        <para>The operator <literal>||</literal> has operands of type string
        and its results is also of type string.</para>
      </listitem>

      <listitem>
        <para>Tests in if-then-else statement and while-statement should be of
        type natural.</para>
      </listitem>
    </itemizedlist>

    <para>Let's look at a simple Pico program that computes the factorial
    function:</para>

    <programlisting>begin declare input : natural,  <co xml:id="fac.1" />
              output : natural,           
              repnr : natural,
              rep : natural;
      input := 14;
      output := 1;
      while input - 1 do <co xml:id="fac.2" />
          rep := output;
          repnr := input;
          while repnr - 1 do
             output := output + rep;
             repnr := repnr - 1
          od;
          input := input - 1
      od
end</programlisting>

    <para>Notes:</para>

    <calloutlist>
      <callout arearefs="fac.1">
        <para>Pico programs do not have input/output statements, so we use
        variables for that purpose.</para>
      </callout>

      <callout arearefs="fac.2">
        <para>Pico has no multiplication operator so we have to simulate it
        with repeated addition (yes, simplicity comes at a price!).</para>
      </callout>
    </calloutlist>
  </section>

  <section>
    <title>Define the syntax for Pico</title>

    <para>The import structure of the syntax definition of Pico is shown in
    <xref linkend="figure.imports-pico-syntax" />. The modules
    <literal>basic/NatCon</literal>, <literal>basic/StrCon</literal> and
    <literal>basic/Whitespace</literal> are reused from the ASF+SDF library.
    The modules <literal>languages/pico/syntax/Identifiers</literal>,
    <literal>languages/pico/syntax/Types</literal> and
    <literal>languages/pico/syntax/Pico</literal> are specified for Pico and
    are now discussed in more detail.</para>

    <figure xml:id="figure.imports-pico-syntax">
      <title>Import structure of Pico syntax</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="pico-modules.png" scale="100"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title><literal>languages/pico/syntax/Types</literal></title>

      <para>Variables can be declared in Pico programs with one of two types:
      "natural number" or "string". This is defined as follows:</para>

      <programlisting>module languages/pico/syntax/Types

exports
  sorts TYPE <co xml:id="types.1" />
  context-free syntax
    "natural"     -&gt; TYPE <co xml:id="types.2" />
    "string"      -&gt; TYPE
    "nil-type"    -&gt; TYPE <co xml:id="types.3" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="types.1">
          <para><literal>TYPE</literal> is the sort of possible types in Pico
          programs.</para>
        </callout>

        <callout arearefs="types.2">
          <para>The constants <literal>natural</literal> and
          <literal>string</literal> represent types as they can be declared in
          a Pico program.</para>
        </callout>

        <callout arearefs="types.3">
          <para>The constant <literal>nil-type</literal> is used for handling
          error cases.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title><literal>languages/pico/syntax/Identifiers</literal></title>

      <para>Identifiers are used for the names of variables in Pico programs.
      They are defined as follows:</para>

      <programlisting>module languages/pico/syntax/Identifiers

exports
  sorts PICO-ID  <co xml:id="id.1" />
  lexical syntax
    [a-z] [a-z0-9]* -&gt; PICO-ID  <co xml:id="id.2" />

  context-free restrictions
    PICO-ID -/- [a-z0-9] <co xml:id="id.3" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="id.1">
          <para><literal>PICO-ID</literal> is the sort of identifiers in Pico
          programs.</para>
        </callout>

        <callout arearefs="id.2">
          <para><literal>PICO-ID</literal> is defined using a regular
          expression that contains the following elements:</para>

          <itemizedlist>
            <listitem>
              <para><literal>[a-z]</literal>: a character class that ranges
              over all lower case letters.</para>
            </listitem>

            <listitem>
              <para><literal>[a-z0-9]</literal>: a character class that ranges
              over all lower case letters and over all digits.</para>
            </listitem>

            <listitem>
              <para><literal>[a-z0-9]*</literal>: <emphasis>zero</emphasis> or
              more repetitions of the character class
              <literal>[a-z0-9]</literal>. In other cases the postfix
              <literal>+</literal> operator can be used that defines
              <emphasis>one</emphasis> or more repetitions of the preceding
              construct.</para>
            </listitem>
          </itemizedlist>

          <para>The overall effect of this definition is that Pico identifiers
          start with a lower case letter that can be followed by lower case
          letters or by digits.</para>
        </callout>

        <callout arearefs="id.3">
          <para>Defines the longest match for Pico identifiers.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title><literal>languages/pico/syntax/Pico</literal></title>

      <para>After these preparations we can present the syntax for
      Pico:</para>

      <programlisting>module languages/pico/syntax/Pico

imports languages/pico/syntax/Identifiers 
imports languages/pico/syntax/Types
imports basic/NatCon 
imports basic/StrCon 

hiddens
  context-free start-symbols <co xml:id="pico-syntax.1" />
    PROGRAM

exports

  sorts PROGRAM DECLS ID-TYPE STATEMENT EXP <co xml:id="pico-syntax.2" />

  context-free syntax <co xml:id="pico-syntax.3" />
    
    "begin" DECLS {STATEMENT";" }* "end" -&gt; PROGRAM <co
          xml:id="pico-syntax.4" />
    "declare" {ID-TYPE "," }*";"         -&gt; DECLS 
    PICO-ID ":" TYPE                     -&gt; ID-TYPE

  context-free syntax <co xml:id="pico-syntax.5" />

    PICO-ID ":=" EXP                     -&gt; STATEMENT
    "if" EXP "then" {STATEMENT";" }* 
             "else" {STATEMENT";" }* 
    "fi"                                 -&gt; STATEMENT
    "while" EXP "do"
                    {STATEMENT ";" }* 
                "od"                     -&gt; STATEMENT
 
  context-free syntax <co xml:id="pico-syntax.6" />

    PICO-ID                              -&gt; EXP  <co xml:id="pico-syntax.7" />                                                
    NatCon                               -&gt; EXP                                   
    StrCon                               -&gt; EXP                                                       
    EXP "+" EXP                          -&gt; EXP {left} <co
          xml:id="pico-syntax.8" />
    EXP "-" EXP                          -&gt; EXP {left}
    EXP "||" EXP                         -&gt; EXP {left}
    "(" EXP ")"                          -&gt; EXP {bracket} <co
          xml:id="pico-syntax.9" />

  context-free priorities <co xml:id="pico-syntax.10" />
    EXP "||" EXP -&gt; EXP &gt;
    EXP "-" EXP -&gt; EXP &gt;
    EXP "+" EXP -&gt; EXP</programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="pico-syntax.1">
          <para><literal>PROGRAM</literal> is the start symbol for this
          grammar, i.e., each Pico program is derived from it.</para>
        </callout>

        <callout arearefs="pico-syntax.2">
          <para>The sorts <literal>PROGRAM</literal>,
          <literal>DECLS</literal>, <literal>ID-TYPE</literal>,
          <literal>STATEMENT</literal> and <literal>EXP</literal> are declared
          here and are used (in addition to the sorts declared in the imported
          modules) to define the Pico grammar.</para>
        </callout>

        <callout arearefs="pico-syntax.3">
          <para>This first context-free syntax section declares the top level
          structure of a Pico program.</para>
        </callout>

        <callout arearefs="pico-syntax.4">
          <para>The rule for <literal>PROGRAM</literal> contains the list
          construct<literal> {STATEMENT ";"}*</literal>. It describes zero or
          more statements separated by a semicolon
          (<literal>;</literal>).</para>
        </callout>

        <callout arearefs="pico-syntax.5">
          <para>This section declares the syntax for statements.</para>
        </callout>

        <callout arearefs="pico-syntax.6">
          <para>This final context-free syntax section declares expression
          syntax.</para>
        </callout>

        <callout arearefs="pico-syntax.7">
          <para>These three rules define that Pico identifiers, natural
          constants and string constants may occur in expressions.</para>
        </callout>

        <callout arearefs="pico-syntax.8">
          <para>The syntax of the operators <literal>+</literal>,
          <literal>-</literal> and <literal>||</literal> is defined. Observe
          that all three are left-associative. This implies that an expression
          like <literal>1+2+3</literal> is considered to be of the form
          <literal>(1+2)+3</literal> and that the other interpretation
          <literal>1+(2+3)</literal> is rejected.</para>
        </callout>

        <callout arearefs="pico-syntax.9">
          <para><literal>(</literal> and <literal>)</literal> can be used as
          brackets in expressions.</para>
        </callout>

        <callout arearefs="pico-syntax.10">
          <para>Priorities define the relative ordering of operators and are
          used to disambiguate text when more interpretations are possible.
          The higher the priority, the stronger the binding. The expression
          <literal>1-2+3</literal> will thus be interpreted as
          <literal>(1-2)+3</literal>.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>Using the Pico syntax in the Meta-Environment</title>

      <para>Now we will create a tiny Pico program:</para>

      <para><itemizedlist>
          <listitem>
            <para>Right click on the module syntax/Pico (since we want to
            create a term using that syntax). A pop-up menu appears.</para>
          </listitem>

          <listitem>
            <para>Select the menu entry <guimenuitem>Editing...</guimenuitem>.
            A new pop-up menu will appear.</para>
          </listitem>

          <listitem>
            <para>Select the menu entry <guimenuitem>Term</guimenuitem> and a
            dialog window will appear to select the desired term. You may
            select an exitsing file or create a new one. We do the latter:
            type in <filename>pico-trial.trm</filename>. The result is a new
            editor pane labelled with the name of the file.</para>
          </listitem>

          <listitem>
            <para>Now start typing the following (syntactically correct) Pico
            program:</para>

            <programlisting>begin
 declare
   x : natural;
   x := "abc"
end</programlisting>
          </listitem>
        </itemizedlist>The result is shown in the <xref
      linkend="figure.pico-trial1" />.</para>

      <figure pgwide="1" xml:id="figure.pico-trial1">
        <title>First program after typing it in.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screen-pico-trial1.png" scale="55"
                       scalefit="1"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Next, goto to the <guimenu>File</guimenu> menu and select the
      <guimenuitem>Save</guimenuitem> entry (or, alternatively, type Ctrl-S).
      The result is that the file is saved and parsed. As a result, all
      keywords will be highlighted as shown in <xref
      linkend="figure.pico-trial2" />.</para>

      <figure pgwide="1" xml:id="figure.pico-trial2">
        <title>First program after saving it.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screen-pico-trial2.png" scale="55"
                       scalefit="1"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Take home points</title>

      <para>The syntax of Pico illustrates the following points:</para>

      <itemizedlist>
        <listitem>
          <para>All modules for a syntax definition reside in a subdirectory
          named <literal>syntax</literal>.</para>
        </listitem>

        <listitem>
          <para>The main module of the syntax definition has the same name as
          the language (with an uppercase, since all module names start with
          an uppercase letter).</para>
        </listitem>

        <listitem>
          <para>The modules
          <literal>languages/pico/syntax/Identifiers</literal>,
          <literal>languages/pico/syntax/Types</literal> and
          <literal>languages/pico/syntax/Pico</literal> define (together with
          the modules they import) the syntax of the Pico language.</para>
        </listitem>

        <listitem>
          <para>This syntax can be used to:</para>

          <itemizedlist>
            <listitem>
              <para>Generate a parser that can parse Pico programs.</para>
            </listitem>

            <listitem>
              <para>Generate a syntax-directed editor for Pico programs
              (including keyword highlighting).</para>
            </listitem>

            <listitem>
              <para>Generate a parser that can parse equations containing
              fragments of Pico programs. This is similar to the use of
              different syntaxes in the definition of the
              <literal>Booleans</literal> described in <xref
              linkend="section.basic-Booleans" /> and is used for program
              analysis and transformation.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Recap: symbols</title>

      <para>In the syntax rules we have seen so far, many different
      <emphasis>symbols</emphasis> are used. <emphasis>Elementary
      symbols</emphasis> are:</para>

      <itemizedlist>
        <listitem>
          <para>Literal strings like <literal>"begin"</literal> or
          <literal>"+"</literal>.</para>
        </listitem>

        <listitem>
          <para>Sort names like <literal>PROGRAM</literal> and
          <literal>STATEMENT</literal>. Note that sorts are usually called
          <emphasis>non-terminals</emphasis>.</para>
        </listitem>

        <listitem>
          <para>Character classes like <literal>[a-z]</literal>. Character
          classes can be combined using the following operators:</para>

          <itemizedlist>
            <listitem>
              <para><literal>~</literal>: complement.</para>
            </listitem>

            <listitem>
              <para><literal>/</literal>: difference.</para>
            </listitem>

            <listitem>
              <para><literal>/\</literal>: intersection.</para>
            </listitem>

            <listitem>
              <para><literal>\/</literal>: union.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Complex symbols are:</para>

      <itemizedlist>
        <listitem>
          <para>Repetition:</para>

          <itemizedlist>
            <listitem>
              <para><literal>S*</literal>: zero or more times
              <literal>S</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>S+</literal>: one or more times
              <literal>S</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>{S1 S2}*</literal>: zero or more times
              <literal>S1</literal> <emphasis>separated by</emphasis>
              <literal>S2</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>{S1 S2}+</literal>: one or more times
              <literal>S1</literal> <emphasis>separated by</emphasis>
              <literal>S2</literal>.</para>
            </listitem>
          </itemizedlist>

          <para>Repetition is best understood by the following examples
          (assuming the rule <literal>"a" -&gt; A</literal>):</para>

          <itemizedlist>
            <listitem>
              <para><literal>A</literal> accepts <literal>a</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>A+</literal> accepts <literal>a</literal>,and
              <literal>aa</literal>, and ....</para>
            </listitem>

            <listitem>
              <para><literal>{A ";"}+</literal> accepts <literal>a</literal>,
              and <literal>a;a</literal>, and <literal>a;a;a</literal>, and
              ... but not: <literal>a;a;a;</literal>.</para>
            </listitem>
          </itemizedlist>

          <para>Slightly different patterns can be defined as well (using
          grouping and alternative as defined below):</para>

          <itemizedlist>
            <listitem>
              <para>(<literal>A ";")+</literal> accepts <literal>a;</literal>,
              and <literal>a;a;</literal>, and <literal>a;a;a;</literal> and
              ... but not <literal>a;a;a</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>(A ";"?)+</literal> accepts <literal>a</literal>,
              and <literal>a a</literal>, and <literal>a;a</literal>, and
              <literal>a;a;</literal>, and ...</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Grouping: <literal>(S1 S2 ...)</literal> is identical to
          <literal>S1 S2 ...</literal>.</para>
        </listitem>

        <listitem>
          <para>Optional: <literal>S?</literal>: zero or one occurrence of
          <literal>S</literal>.</para>
        </listitem>

        <listitem>
          <para>Alternative: <literal>S | T</literal>: an <literal>S</literal>
          or a <literal>T</literal>.</para>
        </listitem>

        <listitem>
          <para>Tuple: <literal>&lt;S,T&gt;</literal>: shorthand for
          <literal>"&lt;" S "," T "&gt;"</literal>.</para>
        </listitem>

        <listitem>
          <para>Parameterized sort: <literal>S[[ P1, P2 ]]</literal></para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Recap: syntax rules</title>

      <para>The general form of a grammar rule is:</para>

      <programlisting>S1 S2 ... Sn -&gt; S0 Attributes</programlisting>

      <para>Where <literal>S1</literal>, ... are symbols and
      <literal>Attributes</literal> is a (possibly empty) list of attributes.
      Attributes are used to define associativity (e.g,
      <literal>left</literal>), constructor functions
      (<literal>cons</literal>), and the like.</para>

      <para>Lexical syntax and context-free syntax are similar but between the
      symbols defined in a context-free rule, optional layout symbols may
      occur in the input text. A context-free rule (like the one above) is
      equivalent to:</para>

      <programlisting>S1 LAYOUT? S2 LAYOUT? ... LAYOUT? Sn -&gt; S0 Attributes</programlisting>
    </section>
  </section>

  <section>
    <title>Define a typechecker for Pico</title>

    <para>For most programming and application languages, it is not enough
    that programs are syntactically correct, i.e., that they strictly conform
    to the syntax rules of the language. In many cases, extra requirements are
    imposed on programs such as:</para>

    <itemizedlist>
      <listitem>
        <para>Variables have to be declared before they can be used.</para>
      </listitem>

      <listitem>
        <para>The operands of operators have to be of certain types.</para>
      </listitem>

      <listitem>
        <para>Procedures can only be called with parameters that correspond in
        number and type with the formal parameters with the procedure has been
        declared.</para>
      </listitem>
    </itemizedlist>

    <para>These extra requirements are usually called <emphasis>type
    constraints</emphasis>, <emphasis>typechecking rules</emphasis>, or
    <emphasis>static semantics</emphasis>. We illustrate these requirements
    for the case of Pico.</para>

    <para>The typechecking rules for the Pico language are very simple:</para>

    <itemizedlist>
      <listitem>
        <para>The only types are <literal>natural</literal> and
        <literal>string</literal>.</para>
      </listitem>

      <listitem>
        <para>All variables should be declared before use.</para>
      </listitem>

      <listitem>
        <para>Left-hand side and right-hand side of an assignment statement
        should have equal type.</para>
      </listitem>

      <listitem>
        <para>The test in while-statement and if-statement should be
        <literal>natural</literal>.</para>
      </listitem>

      <listitem>
        <para>Operands of <literal>+</literal> and <literal>-</literal> should
        be <literal>natural</literal>; their result is also
        <literal>natural</literal>.</para>
      </listitem>

      <listitem>
        <para>Operands of <literal>||</literal> should be
        <literal>string</literal>; the result is also
        <literal>string</literal>.</para>
      </listitem>
    </itemizedlist>

    <para>The task of a typechecker for Pico is to assert that a given Pico
    program complies with the above rules. The typechecker can be seen as a
    transformation from a Pico program to an error report.</para>

    <para>The import structure of the Pico typechecker is shown in <xref
    linkend="figure.Pico-typechecker-modules" />.</para>

    <figure xml:id="figure.Pico-typechecker-modules">
      <title>Import structure of Pico typechecker</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pico-typecheck-modules.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section xml:id="section.Type-environments">
      <title><literal>languages/pico/check/Type-environments</literal></title>

      <para>The purpose of type environments is to maintain a mapping between
      identifiers and their type. This is done as follows:</para>

      <programlisting>module languages/pico/check/Type-environments

imports languages/pico/syntax/Identifiers 
imports containers/Table[PICO-ID TYPE] <co xml:id="type-env.1" />

exports 
  sorts TENV TYPE 

  aliases
    Table[[PICO-ID,TYPE]] -&gt; TENV <co xml:id="type-env.2" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="type-env.1">
          <para>Import the library module <literal>containers/Table</literal>.
          It is a parameterized module with first parameter denoting the sort
          of the keys in the table and the second parameter denoting the sort
          of the values to be stored in the table. After this import, the sort
          <literal>Table[[PICO-ID,TYPE]]</literal> (sorry about the double
          square brackets!) can be used as any other sort in the
          specification.</para>
        </callout>

        <callout arearefs="type-env.2">
          <para>It is pragmatic to give a more descriptive name to
          <literal>Table[[PICO-ID,TYPE]]</literal> and we use the
          <literal>alias</literal> construct for this. From now on,
          <literal>TENV</literal> is an alias (= an abbreviation) for
          <literal>Table[[PICO-ID,TYPE]]</literal>.</para>
        </callout>
      </calloutlist>

      <para>For convenience, we list the functions of Tables here:</para>

      <programlisting>module containers/Table[Key Value]
...
context-free syntax
  "not-in-table"                   -&gt; Value  {constructor} 
  "new-table"                      -&gt; Table[[Key,Value]]               
  lookup(Table[[Key,Value]], Key)  -&gt; Value                            
  store(Table[[Key,Value]], Key, 
                            Value) -&gt; Table[[Key,Value]]               
  delete(Table[[Key,Value]], Key)  -&gt; Table[[Key,Value]]               
  element(Table[[Key,Value]], Key) -&gt; Boolean                          
  keys(Table[[Key,Value]])         -&gt; List[[Key]]                      
  values(Table[[Key,Value]])       -&gt; List[[Value]]
...</programlisting>

      <para>In the case of <literal>Type-environments</literal>, the formal
      parameter <literal>Key</literal> is bound to <literal>PICO-ID</literal>
      and <literal>Value</literal> is bound to <literal>TYPE</literal>.</para>
    </section>

    <section>
      <title><literal>languages/pico/check/Pico</literal></title>

      <para>The central idea of the Pico typechecker is to visit all language
      constructs in a given Pico program while maintaining a type environment
      that maps identifiers to their declared type. Whenever an identifier is
      used, the type correctness of that use in the given context is checked
      against its declared type that is given by the type environment. An
      error message is generated when any violation of the type rules is
      detected. The following type checker is realistic in the following
      sense:</para>

      <itemizedlist>
        <listitem>
          <para>It discovers all errors.</para>
        </listitem>

        <listitem>
          <para>It generates a message for each error.</para>
        </listitem>

        <listitem>
          <para>The error message contains the source code location of the
          Pico construct that violates the type rules.</para>
        </listitem>

        <listitem>
          <para>The type checker can be directly embedded in and used from The
          Meta-Environment.</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>Syntax part</title>

        <para>First consider the syntax part of the Pico typechecker:</para>

        <programlisting>module languages/pico/check/Pico

imports basic/Booleans
imports basic/Errors <co xml:id="pico-tc.1" />
imports languages/pico/syntax/Pico
imports languages/pico/check/Type-environments
imports utilities/PosInfo[EXP] <co xml:id="pico-tc.2" />
imports utilities/PosInfo[PICO-ID]
imports utilities/PosInfo[PROGRAM]

exports
context-free syntax
  "tcp"(PROGRAM) -&gt; {Error ","}* <co xml:id="pico-tc.3" />

hiddens
context-free syntax <co xml:id="pico-tc.4" />
  "tcd"(DECLS)                  -&gt; TENV          
  "tcits"({ID-TYPE ","}*, TENV) -&gt; TENV          
  "tcit"(ID-TYPE, TENV)         -&gt; TENV          
  "tcs"({STATEMENT ";"}*, TENV) -&gt; {Error ","}*  
  "tcst"(STATEMENT, TENV)       -&gt; {Error ","}*  
  "tce"(EXP, TYPE, TENV)        -&gt; {Error ","}*  

context-free start-symbols
  Summary PROGRAM {Error ","}*

variables
  "Message"          -&gt; StrCon            
  "Error*" [0-9\']*  -&gt; {Error ","}*      
  "Decls" [0-9\']*   -&gt; DECLS             
  "Exp" [0-9\']*     -&gt; EXP               
  "Id" [0-9\']*      -&gt; PICO-ID           
  "Id-type*" [0-9]*  -&gt; {ID-TYPE ","}*    
  "Nat-con" [0-9\']* -&gt; NatCon            
  "Series" [0-9\']*  -&gt; {STATEMENT ";"}+  
  "Stat" [0-9\']*    -&gt; STATEMENT         
  "Stat*" [0-9\']*   -&gt; {STATEMENT ";"}*  
  "Str-con" [0-9\']* -&gt; StrCon            
  "Tenv" [0-9\']*    -&gt; TENV              
  "Type" [0-9\']*    -&gt; TYPE              
  "Program" [0-9\']* -&gt; PROGRAM         </programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="pico-tc.1">
            <para>The library module <literal>basic/Errors</literal> describes
            an error format that is ubiquitous in The Meta-Environment. There
            are four categories of errors: <literal>info</literal>,
            <literal>warning</literal>, <literal>error</literal> and
            <literal>fatal</literal>. Each error contains a text that
            describes the error and a list of subjects where the error
            occurred. Each subject consists of a description and actual source
            code locations. All error messages detected by some tool are
            collected in a <literal>summary</literal> that contains an
            identifier for the tool, an identifier for this error summary and
            a list of errors. In the next subsection, various examples will be
            shown.</para>
          </callout>

          <callout arearefs="pico-tc.2">
            <para>The library module <literal>utilities/PosInfo</literal>
            defines functions to get the source code location of any part of
            the input program.</para>
          </callout>

          <callout arearefs="pico-tc.3">
            <para><literal>tcp</literal> is the main type check function for
            complete Pico programs.</para>
          </callout>

          <callout arearefs="pico-tc.4">
            <para>Several auxiliary functions are defined that are used in the
            definition of <literal>tcp</literal>. Note how some of these
            functions take a <literal>TENV</literal> (type environment) as one
            of their arguments and return a possibly modified
            <literal>TENV</literal> as result. Other functions only use the
            <literal>TENV</literal> argument and directly produce error
            messages when necessary.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title>Equations part</title>

        <para>Now let's turn our attention to the equations part of the Pico
        typechecker:</para>

        <programlisting>equations

[Main] start(PROGRAM, Program) =  <co xml:id="pico-tc-eq.1" />
       start(Summary, 
             summary("pico-check",
                     get-filename(get-location(Program)), 
                     [tcp(Program)]))                     

equations

[Tc1]  tcp(begin Decls Series end) = tcs(Series, tcd(Decls)) <co
            xml:id="pico-tc-eq.2" />

equations

[Tc2]  tcd(declare Id-type*;) = tcits(Id-type*, new-table) <co
            xml:id="pico-tc-eq.3" />

equations

[Tc3a] tcits(Id:Type, Id-type*, Tenv) = 
       tcits(Id-type*, tcit(Id:Type, Tenv)) <co xml:id="pico-tc-eq.4" />

[Tc3b] tcits(,Tenv) = Tenv <co xml:id="pico-tc-eq.5" />

equations

[Tc4a] lookup(Tenv, Id) == not-in-table
       =========================================== <co xml:id="pico-tc-eq.6" />
       tcit(Id:Type, Tenv) = store(Tenv, Id, Type)

[default] tcit(Id:Type, Tenv) = Tenv

equations

[Tc5a] tcs(Stat ; Stat*, Tenv) =  <co xml:id="pico-tc-eq.7" />
       tcst(Stat,Tenv), tcs(Stat*,Tenv)

[Tc5b] tcs(,Tenv) = 

equations

[Tc6a]
    not-in-table == lookup(Tenv, Id)
    ==========================================  <co xml:id="pico-tc-eq.8" />
    tcst(Id := Exp, Tenv) = 
    error("Variable not declared", 
          [localized("Id", get-location(Id))])

[default] tcst(Id := Exp, Tenv) = 
          tce(Exp, lookup(Tenv, Id), Tenv) <co xml:id="pico-tc-eq.9" />

[Tc6b]  tcst(if Exp then Series1 else Series2 fi, Tenv) = <co
            xml:id="pico-tc-eq.10" />
        tce(Exp, natural, Tenv), 
        tcs(Series1, Tenv), tcs(Series2, Tenv)

[Tc6c]  tcst(while Exp do Series od, Tenv) = 
        tce(Exp, natural, Tenv), tcs(Series, Tenv)

equations

[default] tce(Exp, natural, Tenv) = <co xml:id="pico-tc-eq.11" />
          error("Expression should be of type natural", 
                [localized("Expression", get-location(Exp))])
[default] tce(Exp, string, Tenv) = 
          error("Expression should be of type string", 
                [localized("Expression", get-location(Exp))])

[Tc7a]  tce(Id, Type, Tenv) = 
        when Type == lookup(Tenv, Id) <co xml:id="pico-tc-eq.12" />
[Tc7b]  tce(Nat-con, natural, Tenv) = <co xml:id="pico-tc-eq.13" />
[Tc7c]  tce(Str-con, string, Tenv) = 
[Tc7d]  tce(Exp1 || Exp2, string, Tenv) = 
        tce(Exp1, string, Tenv), tce(Exp2, string, Tenv) <co
            xml:id="pico-tc-eq.14" />
[Tc7d]  tce(Exp1 + Exp2, natural, Tenv) = 
        tce(Exp1, natural, Tenv), tce(Exp2, natural, Tenv)
[Tc7d]  tce(Exp1 - Exp2, natural, Tenv) = 
        tce(Exp1, natural, Tenv), tce(Exp2, natural, Tenv)</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="pico-tc-eq.1">
            <para>The first equation of this module is probably also the most
            intimidating one. Its role is similar to the
            <literal>main</literal> function in C programs or the
            <literal>main</literal> method in Java programs; it is an entry
            point for execution and indicates with which function execution
            starts. Here, we want to establish a connection between the
            ordinary ASF+SDF functions defined in a module and the calling
            context of The Meta-Environment. Typically, you are editing a Pico
            program and on the push of a button you want the typecheck
            function to be applied to it. The left-hand side
            <literal>start(PROGRAM, Program)</literal> defines that execution
            operates on something of the sort <literal>PROGRAM</literal>. That
            "something" is given as value of the variable
            <literal>Program</literal>. The right-hand side
            <literal>start(Summary,
            summary("pico-check",get-filename(get-location(Program)),
            [tcp(Program)]))</literal> defines in a similar fashion that the
            result sort of execution is a <literal>Summary</literal> and a
            recipe how to compute that result.</para>
          </callout>

          <callout arearefs="pico-tc-eq.2">
            <para>Type checking a complete program amounts to typechecking its
            declarations (this yields a type environment) and then checking
            its statements in that environment.</para>
          </callout>

          <callout arearefs="pico-tc-eq.3">
            <para>To type check declarations create a new type environment
            (<literal>new-table</literal>) and visit all identifier-type pairs
            in the declaration.</para>
          </callout>

          <callout arearefs="pico-tc-eq.4">
            <para>To check a list of identifier-type pairs, we have to visit
            each pair in the list. We use <emphasis>list matching</emphasis>
            to achieve this: in the left-hand side <literal>tcits(Id:Type,
            Id-type*, Tenv)</literal> the first argument of
            <literal>tcits</literal> (the list of identifier-type pairs) is
            decomposed into three values that are assigned to variables. The
            first pair is decomposed into an identifier
            (<literal>Id</literal>) and a type (<literal>Type</literal>). The
            remainder of the list is assigned to the variable<literal>
            Id-type*</literal> (note that we use the naming convention that
            variables that have lists of zero or more elements as value end on
            <literal>*</literal> and, similarly, variables that have one or
            more elements as value end on <literal>+</literal>). In the
            right-hand side of this equation, the contribution of the first
            pair to the type-environment is computed (using
            <literal>tcit</literal>) and the remainder of the list of
            identifier-type pairs is checked recursively.</para>
          </callout>

          <callout arearefs="pico-tc-eq.5">
            <para>The left-hand side <literal>tcits(,Tenv)</literal> looks
            like a typo but it is not. An empty list of identifier-type pairs
            is really denoted by the empty text!</para>
          </callout>

          <callout arearefs="pico-tc-eq.6">
            <para>An identifier that does not yet occur in the type
            environment is stored in the type environment together with its
            type.</para>
          </callout>

          <callout arearefs="pico-tc-eq.7">
            <para>Again, list matching to decompose a list of statements into
            a first statement and a list of remaining statements. Next, check
            the first statement and the remaining statements.</para>
          </callout>

          <callout arearefs="pico-tc-eq.8">
            <para>Check an assignment statement and discover that the
            identifier on the left-hand side of the assignment is not
            declared. Return an error.</para>
          </callout>

          <callout arearefs="pico-tc-eq.9">
            <para>Otherwise, check the type of the expression on the
            right-hand side of the assignment. The declared type of the
            variable on the left-hand side and the derived type of the
            expression on the right-hand side should be the same. Note that
            the <literal>[default]</literal> label in front of this equation
            characterizes it as a <emphasis>default equation</emphasis> that
            is applied after all other equations have been tried. Default
            equations serve to catch all cases that are not handled by other
            equations.</para>
          </callout>

          <callout arearefs="pico-tc-eq.10">
            <para>Checking if-statements and while-statements amounts to
            checking that the test is of type
            <literal>natural</literal>.</para>
          </callout>

          <callout arearefs="pico-tc-eq.11">
            <para>Two default equations that generate an error message when
            the expected type and the actual type of an expression are
            unequal.</para>
          </callout>

          <callout arearefs="pico-tc-eq.12">
            <para>When the declared type of an identifier is equal to the
            expected type, we generate an empty list of errors.</para>
          </callout>

          <callout arearefs="pico-tc-eq.13">
            <para>Similarly, natural constants and string constants satisfy
            the expected types natural, respectively, string.</para>
          </callout>

          <callout arearefs="pico-tc-eq.14">
            <para>For operators, the operands are checked separately.</para>
          </callout>
        </calloutlist>
      </section>
    </section>

    <section>
      <title>Using the Pico typechecker in The Meta-Environment</title>

      <para>Restart The Meta-Environment and do the following:</para>

      <itemizedlist>
        <listitem>
          <para>Open the <guimenu>Module</guimenu> menu and select
          <guimenuitem>Open...</guimenuitem>.</para>
        </listitem>

        <listitem>
          <para>In the dialog select <filename>ASF+SDF Library</filename> to
          look for modules.</para>
        </listitem>

        <listitem>
          <para>Select succesively the directories
          <filename>languages</filename>, <filename>pico</filename>,
          <filename>check</filename>, and then finally the module
          <filename>Pico.sdf</filename>. This is the top level module of the
          Pico typechecker.</para>
        </listitem>

        <listitem>
          <para>After some processing the screen results shown in <xref
          linkend="figure.pico-tc1" />.</para>
        </listitem>
      </itemizedlist>

      <para>The display of the import graph can be changed in various
      ways:</para>

      <itemizedlist>
        <listitem>
          <para>Left click and drag on the display to move to other parts of
          the import graph.</para>
        </listitem>

        <listitem>
          <para>Right click on the display to adjust the size of the graph to
          let it fit on the display.</para>
        </listitem>
      </itemizedlist>

      <figure pgwide="1" xml:id="figure.pico-tc1">
        <title>After opening languages/pico/check/Pico</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screen-pico-tc1.png" scale="55" scalefit="1"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Now select <filename>languages/pico/check/Pico</filename> (in the
      <guilabel>Modules</guilabel> panel on the left or in the import graph)
      and open our previously created Pico program
      <filename>pico-trial.trm</filename> over it (by right clicking on it,
      following the pop-up menus, and opening
      <filename>pico-trial.trm</filename>). Click somewhere in pico-trial.trm
      and observe that several term editing menus have appeared. Of particular
      interest is the menu labelled <guimenu>Pico</guimenu>, see <xref
      linkend="figure.pico-tc2" />.</para>

      <important>
        <para>The version of The meta-Environment produced to create these
        screen dumps gives two messages "constructor used more than one".
        Ignore them.</para>
      </important>

      <figure pgwide="1" xml:id="figure.pico-tc2">
        <title>Opening trial term over <filename>module
        languages/pico/check/Pico</filename></title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screen-pico-tc2.png" scale="55" scalefit="1"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The final step is now to open the <guimenu>Pico</guimenu> menu and
      to select the <guimenuitem>check</guimenuitem> button. The effect is
      that the trial Pico program will be type checked and that an error
      message will be displayed. Recall that the typecheck function
      <literal>tcp</literal> is invoked with the current Pico program as
      argument and is then reduced. See <xref
      linkend="figure.pico-tc3" />.</para>

      <figure pgwide="1" xml:id="figure.pico-tc3">
        <title>After pushing the <guimenuitem>check</guimenuitem> button in
        the <guimenu>Pico</guimenu> menu</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screen-pico-tc3.png" scale="55" scalefit="1"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The error message is more informative than it seems: unfolding it
      reveals the location of the error. Just click on the message to
      highlight the error in the source code. That is shown in <xref
      linkend="figure.pico-tc4" />.</para>

      <figure pgwide="1" xml:id="figure.pico-tc4">
        <title>Click on the error message to highlight its source</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screen-pico-tc4.png" scale="55" scalefit="1"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Take home points</title>

      <para>The Pico typechecker illustrates the following points:</para>

      <itemizedlist>
        <listitem>
          <para>ASF+SDF can be used to define a type checker.</para>
        </listitem>

        <listitem>
          <para>ASF+SDF provides support for error messages and source code
          locations.</para>
        </listitem>

        <listitem>
          <para>All modules for a typechecker reside in a subdirectory named
          <literal>check</literal>.</para>
        </listitem>

        <listitem>
          <para>A typechecker can be integrated with The Meta-Environment. It
          is activated via the <guimenuitem>check</guimenuitem> button.</para>
        </listitem>

        <listitem>
          <para>Error messages are linked back to locations in the source
          text.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Defining an evaluator for Pico</title>

    <para>In addition to syntax rules and typechecking rules, most languages
    also need evaluation rules that determine how a program is to be executed.
    Execution amounts to taking a program and all its input and computing the
    program's result by a step-by-step execution of the statements in the
    program.</para>

    <para>The evaluation rules for the Pico language are simple:</para>

    <itemizedlist>
      <listitem>
        <para>Variables of type <literal>natural</literal> are initialized to
        0.</para>
      </listitem>

      <listitem>
        <para>Variables of type <literal>string</literal> are initialized to
        the empty string.</para>
      </listitem>

      <listitem>
        <para>A variable evaluates to its current value.</para>
      </listitem>

      <listitem>
        <para>The variable on the left-hand side of an assignment statement
        gets as value the value that results from evaluating the expression on
        the right-hand side of the assignment.</para>
      </listitem>

      <listitem>
        <para>If the test in an if-statement or while-statement evaluates to
        0, this is interpreted as <emphasis>false</emphasis>.</para>
      </listitem>

      <listitem>
        <para>Conversely, if the test in an if-statement or while-statement
        evaluates to a value unequal to 0, this is interpreted as
        <emphasis>true</emphasis>.</para>
      </listitem>

      <listitem>
        <para>The statements in a list of statements are evaluated in
        sequential order.</para>
      </listitem>
    </itemizedlist>

    <para>The task of the Pico evaluator is to reduce a Pico program to the
    output it generates, in this case a value environment. The Pico evaluator
    can be seen as a transformation from a Pico program to its output.</para>

    <para>The import structure of the Pico evaluator is shownin <xref
    linkend="figure.pico-eval-modules" />.</para>

    <figure xml:id="figure.pico-eval-modules">
      <title>Import structure of Pico evaluator</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pico-eval-modules.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title><literal>languages/pico/run/Values</literal></title>

      <para>The sort <literal>VALUE</literal> is simply a container for
      integer and string constants and is defined as follows:</para>

      <programlisting>module languages/pico/run/Values

imports basic/Integers basic/StrCon

exports
  sorts VALUE
  context-free syntax
    Integer     -&gt; VALUE  <co xml:id="value.1" />
    StrCon      -&gt; VALUE
    "nil-value" -&gt; VALUE  <co xml:id="value.2" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="value.1">
          <para>It would be better to use here <literal>IntCon</literal>
          rather than <literal>Integer</literal>. This is a historic relict in
          the specification.</para>
        </callout>

        <callout arearefs="value.2">
          <para>The constant <literal>nil-value</literal> denotes error
          values.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title><literal>languages/pico/run/Value-environments</literal></title>

      <para>The purpose of value environments is to maintain a mapping between
      identifiers and their current value. This is done as follows:</para>

      <programlisting>module languages/pico/run/Value-environments

imports languages/pico/syntax/Identifiers 
imports languages/pico/run/Values 
imports containers/Table[PICO-ID VALUE]
    
exports
  sorts VENV 
  aliases
    Table[[PICO-ID, VALUE]] -&gt; VENV</programlisting>

      <para>After the discussion of <literal>Type-environments</literal> in
      <xref linkend="section.Type-environments" /> this definition should be
      easy to follow.</para>
    </section>

    <section>
      <title><literal>languages/pico/run/Pico</literal></title>

      <para>The central idea of the Pico evaluator is to first visit the
      declarations and initialise the declared variables. Next, the statements
      are visited one-by-one and their effect on the value environment is
      computed. The final value environment is then returned as the result of
      evaluation.</para>

      <section>
        <title>Syntax part</title>

        <para>The syntax part of the Pico evaluator looks as follows:</para>

        <programlisting>module languages/pico/run/Pico

imports languages/pico/syntax/Pico
imports languages/pico/run/Value-environments
imports basic/Strings

exports

  context-free syntax
    "evp"(PROGRAM)                -&gt; VENV

  context-free syntax
    "evd"(DECLS)                  -&gt; VENV
    "evits"({ID-TYPE  ","}*)      -&gt; VENV
    "evs"({STATEMENT ";"}*, VENV) -&gt; VENV
    "evst"(STATEMENT, VENV)       -&gt; VENV
    "eve"(EXP, VENV)              -&gt; VALUE

hiddens
  imports basic/Comments
  context-free start-symbols
    VALUE-ENV PROGRAM

  variables
    "Decls"[0-9\']*   -&gt; DECLS
    "Exp"[0-9\']*     -&gt; EXP
    "Id"[0-9]*        -&gt; PICO-ID
    "Id-type*"[0-9]*  -&gt; {ID-TYPE ","}*
    "Nat"[0-9\']*     -&gt; Integer 
    "Nat-con"[0-9\']* -&gt; NatCon
    "Series"[0-9\']*  -&gt; {STATEMENT ";"}+
    "Stat"[0-9\']*    -&gt; STATEMENT
    "Stat*"[0-9\']*   -&gt; {STATEMENT ";"}*
    "Str" "-con"? [0-9\']* -&gt; StrCon
    "Value"[0-9\']*   -&gt; VALUE
    "Venv"[0-9\']*    -&gt; VENV
    "Program"[0-9\']* -&gt; PROGRAM</programlisting>

        <para>Having seen the syntax part of the Pico typechecker there are no
        surprises here. The top level function <literal>evp</literal> maps
        programs to value environments and needs some auxiliary functions to
        achieve this.</para>
      </section>

      <section>
        <title>Equations part</title>

        <para>The equations part of the Pico evaluator:</para>

        <programlisting>equations

[Main] start(PROGRAM, Program) = 
       start(VENV, evp(Program)) <co xml:id="pico-eval.1" />

equations

[Ev1]  evp(begin Decls Series end) = 
       evs(Series, evd(Decls))

[Ev2]  evd(declare Id-type*;) = evits(Id-type*)

[Ev3a] evits(Id:natural, Id-type*) = 
       store(evits(Id-type*), Id, 0) <co xml:id="pico-eval.2" />

[Ev3b] evits(Id:string, Id-type*) = 
       store(evits(Id-type*), Id, "")

[Ev3c] evits() = []

[Ev4a] Venv' := evst(Stat, Venv), 
       Venv'' := evs(Stat*, Venv')
       =================================  <co xml:id="pico-eval.3" />
       evs(Stat ; Stat*, Venv) =  Venv''

[Ev4b] evs( , Venv) = Venv

[Ev5a] evst(Id := Exp, Venv) = 
       store(Venv, Id, eve(Exp, Venv))

[Ev5b]             eve(Exp, Venv) != 0
       ================================================= <co
            xml:id="pico-eval.4" />
       evst(if Exp then Series1 else Series2 fi, Venv) = 
       evs(Series1, Venv)

[Ev5c]             eve(Exp, Venv) == 0
       ================================================= <co
            xml:id="pico-eval.5" />
       evst(if Exp then Series1 else Series2 fi, Venv) = 
       evs(Series2, Venv)

[Ev5d]           eve(Exp, Venv) == 0
       ========================================== <co xml:id="pico-eval.6" />
       evst(while Exp do Series od, Venv) =  Venv

[Ev5e] eve(Exp, Venv) != 0,  Venv' := evs(Series, Venv)
       ================================================ <co
            xml:id="pico-eval.7" />
       evst(while Exp do Series od, Venv) =
       evst(while Exp do Series od, Venv')

[Ev6a] eve(Id, Venv) = lookup(Venv, Id) <co xml:id="pico-eval.8" />
[Ev6b] eve(Nat-con, Venv) = Nat-con <co xml:id="pico-eval.9" />
[Ev6c] eve(Str-con, Venv) = Str-con

[Ev6d] Nat1 := eve(Exp1, Venv),
       Nat2 := eve(Exp2, Venv)
       ==================================== <co xml:id="pico-eval.10" />
       eve(Exp1 + Exp2, Venv) = Nat1 + Nat2

[Ev6e] Nat1 := eve(Exp1, Venv),
       Nat2 := eve(Exp2, Venv)
       ======================================
       eve(Exp1 - Exp2, Venv) =  Nat1 -/ Nat2

[Ev6f] Str1 := eve(Exp1, Venv),
       Str2 := eve(Exp2, Venv),
       Str3 := concat(Str1, Str2)
       ==============================
       eve(Exp1 || Exp2, Venv) = Str3

[default-Ev6]  
       eve(Exp,Venv) = nil-value
</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="pico-eval.1">
            <para>A start equation that connects the functions defined here to
            The Meta-Environment: given a program, a value environment is
            returned and this is computed by applying the function
            <literal>evp</literal> to the program.</para>
          </callout>

          <callout arearefs="pico-eval.2">
            <para>Here declared variables are initialized.</para>
          </callout>

          <callout arearefs="pico-eval.3">
            <para>Evaluation of a series of statements. Observe how the value
            environment <literal>Venv'</literal> that is modified by executing
            the first statement is used to evaluate the remaining statements.
            In this way, the assignments made by the first statement become
            available for the remaining statements.</para>
          </callout>

          <callout arearefs="pico-eval.4">
            <para>Evaluation of if statement; the true case.</para>
          </callout>

          <callout arearefs="pico-eval.5">
            <para>Evaluation of if statement; the false case.</para>
          </callout>

          <callout arearefs="pico-eval.6">
            <para>Evaluation of while statement; the false case.</para>
          </callout>

          <callout arearefs="pico-eval.7">
            <para>Evaluation of while statement; the true case. Note that the
            body of the while statement is evaluated and that the resulting
            value environment <literal>Venv'</literal> is used to evaluate the
            next iteration of the while statement.</para>
          </callout>

          <callout arearefs="pico-eval.8">
            <para>A variable evaluates to its current value.</para>
          </callout>

          <callout arearefs="pico-eval.9">
            <para>Constants evaluate to themselves.</para>
          </callout>

          <callout arearefs="pico-eval.10">
            <para>Operators are evaluated by first evaluating their arguments
            and then applying the relevant operator to them. Observe that the
            <literal>+</literal> in the Pico expression <literal>Exp1 +
            Exp2</literal> is the plus operator as defined by Pico. The
            <literal>+</literal> operator in <literal>Nat1 + Nat2</literal> is
            the addition on integers as defined in
            <literal>basic/Integers</literal>. So we reuse the definition of
            addition on integers to define addition in Pico.</para>
          </callout>
        </calloutlist>

        <para>Now apply the evaluator function <literal>evp</literal> to our
        Pico factorial example:</para>

        <programlisting>evp(
begin declare input : natural,
                      output  :  natural,
                      repnr: natural,
                     rep: natural;
          input := 14;
          output := 1;
          while input - 1 do
              rep := output;
              repnr := input;
              while repnr - 1 do
                 output := output + rep;
                 repnr := repnr - 1
              od;
              input := input - 1
          od
end
)</programlisting>

        <para>The result is:</para>

        <programlisting>[&lt;input,1&gt;,
&lt;repnr,1&gt;,
&lt;output,87178291200&gt;,
&lt;rep,43589145600&gt;]</programlisting>
      </section>
    </section>

    <section>
      <title>Using the Pico evaluator in the Meta-EnvironmentOpen</title>

      <para>To evaluate a Pico program perform the following steps:</para>

      <itemizedlist>
        <listitem>
          <para>Open the module
          <filename>languages/pico/run/Pico.sdf</filename> from the
          <literal>ASF+SDF Library</literal>.</para>
        </listitem>

        <listitem>
          <para>Open the Pico program <literal>fac.trm</literal> over this
          module.</para>
        </listitem>

        <listitem>
          <para>Open the <guimenu>Pico</guimenu> menu and to select the
          <guimenuitem>run</guimenuitem> button. The program is evaluated and
          the result is shown in a new editor pane called
          <filename>run.out</filename>. This may take a while!</para>
        </listitem>
      </itemizedlist>

      <para>The result is shown in <xref linkend="figure.pico-run" />.</para>

      <important>
        <para>Here again, more warnings appear. They can be ignored.</para>
      </important>

      <figure pgwide="1" xml:id="figure.pico-run">
        <title>After running the factorial program.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screen-pico-run.png" scale="55" scalefit="1"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Take home points</title>

      <para>The Pico evaluator has revealed the following points:</para>

      <itemizedlist>
        <listitem>
          <para>ASF+SDF can be used to define an evaluator.</para>
        </listitem>

        <listitem>
          <para>All modules for an evaluator reside in a subdirectory named
          <literal>run</literal>.</para>
        </listitem>

        <listitem>
          <para>An evaluator can be integrated in The Meta-Environment. It is
          activated via the <guimenuitem>run</guimenuitem> button.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Defining a compiler for Pico</title>

    <para>A compiler transforms a program in some higher level language (in
    this case Pico) to a lower level, in most cases assembly language. We will
    first define the assembly language and then define the transformation
    rules from Pico to assembly language. The overall import structure is
    shown in <xref linkend="figure.pico-compiler-modules" /></para>

    <figure xml:id="figure.pico-compiler-modules">
      <title>Import structure Pico compiler</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pico-compile-modules.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title><literal>languages/pico/compile/AsssemblyLanguage</literal></title>

      <para>Now we define an assembly language for a stack-based CPU:</para>

      <programlisting>module languages/pico/compile/AssemblyLanguage

imports basic/Integers basic/Strings 
imports languages/pico/syntax/Identifiers

exports 
  sorts Label Instr
  lexical syntax
    [a-z0-9]+         -&gt; Label  <co xml:id="pico-asm.1" />

  context-free syntax
    "dclnat" PICO-ID  -&gt; Instr  <co xml:id="pico-asm.2" />
    "dclstr" PICO-ID  -&gt; Instr  

    "push" NatCon     -&gt; Instr  <co xml:id="pico-asm.3" />
    "push" StrCon     -&gt; Instr
    "rvalue" PICO-ID  -&gt; Instr  <co xml:id="pico-asm.4" />
    "lvalue" PICO-ID  -&gt; Instr  <co xml:id="pico-asm.5" />
    "assign"          -&gt; Instr  <co xml:id="pico-asm.6" />
    "add"             -&gt; Instr  <co xml:id="pico-asm.7" />
    "sub"             -&gt; Instr 
    "conc"            -&gt; Instr 
    "label" Label     -&gt; Instr  <co xml:id="pico-asm.8" />
    "goto" Label      -&gt; Instr  <co xml:id="pico-asm.9" />
    "gotrue" Label    -&gt; Instr 
    "gofalse" Label   -&gt; Instr
    "noop"            -&gt; Instr  <co xml:id="pico-asm.10" />

  sorts Instrs
context-free syntax
    {Instr";"}+       -&gt; Instrs <co xml:id="pico-asm.11" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="pico-asm.1">
          <para>Define an instruction label.</para>
        </callout>

        <callout arearefs="pico-asm.2">
          <para>Directives to allocate a variable of type
          <literal>natural</literal> or <literal>string</literal>.</para>
        </callout>

        <callout arearefs="pico-asm.3">
          <para>Push a natural constant or a string constant on the
          stack.</para>
        </callout>

        <callout arearefs="pico-asm.4">
          <para>Push the <emphasis>value</emphasis> of a variable on the
          stack.</para>
        </callout>

        <callout arearefs="pico-asm.5">
          <para>Push the <emphasis>name</emphasis> of a variable on the
          stack</para>
        </callout>

        <callout arearefs="pico-asm.6">
          <para>Assign to a variable. The top entries on the stack are the
          value to be assigned and the name of the variable. Both are removed
          after executing this instruction.</para>
        </callout>

        <callout arearefs="pico-asm.7">
          <para>The three operators for addition, subtraction and
          concatenation. They expect two values on the stack and replace them
          by the result of the operation.</para>
        </callout>

        <callout arearefs="pico-asm.8">
          <para>Declare a label. This can be a target of one of the goto
          instructions.</para>
        </callout>

        <callout arearefs="pico-asm.9">
          <para>Goto statements. The unconditional jump
          (<literal>goto</literal>) just continues execution at the
          instruction with the given label. The conditional jumps first
          inspect the top of the stack, pop it, and perform a jump depending
          on the value they found at the top of the stack.</para>
        </callout>

        <callout arearefs="pico-asm.10">
          <para>A dummy instruction.</para>
        </callout>

        <callout arearefs="pico-asm.11">
          <para>A list of instructions separated by semicolons.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title><literal>languages/pico/compile/NextLabel</literal></title>

      <para>During code generation for if-statement and while-statement, the
      need will arise to generate new labels to describe the control flow that
      is implied by these statements. The function
      <literal>nextlabel</literal> defined below describes this.</para>

      <para>The syntax part looks as follows:</para>

      <programlisting>module languages/pico/compile/NextLabel

imports languages/pico/compile/AssemblyLanguage

exports
context-free syntax
  "nextlabel" "(" Label ")" -&gt; Label <co xml:id="nextlabel.1" />

hiddens
lexical variables
  "Char+" [0-9]* -&gt; [a-z0-9]+ <co xml:id="nextlabel.2" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="nextlabel.1">
          <para>The function <literal>nextlabel</literal> takes a
          <literal>Label</literal> as argument and creates a new, unique,
          label.</para>
        </callout>

        <callout arearefs="nextlabel.2">
          <para>The definition uses a so-called <emphasis>lexical
          variable</emphasis>. Ordinary variables range over the subtrees (or
          subterms, if you prefer) of a term. In some cases it is necessary to
          be able to even inspect the contents of the lexical entities that
          form the leaves of a tree. Examples are identifiers, string
          constants and sometimes even the layout. Here we want to inspect the
          textual content of labels and define a lexical variable that ranges
          over the same lexical syntax as labels.</para>
        </callout>
      </calloutlist>

      <para>The equations part:</para>

      <programlisting>equations

 [1] nextlabel(label(Char+)) = label(Char+ x)</programlisting>

      <para>This single equation decomposes a given label into a list of
      characters. Next, it creates a new label consisting of the original list
      of characters extended with a single character <literal>x</literal>.
      Note that for every lexical sort (here: <literal>Label</literal>) there
      exits an automatically generated constructor function (here:
      <literal>label</literal>) that can be used to access the characters of a
      lexical value or to construct a new one. The former happens at the
      left-hand side of the above equation, the latter on the right-hand side.
      Also observe that this is completely type safe and that only
      syntactically correct lexical values can be constructed in this
      way.</para>
    </section>

    <section>
      <title><literal>languages/pico/compile/Pico</literal></title>

      <para>The goal of the Pico compiler is to translate a Pico program into
      an equivalent assembly language program.</para>

      <section>
        <title>Syntax part</title>

        <para>The syntax part of the Pico compiler:</para>

        <programlisting>module languages/pico/compile/Pico

imports languages/pico/syntax/Pico
imports languages/pico/compile/AssemblyLanguage 
imports languages/pico/compile/NextLabel 

  
exports
  context-free syntax
    trp( PROGRAM ) -&gt; Instrs <co xml:id="pico-comp.1" />
  
hiddens
  context-free start-symbols
    PROGRAM Instrs
  context-free syntax <co xml:id="pico-comp.2" />                     
    trd(DECLS)                   -&gt; {Instr ";"}+
    trits({ID-TYPE  ","}*)       -&gt; {Instr ";"}+ 
    trs({STATEMENT ";"}*, Label) -&gt; &lt;{Instr ";"}+, Label&gt;
    trst(STATEMENT, Label)       -&gt; &lt;{Instr ";"}+, Label&gt;
    tre(EXP)                     -&gt; {Instr ";"}+

hiddens
  variables
    "Decls"[0-9\']*   -&gt; DECLS
    "Exp"[0-9\']*     -&gt; EXP
    "Id"[0-9]*        -&gt; PICO-ID
    "Id-type*"[0-9]*  -&gt; {ID-TYPE ","}*
    "Nat-con"[0-9\']* -&gt; NatCon
    "Series"[0-9\']*  -&gt; {STATEMENT ";"}+
    "Stat"[0-9\']*    -&gt; STATEMENT
    "Stat*"[0-9\']*   -&gt; {STATEMENT ";"}*
    "Str-con"[0-9\']* -&gt; StrCon
    "Str"[0-9\']*     -&gt; String

    "Instr*"[0-9\']*  -&gt; {Instr ";"}+
    "Label" [0-9\']*  -&gt; Label
    "Program"         -&gt; PROGRAM</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="pico-comp.1">
            <para>The main compiler function translates a Pico program into a
            sequence of instructions.</para>
          </callout>

          <callout arearefs="pico-comp.2">
            <para>Auxiliary compiler functions. Observe that some of these
            functions have the output sort <literal>&lt;{Instr ";"}+,
            Label&gt;</literal>. This a tuple with as first component a list
            of instructions and as second components a label. The general idea
            is that those functions that generate new labels (for instance, to
            compile an if-statement) return an instruction sequence
            <emphasis>and</emphasis> the last label they have
            generated.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title>Equations part</title>

        <para>The equations of the Pico compiler look as follows:</para>

        <programlisting>equations

[main] start(PROGRAM, Program) = <co xml:id="pico-comp-eqs.1" />
       start(Instrs, trp(Program))

equations 

[Tr1]  Instr*1 := trd(Decls),
       &lt;Instr*2, Label&gt; := trs(Series, x)
       ============================================== <co
            xml:id="pico-comp-eqs.2" />
       trp(begin Decls Series end) = Instr*1; Instr*2

[Tr2]  trd(declare Id-type*;) = trits(Id-type*) <co xml:id="pico-comp-eqs.3" />
 
[Tr3a] trits(Id:natural, Id-type*) = <co xml:id="pico-comp-eqs.4" />
       dclnat Id;
       trits(Id-type*)
 
[Tr3b] trits(Id:string, Id-type*) = 
       dclstr Id; 
       trits(Id-type*)
 
[Tr3c] trits() = noop

[Tr4a] &lt;Instr*1, Label'&gt; := trst(Stat, Label), 
       &lt;Instr*2, Label''&gt; := trs(Stat*, Label')
       ======================================= <co xml:id="pico-comp-eqs.5" />
       trs(Stat ; Stat*, Label) = 
       &lt; Instr*1;
         Instr*2
       , 
         Label'' &gt;

[Tr4b] trs( , Label) = &lt;noop, Label&gt; <co xml:id="pico-comp-eqs.6" />

[Tr5a] Instr* := tre(Exp)
       ================== <co xml:id="pico-comp-eqs.7" />
       trst(Id := Exp, Label) = 
       &lt; lvalue Id;
         Instr*; 
         assign
       , 
         Label &gt;

[Tr5b] Instr* := tre(Exp), 
       &lt;Instr*1, Label'&gt; := trs(Series1, Label),
       &lt;Instr*2, Label''&gt; := trs(Series2, Label'),
       Label1 := nextlabel(Label''), 
       Label2 := nextlabel(Label1)                    <co
            xml:id="pico-comp-eqs.8" />
       ===================================================
       trst(if Exp then Series1  else Series2 fi, Label) =
       &lt; Instr*; 
         gofalse Label1; 
         Instr*1;
         goto Label2; 
         label Label1; 
         Instr*2;
         label Label2
       , 
         Label2 &gt;

[Tr5c] Instr*1 := tre(Exp), 
       &lt;Instr*2, Label'&gt; := trs(Series, Label),
       Label1 := nextlabel(Label'), 
       Label2 := nextlabel(Label1) 
       ======================================= <co xml:id="pico-comp-eqs.9" />
       trst(while Exp do Series od, Label) =
       &lt; label Label1; 
         Instr*1; 
         gofalse Label2; 
         Instr*2;
         goto Label1; 
         label Label2
       , 
         Label2 &gt;

[Tr6a] tre(Nat-con) = push Nat-con <co xml:id="pico-comp-eqs.10" />

[Tr6b] tre(Str-con) = push Str-con

[Tr6c] tre(Id) = rvalue Id

[Trcd] Instr*1 := tre(Exp1), Instr*2 := tre(Exp2)
       ========================================= <co xml:id="pico-comp-eqs.11" />
       tre(Exp1 + Exp2) = Instr*1; Instr*2; add

[Tr6e] Instr*1 := tre(Exp1), Instr*2 := tre(Exp2)
       ======================================== 
       tre(Exp1 - Exp2) = Instr*1; Instr*2; sub

[Tr6f] Instr*1 := tre(Exp1), Instr*2 := tre(Exp2)
       ========================================== 
       tre(Exp1 || Exp2) = Instr*1; Instr*2; conc</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="pico-comp-eqs.1">
            <para>The ubiquitous start equation that establishes that trees of
            sort <literal>PROGRAM</literal> are being transformed into a
            result of sort <literal>Instrs</literal> and this result is
            computed by the function <literal>trp</literal>.</para>
          </callout>

          <callout arearefs="pico-comp-eqs.2">
            <para>A Pico program is compiled by first compiling its
            declarations and then its instructions. The resulting instruction
            sequences are then concatenated and returned as result. Note that
            the translation of the series part of the program starts using the
            label <literal>x</literal> (the single <literal>x</literal>
            character).</para>
          </callout>

          <callout arearefs="pico-comp-eqs.3">
            <para>Compile the declarations.</para>
          </callout>

          <callout arearefs="pico-comp-eqs.4">
            <para>Compile an (id, type) pair. Depending on the declared type,
            we generate a <literal>dclnat</literal> or
            <literal>dclstr</literal> instruction.</para>
          </callout>

          <callout arearefs="pico-comp-eqs.5">
            <para>Compile a series of statements by first compiling the first
            one and then the rest. Observe the careful propagation of the
            label information.</para>
          </callout>

          <callout arearefs="pico-comp-eqs.6">
            <para>An empty series of statements is translated into a
            <literal>noop</literal> instruction.</para>
          </callout>

          <callout arearefs="pico-comp-eqs.7">
            <para>Compile an assignment statement.</para>
          </callout>

          <callout arearefs="pico-comp-eqs.8">
            <para>Compile an if-statement. Labels are created to mark the
            instructions generated for the else branch and, respectively, the
            instructions following the code generated for the if
            statement.</para>
          </callout>

          <callout arearefs="pico-comp-eqs.9">
            <para>Compile a while-statement. Two new label are generated to
            mark the instructions generated for the while statement and,
            respectively, the instructions following the code generated for
            the while loop.</para>
          </callout>

          <callout arearefs="pico-comp-eqs.10">
            <para>Constants are compiled into appropriate push
            instructions.</para>
          </callout>

          <callout arearefs="pico-comp-eqs.11">
            <para>Compilation of expressions. First compile both arguments
            (when the generated code is executed it leaves the two argument
            values on the stack) and then generate the appropriate operator
            instruction that will replace the two values on the stack by the
            result of the operator.</para>
          </callout>
        </calloutlist>

        <para>Recall the Pico example that computes factorial and let's apply
        the function <literal>trp</literal> to it:</para>

        <programlisting>trp(
begin declare input : natural,
                      output  :  natural,
                      repnr: natural,
                     rep: natural;
          input := 14;
          output := 1;
          while input - 1 do
              rep := output;
              repnr := input;
              while repnr - 1 do
                 output := output + rep;
                 repnr := repnr - 1
              od;
              input := input - 1
          od
end
)</programlisting>

        <para>The result is the following assembly language program:</para>

        <programlisting>        dclnat input; 
        dclnat output; 
        dclnat repnr; 
        dclnat rep; 
        noop; lvalue input; 
        push 14; 
        assign ; 
        lvalue output; 
        push 1; 
        assign ; 
        label xxxx; 
        rvalue input; push 1; sub; 
        gofalse xxxxx; 
        lvalue rep; 
        rvalue output; 
        assign ; 
        lvalue repnr; 
        rvalue input; 
        assign ; 
        label xx; 
        rvalue repnr; push 1; sub; 
        gofalse xxx; 
        lvalue output; 
        rvalue output; rvalue rep; add; 
        assign ; 
        lvalue repnr; 
        rvalue repnr; push 1; sub; 
        assign ; 
        noop;
        goto xx; 
        label xxx ; 
        lvalue input; 
        rvalue input; push 1; sub; 
        assign ; 
        noop;
        goto xxxx; 
        label xxxxx ; 
        noop</programlisting>
      </section>
    </section>

    <section>
      <title>Using the Pico compiler in the Meta-Environment</title>

      <para>TBD</para>

      <caution>
        <para>compile does not generate a Pico menu entry but we need to use
        Reduce instead.</para>
      </caution>
    </section>

    <section>
      <title>Take home points</title>

      <para>The Pico compiler illustrates the following issues:</para>

      <itemizedlist>
        <listitem>
          <para>ASF+SDF can be used to define a compiler.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>ASF+SDF allows the decomposition of lexical values into
          characters and the construction of syntactically correct new lexical
          values.</para>
        </listitem>

        <listitem>
          <para>Three languages are involved in the definition of the Pico
          compiler: ASF+SDF (the specification language), Pico (source
          language), and AssemblyLanguage (target language).</para>
        </listitem>

        <listitem>
          <para>The compiler can be integrated in The Meta-Environment and is
          activated via the <guimenuitem>compile</guimenuitem> button.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Intermezzo: traversal functions</title>

    <para>As we have seen in the preceding examples, functions like
    typechecking, evaluation and compilation recursively visit all nodes in
    the parse tree of a program and perform their task at each node, being
    checking, evaluation or code generation. In these cases it is unavoidable
    that we need to define an equation for each possible language construct
    that has to be processed. The number of equations will then be at least
    equal to the number of grammar rules in the syntax of the language. In the
    case of real languages, like Java or COBOL, this amounts to hundreds and
    hundreds of syntax rules and by implication of hundreds of equations as
    well.</para>

    <para>There are, fortunately, also many other applications where something
    interesting has to be done at only a few nodes. Examples are:</para>

    <itemizedlist>
      <listitem>
        <para>Computing program metrics like counting the number of
        identifiers, goto statements, McCabe complexity and the like.</para>
      </listitem>

      <listitem>
        <para>Extracting function calls.</para>
      </listitem>
    </itemizedlist>

    <para>ASF+SDF provides <emphasis>traversal functions</emphasis> that
    automate these cases. There are two important aspects of traversal
    functions:</para>

    <itemizedlist>
      <listitem>
        <para>The <emphasis>kind of traversal</emphasis>:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>accumulate</emphasis> a value during the
            traversal, this is indicated by:
            <literal>traversal(accu)</literal>. A typical example is a
            function that counts statements.</para>
          </listitem>

          <listitem>
            <para><emphasis>transform</emphasis> the tree during the
            traversal, this is indicated by:
            <literal>traversal(trafo)</literal>. A typical example is a
            function that replaces certain statements.</para>
          </listitem>

          <listitem>
            <para>accumulate and transform at the same time, this is indicated
            by: <literal>traversal(accu,trafo)</literal>:</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>The <emphasis>order of traversal</emphasis>:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>top-down</emphasis> versus
            <emphasis>bottom-up</emphasis>: In <xref linkend="figure.order" />
            the difference is shown: a top-down traversal starts with the root
            node and then traverses the root's children from the left to
            right, and so on. A bottom-up traversal, however, starts with the
            left-most leave of the tree and works its way up in the tree
            towards the root which is visited last.</para>
          </listitem>

          <listitem>
            <para><emphasis>break</emphasis> (stop at the first node where
            something can be done) or <emphasis>continue</emphasis> after
            visiting a node.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>

    <figure xml:id="figure.order">
      <title>Top-down versus bottom-up</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="traversal-order.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Simple trees</title>

      <para>Consider the following very simple language of trees:</para>

      <programlisting>module Tree-syntax
imports Naturals
exports
  sorts TREE
  context-free syntax
    NAT           -&gt; TREE <co xml:id="tree.1" />
    f(TREE, TREE) -&gt; TREE <co xml:id="tree.2" /> 
    g(TREE, TREE) -&gt; TREE
    h(TREE, TREE) -&gt; TREE
  variables <co xml:id="tree.3" />
    N[0-9]*     -&gt; NAT
    T[0-9]*     -&gt; TREE</programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="tree.1">
          <para>The leaves of a tree are natural numbers.</para>
        </callout>

        <callout arearefs="tree.2">
          <para>The symbols <literal>f</literal>, <literal>g</literal> and
          <literal>h</literal> can be used to construct composite
          trees.</para>
        </callout>

        <callout arearefs="tree.3">
          <para>The variables <filename>N</filename> and <literal>T</literal>
          (both possibly followed by digits) are defined for the convenient
          use in the following examples.</para>
        </callout>
      </calloutlist>

      <para>An example of a tree defined in this way is <literal>f(g(1,2),
      3)</literal>. Graphically, it looks as in <xref
      linkend="figure.tree" />.</para>

      <figure xml:id="figure.tree">
        <title>Example <literal>f(g(1,2),3)</literal> as tree</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="tree-examp.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Counting tree nodes (classical solution)</title>

      <para>The classical solution for counting the nodes in a tree is as
      follows:</para>

      <programlisting>module Tree-cnt
imports Tree-syntax
exports
context-free syntax
  cnt(TREE)       -&gt; NAT <co xml:id="tree-cnt-class.1" />
equations
[1] cnt(N)        = 1 <co xml:id="tree-cnt-class.2" />
[2] cnt(f(T1,T2)) = 1+cnt(T1)+cnt(T2) <co xml:id="tree-cnt-class.3" />
[3] cnt(g(T1,T2)) = 1+cnt(T1)+cnt(T2)
[4] cnt(h(T1,T2)) = 1+cnt(T1)+cnt(T2)</programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="tree-cnt-class.1">
          <para>The function <literal>cnt</literal> visits all nodes in a tree
          and returns the number of nodes.</para>
        </callout>

        <callout arearefs="tree-cnt-class.2">
          <para>Visiting a leaf (a number) counts for one.</para>
        </callout>

        <callout arearefs="tree-cnt-class.3">
          <para>Visiting a non-leaf counts for one (this node) plus the counts
          for the left and the right subtree. An equation is needed for every
          constructor in the tree language.</para>
        </callout>
      </calloutlist>

      <para>Counting the nodes of our previous example is achieved as
      follows:</para>

      <programlisting>cnt(f(g(1, 2), 3))</programlisting>

      <para>and returns:</para>

      <programlisting>5</programlisting>

      <para>The steps to arrive at this result are shown in <xref
      linkend="figure.reducing-cnt" />.</para>

      <figure xml:id="figure.reducing-cnt">
        <title>Reducing <literal>cnt(f(g(1, 2), 3))</literal></title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="cnt-reduction.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Counting tree nodes (using an accumulator)</title>

      <para>Let's now reformulate the node counting example using traversal
      functions:</para>

      <programlisting>module Tree-cnt
imports Tree-syntax
exports
 context-free syntax
    cnt(TREE, NAT) -&gt; NAT {traversal(accu,  <co xml:id="tree-cnt-trav.1" />
                                     bottom-up,
                                     continue)}
equations
[1] cnt(T, N) = N + 1  <co xml:id="tree-cnt-trav.2" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="tree-cnt-trav.1">
          <para>Define <literal>cnt</literal> as a bottom-up accumulator that
          continues after each matching node. The second argument is the
          accumulator used for counting. Observe that in this example, it is
          arbitrary whether we do a bottom-up or a top-down traversal.</para>
        </callout>

        <callout arearefs="tree-cnt-trav.2">
          <para>A single equation is needed to count any node (both leaves and
          complex nodes). The first argument <literal>T</literal> matches any
          tree, and the accumulator value <literal>N</literal> is incremented
          for it. Given this incremented value, the following nodes of the
          tree will be visited and counted.</para>
        </callout>
      </calloutlist>

      <para>Counting the nodes of the example</para>

      <programlisting>cnt( f( g( f(1,2), 3 ),
           g( g(4,5), 6 )),
       0)</programlisting>

      <para>gives:</para>

      <programlisting>11</programlisting>
    </section>

    <section>
      <title>Increment and modify tree leaves (using a transformer)</title>

      <para>Now we switch to a simple transformation example: given a tree
      construct a new one that is identical except that all values at the
      leaves are incremented by one. This is achieved as follows:</para>

      <programlisting>module Tree-inc
imports Tree-syntax
exports
context-free syntax
  inc(TREE) -&gt; TREE {traversal(trafo, <co xml:id="tree-inc.1" />
                               bottom-up,
                               continue)}
equations
[1] inc(N) = N + 1  <co xml:id="tree-inc.2" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="tree-inc.1">
          <para>The transformer <literal>inc</literal> will compute the
          desired tree. Observe the type of this functions: it transforms
          trees to trees.</para>
        </callout>

        <callout arearefs="tree-inc.2">
          <para>The single equation that performs the replacement. Observe
          that this equation only matches at nodes that contain an integer
          (this is due to the <literal>N</literal> argument on the left-hand
          side). When the equation is applicable it replaces the give integer
          leaf by an incremented one.</para>
        </callout>
      </calloutlist>

      <para>The example:</para>

      <programlisting>inc( f( g( f(1,2),  3 ),
           g( g(4,5), 6 )) )</programlisting>

      <para>gives:</para>

      <programlisting>f( g( f(2,3), 4 ),
      g( g(5,6), 7 ))</programlisting>
    </section>

    <section>
      <title>Increment with variable amount and modify tree leaves (using
      transformer)</title>

      <para>Continuing the incrementing example, we now want to make the
      <emphasis>amount</emphasis> of the increment variable.</para>

      <programlisting>module Tree-incp
imports Tree-syntax
exports
context-free syntax
  inc(TREE, NAT) -&gt; TREE {traversal(trafo, <co xml:id="tree-incp.1" />
                                    bottom-up,
                                    continue)}
equations
[1] inc(N1, N2) = N1 + N2 <co xml:id="tree-incp.2" /></programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="tree-incp.1">
          <para>We define a new <literal>inc</literal> function with a second
          argument that represents the amount of the increment.</para>
        </callout>

        <callout arearefs="tree-incp.2">
          <para>The equation has to be adjusted as well. <literal>N1</literal>
          matches an node (as before) and <literal>N2</literal> represents the
          desired increment. Application of this equation replaces the current
          leaf by its value increment with <literal>N2</literal>.</para>
        </callout>
      </calloutlist>

      <para>Example:</para>

      <programlisting>inc( f( g( f(1,2),  3 ),
           g( g(4,5), 6 )),
       7 )</programlisting>

      <para>Result:</para>

      <programlisting>f( g( f( 8,  9), 10),
      g( g(11,12),  13))</programlisting>
    </section>

    <section>
      <title>Tree replacement</title>

      <para>Performing replacements in trees is a frequently occurring
      operation. Typically, certain values in a tree have to be replaced by
      other ones. These values can be simple or complex. One can distinguish
      different forms of replacement:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Deep replacement</emphasis> replaces only
          occurrences close to the leaves of the tree.</para>
        </listitem>

        <listitem>
          <para><emphasis>Shallow replacement</emphasis> replaces only
          occurrences close to the root.</para>
        </listitem>

        <listitem>
          <para><emphasis>Full replacement</emphasis> replaces all occurrences
          in a tree.</para>
        </listitem>
      </itemizedlist>

      <para>These forms of replacement form a nice test case for traversal
      functions and we will discuss each in detail. The task at hand will be:
      perform a deep/shallow/full replacement of all function symbols
      <literal>g</literal> by a new function symbol
      <literal>i</literal>.</para>

      <section>
        <title>Deep replacement</title>

        <para>Deep replacement only replaces occurrences close to the leaves
        of the tree. This suggests a bottom-up approach where on each path
        from the root of the tree to each leaf, at most one replacement may
        occur. This is exactly what the break attribute of traversal function
        achieves.</para>

        <programlisting>module Tree-drepl
imports Tree-syntax
exports
context-free syntax
   i(TREE, TREE)   -&gt; TREE <co xml:id="drepl.1" />
   drepl(TREE)      -&gt; TREE {traversal(trafo,
                                       bottom-up,
                                       break)} <co xml:id="drepl.2" />
equations
[1] drepl(g(T1, T2)) = i(T1, T2) <co xml:id="drepl.3" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="drepl.1">
            <para>Add the additional tree constructor i to make examples
            slightly more interesting.</para>
          </callout>

          <callout arearefs="drepl.2">
            <para>The function <literal>drepl</literal> is a bottom-up
            transformer that stops at the first match on each path from root
            to leaf.</para>
          </callout>

          <callout arearefs="drepl.3">
            <para>The equation that performs the actual replacement: the
            subtree <literal>g(T1, T2)</literal> is replaced by <literal>i(T1,
            T2)</literal>.</para>
          </callout>
        </calloutlist>

        <para>An example:</para>

        <programlisting>drepl( f( g( f(1,2), 3 ),
          g( g(4,5), 6 )) )</programlisting>

        <para>results in:</para>

        <programlisting>f( i( f(1,2), 3 ),
     g( i(4,5), 6 ))</programlisting>

        <para>Indeed, only the deepest occurrences of <literal>g</literal>
        have been replaced.</para>
      </section>

      <section>
        <title>Shallow replacement</title>

        <para>Shallow replacement only replaces occurrences close to the root
        of the tree. This suggests a top-down approach where on each path from
        the root of the tree to each leaf, at most one replacement may occur.
        This is exactly what the break attribute of traversal function
        achieves.</para>

        <programlisting>module Tree-srepl
imports Tree-syntax
exports
context-free syntax
   i(TREE, TREE)   -&gt; TREE
   srepl(TREE)      -&gt; TREE {traversal(trafo, 
                                       top-down, 
                                       break)} <co xml:id="srepl.1" />
equations
[1] srepl(g(T1, T2)) = i(T1, T2)</programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="srepl.1">
            <para>The function <literal>srepl</literal> is a top-down
            transformer that stops at the first match on each path from root
            to leaf.</para>
          </callout>
        </calloutlist>

        <para>The example:</para>

        <programlisting>srepl( f( g( f(1,2), 3 ),
          g( g(4,5), 6 )) )</programlisting>

        <para>results in:</para>

        <programlisting>f( i( f(1,2), 3 ),
     i( g(4,5), 6 ))</programlisting>

        <para>As expected, only the outermost occurrences of
        <literal>g</literal> have been replaced.</para>
      </section>

      <section>
        <title>Full replacement</title>

        <para>Full replacement replaces all occurrences in the tree. In this
        case, there is no difference between a top-down or a bottom-up
        approach. The continue attribute of traversal function achieves
        traversal of all tree nodes.</para>

        <programlisting>module Tree-frepl
imports Tree-syntax
exports
context-free syntax
   i(TREE, TREE)   -&gt; TREE
   frepl(TREE)      -&gt; TREE {traversal(trafo,
                                       top-down,
                                       continue)}
equations
[1] frepl(g(T1, T2)) = i(T1, T2)</programlisting>

        <para>The example</para>

        <programlisting>frepl( f( g( f(1,2), 3 ),
          g( g(4,5), 6 )) )</programlisting>

        <para>results in:</para>

        <programlisting>f( i( f(1,2), 3 ),
     i( i(4,5), 6 ))</programlisting>

        <para>Indeed, all occurrences of <literal>g</literal> have now been
        replaced.</para>
      </section>
    </section>

    <section>
      <title>A real example: COBOL transformation</title>

      <para>Now let's turn our attention to a real example of traversal
      functions. The problem is that COBOL75 has two forms of
      if-statement:</para>

      <itemizedlist>
        <listitem>
          <para><literal>"IF" Expr "THEN" Stats "END-IF"?</literal></para>
        </listitem>

        <listitem>
          <para><literal>"IF" Expr "THEN" Stats "ELSE" Stats
          "END-IF"?</literal></para>
        </listitem>
      </itemizedlist>

      <para>In other words, COBOL75 has an if-then statement and an
      if-then-else statement and both end on an optional keyword
      <literal>END-IF</literal>. This leads to the well known dangling else
      problem that may cause ambiguities in nested if statements. Given</para>

      <programlisting>IF expr1 THEN IF expr2 THEN stats1 ELSE stats2</programlisting>

      <para>Is this an if-then statement with an if-then-else statement as
      then branch as suggested by the following layout:</para>

      <programlisting>IF expr1 THEN 
   IF expr2 THEN 
      stats1 
   ELSE 
      stats2</programlisting>

      <para>Or is it the other way around, an if-then-else statement with an
      if-then statement as then branch:</para>

      <programlisting>IF expr1 THEN 
   IF expr2 THEN 
      stats1 
ELSE 
   stats2</programlisting>

      <para>This is utterly confusing and error-prone, therefore it is a good
      idea to add END-IF to all if-statement to indicate that either</para>

      <para><programlisting>IF expr1 THEN 
   IF expr2 THEN 
      stats1 
   ELSE 
      stats2
   END-IF
END-IF</programlisting>or</para>

      <para><programlisting>IF expr1 THEN 
   IF expr2 THEN 
      stats1
   END-IF
ELSE 
   stats2
END-IF</programlisting>is intended.</para>

      <para>The following excerpt from a real application achieves
      this:</para>

      <programlisting>module End-If-Trafo
imports Cobol   <co xml:id="cobol.1" />
exports
context-free syntax
  addEndIf(Program) -&gt; Program {traversal(trafo,
                                          continue,
                                          top-down)} <co xml:id="cobol.2" />
variables
 "Stats"[0-9]*      -&gt; StatsOptIfNotClosed
 "Expr"[0-9]*       -&gt; L-exp
 "OptThen"[0-9]*    -&gt; OptThen
equations
[1] addEndIf(IF Expr OptThen Stats)  =
             IF Expr OptThen Stats END-IF <co xml:id="cobol.3" />

[2] addEndIf(IF Expr OptThen Stats1 ELSE Stats2) =
             IF Expr OptThen Stats1 ELSE Stats2 END-IF</programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="cobol.1">
          <para>Import the COBOL grammar. It is huge and consists of hundreds
          of syntax rules.</para>
        </callout>

        <callout arearefs="cobol.3">
          <para>The transformer <literal>addEndIf</literal> will perform the
          desired transformation.</para>
        </callout>

        <callout arearefs="cobol.3">
          <para>Two equations define the transformation for an if-then,
          respectively, an if-then-else statement with missing
          <literal>END-IF</literal> keyword.</para>
        </callout>
      </calloutlist>

      <para>It must be stressed that, due to the nesting of if-statements,
      such a kind of transformation can never be done by a tool that is based
      on lexical analysis alone. The enormous savings due to the use of
      traversal functions should also be stressed: only two equations suffice
      to define the required transformation. Compare this with the hundreds of
      equations that would have been needed without traversal
      functions.</para>
    </section>

    <section>
      <title>A funny Pico typechecker</title>

      <para>To conclude these illustrations of the use of traversal functions,
      we reconsider the problem of Pico typechecking and present a completely
      alternative solution that does not use type environments. Given a Pico
      program, the overall approach is to remove those part that are type
      correct and to repeat this process as long as possible. A type correct
      program will hence be reduced to an empty program, while a
      type-incorrect program will be reduced to a program that precisely
      contains the incorrect statements. The replacement strategy is as
      follows:</para>

      <itemizedlist>
        <listitem>
          <para>Replace all constants by their type, e.g.,
          <literal>3</literal> becomes
          <literal>type(natural)</literal>.</para>
        </listitem>

        <listitem>
          <para>Replace all variables by their declared type, e.g., <literal>x
          + 3</literal> becomes <literal>type(natural) +
          type(natural)</literal>.</para>
        </listitem>

        <listitem>
          <para>Simplify type correct expressions, e.g.,
          <literal>type(natural) + type(natural)</literal> becomes
          <literal>type(natural)</literal>.</para>
        </listitem>

        <listitem>
          <para>Remove all type correct statements, e.g.,
          <literal>type(natural) := type(natural)</literal> is removed.</para>
        </listitem>
      </itemizedlist>

      <para>Consider the erroneous program:</para>

      <programlisting>begin 
   declare x : natural,
                y : natural,
                s : string;
      x := 10; s := "abc";
      if x then 
             x := x + 1
      else 
             s := x + 2
      fi;
      y := x + 2;
end</programlisting>

      <para>(take a second to spot the error) will thus reduce to:</para>

      <programlisting>begin
  declare;
  type(string) := type(natural);
end</programlisting>

      <para>This style of type checking leads to descriptive messages
      concerning the cause of errors and is an alternative to the style where
      explicit error locations have to be taken into account in the
      specification.</para>

      <para>The "funny" Pico typechecker is defined as follows:</para>

      <programlisting>module Pico-typecheck
imports Pico-syntax
exports
context-free syntax
 type(TYPE)                  -&gt; ID  <co xml:id="pico-funny.1" />
 replace(STATS, ID-TYPE) <co xml:id="pico-funny.2" /> -&gt; STATS {traversal(trafo,
                                                 bottom-up,
                                                 break)}
 replace(EXP     , ID-TYPE)  -&gt; EXP   {traversal(trafo,
                                                 bottom-up,
                                                 break)}
variables
   ...
equations
[0] begin declare Id-type, Decl*; Stat* end = <co xml:id="pico-funny.3" />
      begin declare Decl*; replace(Stat*, Id-type) end

[1] replace(Id     , Id : Type) = type(Type) <co xml:id="pico-funny.4" />
[2] replace(Nat-con, Id : Type) = type(natural)
[3] replace(Str-con, Id : Type) = type(string)

[4] type(string) || type(string)  = type(string) <co xml:id="pico-funny.5" />
[5] type(natural) + type(natural) = type(natural)
[6] type(natural) - type(natural) = type(natural)

[7] Stat*1; if type(natural) then Stat*2 else Stat*3 fi ; Stat*4
     = Stat*1; Stat*2; Stat*3; Stat*4 <co xml:id="pico-funny.6" />

[8] Stat*1; while type(natural) do Stat*2 od; Stat*3
     = Stat*1; Stat*2; Stat*3

[9] Stat*1; type(Type) := type(Type); Stat*2
     = Stat*1; Stat*2</programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="pico-funny.1">
          <para>First we have to extend the Pico syntax, to allow type
          indications in the code. Here, we allow at every position where an
          identifier may occur a type indication of the form
          <literal>type(natural)</literal> or
          <literal>type(string)</literal>.</para>
        </callout>

        <callout arearefs="pico-funny.2">
          <para>The traversal function <literal>replace</literal> will replace
          a specific identifier (as defined by its second argument) in a Pico
          program. Since programs are composed of subtrees of various sorts
          (e.g., <literal>PROGRAM</literal>, <literal>DECL</literal>,
          <literal>STAT</literal>, <literal>EXP</literal>, ...) the first
          argument of replace may range over all these sorts. Each variant
          that is <emphasis>used in the equations</emphasis> has to be
          declared here.</para>
        </callout>

        <callout arearefs="pico-funny.3">
          <para>Visit each variable declaration and use
          <literal>replace</literal> to replace the variable by its type in
          the body of the program.</para>
        </callout>

        <callout arearefs="pico-funny.4">
          <para>Replace constants and variables by their type.</para>
        </callout>

        <callout arearefs="pico-funny.5">
          <para>Replace type-correct expressions by their type.</para>
        </callout>

        <callout arearefs="pico-funny.6">
          <para>Remove type-correct expressions and statements.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>Take home points</title>

      <para>This intermezzo introduces the following points:</para>

      <itemizedlist>
        <listitem>
          <para>For tree traversals that have to do work at every node, it is
          unavoidable to write many equations to describe the traversal: at
          least one equation is needed for every rule in the grammar of the
          language in question. Examples are typechecking, evaluation and code
          generation.</para>
        </listitem>

        <listitem>
          <para>Other applications only have to do work at a few types of
          nodes. This is exemplified by various forms of metrics calculation
          and fact extraction.</para>
        </listitem>

        <listitem>
          <para>Traversal functions automate such applications: only equations
          are needed for the cases where real work has to be done at a node;
          the other cases are handled automatically.</para>
        </listitem>

        <listitem>
          <para>An <emphasis>accumulator</emphasis> is a traversal function
          that computes a certain value during the traversal of the
          tree.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>transformer</emphasis> is a traversal function
          that transform the tree during the traversal.</para>
        </listitem>

        <listitem>
          <para>An <emphasis>accumulating transformer</emphasis> combines
          these functionalities.</para>
        </listitem>

        <listitem>
          <para>Traversal functions can traverse the tree from root to leaves
          (<emphasis>top-down</emphasis>) or from leaves to root
          (<emphasis>bottom-up</emphasis>).</para>
        </listitem>

        <listitem>
          <para>Traversal functions can visit all nodes on each path from root
          to tree (<emphasis>continuous</emphasis>) or only the first matching
          node (<emphasis>break</emphasis>).</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Define a fact extractor for Pico</title>

    <para>The goal of a fact extractor is to extract information from source
    files that can be used by later analysis tools. Fact extraction is tightly
    coupled to the requirements of the analysis tools and can differ widely
    per application. Here we show a simple fact extractor that
    extracts:</para>

    <itemizedlist>
      <listitem>
        <para>A control flow graph.</para>
      </listitem>

      <listitem>
        <para>A statement histogram.</para>
      </listitem>
    </itemizedlist>

    <para>The import structure is shown in <xref
    linkend="figure.pico-extract-modules" />.</para>

    <figure xml:id="figure.pico-extract-modules">
      <title>Import structure Pico fact extractor</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pico-extract-modules.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Two imported modules require explanation, but we do not go into too
    much details.</para>

    <para>The module <literal>utilitities/Rstores</literal> defines
    <emphasis>rstores</emphasis>, relation stores, that are used to maintain
    mapping between a typed variable and a set or relation. Rstores are used
    to collect the extracted facts and can be used later on by analysis tools.
    Typical operations are:</para>

    <itemizedlist>
      <listitem>
        <para><literal>create-store</literal>: create a new rstore.</para>
      </listitem>

      <listitem>
        <para><literal>declare</literal>: define a new variable with its type
        and initial value.</para>
      </listitem>

      <listitem>
        <para><literal>set</literal>: assign a value to a variable in the
        rstore.</para>
      </listitem>
    </itemizedlist>

    <para>The module <literal>utilities/Parsing</literal> defines parsing and
    unparsing functions for values of specific sorts. The only function that
    we will use is:</para>

    <itemizedlist>
      <listitem>
        <para><literal>unparse-to-string</literal>: convert an arbitrary value
        (like an identifier, expression, or statement in a Pico program) to a
        string value. This conversion is necessary since sets and relations
        can only contain basic values like integers and strings and no complex
        values like fragments from parse trees.</para>
      </listitem>
    </itemizedlist>

    <section>
      <title><literal>languages/pico/extract/Pico</literal></title>

      <para>The syntax definition of the Pico fact extractor:</para>

      <programlisting>module languages/pico/extract/Pico

imports utilities/RStores
imports languages/pico/syntax/Pico
imports basic/Integers
imports utilities/Parsing[PICO-ID] <co xml:id="pico-extract.1" />
imports utilities/Parsing[STATEMENT]
imports utilities/Parsing[EXP]
imports utilities/PosInfo[STATEMENT]
imports utilities/PosInfo[EXP]

hiddens
context-free syntax
  controlFlow(PROGRAM, RStore)        -&gt; RStore  <co
          xml:id="pico-extract.2" />
  statementHistogram(PROGRAM, RStore) -&gt; RStore  <co
          xml:id="pico-extract.3" />

context-free syntax <co xml:id="pico-extract.4" />
  countStatements(PROGRAM, RStore)    -&gt; RStore  
                                         {traversal(accu, 
                                                    bottom-up, 
                                                    continue)} 
  countStatements(STATEMENT, RStore)  -&gt; RStore 
                                         {traversal(accu, 
                                                    bottom-up, 
                                                    continue)} 
  cflow({STATEMENT ";"}*)             -&gt; &lt;RElem,RElem,RElem&gt;                                        

context-free start-symbols
  PROGRAM RStore RElem

variables
  "Program" [0-9]* -&gt; PROGRAM           
  "Decls" [0-9]*   -&gt; DECLS             
  "Stat" [0-9]*    -&gt; STATEMENT         
  "Stat*" [0-9]*   -&gt; {STATEMENT ";"}*  
  "Stat+" [0-9]*   -&gt; {STATEMENT ";"}+  
  "Exp" [0-9]*     -&gt; EXP               
  "Id" [0-9]*      -&gt; PICO-ID           
  "Entry" [0-9]*   -&gt; RElem             
  "Exit" [0-9]*    -&gt; RElem             
  "Rel" [0-9]*     -&gt; RElem             
  "Control" [0-9]* -&gt; RElem             

variables <co xml:id="pico-extract.5" />
  "Store"[0-9]*    -&gt; RStore  {strict}
  "Int" [0-9]*     -&gt; Integer {strict} 
</programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="pico-extract.1">
          <para>The modules <literal>utilities/Parsing</literal> and
          <literal>utilities/PosInfo</literal> are instantiated for all
          relevant sorts.</para>
        </callout>

        <callout arearefs="pico-extract.2">
          <para>Given a Pico program and an rstore, the function
          <literal>controlFlow</literal> adds a controlflow relation to the
          given rstore.</para>
        </callout>

        <callout arearefs="pico-extract.3">
          <para>Similarly, function <literal>statementHistogram</literal> adds
          a histogram relation to the rstore.</para>
        </callout>

        <callout arearefs="pico-extract.4">
          <para>These two functions are implemented using auxiliary traversal
          functions.</para>
        </callout>

        <callout arearefs="pico-extract.5">
          <para>Variables can be annotated with the attributes
          <literal>wild</literal> and <literal>strict</literal>. They do not
          change the meaning of variables but help in enforcing their correct
          usage:</para>

          <itemizedlist>
            <listitem>
              <para>Wild variables may only be used once in an equation to
              receive a value (as a result of matching or evaluating a
              condition) but that value may not be user later on in the
              equation. Wild variables serve to match an arbitrary part of the
              input that is not re-used later. Typical error case: using the
              same variable to match two arbitrary parts of the input term and
              by doing so erroneously enforcing that both arbitrary parts are
              identical.</para>
            </listitem>

            <listitem>
              <para>Strict variables receive a value and that value may be
              used precisely once. Typical error case: using some intermediate
              variables to represent a global state and incorrectly passing
              the latest version of the global state to another
              function.</para>
            </listitem>
          </itemizedlist>
        </callout>
      </calloutlist>

      <para>The equations for the Pico fact extractor:</para>

      <programlisting>equations

[main] Store1 := create-store(),
       Store2 := statementHistogram(Program, Store1),
       Store3 := controlFlow(Program, Store2)
       =============================================== <co
          xml:id="pico-extract-eqs.1" />
       start(PROGRAM, Program) = start(RStore, Store3)

equations

[hist] statementHistogram(Program, Store) = <co xml:id="pico-extract-eqs.2" />
       countStatements(Program, 
                       declare(Store, 
                               StatementHistogram, 
                               rel[str,int]))

equations

[cS1] countStatements(Id := Exp, Store)  =  <co xml:id="pico-extract-eqs.3" />
      inc(Store, StatementHistogram, "Assignment")

[cS2] countStatements(if Exp 
                      then Stat*1 
                      else Stat*2 fi, 
                      Store) = 
      inc(Store, StatementHistogram, "Conditional")

[cS3] countStatements(while Exp do Stat* od, Store) = 
      inc(Store, StatementHistogram, "Loop")

equations

[cfg] Store1 := declare(Store, 
                        ControlFlow, 
                        rel[&lt;str,loc&gt;,&lt;str,loc&gt;]),
      &lt;Entry, Rel, Exit&gt; := cflow(Stat*)
      ============================================ <co
          xml:id="pico-extract-eqs.4" />
      controlFlow(begin Decls Stat* end, Store) = 
      set(Store1, ControlFlow, Rel)

equations

[cfg-1] 
     &lt;Entry1, Rel1, Exit1&gt; := cflow(Stat), 
     &lt;Entry2, Rel2, Exit2&gt; := cflow(Stat+)
     ===================================== <co xml:id="pico-extract-eqs.5" />
     cflow(Stat ; Stat+) = 
     &lt; 
      Entry1, 
      union(Rel1, union(Rel2, product(Exit1, Entry2))), 
      Exit2
     &gt;

[cfg-2] cflow() = &lt;{}, {}, {}&gt;

equations

[cfg-3]  
     &lt;Entry, Rel, Exit&gt; := cflow(Stat*),
     Control := &lt;unparse-to-string(Exp), 
                 get-location(Exp)&gt;
     ================================== <co xml:id="pico-extract-eqs.6" />
     cflow(while Exp do Stat* od) = 
     &lt; 
      {Control},
      union(product({Control}, Entry), 
            union(Rel, product(Exit, {Control}))),
      {Control}
     &gt;

[cfg-4]  
     &lt;Entry1, Rel1, Exit1&gt; := cflow(Stat*1), 
     &lt;Entry2, Rel2, Exit2&gt; := cflow(Stat*2),
     Control := &lt;unparse-to-string(Exp), 
                 get-location(Exp)&gt;
     ==========================================  <co
          xml:id="pico-extract-eqs.7" />
     cflow(if Exp then Stat*1 else Stat*2 fi) =
     &lt; 
      {Control},
      union(product({Control}, Entry1), 
            union(product({Control}, Entry2), 
                  union(Rel1, Rel2))),
      union(Exit1, Exit2)
    &gt; 

[default-cfg]
    Control := &lt;unparse-to-string(Stat), 
                get-location(Stat)&gt;
    =========================================
    cflow(Stat) = &lt;{Control}, {}, {Control}&gt;</programlisting>

      <para>Notes:</para>

      <calloutlist>
        <callout arearefs="pico-extract-eqs.1">
          <para>A start equation that links the extractor to the
          Meta-Environment: it creates a new rstore, fills it with the two
          defined extractions, and returns it as result.</para>
        </callout>

        <callout arearefs="pico-extract-eqs.2">
          <para>Add a new variable <literal>StatementHistogram</literal> of
          type <literal>rel[str,int]</literal> to the store and apply the
          auxiliary function <literal>countStatements</literal> to collect the
          desired facts.</para>
        </callout>

        <callout arearefs="pico-extract-eqs.3">
          <para>Perform the counting for three statement categories:
          assignments, conditionals and loops. For each category a tuple of
          the form <literal>&lt;<replaceable>Category</replaceable>,
          <replaceable>N</replaceable>&gt;</literal> is added to the relation.
          The function <literal>inc</literal> (imported via the module
          <literal>RStores</literal>) adds the value of
          <literal><replaceable>N</replaceable></literal> for the relavant
          category (or creates a new tuple if it did not yet exist).</para>
        </callout>

        <callout arearefs="pico-extract-eqs.4">
          <para>The function <literal>controlFlow</literal> declares a new
          variable <literal>ControlFlow</literal> of type
          <literal>rel[&lt;str,loc&gt;,&lt;str,loc&gt;]</literal> and applies
          the auxilary function <literal>cflow</literal> to collect the
          facts.</para>
        </callout>

        <callout arearefs="pico-extract-eqs.5">
          <para>The function cflow retruns a triple: the entry points, the
          internal control flow, and the exit points of the investigated
          language construct. In the case of a statement sequence, the exits
          of the first statement and the entries of the following statements
          have to be connected via a Carthesian product to create all possible
          control flow transfers between them. The internal relations Rel1 and
          Rel2 are added to this and the appropriate triple is
          returned.</para>
        </callout>

        <callout arearefs="pico-extract-eqs.6">
          <para>A slightly more complex construction in order to cater for all
          control flows in a while loop. Observe that the control expression
          is the entry as well as the exit of the while-statement. Internally,
          the exits of the body of the loop have to be connected whith the
          control expression.</para>
        </callout>

        <callout arearefs="pico-extract-eqs.7">
          <para>Here again, some plumbing is necessary to collect all the
          possible control flow from control expression, via then or else
          branch to the exits of the statement.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>Using the Pico extractor in the Meta-Environment</title>

      <para>To run a fact extraction on a Pico program perform the following
      steps:</para>

      <itemizedlist>
        <listitem>
          <para>Open the module
          <filename>languages/pico/extract/Pico.sdf</filename> from the
          <literal>ASF+SDF Library</literal>.</para>
        </listitem>

        <listitem>
          <para>Open the term <filename>fac.trm</filename> over this module
          (you may need to copy it first from this article or from the
          <filename>SDF Library</filename> in the
          <filename>examples</filename> directory).</para>
        </listitem>

        <listitem>
          <para>Open the <guimenu>Pico</guimenu> menu and select the entry
          <guimenuitem>extract</guimenuitem>.</para>
        </listitem>
      </itemizedlist>

      <para>After some delay the extraction is complete (check, for instance,
      the progress messages at the bottom of the window). The result is an
      rstore that we can inspect with the fact browser that is available in
      the left pane under <guilabel>Facts</guilabel>. For the various
      variables in the rstore different visualisations are available (they
      depend on the actual type of each variable). The effect of selecting the
      graph visualization for the <literal>ControlFlow</literal> variable is
      shown in <xref linkend="figure.pico-extract" />.</para>

      <figure pgwide="1" xml:id="figure.pico-extract">
        <title>Graph display of ControlFlow</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screen-pico-extract.png" scale="55"
                       scalefit="1"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Another example is the visualization of the
      <literal>StatementHistogram</literal> variable as bar chart shown in
      <xref linkend="figure.pico-extract2" />.</para>

      <figure pgwide="1" xml:id="figure.pico-extract2">
        <title>Bar chart display of StatementHistogram</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screen-pico-extract2.png" scale="55"
                       scalefit="1"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Take home points</title>

      <para>The Pico extractor illustrates the following points:</para>

      <itemizedlist>
        <listitem>
          <para>Traversal functions are very useful for writing relatively
          short extraction functions.</para>
        </listitem>

        <listitem>
          <para>Rstores can be used to represent extracted facts.</para>
        </listitem>

        <listitem>
          <para>Fact extract can be integrated in The Meta-Environment and is
          activated via the <guimenuitem>extract</guimenuitem> button.</para>
        </listitem>

        <listitem>
          <para>The Meta-Environment supports various visualizations for
          rstores.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.todo">
    <title>To Do</title>

    <itemizedlist>
      <listitem>
        <para>Complete the compiler section.</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
