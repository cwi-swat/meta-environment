<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<article>
  <title>Understanding Term Rewriting (under construction)</title>

  <address><authorblurb>
      <para>Paul Klint</para>
    </authorblurb></address>

  <section>
    <title>Motivation</title>

    <para>Term rewriting is a surprisingly simple computational paradigm that
    is based on the repeated application of simplification rules. It is
    particularly suited for tasks like symbolic computation, program analysis
    and program transformation. Understanding term rewriting will help you to
    solve such tasks in a very effective manner.</para>
  </section>

  <section>
    <title>Introduction</title>

    <para>Consider the following, back-of-an-envelope, calculation:</para>

    <programlisting>(9 - 5)<superscript>2</superscript> * (7 + 4) =
4<superscript>2</superscript>  * (7 + 4) =
16 * (7 + 4) =
16 * 11 =
176</programlisting>

    <para>This is a perfect example of <emphasis>term rewriting</emphasis>:
    the initial expression (9 - 5)<superscript>2</superscript> * (7 + 4) is
    simplified in a number of steps using the rules of elementary arithmetic.
    The result is the number 176.</para>

    <para>Many forms of simplification or symbolic manipulation can be
    expressed in this way. Recall the simplification rule</para>

    <para><programlisting>(<emphasis>a</emphasis> + <emphasis>b</emphasis>)<superscript>2</superscript> = <emphasis>a</emphasis><superscript>2</superscript> + 2<emphasis>ab</emphasis> + <emphasis>b</emphasis><superscript>2</superscript></programlisting>from
    high school algebra or the rule to calculate the derivative of the sum of
    two functions <emphasis>u</emphasis> and <emphasis>v</emphasis>:</para>

    <programlisting>d(<emphasis>u</emphasis> + <emphasis>v</emphasis>)/d<emphasis>x</emphasis> = d<emphasis>u</emphasis>/d<emphasis>x</emphasis> + d<emphasis>v</emphasis>/d<emphasis>x</emphasis></programlisting>

    <para>In both cases, there is a complex <emphasis>left-hand
    side</emphasis> that can be simplified into the expression appearing at
    the <emphasis>right-hand side</emphasis>. These expressions are called
    <emphasis>term</emphasis>s and this explains the name
    <emphasis><emphasis>term rewriting</emphasis></emphasis>. The precise form
    of such a term may differ and is explained below. Observe that some of the
    items on the left-hand side re-appear at the right-hand side (e.g.,
    <emphasis>a</emphasis>, <emphasis>b</emphasis>, <emphasis>u</emphasis>,
    <emphasis>v</emphasis>); they are called <emphasis>variables</emphasis>
    and are used during the simplification.</para>

    <para>In order to apply such a simplifcation rule (or better:
    <emphasis>rewrite rule</emphasis>), several ingredients play a
    role:</para>

    <itemizedlist>
      <listitem>
        <para>an initial expression (a term) that is to be simplified.</para>
      </listitem>

      <listitem>
        <para>a subexpression where the rule might be applied (this is called
        the <emphasis>redex</emphasis>); there must be a
        <emphasis>match</emphasis>, between the redex and the left-hand side
        of the rule we want to apply; finding a match means that we can find
        values for the variables in the left-hand side of the rule that make
        the left-hand side and the redex identical.</para>
      </listitem>

      <listitem>
        <para>next, the redex in the initial expression is replaced by the
        right-hand side of the rule, after replacing the variables by the
        values found during the match.</para>
      </listitem>
    </itemizedlist>

    <para>Term rewriting is a simplification process that starts with one or
    more rewrite rules and an initial term. This initial term is gradually
    reduced to a term that cannot be further simplified: this is the outcome
    of the rewriting process and is called the <emphasis>normal
    form</emphasis>.</para>

    <para>In each step, a redex is searched for in (the possibly already
    simplified) initial term and it is replaced by the rewrite rule that can
    be applied.</para>
  </section>

  <section>
    <title>Terms</title>

    <para>Traditionally, terms are defined in a strict prefix format:</para>

    <itemizedlist>
      <listitem>
        <para>A single variable is a term, e.g. X, Y or Z.</para>
      </listitem>

      <listitem>
        <para>A function name applied to zero or more arguments is a term,
        e.g., add(X,Y).</para>
      </listitem>
    </itemizedlist>

    <para>Using this definition, complex hierarchical structures of arbitrary
    depth can be defined.</para>

    <para>Occasionally, we will relax this definition of terms a bit and use a
    more flexible notation. Instead of add(X,Y) we will, for instance, also
    write X + Y.</para>
  </section>

  <section>
    <title>Substitution</title>

    <para>A substitution is an important auxiliary notion that we need on our
    road towards understanding term rewriting. A substitution is an
    association between variables and terms. For instance,</para>

    <programlisting>{ X -&gt; 0, Y -&gt; succ(0) }</programlisting>

    <para>is a substitution that maps the variable X to the term 0 (a function
    without arguments), and the variable Y to the term
    <literal>succ(0)</literal>.</para>

    <para>Substitution can be used to create new terms from old ones. Using
    the above substitution and applying it to the term mul(succ(X), Y) will
    yield the new term mul(succ(0), succ(0)). The basic idea is that variables
    are replaced by the term they are mapped to by the substitution.</para>
  </section>

  <section>
    <title>Matching</title>

    <para>Matching has as goal to determine whether two terms
    T<subscript>1</subscript> and T<subscript>2</subscript> can be made equal.
    More precisely, whether a substitution exists that can make
    T<subscript>1</subscript> equal to T<subscript>2</subscript>. For
    instance, the two terms mul(succ(X), Y) and mul(succ(0), succ(0)) match
    since we can use the substitution { X -&gt; 0 Y -&gt; succ(0) } to make
    them identical. If no such substitution can be found, the two terms cannot
    be matched.</para>
  </section>

  <section>
    <title>The rewriting algorithm</title>

    <para>We can now assemble the ingredients we have described so far into a
    comprehensive description of the rewriting algorithm (Figure <olink
    targetptr="The rewriting algorithm">X</olink>).This algortihm still leaves
    some aspects unspecified:</para>

    <itemizedlist>
      <listitem>
        <para>In what way is the redex selected?</para>
      </listitem>

      <listitem>
        <para>In what order are the rules applied?</para>
      </listitem>
    </itemizedlist>

    <para>Various methods are possible for selecting the redex:</para>

    <itemizedlist>
      <listitem>
        <para>From the top (root) of the term to the bottom or from the leaves
        to the root.</para>
      </listitem>

      <listitem>
        <para>From left to right or from right to left.</para>
      </listitem>
    </itemizedlist>

    <para>We will mostly be using a leaves-to-root and left-to right order.
    This is called the <emphasis>left-most innermost reduction
    strategy</emphasis>.</para>

    <para>Also various methods exist for selecting the rules to be
    tried:</para>

    <itemizedlist>
      <listitem>
        <para>Textual order.</para>
      </listitem>

      <listitem>
        <para>Specificity order (rules with more precise lefthand sides are
        tried before rules with more general left-hand sides).</para>
      </listitem>

      <listitem>
        <para>No order.</para>
      </listitem>
    </itemizedlist>

    <para>We will be using no ordering of the rules.</para>

    <figure xreflabel="">
      <title>The rewriting algortihm</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="rewriting-algorithm.png" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>Examples</title>

    <para>Let´s consider two simple examples of term rewriting systems for
    natural numbers and booleans. More elaborate examples that fall outside
    the scope of this article are:</para>

    <itemizedlist>
      <listitem>
        <para>Typechecking of programs.</para>
      </listitem>

      <listitem>
        <para>Interpretation (= execution) of programs.</para>
      </listitem>

      <listitem>
        <para>Code generation.</para>
      </listitem>

      <listitem>
        <para>Fact extraction from source code for the benefit of quality
        assurance or defect detection.</para>
      </listitem>

      <listitem>
        <para>Software transformation for the benefit of translation or code
        improvement.</para>
      </listitem>
    </itemizedlist>

    <para>See the Further Reading section for pointers to such
    examples.</para>

    <section>
      <title>Numerals</title>

      <para>How can we specify natural numbers with 0, successor, addition and
      multiplication using term rewriting? A usual approach is as
      follows:</para>

      <programlisting>[add1] add(0, X) = X

[add2] add(succ(X), Y) = succ(add(X, Y))

[mul1] mul(0, X) = 0

[mul2] mul(succ(X), Y) = add(mul(X, Y), Y)</programlisting>

      <para>Here, 0 represents the constant zero, and add and mul the
      arithmetic operations addition and multiplication. Natural numbers are
      represented as 0, succ(0), succ(succ(0)), and so on. In other words,
      <emphasis>N</emphasis> applications of the successor to the constant 0,
      represent the number <emphasis>N</emphasis>.</para>

      <para>For mere mortals, the above rules could also be written in a more
      readable form:</para>

      <para><programlisting format="linespecific">[add1´] 0 + X = X

[add2´] succ(X) + Y = succ(X + Y)

[mul1´] 0 * X = 0

[mul2´] succ(X) * Y = mul(X * Y) + Y</programlisting>Now let´s follow the
      simplification of add(succ(succ(0)), succ(succ(0))) as shown in Figure
      Y. Each redex is shown as a yellow box with a thick border. An arrow
      connects the redex with its replacement that is surround by a rectangle
      with a thin border.</para>

      <para>The name of the rule that is applied in each step is shown on the
      right of each vertical arrow. As expected, the answer is
      succ(succ(succ(succ0)))) or, in other words, 2 + 2 equals 4.</para>

      <figure>
        <title>Rewriting an arithmetic term</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" dir="lro" fileref="./two-plus-two.png"
                       scale="100" scalefit="" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Booleans</title>

      <para>How can we define Boolean expressions with constants true and
      false and the operations and, or and not? Consider the following
      definition that structly follows the truth table definitions of Boolean
      operators:</para>

      <programlisting>[or1] or(true, true) = true
[or2] or(true, false) = true
[or3] or(false, true) = true
[or4] or(false, false) = false

[and1] and(true, true) = true
[and2] and(true, false) = false
[and3] and(false, true) = false
[and4] and(false, false) = false

[not1] not(true) = false
[not2] not(false) = true</programlisting>

      <para>Consider the simplification of the Boolean expression
      not(or(false, and(true,not(false)))) as shown in Figure Z.</para>

      <figure>
        <title>Rewriting as Boolean term</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="not-or.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Extensions of term rewriting</title>

    <para>Term rewriting has been extended in various ways to make it even
    more practical. These extensions include:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>User-defined syntax</emphasis>. Instead of writing
        and(true, false) we would rather like to write true &amp; false. We
        want to relax the strict prefix format of functions and use arbitrary
        notation for them.</para>
      </listitem>

      <listitem>
        <para><emphasis>Conditional rules</emphasis>. So far we have only seen
        rewrite rules that are applied when they <emphasis>can</emphasis> be
        applied. To conditional rewrite rules, one or more conditions are
        attached that are first evaluated in order to determine whether the
        rule should be applied at all.</para>
      </listitem>

      <listitem>
        <para><emphasis>Default rules</emphasis>. So far we have used no
        ordering for the rewrite rules. Default rules are only applied when no
        other rules can be applied an capture the idea of a
        <emphasis>catch-all rule</emphasis> that covers the cases that are not
        addressed by other, more specific, rules.</para>
      </listitem>

      <listitem>
        <para><emphasis>Lists and list matching</emphasis>. Terms can be
        extended with a notion of lists. This is particularly handy when
        representing repeated items in a structure such as a list of
        identifiers in a declaration, or a list of statements in a procedure
        body. The matching between two terms has to be extended to cover the
        case of matching lists of terms rather than a single term. In this
        way, one can, for instance, define patterns that match a list of
        statements that contains a statement of a particular form.</para>
      </listitem>

      <listitem>
        <para><emphasis>Traversal functions</emphasis>. In many problem
        domains it may occur that a large structure has to be searched while
        only a few elements are relevant for the operation at hand. Consider
        counting goto statements in C or Cobol programs: we are only
        interested to do something when we encounter a goto statement and we
        just want to travel over the other statements kinds. Traversal
        functions automate this kind of behaviour and can hugely reduce the
        number of rewrite rules that are needed in industrial size
        applications.</para>
      </listitem>
    </itemizedlist>

    <para>All these -- and more -- extensions our provided by the ASF+SDF
    formalism that is supported by The Meta-Environment.</para>
  </section>

  <section>
    <title>Further reading</title>

    <itemizedlist>
      <listitem>
        <para>Several articles on this website give detailed examples of term
        rewriting applications.</para>
      </listitem>

      <listitem>
        <para>The book <emphasis>Term Rewriting and All That</emphasis> by
        Franz Baader and Tobias Nipkow (Cambridge University Press, 1998)
        gives an introduction to the theory of term rewriting.</para>
      </listitem>

      <listitem>
        <para>The book <emphasis>Term Rewriting Systems</emphasis> by the
        Terese collective (Cambridge Tracts in Theoretical Computer Science,
        2003) gives a comprehensive overview of research in this area.</para>
      </listitem>

      <listitem>
        <para>The Meta-Environment (<uri>www.meta-environment.org</uri>) is
        the tools suite par excellence to explore applications of term
        rewriting.</para>
      </listitem>
    </itemizedlist>
  </section>
</article>