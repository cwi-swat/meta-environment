<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<article>
  <title>Understanding Term Rewriting (under construction)</title>

  <address><authorblurb>
      <para>Paul Klint</para>
    </authorblurb></address>

  <section>
    <title>Motivation and introduction</title>

    <para>Consider the following, back-of-an-envelope, calculation:</para>

    <programlisting>(9 - 5)<superscript>2</superscript> * (7 + 4) =

4<superscript>2</superscript>  * (7 + 4) =

16 * (7 + 4) =

16 * 11 =

176</programlisting>

    <para>This is a perfect example of <emphasis>term rewriting</emphasis>:
    the initial expression (9 - 5)<superscript>2</superscript> * (7 + 4) is
    simplified in a number of steps using the rules of elementary arithmetic.
    The result is the number 176.</para>

    <para>Many forms of simplification or symbolic manipulation can be
    expressed in this way. Recall the simplification rule</para>

    <para><programlisting>(<emphasis>a</emphasis> + <emphasis>b</emphasis>)<superscript>2</superscript> = <emphasis>a</emphasis><superscript>2</superscript> + 2<emphasis>ab</emphasis> + <emphasis>b</emphasis><superscript>2</superscript></programlisting>from
    high school algebra or the rule to calculate the derivative of the sum of
    two functions <emphasis>u</emphasis> and <emphasis>v</emphasis>:</para>

    <programlisting>d(<emphasis>u</emphasis> + <emphasis>v</emphasis>)/d<emphasis>x</emphasis> = d<emphasis>u</emphasis>/d<emphasis>x</emphasis> + d<emphasis>v</emphasis>/d<emphasis>x</emphasis></programlisting>

    <para>In both cases, there is a complex <emphasis>left-hand
    side</emphasis> that can be simplified into the expression appearing at
    the <emphasis>right-hand side</emphasis>. These expressions are called
    <emphasis>term</emphasis>s and this explains the name
    <emphasis><emphasis>term rewriting</emphasis></emphasis>. The precise form
    of such a term may differ and is explained below. Observe that some of the
    items on the left-hand side re-appear at the right-hand side (e.g.,
    <emphasis>a</emphasis>, <emphasis>b</emphasis>, <emphasis>u</emphasis>,
    <emphasis>v</emphasis>); they are called <emphasis>variables</emphasis>
    and are used during the simplification.</para>

    <para>In order to apply such a simplifcation rule (or better:
    <emphasis>rewrite rule</emphasis>), several ingredients play a
    role:</para>

    <itemizedlist>
      <listitem>
        <para>an initial expression (a term) that is to be simplified.</para>
      </listitem>

      <listitem>
        <para>a subexpression where the rule might be applied (this is called
        the <emphasis>redex</emphasis>); there must be a
        <emphasis>match</emphasis>, between the redex and the left-hand side
        of the rule we want to apply; finding a match means that we can find
        values for the variables in the left-hand side of the rule that make
        the left-hand side and the redex identical.</para>
      </listitem>

      <listitem>
        <para>next, the redex in the initial expression is replaced by the
        right-hand side of the rule, after replacing the variables by the
        values found during the match.</para>
      </listitem>
    </itemizedlist>

    <para>Term rewriting is a simplification process that starts with one or
    more rewrite rules and an initial term. This initial term is gradually
    reduced to a term that cannot be further simplified: this is the outcome
    of the rewriting process and is called the <emphasis>normal
    form</emphasis>.</para>

    <para>In each step, a redex is searched for in (the possibly already
    simplified) initial term and it is replaced by the rewrite rule that can
    be applied.</para>
  </section>

  <section>
    <title>Terms</title>

    <para>Traditionally, terms are defined in a strict prefix format:</para>

    <itemizedlist>
      <listitem>
        <para>A single variable is a term, e.g. X, Y or Z.</para>
      </listitem>

      <listitem>
        <para>A function name applied to zero or more arguments is a term,
        e.g., add(X,Y).</para>
      </listitem>
    </itemizedlist>

    <para>Using this definition, complex hierarchical structures of arbitrary
    depth can be defined.</para>

    <para>Later, we will relax this definition of terms a bit and use a more
    flexible notation. Instead of add(X,Y) we will, for instance, also write
    (X + Y).</para>
  </section>

  <section>
    <title>Substitution</title>

    <para>A substitution is an important auxiliary notion that we need on our
    road towards understanding term rewriting. A substitution is an
    association between variables and terms. For instance,</para>

    <programlisting>{ X -&gt; 0, Y -&gt; succ(0) }</programlisting>

    <para>is a substitution that maps the variable X to the term 0 (a function
    without arguments), and the variable Y to the term
    <literal>succ(0)</literal>.</para>

    <para>Substitution can be used to create new terms from old ones. Using
    the above substitution and applying it to the term mul(succ(X), Y) will
    yield the new term mul(succ(0), succ(0)). The basic idea is that variables
    are replaced by the term they are mapped to by the substitution.</para>
  </section>

  <section>
    <title>Matching</title>

    <para>Matching has as goal to determine whether two terms
    T<subscript>1</subscript> and T<subscript>2</subscript> can be made equal.
    More precisely, whether a substitution exists that can make
    T<subscript>1</subscript> equal to T<subscript>2</subscript>. For
    instance, the two terms mul(succ(X), Y) and mul(succ(0), succ(0)) match
    since we can use the substitution { X -&gt; 0 Y -&gt; succ(0) } to make
    them identical. If no such substitution can be found, the two terms cannot
    be matched.</para>
  </section>

  <section>
    <title>The rewriting algorithm</title>

    <para>We can now assemble the ingredients we have described so far into a
    comprehensive description of the rewriting algorithm (Figure <olink
    targetptr="The rewriting algorithm">X</olink>).This algortihm still leaves
    some aspects unspecified:</para>

    <itemizedlist>
      <listitem>
        <para>In what way is the redex selected?</para>
      </listitem>

      <listitem>
        <para>In what order are the rules applied?</para>
      </listitem>
    </itemizedlist>

    <para>Various methods are possible for selecting the redex:</para>

    <itemizedlist>
      <listitem>
        <para>From the top (root) of the term to the bottom or from the leaves
        to the root.</para>
      </listitem>

      <listitem>
        <para>From left to right or from right to left.</para>
      </listitem>
    </itemizedlist>

    <para>We will mostly be using a leaves-to-root and left-to right order.
    This is called the <emphasis>left-most innermost reduction
    strategy</emphasis>.</para>

    <para>Also various methods exist for selecting the rules to be
    tried:</para>

    <itemizedlist>
      <listitem>
        <para>Textual order.</para>
      </listitem>

      <listitem>
        <para>Specificity order (rules with more precise lefthand sides are
        tried before rules with more general left-hand sides).</para>
      </listitem>

      <listitem>
        <para>No order.</para>
      </listitem>
    </itemizedlist>

    <para>We will be using no ordering of the rules.</para>

    <figure xreflabel="">
      <title>The rewriting algortihm</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="rewriting-algorithm.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>
  </section>

  <section>
    <title>Examples</title>

    <para>Let´s consider two simple examples of term rewriting systems for
    natural numbers and booleans.</para>

    <section>
      <title>Numerals</title>

      <para>How can we specify natural numbers with 0, successor, addition and
      multiplication using term rewriting? A usual approach is as
      follows:</para>

      <programlisting>[add1] add(0, X) = X

[add2] add(succ(X), Y) = succ(add(X, Y))

[mul1] mul(0, X) = 0

[mul2] mul(succ(X), Y) = add(mul(X, Y), Y)</programlisting>

      <para>Here, 0 represents the constant zero, and add and mul the
      arithmetic operations addition and multiplication. Natural numbers are
      represented as 0, succ(0), succ(succ(0)), and so on. In other words,
      <emphasis>N</emphasis> applications of the successor to the constant 0,
      represent the number <emphasis>N</emphasis>.</para>

      <para>For mere mortals, the above rules could also be written in a more
      readable form:</para>

      <para><programlisting format="linespecific">[add1´] 0 + X = X

[add2´] succ(X) + Y = succ(X + Y)

[mul1´] 0 * X = 0

[mul2´] succ(X) * Y = mul(X * Y) + Y</programlisting>Now let´s follow the
      simplification of add(succ(succ(0)), succ(succ(0))) as shown in Figure
      Y. Each redex is shown as a yellow box with a thick border.</para>

      <para>The name of the rule that is applied in each step is shown on the
      right of each vertical arrow.</para>

      <figure>
        <title>Rewriting an arithmetic term</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" dir="lro" fileref="./two-plus-two.png"
                       scale="100" scalefit="" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Booleans</title>

      <para></para>
    </section>
  </section>

  <section>
    <title>Further reading</title>

    <para></para>
  </section>
</article>