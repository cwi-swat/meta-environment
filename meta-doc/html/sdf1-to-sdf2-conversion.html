<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Conversion</title>
  </head>

  <body  BGCOLOR="#FFFFDE">

    <h1>Sdf1 to Sdf2 Conversion</h1>

<p>The new Asf+Sdf Meta-Environment is based on a new version of <em>Sdf</em>
(syntax definition formalism).
If you have an Asf+Sdf language definition developed with the old 
Asf+Sdf Meta-Environment you have to perform some (simple) 
modifications.
For details concerning Sdf2 we refer to the PhD-thesis of Eelco Visser.

<p>The main differences between Sdf1 and Sdf2 are in the range of
lexical disambiguation.

    <h2>Lexical and Syntactic Modifications</h2>

       <ul>
          <li>Each module M should start with:
<pre>
module M
...
</pre>
 
          <li>All characters not being a (uppercase) letter or a digit have
              to be escaped.
          <p>Sdf1: [!@#$%^] -> StrangeChar
          <p>Sdf2: [\!\@\#\$\%\^] -> StrangeChar

          <p>This has also effect on the way the layout characters are
             defined, the space character must be escaped.
          <p>Sdf1: [ \n\t\r] -> LAYOUT
          <p>Sdf2: [\ \n\t\r] -> LAYOUT

          <li>The octal coding of characters in a character class
              is changed into a decimal coding.
          <p>Sdf1: [\012] -> NL
          <p>Sdf2: [\010] -> NL

          <li>The syntax of priority section in Sdf1 is changed:
              <ul>
                 <li>The keyword "context-free" is added to "priorities".
                 <li>Only the ascending priority changes are supported.
                 <li>The abbreviations are no longer supported.
              </ul>
              <p>For example the priority definition section in Sdf1:
<pre>
priorities 
  "|" < "&"
</pre>
              becomes
<pre>
context-free priorities
  Bool "&" Bool -> Bool >
  Bool "|" Bool -> Bool 
</pre>
<li>The variable names in the variable section must be quoted.
<pre>
variables 
  Bool [0-9']* -> BOOL
</pre>
    becomes

<pre>
variables 
  "Bool" [0-9\']* -> BOOL
</pre>

       </ul>

    <h2>Lexical Disambiguation</h2>
Sdf2 does not support automatic lexical disambiguation. If you do not take
extra precautions this may lead to many ambiguities and performance penalties
during parsing. There are a number of simple rules to which one has to stick
when converting to and/or writing an Sdf2 definition.
The lexical disambiguation rules in Sdf1 are:
<ul>
<li>Prefer longest match per sort.
<li>Prefer non layout.
<li>Prefer literals.
<li>Prefer variables. 
</ul>
For more details on these lexical disambiguation rules 
we refer to the Sdf reference manual.

We will discuss how the most crucial lexical disambiguation rules
can be defined in Sdf2, but first we will give an example of
how the layout defined in Sdf2.

<h3>Example Definition of Layout</h3>

<pre>
module Layout

exports
  lexical syntax
    [\ \t\n]         -> LAYOUT
    "%%" ~[\n]* "\n" -> LAYOUT
    "%" ~[\%\n]+ "%" -> LAYOUT
  context-free restrictions
    LAYOUT? -/- [\ \t\n]
</pre>
<p>Besides the extra back-slash before the space symbol in the character class
the main difference is the extra section "context-free restrictions".
The purpose of this extra section is to force the parser to go on with
recognizing layout as long as possible. The question mark behind "LAYOUT"
is a new feature of Sdf2 and represents optional LAYOUT. 
Even if there is an empty recognizing non-terminal between two optional
layouts.

<p>Note that the 
use of these new features may prove to be problematic in combination
with complilation and interpretation.

<h3>Definition of "Prefer Longest Match per Sort"</h3>

The prefer longest match rules forces the scanner to go on with
recognizing a lexical token as long as possible. 
Given the definition of identifiers as
<pre>
exports
  sorts Id
  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]* -> Id
</pre>
The lexical token "Program" can be recognized in several ways, but by
the prefer longest match rule only one interpretation is possible.

<p>This longest match rule is enforced in Sdf2 as follows:
<pre>
exports
  sorts Id
  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]* -> Id

  lexical restrictions
    <Id -CF> -/- [a-zA-Z0-9\_]
</pre>
The keyword "lexical" for "restrictions" is optional, the definition can
also be written down as follows:
<pre>
exports
  sorts Id
  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]* -> Id

  context-free restrictions
    Id -/- [a-zA-Z0-9\_]
</pre>
When discussing the prefer keywords disambiguation rule we will come
back to the prefer longest match rule.

<h3>Definition of "Prefer Keywords or Literals"</h3>

The prefer keyword or literal rules forces the scanner to recognize 
strings which can be recognized both as keywords or as lexical
tokens like ``Identifiers'' as keywords.

<p>To enforce this in Sdf2 we have to use the ``reject''-mechanism.
Suppose we have the following context-free grammar rule
<pre>
exports
  context-free syntax
    "if" Bool "then" Series "else" Series "fi" -> Statement
</pre>
Than there is an overlap between these keywords and the ``Id'' definition
above. This problem is solved as follows in Sdf2:
<pre>
exports
  context-free syntax
    "if" Bool "then" Series "else" Series "fi" -> Statement
  context-free syntax
    "if"   -> Id {reject}
    "then" -> Id {reject}
    "else" -> Id {reject}
    "fi"   -> Id {reject}
</pre>
In order to enforce that a list of characters like ``ifIdentifier'' is
recognized as two separate Ids it may be wise to add also the following
restrictions section:
<pre>
   restrictions
     "if" "then" "else" "fi" -/- [a-zA-Z0-9\_]
</pre>
This forces the parser not to stop after the "if" but to go on.

    <hr>
    <address><a href="mailto:Mark.van.den.Brand@cwi.nl">Mark van den Brand</a></address>
<!-- Created: Mon Jun 21 11:28:10 MET DST 1999 -->
<!-- hhmts start -->
Last modified: Wed Aug  4 11:48:17 MET DST 1999
<!-- hhmts end -->
  </body>
</html>
