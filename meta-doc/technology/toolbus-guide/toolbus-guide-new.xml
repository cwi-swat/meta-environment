<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Guide to ToolBus Programming</title>

    <authorgroup>
      <author>
        <personname><firstname>Hayco</firstname><surname>de
        Jong</surname></personname>
      </author>

      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Arnold</firstname><surname>Lankamp</surname></personname>
      </author>

      <author>
        <personname><firstname>Pieter</firstname><surname>Olivier</surname></personname>
      </author>
    </authorgroup>

    <pubdate>Not yet released</pubdate>
  </info>

  <warning>
    <para>This document is in state of creation and will further evolve. It
    provides a description of the classic C-based ToolBus as well as of the
    Java-based ToolBusNG. Eventually, it will exclusively focus on ToolBusNG.
    See <xref linkend="section.toolbus-to-do" />.</para>
  </warning>

  <section xml:id="section.toolbus-introduction">
    <title>Introduction</title>

    <section xml:id="section.toolbus-background">
      <title>Background and Motivation</title>

      <para>Building large, heterogeneous, distributed software systems poses
      serious problems for the software engineer. Systems grow
      <emphasis>larger</emphasis> because the complexity of the tasks we want
      to automate increases. They become <emphasis>heterogeneous</emphasis>
      because large systems may be constructed by re-using existing software
      as components. It is more than likely that these components have been
      developed using different implementation languages and run on different
      hardware platforms. Systems become <emphasis>distributed</emphasis>
      because they have to operate in the context of local area
      networks.</para>

      <para>Three aspects of heterogeneous, distributed, systems should be
      considered: <emphasis>coordination</emphasis>,
      <emphasis>representation</emphasis> and
      <emphasis>computation</emphasis>.</para>

      <formalpara>
        <title>Coordination</title>

        <para>Coordination is the way in which program and system parts
        interact with each other using, ordinary procedure calls, remote
        procedure calls (RPC), remote method invocation (RMI), and
        others.</para>
      </formalpara>

      <formalpara>
        <title>Representation</title>

        <para>Representation is the language and machine neutral format for
        data being exchanged between components.</para>
      </formalpara>

      <formalpara>
        <title>Computation</title>

        <para>Computation is done by specialized program code that carries out
        a specific task, e.g., providing a user-interface, providing database
        access, and the like.</para>
      </formalpara>

      <para>Our key assumption is as follows:<important>
          <para>A rigorous separation of coordination from computation is the
          key to flexible and reusable systems.</para>
        </important></para>

      <para>A system organization that respects this separation is shown
      in</para>

      <figure>
        <title>Separating coordination from computation</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="coordination.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>We propose to get control over the possible interactions between
      software components (<emphasis>tools</emphasis>) by forbidding direct
      inter-tool communication. Instead, all interactions are controlled by a
      process-oriented <emphasis>script</emphasis> that formalizes all the
      desired interactions among tools. This leads to a component
      interconnection architecture resembling a hardware communication bus,
      and therefore we call it a ``ToolBus''.</para>
    </section>

    <section xml:id="section.toolbus-requirements">
      <title>ToolBus requirements</title>

      <para>Given the motivation for the ToolBus we can briefly summarize the
      requirements that the ToolBus should satisfy:</para>

      <itemizedlist>
        <listitem>
          <para>Provide a flexible interconnection architecture for software
          components that are not only written in different languages and
          executing on different hardware and software platforms, but are also
          running in a distributed fashion on a system of networked computers
          and devices. <emphasis role="bold">Rationale</emphasis>: it is more
          and more common that applications are built using existing
          commercial or open source components. This reduces implementation
          effort but increases the need for usable interconnection
          technology.</para>
        </listitem>

        <listitem>
          <para>Provide good control over the communication between
          components. <emphasis role="bold">Rationale</emphasis>: component
          integration requires both control over the communication between
          components and over the data that are being exchanged (see next
          requirement).</para>
        </listitem>

        <listitem>
          <para>Provide a uniform data exchange mechanism between
          heterogeneous components. <emphasis
          role="bold">Rationale</emphasis>: a common understanding about data
          formats is needed in order to exchange data between
          components.</para>
        </listitem>

        <listitem>
          <para>The description of communication should be based on existing
          concurrency theory and provide the option for formal verification of
          the cooperation between software components. <emphasis
          role="bold">Rationale</emphasis>: when components are integrated
          that run on different machines or on multi-core machines, it is
          unavoidable that concurrency is taken into account and to use
          existing theory to describe it. The long term perspective of
          checking formal aspects of these cooperation is appealing for
          certain, safety-critical, applications.</para>
        </listitem>

        <listitem>
          <para>Provide relatively simple application descriptions that can be
          understood by most programmers. <emphasis
          role="bold">Rationale</emphasis>: we don't want to frighten
          programmers by using formal notations.</para>
        </listitem>

        <listitem>
          <para>Provide multi-lingual support, at least C, Java, ASF+SDF,
          Tcl/Tk, and possibly Perl, Python and Ruby should be supported.
          Rationale: various tools of interest are currently implemented in
          the first four languages, and the last three languages are
          interesting for future developments.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.toolbus-architecture">
      <title>The ToolBus architecture</title>

      <para>The global architecture of the ToolBus is shown in <xref
      linkend="figure.toolbus-organization" />. The ToolBus serves the purpose
      of defining the cooperation of a variable number of
      <emphasis>tools</emphasis> <replaceable>T</replaceable><subscript>i
      </subscript>(<replaceable>i</replaceable> = 1, ...,
      <replaceable>m</replaceable>) that are to be combined into a complete
      system. The internal behaviour or implementation of each tool is
      irrelevant: they may be implemented in different programming languages,
      be generated from specifications, etc. Tools may, or may not, maintain
      their own internal state. Here we concentrate on the external behaviour
      of each tool. In general an <emphasis>adapter</emphasis> will be needed
      for each tool to adapt it to the common data representation and message
      protocols imposed by the ToolBus.</para>

      <figure xml:id="figure.toolbus-organization">
        <title>Global organization of the ToolBus</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="architecture.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The ToolBus itself consists of a variable number of processes
      <replaceable>P</replaceable><subscript>i</subscript>
      (<replaceable>i</replaceable> = 1, ...,
      <replaceable>n</replaceable>)<footnote>
          <para>By ``processes'' we mean here computational activities
          <emphasis>inside</emphasis> the ToolBus as opposed to, for instance,
          processes at the operating system level. When confusing might arise,
          we will call the former ``ToolBus processes'' and the latter
          ``operating system level tasks''.</para>
        </footnote>The parallel composition of the processes
      <replaceable>P</replaceable><subscript>i</subscript> represents the
      intended behaviour of the whole system. Tools are external,
      computational activities, most likely corresponding with operating
      system level tasks. They come into existence either by an execution
      command issued by the ToolBus or their execution is initiated
      externally, in which case an explicit connect command has to be
      performed by the ToolBus. Although a one-to-one correspondence between
      tools and processes seems simple and desirable, we do not enforce this
      and permit tools that are being controlled by more than one process as
      well as clusters of tools being controlled by a single process.</para>

      <formalpara>
        <title>Communication inside the ToolBus</title>

        <para>Inside the ToolBus, there are two communication mechanisms
        available. First, a process can send a <emphasis>message</emphasis>
        (using <literal>snd-msg</literal>) which should be received,
        synchronously, by one other process (using
        <literal>rec-msg</literal>). Messages are intended to request a
        service from another process. When the receiving process has completed
        the desired service it may inform the sender, synchronously, by means
        of another message (using <literal>snd-msg</literal>). The original
        sender can receive the reply using <literal>rec-msg</literal>. By
        convention, part of the original message is contained in the reply
        (but this is not enforced).</para>
      </formalpara>

      <para>Second, a process can send a <emphasis>note</emphasis> (using
      <literal>snd-note</literal>) which is broadcasted to other, interested,
      processes. The sending process does not expect an answer while the
      receiving processes read notes asynchronously (using
      <literal>rec-note</literal>). Notes are intended to notify others of
      state changes in the sending process. Sending notes amounts to
      <emphasis>asynchronous selective broadcasting</emphasis>. Processes will
      only receive notes to which they have
      <emphasis>subscribed</emphasis>.</para>

      <para><figure xml:id="figure.tool-communication">
          <title>Communication between ToolBus and tools</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="tool-protocol.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <formalpara>
        <title>Communication between ToolBus and tools</title>

        <para>The communication between ToolBus and tools is based on
        handshaking communication between a ToolBus process and a tool. A
        process may send messages in several formats to a tool
        (<literal>snd-eval</literal>, <literal>snd-do</literal>, and
        <literal>snd-ack-event</literal>) while a tool may send the messages
        <literal>snd-event</literal> and <literal>snd-value</literal> to a
        ToolBus process. There is no direct communication possible between
        tools. These communication patterns are shown in <xref
        linkend="figure.tool-communication" />.</para>
      </formalpara>

      <para>The execution and termination of the tools attached to the ToolBus
      can be explicitly controlled. It is also possible to connect or
      disconnect tools that have been executing independently of the
      ToolBus.</para>

      <formalpara>
        <title>Knowledge separation</title>

        <para>Equipped with the mechanisms provided by the ToolBus, careful
        control over application knowledge can be achieved as shown in <xref
        linkend="figure.toolbus-application" /> where an application is
        depicted consisting of a user-interface (UI) and a database (DB). In a
        more conventional approach, elements of the user-interface, say a
        button, would be directly connected with functions in the database
        component and a strong coupling between the two components would be
        the result. Using the ToolBus, the two components can be completely
        oblivious of each other. It is only in the ToolBus script that they
        are configured to work together. The extra level of indirection
        introduced by the ToolBus thus leads to extra flexibility and
        decoupling.</para>
      </formalpara>

      <para><figure xml:id="figure.toolbus-application">
          <title>Knowledge separation in ToolBus-based application</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="application.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>

    <section>
      <title>How to go from here?</title>

      <para>After this brief motivation and explanation of the ToolBus
      architecture it is time to delve into more details. In the remainder of
      this chapter, we will have a look at the following topics:</para>

      <itemizedlist>
        <listitem>
          <para>ToolBus scripts (or Tscripts, for short).</para>
        </listitem>

        <listitem>
          <para>How to write ToolBus tools.</para>
        </listitem>

        <listitem>
          <para>A brief peek at the ToolBus implementation.</para>
        </listitem>

        <listitem>
          <para>Historical notes</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.tscripts">
    <title>Tscripts</title>

    <para>Tscripts describe how the tools in an application cooperate. They
    allow the definition of a collection of concurrent processes that can
    communicate with each other and with the tools in the application.</para>

    <section xml:id="section.terms">
      <title>Terms</title>

      <para>Tscripts make heavy use of <emphasis>terms</emphasis>, simple
      prefix expressions that are used to exchange structured data between
      processes and tools. Terms are recursively defined as follows:</para>

      <itemizedlist>
        <listitem>
          <para>A Boolean constant, integer constant, real constant, or string
          constant is a term, e.g., <literal>true</literal>,
          <literal>37</literal>, <literal>314e-12</literal>, or
          <literal>"rose"</literal>.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>value occurrence</emphasis> of a variable is a
          term, e.g., <literal>X</literal>, <literal>InitialAmount</literal>,
          or <literal>Highest-Bid</literal>.</para>

          <important>
            <para>Variables always start with a capital letter. A value
            occurrence serves the purpose of using the current value of a
            variable.</para>
          </important>
        </listitem>

        <listitem>
          <para>A <emphasis>result occurrence</emphasis> of a variable is a
          term, e.g., <literal>X?</literal>, <literal>InitialAmount?</literal>
          or <literal>Highest-Bid?</literal>.</para>

          <important>
            <para>A result occurrence of a variable plays a role when this
            term is <emphasis>matched</emphasis> with another term. In the
            case that the match succeeds, the corresponding part of the other
            term is assigned to the result variable.</para>
          </important>
        </listitem>

        <listitem>
          <para>A single <emphasis>identifier</emphasis> is a term, e.g.,
          <literal>f</literal>, <literal>pair</literal>, or
          <literal>zero</literal>.</para>

          <important>
            <para>Identifier always start with a lowercase letter.</para>
          </important>
        </listitem>

        <listitem>
          <para>A <emphasis>function application</emphasis> is a term, e.g.,
          <literal>pair("rose", address("STREE", 12345)</literal>.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>list</emphasis> is a term, e.g., <literal>[a, b,
          c]</literal> or <literal>[a, 1.25, "lost"]</literal>.</para>
        </listitem>

        <listitem>
          <para>A placeholder is a term, e.g., <literal>&lt;int&gt;</literal>
          or <literal>add(&lt;int&gt;,&lt;int&gt;)</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.matching">
      <title>Matching</title>

      <para>Term matching is used for several purposes in the ToolBus:</para>

      <itemizedlist>
        <listitem>
          <para>To determine which actions can communicate with each other.
          For instance, a <literal>snd-msg</literal> and a
          <literal>rec-msg</literal> can only communicate if their arguments
          match.</para>
        </listitem>

        <listitem>
          <para>To transfer information between sender and receiver.</para>
        </listitem>

        <listitem>
          <para>To do case analysis, for instance, when receiving events from
          a tool.</para>
        </listitem>
      </itemizedlist>

      <para>Intuitively, the matching between two terms works as
      follows:</para>

      <itemizedlist>
        <listitem>
          <para>Two terms match if they are structurally identical.</para>
        </listitem>

        <listitem>
          <para>For a value occurrence of a variable: use its current
          value.</para>
        </listitem>

        <listitem>
          <para>For a result occurrence of a variable: assign the matched
          subterm of the other term to the variable (but make this only
          permanent if the overall match succeeds).</para>
        </listitem>
      </itemizedlist>

      <para>This illustrated in <xref linkend="figure.match-example" />.
      Before the match, two contexts are given. Each context associates some
      variables with a value. For instance, Context 1 associates the value
      <literal>3</literal> with variable <literal>X</literal>. For each
      context a term is given and the challenge is to match these two terms
      and to observe the effects on the two contexts. The matching of the two
      terms can be understood as follows:</para>

      <itemizedlist>
        <listitem>
          <para>The top level function names are identical (both
          <literal>f</literal>) and both have the same number of arguments.
          The left term and the right term match if their arguments
          match.</para>
        </listitem>

        <listitem>
          <para>The first argument in the left term is <literal>X</literal>
          and <literal>3</literal> in the right term. Since,
          <literal>X</literal> has value <literal>3</literal> in Context 1,
          they match.</para>
        </listitem>

        <listitem>
          <para>The second argument in the left term is <literal>4</literal>
          and <literal>Z?</literal> in the right term. By assigning
          <literal>4</literal> to <literal>Z</literal> in Context 2 we achieve
          a match.</para>
        </listitem>

        <listitem>
          <para>The third argument in the left term is <literal>Y?</literal>
          and <literal>5</literal> in the right term. Here we achieve a match
          by assigning <literal>5</literal> to <literal>Y</literal> in Context
          1.</para>
        </listitem>

        <listitem>
          <para>The fourth and last argument of both terms is
          <literal>6</literal> and thus matches.</para>
        </listitem>
      </itemizedlist>

      <para>The net result is that both terms match and that Context 1 and
      Context 2 are modified as shown at the bottom of the figure.</para>

      <para><figure xml:id="figure.match-example">
          <title>Example of term matching</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="match-example.png" scale="40"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>

    <section xml:id="section.types">
      <title>Types</title>

      <para>The ToolBus uses a type system that is a compromise between the
      safety of static checking and the flexibility of dynamic typing. Another
      objective of the type system is to provide sufficient information to
      enable the automatic generation of adapter code for tools. Type are
      defined as follows:</para>

      <itemizedlist>
        <listitem>
          <para><literal>bool</literal>, <literal>int</literal>,
          <literal>real</literal> and <literal>str</literal> are the types of
          the elementary terms.</para>
        </listitem>

        <listitem>
          <para><literal>list</literal> is the type of arbitrary lists.</para>
        </listitem>

        <listitem>
          <para><literal>list(<replaceable>Type</replaceable>)</literal> is
          the type of lists with elements of type
          <replaceable>Type</replaceable>. For instance,
          <literal>list(int)</literal> is the type of lists of
          integers.</para>
        </listitem>

        <listitem>
          <para><replaceable>Id</replaceable> is the type of all terms with
          function symbol <replaceable>Id</replaceable> (this allows the
          declaration of partial types). The type <literal>f</literal>, thus
          corresponds to the terms <literal>f</literal>,
          <literal>f(1)</literal>, <literal>f("abc", 3)</literal> and the
          like.</para>
        </listitem>

        <listitem>
          <para><literal>Id(<replaceable>Type</replaceable><subscript>1</subscript>,
          ...,
          <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript>)</literal>
          is the type of terms with function symbol
          <replaceable>Id</replaceable> and the given types
          <replaceable>Type</replaceable><subscript>1</subscript>, ...,
          <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript>a
          s argument types. For instance, <literal>f(int,str)</literal>
          accepts <literal>f(3,"abc")</literal> but not
          <literal>f(3)</literal>.</para>
        </listitem>

        <listitem>
          <para>[<replaceable>Type</replaceable><subscript>1</subscript>, ...,
          <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript>]
          is the type of a list of elements with the given types
          <replaceable>Type</replaceable><subscript>1</subscript>, ...,
          <replaceable>Type<subscript>n</subscript>.</replaceable> For
          instance, <literal>[int, str]</literal> accepts <literal>[1,
          "abc"]</literal>, but not <literal>[1,2,3]</literal>.</para>
        </listitem>

        <listitem>
          <para><literal>term</literal> is the type of an arbitrary term. And
          is used as escape from the more precise typing by the preceding
          types.</para>
        </listitem>
      </itemizedlist>

      <para>Types are used in the following ways:</para>

      <itemizedlist>
        <listitem>
          <para>All variables have a type.</para>
        </listitem>

        <listitem>
          <para>Types are statically checked whenever possible. Only in the
          case of type <literal>term</literal>, dynamic checks are
          needed.</para>
        </listitem>

        <listitem>
          <para>Types play a role during matching: a match can also fail if
          the types of corresponding subterms are unequal. For instance, given
          <literal>I</literal> as <literal>int</literal> variable,
          <literal>S</literal> as <literal>str</literal> variable and
          <literal>T</literal> as <literal>term</literal> variable,</para>

          <itemizedlist>
            <listitem>
              <para><literal>f(13)</literal> and <literal>f(I?)</literal> will
              match.</para>
            </listitem>

            <listitem>
              <para><literal>f(13)</literal> and <literal>f(S?)</literal> will
              fail.</para>
            </listitem>

            <listitem>
              <para><literal>f(13)</literal> and <literal>f(T?)</literal> will
              succeed.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.tscript-in-detail">
      <title>Tscripts in detail</title>

      <section xml:id="section.overall-structure-tscripts">
        <title>Overall structure</title>

        <para>A Tscript can define the following ingredients:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>process definition</emphasis> consisting of a
            process name, optional parameters and a process expression that
            describes the behaviour of this process.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>tool definition</emphasis> consisting of a tool
            name and some operational details, such as the command to execute
            when the tool is started.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>ToolBus configuration</emphasis> consisting of
            one or more process names (optionally followed by actual
            parameters) that will be created when the application is started.
            A Tscript may contain more than one ToolBus configuration.</para>
          </listitem>

          <listitem>
            <para>An <emphasis>include file</emphasis> that contains another
            Tscript that will be literally included.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>constant definition</emphasis>.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>conditional</emphasis> that allows the
            conditional inclusion or exclusion of parts of the Tscript.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.tscripts-first-example">
        <title>A first example</title>

        <para>Before delving into the details of Tscripts, it is good to have
        a look at the hello world application <filename>hello1.tb</filename>
        shown in <xref linkend="example.hello1" />.</para>

        <para><example xml:id="example.hello1">
            <title>hello1.tb</title>

            <programlisting>process HELLO <co xml:id="co.hello1-1" />
is <co xml:id="co.hello1-2" />
  printf(“Hello world, my first Tscript!\n”) <co xml:id="co.hello1-3" />

toolbus(HELLO) <co xml:id="co.hello1-4" /></programlisting>

            <para>Notes:</para>

            <calloutlist>
              <callout arearefs="co.hello1-1">
                <para>Here starts the definition of a process with name
                <literal>HELLO</literal>.</para>
              </callout>

              <callout arearefs="co.hello1-2">
                <para>After the keyword <literal>is</literal> follows the
                process expression that defines the behaviour of this
                process.</para>
              </callout>

              <callout arearefs="co.hello1-3">
                <para>The process expression consists of a single action that
                prints a string.</para>
              </callout>

              <callout arearefs="co.hello1-4">
                <para>Define the initial ToolBus configuration, in this case
                only process HELLO will be started.</para>
              </callout>
            </calloutlist>
          </example></para>

        <para>Running this example will yield the following command line
        dialog:</para>

        <screen>1&gt; toolbus hello1.tb
Hello world, my first Tscript!
2&gt;</screen>

        <para>Becoming more courageous, we show now a more ambitious Tscript
        <literal>hello2.tb</literal> in <xref linkend="example.hello2" /> that
        does not print the hello string itself, but executes a tool to compute
        it.</para>

        <para><example xml:id="example.hello2">
            <title>hello2.tb</title>

            <programlisting>process HELLO is <co xml:id="co.hello2-1" />
  let H : hello, <co xml:id="co.hello2-2" />
      S : str    <co xml:id="co.hello2-3" />
  in
         execute(hello, H?) <co xml:id="co.hello2-4" /> .   <co
                xml:id="co.hello2-5" />
         snd-eval(H, get_text) .   <co xml:id="co.hello2-6" />
         rec-value(H, text(S?)).   <co xml:id="co.hello2-7" />
         printf(S)                 <co xml:id="co.hello2-8" />
  endlet

tool hello is {command = “hello” } <co xml:id="co.hello2-9" />
toolbus(HELLO)                     <co xml:id="co.hello2-10" /></programlisting>

            <para>Notes:</para>

            <calloutlist>
              <callout arearefs="co.hello2-1">
                <para>Define a process <literal>HELLO</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-2">
                <para>Use a <literal>let ... in ... endlet</literal> construct
                to declare local variables. Variable <literal>H</literal> is
                declared with type <literal>hello</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-3">
                <para>Variable <literal>S</literal> is declared with type
                <literal>str</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-4">
                <para>Execute the <literal>hello</literal> tool (according to
                the tool definition at <xref linkend="co.hello2-9" />). The
                resulting tool identifier is assigned to variable
                <literal>H</literal>. Observe that the name of the tool and
                the type of <literal>H</literal> are identical.</para>
              </callout>

              <callout arearefs="co.hello2-5">
                <para>Use the sequential composition operator
                <literal>.</literal> to combine atom actions into a larger
                process expression.</para>
              </callout>

              <callout arearefs="co.hello2-6">
                <para>Send an evaluation request to the tool we have just
                executed. <literal>H</literal> identifies the tool instance,
                and <literal>get_text</literal> is the term to be sent to the
                hello tool.</para>
              </callout>

              <callout arearefs="co.hello2-7">
                <para>In response to the evaluation request, the hello tool
                returns a value of the form <literal>text("Hello world from my
                first tool")</literal>. The actual text is extracted by the
                result variable <literal>S?</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-8">
                <para>Print the string value of <literal>S</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-9">
                <para>The definition for the hello tool. It contains the name
                of an executable program to be run when this tool is
                executed.</para>
              </callout>

              <callout arearefs="co.hello2-10">
                <para>The initial ToolBus configuration consisting of just the
                <literal>HELLO</literal> process.</para>
              </callout>
            </calloutlist>
          </example></para>

        <para>All the Tscript primitives (including the ones that occur in
        these two simple examples) will now be described in more depth.</para>
      </section>

      <section xml:id="section.process-primitives">
        <title>Process primitives</title>

        <para>During execution, the ToolBus consists of a parallel composition
        of processes. The ToolBus configurations define the processes that are
        created at the start of the start of the application, but later on
        processes may die and new ones may be created.</para>

        <para>Each process has a local state in the form of private local
        variables. These variables get their value through assignment and
        matching. They are only visible inside each process.</para>

        <para>Processes are built-in up from atomic actions (detailed below)
        and atomic actions can be combined into process expressions using the
        following operators:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Sequential composition</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> .
            <replaceable>P</replaceable><subscript>2</subscript></literal>.
            First the actions in <replaceable>
            P</replaceable><subscript>1</subscript>are executed and then the
            ones in
            <replaceable>P</replaceable><subscript>2</subscript>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Choice</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> +
            <replaceable>P</replaceable><subscript>2</subscript></literal>. A
            choice is made between the first action in
            <replaceable>P</replaceable><subscript>1</subscript>and the first
            action in <replaceable>P</replaceable><subscript>2</subscript>.
            This choice is based on two criteria:</para>

            <itemizedlist>
              <listitem>
                <para>An action to be selected must be
                <emphasis>enabled</emphasis>.</para>
              </listitem>

              <listitem>
                <para>If more than one action is enabled, a random choice is
                made.</para>
              </listitem>
            </itemizedlist>

            <para>There are various ways in which an action can be enabled
            (this depends on the precise action):</para>

            <itemizedlist>
              <listitem>
                <para>An associated condition evaluates to true (see
                conditional and guarded command, below).</para>
              </listitem>

              <listitem>
                <para>An associated timing constraint is true.</para>
              </listitem>

              <listitem>
                <para>Required external tool results are available.</para>
              </listitem>

              <listitem>
                <para>Communication conditions are satisfied.</para>
              </listitem>
            </itemizedlist>

            <para>Once the choice for the first action has been made all
            remaining actions of the selected process expression
            <replaceable>P</replaceable><subscript>1</subscript> or
            <replaceable>P</replaceable><subscript>2</subscript> are executed
            as well.</para>
          </listitem>

          <listitem>
            <para><emphasis>Parallel composition</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> ||
            <replaceable>P</replaceable><subscript>2</subscript></literal>.
            The actions in
            <replaceable>P</replaceable><subscript>1</subscript>and
            <replaceable>P</replaceable><subscript>2</subscript> are executed
            in parallel. This means that the sequential order of the actions
            in
            <replaceable>P</replaceable><subscript>1</subscript>respectively
            <replaceable>P</replaceable><subscript>2</subscript> is respected
            but that apart from this constraint the actions can be executed in
            arbitrary order.</para>
          </listitem>

          <listitem>
            <para><emphasis>Iteration</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> *
            <replaceable>P</replaceable><subscript>2</subscript></literal>.
            <replaceable>P</replaceable><subscript>1</subscript> is executed
            repeatedly, until an action of
            <replaceable>P</replaceable><subscript>2</subscript> is executed.
            Execution then continues with the remaining actions of
            <replaceable>P</replaceable><subscript>2</subscript>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Conditional</emphasis> <literal>if
            <replaceable>T</replaceable> then
            <replaceable>P</replaceable><subscript>1</subscript> else
            <replaceable>P</replaceable><subscript>2</subscript> fi</literal>.
            The test <replaceable>T</replaceable> is evaluated and if the
            result is true then
            <replaceable>P</replaceable><subscript>1</subscript> is executed,
            otherwise <replaceable>P</replaceable><subscript>2</subscript> is
            executed. Note that the evaluation of the test does not count as a
            separate atomic action; the test is effectively attached to the
            first atom of
            <replaceable>P</replaceable><subscript>1</subscript>respectively
            <replaceable>P</replaceable><subscript>2</subscript>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Guarded command</emphasis> <literal>if
            <replaceable>T</replaceable> then <replaceable>P</replaceable>
            fi</literal>. The test <replaceable>T</replaceable> is evaluated
            and if the result is true then
            <replaceable>P</replaceable><subscript>1</subscript> is executed,
            otherwise this command deadlocks.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.local-variables">
        <title>Local variables</title>

        <para>As we have seen local variables play a key role in the execution
        of Tscripts. They are defined using the <literal>let</literal>
        construct:</para>

        <itemizedlist>
          <listitem>
            <para>let Var1 : Type1, ... in P endlet. Variables Var1, ... are
            declared with respective type Type1, .... These variables act as
            local variables during the execution of the process expression P.
            P may contain other <literal>let</literal> constructs.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.primitive-actions">
        <title>Primitive actions</title>

        <itemizedlist>
          <listitem>
            <para><emphasis>Deadlock</emphasis> <literal>delta</literal>. This
            constant represents the process that cannot execute any further
            steps. During execution deadlock is always avoided as long as this
            is possible. A process that end in deadlock effectively terminates
            and disappears.</para>
          </listitem>

          <listitem>
            <para><emphasis>Silent step</emphasis> <literal>tau</literal>.
            This constant represents one internal step in a process and
            resemble a dummy statement in a conventional programming
            language.</para>
          </listitem>

          <listitem>
            <para>Print printf. An action for generating formatted
            output.</para>
          </listitem>

          <listitem>
            <para><emphasis>Assignment</emphasis>
            <literal><replaceable>V</replaceable> :=
            <replaceable>T</replaceable></literal>. The term
            <literal>T</literal> is evaluated as expression (using the
            built-in functions) and the result is assigned to the local
            variable <replaceable>V</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.messages">
        <title>Messages: synchronous communication primitives</title>

        <para>Synchronous communication resembles an ordinary phone call: it
        involves two processes that can communicate at the same instant in
        time. In ToolBus terminology <emphasis>messages</emphasis> are used
        for synchronous communication. There are two primitives
        involved:</para>

        <itemizedlist>
          <listitem>
            <para><literal>snd-msg</literal> sends a message to another
            process.</para>
          </listitem>

          <listitem>
            <para><literal>rec-msg</literal> receives a message from another
            process.</para>
          </listitem>
        </itemizedlist>

        <para>Two requirements have to be satisfied before communication can
        take place:</para>

        <itemizedlist>
          <listitem>
            <para>The arguments of <literal>snd-msg</literal> and
            <literal>rec-msg</literal> match with each other.</para>
          </listitem>

          <listitem>
            <para>In addition, <literal>snd-msg</literal> respectively
            <literal>rec-msg</literal> are enabled in each process.</para>
          </listitem>
        </itemizedlist>

        <para>When communication takes place, the effects of the argument
        matching is recorded in the local state of each process and both
        continue execution. The observant reader may have noticed that sending
        and receiving is actually symmetric: by way of result variables in the
        arguments of <literal>snd-msg</literal> and <literal>rec-msg</literal>
        information may flow from sender to receiver and <emphasis>vice
        versa</emphasis>.</para>
      </section>

      <section xml:id="section.notes">
        <title>Notes: asynchronous broadcasting primitives</title>

        <para>Asynchronous communication resembles conventional e-mail: it
        involves one sending and zero or more receiving processes that read
        the communicated information at a later instant in time. In ToolBus
        terminology <emphasis>notes</emphasis> are used for asynchronous
        communication. There four primitives involved:</para>

        <itemizedlist>
          <listitem>
            <para><literal>subscribe(<replaceable>T</replaceable>)</literal>.
            Subscribes a process to notes that match the term
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>unsubscribe(<replaceable>T</replaceable>)</literal>.
            Unsubscribes a process from notes that match
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>snd-note(<replaceable>T</replaceable>)</literal>.
            Broadcast the term <replaceable>T</replaceable> to all subscribed
            processes. Effectively, <replaceable>T</replaceable> is placed in
            the private inbox of each subscribed process to be read at a later
            moment.</para>
          </listitem>

          <listitem>
            <para><literal>rec-note(<replaceable>T</replaceable>)</literal>.
            Receive a note that matches <replaceable>T</replaceable>.
            Effectively, the private inbox is searched for a note that matches
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>no-note(<replaceable>T</replaceable>)</literal>.
            There is no note that matches <replaceable>T</replaceable> in the
            private inbox.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.named-processes">
        <title>Using named processes</title>

        <para>A process definition associates a name
        <replaceable>Pnm</replaceable> (optimally followed by parameters) with
        a process expression <replaceable>P</replaceable>. These process names
        can be used in two ways in process expressions:</para>

        <itemizedlist>
          <listitem>
            <para>An <emphasis>inline process expression</emphasis>
            <literal><replaceable>Pnm</replaceable>(...)</literal>:
            Effectively, this amount to macro substitution:
            <replaceable>Pnm</replaceable> is replaced by the process
            expression <replaceable>P</replaceable> (after proper parameter
            substitution).</para>
          </listitem>

          <listitem>
            <para>A <emphasis>process creation</emphasis>
            <literal>create(<replaceable>Pnm</replaceable>(...),
            <replaceable>Pid</replaceable>?)</literal>: a completely new
            process is created that runs in parallel with all other processes
            currently running in the ToolBus. The process identifier of this
            new process is assigned to <replaceable>Pid</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.tool-primitives">
        <title>Tool primitives</title>

        <para>There two possible scenarios for a ToolBus tool. In scenario 1,
        the tool is executed from the ToolBus, the tool receives a number of
        evaluation requests and/or generates an number of events, and finally,
        the ToolBus decides to terminate the execution of the tool. A
        variation of scenario 1 is that the tool decides to disconnect from
        the ToolBus and continues execution disconnect from the ToolBus
        application. In scenario 2, the tool is executed separately and starts
        its cooperation by requesting a connection with the ToolBus. Once
        connected, it follows the same steps as in scenario 1. The following
        primitives achieve this (also see <xref
        linkend="figure.tool-communication" /> for the various communication
        patterns between ToolBus and tools):</para>

        <itemizedlist>
          <listitem>
            <para><literal>execute(<replaceable>Tnm</replaceable>,
            <replaceable>Tid</replaceable>?)</literal>: Execute a tool with
            name <replaceable>Tnm</replaceable>. The result is a
            <emphasis>tool identifier</emphasis> that is bound to
            <replaceable>Tid</replaceable>. Tool identifiers are unique; if
            more than one instance of the same tool is executing they can be
            distinguished via their tool identifier. There are two additional
            constraints:</para>

            <itemizedlist>
              <listitem>
                <para>The Tscript should contain a tool definition for
                <replaceable>Tnm</replaceable>.</para>
              </listitem>

              <listitem>
                <para>The variable Tid should have a type that corresponds
                with the tool name, i.e., it should be declared as
                <literal><replaceable>Tid</replaceable> :
                <replaceable>Tnm</replaceable></literal>. Why? Well this in
                this way the implementation can track via the type of the tool
                identifier in each tool request, <emphasis>which</emphasis>
                tool it is and that information is essential for the automatic
                generation of adapter code.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><literal>snd-terminate(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: terminates the execution
            of the tool instance <replaceable>Tid</replaceable>. The term
            <replaceable>T</replaceable> contains a reason for the termination
            and is usually printed by the tool on termination.</para>
          </listitem>

          <listitem>
            <para><literal>rec-connect(<replaceable>Tnm</replaceable>,
            <replaceable>Tid</replaceable>?)</literal>: receive a connection
            request for a tool with name <replaceable>Tnm</replaceable>.
            <literal>rec-connect</literal> is very similar to
            <literal>execute</literal>. The only difference is the initiating
            party: for <literal>execute</literal> the ToolBus and for
            <literal>rec-connect</literal> the tool.</para>
          </listitem>

          <listitem>
            <para><literal>rec-disconnect(<replaceable>Tid</replaceable>?)</literal>:
            receive a disconnection request from a tool. It does not matter
            whether the connection with the tool was originally established
            via <literal>execute</literal> or
            <literal>rec-connect</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>snd-eval(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: send an evaluation
            request to a tool. All value occurrences in
            <replaceable>T</replaceable> are first replaced by their value
            before sending <replaceable>T</replaceable> to the tool. It is up
            to the tool to interpret the term. The usual scenario is that the
            outermost function symbol of <replaceable>T</replaceable> is
            identical to the name of a procedure in the tool and that
            procedure is called. The ToolBus can only send one evaluation
            request at a time. Only when the request is cancelled, or a value
            is returned by the tool, the next request can be sent to the
            tool.</para>
          </listitem>

          <listitem>
            <para><literal>rec-value(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: receive a value from a
            tool in response to a previous <literal>snd-eval</literal>
            request. <replaceable>T</replaceable> has to match the value from
            the tool; this is useful for case distinctions. In many case, T
            consists of a single result variable, or a is a term that contains
            result variables.</para>
          </listitem>

          <listitem>
            <para><literal>snd-do(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: send an evaluation
            request to a tool but do not expect a return value. Typically used
            to implement printing or logging activities.</para>
          </listitem>

          <listitem>
            <para><literal>rec-event(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable><subscript>1</subscript>,
            ...)</literal>: receive an event from a tool. Events need not be
            handled one-by-one. The same tool may generate more than one event
            provided that the value of argument
            <replaceable>T</replaceable><subscript>1</subscript> differs.
            <replaceable>T</replaceable><subscript>1</subscript> thus serves
            as identification for this event.</para>
          </listitem>

          <listitem>
            <para><literal>snd-ack-event(<replaceable>Tid</replaceable>,
            <replaceable><replaceable>T</replaceable><subscript>1</subscript></replaceable>)</literal>:
            acknowledge the completion of the handling of a previous event.
            Since, <replaceable>T</replaceable><subscript>1</subscript> is
            identical to the
            <replaceable>T</replaceable><subscript>1</subscript> in a
            preceding <literal>snd-event</literal> and is used to identify
            that event.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.timing-primitives">
        <title>Timing primitives</title>

        <para>Time can play an important role in applications, be it as
        ingredient in a protocol that prescribes certain time constraints, be
        it as watchdog that certain operations are carried out in time. The
        general approach in Tscripts is that a delay or timeout may be
        attached to every atom action. Delays and timeouts may be relative to
        the current time or they may be specified in absolute time. The
        primitives are as follows (for arbitrary atomic action
        <replaceable>A</replaceable>):</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Relative delay</emphasis>:
            <literal><replaceable>A</replaceable>
            delay(<replaceable>E</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> can only become enabled after
            <replaceable>E</replaceable><replaceable> </replaceable>seconds
            have passed.</para>
          </listitem>

          <listitem>
            <para><emphasis>Absolute delay</emphasis>:
            <literal><replaceable>A</replaceable>
            abs-delay(<replaceable>Year</replaceable>,
            <replaceable>Month</replaceable>, <replaceable>Day</replaceable>,
            <replaceable>Hour</replaceable>, <replaceable>Min</replaceable>,
            <replaceable>Sec</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> can only become enabled after the
            specified absolute date and time.</para>
          </listitem>

          <listitem>
            <para><emphasis>Relative timeout</emphasis>:
            <literal><replaceable>A</replaceable>
            timeout(<replaceable>E</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> is only enabled during the next
            <replaceable>E</replaceable> seconds.</para>
          </listitem>

          <listitem>
            <para><emphasis>Absolute timeout</emphasis>:
            <literal><replaceable>A</replaceable>
            abs-timeout(<replaceable>Year</replaceable>,
            <replaceable>Month</replaceable>, <replaceable>Day</replaceable>,
            <replaceable>Hour</replaceable>, <replaceable>Min</replaceable>,
            <replaceable>Sec</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> is only enabled until the specified
            absolute date and time.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.expressions">
        <title>Expressions</title>

        <para>Terms can occur in Tscripts on various locations. In the
        majority of cases these terms are used as such; only variables are
        replaced by their value but no further evaluation of terms take place.
        There are, however, two exceptions to this general rule. In three
        cases, terms are evaluated:</para>

        <itemizedlist>
          <listitem>
            <para>The test in <literal>if <replaceable>T</replaceable> then
            ... fi</literal> and <literal>if <replaceable>T</replaceable> then
            ... else ... fi</literal>.</para>
          </listitem>

          <listitem>
            <para>The right-hand side of the assignment
            <literal><replaceable>V</replaceable> :=
            <replaceable>T</replaceable></literal>.</para>
          </listitem>

          <listitem>
            <para>In delays or timeouts.</para>
          </listitem>
        </itemizedlist>

        <para>The term is evaluated in a bottom-up manner, i.e., first
        arguments are evaluated and then the function is applied. Here are
        some examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>not(true)</literal> evaluates to
            <literal>false</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>add(mul(2,3), 4)</literal> evaluates to
            <literal>10</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>greater(6,5)</literal> evaluates to
            <literal>true</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>first([9, 8, 7])</literal> evaluates to
            <literal>9</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>A detailed overview of all built-in functions is given in XXX.
        They can be summarized as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Functions on <emphasis>Booleans</emphasis>:
            <literal>not</literal>, <literal>and</literal>,
            <literal>or</literal>.</para>
          </listitem>

          <listitem>
            <para>Functions on <emphasis>Integers</emphasis>:
            <literal>add</literal>, <literal>sub</literal>,
            <literal>mul</literal>, <literal>div</literal>,
            <literal>mod</literal>, <literal>less</literal>,
            <literal>less-equal</literal>, <literal>greater</literal>,
            <literal>greater-equal</literal>.</para>
          </listitem>

          <listitem>
            <para>Functions on <emphasis>lists</emphasis>:
            <literal>first</literal>, <literal>next</literal>,
            <literal>get</literal>, <literal>put</literal>,
            <literal>join</literal>, <literal>member</literal>,
            <literal>subset</literal>, <literal>diff</literal>,
            <literal>inter</literal>, <literal>size</literal>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Miscellaneous</emphasis> functions:
            <filename>equal</filename>, <literal>not-equal</literal>,
            <literal>process-id</literal>, <literal>process-name</literal>,
            <literal>current-time</literal>, <literal>quote</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section xml:id="section.tscript-examples">
    <title>Examples of Tscripts</title>

    <para>We are now ready to have a look at some larger examples of
    Tscripts.</para>

    <section xml:id="section.example-calculator">
      <title>Calculator Example</title>

      <para>The calculator example illustrates how a calculator tool that can
      compute simple arithmetic expressions is shared by cooperating
      processes. The overall architecture is shown in <xref
      linkend="figure.clock-architecture" />. The application consists of the
      following 5 processes:</para>

      <itemizedlist>
        <listitem>
          <para><literal>CALC</literal>: the calculator
          <emphasis>process</emphasis> that regulates the access to the
          calculator <emphasis>tool</emphasis> <literal>calc</literal>, see
          <xref linkend="example.CALC" />.</para>
        </listitem>

        <listitem>
          <para><literal>BATCH</literal>: a batch process that uses the tool
          <literal>batch</literal> to read an expression from file, calculate
          its value and write the result back to file, see <xref
          linkend="example.BATCH" />.</para>
        </listitem>

        <listitem>
          <para><literal>UI</literal>: a user-interface process that uses the
          tool ui to allow a user to enter an expression and get its value
          back, see <xref linkend="example.UI" />. Observe that the processes
          <literal>BATCH</literal> and <literal>UI</literal> are both
          competing for the shared resource calculator (implemented by the
          process <literal>CALC</literal> and the tool
          <literal>calc</literal>).</para>
        </listitem>

        <listitem>
          <para><literal>LOG</literal>: a logging process that maintains a log
          of all calculations that have been performed by the application, see
          <xref linkend="example.LOG" />.</para>
        </listitem>

        <listitem>
          <para><literal>CLOCK</literal>: a clock process that uses the tool
          <literal>clock</literal> to provide the current time, see <xref
          linkend="example.CLOCK" />.</para>
        </listitem>
      </itemizedlist>

      <para><figure xml:id="figure.clock-architecture">
          <title>Architecture of the clock application</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="clock-architecture.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>The global structure of the Tscript
      <literal>calc.tb</literal> is sketched in <xref
      linkend="example.global-structure-calc.tb" />.<example
          xml:id="example.global-structure-calc.tb">
          <title>Global structure of <literal>calc.tb</literal></title>

          <para><programlisting>process CALC is ... 
tool calc is ...
     <lineannotation>See <xref linkend="example.CALC" /> </lineannotation>

process BATCH is ... 
tool batch is ...
     <lineannotation>See <xref linkend="example.BATCH" /> </lineannotation>

process UI is ...         
     <lineannotation>See <xref linkend="example.UI" /> </lineannotation>

process CALC-BUTTON is ... 
     <lineannotation>See <xref linkend="example.CALC-BUTTON" /> </lineannotation>

process LOG-BUTTON is ...  
     <lineannotation>See <xref linkend="example.LOG-BUTTON" /> </lineannotation>

process TIME-BUTTON is ... 
     <lineannotation>See <xref linkend="example.LOG-BUTTON" /> </lineannotation>

process QUIT-BUTTON is ...
     <lineannotation>See <xref linkend="example.QUIT-BUTTON" /> </lineannotation>

process LOG is ...
     <lineannotation>See <xref linkend="example.LOG" /> </lineannotation>

process CLOCK is ...
     <lineannotation>See <xref linkend="example.CLOCK" /> </lineannotation>

toolbus(CALC, BATCH, UI, LOG, CLOCK)
     <lineannotation>See <xref
                  linkend="example.calculator-toolbus-configuration" />
                </lineannotation></programlisting></para>
        </example><example xml:id="example.CALC">
          <title>Process <literal>CALC</literal> and tool
          <literal>calc</literal></title>

          <para><programlisting>process CALC is
    let Tid : calc, E : str, V : term
    in
         execute(calc, Tid?). <co xml:id="co.calc.1" />
          (<co xml:id="co.calc.2" />
            rec-msg(compute, E?) . <co xml:id="co.calc.3" />
            snd-eval(Tid, expr(E)) . rec-value(Tid, val(V?)) . <co
                xml:id="co.calc.4" />
            snd-msg(compute, E, V) . snd-note(compute(E, V))  <co
                xml:id="co.calc.5" />
          )* delta <co xml:id="co.calc.6" />
    endlet

tool calc is { command = “calc”}</programlisting>Notes:<calloutlist>
              <callout arearefs="co.calc.1">
                <para>Execute the <literal>calc</literal> tool. The tool
                identifier is assigned to the variable <literal>Tid</literal>,
                that is of type <literal>calc</literal>.</para>
              </callout>

              <callout arearefs="co.calc.2">
                <para>Begin of endless loop.</para>
              </callout>

              <callout arearefs="co.calc.3">
                <para>Receive a compute message.</para>
              </callout>

              <callout arearefs="co.calc.4">
                <para>Send an evaluation request to the
                <literal>calc</literal> tool and receive its value
                back.</para>
              </callout>

              <callout arearefs="co.calc.5">
                <para>Send a reply to the original compute request. By
                convention, the original message is included in the reply.
                Also send a note regarding this (expression,result) pair for
                the sake of logging.</para>
              </callout>

              <callout arearefs="co.calc.6">
                <para>End of the endless loop.</para>
              </callout>
            </calloutlist></para>
        </example><example xml:id="example.BATCH">
          <title>Process <literal>BATCH</literal> and tool
          <literal>batch</literal></title>

          <para><programlisting>process BATCH is
    let Tid : batch, E : str, V : int
    in
         execute(batch, Tid?).
         (
           snd-eval(Tid, fromFile) . rec-value(Tid, expr(E?)) . <co
                xml:id="co.batch.1" />
           snd-msg(compute, E) . rec-msg(compute, E, V?) .      <co
                xml:id="co.batch.2" />
           snd-do(Tid, toFile(E, V))  <co xml:id="co.batch.3" />
         ) * delta
    endlet

tool batch is {command = “batch”}</programlisting>Notes:<calloutlist>
              <callout arearefs="co.batch.1">
                <para>Send an evaluation request to the
                <literal>batch</literal> tool and receive an expression
                back.</para>
              </callout>

              <callout arearefs="co.batch.2">
                <para>Communicate with the <literal>CALC</literal> process
                (and thus with the <literal>calc</literal> tool) to get the
                expression evaluated.</para>
              </callout>

              <callout arearefs="co.batch.3">
                <para>Send the result back to the <literal>batch</literal>
                tool.</para>
              </callout>
            </calloutlist></para>
        </example>The user-interface is shown in <xref
      linkend="figure.calc-gui" /> and behaves as follows:</para>

      <itemizedlist>
        <listitem>
          <para>When the user presses <guimenuitem>Calc</guimenuitem>, a
          dialog window appears to enter an expression. The result is shown in
          a separate window. See <xref linkend="figure.calc-dialog" />.</para>
        </listitem>

        <listitem>
          <para>Pressing <guimenuitem>showLog</guimenuitem> displays all
          calculations so far.</para>
        </listitem>

        <listitem>
          <para>Pressing <guimenuitem>showTime</guimenuitem> displays the
          current time in a separate window.</para>
        </listitem>

        <listitem>
          <para>Pressing <guimenuitem>Quit</guimenuitem> end the
          application.</para>
        </listitem>
      </itemizedlist>

      <para><figure xml:id="figure.calc-gui">
          <title>The calc GUI</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="calc-gui.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure><example xml:id="example.UI">
          <title>Process <literal>UI</literal> and tool
          <literal>ui</literal></title>

          <para><programlisting>process UI is
    let Tid : ui
    in
            execute(ui, Tid?) .
            ( CALC-BUTTON(Tid) + LOG-BUTTON(Tid))* delta <co xml:id="co.UI.1" />
             ||
             TIME-BUTTON(Tid) * delta <co xml:id="co.UI.2" />
             ||
             QUIT-BUTTON(Tid) <co xml:id="co.UI.3" />
    endlet

tool ui is { command = wish-adapter -script calc.tcl” }</programlisting>Notes:<calloutlist>
              <callout arearefs="co.UI.1">
                <para><literal>CALC-BUTTON</literal> and
                <literal>LOG-BUTTON</literal> are mutually exclusive and they
                can be activated indefinitely.</para>
              </callout>

              <callout arearefs="co.UI.2">
                <para><literal>TIME-BUTTON</literal> is independent and can
                also be repeated indefinitely.</para>
              </callout>

              <callout arearefs="co.UI.3">
                <para><literal>QUIT-BUTTON</literal> is also independent but
                be activated only once (for obvious reasons).</para>
              </callout>
            </calloutlist>Also observe the extensive use of named process
          expressions like, for instance, <literal>CALC-BUTTON</literal> to
          give an high-level overview of the <literal>UI</literal> process.
          See <xref linkend="example.CALC-BUTTON" />, <xref
          linkend="example.LOG-BUTTON" />, <xref
          linkend="example.TIME-BUTTON" />, and <xref
          linkend="example.QUIT-BUTTON" /> for their definitions.</para>
        </example><example xml:id="example.CALC-BUTTON">
          <title>Process <literal>CALC-BUTTON</literal></title>

          <para><programlisting>process CALC-BUTTON(Tid : ui) is
    let N : int, E : str, V : term
    in
            rec-event(Tid, N?, button(calc)) . <co xml:id="co.CALC-BUTTON.1" />
            snd-eval(Tid, get-expr-dialog) .   <co xml:id="co.CALC-BUTTON.2" />
            (  rec-value(Tid, cancel)          <co xml:id="co.CALC-BUTTON.3" />
            +  rec-value(Tid, expr(E?)) .      <co xml:id="co.CALC-BUTTON.4" />
                snd-msg(compute, E) .
                rec-msg(compute, E, V?) .
                 snd-do(Tid, display-value(V)) <co xml:id="co.CALC-BUTTON.5" />
            ) . snd-ack-event(Tid, N)          <co xml:id="co.CALC-BUTTON.6" />
    endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.CALC-BUTTON.1">
                <para>The <guimenuitem>Calc</guimenuitem> button is pressed;
                the <literal>ui</literal> tool generates an event.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.2">
                <para>Ask the <literal>ui</literal> tool for an expression,
                see <xref linkend="figure.calc-dialog" /> for examples.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.3">
                <para>The user cancels the dialog; no further actions are
                needed.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.4">
                <para>The user has entered an expression. Communicate with the
                CALC process to compute a value.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.5">
                <para>Ask the <literal>ui</literal> tool to display the
                value.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.6">
                <para>Acknowledge the event to the tool.</para>
              </callout>
            </calloutlist></para>
        </example><figure xml:id="figure.calc-dialog">
          <title>Dialog resulting from <literal>CALC-BUTTON</literal></title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="calc-dialog.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure><example xml:id="example.LOG-BUTTON">
          <title>Process <literal>LOG-BUTTON</literal></title>

          <para><programlisting>process LOG-BUTTON(Tid : ui) is
    let N : int, L : term
    in
            rec-event(Tid, N?, button(showLog)) .
            snd-msg(showLog) .
            rec-msg(showLog, L?) .
            snd-do(Tid, display-log(L)) .
            snd-ack-event(Tid, N)
    endlet</programlisting></para>
        </example><example xml:id="example.TIME-BUTTON">
          <title>Process <literal>TIME-BUTTON</literal></title>

          <para><programlisting>process TIME-BUTTON(Tid : ui) is
    let N : int, T : str
    in     rec-event(Tid, N?, button(showTime)) .
            snd-msg(showTime) .
            rec-msg(showTime, T?) .
            snd-do(Tid, display-time(T)) .
            snd-ack-event(Tid, N)
    endlet</programlisting></para>
        </example><example xml:id="example.QUIT-BUTTON">
          <title>Process <literal>QUIT-BUTTON</literal></title>

          <para><programlisting>process QUIT-BUTTON(Tid : ui) is
        rec-event(Tid, button(quit)) .
        shutdown("End of calc demo")</programlisting></para>
        </example><example xml:id="example.LOG">
          <title>Process <literal>LOG</literal> and tool
          <literal>log</literal></title>

          <para><programlisting>process LOG is
    let Tid : log, E : str, V : term, L : term
    in    subscribe(compute(&lt;str&gt;, &lt;term&gt;)) .
            execute(log, Tid?).
                (       rec-note(compute(E?, V?)) . <co xml:id="co.LOG.1" />
                        snd-do(Tid, writeLog(E, V))
                +
                        rec-msg(showLog) .          <co xml:id="co.LOG.2" />
                        snd-eval(Tid, readLog) .
                        rec-value(Tid, history(L?)) .
                        snd-msg(showLog, history(L))
                ) * delta
    endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.LOG.1">
                <para>Receive a note about a computation that has taken place
                and log it.</para>
              </callout>

              <callout arearefs="co.LOG.2">
                <para>Receive a message to show the value of the current log.
                Retrieve it from the <literal>log</literal> tool and return
                the result.</para>
              </callout>
            </calloutlist></para>

          <para>An alternative way to describe the LOG process is shown in
          <xref linkend="example.LOG1" />. Instead of running a separate log
          tool, the process LOG1 maintains the log in a local process variable
          TheLog. See <xref linkend="section.built-in-functions" /> for a
          description of the function <literal>join</literal> that is used
          this example.</para>
        </example><example xml:id="example.LOG1">
          <title>Process <literal>LOG1</literal>: maintaining the log inside
          the ToolBus</title>

          <para><programlisting>process LOG1 is
    let TheLog : list, E : str, V : term
    in      subscribe(compute(&lt;str&gt;, &lt;term&gt;)) .
            TheLog := [] .
                (       rec-note(compute(E?, V?)) .
                        TheLog := join(TheLog, [[E, V]])
                 +
                        rec-msg(showLog) .
                        snd-msg(showLog, TheLog)
                ) * delta
    endlet</programlisting></para>
        </example><example xml:id="example.CLOCK">
          <title>Process <literal>CLOCK</literal> and tool
          <literal>clock</literal></title>

          <para><programlisting>process CLOCK is
    let Tid : clock, T : str
    in
            execute(clock, Tid?).
             (     rec-msg(showTime) .
                    snd-eval(Tid, readTime) .
                    rec-value(Tid, time(T?)) .
                    snd-msg(showTime, T)
              ) * delta
    endlet</programlisting></para>
        </example>The complete ToolBus configuration that describes the start
      of the calculator demo is shown in <xref
      linkend="example.calculator-toolbus-configuration" />. It starts the
      mentioned processes in parallel and from that moment on user-interaction
      and the activities of the BATCH process will drive the
      execution.<example xml:id="example.calculator-toolbus-configuration">
          <title>ToolBus configuration for calculator demo</title>

          <para><programlisting>toolbus (CALC, BATCH, UI, LOG, CLOCK)</programlisting></para>
        </example></para>
    </section>

    <section xml:id="section.example-auction">
      <title>Auction Example</title>

      <para>In the <emphasis>classical auction</emphasis>, the auction master
      and all bidders are in the same room and interact with each other
      according to a fixed protocol. It is shown in <xref
      linkend="figure.classical-auction" />. The steps in the protocol
      are:</para>

      <orderedlist>
        <listitem>
          <para>The auction master introduces a new item for sale and sets an
          initial price for it.</para>
        </listitem>

        <listitem>
          <para>Next, bidders raise their hand and shout a new bid that is to
          be acknowledged by the auction master.</para>
        </listitem>

        <listitem>
          <para>Step 2 is repeated as long as new bids come in.</para>
        </listitem>

        <listitem>
          <para>When no new bids are being made, the auction master asks for
          "any higher bid?" and waits during a fixed period.</para>
        </listitem>

        <listitem>
          <para>If no new bids come in during this period, the auction master
          declares the item for sale to be sold to the highest bidder.</para>
        </listitem>

        <listitem>
          <para>If a new bid comes in during this period, the procedure
          continues with step 2.</para>
        </listitem>
      </orderedlist>

      <para><figure xml:id="figure.classical-auction">
          <title>Classical auction</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="classic-auction.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>A striking aspect of the classical auction is that the
      auction master and the bidders can <emphasis>see</emphasis> each other.
      This is a great communication and synchronization tool. In the case of a
      <emphasis>distributed auction</emphasis>, auction master and bidders are
      on different locations and can only communicate via the Internet, see
      <xref linkend="figure.distributed-auction" />.</para>

      <para><figure xml:id="figure.distributed-auction">
          <title>Distributed auction</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="distributed-auction.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The communication and synchronization in a distributed auction has
      to be described explicitly and requires answers to questions
      like:</para>

      <itemizedlist>
        <listitem>
          <para>How are bids synchronized?</para>
        </listitem>

        <listitem>
          <para>How to inform bidders about the highest bid?</para>
        </listitem>

        <listitem>
          <para>How to decide when bidding is over and the item is to be
          sold?</para>
        </listitem>

        <listitem>
          <para>How to handle bidders that come and go during the
          auction?</para>
        </listitem>
      </itemizedlist>

      <para>The auction application to be described answers these questions
      and has an architecture as shown in <xref
      linkend="figure.auction-architecture" />.</para>

      <para><figure xml:id="figure.auction-architecture">
          <title>Architecture of the auction example</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="auction-architecture.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>The auction application consists of a variable number of
      processes:</para>

      <itemizedlist>
        <listitem>
          <para><literal>Auction</literal>: the process Auction orchestrates
          the complete auction and is controlled by the tool
          <literal>master</literal> that enables the auction master to offer
          new items for sale and to monitor the progress of the
          auction.</para>
        </listitem>

        <listitem>
          <para><literal>Bidder</literal>: for each new bidder that enters the
          auction a new process <literal>Bidder</literal> and tool
          <literal>bidder</literal> are created. The tool bidder keep the user
          informed and allows her or him to submit new bids.</para>
        </listitem>
      </itemizedlist>

      <para>The global structure of the Tscript auction.tb is sketched in
      <xref linkend="example.global-structure-auction.tb" />.</para>

      <para><example xml:id="example.global-structure-auction.tb">
          <title>Global structure of <literal>auction.tb</literal></title>

          <para><programlisting>process Auction is ... 
     <lineannotation>See <xref linkend="example.Auction" /> </lineannotation>

tool master is ...

process ConnectBidder is ...
     <lineannotation>See <xref linkend="example.ConnectBidder" /> </lineannotation>

tool batch is ...

process OneSale is ...
     <lineannotation>See <xref linkend="example.OneSale" /> </lineannotation>

process Bidder is ...
     <lineannotation>See <xref linkend="example.Bidder" /> </lineannotation>

toolbus(Auction)</programlisting></para>
        </example><example xml:id="example.Auction">
          <title>Process <literal>Auction</literal></title>

          <para><programlisting>process Auction is
  let Mid : master, Bid : bidder
  in
      execute(master, Mid?) .      <co xml:id="co.Auction.1" />
      ( ConnectBidder(Mid, Bid?)   <co xml:id="co.Auction.2" />
      +      
        OneSale(Mid) 
      ) *
      rec-event(Mid, quit) .        <co xml:id="co.Auction.3" />
      shutdown("Auction is closed") <co xml:id="co.Auction.4" />
  endlet


tool master is { command = "wish-adapter -script master.tcl" }</programlisting>Notes:<calloutlist>
              <callout arearefs="co.Auction.1">
                <para>Execute the <literal>master</literal> tool.</para>
              </callout>

              <callout arearefs="co.AbstractTool.2">
                <para>Repeat:</para>

                <itemizedlist>
                  <listitem>
                    <para>Add new bidders between sales, or</para>
                  </listitem>

                  <listitem>
                    <para>Perform one sale.</para>
                  </listitem>
                </itemizedlist>
              </callout>

              <callout arearefs="co.Auction.3">
                <para>Until auction master quits</para>
              </callout>

              <callout arearefs="co.Auction.4">
                <para>Close the auction application.</para>
              </callout>
            </calloutlist></para>
        </example><example xml:id="example.ConnectBidder">
          <title>Process <literal>ConnectBidder</literal></title>

          <para><programlisting>process ConnectBidder(Mid : master, Bid : bidder?) is
  let Pid : int, Name : str
  in
     rec-connect(Bid?) .               <co xml:id="co.ConnectBidder.1" />     
     create(Bidder(Bid), Pid?) .       <co xml:id="co.ConnectBidder.2" />
     snd-eval(Bid, get-name) .         <co xml:id="co.ConnectBidder.3" />
     rec-value(Bid, name(Name?)) . 
     snd-do(Mid, new-bidder(Bid, Name))<co xml:id="co.ConnectBidder.4" />
  endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.ConnectBidder.1">
                <para>Receive a connection request from a new
                <literal>bidder</literal> tool.</para>
              </callout>

              <callout arearefs="co.ConnectBidder.2">
                <para>Create a new <literal>Bidder</literal> process that
                orchestrates the behaviour of this bidder.</para>
              </callout>

              <callout arearefs="co.ConnectBidder.3">
                <para>Ask <literal>bidder</literal> for its name.</para>
              </callout>

              <callout arearefs="co.ConnectBidder.4">
                <para>Send the name of the bidder to the
                <literal>master</literal> tool.</para>
              </callout>
            </calloutlist></para>
        </example></para>

      <para><example xml:id="example.OneSale">
          <title>Process <literal>OneSale</literal></title>

          <para><programlisting>process OneSale(Mid : master) is
  let Descr : str,                <co xml:id="co.OneSale.1" /> 
      InAmount : int,             <co xml:id="co.OneSale.2" /> 
      Amount : int,               <co xml:id="co.OneSale.3" />
      HighestBid : int,           <co xml:id="co.OneSale.4" />
      Final : bool,               <co xml:id="co.OneSale.5" />
      Sold : bool,            
      Bid : bidder                <co xml:id="co.OneSale.6" />
  in rec-event(Mid, new-item(Descr?, InAmount?)) . <co xml:id="co.OneSale.7" />
      HighestBid := InAmount .
      snd-note(new-item(Descr, InAmount)) .        <co xml:id="co.OneSale.8" />
      Final := false . Sold := false .
      ( <lineannotation>
         Here is the main logic of OneSale</lineannotation>          <co
                xml:id="co.OneSale.9" />
      ) * if Sold then 
             snd-ack-event(Mid, new-item(Descr, InAmount)) 
          fi
  endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.OneSale.1">
                <para><literal>Descr</literal> contains a textual description
                of the current item for sale.</para>
              </callout>

              <callout arearefs="co.OneSale.2">
                <para><literal>InAmount</literal> is the initial amount asked
                for the item.</para>
              </callout>

              <callout arearefs="co.OneSale.3">
                <para><literal>Amount</literal> is the value of the current
                bid.</para>
              </callout>

              <callout arearefs="co.OneSale.4">
                <para><literal>HighestBid</literal> is the highest bid so far
                for this item.</para>
              </callout>

              <callout arearefs="co.OneSale-one-bid.5">
                <para>Two Boolean values control the logic of the bidding
                process. <literal>Final</literal> is true when the call for
                final bids has been issued and <literal>Sold</literal> is true
                when the item has been sold.</para>
              </callout>

              <callout arearefs="co.OneSale-one-bid.6">
                <para>Bidder is a new bidder tool that has connected during
                the sale.</para>
              </callout>

              <callout arearefs="co.OneSale.7">
                <para>The auction master wants to initiate the sale of a new
                item.</para>
              </callout>

              <callout arearefs="co.OneSale.8">
                <para>Inform all connected bidders about the new item that is
                for sale.</para>
              </callout>

              <callout arearefs="co.OneSale.9">
                <para>The detailed logic is explained in <xref
                linkend="example.OneSale-main-logic" />, <xref
                linkend="example.OneSale-one-bid" />, and <xref
                linkend="example.OneSale-other-cases" />.</para>
              </callout>
            </calloutlist></para>
        </example></para>

      <para><example xml:id="example.OneSale-main-logic">
          <title>Process <literal>OneSale</literal>, main logic</title>

          <para><programlisting>( if not(Sold) then ... <co
                xml:id="co.OneSale-main.1" /> fi
+ if not(or(Final, Sold)) then ... <co xml:id="co.OneSale-main.2" />fi 
+ if and(Final, not(Sold)) then ... <co xml:id="co.OneSale-main.3" />fi
+ ConnectBidder(Mid, Bid?) ... <co xml:id="co.OneSale-main.4" />
) * if Sold then ... fi</programlisting></para>

          <para>The main process logic consists of four parts:<calloutlist>
              <callout arearefs="co.OneSale-main.1">
                <para>Handle one incoming bid, see <xref
                linkend="example.OneSale-one-bid" />.</para>
              </callout>

              <callout arearefs="co.OneSale-main.2">
                <para>Start the "any higher bid" procedure, see <xref
                linkend="example.OneSale-other-cases" />.</para>
              </callout>

              <callout arearefs="co.OneSale-main.3">
                <para>Sell the item when no further bids are received, see
                <xref linkend="example.OneSale-other-cases" />.</para>
              </callout>

              <callout arearefs="co.OneSale-main.4">
                <para>Connect a bidder during the sale, see <xref
                linkend="example.OneSale-other-cases" />.</para>
              </callout>
            </calloutlist></para>
        </example></para>

      <para><example xml:id="example.OneSale-one-bid">
          <title>Process <literal>OneSale</literal>, handling one bid</title>

          <para><programlisting>( if not(Sold) then
    rec-msg(bid(Bid?, Amount?)) .          <co xml:id="co.OneSale-one-bid.1" />
    snd-do(Mid, new-bid(Bid, Amount)) .    <co xml:id="co.OneSale-one-bid.2" />
    if less-equal(Amount, HighestBid) then
        snd-msg(Bid, rejected)             <co xml:id="co.OneSale-one-bid.3" />
    else 
        HighestBid := Amount .             <co xml:id="co.OneSale-one-bid.4" />
        snd-msg(Bid, accepted) .           <co xml:id="co.OneSale-one-bid.5" />
        snd-note(update-bid(Amount)) .     <co xml:id="co.OneSale-one-bid.6" />
        snd-do(Mid, update-highest-bid(Bid, Amount)) . <co
                xml:id="co.OneSale-one-bid.7" />
        Final := false
    fi
  fi
+ if not(or(Final, Sold)) then    ... fi 
+ if and(Final, not(Sold)) then ... fi
+ ConnectBidder(Mid, Bid?) ...
) * if Sold then ... fi</programlisting></para>

          <para>Notes:<calloutlist>
              <callout arearefs="co.OneSale-one-bid.1">
                <para>Receive a bid from a bidder.</para>
              </callout>

              <callout arearefs="co.OneSale-one-bid.2">
                <para>Inform the auction master about the new bid.</para>
              </callout>

              <callout arearefs="co.OneSale-one-bid.3">
                <para>Reject the bid when it is too low.</para>
              </callout>

              <callout arearefs="co.OneSale-one-bid.4">
                <para>Remember this bid as the highest bid so far.</para>
              </callout>

              <callout arearefs="co.OneSale-one-bid.5">
                <para>Inform the bidder that his bid is accepted.</para>
              </callout>

              <callout arearefs="co.OneSale-one-bid.6">
                <para>Inform all connected bidders that there is higher
                bid.</para>
              </callout>

              <callout arearefs="co.OneSale-one-bid.7">
                <para>Update the status of the auction master.</para>
              </callout>
            </calloutlist></para>
        </example></para>

      <para><example xml:id="example.OneSale-other-cases">
          <title>Process OneSale, handling other cases</title>

          <para><programlisting>( if not(Sold) then ... fi
+ if not(or(Final, Sold))  <co xml:id="co.OneSale-other.1" /> then
      snd-note(any-higher-bid) delay(sec(10)) .   <co
                xml:id="co.OneSale-other.2" />
      snd-do(Mid, any-higher-bid(10)) .
      Final := true                               <co
                xml:id="co.OneSale-other.3" />
  fi
+ if and(Final, not(Sold)) <co xml:id="co.OneSale-other.4" /> then
      snd-note(sold(HighestBid)) delay(sec(10)) . <co
                xml:id="co.OneSale-other.5" />
      Sold := true                                <co
                xml:id="co.OneSale-other.6" />
   fi
+ ConnectBidder(Mid, Bid?) .                      <co
                xml:id="co.OneSale-other.7" />
   snd-msg(Bid, new-item(Descr, HighestBid)) .    <co
                xml:id="co.OneSale-other.8" />
   Final := false                                 <co
                xml:id="co.OneSale-other.9" />
) * if Sold then ... fi</programlisting></para>

          <para>Notes:<calloutlist>
              <callout arearefs="co.OneSale-other.1">
                <para>The item is not yet sold, but we have not yet asked for
                a final bid.</para>
              </callout>

              <callout arearefs="co.OneSale-other.2">
                <para>Wait for 10 seconds and then ask for final bids.</para>
              </callout>

              <callout arearefs="co.OneSale-other.3">
                <para>Inform the auction master and remember that we asked for
                final bids.</para>
              </callout>

              <callout arearefs="co.OneSale-other.4">
                <para>The item is not yet sold but we have already asked for
                final bids.</para>
              </callout>

              <callout arearefs="co.OneSale-other.5">
                <para>Wait another 10 seconds and inform all bidders that the
                item has been sold.</para>
              </callout>

              <callout arearefs="co.OneSale-other.6">
                <para>Record that the item is sold.</para>
              </callout>

              <callout arearefs="co.OneSale-other.7">
                <para>During the sale a new bidder wants to connect.</para>
              </callout>

              <callout arearefs="co.OneSale-other.8">
                <para>Inform the new bidder about the progress of the
                auction.</para>
              </callout>

              <callout arearefs="co.OneSale-other.9">
                <para>Restart the bidding procedure; this overrules the call
                for final bids.</para>
              </callout>
            </calloutlist></para>
        </example></para>

      <para><example xml:id="example.Bidder">
          <title>Process <literal>Bidder</literal></title>

          <para><programlisting>process Bidder(Bid : bidder) is
  let Descr : str,  Amount : int,  Acceptance : term  
  in
     subscribe(new-item(&lt;str&gt;, &lt;int&gt;)) .         <co
                xml:id="co.Bidder.1" />
     subscribe(update-bid(&lt;int&gt;)) .
     subscribe(sold(&lt;int&gt;)) . 
     subscribe(any-higher-bid) .
     ( ( rec-msg(Bid, new-item(Descr?, Amount?)) <co xml:id="co.Bidder.2" />
         + rec-note(new-item(Descr?, Amount?))   <co xml:id="co.Bidder.3" />
         + rec-disconnect(Bid) <co xml:id="co.Bidder.4" />. delta
        ) .
       snd-do(Bid, new-item(Descr, Amount)) .    <co xml:id="co.Bidder.5" />
       ( rec-event(Bid, bid(Amount?)) .          <co xml:id="co.Bidder.6" />
         snd-msg(bid(Bid, Amount)) .             <co xml:id="co.Bidder.7" />
         rec-msg(Bid, Acceptance?) .
         snd-do(Bid, accept(Acceptance)) . 
         snd-ack-event(Bid, bid(Amount))
       )*
     + rec-note(update-bid(Amount?)) .           <co xml:id="co.Bidder.8" />
       snd-do(Bid, update-bid(Amount))
     + rec-note(any-higher-bid) . 
       snd-do(Bid, any-higher-bid)
     + rec-disconnect(Bid) . delta               <co xml:id="co.Bidder.9" />
     ) *
       rec-note(sold(Amount?)) .                 <co xml:id="co.Bidder.10" />
       snd-do(Bid, sold(Amount))
     )* delta
  endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.Bidder.1">
                <para>Subscribe to all relevant notes.</para>
              </callout>

              <callout arearefs="co.Bidder.2">
                <para>Get information about the current item for sale,
                directly after connecting.</para>
              </callout>

              <callout arearefs="co.Bidder.3">
                <para>Get information about the current item for sale during
                regular progress of the auction.</para>
              </callout>

              <callout arearefs="co.Bidder.4">
                <para>Disconnect between sales.</para>
              </callout>

              <callout arearefs="co.Bidder.5">
                <para>Inform the bidder tool by updating the information about
                the item for sale.</para>
              </callout>

              <callout arearefs="co.Bidder.6">
                <para>This bidder want to bid on the current item for
                sale.</para>
              </callout>

              <callout arearefs="co.Bidder.7">
                <para>Pass this bid on and await its acceptance. The result is
                returned to the bidder tool and the event is
                acknowledged.</para>
              </callout>

              <callout arearefs="co.Bidder.8">
                <para>Handle the informative notes about the update of the
                highest bid and the request for any higher bids.</para>
              </callout>

              <callout arearefs="co.Bidder.9">
                <para>Disconnect during a sale.</para>
              </callout>

              <callout arearefs="co.Bidder.10">
                <para>The item is sold.</para>
              </callout>
            </calloutlist></para>
        </example></para>
    </section>

    <section xml:id="section.example-wave">
      <title>Wave Example</title>

      <para>Have you ever considered a (guitar) string that is attached at
      both ends and wondered how the movements of the strings can be
      simulated? Although this is a completely atypical application of the
      ToolBus, it is fun to do so we will delve into the details.</para>

      <para>In mathematical physics, the vibrating string is described by the
      so-called one-dimensional wave equation that describes a discrete
      approximation of the continuous string. The discretization is achieved
      by sampling the amplitude of the string at certain points
      <replaceable>i</replaceable> = 1, ... <replaceable>N</replaceable>,
      where <replaceable>N</replaceable> is the number of points. The
      amplitude at point <replaceable>i</replaceable> at time
      <replaceable>t</replaceable> can now be described by
      y<subscript><replaceable>i</replaceable>+1</subscript>(<replaceable>t</replaceable>)
      (see also <xref linkend="figure.wave-graph" />) that is defined as
      follows:<equation>
          <mathphrase><replaceable>y</replaceable><subscript><replaceable>i</replaceable></subscript>(<replaceable>t</replaceable>+Δ<replaceable>t</replaceable>)
          =
          <replaceable>F</replaceable>(<replaceable>y</replaceable><subscript><replaceable>i</replaceable></subscript>(<replaceable>t</replaceable>),
          <replaceable>y</replaceable><subscript><replaceable>i</replaceable></subscript>(<replaceable>t</replaceable>-Δ<replaceable>t</replaceable>)
          ,
          <replaceable>y</replaceable><subscript><replaceable>i</replaceable>-1</subscript>(<replaceable>t</replaceable>),
          <replaceable>y</replaceable><subscript><replaceable>i</replaceable>+1</subscript>(<replaceable>t</replaceable>))</mathphrase>
        </equation>In other words, the amplitude at point
      <replaceable>i</replaceable> and time <replaceable>t</replaceable>
      depends on:</para>

      <itemizedlist>
        <listitem>
          <para>the current amplitude,</para>
        </listitem>

        <listitem>
          <para>the previous amplitude at this point,</para>
        </listitem>

        <listitem>
          <para>the current amplitude of the left neighbour, and</para>
        </listitem>

        <listitem>
          <para>the current amplitude of the right neighbour.</para>
        </listitem>
      </itemizedlist>

      <para>It also depends on the function <replaceable>F</replaceable>
      defined as follows:</para>

      <para><equation>
          <mathphrase><replaceable>F</replaceable>(<replaceable>z</replaceable><subscript>1</subscript>,<replaceable>z</replaceable><subscript>2</subscript>,<replaceable>z</replaceable><subscript>3</subscript>,<replaceable>z</replaceable><subscript>4</subscript>)
          = 2<replaceable>z</replaceable><subscript>1</subscript>-
          <replaceable>z</replaceable><subscript>2</subscript> + (c
          Δ<replaceable>t</replaceable>/Δ<replaceable>x)<superscript>2</superscript>
          (<replaceable>z</replaceable><subscript>3</subscript> -
          2<replaceable>z</replaceable><subscript>1</subscript>+
          <replaceable>z</replaceable><subscript>4</subscript>)</replaceable></mathphrase>
        </equation>where</para>

      <itemizedlist>
        <listitem>
          <para>Δ<replaceable>x</replaceable> is the (small) interval between
          sampling points, and</para>
        </listitem>

        <listitem>
          <para>c is a constant representing the propagation velocity of the
          wave.</para>
        </listitem>
      </itemizedlist>

      <para><figure xml:id="figure.wave-graph">
          <title>One-dimensional wave equation</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="wave-graph.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>After these preparations, we have to define the architecture of a
      ToolBus application that can simulate the behaviour of a string. The key
      idea is to use a separate ToolBus process to represent the behaviour of
      each sampling point. The architecture is shown in <xref
      linkend="figure.wave-architecture" /> and consists of the following
      processes and tools:</para>

      <itemizedlist>
        <listitem>
          <para>Process <literal>Pend</literal> models an end point of the
          string, see <xref linkend="example.Pend" /> .Two instances are used
          to model the left and right end point.</para>
        </listitem>

        <listitem>
          <para>Process <literal>P</literal> models one sampling point, see
          <xref linkend="example.P" />. <replaceable>N</replaceable>-1
          instances are used to model all intermediate points.</para>
        </listitem>

        <listitem>
          <para>The auxiliary process <literal>F</literal> computes the
          function <replaceable>F</replaceable> discussed above, see <xref
          linkend="example.F" />.</para>
        </listitem>

        <listitem>
          <para>Process <literal>makeWave</literal> constructs
          <replaceable>N</replaceable> connected instances of processes
          <literal>P</literal> and two end points <literal>Pend</literal>, see
          <xref linkend="example.MakeWave" />.</para>
        </listitem>

        <listitem>
          <para>The tool display visualizes the simulation.</para>
        </listitem>
      </itemizedlist>

      <para><figure xml:id="figure.wave-architecture">
          <title>Architecture of the wave example</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="wave-architecture.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>The global structure of the Tscript
      <literal>wave.tb</literal> is shown in <xref
      linkend="example.global-structure-wave.tb" />.<example
          xml:id="example.global-structure-wave.tb">
          <title>Global structure of <literal>wave.tb</literal></title>

          <para><programlisting>process MakeWave ... <lineannotation>See <xref
                  linkend="example.MakeWave" /></lineannotation>
process Pend ...     <lineannotation>See <xref linkend="example.Pend" /></lineannotation>
process P ...        <lineannotation>See <xref linkend="example.P" /></lineannotation>
process F ...        <lineannotation>See <xref linkend="example.F" /></lineannotation>

toolbus(MakeWave(...))</programlisting></para>
        </example><example xml:id="example.MakeWave">
          <title>Process <literal>MakeWave</literal></title>

          <para><programlisting>process MakeWave(N : int) is
  let Tid : display, Id : int, I : int, L : int, R : int
  in
     execute(display, Tid?) .       <co xml:id="co.MakeWave.1" />
     snd-do(Tid, mk-wave(N)) .
     create(Pend(Tid, 0, 1), Id?).  <co xml:id="co.MakeWave.2" />
     L := sub(N,1) .
     create(Pend(Tid, N, L), Id?) . 
     I := 1 .                       <co xml:id="co.MakeWave.3" />
     if less(I, N) then
        L := sub(I, 1) . R := add(I, 1) .
        create(P(Tid, L, I, R, 1.0, 1.0), Id?) .
        I := add(I, 1)
     fi *
     shutdown("end") delay(sec(60)) <co xml:id="co.MakeWave.4" />
  endlet

tool display is { command = "wish-adapter -script ui-wave.tcl"}</programlisting>Notes:<calloutlist>
              <callout arearefs="co.MakeWave.1">
                <para>Execute the display tool and initialize it to show
                <replaceable>N</replaceable> points. <xref
                linkend="figure.wave-gui" /> shows the display tool in action
                during a later stage of the simulation.</para>
              </callout>

              <callout arearefs="co.MakeWave.2">
                <para>Create the two end points with index 0 and
                <replaceable>N</replaceable>.</para>
              </callout>

              <callout arearefs="co.MakeWave.3">
                <para>Create the intermediate points 1,...,
                <replaceable>N</replaceable>-1 in a loop.</para>
              </callout>

              <callout arearefs="co.MakeWave.4">
                <para>Run the demo for one minute.</para>
              </callout>
            </calloutlist></para>
        </example><figure xml:id="figure.wave-gui">
          <title>User-interface of wave demo</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="wave-ui.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure><example>
          <title>ToolBus configuration for wave</title>

          <para><programlisting>toolbus(MakeWave(8))</programlisting></para>
        </example><example xml:id="example.Pend">
          <title>Process <literal>Pend</literal></title>

          <para><programlisting>process Pend(Tid : display, I <co
                xml:id="co.Pend.1" />: int, NB <co xml:id="co.Pend.2" />: int) is
  let W : real
  in
   ( rec-msg(NB, I, W?) || snd-msg(I, NB, 0.0) || <co xml:id="co.Pend.3" />
     snd-do(Tid, update(I, 0.0))                  <co xml:id="co.Pend.4" />
   ) * delta
  endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.Pend.1">
                <para><literal>I</literal> is the index of this end
                point.</para>
              </callout>

              <callout arearefs="co.Pend.2">
                <para><literal>NB</literal> is the index of the neighbouring
                point.</para>
              </callout>

              <callout arearefs="co.Pend.3">
                <para>Receive the amplitude of the neighbour and send our own
                zero amplitude to the neighbour. Since a parallel operator
                <literal>||</literal> is used, these communications can appear
                in any order.</para>
              </callout>

              <callout arearefs="co.Pend.4">
                <para>Display the zero amplitude of this end point on the
                display.</para>
              </callout>
            </calloutlist></para>
        </example><example xml:id="example.P">
          <title>Process <literal>P</literal></title>

          <para><programlisting>process P(Tid : display, <co xml:id="co.P.1" />
          L : int,       <co xml:id="co.P.2" />
          I : int,       <co xml:id="co.P.3" />
          R : int,       <co xml:id="co.P.4" />
          Dstart : real, <co xml:id="co.P.5" />
          Estart : real  <co xml:id="co.P.6" />
         ) is
  let AL : real, AR : real, D : real, D1 : real, E : real
  in
     D := Dstart . E := Estart .
     ( (  rec-msg(L, I, AL?)        <co xml:id="co.P.7" />
       || rec-msg(R, I, AR?) 
       || snd-msg(I, L, E)          <co xml:id="co.P.8" />
       || snd-msg(I, R, E) 
       || snd-do(Tid, update(I, E)) <co xml:id="co.P.9" />
       ) .
       D1 := E .
       F(E, D, AL, AR, E?) .        <co xml:id="co.P.10" />
       D := D1
     ) * delta
  endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.P.1">
                <para><literal>Tid</literal> is the tool identifier of the
                display tool.</para>
              </callout>

              <callout arearefs="co.P.2">
                <para><literal>L</literal> is the index of the left neighbour
                of this point.</para>
              </callout>

              <callout arearefs="co.P.3">
                <para><literal>I</literal> is the index of this point.</para>
              </callout>

              <callout arearefs="co.P.4">
                <para><literal>R</literal> is the index of the right neighbour
                of this point.</para>
              </callout>

              <callout arearefs="co.P.5">
                <para><literal>Dstart</literal> is the previous amplitude of
                this point.</para>
              </callout>

              <callout arearefs="co.P.6">
                <para><literal>Estart</literal> is the current amplitude of
                this point.</para>
              </callout>

              <callout arearefs="co.P.7">
                <para>Receive amplitudes from our neighbours.</para>
              </callout>

              <callout arearefs="co.P.8">
                <para>Send our own amplitude to our neighbours.</para>
              </callout>

              <callout arearefs="co.P.9">
                <para>Show current amplitude on the display.</para>
              </callout>

              <callout arearefs="co.P.10">
                <para>Compute a new value for our amplitude by applying
                <literal>F</literal>.</para>
              </callout>
            </calloutlist></para>
        </example></para>

      <para></para>

      <para><example xml:id="example.F">
          <title>Auxiliary process <literal>F</literal></title>

          <para><programlisting>process F(Z1 : real, Z2 : real, Z3 : real, Z4 : real, Res : real?) is
  let CdTdX2 : real
  in <co xml:id="co.F.1" />
     CdTdX2 := 0.01 . <co xml:id="co.F.2" />                               
     Res := radd(rsub(rmul(2.0, Z1), Z2), <co xml:id="co.F.3" />
                 rmul(CdTdX2, <co xml:id="co.F.4" />
                     radd(rsub(Z3, rmul(2.0, Z1)), Z4))) <co xml:id="co.F.5" />
  endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.F.1">
                <para>Recall that we are computing
                2<replaceable>z</replaceable><subscript>1</subscript>-
                <replaceable>z</replaceable><subscript>2</subscript> + (c
                Δ<replaceable>t</replaceable>/Δ<replaceable>x</replaceable>)<superscript>2</superscript>
                (z<subscript>3</subscript> -
                2<replaceable><replaceable>z</replaceable></replaceable><subscript>1</subscript>+
                <replaceable><replaceable>z</replaceable></replaceable><subscript>4</subscript>)
                and that the main challenge is to write this formula in prefix
                form.</para>
              </callout>

              <callout arearefs="co.F.2">
                <para>Take an arbitrary (small) value for (c
                Δ<replaceable>t</replaceable>/Δ<replaceable>x)<superscript>2</superscript>.</replaceable></para>
              </callout>

              <callout arearefs="co.F.3">
                <para>2<replaceable>z</replaceable><subscript>1</subscript>-
                <replaceable>z</replaceable><subscript>2</subscript>
                +...</para>
              </callout>

              <callout arearefs="co.F.4">
                <para>(c
                Δ<replaceable>t</replaceable>/Δ<replaceable>x)<superscript>2</superscript></replaceable>
                * ...</para>
              </callout>

              <callout arearefs="co.F.5">
                <para><replaceable>... +
                (<replaceable>z</replaceable><subscript>3</subscript> -
                2<replaceable>z</replaceable><subscript>1</subscript>+
                <replaceable>z</replaceable><subscript>4</subscript>)</replaceable></para>
              </callout>
            </calloutlist></para>
        </example></para>
    </section>
  </section>

  <section xml:id="section.executing-toolbus-and-tools">
    <title>Executing ToolBus and tools</title>

    <para>The ToolBus interpreter (<command>ToolBus</command>) and all tools
    have some standard program arguments in common, but they have some
    specific arguments as well. In this section we describe all possible
    program arguments and the way to execute <command>ToolBus</command> and
    tools.</para>

    <section xml:id="section.common-arguments">
      <title>Common arguments</title>

      <para>ToolBus and tools have the following optional arguments in
      common:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-help</literal>: prints a description of all
          arguments of the ToolBus or tool.</para>
        </listitem>

        <listitem>
          <para><literal>-P<replaceable>port_name</replaceable></literal>:
          defines the "well known socket" <replaceable>port_name</replaceable>
          to which all tools temporarily connect in order to set up their own
          private socket that connects them permanently to the ToolBus
          interpreter. When omitted, socket 8998 will be used.<warning>
              <para>Not yet implemented.</para>
            </warning></para>
        </listitem>
      </itemizedlist>

      <para>Note that explicit arguments defining the sockets are
      <emphasis>only</emphasis> needed when several ToolBus interpreters are
      running simultaneously on the <emphasis>same</emphasis> host
      machine.</para>
    </section>

    <section xml:id="section.toolbus-arguments">
      <title>ToolBus arguments</title>

      <para>The <replaceable>script_name</replaceable> (see below) given as
      argument to the ToolBus is always preprocessed by a preprocessor before
      it is parsed as a Tscript. In this way, directives like, e.g.,
      <literal>#define</literal>, <literal>#include</literal> and
      <literal>#ifdef</literal> can be used freely in Tscripts. The following
      preprocessor arguments are accepted by the <command>ToolBus</command>
      command:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-I<replaceable>dir</replaceable></literal>: append
          directory <literal><replaceable>dir</replaceable></literal> to the
          list of directories searched for include files.</para>
        </listitem>

        <listitem>
          <para><literal>-D<replaceable>name</replaceable></literal>: defines
          <literal><replaceable>name</replaceable></literal> with the string
          <literal>"1" </literal>as its definition.</para>
        </listitem>

        <listitem>
          <para><literal>D<replaceable>name</replaceable>=<replaceable>defn</replaceable></literal>:
          defines <literal><replaceable>name</replaceable></literal> with
          <literal><replaceable>defn</replaceable></literal> as
          definition.</para>
        </listitem>
      </itemizedlist>

      <para>Other arguments specific for the ToolBus command are:</para>

      <warning>
        <para>The following arguments will probably be supported differently
        in ToolBusNG.</para>
      </warning>

      <itemizedlist>
        <listitem>
          <para><literal>-viewer</literal>: execute the ToolBus viewer that
          enables step-by-step execution and inspection of the state of each
          process state.</para>
        </listitem>

        <listitem>
          <para><literal>-gentifs</literal>: only generate tool interfaces for
          all tools used in the script in a language independent format. For a
          script file named <filename>script.tb</filename> the tool interfaces
          are written to <filename>script.tifs</filename>. Do not execute the
          script.<warning>
              <para>Not yet implemented.</para>
            </warning></para>
        </listitem>

        <listitem>
          <para><literal>-fixed-seed</literal>: use a fixed seed for the
          random generator used by the interpreter for scheduling processes
          and selecting alternatives in processes. By default, the random
          generator is initialized with the current time the
          <command>ToolBus</command> command is given. Using the
          <literal>-fixed-seed</literal> option makes the execution of the
          script reproducible across multiple runs of the
          <command>ToolBus</command> command.<warning>
              <para>Not yet implemented.</para>
            </warning></para>
        </listitem>

        <listitem>
          <para><literal>-S<replaceable>script_name</replaceable></literal>:
          any other argument is the name of the ToolBus script to be
          interpreted.</para>
        </listitem>
      </itemizedlist>

      <para>As an example, consider first <programlisting>toolbus -Shello.tb</programlisting>which
      starts interpreting the script <filename>hello.tb</filename>. Next,
      consider <programlisting>toolbus -Imy-include-dir -DCNT=33 -Swave.tb</programlisting>which
      searches the directory <filename>my-include-dir</filename> for files
      used in <literal>#include</literal> directives in the script
      <filename>wave.tb</filename> and it will define the name
      <literal>CNT</literal> with value <literal>33</literal>. All occurrences
      of <literal>CNT</literal> in the script will be replaced by this value
      before parsing it as a Tscript. Finally, <programlisting>toolbus -gentifs -Shello.tb </programlisting>produces
      the tool interfaces file <filename>hello.tifs</filename>.</para>
    </section>

    <section xml:id="section.tool-arguments">
      <title>Tool arguments</title>

      <para><warning>
          <para>This section needs some work.</para>
        </warning>Arguments specific for tools are:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-TB_HOST
          <replaceable>host_name</replaceable></literal>: defines the host
          machine <literal><replaceable>host_name</replaceable></literal> on
          which the ToolBus interpreter is running and to which the tool
          should be connected. When omitted, the ToolBus interpreter should be
          running on the same host as the tool.</para>
        </listitem>

        <listitem>
          <para><literal>-TB_TOOL_NAME tool_name</literal>: the tool name as
          defined in the Tscript (added automatically, when a tool is executed
          by the ToolBus).</para>
        </listitem>

        <listitem>
          <para><literal>-TB_TOOL_ID <replaceable>Id</replaceable></literal>:
          internal tool identifier of this tool execution (added
          automatically, when a tool is executed by the ToolBus).</para>
        </listitem>
      </itemizedlist>

      <para>The execution of a tool can start in two ways:</para>

      <itemizedlist>
        <listitem>
          <para>The tool is started by an <literal>execute</literal> command
          in the Tscript.</para>
        </listitem>

        <listitem>
          <para>The initiative to execute the tool is taken outside the
          ToolBus. This requires that the script contains a
          <literal>rec-connect</literal> for this particular tool.</para>
        </listitem>
      </itemizedlist>

      <para>When ToolBus and tool are running on different host machines, it
      is important to define the host machine on which the ToolBus interpreter
      is running when starting the execution of the tool. As an example,
      consider the <command>hello</command> application described in <xref
      linkend="example.hello2" />. The <command>hello</command> tool will be
      executed by the ToolBus using the command <programlisting>hello -P8998 -TB_HOST host1.institute.nl</programlisting>when
      running on machine <literal>host1.institute.nl</literal>. Suppose, we
      replace the explicit <literal>execute</literal> in <xref
      linkend="example.hello2" /> by a <literal>rec-connect</literal> as shown
      in Figure~\ref{fig:hello3.tb}. We may then manually start the
      <command>hello</command> tool by typing <programlisting>hello</programlisting>where
      we use the default values for the input/output sockets and assume that
      tool and ToolBus interpreter are both running on the same host (i.e.,
      <literal>host1.institute.nl</literal>). Starting the execution from
      <emphasis>another</emphasis> host is achieved by typing (on, say,
      <literal>host2.institute.nl</literal>): <programlisting>hello -TB_HOST host1.institute.nl </programlisting></para>
    </section>
  </section>

  <section xml:id="section.toolbus-tools">
    <title>ToolBus tools</title>

    <para>There are some general issues to understand about ToolBus tools and
    we cover them here. First, the global structure of a tool is explained in
    <xref linkend="section.global-structure-tool" />. Next, we describe how
    tool adapters work in <xref linkend="section.tool-adapters" />. Finally,
    we cover in <xref linkend="section.generating-tool-interfaces" /> the
    automatic generation of tool interfaces that is needed for some tool
    implementation languages .</para>

    <section xml:id="section.global-structure-tool">
      <title>The global structure of a ToolBus tool</title>

      <para><figure xml:id="figure-tool-organization">
          <title>Global tool organization</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="tool-organization.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>In its simplest form, a tool is a box connected via an input and
      an output port to a ToolBus. In the most general case, a tool has</para>

      <itemizedlist>
        <listitem>
          <para>one input port from the ToolBus to the tool and can receive
          tree structures (terms) via this port;</para>
        </listitem>

        <listitem>
          <para>one output port from the tool to the ToolBus and can send
          terms to the ToolBus via this port;</para>
        </listitem>

        <listitem>
          <para>zero or more <emphasis>term ports</emphasis> to receive terms
          from other sources;</para>
        </listitem>

        <listitem>
          <para>zero or more <emphasis>character ports</emphasis> to receive
          character data from other sources.</para>
        </listitem>
      </itemizedlist>

      <para>This global, architectural, structure of a tool is shown in <xref
      linkend="figure-tool-organization" />. With each input port, an
      <emphasis>event handler</emphasis> is associated that takes care of the
      processing of the data received via that port and is responsible for
      returning a result (if any). One tool may thus contain several event
      handlers. When a request is received, the following steps are
      taken:</para>

      <itemizedlist>
        <listitem>
          <para>The data received are parsed to check that they form a legal
          ToolBus term <replaceable>T</replaceable>. (If this is impossible, a
          warning message is generated).</para>
        </listitem>

        <listitem>
          <para>The event handler is called with <replaceable>T</replaceable>
          as argument.</para>
        </listitem>

        <listitem>
          <para>The event handler can do arbitrary processing needed to
          decompose <replaceable>T</replaceable>, to determine what has to be
          done, and perform any desired computation.</para>
        </listitem>

        <listitem>
          <para>The event handler returns either:</para>

          <itemizedlist>
            <listitem>
              <para>a legal ToolBus term representing a reply to be sent back
              to the ToolBus.</para>
            </listitem>

            <listitem>
              <para><literal>NULL</literal> indicating that there is no
              reply.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>The global mode of operation of a tool is now:</para>

      <itemizedlist>
        <listitem>
          <para>receive data on any input port and respond to this by sending
          some term (or <literal>NULL</literal>) to the ToolBus; or</para>
        </listitem>

        <listitem>
          <para>take the initiative to send a term to the ToolBus (typically
          to inform the ToolBus about some external event).</para>
        </listitem>
      </itemizedlist>

      <para>A tool is thus on the one hand a reactive engine that responds to
      a request from the ToolBus and returns the result back to the ToolBus in
      the form of a term (e.g., calculate the value of some expression), but
      on the other hand it can also take the initiative to send a term to the
      ToolBus (e.g., generate an event when a user pushes some button).</para>
    </section>

    <section xml:id="section.tool-adapters">
      <title>Adapters for tools and languages</title>

      <figure xml:id="figure.organization-tool-adapter">
        <title>Two organizations of a tool adapter</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="tool-adapter.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The main purpose of adapters is to act as small
      <emphasis>wrappers</emphasis> around existing programs or programming
      languages in order to transform them into tools that can be connected to
      the ToolBus. There exist two global strategies for constructing
      adapters:</para>

      <itemizedlist>
        <listitem>
          <para>The adapter and the program to be adapted are executed as
          separate (Unix) processes. This structure is sketched in <xref
          linkend="figure.organization-tool-adapter" />. The advantage of this
          approach is that no access is needed to the source code of the
          program: it can remain a black box. Another advantage is that
          adapters may be reused for the adaptation of different programs. A
          possible disadvantage is some loss in efficiency.</para>

          <para>In this category a further subdivision is possible:</para>

          <itemizedlist>
            <listitem>
              <para>The program is executed once as a child process of the
              adapter and all
              <literal>snd-eval</literal>/<literal>snd-do</literal> requests
              are directed to this child process. The program can thus
              maintain an internal state between requests.</para>
            </listitem>

            <listitem>
              <para>The same program is executed as a child process of the
              adapter for each
              <literal>snd-eval</literal>/<literal>snd-do</literal>
              request.</para>
            </listitem>

            <listitem>
              <para>A different program is executed as a child process of the
              adapter for each
              <literal>snd-eval</literal>/<literal>snd-do</literal>
              request.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Integrate the adapter and the software to be adapted into a
          single (Unix) process. This approach permits the most detailed
          adaptation of the program and is also the most efficient solution.
          This approach leads, however, to potentially less reusable adapters
          than the previous approach.</para>
        </listitem>
      </itemizedlist>

      <para>In order to achieve some uniformity, the current collection of
      adapters have the following optional program arguments in common:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-cmd</literal>: the (default) program to be executed
          by the adapter. All arguments of the adapter that follow
          <literal>-cmd</literal> are interpreted as the name and arguments of
          the program to be executed.</para>
        </listitem>

        <listitem>
          <para>All tool arguments, see <xref
          linkend="section.tool-arguments" />.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.generating-tool-interfaces">
      <title>Automatic generation of tool interfaces</title>

      <para><figure xml:id="figure.tifs">
          <title>Automatic generation of tool interfaces</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="tifs.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>The interface code for each tool depends on the particulars
      of the Tscript in which it is used. Changing the number of arguments in
      an evaluation request to the tool, or adding a new request, requires
      making changes to the interface code that are easily forgotten and
      therefore error prone. Another observation is that the interface code
      for different tools has a lot in common. An obvious solution to both
      problems is to <emphasis>generate</emphasis> tool interfaces
      automatically, given a Tscript. This generation process is shown in
      <xref linkend="figure.tifs" /> and consists of two steps:</para>

      <itemizedlist>
        <listitem>
          <para>Generate a language-independent description of all tool
          interfaces used in the script. This amounts to a static analysis of
          all tool communication in the script. It is achieved by using the
          <literal>-gentifs</literal> option of the ToolBus interpreter. For
          instance, <programlisting>toolbus -gentifs hello2.tb</programlisting>
          will create a file <filename>hello2.tifs</filename> containing the
          tool interfaces.</para>
        </listitem>

        <listitem>
          <para>Use the language independent interface description to generate
          a tool interface for a specific tool in a specific implementation
          language. The generator <command>tifstoc</command> exists for
          generating C tool interfaces. It is called as follows:
          <programlisting>tifstoc -tool <replaceable>Name</replaceable> <replaceable>TifsFile</replaceable></programlisting>and
          generates a file named
          <literal><replaceable>Name</replaceable>.tif.c</literal>. For the
          hello example, we would have, for instance: <programlisting>tifstoc -tool hello hello2.tifs</programlisting>
          The resulting file <filename>hello.tif.c</filename> is shown in
          <xref linkend="example.hello.tif.c" />.</para>
        </listitem>
      </itemizedlist>

      <para>In <xref linkend="figure.tifs" /> it is also shown how tool
      interface generators for <emphasis>other</emphasis> languages (e.g.,
      Java, Cobol) fit into this scheme. In addition to
      <command>tifstoc</command>, we used to support the generation of Java
      interfaces by way of <command>tifstojava</command>. In the current
      ToolBus implementation, this is no longer necessary, see <xref
      linkend="section.Java-tools" />.</para>
    </section>
  </section>

  <section xml:id="section.C-tools">
    <title>Writing ToolBus tools in C</title>

    <para>Although ToolBus tools can be implemented in many languages
    (including Java, C++, Tcl/Tk, ASF+SDF, and others) we start explaining how
    tools can be written in C. In other languages identical notions will be
    used with only minor adjustments to language-specific features and
    limitations. Writing tools in C amounts to:</para>

    <itemizedlist>
      <listitem>
        <para>ATerms: the essential data type that is used to exchange
        information between tool and TB <note>
            <para>Add ref to ATerms</para>
          </note></para>
      </listitem>

      <listitem>
        <para>The global structure of a ToolBus tool, see <xref
        linkend="section.global-structure-tool" />.</para>
      </listitem>

      <listitem>
        <para>The ToolBus Application Programmer's Interface , see <xref
        linkend="section.toolbus-API" />.</para>
      </listitem>

      <listitem>
        <para>Compiling ToolBus tools written in C, <xref
        linkend="section.compiling-C-tools" />.</para>
      </listitem>

      <listitem>
        <para>Generating tool interfaces with {\tt tifstoc}, <xref
        linkend="section.generating-tool-interfaces" />.</para>
      </listitem>
    </itemizedlist>

    <section xml:id="section.atb-tool.h">
      <title>The include file <literal>atb-tool.h</literal></title>

      <para>Each tool needs to include the file <literal>atb-tool.h</literal>
      which defines some basic types as well as the set of library functions
      available. It consists of</para>

      <itemizedlist>
        <listitem>
          <para>An include of <literal>&lt;aterm1.h&gt;</literal>.</para>
        </listitem>

        <listitem>
          <para>Defines <literal>ATBhandler</literal>: the type of event
          handlers.</para>
        </listitem>

        <listitem>
          <para>Defines the prototypes of all library functions</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.libATB.h">
      <title>The tool library <literal>libATB.a</literal></title>

      <para>When compiling tools, the library <literal>libATB.a</literal> must
      be specified in order to make the tool library available (using the
      -<literal>lATB</literal> option of the C compiler). It provides the
      following functions:</para>

      <itemizedlist>
        <listitem>
          <para><literal>ATBinit</literal>: tool initialization, see <xref
          linkend="section.ATBinit" />.</para>
        </listitem>

        <listitem>
          <para><literal>ATBconnect</literal>: to connect the tool to the
          ToolBus, <xref linkend="section.ATBconnect" />.</para>
        </listitem>

        <listitem>
          <para><literal>ATBdisconnect</literal>: to disconnect the tool from
          the ToolBus, <xref linkend="section.ATBconnect" />.</para>
        </listitem>

        <listitem>
          <para><literal>ATBeventloop</literal>: a standard event loop for a
          tool, see <xref linkend="section.ATBeventloop" />.</para>
        </listitem>

        <listitem>
          <para><literal>ATB</literal>postEvent send an event to the ToolBus,
          see <xref linkend="section.ATBpostEvent" />.</para>
        </listitem>
      </itemizedlist>

      <para>In the following section, we will describe these functions.</para>
    </section>

    <section xml:id="section.toolbus-API">
      <title>The ToolBus API</title>

      <para>During the initialization of each tool, some preparations have to
      made before the tool can be properly connected to the ToolBus. These
      preparations include</para>

      <itemizedlist>
        <listitem>
          <para>Defining the <emphasis>name</emphasis> of the tool as it is
          known from a tool declaration in a Tscript.</para>
        </listitem>

        <listitem>
          <para>Parsing standard program arguments that are passed to the tool
          when it is started.</para>
        </listitem>

        <listitem>
          <para>Creating a pair of socket connections with a ToolBus
          interpreter.</para>
        </listitem>

        <listitem>
          <para>Starting an event loop.</para>
        </listitem>
      </itemizedlist>

      <para>During execution of the event loop, the tool can either
      <emphasis>receive</emphasis> terms from the ToolBus or it can take the
      initiative to <emphasis>send</emphasis> terms to the ToolBus. It is thus
      possible for a tool to both respond to ToolBus requests and
      <emphasis>asynchronously</emphasis> send terms to the ToolBus.</para>

      <section xml:id="section.ATBinit">
        <title><literal>ATBinit</literal></title>

        <para>The initialization of the ToolBus API is achieved
        by<programlisting>int ATBinit(int <replaceable>argc</replaceable>, char *<replaceable>argv</replaceable>[], ATerm *<replaceable>bottomOfStack</replaceable>).</programlisting></para>

        <para>This initializes the ToolBus API as well as the ATerm library
        that is used by it.</para>

        <para>The standard program arguments that are passed (via
        <replaceable>argc</replaceable> and <replaceable>argv</replaceable>)
        are fully described in <xref
        linkend="section.executing-toolbus-and-tools" />. Particularly
        important is that the tool is initialized with a proper name. It
        should be literally equal (including the case of letters) to a tool
        name as appearing in a tool declaration in the Tscript. This is
        important since the tool name will be used when the tool is connected
        to the ToolBus. Note that <literal>ATBinit</literal> also initializes
        the ATerm library (hence the <replaceable>bottomOfStack</replaceable>
        argument, see <note>
            <para>Ref to Section \ref{ATinit}) in ATerm manual.</para>
          </note></para>

        <para>The return value indicates whether or not the ToolBus host could
        be found: 0 indicates that all is well, and -1 indicates an error, in
        which case the standard variable <literal>errno</literal> of the C
        run-time system is set to indicate which error.</para>
      </section>

      <section xml:id="section.ATBconnect">
        <title><literal>ATBconnect</literal></title>

        <para>A tool can be connected to the ToolBus using <replaceable>term
        ports</replaceable> that can be using for sending and receiving data
        in the form of complete terms. Two aspects of term ports are
        important: the input channel used for the actual data transfer and the
        <emphasis>handler</emphasis> that takes care of processing input terms
        when they arrive. The connection is established as
        follows:<programlisting>int ATBconnect(char *<replaceable>toolname</replaceable>, char *<replaceable>host</replaceable>, 
               int <replaceable>port</replaceable>, ATBhandler <replaceable>h</replaceable>);</programlisting>Here,
        <replaceable>toolname</replaceable> is the tool name to be used,
        <replaceable>host</replaceable> is the machine where the ToolBus is
        executing, <replaceable>port</replaceable> is the file descriptor of
        the channel to be used, and <replaceable>h</replaceable> is the
        handler to associated with this connection. If value
        <literal>NULL</literal> is passed as
        <replaceable>toolname</replaceable> or
        <replaceable>host</replaceable>, default values are used that are
        taken from <replaceable>argv</replaceable> that was passed to
        <literal>ATBinit</literal>. The same is true when
        <literal>-1</literal> is passed as value for
        <replaceable>port</replaceable>. The return value of
        <literal>ATBconnect</literal> is either <literal>-1</literal>
        (failure) or a positive number (the connection succeeded and the
        result is the file descriptor of the resulting socket connection with
        the ToolBus). Handlers for term ports are functions from ATerm to
        ATerm and have the type:<programlisting>ATerm some_handler(int <replaceable>conn</replaceable>, ATerm <replaceable>input</replaceable>)</programlisting>The
        argument <replaceable>conn</replaceable> is the connection along which
        the input term was received and <replaceable>input</replaceable> is
        the actual term received. The term returned by the handler is the
        reply to be sent to the ToolBus in response to this input event, or
        <literal>NULL</literal> if no reply is needed. In this fashion, an
        arbitrary number of term input ports can be set up which will be read
        in parallel: as soon as a term arrives at one of the ports the
        associated handler is activated. A connection can be terminated as
        follows:<programlisting>void ATBdisconnect(int <replaceable>conn</replaceable>)</programlisting>where
        <replaceable>conn</replaceable> is a connection that has been created
        earlier using <literal>ATBconnect</literal>.</para>
      </section>

      <section xml:id="section.ATBeventloop">
        <title>ATBeventloop</title>

        <para>Many tools first establish a number of term ports and then enter
        an infinite loop that processes input events. The
        function<programlisting>int ATBeventloop(void)</programlisting>captures
        this idea. It never returns, unless something goes wrong. We can now
        give a skeleton that many tools have in common:<programlisting>#include "my_tool.tif.c"

ATerm my_tool_handler(int conn, ATerm input)
{ ... handle input and return a term or NULL ...  }

int main(int argc, char *argv[]) 
{ ATerm bottomOfStack;

  ATBinit(argc, argv, &amp;bottomOfStack);
  if(ATBconnect(NULL, NULL, -1,  my_tool_handler) &gt;= 0)
  {
     ATBeventloop();
  } else 
     fprintf(stderr, 
             "my_tool: Could not connect to the ToolBus, giving up!\n");
  ATBeventloop();
  return 0; 
}</programlisting></para>
      </section>

      <section xml:id="section.ATBpostEvent">
        <title><literal>ATB</literal>postEvent</title>

        <para>So far, we have seen primitives for tools that only receive
        terms from the ToolBus. In the case of events that are generated by a
        tool, a term needs to be sent from the tool to the ToolBus. This can
        be achieved using<programlisting>int ATBpostEvent(int <replaceable>conn</replaceable>, ATerm <replaceable>term</replaceable>)</programlisting>which
        sends <replaceable>term</replaceable> along the port
        <replaceable>conn</replaceable>. Failure is indicated by the return
        value <literal>-1</literal>. A typical usage is:<programlisting>ATBpostEvent(conn, ATmake(button("ok"))).</programlisting></para>
      </section>

      <section xml:id="section.advanced-control-flow">
        <title>Primitives for advanced control flow</title>

        <para>Tool programming amounts, in essence, to event driven
        programming: most of the time a tool is awaiting the arrival of data
        on one of its ports and when the data are there, a reply is sent to
        the ToolBus by the handler associated with that port. In
        computation-intensive tools, the need may arise to check for the
        availability of incoming data from the ToolBus during computations. In
        those cases, ATBeventloop may not offer enough flexibility. More
        customized control flow can be achieved using the following functions.
        Observe that these function are parameterized with a specific ToolBus
        connection (as returned by <literal>ATBconnect</literal>) and can be
        used to handle situations where a single tool is connected with
        <emphasis>more than one</emphasis> ToolBus.</para>

        <para>Checking if there is input awaiting on a ToolBus connection is
        done by:</para>

        <para><programlisting>ATbool ATBpeekOne(int <replaceable>conn</replaceable>)</programlisting>This
        function returns <literal>ATtrue</literal> if incoming data from a
        ToolBus are available on the connection
        <replaceable>conn</replaceable>.</para>

        <para>Similarly, the availability of data on <emphasis>any</emphasis>
        connection may be checked by:<programlisting>int ATBpeekAny(void)</programlisting>If
        input is waiting, the appropriate connection is returned. Otherwise
        <literal>-1</literal> is returned. The sequence of activities needed
        for handling (once) the data available from a specific connection is
        captured by the function<programlisting>void ATBhandleOne(int <replaceable>conn</replaceable>)</programlisting>This
        amounts to calling the handler associated with connection
        <replaceable>conn</replaceable> with the available data as input term.
        Similarly, the data from <emphasis>any</emphasis> connection is
        handled by<programlisting>int ATBhandleAny(void)</programlisting></para>

        <para>which returns -1 if anything goes wrong.</para>

        <para>Finally, the function</para>

        <para><programlisting>int ATBgetDescriptors(fd_set *set)</programlisting></para>

        <para>Gathers all ToolBus connection file descriptors in a single
        descriptor set. The return value indicates the maximum value of any
        descriptor in the set.</para>
      </section>

      <section xml:id="section.control-flow-patterns">
        <title>Control flow patterns</title>

        <para>Given, the control flow primitives in the previous section, we
        can express various common control flow patterns.</para>

        <para>The function <literal>ATBeventloop</literal> can be expressed
        with the primitives just introduced:<programlisting>int ATBeventloop(void)
{ int conn;
  while(ATtrue)
  {
    n  = ATBhandleAny();
    if(n &lt; 0)
      return -1;
  }
}</programlisting>Another style mixes the handling of input from the ToolBus,
        with other computations: <programlisting>   while(ATtrue)
   { 
     if(n = ATBpeekAny() &gt;= 0) /* if there is an incoming event */
        ATBhandleOne(n);       /* handle it                     */
     else {
        ...                    /* perform other computation     */
     }
   }</programlisting>In some tools, a mixture of passively awaiting input and
        actively sending terms to the ToolBus can be seen. Using
        <literal>ATBwriteTerm</literal>, the most general global event loop of
        a tool becomes: <programlisting> while(ATtrue)
 {
 ... ATBwriteTerm(c1,e1); ...; ATBwriteTerm(cn,en); ...
   ATBhandleAny();
 }</programlisting>In other words, each iteration starts by sending zero or
        more terms to the ToolBus (using <literal>ATBwriteTerm</literal>) and
        ends with processing one event coming from some port (using
        <literal>ATBhandleAny</literal>). The Tscript being used should, of
        course, be able to receive such events.</para>
      </section>
    </section>

    <section xml:id="section.compiling-C-tools">
      <title>Compiling ToolBus tools written in C</title>

      <para>When compiling a tool written in C the following questions should
      be answered:</para>

      <itemizedlist>
        <listitem>
          <para>Where is the include file <literal>aterm1.h</literal> (or
          <literal>aterm2.h</literal> if you use the more sophisticated parts
          of the ATerm library)?</para>
        </listitem>

        <listitem>
          <para>Where is the include file
          <literal>atb-tool.h</literal>?</para>
        </listitem>

        <listitem>
          <para>Where is the ATerm library
          <literal>libATerm.a</literal>?</para>
        </listitem>

        <listitem>
          <para>Where is the ToolBus API library
          <literal>libATB.a</literal>?</para>
        </listitem>

        <listitem>
          <para>Which other libraries are needed to compile the tool?</para>
        </listitem>
      </itemizedlist>

      <para>The answers to these questions are clearly system dependent. There
      are two strategies to answer them. Strategy 1: find the desired
      locations on your system and hard code them in the compilation command.
      This will lead to a call to the C compiler with the following
      arguments:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-I<replaceable>dir-where-aterm1.h-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>-I<replaceable>dir-where-ATB-tool.h-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>hello.c -o hello</literal></para>
        </listitem>

        <listitem>
          <para><literal>-L<replaceable>dir-where-libATerm.a-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>-lATerm</literal></para>
        </listitem>

        <listitem>
          <para><literal>-L<replaceable>dir-where-libATB.a-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>-lATB</literal></para>
        </listitem>

        <listitem>
          <para>other libraries.</para>
        </listitem>
      </itemizedlist>

      <para>Strategy 2: write a make file that encodes this information. As a
      result, the location information is hardwired in the make file rather
      than in a command that has to be repeated over and over again.</para>
    </section>

    <section xml:id="section.automatic-generation-C-tool-interfaces">
      <title>Automatic generation of C tool interfaces</title>

      <para>As already explained in <xref
      linkend="section.generating-tool-interfaces" /> tool interfaces can be
      generated from a given Tscript for a given tool name. The ToolBus can
      generate a language-independent <literal>.tifs</literal> file, when it
      is started with the <literal>-gentifs</literal> option. In the case of
      C, the command <command>tifstoc</command> generates a tool interface in
      C for use with the ATerm library. The generated interface consists of
      two files:</para>

      <itemizedlist>
        <listitem>
          <para>a C source file (<filename>hello2.tif.c</filename> in the
          example below), and</para>
        </listitem>

        <listitem>
          <para>a C header file (<filename>hello2.tif.h</filename> in the
          example below).</para>
        </listitem>
      </itemizedlist>

      <para>In the header file a number of interface functions is declared,
      one for each element in the input signature of the tool. It is up to the
      writer of the tool to provide an implementation for these functions. The
      generated C file contains a handler function that analyzes incoming
      terms from the ToolBus, and delegates actual processing to the
      appropriate interface function.</para>

      <para>We will use the Tscript <literal>hello2.tb</literal> shown earlier
      in <xref linkend="example.hello2" /> and describe all the steps needed
      to write and compile the hello tool.</para>

      <section>
        <title>Step 1: generate tifs</title>

        <para>Using the command:<programlisting>toolbus -gentifs hello2.tb </programlisting></para>

        <para>we generate a file called <literal>hello2.tifs</literal>. It
        contains information amount the interfaces for all tools that are used
        in a given Tscript.<warning>
            <para>The -gentifs flag is not yet implemented.</para>
          </warning></para>
      </section>

      <section>
        <title>Step 2: generate C tool interface</title>

        <para>Using the command:</para>

        <para><programlisting>tifstoc -tool hello test.tifs </programlisting></para>

        <para>we generate two files:</para>

        <itemizedlist>
          <listitem>
            <para>the header file hello.tif.h, see <xref
            linkend="example.hello.tif.h" />.</para>
          </listitem>

          <listitem>
            <para>the source file <literal>hello.tif.c</literal>, see <xref
            linkend="example.hello.tif.c" />.</para>
          </listitem>
        </itemizedlist>

        <para><example xml:id="example.hello.tif.h">
            <title>The generated header file
            <literal>hello.tif.h</literal></title>

            <para><programlisting>**
 * This file is generated by tifstoc. Do not edit!
 * Generated from tifs for tool 'hello' (prefix='')
 */

#ifndef _HELLO_H
#define _HELLO_H

#include &lt;atb-tool.h&gt;

/* Prototypes for functions called from the event handler */
ATerm get_text(int conn);
void rec_terminate(int conn, ATerm);
extern ATerm hello_handler(int conn, ATerm term);
extern ATerm hello_checker(int conn, ATerm sigs);

#endif</programlisting>Only the functions <literal>get_text</literal> and
            <literal>rec_terminate</literal> together with a simple
            <literal>main</literal> function have to be implemented to build a
            fully functional ToolBus tool.</para>
          </example><example xml:id="example.hello.tif.c">
            <title>The generated file <literal>hello.tif.c</literal></title>

            <para><programlisting>/**
 * This file is generated by tifstoc. Do not edit!
 * Generated from tifs for tool 'hello' (prefix='')
 */

#include "hello.tif.h"

#define NR_SIG_ENTRIES  2

static char *signature[NR_SIG_ENTRIES] = {     <co xml:id="co.hello2.tif.c.1" />
  "rec-eval(&lt;hello&gt;,get_text)",
  "rec-terminate(&lt;hello&gt;,&lt;term&gt;)",
};

/* Event handler for tool 'hello' */
ATerm hello_handler(int conn, ATerm term)      <co xml:id="co.hello2.tif.c.2" />
{
  ATerm in, out;
  /* We need some temporary variables during matching */
  ATerm t0;

  if(ATmatch(term, "rec-eval(get_text)")) {
    return get_text(conn);
  }
  if(ATmatch(term, "rec-terminate(&lt;term&gt;)", &amp;t0)) {
    rec_terminate(conn, t0);
    return NULL;
  }
  if(ATmatch(term, 
             "rec-do(signature(&lt;term&gt;,&lt;term&gt;))", &amp;in, &amp;out)) {
    ATerm result = hello_checker(conn, in);
    if(!ATmatch(result, "[]"))
      ATfprintf(stderr, 
                "warning: not in input signature:\n\t%\n\tl\n",
                result);
    return NULL;
  }

  ATerror("tool hello cannot handle term %t", term);
  return NULL; /* Silence the compiler */
}

/* Check the signature of the tool 'hello' */
ATerm hello_checker(int conn, ATerm siglist)   <co xml:id="co.hello2.tif.c.3" />
{
  return ATBcheckSignature(siglist, signature, NR_SIG_ENTRIES);
}</programlisting>Notes:<calloutlist>
                <callout arearefs="co.hello2.tif.c.1">
                  <para>An array of signature definitions
                  (<literal>signature</literal>) that contains the argument
                  and return types of each interface function.</para>
                </callout>

                <callout arearefs="co.hello2.tif.c.2">
                  <para>The handler function
                  (<literal>hello_handler</literal>), that differentiates
                  between the different possible input terms coming from the
                  ToolBus, and delegates the actual work to the appropriate
                  function.</para>
                </callout>

                <callout arearefs="co.hello2.tif.c.3">
                  <para>The signature checker <literal>hello_checker</literal>
                  uses the assembled signature information in the array
                  <literal>signature</literal> and compares it with
                  <literal>siglist</literal>, an ATerm that encodes the tool's
                  signature as expected by the ToolBus.</para>
                </callout>
              </calloutlist></para>
          </example></para>
      </section>

      <section>
        <title>Step 3: write main</title>

        <para>As mentioned earlier, the only thing needed to implement the
        actual hello tool, is the implementation of the two interface
        functions <literal>get_txt</literal> and
        <literal>rec_terminate</literal>, and the implementation of
        <literal>main</literal> to get things going. We will first take a look
        at the initialization stuff that the <literal>main</literal> function
        of the hello tool has to do, see <xref
        linkend="example.hello.main" />.<example xml:id="example.hello.main">
            <title><literal>main</literal> function of hello tool</title>

            <para><programlisting>#include &lt;stdlib.h&gt;
#include "hello.tif.h"

int main(int argc, char *argv[])
{
  ATerm bottomOfStack;                                   <co
                  xml:id="co.hello2.main.1" />

  ATBinit(argc, argv, &amp;bottomOfStack);                   <co
                  xml:id="co.hello2.main.2" />
  if(ATBconnect(NULL, NULL, -1, testing_handler) &gt;= 0) { <co
                  xml:id="co.hello2.main.3" />
    ATBeventloop();                                      <co
                  xml:id="co.hello2.main.4" />
  } else {
    fprintf(stderr, 
            "Could not connect to the ToolBus, giving up!\n");
    return -1;
  }
  return 0;
}</programlisting></para>

            <para>Notes:<calloutlist>
                <callout arearefs="co.hello2.main.1">
                  <para>The variable <literal>bottomOfStack</literal> is
                  needed by the ATerm library to determine where to look for
                  the stack. It is passed as argument to
                  <literal>ATBinit</literal>.</para>
                </callout>

                <callout arearefs="co.hello2.main.2">
                  <para>The variables <literal>argc</literal> and
                  <literal>argv</literal> are passed unchanged to
                  <literal>ATBinit</literal>, so the ToolBus library can look
                  for default values for things like the ToolBus' well-known
                  socket address and the ToolBus host name.</para>
                </callout>

                <callout arearefs="co.hello2.main.3">
                  <para>The call to <literal>ATBconnect</literal> connects to
                  a running ToolBus, and requires four arguments: a character
                  string representing the tool name, a character string
                  representing the host name of the ToolBus to connect to, the
                  port number of the ToolBus to connect to, and a handler
                  function. Passing <literal>NULL</literal>,
                  <literal>NULL</literal>, and -1 respectively as the tool
                  name, the host name, and the port number cause the defaults
                  for these values to be used instead.</para>
                </callout>

                <callout arearefs="co.hello2.main.4">
                  <para>When all goes well, the call to
                  <literal>ATBeventloop</literal> starts the main ToolBus
                  eventloop and the tool will be ready to receive requests
                  from the ToolBus.</para>
                </callout>
              </calloutlist></para>
          </example></para>
      </section>

      <section>
        <title>Step 4: implement interface functions</title>

        <para>Finally, we only need the implementation of the two interface
        functions <literal>get_txt</literal> and
        <literal>rec_terminate</literal>, see <xref
        linkend="example.hello.interface-functions" /></para>

        <para><example xml:id="example.hello.interface-functions">
            <title>Implementation of interface functions of hello tool</title>

            <para><programlisting>ATerm get_text(int conn)                  <co
                  xml:id="co.hello2.interface.1" />             
{
  return 
    ATmake(
     "snd-value(text(\"Hello World, my first tool in C!\n\"))"
    );
}

void rec_terminate(int conn, ATerm msg){  <co xml:id="co.hello2.interface.2" /> 
  exit(0);
}</programlisting>Notes:<calloutlist>
                <callout arearefs="co.hello2.interface.1">
                  <para>get_text: generate the greeting text. The
                  <literal>conn</literal> argument identifies the ToolBus
                  connection, making it possible to distinguish
                  <emphasis>which</emphasis> ToolBus made the request. This
                  enables connecting to more than one ToolBus at the same
                  time.</para>
                </callout>

                <callout arearefs="co.hello2.interface.2">
                  <para>Mandatory function that is called to terminate the
                  tool.</para>
                </callout>
              </calloutlist></para>
          </example></para>
      </section>
    </section>
  </section>

  <section xml:id="section.Java-tools">
    <title>Writing ToolBus tools in Java</title>

    <para>Now we will show how ToolBus tools can be implemented in Java. The
    overall organization is shown in <xref
    linkend="figure.java-tool-organization" />. The actual communication
    between ToolBus and tool is taken care of by an instance of the class
    <literal>ToolBridge</literal> that takes care of low-level communication
    details. The ToolBridge is used by <literal>AbstractTool</literal>, an
    abstract class that defines the possible interactions between ToolBus and
    tool. The actual tool, in the figure <literal>MyTool</literal>, extends
    <literal>AbstractTool</literal>, gives implementations for its abstract
    methods, and implements tool-specific behaviour.</para>

    <para>Compared to writing a tool in C, using Java is simpler because there
    is no need for generating a tool interface using a tif file.<footnote>
        <para>This is due to the use of Java reflection in the class
        ToolBridge. In older versions, a generation step was also needed for
        Java tools.</para>
      </footnote></para>

    <para><figure xml:id="figure.java-tool-organization">
        <title>Global organization of a tool implemented in Java</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="java-tool-organization.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>Before showing the Java implementation of the hello tool, we
    first explain the AbstractTool class.</para>

    <section xml:id="section.AbstractTool">
      <title>The <literal>AbstractTool</literal> class</title>

      <para><programlisting>public abstract class AbstractTool implements IOperations {

public AbstractTool(){ ... } <co xml:id="co.AbstractTool.1" />

public void connect(String[] args) throws Exception{ ... } <co
            xml:id="co.AbstractTool.2" />

public ToolBridge getToolBridge(){ ... } <co xml:id="co.AbstractTool.3" />

public PureFactory getFactory(){ ... } <co xml:id="co.AbstractTool.4" />

public void sendEvent(ATerm aTerm){ ... }  <co xml:id="co.AbstractTool.5" />

public void disconnect(ATerm aTerm){ ... } <co xml:id="co.AbstractTool.6" />

public abstract void receiveAckEvent(ATerm aTerm); <co
            xml:id="co.AbstractTool.7" />

public abstract void receiveTerminate(ATerm aTerm); <co
            xml:id="co.AbstractTool.8" />
} </programlisting>Notes:</para>

      <calloutlist>
        <callout arearefs="co.AbstractTool.1">
          <para>The default constructor of AbstractTool.</para>
        </callout>

        <callout arearefs="co.AbstractTool.2">
          <para>Connect to the ToolBus. The argument <literal>args</literal>
          contains the required information for running a tool (name, id and
          additionally the host and port of the ToolBus, depending on how this
          tool is connected to the ToolBus). An exception is thrown when
          something goes wrong during parsing of the arguments or while
          establishing the connection.</para>
        </callout>

        <callout arearefs="co.AbstractTool.3">
          <para>Returns a reference to the tool bridge that this tool instance
          is using.</para>
        </callout>

        <callout arearefs="co.AbstractTool.4">
          <para>Returns a reference to the ATerm factory that is being
          used.</para>
        </callout>

        <callout arearefs="co.AbstractTool.5">
          <para>Send an event to the ToolBus.</para>
        </callout>

        <callout arearefs="co.AbstractTool.6">
          <para>Send a disconnect request to the ToolBus. The argument
          <literal>aTerm</literal> gives additional information about the
          request.</para>
        </callout>

        <callout arearefs="co.AbstractTool.7">
          <para>Receive an acknowledgement (in response to a previous event
          generated by this tool instance by way of
          <literal>sendEvent</literal>). The argument <literal>aTerm</literal>
          gives further details about the acknowledgement.</para>
        </callout>

        <callout arearefs="co.AbstractTool.8">
          <para>Receive a request from the ToolBus to terminate the execution
          of this tool instance.</para>
        </callout>
      </calloutlist>
    </section>

    <section xml:id="section.hello-Java-tool-definition">
      <title>Tool definition in the hello script</title>

      <para>The hello script from <xref linkend="example.hello2" /> can be
      used as is, except that the definition of the hello tool has to be
      changed to reflect the Java implementation:</para>

      <para><programlisting>tool hello is { kind = "javaNG" class = "toolbus.tool.java.hello.HelloTool"}</programlisting></para>
    </section>

    <section xml:id="section.hello-Java">
      <title>The hello example in Java</title>

      <para><example>
          <title>Hello tool implemented in Java</title>

          <para><programlisting>package toolbus.tool.java.hello;

import toolbus.adapter.AbstractTool;
import aterm.ATerm;
import aterm.ATermFactory;

public class HelloTool extends AbstractTool <co xml:id="co.hello-java.1" />
{
  public HelloTool(String[] args){ <co xml:id="co.hello-java.2" />
    super(); 
    try {
      connect(args); 
    } catch(Exception ex){
      throw new RuntimeException(ex);
    }
  }

  protected ATerm getText(){ <co xml:id="co.hello-java.3" />
    ATermFactory factory = getFactory();
    return factory.make("text(&lt;str&gt;)", 
                             "Hello world in Java!\n");
  }

  public void receiveAckEvent(ATerm aTerm){
  // Left blank intentionally. 
  }

  public void receiveTerminate(ATerm msg){
     System.out.print("rec-terminate received: " + msg);
 }
  
  public static void main(String[] args) {
    new HelloTool(args);
  }
}</programlisting>Notes:<calloutlist>
              <callout arearefs="co.hello-java.1">
                <para>The class <literal>HelloTool</literal> extends
                <literal>AbstractTool</literal> and provides an implementation
                for the hello tool.</para>
              </callout>

              <callout arearefs="co.hello-java.2">
                <para>The constructor for <literal>HelloTool</literal> first
                calls its super class and then attempt to make a connection.
                The arguments of the constructor are passed to the
                <literal>connect</literal> call.</para>
              </callout>

              <callout arearefs="co.hello-java.3">
                <para>The evaluation request <literal>snd-eval(H,
                get_text)</literal> in the Tscript is implemented by the
                method <literal>getText</literal>. It constructs the required
                ATerm that <literal>text("Hello world in Java!\n")</literal>
                and returns it as result. This result will passed to the
                ToolBus and will be accepted by the atom <literal>rec-value(H,
                text(S?))</literal> in the Tscript. Note that in this example
                <literal>H</literal> is the tool identifier of the hello
                tool.</para>
              </callout>
            </calloutlist></para>
        </example></para>
    </section>
  </section>

  <section xml:id="section.tools-other-languages">
    <title>Writing ToolBus tools in other languages</title>

    <section xml:id="section.TclTk-tools">
      <title>Writing tools in Tcl/TK</title>

      <para>Writing ToolBus tools in Tcl is greatly simplified by the
      <command>wish-adapter</command> to be explained in <xref
      linkend="section.wish-adapter" />. Next, a small set of predefined Tcl
      functions is described that are always loaded by the
      <command>wish-adapter</command> and can be used in any Tcl script, see
      <xref linkend="section.predefined-Tcl-functions" />. Finally, we present
      the Tcl version of the hello tool in <xref
      linkend="section.hello-tcl" />.</para>

      <section xml:id="section.wish-adapter">
        <title>wish-adapter</title>

        <para>The purpose of the wish-adapter is to execute Tcl/Tk's windowing
        shell <command>wish</command> as a tool. For instance,<programlisting>wish-adapter -script calculator.tcl</programlisting></para>

        <para>executes <command>wish</command> as a TooBus tool and executes
        the Tcl script <filename>calculator.tcl</filename>.</para>

        <para>In addition to the common tool arguments, wish-adapter has the
        following specific arguments:</para>

        <itemizedlist>
          <listitem>
            <para><literal>-wish <replaceable>Name</replaceable></literal>:
            Use <replaceable>Name</replaceable> rather than
            <command>wish</command> as Tcl/Tk's windowing shell.</para>
          </listitem>

          <listitem>
            <para><literal>-lazy-exec</literal>: Postpone execution of
            <command>wish</command> until needed. </para>
          </listitem>

          <listitem>
            <para><literal>-script</literal>: The Tcl script to be executed.
            </para>
          </listitem>

          <listitem>
            <para><literal>-script-args</literal>: The arguments for the Tcl
            script to be executed. These arguments are available to the Tcl
            script throught the variables <replaceable>argc</replaceable> and
            <replaceable>argv</replaceable>. </para>
          </listitem>
        </itemizedlist>

        <para>Various communication patterns are supported by wish-adapter.
        Communication is described here from the point of view of the ToolBus,
        i.e., <literal>snd-</literal> and <literal>rec-</literal> mean,
        respectively, send by ToolBus and receive by ToolBus. The
        communication patterns are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>snd-do(<replaceable>Tid</replaceable>,
            <replaceable>Fun</replaceable>(<replaceable>A</replaceable><subscript>1</subscript>,
            ...,
            </literal><replaceable>A</replaceable><subscript>n</subscript>))
            perform the Tcl function call
            <literal><replaceable>Fun</replaceable>(<replaceable>A</replaceable><subscript>1</subscript>,
            ...,</literal><replaceable>A</replaceable><subscript>n</subscript>).
            Here <replaceable>Tid</replaceable> is a tool identifier (as
            produced by <literal>execute</literal> or
            <literal>rec-connect</literal>) for an instance of the
            <command>wish-adapter</command>. </para>
          </listitem>

          <listitem>
            <para><literal>snd-do(<replaceable>Tid</replaceable>,
            <replaceable>Fun</replaceable>(<replaceable>A</replaceable><subscript>1</subscript>,
            ...,</literal><replaceable>A</replaceable><subscript>n</subscript>)):
            perform the Tcl function call
            <literal><replaceable>Fun</replaceable>(<replaceable>A</replaceable><subscript>1</subscript>,
            ...,</literal><replaceable>A</replaceable><subscript>n</subscript>).
            Here <replaceable>Tid</replaceable> is a tool identifier (as
            produced by <literal>execute</literal> or
            <literal>rec-connect</literal>) for an instance of the
            <command>wish-adapter</command>. Note that the function
            <replaceable>Fun</replaceable> must send an answer back to the
            ToolBus (using <literal>TBsend "snd-eval(...)"</literal>). </para>
          </listitem>

          <listitem>
            <para><literal>rec-value(<replaceable>Tid</replaceable>,
            <replaceable>Res</replaceable>)</literal>: the return value for a
            previous evaluation request. </para>
          </listitem>

          <listitem>
            <para>rec-event(Tid,
            <literal><replaceable>A</replaceable><subscript>1</subscript>,
            ...,</literal><replaceable>A</replaceable><subscript>n</subscript>):
            event generated by wish.</para>
          </listitem>

          <listitem>
            <para>snd-ack-event(<replaceable>Tid</replaceable>,
            <replaceable>A</replaceable><subscript>1</subscript>):
            acknowledgement of a previously generated event. </para>
          </listitem>

          <listitem>
            <para>snd-terminate(<replaceable>Tid</replaceable>,
            <replaceable>A</replaceable><subscript>1</subscript>): terminate
            execution of wish-adapter.</para>
          </listitem>
        </itemizedlist>

        <para>The command <command>wish</command> is executed once, an initial
        Tcl script is read, and all further requests are directed to this
        incarnation of <command>wish</command>. A small set of Tcl procedures
        is available for unpacking and packing ToolBus terms (see
        below).</para>
      </section>

      <section xml:id="section.predefined-Tcl-functions">
        <title>Predefined Tcl functions</title>

        <para>The following Tcl functions are predefined and can be used
        freely in Tcl script executed via the wish-adapter:</para>

        <itemizedlist>
          <listitem>
            <para><literal>TBstring <replaceable>Str</replaceable></literal>:
            converts a Tcl string to a ToolBus string by surrounding it with
            double quotes and escaping double quotes occurring inside
            <replaceable>Str</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>TCLstring <replaceable>Str</replaceable></literal>:
            converts a ToolBus string into a Tcl string by removing
            surrounding double quotes.</para>
          </listitem>

          <listitem>
            <para><literal>TBlist <replaceable>List</replaceable></literal>:
            converts a Tcl list to a ToolBus list by separating the elements
            with commas and surrounding the list by curly braces.</para>
          </listitem>

          <listitem>
            <para><literal>TBerror <replaceable>Msg</replaceable></literal>:
            constructs an error message that can be sent to the
            ToolBus.</para>
          </listitem>

          <listitem>
            <para><literal>TBsend <replaceable>Trm</replaceable></literal>:
            send <replaceable>Trm</replaceable> back to the ToolBus.</para>
          </listitem>

          <listitem>
            <para><literal>TBevent <replaceable>Event</replaceable></literal>:
            send event <literal>Event</literal> to the ToolBus.</para>
          </listitem>

          <listitem>
            <para><literal>TBrequire <replaceable>ToolName</replaceable>
            <replaceable>ProcName</replaceable>
            <replaceable>Nargs</replaceable></literal>: check that the Tcl
            code for <replaceable>ToolName</replaceable> contains a procedure
            declaration for <replaceable>ProcName</replaceable> with
            <replaceable>Nargs</replaceable> formal parameters. This function
            is mainly used by the <command>wish-adapter</command> to check
            compatibility of the Tcl code with the expected input signature of
            the tool.</para>
          </listitem>
        </itemizedlist>

        <warning>
          <para>All communication between <command>wish-adapter</command> and
          a tool written in Tcl is done via standard input/output. Only use
          the standard error stream for print statements in the Tcl script,
          since using standard output will disrupt the communication with the
          ToolBus.</para>
        </warning>
      </section>

      <section xml:id="section.hello-tcl">
        <title>The hello example in Tcl</title>

        <para>Writing the hello tool in Tcl requires two steps:</para>

        <itemizedlist>
          <listitem>
            <para>Write the required Tcl code <filename>hello.tcl</filename>.
            The result is shown in <xref
            linkend="example.hello.tcl" />.</para>
          </listitem>

          <listitem>
            <para>Replace hello's tool definition in
            <filename>hello2.tb</filename> (see <xref
            linkend="example.hello2" />) by: <programlisting>tool hello is {command = "wish-adapter -script hello.tcl"}</programlisting></para>
          </listitem>
        </itemizedlist>

        <para><example xml:id="example.hello.tcl">
            <title>hello.tcl: the hello tool in Tcl</title>

            <para><programlisting># hello.tcl -- hello tool in Tcl/Tk

proc get-text {} {
   TBsend "snd-value(text(\"Hello World, my first ToolBus tool in Tcl!\n\"))"
}

proc rec-terminate { n } {
   exit
}</programlisting></para>
          </example></para>
      </section>
    </section>

    <section xml:id="section.Python-adapter">
      <title>Python</title>

      <para>A Python adapter is only available for older versions of the
      ToolBus. It is currently not supported.</para>
    </section>

    <section xml:id="section.Perl-adapter">
      <title>Perl</title>

      <para>A Perl adapter is only available for older versions of the
      ToolBus. It is currently not supported.</para>
    </section>
  </section>

  <section xml:id="section.toolbus-reference">
    <title>Reference Information</title>

    <section xml:id="section.syntax-Tscripts">
      <title>The syntax of Tscripts</title>

      <para>A Tscript may contain directives like, e.g.,
      <literal>#define</literal>, <literal>#include</literal> and
      <literal>#ifdef</literal> that are replaced by a preprocessor similar to
      the C preprocessor. We summarize the most frequently used
      directives:</para>

      <itemizedlist>
        <listitem>
          <para><literal>#define <replaceable>Identifier</replaceable>
          <replaceable>Token-sequence</replaceable></literal> causes the
          preprocessor to replace all occurrences of
          <replaceable>Identifier</replaceable> by
          <replaceable>Token-sequence</replaceable>.</para>
        </listitem>

        <listitem>
          <para><literal>#include
          "<replaceable>Filename</replaceable>"</literal> will be replaced by
          the entire contents of the named file.</para>
        </listitem>

        <listitem>
          <para><literal>#ifdef</literal> and <literal>#ifndef</literal> can
          be used for the conditional incorporation or exclusion of parts of a
          script.</para>
        </listitem>
      </itemizedlist>

      <para>The syntax of Tscripts (without preprocessor directives) is as
      follows:</para>

      <warning>
        <para>This definition is slightly out-of-date.</para>
      </warning>

      <programlisting>
exports
  sorts BOOL NAT INT SIGN EXP UNSIGNED-REAL REAL STRING ID 
        NAME VNAME BSTR TERM TERM-LIST VAR GEN-VAR TYPE ATOM 
        ATOMIC-FUN PROC PROC-APPL FORMALS TIMER-FUN 
        FEATURE-ASG FEATURES TB-CONFIG DEF T-SCRIPT
  lexical syntax
        [ \t\n]                              -&gt; LAYOUT
        "%%" ~[\n]*                          -&gt; LAYOUT

        [0-9]+                               -&gt; NAT
        NAT                                  -&gt; INT
        SIGN NAT                             -&gt; INT
        [+\-]                                -&gt; SIGN

        [eE] NAT                             -&gt; EXP
        [eE] SIGN NAT                        -&gt; EXP
        NAT "." NAT                          -&gt; UNSIGNED-REAL
        NAT "." NAT EXP                      -&gt; UNSIGNED-REAL
        UNSIGNED-REAL                        -&gt; REAL
        SIGN UNSIGNED-REAL                   -&gt; REAL

        [a-z][A-Za-z0-9\-]*                  -&gt; ID
        "\"" ~[\"]* "\""                     -&gt; STRING
        [A-Z][A-Za-z0-9\-]*                  -&gt; NAME
        [A-Z][A-Za-z0-9\-]*                  -&gt; VNAME
        [a-z][a-z\-]*                        -&gt; ATOMIC-FUN

        delay                                -&gt; TIMER-FUN
        abs-delay                            -&gt; TIMER-FUN
        timeout                              -&gt; TIMER-FUN
        abs-timeout                          -&gt; TIMER-FUN
  context-free syntax
        true                                 -&gt; BOOL
        false                                -&gt; BOOL
        BOOL                                 -&gt; TERM
        INT                                  -&gt; TERM
        REAL                                 -&gt; TERM
        STRING                               -&gt; TERM

        TERM                                 -&gt; TYPE

        VNAME                                -&gt; VAR
        VNAME ":" TYPE                       -&gt; VAR
        VAR                                  -&gt; GEN-VAR
        VAR "?"                              -&gt; GEN-VAR
        GEN-VAR                              -&gt; TERM
        "&lt;" TERM "&gt;"                         -&gt; TERM
        ID                                   -&gt; TERM
        ID "(" TERM-LIST ")"                 -&gt; TERM
        {TERM ","}*                          -&gt; TERM-LIST
        "[" TERM-LIST "]"                    -&gt; TERM

        NAME                                 -&gt; VNAME

        ATOMIC-FUN "(" TERM-LIST ")"         -&gt; ATOM
        delta                                -&gt; ATOM
        tau                                  -&gt; ATOM
        create "(" NAME "(" TERM-LIST ")" ","  
                   TERM ")"                  -&gt; ATOM
        ATOM TIMER-FUN "(" TERM ")"          -&gt; ATOM
        VNAME ":=" TERM                      -&gt; ATOM

        ATOM                                 -&gt; PROC
        PROC "+" PROC                        -&gt; PROC  {left}
        PROC "." PROC                        -&gt; PROC  {right}
        PROC "||" PROC                       -&gt; PROC  {right}
        PROC "*" PROC                        -&gt; PROC  {left}
        "(" PROC ")"                         -&gt; PROC  {bracket}
        if TERM then PROC else PROC fi       -&gt; PROC
        if TERM then PROC fi                 -&gt; PROC
        execute(TERM-LIST)                   -&gt; PROC
        let {VAR ","}* in PROC endlet        -&gt; PROC

        NAME                                 -&gt; PROC-APPL
        NAME "(" TERM-LIST ")"               -&gt; PROC-APPL
        PROC-APPL                            -&gt; PROC

        "(" {GEN-VAR ","}* ")"               -&gt; FORMALS
                                             -&gt; FORMALS

        process NAME FORMALS is PROC         -&gt; DEF
        ID "=" STRING                        -&gt; FEATURE-ASG
       "{" { FEATURE-ASG  ";"}* "}"          -&gt; FEATURES
        tool ID FORMALS is FEATURES          -&gt; DEF
        toolbus "("{PROC-APPL ","}+ ")"      -&gt; TB-CONFIG
        DEF* TB-CONFIG                       -&gt; T-SCRIPT

 priorities
       PROC "*" PROC -&gt; PROC &gt; PROC "." PROC -&gt; PROC &gt;
       PROC "+" PROC -&gt; PROC &gt; PROC "||" PROC -&gt; PROC
   </programlisting>
    </section>

    <section xml:id="section.built-in-functions">
      <title>Built-in functions</title>

      <para>Tscripts provide a limited form of built-in functions that are
      summarized here. Recall that built-in functions are only evaluated at
      the following syntactic positions in a Tscript:</para>

      <itemizedlist>
        <listitem>
          <para>The right-hand side of an assignment.</para>
        </listitem>

        <listitem>
          <para>The test in an if-then or if-then-else construct.</para>
        </listitem>

        <listitem>
          <para>The expression in time-related constructs.</para>
        </listitem>
      </itemizedlist>

      <section xml:id="section.Boolean-functions">
        <title>Boolean functions</title>

        <para><table>
            <title>Boolean functions</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description&#160;</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>not(&lt;bool&gt;<subscript>1</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>¬
                  <literal>&lt;bool&gt;<subscript>1</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>and(&lt;bool&gt;<subscript>1</subscript>,
                  &lt;bool&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;bool&gt;<subscript>1</subscript> and
                  &lt;bool&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>or(&lt;bool&gt;<subscript>1</subscript>,
                  &lt;bool&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;bool&gt;<subscript>1</subscript> OR
                  &lt;bool&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>equal(&lt;term&gt;<subscript>1</subscript>,
                  &lt;term&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;term&gt;<subscript>1</subscript>
                  </literal>=
                  <literal>&lt;term&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>not-equal(&lt;term&gt;<subscript>1</subscript>,
                  &lt;term&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;term&gt;<subscript>1</subscript> NE
                  &lt;term&gt;<subscript>2</subscript></literal></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.Integer-functions">
        <title>Integer functions</title>

        <table>
          <title>Integer functions</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>add(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                +
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>sub(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                -
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>mul(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry
                char="02306"><literal>&lt;int&gt;<subscript>1</subscript></literal>
                TIMES
                <literal>&lt;int&gt;</literal><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><literal>div(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                /
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>mod(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                <emphasis role="bold">mod</emphasis>
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>abs(&lt;int&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry>|
                <literal>&lt;int&gt;<subscript>1</subscript></literal>
                |</entry>
              </row>

              <row>
                <entry><literal>less(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                &lt;
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>less-equal(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript>
                </literal>LEQ
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>greater(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                &gt;
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>greater-equal(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                GEQ
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section xml:id="section.Real-functions">
        <title>Real functions</title>

        <para><table>
            <title>Real functions</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>radd(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  +
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rsub(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  -
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rmul(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  ×
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rdiv(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  /
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>mod(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  <emphasis role="bold">mod</emphasis>
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rabs(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry>|
                  <literal>&lt;real&gt;<subscript>1</subscript></literal>
                  |</entry>
                </row>

                <row>
                  <entry><literal>rless(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  &lt;
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rless-equal(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;&gt;<subscript>1</subscript></literal>
                  ≤
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rgreater(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  &gt;
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rgreater-equal(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;&gt;<subscript>1</subscript></literal>
                  ≥
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.Goniometric-functions">
        <title>Goniometric functions</title>

        <table>
          <title>Goniometric functions</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>sin(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>sin</emphasis>(<literal>&lt;real&gt;<subscript>1</subscript></literal>)</entry>
              </row>

              <row>
                <entry><literal>cos(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>cos</emphasis>(<literal>&lt;real&gt;<subscript>1</subscript></literal>)</entry>
              </row>

              <row>
                <entry><literal>atan(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>tan</emphasis><superscript>-1</superscript>(<literal>&lt;real&gt;<subscript>1</subscript></literal>)
                in the range [-π/2, π/2]</entry>
              </row>

              <row>
                <entry><literal>atan2(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>tan</emphasis><superscript>-1</superscript>(<literal>&lt;real&gt;<subscript>1</subscript></literal>/<literal>&lt;real&gt;<subscript>2</subscript></literal>)
                in the range [-π, π]</entry>
              </row>

              <row>
                <entry><literal>exp(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>e</emphasis><superscript>&lt;real&gt;<subscript>1</subscript></superscript></entry>
              </row>

              <row>
                <entry><literal>log(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry>natural logarithm
                <emphasis>ln</emphasis>(<literal>&lt;real&gt;<subscript>1</subscript></literal>),
                with <literal>&lt;real&gt;<subscript>1</subscript></literal>
                &gt; 0</entry>
              </row>

              <row>
                <entry><literal>log10(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry>base 10 logarithm
                <emphasis>log</emphasis><subscript>10</subscript>(<literal>&lt;real&gt;<subscript>1</subscript></literal>),
                with <literal>&lt;real&gt;<subscript>1</subscript></literal>
                &gt; 0</entry>
              </row>

              <row>
                <entry><literal>sqrt(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>√</emphasis><literal>&lt;real&gt;<subscript>1</subscript></literal>,
                with <literal>&lt;real&gt;<subscript>1</subscript></literal> ≥
                0</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section xml:id="section.list-functions">
        <title>Functions on lists</title>

        <table>
          <title>Functions on lists</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>first(&lt;list&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;term&gt;</literal></entry>

                <entry>First element of
                <literal>&lt;list&gt;<subscript>1</subscript></literal>; The
                empty list <literal>[]</literal> when applied to non-list or
                empty list.</entry>
              </row>

              <row>
                <entry><literal>next(&lt;list&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>Remaining elements of
                <literal>&lt;list&gt;<subscript>1</subscript></literal>.</entry>
              </row>

              <row>
                <entry><literal>join(&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>Concatenation of
                <literal>&lt;term&gt;<subscript>1</subscript></literal> and
                <literal>&lt;term&gt;<subscript>2</subscript></literal>. When
                both arguments are lists their elements are spliced into a new
                list. A non-list argument is included as single element in the
                new list.</entry>
              </row>

              <row>
                <entry><literal>size(&lt;list&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry>The number of elements in
                <literal>&lt;list&gt;<subscript>1</subscript></literal>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Functions on lists as arrays</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>index(&lt;list&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;term&gt;</literal></entry>

                <entry>The
                <literal>&lt;int&gt;<subscript>1</subscript></literal>-th
                element of
                <literal>&lt;list&gt;<subscript>1</subscript></literal>, if it
                exists; otherwise <literal>[]</literal>.</entry>
              </row>

              <row>
                <entry><literal>replace(&lt;list&gt;<subscript>1</subscript>,&lt;int<subscript>1</subscript>&gt;,&lt;term&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>If the
                &lt;<literal>int&gt;<subscript>1</subscript></literal>-the
                element exists, replace it by
                <literal>&lt;term&gt;<subscript>1</subscript></literal> and
                returned the modified list; otherwise return
                <literal>&lt;list&gt;<subscript>1</subscript></literal>
                unmodified.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Functions on lists as symbol tables</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>get(&lt;list&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;term&gt;</literal></entry>

                <entry>If
                <literal>&lt;list&gt;<subscript>1</subscript></literal>contains
                a pair <literal>[&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>1</subscript>']</literal> then return
                <literal>&lt;term&gt;<subscript>1</subscript>'</literal>;
                otherwise [].</entry>
              </row>

              <row>
                <entry><literal>put(&lt;list&gt;<subscript>1</subscript>,&lt;term&gt;<subscript>1</subscript>,&lt;term&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>If
                <literal>&lt;list&gt;<subscript>1</subscript></literal>contains
                a pair <literal>[&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>1</subscript>']</literal> then replace
                it by <literal>[&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>2</subscript>]</literal>; otherwise add
                a new pair [&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>2</subscript>] to
                &lt;list&gt;<subscript>1</subscript>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Functions on lists as multi-sets</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>member(&lt;term&gt;<subscript>1</subscript>,
                &lt;list&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;term&gt;<subscript>1</subscript></literal>
                IN <literal>&lt;list&gt;<subscript>2</subscript></literal>
                (membership in multi-set)</entry>
              </row>

              <row>
                <entry><literal>subset(&lt;list&gt;<subscript>1</subscript>,&lt;list&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;list&gt;<subscript>1</subscript></literal>
                SUBSET <literal>&lt;list&gt;<subscript>2</subscript></literal>
                (subset on multi-set)</entry>
              </row>

              <row>
                <entry><literal>diff(&lt;list&gt;<subscript>1</subscript>,&lt;list&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry><literal>&lt;list&gt;<subscript>1</subscript></literal>
                DIFF <literal>&lt;list&gt;<subscript>2</subscript></literal>
                (difference on multi-set)</entry>
              </row>

              <row>
                <entry><literal>inter(&lt;list&gt;<subscript>1</subscript>,&lt;list&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry><literal>&lt;list&gt;<subscript>1</subscript></literal>
                INTER <literal>&lt;list&gt;<subscript>2</subscript></literal>
                (intersection on multi-set)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section xml:id="section.term-functions">
        <title>Functions on terms</title>

        <para><table>
            <title>Functions on ATerms</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>is-bool(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>bool</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-int(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>int</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-real(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>real</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-str(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>str</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-bstr(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>bstr</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-appl(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is an application
                  then <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-list(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a list then
                  <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-empty(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is equal to
                  <literal>[] </literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-var(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a variable then
                  <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-var(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a variable then
                  <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-result-var(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a result
                  variable then <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-formal(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a formal
                  variable then <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>fun(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;str&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a function
                  application then its function symbol; otherwise
                  <literal>""</literal>.</entry>
                </row>

                <row>
                  <entry><literal>args(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;list&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a function
                  application then its argument; otherwise
                  <literal>[]</literal>.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.time-functions">
        <title>Time-related functions</title>

        <para><table>
            <title>Time-related functions</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>current-time</literal></entry>

                  <entry><literal>&lt;list&gt;</literal></entry>

                  <entry>Six-tuple describing the current absolute
                  time</entry>
                </row>

                <row>
                  <entry><literal>sec(&lt;int&gt;)</literal></entry>

                  <entry><literal>&lt;int&gt;</literal></entry>

                  <entry>Convert &lt;int&gt; into seconds</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.misc-functions">
        <title>Miscellaneous functions</title>

        <para><table>
            <title>Miscellaneous functions</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>process-id</literal></entry>

                  <entry><literal>&lt;int&gt;</literal></entry>

                  <entry>Process id of the current process</entry>
                </row>

                <row>
                  <entry><literal>process-name</literal></entry>

                  <entry><literal>&lt;str&gt;</literal></entry>

                  <entry>Name of the current process</entry>
                </row>

                <row>
                  <entry><literal>quote(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;term&gt;</literal></entry>

                  <entry>Quoted (unevaluated) term; only variables are
                  replaced by their values</entry>
                </row>

                <row>
                  <entry><literal>functions</literal></entry>

                  <entry><literal>&lt;list&gt;</literal></entry>

                  <entry>List of all built-in functions</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>
    </section>

    <section xml:id="section.synopsis-toolbus-primitives">
      <title>Synopsis of ToolBus primitives</title>

      <para>In the following two sections all primitives are summarized that
      can occur in a Tscript.</para>

      <section xml:id="section.process-related-primitives">
        <title>Process-related primitives in Tscripts</title>

        <para><table>
            <title>Process-related primitives in Tscripts</title>

            <tgroup cols="3">
              <colspec align="left" colname="col1" colwidth="2*" />

              <colspec align="left" colname="col2" colwidth="3*" />

              <colspec align="left" colname="col3" colwidth="1*" />

              <thead>
                <row>
                  <entry>Primitive</entry>

                  <entry>Synopsis</entry>

                  <entry>See</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>delta</entry>

                  <entry>Inaction (deadlock)</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry>tau</entry>

                  <entry>Internal step</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  +
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry>Choice between
                  <replaceable>P</replaceable><subscript>1</subscript> and
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  .
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  followed by
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  ||
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  parallel with
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  *
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry>Repeat
                  <replaceable>P</replaceable><subscript>1</subscript> until
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>if <replaceable>T</replaceable> then
                  <replaceable>P</replaceable> fi</literal></entry>

                  <entry>Guarded command</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>if <replaceable>T</replaceable> then
                  <replaceable>P</replaceable><subscript>1</subscript> else
                  <replaceable>P</replaceable><subscript>2</subscript>
                  fi</literal></entry>

                  <entry>Conditional</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>create(<replaceable>Pnm</replaceable>(<replaceable>T</replaceable>,
                  ...), <replaceable>Pid</replaceable>?)</literal></entry>

                  <entry>Create new process</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>V</replaceable> :=
                  <replaceable>T</replaceable></literal></entry>

                  <entry>Assign <replaceable>T</replaceable> ( seen as
                  expression) to <replaceable>V</replaceable></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-msg(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Send synchronous message</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-msg(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Receive a synchronous message</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-note(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Broadcast an asynchronous note</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-note(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Receive an asynchronous note</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>no-note(<replaceable>T</replaceable>)</literal></entry>

                  <entry>No note available</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>subscribe(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Subscribe to notes</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>A</replaceable>
                  delay(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Relative delay of atom execution</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>A</replaceable>
                  abs-delay(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Absolute delay of atom execution</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>A</replaceable>
                  timeout(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Relative timeout of atom execution</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>A</replaceable>
                  abs-timeout(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Absolute timeout of atom execution</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>shutdown(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Terminate ToolBus application</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>printf(<replaceable>S</replaceable>,
                  <replaceable>T</replaceable>, ...)</literal></entry>

                  <entry>Print terms according to format string S</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>read(<replaceable>T</replaceable><subscript>1</subscript>,
                  <replaceable>T</replaceable><subscript>2</subscript>)</literal></entry>

                  <entry>Give prompt
                  <replaceable>T</replaceable><subscript>1</subscript>and read
                  term that should match with
                  <replaceable>T</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>process
                  <replaceable>Pnm</replaceable>(<replaceable>F</replaceable>,
                  ...) is <replaceable>P</replaceable></literal></entry>

                  <entry>Define process <literal>
                  <replaceable>Pnm</replaceable> </literal></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>let <replaceable>F</replaceable>, ... in
                  <replaceable>P</replaceable> endlet</literal></entry>

                  <entry>Declare local variables in
                  <replaceable>P</replaceable></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>ToolBus(<replaceable>Pnm</replaceable>(<replaceable>T</replaceable>,...),
                  ...)</literal></entry>

                  <entry>Define initial ToolBus process configuration</entry>

                  <entry></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.tool-related-primitives">
        <title>Tool-related primitives in Tscripts</title>

        <para><table>
            <title>Tool-related primitives in Tscripts</title>

            <tgroup cols="3">
              <colspec align="left" colname="col1" colwidth="2*" />

              <colspec align="left" colname="col2" colwidth="3*" />

              <colspec align="left" colname="col3" colwidth="1*" />

              <thead>
                <row>
                  <entry>Primitive</entry>

                  <entry>Synopsis</entry>

                  <entry>See</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>rec-connect(<replaceable>Tid</replaceable>?)</literal></entry>

                  <entry>Receive connection request from tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-disconnect(<replaceable>Tid</replaceable>?)</literal></entry>

                  <entry>Receive disconnection request from tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>execute(<replaceable>Tnm</replaceable>(<replaceable>T</replaceable>,...),
                  <replaceable>Tid</replaceable>?)</literal></entry>

                  <entry>Execute a tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-terminate(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Terminate execution of a tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-eval(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Send evaluation request to tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-cancel(<replaceable>Tid</replaceable>)</literal></entry>

                  <entry>Cancel previous evaluation request</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-value(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Receive answer to evaluation request</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-do(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Send evaluation request to tool (no return
                  value)</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-event(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>, ...)</literal></entry>

                  <entry>Receive event from tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-ack-event(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Acknowledge previous event from tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>tool <replaceable>Tnm</replaceable> is {
                  <replaceable>Feat</replaceable>, ... }</literal></entry>

                  <entry>Define tool <replaceable>Tnm</replaceable></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>host =
                  <replaceable>Str</replaceable></literal></entry>

                  <entry>Host feature in tool definition</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>command =
                  <replaceable>Str</replaceable></literal></entry>

                  <entry>Command feature in tool definition</entry>

                  <entry></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>
    </section>
  </section>

  <section xml:id="section.toolbus-historical-notes">
    <title>Historical notes</title>

    <para>The first generation ToolBus is described in <xref
    linkend="BergstraKlint94" />. In addition to the design, the complete C
    implementation is discussed in detail. The second generation ("discrete
    time") ToolBus includes timing primitives as well as built-in functions.
    It has been formally described using ASF+SDF, see <xref
    linkend="BergstraKlint95" /> and <xref linkend="BergstraKlint98" />. In
    <xref linkend="Olivier00" /> a framework for the debugging of ToolBus
    applications is presented. Initial thoughts about a next generation
    ToolBus were published in <xref linkend="deJongKlint03" />. <xref
    linkend="deJong07" /> describes architectural aspects of ToolBus-based
    applications.<warning>
        <para>Add: theses of Peter Heibrink, Arnold Lankamp, Dennis
        Hendriks.</para>
      </warning></para>
  </section>

  <section xml:id="section.toolbus-bibliography">
    <title>Bibliography</title>

    <para><bibliolist>
        <bibliomixed xml:id="BergstraKlint94"></bibliomixed>

        <bibliomixed xml:id="BergstraKlint95"></bibliomixed>

        <bibliomixed xml:id="BergstraKlint98"></bibliomixed>

        <bibliomixed xml:id="deJongKlint03"></bibliomixed>

        <bibliomixed xml:id="deJong07"></bibliomixed>

        <bibliomixed xml:id="Olivier00"></bibliomixed>
      </bibliolist></para>
  </section>

  <section xml:id="section.toolbus-to-do">
    <title>To Do</title>

    <itemizedlist>
      <listitem>
        <para>What do we do with the other adapters?</para>
      </listitem>

      <listitem>
        <para>Describe current viewer.</para>
      </listitem>

      <listitem>
        <para>Describe console commands.</para>
      </listitem>

      <listitem>
        <para>Do we describe the global structure of the Java implementation
        (or partially refer to online docs)?</para>
      </listitem>

      <listitem>
        <para>Describe viewer interface.</para>
      </listitem>
    </itemizedlist>

    <para></para>
  </section>
</chapter>