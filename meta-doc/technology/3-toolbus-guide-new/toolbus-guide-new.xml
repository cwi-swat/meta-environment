<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Guide to ToolBus Programming</title>

  <warning>
    <para>This document is in state of creation and will further evolve. It
    provides a description of the classic C-based ToolBus as well as of the
    Java-based ToolBusNG. Eventually, it will exclusively focus on ToolBusNG.
    See <xref linkend="section.toolbus-to-do" />.</para>
  </warning>

  <section>
    <title>Introduction</title>

    <section>
      <title>Background and Motivation</title>

      <para>Building large, heterogeneous, distributed software systems poses
      serious problems for the software engineer. Systems grow
      <emphasis>larger</emphasis> because the complexity of the tasks we want
      to automate increases. They become <emphasis>heterogeneous</emphasis>
      because large systems may be constructed by re-using existing software
      as components. It is more than likely that these components have been
      developed using different implementation languages and run on different
      hardware platforms. Systems become <emphasis>distributed</emphasis>
      because they have to operate in the context of local area
      networks.</para>

      <para>Three aspects of heterogeneous, distributed, systems should be
      considered: <emphasis>coordination</emphasis>,
      <emphasis>representation</emphasis> and
      <emphasis>computation</emphasis>.</para>

      <formalpara>
        <title>Coordination</title>

        <para>Coordination is the way in which program and system parts
        interact with each other using, ordinary procedure calls, remote
        procedure calls (RPC), remote method invocation (RMI), and
        others.</para>
      </formalpara>

      <formalpara>
        <title>Representation</title>

        <para>Representation is the language and machine neutral format for
        data being exchanged between components.</para>
      </formalpara>

      <formalpara>
        <title>Computation</title>

        <para>Computation is done by specialized program code that carries out
        a specific task, e.g., providing a user-interface, providing database
        access, and the like.</para>
      </formalpara>

      <para>Our key assumption is as follows:<important>
          <para>A rigorous separation of coordination from computation is the
          key to flexible and reusable systems.</para>
        </important></para>

      <para>A system organization that respects this separation is shown
      in</para>

      <figure>
        <title>Separating coordination from computation</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="coordination.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>We propose to get control over the possible interactions between
      software components (<emphasis>tools</emphasis>) by forbidding direct
      inter-tool communication. Instead, all interactions are controlled by a
      process-oriented <emphasis>script</emphasis> that formalizes all the
      desired interactions among tools. This leads to a component
      interconnection architecture resembling a hardware communication bus,
      and therefore we call it a ``ToolBus''.</para>
    </section>

    <section>
      <title>ToolBus requirements</title>

      <para>Given the motivation for the ToolBus we can briefly summarize the
      requirements that the ToolBus should satisfy:</para>

      <itemizedlist>
        <listitem>
          <para>Provide a flexible interconnection architecture for software
          components that are not only written in different languages and
          executing on different hardware and software platforms, but are also
          running in a distributed fashion on a system of networked computers
          and devices.</para>
        </listitem>

        <listitem>
          <para>Provide good control over the communication between
          components.</para>
        </listitem>

        <listitem>
          <para>The description of communication should be based on existing
          concurrency theory and provide the option for formal verification of
          the cooperation between software components.</para>
        </listitem>

        <listitem>
          <para>Provide relatively simple application descriptions that can be
          understood by most programmers.</para>
        </listitem>

        <listitem>
          <para>Provide a uniform data exchange mechanism between
          heterogeneous components.</para>
        </listitem>

        <listitem>
          <para>Provide multi-lingual support, at least C, Java, ASF+SDF,
          Tcl/Tk, Perl, Python and Ruby should be supported.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The ToolBus architecture</title>

      <para>The global architecture of the ToolBus is shown in <xref
      linkend="figure.toolbus-organization" />. The ToolBus serves the purpose
      of defining the cooperation of a variable number of
      <emphasis>tools</emphasis> <replaceable>T</replaceable><subscript>i
      </subscript>(<replaceable>i</replaceable> = 1, ...,
      <replaceable>m</replaceable>) that are to be combined into a complete
      system. The internal behaviour or implementation of each tool is
      irrelevant: they may be implemented in different programming languages,
      be generated from specifications, etc. Tools may, or may not, maintain
      their own internal state. Here we concentrate on the external behaviour
      of each tool. In general an <emphasis>adapter</emphasis> will be needed
      for each tool to adapt it to the common data representation and message
      protocols imposed by the ToolBus.</para>

      <figure xml:id="figure.toolbus-organization">
        <title>Global organization of the ToolBus</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="architecture.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The ToolBus itself consists of a variable number of processes
      <replaceable>P</replaceable><subscript>i</subscript>
      (<replaceable>i</replaceable> = 1, ...,
      <replaceable>n</replaceable>)<footnote>
          <para>By ``processes'' we mean here computational activities
          <emphasis>inside</emphasis> the ToolBus as opposed to, for instance,
          processes at the operating system level. When confusing might arise,
          we will call the former ``ToolBus processes'' and the latter
          ``operating system level tasks''.</para>
        </footnote>The parallel composition of the processes
      <replaceable>P</replaceable><subscript>i</subscript> represents the
      intended behaviour of the whole system. Tools are external,
      computational activities, most likely corresponding with operating
      system level tasks. They come into existence either by an execution
      command issued by the ToolBus or their execution is initiated
      externally, in which case an explicit connect command has to be
      performed by the ToolBus. Although a one-to-one correspondence between
      tools and processes seems simple and desirable, we do not enforce this
      and permit tools that are being controlled by more than one process as
      well as clusters of tools being controlled by a single process.</para>

      <formalpara>
        <title>Communication inside the ToolBus</title>

        <para>Inside the ToolBus, there are two communication mechanisms
        available. First, a process can send a <emphasis>message</emphasis>
        (using <literal>snd-msg</literal>) which should be received,
        synchronously, by one other process (using
        <literal>rec-msg</literal>). Messages are intended to request a
        service from another process. When the receiving process has completed
        the desired service it may inform the sender, synchronously, by means
        of another message (using <literal>snd-msg</literal>). The original
        sender can receive the reply using <literal>rec-msg</literal>. By
        convention, part of the the original message is contained in the reply
        (but this is not enforced).</para>
      </formalpara>

      <para>Second, a process can send a <emphasis>note</emphasis> (using
      <literal>snd-note</literal>) which is broadcasted to other, interested,
      processes. The sending process does not expect an answer while the
      receiving processes read notes asynchronously (using
      <literal>rec-note</literal>) at a low priority. Notes are intended to
      notify others of state changes in the sending process. Sending notes
      amounts to <emphasis>asynchronous selective broadcasting</emphasis>.
      Processes will only receive notes to which they have
      <emphasis>subscribed</emphasis>.</para>

      <para><figure xml:id="figure.tool-communication">
          <title>Communication between ToolBus and tools</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="tool-protocol.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <formalpara>
        <title>Communication between ToolBus and tools</title>

        <para>The communication between ToolBus and tools is based on
        handshaking communication between a ToolBus process and a tool. A
        process may send messages in several formats to a tool
        (<literal>snd-eval</literal>, <literal>snd-do</literal>, and
        <literal>snd-ack-event</literal>) while a tool may send the messages
        <literal>snd-event</literal> and <literal>snd-value</literal> to a
        ToolBus process. There is no direct communication possible between
        tools. These communication patterns are shown in <xref
        linkend="figure.tool-communication" />.</para>
      </formalpara>

      <para>The execution and termination of the tools attached to the ToolBus
      can be explicitly controlled. It is also possible to connect or
      disconnect tools that have been executing independently of the
      ToolBus.</para>

      <formalpara>
        <title>Knowledge separation</title>

        <para>Equipped with the mechanisms provided by the ToolBus, carefull
        control over application knowledge can be achieved as shown in <xref
        linkend="figure.toolbus-application" /> where an application is
        depicted consisting of a user-interface (UI) and a database (DB). In a
        more conventional approach, elements of the user-interface, say a
        button, would be directly connected with functions in the database
        component and a strong coupling between the two components would be
        the result. Using the ToolBus, the two components can be completely
        oblivious of each other. It is only in the ToolBus script that they
        are configured to work together. The extra level of indirection
        introduced by the ToolBus thus leads to extra flexibility and
        decoupling.</para>
      </formalpara>

      <para><figure xml:id="figure.toolbus-application">
          <title>Knowledge separation in ToolBus-based application</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="application.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>

    <section>
      <title>How to go from here?</title>

      <para>After this brief motivation and explanation of the ToolBus
      architecture it is time to delve into more details. In the remainder of
      this chapter, we will have a look at the following topics:</para>

      <itemizedlist>
        <listitem>
          <para>ToolBus scripts (or Tscripts, for short).</para>
        </listitem>

        <listitem>
          <para>How to write ToolBus tools.</para>
        </listitem>

        <listitem>
          <para>A brief peek at the ToolBus implementation.</para>
        </listitem>

        <listitem>
          <para>Historical notes</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="section.tscripts">
    <title>Tscripts</title>

    <para>Tscripts describe how the tools in an application cooperate. They
    allow the definition of a collection of concurrent processes that can
    communicate with eachother and with the tools in the application.</para>

    <section xml:id="section.terms">
      <title>Terms</title>

      <para>Tscripts make heavy use of <emphasis>terms</emphasis>, simple
      prefix expressions that are used to exchange structured data between
      processes and tools. Terms are recursively defined as follows:</para>

      <itemizedlist>
        <listitem>
          <para>A Boolean constant, integer constant, real constant, or string
          constant is a term, e.g., <literal>true</literal>,
          <literal>37</literal>, <literal>314e-12</literal>, or
          <literal>"rose"</literal>.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>value occurrence</emphasis> of a variable is a
          term, e.g., <literal>X</literal>, <literal>InitialAmount</literal>,
          or <literal>Highest-Bid</literal>.</para>

          <important>
            <para>Variables always start with a capital letter. A value
            occurence serves the purpose of using the current value of a
            variable.</para>
          </important>
        </listitem>

        <listitem>
          <para>A <emphasis>result occurrence</emphasis> of a variable is a
          term, e.g., <literal>X?</literal>, <literal>InItialAmount?</literal>
          or <literal>Highest-Bid?</literal>.</para>

          <important>
            <para>A result occurrence of a variable plays a role when this
            term is <emphasis>matched</emphasis> with another term. In the
            case that the match succeeds, the corresponding part of the other
            term is assigned to the result variable.</para>
          </important>
        </listitem>

        <listitem>
          <para>A single <emphasis>identifier</emphasis> is a term, e.g.,
          <literal>f</literal>, <literal>pair</literal>, or
          <literal>zero</literal>.</para>

          <important>
            <para>Identifier always start with a lowercase letter.</para>
          </important>
        </listitem>

        <listitem>
          <para>A <emphasis>function application</emphasis> is a term, e.g.,
          <literal>pair("rose", address("STREE", 12345)</literal>.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>list</emphasis> is a term, e.g., <literal>[a, b,
          c]</literal> or <literal>[a, 1.25, "lost"]</literal>.</para>
        </listitem>

        <listitem>
          <para>A placeholder is a term, e.g., <literal>&lt;int&gt;</literal>
          or <literal>add(&lt;int&gt;,&lt;int&gt;)</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.matching">
      <title>Matching</title>

      <para>Term matching is used for several purposes in the ToolBus:</para>

      <itemizedlist>
        <listitem>
          <para>To determine which actions can communicate with each other.
          For instance, a <literal>snd-msg</literal> and a
          <literal>rec-msg</literal> can only communicate if their arguments
          match.</para>
        </listitem>

        <listitem>
          <para>To transfer information between sender and receiver.</para>
        </listitem>

        <listitem>
          <para>To do case analysis, for instance, when receiving events from
          a tool.</para>
        </listitem>
      </itemizedlist>

      <para>Intuitively, the matching between two terms works as
      follows:</para>

      <itemizedlist>
        <listitem>
          <para>Two terms match if they are structurally identical.</para>
        </listitem>

        <listitem>
          <para>For a value occurrence of a variable: use its current
          value.</para>
        </listitem>

        <listitem>
          <para>For a result occurrence of a variable: assign the matched
          subterm of the other term to the variable (but make this only
          permanent if the overall match succeeds).</para>
        </listitem>
      </itemizedlist>

      <para>This illustrated in <xref linkend="figure.match-example" />.
      Before the match, two contexts are given. Each context associates some
      variables with a value. For instance, Context 1 associates the value
      <literal>3</literal> with variable <literal>X</literal>. For each
      context a term is given and the challenge is to match these two terms
      and to observe the effects on the two contexts. The matching of the two
      terms can be understood as follows:</para>

      <itemizedlist>
        <listitem>
          <para>The toplevel function names are identical (both
          <literal>f</literal>) and both have the same number of arguments.
          The left term and the right term match if their arguments
          match.</para>
        </listitem>

        <listitem>
          <para>The first argument in the left term is <literal>X</literal>
          and <literal>3</literal> in the right term. Since,
          <literal>X</literal> has value <literal>3</literal> in Context 1,
          they match.</para>
        </listitem>

        <listitem>
          <para>The second argument in the left term is <literal>4</literal>
          and <literal>Z?</literal> in the right term. By assigning
          <literal>4</literal> to <literal>Z</literal> in Context 2 we achieve
          a match.</para>
        </listitem>

        <listitem>
          <para>The third argument in the leftvterm is <literal>Y?</literal>
          and <literal>5</literal> in the right term. Here we achieve a match
          by assigning <literal>5</literal> to <literal>Y</literal> in Context
          1.</para>
        </listitem>

        <listitem>
          <para>The fourth and last argument of both terms is
          <literal>6</literal> and thus matches.</para>
        </listitem>
      </itemizedlist>

      <para>The net result is that both terms match and that Context 1 and
      Context 2 are modified as shown iat the bottom of the figure.</para>

      <para><figure xml:id="figure.match-example">
          <title>Example of term matching</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="match-example.png" scale="40"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>

    <section xml:id="section.types">
      <title>Types</title>

      <para>The ToolBus uses a type system that is a compromise between the
      safety of static checking and the flexibility of dynamic typing. Another
      objective of the type system is to provide sufficient information to
      enable the automatic generation of adapter code for tools. Type are
      defined as follows:</para>

      <itemizedlist>
        <listitem>
          <para><literal>bool</literal>, <literal>int</literal>,
          <literal>real</literal> and <literal>str</literal> are the types of
          the elementary terms.</para>
        </listitem>

        <listitem>
          <para><literal>list</literal> is the type of arbitrary lists.</para>
        </listitem>

        <listitem>
          <para><literal>list(<replaceable>Type</replaceable>)</literal> is
          the type of lists with elements of type
          <replaceable>Type</replaceable>. For instance,
          <literal>list(int)</literal> is the type of lists of
          integers.</para>
        </listitem>

        <listitem>
          <para><replaceable>Id</replaceable> is the type of all terms with
          function symbol <replaceable>Id</replaceable> (this allows the
          declaration of partial types). The type <literal>f</literal>, thus
          corresponds to the terms <literal>f</literal>,
          <literal>f(1)</literal>, <literal>f("abc", 3)</literal> and the
          like.</para>
        </listitem>

        <listitem>
          <para><literal>Id(<replaceable>Type</replaceable><subscript>1</subscript>,
          ...,
          <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript>)</literal>
          is the type of terms with function symbol
          <replaceable>Id</replaceable> and the given types
          <replaceable>Type</replaceable><subscript>1</subscript>, ...,
          <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript>a
          s argument types. For instance, <literal>f(int,str)</literal>
          accepts <literal>f(3,"abc")</literal> but not
          <literal>f(3)</literal>.</para>
        </listitem>

        <listitem>
          <para>[<replaceable>Type</replaceable><subscript>1</subscript>, ...,
          <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript>]
          is the type of a list of elements with the given types
          <replaceable>Type</replaceable><subscript>1</subscript>, ...,
          <replaceable>Type<subscript>n</subscript>.</replaceable> For
          instance, <literal>[int, str]</literal> accepts <literal>[1,
          "abc"]</literal>, but not <literal>[1,2,3]</literal>.</para>
        </listitem>

        <listitem>
          <para><literal>term</literal> is the type of an arbitrary term. And
          is used as escape from the more precise typing by the preceeding
          types.</para>
        </listitem>
      </itemizedlist>

      <para>Types are used in the following ways:</para>

      <itemizedlist>
        <listitem>
          <para>All variables have a type.</para>
        </listitem>

        <listitem>
          <para>Types are statically checked whenever possible. Only in the
          case of type <literal>term</literal>, dynamic checks are
          needed.</para>
        </listitem>

        <listitem>
          <para>Types play a role during matching: a match can also fail if
          the types of corresponding subterms are unequal. For instance, given
          <literal>I</literal> as <literal>int</literal> variable,
          <literal>S</literal> as <literal>str</literal> variable and
          <literal>T</literal> as <literal>term</literal> variable,</para>

          <itemizedlist>
            <listitem>
              <para><literal>f(13)</literal> and <literal>f(I?)</literal> will
              match.</para>
            </listitem>

            <listitem>
              <para><literal>f(13)</literal> and <literal>f(S?)</literal> will
              fail.</para>
            </listitem>

            <listitem>
              <para><literal>f(13)</literal> and <literal>f(T?)</literal> will
              succeed.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.tscript-in-detail">
      <title>Tscripts in detail</title>

      <section xml:id="section.overall-structure-tscripts">
        <title>Overall structure</title>

        <para>A Tscript can define the following ingredients:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>process definition</emphasis> consisting of a
            process name, optional parameters and a process expression that
            describes the behaviour of this process.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>tool definition</emphasis> consisting of a tool
            name and some operational details, such as the command to execute
            when the tool is started.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>ToolBus configuration</emphasis> consisting of
            one or more process names (optionally followed by actual
            parameters) that will be created when the application is started.
            A Tscript may contain more than one ToolBus configuration.</para>
          </listitem>

          <listitem>
            <para>An <emphasis>include file</emphasis> that contains another
            Tscript that will be literally included.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>constant definition</emphasis>.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>conditional</emphasis> that allows the condional
            inclusion or exclusion of parts of the Tscript.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.tscripts-first-example">
        <title>A first example</title>

        <para>Beforer delving into the details of Tscripts, it is good to have
        a look at the hello world application <filename>hello1.tb</filename>
        shown in <xref linkend="example.hello1" />.</para>

        <para><example xml:id="example.hello1">
            <title>hello1.tb</title>

            <programlisting>process HELLO <co xml:id="co.hello1-1" />
is <co xml:id="co.hello1-2" />
  printf(“Hello world, my first Tscript!\n”) <co xml:id="co.hello1-3" />

toolbus(HELLO) <co xml:id="co.hello1-4" /></programlisting>

            <para>Notes:</para>

            <calloutlist>
              <callout arearefs="co.hello1-1">
                <para>Here starts the definition of a process with name
                <literal>HELLO</literal>.</para>
              </callout>

              <callout arearefs="co.hello1-2">
                <para>After the keyword <literal>is</literal> follows the
                process expression that defines the behaviour of this
                process.</para>
              </callout>

              <callout arearefs="co.hello1-3">
                <para>The process expression consists of a single action that
                prints a string.</para>
              </callout>

              <callout arearefs="co.hello1-4">
                <para>Define the initial ToolBus configuration, in this case
                only process HELLO will be started.</para>
              </callout>
            </calloutlist>
          </example></para>

        <para>Running this example will yield the following command line
        dialog:</para>

        <screen>1&gt; toolbus hello1.tb
Hello world, my first Tscript!
2&gt;</screen>

        <para>Becoming more courageous, we show now a more ambituous Tscript
        <literal>hello2.tb</literal> in <xref linkend="example.hello2" /> that
        does not print the hello string itself, but executes a tool to compute
        it.</para>

        <para><example xml:id="example.hello2">
            <title>hello2.tb</title>

            <programlisting>process HELLO is <co xml:id="co.hello2-1" />
  let H : hello, <co xml:id="co.hello2-2" />
      S : str    <co xml:id="co.hello2-3" />
  in
         execute(hello, H?) <co xml:id="co.hello2-4" /> .   <co
                xml:id="co.hello2-5" />
         snd-eval(H, get-text) .   <co xml:id="co.hello2-6" />
         rec-value(H, text(S?)).   <co xml:id="co.hello2-7" />
         printf(S)                 <co xml:id="co.hello2-8" />
  endlet

tool hello is {command = “hello” } <co xml:id="co.hello2-9" />
toolbus(HELLO)                     <co xml:id="co.hello2-10" /></programlisting>

            <para>Notes:</para>

            <calloutlist>
              <callout arearefs="co.hello2-1">
                <para>Define a process <literal>HELLO</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-2">
                <para>Use a <literal>let ... in ... endlet</literal> construct
                to declare local variables. Variable <literal>H</literal> is
                declared with type <literal>hello</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-3">
                <para>Variable <literal>S</literal> is declared with type
                <literal>str</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-4">
                <para>Execute the <literal>hello</literal> tool (according to
                the tool definition at <xref linkend="co.hello2-9" />). The
                resulting tool identifier is assigned to variable
                <literal>H</literal>. Observe that the name of the tool and
                the type of <literal>H</literal> are identical.</para>
              </callout>

              <callout arearefs="co.hello2-5">
                <para>Use the sequential composition operator
                <literal>.</literal> to combine atom actions into a larger
                process expression.</para>
              </callout>

              <callout arearefs="co.hello2-6">
                <para>Send an evaluation request to the tool we have just
                executed. <literal>H</literal> identifies the tool instance,
                and <literal>get-text</literal> is the term to be sent to the
                hello tool.</para>
              </callout>

              <callout arearefs="co.hello2-7">
                <para>In response to the evaluation request, the hello tool
                returns a value of the form <literal>text("Hello world from my
                first tool")</literal>. The actual text is extracted by the
                result variable <literal>S?</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-8">
                <para>Print the string value of <literal>S</literal>.</para>
              </callout>

              <callout arearefs="co.hello2-9">
                <para>The definition for the hello tool. It contains the name
                of an executable program to be run when this tool is
                executed.</para>
              </callout>

              <callout arearefs="co.hello2-10">
                <para>The initial ToolBus configuration consisting of just the
                <literal>HELLO</literal> process.</para>
              </callout>
            </calloutlist>
          </example></para>

        <para>All the Tscript primitives (including the ones that occur in
        these two simple examples) will now be described in more depth.</para>
      </section>

      <section xml:id="section.process-primitives">
        <title>Process primitives</title>

        <para>During execution, the ToolBus consists of a parallel composition
        of processes. The ToolBus configurations define the processes that are
        created at the start of the start of the application, but later on
        processes may die and new ones may be created.</para>

        <para>Each process has a local state in the form of private local
        variables. These variables get their value through assignment and
        matching. They are only visible inside each process.</para>

        <para>Processes are built-in up from atomic actions (detailed below)
        and atomic actions can be combined into process expressions using the
        following operators:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Sequential composition</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> .
            <replaceable>P</replaceable><subscript>2</subscript></literal>.
            First the actions in <replaceable>
            P</replaceable><subscript>1</subscript>are executed and then the
            ones in
            <replaceable>P</replaceable><subscript>2</subscript>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Choice</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> +
            <replaceable>P</replaceable><subscript>2</subscript></literal>. A
            choice is made between the first action in
            <replaceable>P</replaceable><subscript>1</subscript>and the first
            action in <replaceable>P</replaceable><subscript>2</subscript>.
            This choice is based on two criteria:</para>

            <itemizedlist>
              <listitem>
                <para>An action to be selected must be
                <emphasis>enabled</emphasis>.</para>
              </listitem>

              <listitem>
                <para>If more than one action is enabled, a random choice is
                made.</para>
              </listitem>
            </itemizedlist>

            <para>There are various ways in which an action can be enabled
            (this depends on the precise action):</para>

            <itemizedlist>
              <listitem>
                <para>An associated condition evaluates to true (see
                conditional and guarded command, below).</para>
              </listitem>

              <listitem>
                <para>An associated timing constraint is true.</para>
              </listitem>

              <listitem>
                <para>Required external tool results are available.</para>
              </listitem>

              <listitem>
                <para>Communication conditions are satisfied.</para>
              </listitem>
            </itemizedlist>

            <para>Once the choice for the first action has been made all
            remaining actions of the selected process expression
            <replaceable>P</replaceable><subscript>1</subscript> or
            <replaceable>P</replaceable><subscript>2</subscript> are executed
            as well.</para>
          </listitem>

          <listitem>
            <para><emphasis>Parallel composition</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> ||
            <replaceable>P</replaceable><subscript>2</subscript></literal>.
            The actions in
            <replaceable>P</replaceable><subscript>1</subscript>and
            <replaceable>P</replaceable><subscript>2</subscript> are executed
            in parallel. This means that the sequential order of the actions
            in
            <replaceable>P</replaceable><subscript>1</subscript>respectively
            <replaceable>P</replaceable><subscript>2</subscript> is respected
            but that apart from this constraint the actions can be executed in
            arbitrary order.</para>
          </listitem>

          <listitem>
            <para><emphasis>Iteration</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> *
            <replaceable>P</replaceable><subscript>2</subscript></literal>.
            <replaceable>P</replaceable><subscript>1</subscript> is executed
            repeatedly, until an action of
            <replaceable>P</replaceable><subscript>2</subscript> is executed.
            Execution then continues with the remaining actions of
            <replaceable>P</replaceable><subscript>2</subscript>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Conditional</emphasis> <literal>if
            <replaceable>T</replaceable> then
            <replaceable>P</replaceable><subscript>1</subscript> else
            <replaceable>P</replaceable><subscript>2</subscript> fi</literal>.
            The test <replaceable>T</replaceable> is evaluated and if the
            result is true then
            <replaceable>P</replaceable><subscript>1</subscript> is executed,
            otherwise <replaceable>P</replaceable><subscript>2</subscript> is
            executed. Note that the evaluation of the test does not count as a
            separate atomic action; the test is effectively attached to the
            first atom of
            <replaceable>P</replaceable><subscript>1</subscript>respectively
            <replaceable>P</replaceable><subscript>2</subscript>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Guarded command</emphasis> <literal>if
            <replaceable>T</replaceable> then <replaceable>P</replaceable>
            fi</literal>. The test <replaceable>T</replaceable> is evaluated
            and if the result is true then
            <replaceable>P</replaceable><subscript>1</subscript> is executed,
            otherwise this command deadlocks.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.local-variables">
        <title>Local variables</title>

        <para>As we have seen local variables play a key role in the execution
        of Tscripts. They are defined using the <literal>let</literal>
        construct:</para>

        <itemizedlist>
          <listitem>
            <para>let Var1 : Type1, ... in P endlet. Variables Var1, ... are
            declared with respective type Type1, .... These variables act as
            local variables during the execution of the process expression P.
            P may contain other <literal>let</literal> constructs.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.primitive-actions">
        <title>Primitive actions</title>

        <itemizedlist>
          <listitem>
            <para><emphasis>Deadlock</emphasis> <literal>delta</literal>. This
            constant represents the process that cannot execute any further
            steps. During execution deadlock is always avoided as long as this
            is possible. A process that end in deadlock effectively terminates
            and disappears.</para>
          </listitem>

          <listitem>
            <para><emphasis>Silent step</emphasis> <literal>tau</literal>.
            This constant represents one internal step in a process and
            resemble a dummy statement in a conventional programming
            language.</para>
          </listitem>

          <listitem>
            <para>Print printf. An action for generating formatted
            output.</para>
          </listitem>

          <listitem>
            <para><emphasis>Assignment</emphasis>
            <literal><replaceable>V</replaceable> :=
            <replaceable>T</replaceable></literal>. The term
            <literal>T</literal> is evaluated as expression (using the
            built-in functions) and the result is assigned to the local
            variable <replaceable>V</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.messages">
        <title>Messages: synchronous communication primitives</title>

        <para>Synchronous communication resembles an ordinary phone call: it
        involves two processes that can communicate at the same instant in
        time. In ToolBus terminology <emphasis>messages</emphasis> are used
        for synchronous communication. There are two primitives
        involved:</para>

        <itemizedlist>
          <listitem>
            <para><literal>snd-msg</literal> sends a message to another
            process.</para>
          </listitem>

          <listitem>
            <para><literal>rec-msg</literal> receives a message from another
            process.</para>
          </listitem>
        </itemizedlist>

        <para>Two requirements have to be satisfied before communication can
        take place:</para>

        <itemizedlist>
          <listitem>
            <para>The arguments of <literal>snd-msg</literal> and
            <literal>rec-msg</literal> match with each other.</para>
          </listitem>

          <listitem>
            <para>In addition, <literal>snd-msg</literal> respectively
            <literal>rec-msg</literal> are enabled in each process.</para>
          </listitem>
        </itemizedlist>

        <para>When communication takes place, the effects of the argument
        matching is recorded in the local state of each process and both
        continue execution. The observant reader may have noticed that sending
        and receiving is actually symmetric: by way of result variablesin the
        arguments of <literal>snd-msg</literal> and <literal>rec-msg</literal>
        information may flow from sender to receiver and <emphasis>vice
        versa</emphasis>.</para>
      </section>

      <section xml:id="section.notes">
        <title>Notes: asynchronous broadcasting primitives</title>

        <para>Asynchronous communication resembles conventional e-mail: it
        involves one sending and zero or more receiving processes that read
        the communicated information at a later instant in time. In ToolBus
        terminology <emphasis>notes</emphasis> are used for asynchronous
        communication. There four primitives involved:</para>

        <itemizedlist>
          <listitem>
            <para><literal>subscribe(<replaceable>T</replaceable>)</literal>.
            Subscribes a process to notes that match the term
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>unsubscribe(<replaceable>T</replaceable>)</literal>.
            Unsubscribes a process from notes that match
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>snd-note(<replaceable>T</replaceable>)</literal>.
            Broadcast the term <replaceable>T</replaceable> to all subscribed
            processes. Effectively, <replaceable>T</replaceable> is placed in
            the private inbox of each subscribed process to be read at a later
            moment.</para>
          </listitem>

          <listitem>
            <para><literal>rec-note(<replaceable>T</replaceable>)</literal>.
            Receive a note that matches <replaceable>T</replaceable>.
            Effectively, the private inbox is searched for a note that matches
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>no-note(<replaceable>T</replaceable>)</literal>.
            There is no note that matches <replaceable>T</replaceable> in the
            private inbox.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.named-processes">
        <title>Using named processes</title>

        <para>A process definition associates a name
        <replaceable>Pnm</replaceable> (optinally followed by parameters) with
        a process expression <replaceable>P</replaceable>. These process names
        can be used in two ways in process expressions:</para>

        <itemizedlist>
          <listitem>
            <para>An <emphasis>inline process expression</emphasis>
            <literal><replaceable>Pnm</replaceable>(...)</literal>:
            Effectively, this amount to macro substitution:
            <replaceable>Pnm</replaceable> is replaced by the process
            expression <replaceable>P</replaceable> (after proper parameter
            substitution).</para>
          </listitem>

          <listitem>
            <para>A <emphasis>process creation</emphasis>
            <literal>create(<replaceable>Pnm</replaceable>(...),
            <replaceable>Pid</replaceable>?)</literal>: a completely new
            process is created that runs in parallel with all other processes
            currently running in the ToolBus. The process identifier of this
            new process is assigned to <replaceable>Pid</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.tool-primitives">
        <title>Tool primitives</title>

        <para>There two possible scenarios for a ToolBus tool. In scenario 1,
        the tool is executed from the ToolBus, the tool receives a number of
        evaluation requests and/or generates an number of events, and finally,
        the ToolBus decides to terminate the execution of the tool. A
        variation of scenario 1 is that the tool decides to disconnect from
        the ToolBus and continues execution disconnect from the ToolBus
        application. In scenario 2, the tool is executed separately and
        startes its cooperation by requesting a connection with the ToolBus.
        Once connected, it follows the same steps as in scenario 1. The
        following primitives achieve this (also see <xref
        linkend="figure.tool-communication" /> for the various communication
        patterns between ToolBus and tools):</para>

        <itemizedlist>
          <listitem>
            <para><literal>execute(<replaceable>Tnm</replaceable>,
            <replaceable>Tid</replaceable>?)</literal>: Execute a tool with
            name <replaceable>Tnm</replaceable>. The result is a
            <emphasis>tool identifier</emphasis> that is bound to
            <replaceable>Tid</replaceable>. Tool indentifiers are unique; if
            more than one instance of the same tool is executing they can be
            distinguished via their tool indentifier. There are two additional
            constraints:</para>

            <itemizedlist>
              <listitem>
                <para>The Tscript should contain a tool definition for
                <replaceable>Tnm</replaceable>.</para>
              </listitem>

              <listitem>
                <para>The variable Tid should have a type that corresponds
                with the tool name, i.e., it should be declared as
                <literal><replaceable>Tid</replaceable> :
                <replaceable>Tnm</replaceable></literal>. Why? Well this in
                this way the implementation can track via the type of the tool
                indentifier in each tool request, <emphasis>which</emphasis>
                tool it is and that information is essential for the automatic
                generation of adapter code.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><literal>snd-terminate(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: terminates the execution
            of the tool instance <replaceable>Tid</replaceable>. The term
            <replaceable>T</replaceable> contains a reason for the termination
            and is usually printed by the tool on termination.</para>
          </listitem>

          <listitem>
            <para><literal>rec-connect(<replaceable>Tnm</replaceable>,
            <replaceable>Tid</replaceable>?)</literal>: receive a connection
            request for a tool with name <replaceable>Tnm</replaceable>.
            <literal>rec-connect</literal> is very similar to
            <literal>execute</literal>. The only difference is the initiating
            party: for <literal>execute</literal> the ToolBus and for
            <literal>rec-connect</literal> the tool.</para>
          </listitem>

          <listitem>
            <para><literal>rec-disconnect(<replaceable>Tid</replaceable>?)</literal>:
            receive a disconnection request from a tool. It does not matter
            whether the connection with the tool was originally established
            via <literal>execute</literal> or
            <literal>rec-connect</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>snd-eval(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: send an evaluation
            request to a tool. All value occurrences in
            <replaceable>T</replaceable> are first replaced by their value
            before sending <replaceable>T</replaceable> to the tool. It is up
            to the tool to interpret the term. The usual scenario is that the
            outermost function symbol of <replaceable>T</replaceable> is
            identical to the name of a procedure in the tool and that that
            procedure is called. The ToolBus can only send one evaluation
            request at a time. Only when the request is cancelled, or a value
            is returned by the tool, the next request can be sent to the
            tool.</para>
          </listitem>

          <listitem>
            <para><literal>snd-cancel(<replaceable>Tid</replaceable>)</literal>:
            cancel a previous evaluation request.</para>
          </listitem>

          <listitem>
            <para><literal>rec-value(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: recieve a value from a
            tool in response to a previous <literal>snd-eval</literal>
            request. <replaceable>T</replaceable> has to match the value from
            the tool; this is usefull for case distinctions. In many case, T
            consists of a single result variable, or a is a term that contains
            result variables.</para>
          </listitem>

          <listitem>
            <para><literal>snd-do(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: send an evaluation
            request to a tool but do not expect a return value. Typically used
            to implement printing or logging activities.</para>
          </listitem>

          <listitem>
            <para><literal>rec-event(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable><subscript>1</subscript>,
            ...)</literal>: receive an event from a tool. Events need not be
            handled one-by-one. The same tool may generate more than one event
            provided that the value of argument
            <replaceable>T</replaceable><subscript>1</subscript> differs.
            <replaceable>T</replaceable><subscript>1</subscript> thus serves
            as identification for this event.</para>
          </listitem>

          <listitem>
            <para><literal>snd-ack-event(<replaceable>Tid</replaceable>,
            <replaceable><replaceable>T</replaceable><subscript>1</subscript></replaceable>)</literal>:
            acknowledge the completion of the handling of a previous event.
            Since, <replaceable>T</replaceable><subscript>1</subscript> is
            identical to the
            <replaceable>T</replaceable><subscript>1</subscript> in a
            preceeding <literal>snd-event</literal> and is used to identify
            that event.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.timing-primitives">
        <title>Timing primitives</title>

        <para>Time can play an important role in applications, be it as
        ingredient in a protocol that prescribes certain time constraints, be
        it as watchdog that certain operations are carried out in time. The
        general approach in Tscripts is that a delay or timeout may be
        attached to every atom action. Delays and timeouts may be relative to
        the current time or they may be specified in absolute time. The
        primitives are as follows (for arbitrary atomic action
        <replaceable>A</replaceable>):</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Relative delay</emphasis>:
            <literal><replaceable>A</replaceable>
            delay(<replaceable>E</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> can only become enabled after
            <replaceable>E</replaceable><replaceable> </replaceable>seconds
            have passed.</para>
          </listitem>

          <listitem>
            <para><emphasis>Absolute delay</emphasis>:
            <literal><replaceable>A</replaceable>
            abs-delay(<replaceable>Year</replaceable>,
            <replaceable>Month</replaceable>, <replaceable>Day</replaceable>,
            <replaceable>Hour</replaceable>, <replaceable>Min</replaceable>,
            <replaceable>Sec</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> can only become enabled after the
            specified absolute date and time.</para>
          </listitem>

          <listitem>
            <para><emphasis>Relative timeout</emphasis>:
            <literal><replaceable>A</replaceable>
            timeout(<replaceable>E</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> is only enabled during the next
            <replaceable>E</replaceable> seconds.</para>
          </listitem>

          <listitem>
            <para><emphasis>Absolute timeout</emphasis>:
            <literal><replaceable>A</replaceable>
            abs-timeout(<replaceable>Year</replaceable>,
            <replaceable>Month</replaceable>, <replaceable>Day</replaceable>,
            <replaceable>Hour</replaceable>, <replaceable>Min</replaceable>,
            <replaceable>Sec</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> is only enabled until the specified
            absolute date and time.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="section.expressions">
        <title>Expressions</title>

        <para>Terms can occur in Tscripts on various locations. In the
        majority of cases these terms are used as such; only variables are
        replaced by their value but no further evaluation of terms take place.
        There are, however, two exceptions to this general rule. In three
        cases, terms are evaluated:</para>

        <itemizedlist>
          <listitem>
            <para>The test in <literal>if <replaceable>T</replaceable> then
            ... fi</literal> and <literal>if <replaceable>T</replaceable> then
            ... else ... fi</literal>.</para>
          </listitem>

          <listitem>
            <para>The right-hand side of the assignment
            <literal><replaceable>V</replaceable> :=
            <replaceable>T</replaceable></literal>.</para>
          </listitem>

          <listitem>
            <para>In delays or timeouts.</para>
          </listitem>
        </itemizedlist>

        <para>The term is evaluated in a bottom-up manner, i.e., first
        aguments are evaluated and then the function is applied. Here are some
        examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>not(true)</literal> evaluates to
            <literal>false</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>add(mul(2,3), 4)</literal> evaluates to
            <literal>9</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>greater(6,5)</literal> evaluates to
            <literal>true</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>first([9, 8, 7])</literal> evaluates to
            <literal>9</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>A detailed overview of all built-in functions is given in XXX.
        They can be summarized as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Functions on <emphasis>Booleans</emphasis>:
            <literal>not</literal>, <literal>and</literal>,
            <literal>or</literal>.</para>
          </listitem>

          <listitem>
            <para>Functions on <emphasis>Integers</emphasis>:
            <literal>add</literal>, <literal>sub</literal>,
            <literal>mul</literal>, <literal>mod</literal>,
            <literal>less</literal>, <literal>less-equal</literal>,
            <literal>greater</literal>,
            <literal>greater-equal</literal>.</para>
          </listitem>

          <listitem>
            <para>Functions on <emphasis>lists</emphasis>:
            <literal>first</literal>, <literal>next</literal>,
            <literal>get</literal>, <literal>put</literal>,
            <literal>join</literal>, <literal>member</literal>,
            <literal>subset</literal>, <literal>diff</literal>,
            <literal>inter</literal>, <literal>size</literal>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Miscellaneous</emphasis> functions:
            <filename>equal</filename>, <literal>not-equal</literal>,
            <literal>process-id</literal>, <literal>process-name</literal>,
            <literal>current-time</literal>, <literal>quote</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section xml:id="section.tscript-examples">
    <title>Examples of Tscripts</title>

    <para>We are now ready to have a look at some larger examples of
    Tscripts.</para>

    <section xml:id="section.example-calculator">
      <title>Calculator</title>

      <para>The calculator example illustrates how a calculator tool that can
      compute simple arithmetic expressions is shared by cooperating
      processes. The overall architecture is shown in <xref
      linkend="figure.clock-architecture" />. The application consists of the
      following 5 processes:</para>

      <itemizedlist>
        <listitem>
          <para><literal>CALC</literal>: the calculator
          <emphasis>process</emphasis> that regulates the access to the
          calculator <emphasis>tool</emphasis> <literal>calc</literal>, see
          <xref linkend="example.CALC" />.</para>
        </listitem>

        <listitem>
          <para><literal>BATCH</literal>: a batch process that uses the tool
          <literal>batch</literal> to read an expression from file, calculate
          its value and write the result back to file, see <xref
          linkend="example.BATCH" />.</para>
        </listitem>

        <listitem>
          <para><literal>UI</literal>: a user-interface process that uses the
          tool ui to allow a user to enter an expression and get its value
          back, see <xref linkend="example.UI" />. Observe that the processes
          <literal>BATCH</literal> and <literal>UI</literal> are both
          competing for the shared resource calculator (implemented by the
          process <literal>CALC</literal> and the tool
          <literal>calc</literal>).</para>
        </listitem>

        <listitem>
          <para><literal>LOG</literal>: a logging process that maintains a log
          of all calculations that have been performed by the application, see
          <xref linkend="example.LOG" />.</para>
        </listitem>

        <listitem>
          <para><literal>CLOCK</literal>: a clock process that uses the tool
          <literal>clock</literal> to provide the current time, see <xref
          linkend="example.CLOCK" />.</para>
        </listitem>
      </itemizedlist>

      <para xml:id="figure.calc-gui"><figure
          xml:id="figure.clock-architecture">
          <title>Architecture of the clock application</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="clock-architecture.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure><example xml:id="example.CALC">
          <title>Process <literal>CALC</literal> and tool
          <literal>calc</literal></title>

          <para><programlisting>process CALC is
    let Tid : calc, E : str, V : term
    in
         execute(calc, Tid?). <co xml:id="co.calc.1" />
          (<co xml:id="co.calc.2" />
              rec-msg(compute, E?) . <co xml:id="co.calc.3" />
              snd-eval(Tid, expr(E)) . rec-value(Tid, val(V?)) . <co
                xml:id="co.calc.4" />
               snd-msg(compute, E, V) . snd-note(compute(E, V))  <co
                xml:id="co.calc.5" />
           )* delta <co xml:id="co.calc.6" />
    endlet

tool calc is { command = “calc”}</programlisting>Notes:<calloutlist>
              <callout arearefs="co.calc.1">
                <para>Execute the <literal>calc</literal> tool. The tool
                identifier is assigned to the variable <literal>Tid</literal>,
                that is of type <literal>calc</literal>.</para>
              </callout>

              <callout arearefs="co.calc.2">
                <para>Begin of endless loop.</para>
              </callout>

              <callout arearefs="co.calc.3">
                <para>Receive a compute message.</para>
              </callout>

              <callout arearefs="co.calc.4">
                <para>Send an evaluation request to the
                <literal>calc</literal> tool and receive its value
                back.</para>
              </callout>

              <callout arearefs="co.calc.5">
                <para>Send a reply to the original compute request. By
                convention, the original message is included in the reply.
                Also send a note regarding this (expression,result) pair for
                the sake of logging.</para>
              </callout>

              <callout arearefs="co.calc.6">
                <para>End of the endless loop.</para>
              </callout>
            </calloutlist></para>
        </example><example xml:id="example.BATCH">
          <title>Process <literal>BATCH</literal> and tool
          <literal>batch</literal></title>

          <para><programlisting>process BATCH is
    let Tid : batch, E : str, V : int
    in
         execute(batch, Tid?).
         (
             snd-eval(Tid, fromFile) . rec-value(Tid, expr(E?)) . <co
                xml:id="co.batch.1" />
             snd-msg(compute, E) . rec-msg(compute, E, V?) .      <co
                xml:id="co.batch.2" />
             snd-do(Tid, toFile(E, V))  <co xml:id="co.batch.3" />
          ) * delta
    endlet

tool batch is {command = “batch”}</programlisting>Notes:<calloutlist>
              <callout arearefs="co.batch.1">
                <para>Send an evaluation request to the
                <literal>batch</literal> tool and receive an expression
                back.</para>
              </callout>

              <callout arearefs="co.batch.2">
                <para>Communicate with the <literal>CALC</literal> process
                (and thus with the <literal>calc</literal> tool) to get the
                expression evaluated.</para>
              </callout>

              <callout arearefs="co.batch.3">
                <para>Send the result back to the <literal>batch</literal>
                tool.</para>
              </callout>
            </calloutlist></para>
        </example>The user-interface is shown in <xref
      linkend="figure.calc-gui" /> and behaves as follows:</para>

      <itemizedlist>
        <listitem>
          <para>When the user presses <guimenuitem>Calc</guimenuitem>, a
          dialog window appears to enter an expression. The result is shown in
          a separate window. See <xref linkend="figure.calc-dialog" />.</para>
        </listitem>

        <listitem>
          <para>Pressing <guimenuitem>showLog</guimenuitem> displays all
          calculations sofar.</para>
        </listitem>

        <listitem>
          <para>Pressing <guimenuitem>showTime</guimenuitem> displays the
          current time in a separate window.</para>
        </listitem>

        <listitem>
          <para>Pressing <guimenuitem>Quit</guimenuitem> end the
          application.</para>
        </listitem>
      </itemizedlist>

      <para><figure>
          <title>The calc GUI</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="calc-gui.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure><example xml:id="example.UI">
          <title>Process <literal>UI</literal> and tool
          <literal>ui</literal></title>

          <para><programlisting>process UI is
    let Tid : ui
    in
            execute(ui, Tid?) .
            ( CALC-BUTTON(Tid) + LOG-BUTTON(Tid))* delta <co xml:id="co.UI.1" />
             ||
             TIME-BUTTON(Tid) * delta <co xml:id="co.UI.2" />
             ||
             QUIT-BUTTON(Tid) <co xml:id="co.UI.3" />
    endlet

tool ui is { command = wish-adapter -script calc.tcl” }</programlisting>Notes:<calloutlist>
              <callout arearefs="co.UI.1">
                <para><literal>CALC-BUTTON</literal> and
                <literal>LOG-BUTTON</literal> are mutually exclusive and they
                can be activated indefinitely.</para>
              </callout>

              <callout arearefs="co.UI.2">
                <para><literal>TIME-BUTTON</literal> is independent and can
                also be repeated indefinitely.</para>
              </callout>

              <callout arearefs="co.UI.3">
                <para><literal>QUIT-BUTTON</literal> is also independent but
                be activated only once (for obvious reasons).</para>
              </callout>
            </calloutlist>Also observe the extensive use of named process
          expressions like <literal>CALC-BUTTON</literal>, etc. to give an
          high-level overview of the <literal>UI</literal> process. See <xref
          linkend="example.CALC-BUTTON" />, <xref
          linkend="example.LOG-BUTTON" />, <xref
          linkend="example.TIME-BUTTON" />, and <xref
          linkend="example.QUIT-BUTTON" /> for their definitions.</para>
        </example><example xml:id="example.CALC-BUTTON">
          <title>Process <literal>CALC-BUTTON</literal></title>

          <para><programlisting>process CALC-BUTTON(Tid : ui) is
    let N : int, E : str, V : term
    in
            rec-event(Tid, N?, button(calc)) . <co xml:id="co.CALC-BUTTON.1" />
            snd-eval(Tid, get-expr-dialog) .   <co xml:id="co.CALC-BUTTON.2" />
            (  rec-value(Tid, cancel)          <co xml:id="co.CALC-BUTTON.3" />
            +  rec-value(Tid, expr(E?)) .      <co xml:id="co.CALC-BUTTON.4" />
                snd-msg(compute, E) .
                rec-msg(compute, E, V?) .
                 snd-do(Tid, display-value(V)) <co xml:id="co.CALC-BUTTON.5" />
            ) . snd-ack-event(Tid, N)          <co xml:id="co.CALC-BUTTON.6" />
    endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.CALC-BUTTON.1">
                <para>The <guimenuitem>Calc</guimenuitem> button is pressed;
                the <literal>ui</literal> tool generates an event.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.2">
                <para>Ask the <literal>ui</literal> tool for an expression,
                see <xref linkend="figure.calc-dialog" /> for examples.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.3">
                <para>The user cancels the dialog; no further actions are
                needed.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.4">
                <para>The user has entered an expression. Communicate with the
                CALC process to compute a value.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.5">
                <para>Ask the <literal>ui</literal> tool to display the
                value.</para>
              </callout>

              <callout arearefs="co.CALC-BUTTON.6">
                <para>Acknowledge the event to the tool.</para>
              </callout>
            </calloutlist></para>
        </example><figure xml:id="figure.calc-dialog">
          <title>Dialog resulting from <literal>CALC-BUTTON</literal></title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="calc-dialog.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure><example xml:id="example.LOG-BUTTON">
          <title>Process <literal>LOG-BUTTON</literal></title>

          <para><programlisting>process LOG-BUTTON(Tid : ui) is
    let N : int, L : term
    in
            rec-event(Tid, N?, button(showLog)) .
            snd-msg(showLog) .
            rec-msg(showLog, L?) .
            snd-do(Tid, display-log(L)) .
            snd-ack-event(Tid, N)
    endlet</programlisting></para>
        </example><example xml:id="example.TIME-BUTTON">
          <title>Process <literal>TIME-BUTTON</literal></title>

          <para><programlisting>process TIME-BUTTON(Tid : ui) is
    let N : int, T : str
    in     rec-event(Tid, N?, button(showTime)) .
            snd-msg(showTime) .
            rec-msg(showTime, T?) .
            snd-do(Tid, display-time(T)) .
            snd-ack-event(Tid, N)
    endlet</programlisting></para>
        </example><example xml:id="example.QUIT-BUTTON">
          <title>Process <literal>QUIT-BUTTON</literal></title>

          <para><programlisting>process QUIT-BUTTON(Tid : ui) is
        rec-event(Tid, button(quit)) .
        shutdown("End of calc demo")</programlisting></para>
        </example><example xml:id="example.LOG">
          <title>Process <literal>LOG</literal> and tool
          <literal>log</literal></title>

          <para><programlisting>process LOG is
    let Tid : log, E : str, V : term, L : term
    in    subscribe(compute(&lt;str&gt;, &lt;term&gt;)) .
            execute(log, Tid?).
                (       rec-note(compute(E?, V?)) . <co xml:id="co.LOG.1" />
                        snd-do(Tid, writeLog(E, V))
                +
                        rec-msg(showLog) .          <co xml:id="co.LOG.2" />
                        snd-eval(Tid, readLog) .
                        rec-value(Tid, history(L?)) .
                        snd-msg(showLog, history(L))
                ) * delta
    endlet</programlisting>Notes:<calloutlist>
              <callout arearefs="co.LOG.1">
                <para>Receive a note about a computation that has taken place
                and log it.</para>
              </callout>

              <callout arearefs="co.LOG.2">
                <para>Receive a message to show the value of the current log.
                Retrieve it from the <literal>log</literal> tool and return
                the result.</para>
              </callout>
            </calloutlist></para>

          <para>An alternnative way to describe the LOG process is shown in
          <xref linkend="example.LOG1" />. Instead of running a separate log
          tool, the process LOG1 maintains the log in a local process variable
          TheLog. See <xref linkend="section.built-in-functions" /> for a
          description of the function <literal>join</literal> that is used
          this example.</para>
        </example><example xml:id="example.LOG1">
          <title>Process <literal>LOG1</literal>: maintaining the log inside
          the ToolBus</title>

          <para><programlisting>process LOG1 is
    let TheLog : list, E : str, V : term
    in      subscribe(compute(&lt;str&gt;, &lt;term&gt;)) .
            TheLog := [] .
                (       rec-note(compute(E?, V?)) .
                        TheLog := join(TheLog, [[E, V]])
                 +
                        rec-msg(showLog) .
                        snd-msg(showLog, TheLog)
                ) * delta
    endlet</programlisting></para>
        </example><example xml:id="example.CLOCK">
          <title>Process <literal>CLOCK</literal> and tool
          <literal>clock</literal></title>

          <para><programlisting>process CLOCK is
    let Tid : clock, T : str
    in
            execute(clock, Tid?).
             (     rec-msg(showTime) .
                    snd-eval(Tid, readTime) .
                    rec-value(Tid, time(T?)) .
                    snd-msg(showTime, T)
              ) * delta
    endlet</programlisting></para>
        </example>The comple ToolBus configurations that describes the start
      of the calculator demo is shown in <xref
      linkend="example.calculator-toolbus-configuration" />. It starts the
      mentioned processes in parallel and from that moment on user-interaction
      and the activities of the BATCH process will drive the
      execution.<example xml:id="example.calculator-toolbus-configuration">
          <title>ToolBus configuration for calculator demo</title>

          <para><programlisting>toolbus (CALC, BATCH, UI, LOG, CLOCK)</programlisting></para>
        </example></para>
    </section>

    <section xml:id="section.example-auction">
      <title>Auction</title>

      <para>In the <emphasis>classical auction</emphasis>, the auction master
      and all bidders are in the same room and interact with each other
      according to a fixed protocol. It is shown in <xref
      linkend="figure.classical-auction" />. The steps in the protocol
      are:</para>

      <orderedlist>
        <listitem>
          <para>The auction master introduces a new item for sale and sets an
          initial price for it.</para>
        </listitem>

        <listitem>
          <para>Next, bidders raise their hand and shout a new bid that is to
          be acknowledged by the auction master.</para>
        </listitem>

        <listitem>
          <para>Step 2 is repeated as long as new bids come in.</para>
        </listitem>

        <listitem>
          <para>When no new bids are being made, the auction master asks for
          "any higher bid?" and waits during a fixed period.</para>
        </listitem>

        <listitem>
          <para>If no new bids come in during this period, the auction master
          declares the item for sale to be sold to the highest bidder.</para>
        </listitem>

        <listitem>
          <para>If a new bid comes in during this period, the procedure
          continues with step 2.</para>
        </listitem>
      </orderedlist>

      <para><figure xml:id="figure.classical-auction">
          <title>Classical auction</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="classic-auction.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>A striking aspect of the classical auction is that the
      auction master and the bidders can <emphasis>see</emphasis> each other.
      This is a great communication and synchronization tool. In the case of a
      <emphasis>distributed auction</emphasis>, auction master and bidders are
      on different locations and can only communicate via the Internet, see
      <xref linkend="figure.distributed-auction" />.</para>

      <para><figure xml:id="figure.distributed-auction">
          <title>Distributed auction</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="distributed-auction.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The communication and synschronization in a distrubuted auction
      has to be described explicitly and requires answers to questions
      like:</para>

      <itemizedlist>
        <listitem>
          <para>How are bids synchronized?</para>
        </listitem>

        <listitem>
          <para>How to inform bidders about the highest bid?</para>
        </listitem>

        <listitem>
          <para>How to decide when bidding is over and the item is to be
          sold?</para>
        </listitem>

        <listitem>
          <para>How to handle bidders that come and go during the
          auction?</para>
        </listitem>
      </itemizedlist>

      <para>The auction application to be described answers these questions
      and has an architecture as shown in <xref
      linkend="figure.auction-architecture" />.</para>

      <para><figure xml:id="figure.auction-architecture">
          <title>Architecture of the auction application</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="auction-architecture.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para></para>
    </section>

    <section xml:id="section.example-wave">
      <title>Wave</title>

      <para></para>
    </section>
  </section>

  <section xml:id="section.executing-toolbus-and-tools">
    <title>Executing Toolbus and tools</title>

    <para>The ToolBus interpreter (<command>toolbus</command>) and all tools
    have some standard program arguments in common, but they have some
    specific arguments as well. In this section we describe all possible
    program arguments and the way to execute <command>toolbus</command> and
    tools.</para>

    <section xml:id="section.common-arguments">
      <title>Common arguments</title>

      <para>ToolBus and tools have the following optional arguments in
      common:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-help</literal>: prints a description of all
          arguments of the toolbus or tool.</para>
        </listitem>

        <listitem>
          <para><literal>-verbose</literal>: produces a log of steps taken by
          toolbus or tool that may be useful to debug your script or tool. The
          same effect may be obtained by setting the environment variable
          <literal>TB_VERBOSE</literal> to <literal>true</literal> and export
          it. In the Korn shell this can, for instance, be achieved by:
          <programlisting>TB_VERBOSE=true 
export TB_VERBOSE</programlisting></para>
        </listitem>

        <listitem>
          <para><literal>-TB_PORT
          <replaceable>port_name</replaceable></literal>: defines the
          <emphasis>well known socket</emphasis> <literal>port_name</literal>
          to which all tools temporarily connect in order to set up their own
          private socket that connects them permanently to the ToolBus
          interpreter. When omitted, socket 8998 will be used.</para>
        </listitem>
      </itemizedlist>

      <para>Note that explicit arguments defining the sockets are
      <emphasis>only</emphasis> needed when several ToolBus interpreters are
      running simultaneously on the <emphasis>same</emphasis> host
      machine.</para>
    </section>

    <section xml:id="section.toolbus-arguments">
      <title>ToolBus arguments</title>

      <para>The <replaceable>script_name</replaceable> (see below) given as
      argument to the ToolBus is always preprocessed by a preprocessor before
      it is parsed as a Tscript. In this way, directives like, e.g.,
      <literal>#define</literal>, <literal>#include</literal> and
      <literal>#ifdef</literal> can be used freely in Tscripts. The following
      preprocessor arguments are accepted by the <command>toolbus</command>
      command:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-I<replaceable>dir</replaceable></literal>: append
          directory <literal><replaceable>dir</replaceable></literal> to the
          list of directories searched for include files.</para>
        </listitem>

        <listitem>
          <para><literal>-D<replaceable>name</replaceable></literal>: defines
          <literal><replaceable>name</replaceable></literal> with the string
          <literal>"1" </literal>as its definition.</para>
        </listitem>

        <listitem>
          <para><literal>D<replaceable>name</replaceable>=<replaceable>defn</replaceable></literal>:
          defines <literal><replaceable>name</replaceable></literal> with
          <literal><replaceable>defn</replaceable></literal> as
          definition.</para>
        </listitem>
      </itemizedlist>

      <para>Other arguments specific for the ToolBus command are:</para>

      <warning>
        <para>The following arguments will probably be supported differently
        in ToolBusNG.</para>
      </warning>

      <itemizedlist>
        <listitem>
          <para><literal>-logger</literal>: execute a logger tool that will be
          attached to all processes in the ToolBus. If the script contains a
          tool definition for a tool named <literal>logger</literal>, that
          will be used for executing the logger. Otherwise a default tool
          definition is used.</para>
        </listitem>

        <listitem>
          <para><literal>-viewer</literal>: similar as above, for a viewer
          tool. The default viewer is the ``ToolBus viewer'' (previously known
          as the ToolBus debugger).</para>
        </listitem>

        <listitem>
          <para><literal>-controller</literal>: similar as above, for a
          controller tool. Currently, no default controller tool is
          provided.</para>
        </listitem>

        <listitem>
          <para><literal>-gentifs</literal>: only generate tool interfaces for
          all tools used in the script in a language independent format. For a
          script file named <filename>script.tb</filename> the tool interfaces
          are written to <filename>script.tifs</filename>. Do not execute the
          script.</para>
        </listitem>

        <listitem>
          <para><literal>-fixed-seed</literal>: use a fixed seed for the
          random generator used by the interpreter for scheduling processes
          and selecting alternatives in processes. By default, the random
          generator is initialized with the current time the
          <command>toolbus</command> command is given. Using the
          <literal>-fixed-seed</literal> option makes the execution of the
          script reproducible across multiple runs of the
          <command>toolbus</command> command.</para>
        </listitem>

        <listitem>
          <para><literal><replaceable>script_name</replaceable></literal>: any
          other argument is the name of the ToolBus script to be
          interpreted.</para>
        </listitem>
      </itemizedlist>

      <para>As an example, consider first <programlisting>toolbus hello.tb</programlisting>which
      starts interpreting the script <filename>hello.tb</filename>. Next,
      consider<programlisting>toolbus -TB_PORT 4000 hello.tb</programlisting>which
      interprets the same script, but uses socket <literal>4000</literal> to
      find the ToolBus. Next, consider <programlisting>toolbus -Imy-include-dir -DCNT=33 wave.tb</programlisting>which
      searches the directory <filename>my-include-dir</filename> for files
      used in <literal>#include</literal> directives in the script
      <filename>wave.tb</filename> and it will define the name
      <literal>CNT</literal> with value <literal>33</literal>. All occurrences
      of <literal>CNT</literal> in the script will be replaced by this value
      before parsing it as a Tscript. Finally, <programlisting>toolbus -gentifs hello.tb </programlisting>produces
      the tool interfaces file <filename>hello.tifs</filename>.</para>
    </section>

    <section xml:id="section.tool-arguments">
      <title>Tool arguments</title>

      <para>Arguments specific for tools are:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-TB_HOST
          <replaceable>host_name</replaceable></literal>: defines the host
          machine <literal><replaceable>host_name</replaceable></literal> on
          which the ToolBus interpreter is running and to which the tool
          should be connected. When omitted, the ToolBus interpreter should be
          running on the same host as the tool.</para>
        </listitem>

        <listitem>
          <para><literal>-TB_TOOL_NAME tool_name</literal>: the tool name as
          defined in the Tscript (added automatically, when a tool is executed
          by the ToolBus).</para>
        </listitem>

        <listitem>
          <para><literal>-TB_TOOL_ID <replaceable>Id</replaceable></literal>:
          internal tool identifier of this tool execution (added
          automatically, when a tool is executed by the ToolBus).</para>
        </listitem>

        <listitem>
          <para><literal>-TB_SINGLE</literal>: execute the tool stand-alone
          and do not connect it with the ToolBus.</para>
        </listitem>
      </itemizedlist>

      <para>The execution of a tool can start in two ways:</para>

      <itemizedlist>
        <listitem>
          <para>The tool is started by an <literal>execute</literal> command
          in the Tscript.</para>
        </listitem>

        <listitem>
          <para>The initiative to execute the tool is taken outside the
          ToolBus. This requires that the script contains a
          <literal>rec-connect</literal> for this particular tool.</para>
        </listitem>
      </itemizedlist>

      <para>When ToolBus and tool are running on different host machines, it
      is important to define the host machine on which the ToolBus interpreter
      is running when starting the execution of the tool. As an example,
      consider the <command>hello</command> application described in Section
      XXX. The <command>hello</command> tool will be executed by the ToolBus
      using the command <programlisting>hello -TB_PORT 8998 -TB_HOST host1.institute.nl</programlisting>when
      running on machine <literal>host1.institute.nl</literal>. Suppose, we
      replace the explicit <literal>execute</literal> in
      Figure~\ref{fig:hello2.tb} by a <literal>rec-connect</literal> as shown
      in Figure~\ref{fig:hello3.tb}. We may then manually start the
      <command>hello</command> tool by typing <programlisting>hello</programlisting>where
      we use the default values for the input/output sockets and assume that
      tool and ToolBus interpreter are both running on the same host (i.e.,
      <literal>host1.institute.nl</literal>). Starting the execution from
      <emphasis>another</emphasis> host is achieved by typing (on, say, {\tt
      host2.institute.nl}): <programlisting>hello -TB_HOST host1.institute.nl </programlisting></para>
    </section>
  </section>

  <section xml:id="section.toolbus-tools">
    <title>ToolBus tools</title>

    <para></para>

    <section xml:id="section.global-structure-tool">
      <title>The global structure of a ToolBus tool</title>

      <para><figure xml:id="figure-tool-organization">
          <title>Global tool organization</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="tool-organization.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>In its simplest form, a tool is a box connected via an input and
      an output port to a ToolBus. In the most general case, a tool has</para>

      <itemizedlist>
        <listitem>
          <para>one input port from the ToolBus to the tool and can receive
          tree structures (terms) via this port;</para>
        </listitem>

        <listitem>
          <para>one output port from the tool to the ToolBus and can send
          terms to the ToolBus via this port;</para>
        </listitem>

        <listitem>
          <para>zero or more <emphasis>term ports</emphasis> to receive terms
          from other sources;</para>
        </listitem>

        <listitem>
          <para>zero or more <emphasis>character ports</emphasis> to receive
          character data from other sources.</para>
        </listitem>
      </itemizedlist>

      <para>This global, architectural, structure of a tool is shown in <xref
      linkend="figure-tool-organization" />. With each input port, an
      <emphasis>event handler</emphasis> is associated that takes care of the
      processing of the data received via that port and is responsible for
      returning a result (if any). One tool may thus contain several event
      handlers. When a request is received, the following steps are
      taken:</para>

      <itemizedlist>
        <listitem>
          <para>The data received are parsed to check that they form a legal
          ToolBus term <replaceable>T</replaceable>. (If this is impossible, a
          warning message is generated).</para>
        </listitem>

        <listitem>
          <para>The event handler is called with <replaceable>T</replaceable>
          as argument.</para>
        </listitem>

        <listitem>
          <para>The event handler can do arbitrary processing needed to
          decompose <replaceable>T</replaceable>, to determine what has to be
          done, and perform any desired computation.</para>
        </listitem>

        <listitem>
          <para>The event handler returns either:</para>

          <itemizedlist>
            <listitem>
              <para>a legal ToolBus term representing a reply to be sent back
              to the ToolBus.</para>
            </listitem>

            <listitem>
              <para><literal>NULL</literal> indicating that there is no
              reply.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>The global mode of operation of a tool is now:</para>

      <itemizedlist>
        <listitem>
          <para>receive data on any input port and respond to this by sending
          some term (or <literal>NULL</literal>) to the ToolBus; or</para>
        </listitem>

        <listitem>
          <para>take the initiative to send a term to the ToolBus (typically
          to inform the ToolBus about some external event).</para>
        </listitem>
      </itemizedlist>

      <para>A tool is thus on the one hand a reactive engine that responds to
      a request from the \TB\ and returns the result back to the ToolBus in
      the form of a term (e.g., calculate the value of some expression), but
      on the other hand it can also take the initiative to send a term to the
      ToolBus (e.g., generate an event when a user pushes some button). At the
      level of the source code, the global structure of a purely reactive tool
      without additional term or character ports has already been illustrated
      in Figure~\ref{fig:hello.c}.</para>
    </section>

    <section xml:id="section.tool-adapters">
      <title>Adapters for tools and languages</title>

      <figure xml:id="figure.organization-tool-adapter">
        <title>Two organizations of a tool adapter</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="tool-adapter.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The main purpose of adapters is to act as small
      <emphasis>wrappers</emphasis> around existing programs or programming
      languages in order to transform them into tools that can be connected to
      the ToolBus. There exist two global strategies for constructing
      adapters:</para>

      <itemizedlist>
        <listitem>
          <para>The adapter and the program to be adapted are executed as
          separate (Unix) processes. This structure is sketched in <xref
          linkend="figure.organization-tool-adapter" />. The advantage of this
          approach is that no access is needed to the source code of the
          program: it can remain a black box. Another advantage is that
          adapters may be reused for the adaptation of different programs. A
          possible disadvantage is some loss in efficiency.</para>

          <para>In this category a further subdivision is possible:</para>

          <itemizedlist>
            <listitem>
              <para>The program is executed once as a child process of the
              adapter and all
              <literal>snd-eval</literal>/<literal>snd-do</literal> requests
              are directed to this child process. The program can thus
              maintain an internal state between requests.</para>
            </listitem>

            <listitem>
              <para>The same program is executed as a child process of the
              adapter for each
              <literal>snd-eval</literal>/<literal>snd-do</literal>
              request.</para>
            </listitem>

            <listitem>
              <para>A different program is executed as a child process of the
              adapter for each
              <literal>snd-eval</literal>/<literal>snd-do</literal>
              request.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Integrate the adapter and the software to be adapted into a
          single (Unix) process. This approach permits the most detailed
          adaptation of the program and is also the most efficient solution.
          This approach leads, however, to potentially less reusable adapters
          than the previous approach.</para>
        </listitem>
      </itemizedlist>

      <para>In order to achieve some uniformity, the current collection of
      adapters have the following optional program arguments in common:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-cmd</literal>: the (default) program to be executed
          by the adapter. All arguments of the adapter that follow
          <literal>-cmd</literal> are interpreted as the name and arguments of
          the program to be executed.</para>
        </listitem>

        <listitem>
          <para>All tool arguments (see Section~\ref{ToolArgs}.)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.generating-tool-interfaces">
      <title>Automatic generation of tool interfaces</title>

      <para><figure xml:id="figure.tifs">
          <title>Automatic generation of tool interfaces</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="tifs.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>The interface code for each tool depends on the particulars
      of the Tscript in which it is used. Changing the number of arguments in
      an evaluation request to the tool, or adding a new request, requires
      making changes to the interface code that are easily forgotten and
      therefore error prone. As already mentioned in Section~\ref{Hello},
      another observation is that the interface code for different tools has a
      lot in common. An obvious solution to both problems is to
      <emphasis>generate</emphasis> tool interfaces automatically, given a
      Tscript. This generation process is shown in <xref
      linkend="figure.tifs" /> and consists of two steps:</para>

      <itemizedlist>
        <listitem>
          <para>Generate a language-independent description of all tool
          interfaces used in the script. This amounts to a static analysis of
          all tool communication in the script. It is achieved by using the
          <literal>-gentifs</literal> option of the ToolBus interpreter. For
          instance, <programlisting>toolbus -gentifs hello2.tb</programlisting>
          will create a file <filename>hello2.tifs</filename> containing the
          tool interfaces.</para>
        </listitem>

        <listitem>
          <para>Use the language independent interface description to generate
          a tool interface for a specific tool in a specific implementation
          language. The generator <command>tifstoc</command> exists for
          generating C tool interfaces. It is called as follows:
          <programlisting>tifstoc -tool <replaceable>Name</replaceable> <replaceable>TifsFile</replaceable></programlisting>and
          generates a file named
          <literal><replaceable>Name</replaceable>.tif.c</literal>. For the
          hello example, we would have, for instance: <programlisting>tifstoc -tool hello hello2.tifs</programlisting>
          %The resulting file {\tt hello.tif.c} is shown in
          %Figure~\ref{fig:hello.tif.c}. \end{itemize}</para>
        </listitem>
      </itemizedlist>

      <para>In <xref linkend="figure.tifs" /> it is also shown how tool
      interface generators for <emphasis>other</emphasis> languages (e.g.,
      Java, Cobol) fit into this scheme. In addition to
      <command>tifstoc</command>, we alo support the generation of Java
      interfaces by way of <command>tifstojava</command> (See
      Section~\ref{ToolsInJava}).</para>
    </section>
  </section>

  <section xml:id="section.C-tools">
    <title>Writing ToolBus tools in C</title>

    <para>Although ToolBus tools can be implemented in many languages
    (including Java, C++, Perl, Tcl/Tk, Prolog, ASF+SDF, Cobol and others) we
    start explaining how tools can be written in C. In other languages
    identical notions will be used with only minor adjustements to
    language-specific features and limitations. Writing tools in C amounts
    to:</para>

    <itemizedlist>
      <listitem>
        <para>ATerms: the essential data type that is used to exchange
        information between tool and \TB\ (Section~\ref{ATerms}).</para>
      </listitem>

      <listitem>
        <para>The global structure of a \TB\ tool
        (Section~\ref{GlobalStructureTool}).</para>
      </listitem>

      <listitem>
        <para>The \TB\ Application Programmer's Interface
        (Section~\ref{ToolBusAPI}).</para>
      </listitem>

      <listitem>
        <para>Compiling \TB\ tools written in C
        (Section~\ref{CompilingTools}).</para>
      </listitem>

      <listitem>
        <para>Generating tool interfaces with {\tt tifstoc}
        (Section~\ref{tifstoc}).</para>
      </listitem>
    </itemizedlist>

    <section xml:id="section.atb-tool.h">
      <title>The include file <literal>atb-tool.h</literal></title>

      <para>Each tool needs to include the file <literal>atb-tool.h</literal>
      which defines some basic types as well as the set of library functions
      available. It consists of</para>

      <itemizedlist>
        <listitem>
          <para>An include of <literal>&lt;aterm1.h&gt;</literal>.</para>
        </listitem>

        <listitem>
          <para>Defines <literal>ATBhandler</literal>: the type of event
          handlers.</para>
        </listitem>

        <listitem>
          <para>Defines the prototypes of all library functions</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="section.libATB.h">
      <title>The tool library <literal>libATB.a</literal></title>

      <para>When compiling tools, the library <literal>libATB.a</literal> must
      be specified in order to make the tool library available (using the
      -<literal>lATB</literal> option of the C compiler). It provides the
      following functions:</para>

      <itemizedlist>
        <listitem>
          <para><literal>ATBinit</literal>: tool initialization
          (Sections~\ref{ATBinit}).</para>
        </listitem>

        <listitem>
          <para><literal>ATBconnect</literal>: to connect the tool to the
          ToolBus (Sections~\ref{ATBconnect}).</para>
        </listitem>

        <listitem>
          <para><literal>ATBdisconnect</literal>: to disconnect the tool from
          the ToolBus (Sections~\ref{ATBconnect}).</para>
        </listitem>

        <listitem>
          <para><literal>ATBeventloop</literal>: a standard event loop for a
          tool (Section~\ref{ATBeventloop}).</para>
        </listitem>

        <listitem>
          <para><literal>ATBreadTerm</literal>: process one input event on a
          port (Section~\ref{ATBreadTerm}).</para>
        </listitem>

        <listitem>
          <para><literal>ATBwriteTerm</literal>: send a term to the ToolBus
          (Section~\ref{ATBreadTerm}).</para>
        </listitem>
      </itemizedlist>

      <para>In the following section, we will describe these functions.</para>
    </section>

    <section xml:id="section.toolbus-API">
      <title>The ToolBus API</title>

      <para>During the initialization of each tool, some preparations have to
      made before the tool can be properly connected to the ToolBus. These
      preparations include</para>

      <itemizedlist>
        <listitem>
          <para>Defining the <emphasis>name</emphasis> of the tool as it is
          known from a tool declaration in a Tscript.</para>
        </listitem>

        <listitem>
          <para>Parsing standard program arguments that are passed to the tool
          when it is started.</para>
        </listitem>

        <listitem>
          <para>Creating a pair of socket connections with a ToolBus
          interpreter.</para>
        </listitem>

        <listitem>
          <para>Starting an event loop.</para>
        </listitem>
      </itemizedlist>

      <para>During execution of the event loop, the tool can either
      <emphasis>receive</emphasis> terms from the ToolBus or it can take the
      initiative to <emphasis>send</emphasis> terms to the ToolBus. It is thus
      possible for a tool to both respond to ToolBus requests and
      <emphasis>asynchronously</emphasis> send terms to the ToolBus.</para>

      <section xml:id="section.ATBinit">
        <title><literal>ATBinit</literal></title>

        <para>The initialization of the ToolBus API is achieved
        by<programlisting>int ATBinit(int <replaceable>argc</replaceable>, char *<replaceable>argv</replaceable>[], ATerm *<replaceable>bottomOfStack</replaceable>).</programlisting></para>

        <para>This initializes the ToolBus API as weel as the ATerm library
        that is used by it.</para>

        <para>The standard program arguments that are passed (via
        <replaceable>argc</replaceable> and <replaceable>argv</replaceable>)
        are fully described in Section~\ref{Executing}. Particularly important
        is that the tool is initialized with a proper name. It should be
        literally equal (including the case of letters) to a tool name as
        appearing in a tool declaration in the Tscript. This is important
        since the tool name will be used when the tool is connected to the
        ToolBus. Note that <literal>ATBinit</literal> also initializes the
        ATerm library (hence the <replaceable>bottomOfStack</replaceable>
        argument, see Section \ref{ATinit}).</para>

        <para>The return value indicates whether or not the Toolbus host could
        be found: 0 indicates that all is well, and -1 indicates an error, in
        which case the standard variable <literal>errno</literal> of the C
        run-time system is set to indicate which error.</para>
      </section>

      <section xml:id="section.ATBconnect">
        <title><literal>ATBconnect</literal></title>

        <para>A tool can be connected to the ToolBus using <replaceable>term
        ports</replaceable> that can be using for sending and receiving data
        in the form of complete terms. Two aspects of term ports are
        important: the input channel used for the actual data transfer and the
        <emphasis>handler</emphasis> that takes care of processing input terms
        when they arrive. The connection is established as
        follows:<programlisting>int ATBconnect(char *<replaceable>toolname</replaceable>, char *<replaceable>host</replaceable>, 
               int <replaceable>port</replaceable>, ATBhandler <replaceable>h</replaceable>);</programlisting>Here,
        <replaceable>toolname</replaceable> is the tool name to be used,
        <replaceable>host</replaceable> is the machine where the ToolBus is
        executing, <replaceable>port</replaceable> is the file descriptior of
        the channel to be used, and <replaceable>h</replaceable> is the
        handler to associated with this connection. If value
        <literal>NULL</literal> is passed as
        <replaceable>toolname</replaceable> or
        <replaceable>host</replaceable>, default values are used that are
        taken from <replaceable>argv</replaceable> that was passed to
        <literal>ATBinit</literal>. The same is true when
        <literal>-1</literal> is passed as value for
        <replaceable>port</replaceable>. The return value of
        <literal>ATBconnect</literal> is either <literal>-1</literal>
        (failure) or a positive number (the connection succeeded and the
        result is the file descriptor of the resulting socket connection with
        the ToolBus). Handlers for term ports are functions from ATerm to
        ATerm and have the type:<programlisting>ATerm some_handler(int <replaceable>conn</replaceable>, ATerm <replaceable>input</replaceable>)</programlisting>The
        argument <replaceable>conn</replaceable> is the connection along which
        the input term was received and <replaceable>input</replaceable> is
        the actual term received. The term retruned by the handler is the
        reply to be sent to the ToolBus in response to this input event, or
        <literal>NULL</literal> if no reply is needed. In this fashion, an
        arbitrary number of term input ports can be set up which will be read
        in parallel: as soon as a term arrives at one of the ports the
        associated handler is activated. A connection can be terminated as
        follows:<programlisting>void ATBdisconnect(int <replaceable>conn</replaceable>)</programlisting>where
        <replaceable>conn</replaceable> is a connection that has been created
        eralier using <literal>ATBconnect</literal>.</para>
      </section>

      <section xml:id="section.ATBeventloop">
        <title>ATBeventloop</title>

        <para>Many tools first establish a number of term ports and then enter
        an infinite loop that processes input events. The
        function<programlisting>int ATBeventloop(void)</programlisting>captures
        this idea. It never returns, unless something goes wrong. We can now
        give a skeleton that many tools have in common:<programlisting>#include "my_tool.tif.c"

ATerm my_tool_handler(int conn, ATerm input)
{ ... handle input and return a term or NULL ...  }

int main(int argc, char *argv[]) 
{ ATerm bottomOfStack;

  ATBinit(argc, argv, &amp;bottomOfStack);
  if(ATBconnect(NULL, NULL, -1,  my_tool_handler) &gt;= 0)
  {
     ATBeventloop();
  } else 
     fprintf(stderr, "my_tool: Could not connect to the ToolBus, giving up!\n");
  ATBeventloop();
  return 0; 
}</programlisting></para>
      </section>

      <section xml:id="section.ATBwrite-read-Term">
        <title><literal>ATBwriteTerm</literal> and
        <literal>ATBreadTerm</literal></title>

        <para>So far, we have seen primitives for tools that only receive
        terms from the ToolBus. In the case of, for instance, events that are
        generated by a tool, a term needs to be sent from the tool to the
        ToolBus. This can be achieved using<programlisting>int ATBwriteTerm(int <replaceable>conn</replaceable>, ATerm <replaceable>term</replaceable>)</programlisting>which
        sends <replaceable>term</replaceable> along the port
        <replaceable>conn</replaceable>. Failure is indicated by the return
        value <literal>-1</literal>. A typical usage is:<programlisting>ATBwriteTerm(conn, ATmake(snd-event(button("ok")).</programlisting>Symmetrically,
        a term can be read from a ToolBus connection as
        follows:<programlisting>ATerm ATBreadTerm(int <replaceable>conn</replaceable>).</programlisting></para>
      </section>

      <section xml:id="section.advanced-control-flow">
        <title>Primitives for advanved control flow</title>

        <para>Tool programming amounts, in essence, to event driven
        programming: most of the time a tool is awaiting the arrival of data
        on one of its ports and when the data are there, a reply is sent to
        the ToolBus by the handler associated with that port. In
        computation-intensive tools, the need may arise to check for the
        availability of incoming data from the ToolBus during computations. In
        those cases, ATBeventloop may not offer enough flexibility. More
        customized control flow can be achieved using the following functions.
        Observe that these function are parameterized with a specific ToolBus
        connection (as returned by <literal>ATBconnect</literal>) and can be
        used to handle situations where a single tool is connected with
        <emphasis>more than one</emphasis> ToolBus.</para>

        <para>Checking if there is input awaiting on a ToolBus connection is
        done by:</para>

        <para><programlisting>ATbool ATBpeekOne(int <replaceable>conn</replaceable>)</programlisting>This
        function returns <literal>ATtrue</literal> if incoming data from a
        ToolBus are available on the connection
        <replaceable>conn</replaceable>.</para>

        <para>Similarly, the availability of data on <emphasis>any</emphasis>
        connection may be checked by:<programlisting>int ATBpeekAny(void)</programlisting>If
        input is waiting, the appropriate connection is returned. Otherwise
        <literal>-1</literal> is returned. The sequence of activities needed
        for handling (once) the data available from a specific connection is
        captured by the function<programlisting>void ATBhandleOne(int <replaceable>conn</replaceable>)</programlisting>This
        amounts to calling the handler associated with connection
        <replaceable>conn</replaceable> with the available data as input term.
        Similarly, the data from <emphasis>any</emphasis> connection is
        handled by<programlisting>int ATBhandleAny(void)</programlisting></para>

        <para>which returns -1 if anything goes wrong.</para>

        <para>Finally, the function</para>

        <para><programlisting>int ATBgetDescriptors(fd_set *set)</programlisting></para>

        <para>Gathers all Toolbus connection file descriptors in a single
        descriptor set. The return value indicates the maximum value of any
        descriptor in the set.</para>
      </section>

      <section xml:id="section.control-flow-patterns">
        <title>Control flow patterns</title>

        <para>Given, the control flow primitives in the previous section, we
        can express various common control flow patterns.</para>

        <para>The function <literal>ATBeventloop</literal> can be expressed
        with the primitives just introduced:<programlisting>int ATBeventloop(void)
{ int conn;
  while(ATtrue)
  {
    n  = ATBhandleAny();
    if(n &lt; 0)
      return -1;
  }
}</programlisting>Another style mixes the handling of input from the ToolBus,
        with other computations: <programlisting>   while(ATtrue)
   { 
     if(n = ATBpeekAny() &gt;= 0) /* if there is an incoming event */
        ATBhandleOne(n);             /* handle it                     */
     else {
        ...                         /* perform other computation     */
     }
   }</programlisting>In some tools, a mixture of passively awaiting input and
        actively sending terms to the ToolBus can be seen. Using
        <literal>ATBwriteTerm</literal>, the most general global event loop of
        a tool becomes: <programlisting> while(ATtrue)
 {
 ... ATBwriteTerm(c1,e1); ...; ATBwriteTerm(cn,en); ...
   ATBhandleAny();
 }</programlisting>In other words, each iteration starts by sending zero or
        more terms to the ToolBus (using <literal>ATBwriteTerm</literal>) and
        ends with processing one event coming from some port (using
        <literal>ATBhandleAny</literal>). The Tscript being used should, of
        course, be able to receive such events.</para>
      </section>
    </section>

    <section xml:id="section.compiling-C-tools">
      <title>Compiling ToolBus tools written in C</title>

      <para>When compiling a tool written in C the following questions should
      be answered:</para>

      <itemizedlist>
        <listitem>
          <para>Where is the include file <literal>aterm1.h</literal> (or
          <literal>aterm2.h</literal> if you use the more sophisticated parts
          of the ATerm library)?</para>
        </listitem>

        <listitem>
          <para>Where is the include file
          <literal>atb-tool.h</literal>?</para>
        </listitem>

        <listitem>
          <para>Where is the ATerm library
          <literal>libATerm.a</literal>?</para>
        </listitem>

        <listitem>
          <para>Where is the ToolBus API library
          <literal>libATB.a</literal>?</para>
        </listitem>

        <listitem>
          <para>Which other libraries are needed to compile the tool?</para>
        </listitem>
      </itemizedlist>

      <para>The answers to these questions are clearly system dependent. There
      are two strategies to answer them. Strategy 1: find the desired
      locations on your system and hard code them in the compilation command.
      This will lead to a call to the C compiler with the following
      arguments:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-I<replaceable>dir-where-aterm1.h-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>-I<replaceable>dir-where-ATB-tool.h-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>hello.c -o hello</literal></para>
        </listitem>

        <listitem>
          <para><literal>-L<replaceable>dir-where-libATerm.a-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>-lATerm</literal></para>
        </listitem>

        <listitem>
          <para><literal>-L<replaceable>dir-where-libATB.a-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>-lATB</literal></para>
        </listitem>

        <listitem>
          <para>other libraries.</para>
        </listitem>
      </itemizedlist>

      <para>Strategy 2: write a make file that encodes this information. As a
      result, the location information is hardwired in the make file rather
      than in a command that has to be repeated over and over again.</para>
    </section>

    <section xml:id="section.automatic-generation-C-tool-interfaces">
      <title>Automatic generation of C tool interfaces</title>

      <para>As already explained in <xref
      linkend="section.generating-tool-interfaces" /> tool interfaces can be
      generated from a given Tscript for a given tool name. The ToolBus can
      generate a language-independent <literal>.tifs</literal> file, when it
      is started with the <literal>-gentifs</literal> option. In the case of
      C, the command <command>tifstoc</command> generates a tool interface in
      C for use with the ATerm library. The generated interface consists of
      two files:</para>

      <itemizedlist>
        <listitem>
          <para>a C source file (<filename>hello2.tif.c</filename> in the
          example below), and</para>
        </listitem>

        <listitem>
          <para>a C header file (<filename>hello2.tif.h</filename> in the
          example below).</para>
        </listitem>
      </itemizedlist>

      <para>In the header file a number of interface functions is declared,
      one for each element in the input signature of the tool. It is up to the
      writer of the tool to provide an implementation for these functions. The
      generated C file contains a handler function that analyzes incoming
      terms from the ToolBus, and delegates actual processing to the
      appropriate interface function.</para>

      <para>We will use the Tscript <literal>hello2.tb</literal> shown earlier
      in <xref linkend="example.hello2" /> and describe all the steps needed
      to write and compile the hello tool.</para>

      <section>
        <title>Step 1: generate tifs</title>

        <para>Using the command:<programlisting>toolbus -gentifs hello2.tb </programlisting></para>

        <para>we generate a file called <literal>hello2.tifs</literal>. It
        contains information amount the interfaces for all tools that are used
        in a given Tscript.</para>
      </section>

      <section>
        <title>Step 2: generate C tool interface</title>

        <para>Using the command:</para>

        <para><programlisting>tifstoc -tool hello test.tifs </programlisting></para>

        <para>we generate two files:</para>

        <itemizedlist>
          <listitem>
            <para>the header file hello.tif.h, see <xref
            linkend="example.hello.tif.h" />.</para>
          </listitem>

          <listitem>
            <para>the source file <literal>hello.tif.c</literal>, see <xref
            linkend="example.hello.tif.c" />.</para>
          </listitem>
        </itemizedlist>

        <para><example xml:id="example.hello.tif.h">
            <title>The generated header file
            <literal>hello.tif.h</literal></title>

            <para><programlisting>**
 * This file is generated by tifstoc. Do not edit!
 * Generated from tifs for tool 'hello' (prefix='')
 */

#ifndef _HELLO_H
#define _HELLO_H

#include &lt;atb-tool.h&gt;

/* Prototypes for functions called from the event handler */
ATerm get_text(int conn);
void rec_terminate(int conn, ATerm);
extern ATerm hello_handler(int conn, ATerm term);
extern ATerm hello_checker(int conn, ATerm sigs);

#endif</programlisting>Only the functions <literal>get_text</literal> and
            <literal>rec_terminate</literal> together with a simple
            <literal>main</literal> function have to be implemented to build a
            fully functional ToolBus tool.</para>
          </example><example xml:id="example.hello.tif.c">
            <title>The generated file <literal>hello.tif.c</literal></title>

            <para><programlisting>/**
 * This file is generated by tifstoc. Do not edit!
 * Generated from tifs for tool 'hello' (prefix='')
 */

#include "hello.tif.h"

#define NR_SIG_ENTRIES  2

static char *signature[NR_SIG_ENTRIES] = {     <co xml:id="co.hello2.tif.c.1" />
  "rec-eval(&lt;hello&gt;,get-text)",
  "rec-terminate(&lt;hello&gt;,&lt;term&gt;)",
};

/* Event handler for tool 'hello' */
ATerm hello_handler(int conn, ATerm term)      <co xml:id="co.hello2.tif.c.2" />
{
  ATerm in, out;
  /* We need some temporary variables during matching */
  ATerm t0;

  if(ATmatch(term, "rec-eval(get-text)")) {
    return get_text(conn);
  }
  if(ATmatch(term, "rec-terminate(&lt;term&gt;)", &amp;t0)) {
    rec_terminate(conn, t0);
    return NULL;
  }
  if(ATmatch(term, "rec-do(signature(&lt;term&gt;,&lt;term&gt;))", &amp;in, &amp;out)) {
    ATerm result = hello_checker(conn, in);
    if(!ATmatch(result, "[]"))
      ATfprintf(stderr, 
                "warning: not in input signature:\n\t%\n\tl\n",
                result);
    return NULL;
  }

  ATerror("tool hello cannot handle term %t", term);
  return NULL; /* Silence the compiler */
}

/* Check the signature of the tool 'hello' */
ATerm hello_checker(int conn, ATerm siglist)   <co xml:id="co.hello2.tif.c.3" />
{
  return ATBcheckSignature(siglist, signature, NR_SIG_ENTRIES);
}</programlisting>Notes:<calloutlist>
                <callout arearefs="co.hello2.tif.c.1">
                  <para>An array of signature definitions
                  (<literal>signature</literal>) that contains the argument
                  and return types of each interface function.</para>
                </callout>

                <callout arearefs="co.hello2.tif.c.2">
                  <para>The handler function
                  (<literal>hello_handler</literal>), that differentiates
                  between the different possible input terms coming from the
                  ToolBus, and delegates the actual work to the appropriate
                  function.</para>
                </callout>

                <callout arearefs="co.hello2.tif.c.3">
                  <para>The signature checker <literal>hello_checker</literal>
                  uses the assembled signature information in the array
                  <literal>signature</literal> and compares it with
                  <literal>siglist</literal>, an ATerm that encodes the tool's
                  signature as expected by the ToolBus.</para>
                </callout>
              </calloutlist></para>
          </example></para>
      </section>

      <section>
        <title>Step 3: write main</title>

        <para>As mentioned earlier, the only thing needed to implement the
        actual hello tool, is the implementation of the two interface
        functions <literal>get_txt</literal> and
        <literal>rec_terminate</literal>, and the implementation of
        <literal>main</literal> to get things going. We will first take a look
        at the initialization stuff that the <literal>main</literal> function
        of the hllo tool has to do, see <xref
        linkend="example.hello.main" />.<example xml:id="example.hello.main">
            <title><literal>main</literal> function of hello tool</title>

            <para><programlisting>#include &lt;stdlib.h&gt;
#include "hello.tif.h"

int main(int argc, char *argv[])
{
  ATerm bottomOfStack;                                   <co
                  xml:id="co.hello2.main.1" />

  ATBinit(argc, argv, &amp;bottomOfStack);                   <co
                  xml:id="co.hello2.main.2" />
  if(ATBconnect(NULL, NULL, -1, testing_handler) &gt;= 0) { <co
                  xml:id="co.hello2.main.3" />
    ATBeventloop();                                      <co
                  xml:id="co.hello2.main.4" />
  } else {
    fprintf(stderr, 
            "Could not connect to the ToolBus, giving up!\n");
    return -1;
  }
  return 0;
}</programlisting></para>

            <para>Notes:<calloutlist>
                <callout arearefs="co.hello2.main.1">
                  <para>The variable <literal>bottomOfStack</literal> is
                  needed by the ATerm library to determine where to look for
                  the stack. It is passed as argument to
                  <literal>ATBinit</literal>.</para>
                </callout>

                <callout arearefs="co.hello2.main.2">
                  <para>The variables <literal>argc</literal> and
                  <literal>argv</literal> are passed unchanged to
                  <literal>ATBinit</literal>, so the ToolBus library can look
                  for default values for things like the ToolBus' well-known
                  socket address and the ToolBus host name.</para>
                </callout>

                <callout arearefs="co.hello2.main.3">
                  <para>The call to <literal>ATBconnect</literal> connects to
                  a running ToolBus, and requires four arguments: a character
                  string representing the tool name, a character string
                  representing the host name of the ToolBus to connect to, the
                  port number of the ToolBus to connect to, and a handler
                  function. Passing <literal>NULL</literal>,
                  <literal>NULL</literal>, and -1 respectively as the tool
                  name, the host name, and the port number cause the defaults
                  for these values to be used instead.</para>
                </callout>

                <callout arearefs="co.hello2.main.4">
                  <para>When all goes well, the call to
                  <literal>ATBeventloop</literal> starts the main ToolBus
                  eventloop and the tool will be ready to receive requests
                  from the ToolBus.</para>
                </callout>
              </calloutlist></para>
          </example></para>
      </section>

      <section>
        <title>Step 4: implement interface functions</title>

        <para>Finally, we only need the implementation of the two interface
        functions <literal>get_txt</literal> and
        <literal>rec_terminate</literal>, see <xref
        linkend="example.hello.interface-functions" /></para>

        <para><example xml:id="example.hello.interface-functions">
            <title>Implementation of interface functions of hello tool</title>

            <para><programlisting>ATerm get_text(int conn)                  <co
                  xml:id="co.hello2.interface.1" />             
{
  return 
    ATmake(
     "snd-value(text(\"Hello World, my first tool in C!\n\"))"
    );
}

void rec_terminate(int conn, ATerm msg){  <co xml:id="co.hello2.interface.2" /> 
  exit(0);
}</programlisting>Notes:<calloutlist>
                <callout arearefs="co.hello2.interface.1">
                  <para>get_text: generate the greeting text. The
                  <literal>conn</literal> argument identifies the ToolBus
                  connection, making it possible to distinguish
                  <emphasis>which</emphasis> ToolBus made the request. This
                  enables connecting to more than one Toolbus at the same
                  time.</para>
                </callout>

                <callout arearefs="co.hello2.interface.2">
                  <para>Mandatory function that is called to terminate the
                  tool.</para>
                </callout>
              </calloutlist></para>
          </example></para>
      </section>
    </section>
  </section>

  <section xml:id="section.Java-tools">
    <title>Writing ToolBus tools in Java</title>

    <para>Now we will show how ToolBus tools can be implemented in Java. The
    overall organization is shown in <xref
    linkend="figure.java-tool-organization" />. The actual communication
    between ToolBus and tool is taken care of by an instance of the class
    <literal>ToolBridge</literal> that takes care of low-level communication
    details. The ToolBridge is used by <literal>AbstractTool</literal>, an
    abstract class that defines the possible interactions between ToolBus and
    tool. The actual tool, in the figure <literal>MyTool</literal>, extends
    <literal>AbstractTool</literal>, gives implementations for its abstract
    methods, and implements tool-specific behaviour.</para>

    <para>Compared to writing a tool in C, using Java is simpler because there
    is no need for generating a tool interface using a tif file.<footnote>
        <para>This is due to the use of Java reflection in the class
        ToolBridge. In older versions, a generation step was also needed for
        Java tools.</para>
      </footnote></para>

    <para><figure xml:id="figure.java-tool-organization">
        <title>Global organization of a tool implemented in Java</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="java-tool-organization.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>Before showing the Java implementation of the hello tool, we
    first explain the AbstractTool class.</para>

    <section xml:id="section.AbstractTool">
      <title>The <literal>AbstractTool</literal> class</title>

      <para><programlisting>public abstract class AbstractTool implements IOperations {

public AbstractTool(){ ... } <co xml:id="co.AbstractTool.1" />

public void connect(String[] args) throws Exception{ ... } <co
            xml:id="co.AbstractTool.2" />

public ToolBridge getToolBridge(){ ... } <co xml:id="co.AbstractTool.3" />

public PureFactory getFactory(){ ... } <co xml:id="co.AbstractTool.4" />

public void sendEvent(ATerm aTerm){ ... }  <co xml:id="co.AbstractTool.5" />

public void disconnect(ATerm aTerm){ ... } <co xml:id="co.AbstractTool.6" />

public abstract void receiveAckEvent(ATerm aTerm); <co
            xml:id="co.AbstractTool.7" />

public abstract void receiveTerminate(ATerm aTerm); <co
            xml:id="co.AbstractTool.8" />
} </programlisting>Notes:</para>

      <calloutlist>
        <callout arearefs="co.AbstractTool.1">
          <para>The default constructor of AbstractTool.</para>
        </callout>

        <callout arearefs="co.AbstractTool.2">
          <para>Connect to the ToolBus. The argument <literal>args</literal>
          contains the required information for running a tool (name, id and
          additionally the host and port of the ToolBus, depending on how this
          tool is connected to the ToolBus). An exception is thrown when
          something goes wrong during parsing of the arguments or while
          establishing the connection.</para>
        </callout>

        <callout arearefs="co.AbstractTool.3">
          <para>Returns a reference to the tool bridge that this tool instance
          is using.</para>
        </callout>

        <callout arearefs="co.AbstractTool.4">
          <para>Returns a reference to the ATerm factory that is being
          used.</para>
        </callout>

        <callout arearefs="co.AbstractTool.5">
          <para>Send an event to the ToolBus.</para>
        </callout>

        <callout arearefs="co.AbstractTool.6">
          <para>Send a disconnect request to the ToolBus. The argument
          <literal>aTerm</literal> gives additional information about the
          request.</para>
        </callout>

        <callout arearefs="co.AbstractTool.7">
          <para>Receive an acknowledgement (in response to a previous event
          generated by this tool instance by way of
          <literal>sendEvent</literal>). The argument <literal>aTerm</literal>
          gives further details about the acknowledgement.</para>
        </callout>

        <callout arearefs="co.AbstractTool.8">
          <para>Receive a request from the ToolBus to terminate the execution
          of this tool instance.</para>
        </callout>
      </calloutlist>
    </section>

    <section xml:id="section.hello-Java-tool-definition">
      <title>Tool definition in the hello script</title>

      <para>The hello script from <xref linkend="example.hello2" /> can be
      used as is, except that the definition of the hello tool has to be
      changed to reflect the Java implementation:</para>

      <para><programlisting>tool hello is { kind = "javaNG" class = "toolbus.tool.java.hello.HelloTool"}</programlisting></para>
    </section>

    <section xml:id="section.hello-Java">
      <title>The hello example in Java</title>

      <para><example>
          <title>Hello tool implemented in Java</title>

          <para><programlisting>package toolbus.tool.java.hello;

import toolbus.adapter.AbstractTool;
import aterm.ATerm;
import aterm.ATermFactory;

public class HelloTool extends AbstractTool <co xml:id="co.hello-java.1" />
{
  public HelloTool(String[] args){ <co xml:id="co.hello-java.2" />
    super(); 
    try {
      connect(args); 
    } catch(Exception ex){
      throw new RuntimeException(ex);
    }
  }

  protected ATerm getText(){ <co xml:id="co.hello-java.3" />
    ATermFactory factory = getFactory();
    return factory.make("text(&lt;str&gt;)", 
                             "Hello world in Java!\n");
  }

  public void receiveAckEvent(ATerm aTerm){
  // Left blank intentionally. 
  }

  public void receiveTerminate(ATerm msg){
     System.out.print("rec-terminate received: " + msg);
 }
  
  public static void main(String[] args) {
    new HelloTool(args);
  }
}</programlisting>Notes:<calloutlist>
              <callout arearefs="co.hello-java.1">
                <para>The class <literal>HelloTool</literal> extends
                <literal>AbstractTool</literal> and provides an implementation
                for the hello tool.</para>
              </callout>

              <callout arearefs="co.hello-java.2">
                <para>The constructor for <literal>HelloTool</literal> first
                calls its super class and then attempt to make a connection.
                The arguments of the constructor are passed to the
                <literal>connect</literal> call.</para>
              </callout>

              <callout arearefs="co.hello-java.3">
                <para>The evaluation request <literal>snd-eval(H,
                get-text)</literal> in the Tscript is implemented by the
                method <literal>getText</literal>. It constructs the required
                ATerm that <literal>text("Hello world in Java!\n")</literal>
                and returns it as result. This result will passed to the
                ToolBus and will be accepted by the atom <literal>rec-value(H,
                text(S?))</literal> in the Tscript. Note that in this example
                <literal>H</literal> is the tool identifier of the hello
                tool.</para>
              </callout>
            </calloutlist></para>
        </example></para>
    </section>
  </section>

  <section xml:id="section.tools-other-languages">
    <title>Writing ToolBus tools in other languages</title>

    <section xml:id="section.TclTk-adapter">
      <title>Tcl/TK</title>

      <para>TBD</para>
    </section>

    <section xml:id="section.Python-adapter">
      <title>Python</title>

      <para>A Python adapter is only available for older versions of the
      ToolBus. It is currently not supported.</para>
    </section>

    <section xml:id="section.Perl-adapter">
      <title>Perl</title>

      <para>A Perl adapter is only available for older versions of the
      ToolBus. It is currently not supported.</para>
    </section>
  </section>

  <section xml:id="section.ToolBus-implementation">
    <title>The ToolBus Implementation</title>

    <para>TBD</para>
  </section>

  <section xml:id="section.toolbus-reference">
    <title>Reference Information</title>

    <section xml:id="section.syntax-Tscripts">
      <title>The syntax of Tscripts</title>

      <para>A Tscript may contain directives like, e.g.,
      <literal>#define</literal>, <literal>#include</literal> and
      <literal>#ifdef</literal> that are replaced by a preprocessor similar to
      the C preprocessor. We summarize the most frequently used
      directives:</para>

      <itemizedlist>
        <listitem>
          <para><literal>#define <replaceable>Identifier</replaceable>
          <replaceable>Token-sequence</replaceable></literal> causes the
          preprocessor to replace all occurrences of
          <replaceable>Identifier</replaceable> by
          <replaceable>Token-sequence</replaceable>.</para>
        </listitem>

        <listitem>
          <para><literal>#include
          "<replaceable>Filename</replaceable>"</literal> will be replaced by
          the entire contents of the named file.</para>
        </listitem>

        <listitem>
          <para><literal>#ifdef</literal> and <literal>#ifndef</literal> can
          be used for the conditional incorporation or exclusion of parts of a
          script.</para>
        </listitem>
      </itemizedlist>

      <para>The syntax of Tscripts (without preprocessor directives) is as
      follows:</para>

      <warning>
        <para>This definition is slightly out-of-date.</para>
      </warning>

      <programlisting>
exports
  sorts BOOL NAT INT SIGN EXP UNSIGNED-REAL REAL STRING ID 
        NAME VNAME BSTR TERM TERM-LIST VAR GEN-VAR TYPE ATOM 
        ATOMIC-FUN PROC PROC-APPL FORMALS TIMER-FUN 
        FEATURE-ASG FEATURES TB-CONFIG DEF T-SCRIPT
  lexical syntax
        [ \t\n]                              -&gt; LAYOUT
        "%%" ~[\n]*                          -&gt; LAYOUT

        [0-9]+                               -&gt; NAT
        NAT                                  -&gt; INT
        SIGN NAT                             -&gt; INT
        [+\-]                                -&gt; SIGN

        [eE] NAT                             -&gt; EXP
        [eE] SIGN NAT                        -&gt; EXP
        NAT "." NAT                          -&gt; UNSIGNED-REAL
        NAT "." NAT EXP                      -&gt; UNSIGNED-REAL
        UNSIGNED-REAL                        -&gt; REAL
        SIGN UNSIGNED-REAL                   -&gt; REAL

        [a-z][A-Za-z0-9\-]*                  -&gt; ID
        "\"" ~[\"]* "\""                     -&gt; STRING
        [A-Z][A-Za-z0-9\-]*                  -&gt; NAME
        [A-Z][A-Za-z0-9\-]*                  -&gt; VNAME
        [a-z][a-z\-]*                        -&gt; ATOMIC-FUN

        delay                                -&gt; TIMER-FUN
        abs-delay                            -&gt; TIMER-FUN
        timeout                              -&gt; TIMER-FUN
        abs-timeout                          -&gt; TIMER-FUN
  context-free syntax
        true                                 -&gt; BOOL
        false                                -&gt; BOOL
        BOOL                                 -&gt; TERM
        INT                                  -&gt; TERM
        REAL                                 -&gt; TERM
        STRING                               -&gt; TERM

        TERM                                 -&gt; TYPE

        VNAME                                -&gt; VAR
        VNAME ":" TYPE                       -&gt; VAR
        VAR                                  -&gt; GEN-VAR
        VAR "?"                              -&gt; GEN-VAR
        GEN-VAR                              -&gt; TERM
        "&lt;" TERM "&gt;"                         -&gt; TERM
        ID                                   -&gt; TERM
        ID "(" TERM-LIST ")"                 -&gt; TERM
        {TERM ","}*                          -&gt; TERM-LIST
        "[" TERM-LIST "]"                    -&gt; TERM

        NAME                                 -&gt; VNAME

        ATOMIC-FUN "(" TERM-LIST ")"         -&gt; ATOM
        delta                                -&gt; ATOM
        tau                                  -&gt; ATOM
        create "(" NAME "(" TERM-LIST ")" ","  
                   TERM ")"                  -&gt; ATOM
        ATOM TIMER-FUN "(" TERM ")"          -&gt; ATOM
        VNAME ":=" TERM                      -&gt; ATOM

        ATOM                                 -&gt; PROC
        PROC "+" PROC                        -&gt; PROC  {left}
        PROC "." PROC                        -&gt; PROC  {right}
        PROC "||" PROC                       -&gt; PROC  {right}
        PROC "*" PROC                        -&gt; PROC  {left}
        "(" PROC ")"                         -&gt; PROC  {bracket}
        if TERM then PROC else PROC fi       -&gt; PROC
        if TERM then PROC fi                 -&gt; PROC
        execute(TERM-LIST)                   -&gt; PROC
        let {VAR ","}* in PROC endlet        -&gt; PROC

        NAME                                 -&gt; PROC-APPL
        NAME "(" TERM-LIST ")"               -&gt; PROC-APPL
        PROC-APPL                            -&gt; PROC

        "(" {GEN-VAR ","}* ")"               -&gt; FORMALS
                                             -&gt; FORMALS

        process NAME FORMALS is PROC         -&gt; DEF
        ID "=" STRING                        -&gt; FEATURE-ASG
       "{" { FEATURE-ASG  ";"}* "}"          -&gt; FEATURES
        tool ID FORMALS is FEATURES          -&gt; DEF
        toolbus "("{PROC-APPL ","}+ ")"      -&gt; TB-CONFIG
        DEF* TB-CONFIG                       -&gt; T-SCRIPT

 priorities
       PROC "*" PROC -&gt; PROC &gt; PROC "." PROC -&gt; PROC &gt;
       PROC "+" PROC -&gt; PROC &gt; PROC "||" PROC -&gt; PROC
   </programlisting>
    </section>

    <section xml:id="section.built-in-functions">
      <title>Built-in functions</title>

      <para>Tscripts provide a limited form of built-in functions that are
      summarized here. Recall that built-in functions are only evaluated at
      the following syntactic positions in a Tscript:</para>

      <itemizedlist>
        <listitem>
          <para>The right-hand side of an assignment.</para>
        </listitem>

        <listitem>
          <para>The test in an if-then or if-then-else construct.</para>
        </listitem>

        <listitem>
          <para>The expression in time-related constructs.</para>
        </listitem>
      </itemizedlist>

      <section xml:id="section.Boolean-functions">
        <title>Boolean functions</title>

        <para><table>
            <title>Boolean functions</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description&#160;</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>not(&lt;bool&gt;<subscript>1</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>¬
                  <literal>&lt;bool&gt;<subscript>1</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>and(&lt;bool&gt;<subscript>1</subscript>,
                  &lt;bool&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;bool&gt;<subscript>1</subscript> and
                  &lt;bool&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>or(&lt;bool&gt;<subscript>1</subscript>,
                  &lt;bool&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;bool&gt;<subscript>1</subscript> OR
                  &lt;bool&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>equal(&lt;term&gt;<subscript>1</subscript>,
                  &lt;term&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;term&gt;<subscript>1</subscript>
                  </literal>=
                  <literal>&lt;term&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>not-equal(&lt;term&gt;<subscript>1</subscript>,
                  &lt;term&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;term&gt;<subscript>1</subscript> NE
                  &lt;term&gt;<subscript>2</subscript></literal></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.Integer-functions">
        <title>Integer functions</title>

        <table>
          <title>Integer functions</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>add(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                +
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>sub(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                -
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>mul(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry
                char="02306"><literal>&lt;int&gt;<subscript>1</subscript></literal>
                TIMES
                <literal>&lt;int&gt;</literal><subscript>2</subscript></entry>
              </row>

              <row>
                <entry><literal>div(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                /
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>mod(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                <emphasis role="bold">mod</emphasis>
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>abs(&lt;int&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry>|
                <literal>&lt;int&gt;<subscript>1</subscript></literal>
                |</entry>
              </row>

              <row>
                <entry><literal>less(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                &lt;
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>less-equal(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript>
                </literal>LEQ
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>greater(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                &gt;
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>greater-equal(&lt;int&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
                GEQ
                <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section xml:id="section.Real-functions">
        <title>Real functions</title>

        <para><table>
            <title>Real functions</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>radd(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  +
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rsub(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  -
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rmul(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  ×
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rdiv(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  /
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>mod(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  <emphasis role="bold">mod</emphasis>
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rabs(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                  <entry><literal>&lt;real&gt;</literal></entry>

                  <entry>|
                  <literal>&lt;real&gt;<subscript>1</subscript></literal>
                  |</entry>
                </row>

                <row>
                  <entry><literal>rless(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  &lt;
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rless-equal(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;&gt;<subscript>1</subscript></literal>
                  ≤
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rgreater(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                  &gt;
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>

                <row>
                  <entry><literal>rgreater-equal(&lt;real&gt;<subscript>1</subscript>,
                  &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry><literal>&lt;real&gt;&gt;<subscript>1</subscript></literal>
                  ≥
                  <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.Goniometric-functions">
        <title>Goniometric functions</title>

        <table>
          <title>Goniometric functions</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>sin(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>sin</emphasis>(<literal>&lt;real&gt;<subscript>1</subscript></literal>)</entry>
              </row>

              <row>
                <entry><literal>cos(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>cos</emphasis>(<literal>&lt;real&gt;<subscript>1</subscript></literal>)</entry>
              </row>

              <row>
                <entry><literal>atan(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>tan</emphasis><superscript>-1</superscript>(<literal>&lt;real&gt;<subscript>1</subscript></literal>)
                in the range [-π/2, π/2]</entry>
              </row>

              <row>
                <entry><literal>atan2(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>tan</emphasis><superscript>-1</superscript>(<literal>&lt;real&gt;<subscript>1</subscript></literal>/<literal>&lt;real&gt;<subscript>2</subscript></literal>)
                in the range [-π, π]</entry>
              </row>

              <row>
                <entry><literal>exp(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>e</emphasis><superscript>&lt;real&gt;<subscript>1</subscript></superscript></entry>
              </row>

              <row>
                <entry><literal>log(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry>natural logarithm
                <emphasis>ln</emphasis>(<literal>&lt;real&gt;<subscript>1</subscript></literal>),
                with <literal>&lt;real&gt;<subscript>1</subscript></literal>
                &gt; 0</entry>
              </row>

              <row>
                <entry><literal>log10(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry>base 10 logarithm
                <emphasis>log</emphasis><subscript>10</subscript>(<literal>&lt;real&gt;<subscript>1</subscript></literal>),
                with <literal>&lt;real&gt;<subscript>1</subscript></literal>
                &gt; 0</entry>
              </row>

              <row>
                <entry><literal>sqrt(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><emphasis>√</emphasis><literal>&lt;real&gt;<subscript>1</subscript></literal>,
                with <literal>&lt;real&gt;<subscript>1</subscript></literal> ≥
                0</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section xml:id="section.list-functions">
        <title>Functions on lists</title>

        <table>
          <title>Functions on lists</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>first(&lt;list&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;term&gt;</literal></entry>

                <entry>First element of
                <literal>&lt;list&gt;<subscript>1</subscript></literal>; The
                empty list <literal>[]</literal> when applied to non-list or
                empty list.</entry>
              </row>

              <row>
                <entry><literal>next(&lt;list&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>Remaining elements of
                <literal>&lt;list&gt;<subscript>1</subscript></literal>.</entry>
              </row>

              <row>
                <entry><literal>join(&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>Concatenation of
                <literal>&lt;term&gt;<subscript>1</subscript></literal> and
                <literal>&lt;term&gt;<subscript>2</subscript></literal>. When
                both arguments are lists their elements are spliced into a new
                list. A non-list argument is included as single element in the
                new list.</entry>
              </row>

              <row>
                <entry><literal>size(&lt;list&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry>The number of elements in
                <literal>&lt;list&gt;<subscript>1</subscript></literal>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Functions on lists as arrays</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>index(&lt;list&gt;<subscript>1</subscript>,
                &lt;int&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;term&gt;</literal></entry>

                <entry>The
                <literal>&lt;int&gt;<subscript>1</subscript></literal>-th
                element of
                <literal>&lt;list&gt;<subscript>1</subscript></literal>, if it
                exists; otherwise <literal>[]</literal>.</entry>
              </row>

              <row>
                <entry><literal>replace(&lt;list&gt;<subscript>1</subscript>,&lt;int<subscript>1</subscript>&gt;,&lt;term&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>If the
                &lt;<literal>int&gt;<subscript>1</subscript></literal>-the
                element exists, replace it by
                <literal>&lt;term&gt;<subscript>1</subscript></literal> and
                returned the modifed list; otherwise return
                <literal>&lt;list&gt;<subscript>1</subscript></literal>
                unmodified.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Functions on lists as symbol tables</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>get(&lt;list&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;term&gt;</literal></entry>

                <entry>If
                <literal>&lt;list&gt;<subscript>1</subscript></literal>contains
                a pair <literal>[&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>1</subscript>']</literal> then return
                <literal>&lt;term&gt;<subscript>1</subscript>'</literal>;
                otherwise [].</entry>
              </row>

              <row>
                <entry><literal>put(&lt;list&gt;<subscript>1</subscript>,&lt;term&gt;<subscript>1</subscript>,&lt;term&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>If
                <literal>&lt;list&gt;<subscript>1</subscript></literal>contains
                a pair <literal>[&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>1</subscript>']</literal> then replace
                it by <literal>[&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>2</subscript>]</literal>; otherwise add
                a new pair [&lt;term&gt;<subscript>1</subscript>,
                &lt;term&gt;<subscript>2</subscript>] to
                &lt;list&gt;<subscript>1</subscript>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Functions on lists as multi-sets</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function&#160;</entry>

                <entry align="center">Result type&#160;</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>member(&lt;term&gt;<subscript>1</subscript>,
                &lt;list&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;term&gt;<subscript>1</subscript></literal>
                IN <literal>&lt;list&gt;<subscript>2</subscript></literal>
                (membership in multi-set)</entry>
              </row>

              <row>
                <entry><literal>subset(&lt;list&gt;<subscript>1</subscript>,&lt;list&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;list&gt;<subscript>1</subscript></literal>
                SUBSET <literal>&lt;list&gt;<subscript>2</subscript></literal>
                (subset on multi-set)</entry>
              </row>

              <row>
                <entry><literal>diff(&lt;list&gt;<subscript>1</subscript>,&lt;list&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry><literal>&lt;list&gt;<subscript>1</subscript></literal>
                DIFF <literal>&lt;list&gt;<subscript>2</subscript></literal>
                (difference on multi-set)</entry>
              </row>

              <row>
                <entry><literal>inter(&lt;list&gt;<subscript>1</subscript>,&lt;list&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry><literal>&lt;list&gt;<subscript>1</subscript></literal>
                INTER <literal>&lt;list&gt;<subscript>2</subscript></literal>
                (intersection on multi-set)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section xml:id="section.term-functions">
        <title>Functions on terms</title>

        <para><table>
            <title>Functions on lterms</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>is-bool(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>bool</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-int(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>int</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-real(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>real</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-str(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>str</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-bstr(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is of type
                  <literal>bstr</literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-appl(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is an application
                  then <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-list(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a list then
                  <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-empty(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> isequal to
                  <literal>[] </literal> then <literal>true</literal>;
                  otherwise <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-var(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a variable then
                  <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-var(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a variable then
                  <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-result-var(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a result
                  variable then <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>is-formal(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;bool&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a formal
                  variable then <literal>true</literal>; otherwise
                  <literal>false</literal>.</entry>
                </row>

                <row>
                  <entry><literal>fun(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;str&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a function
                  application then its function symbol; otherwise
                  <literal>""</literal>.</entry>
                </row>

                <row>
                  <entry><literal>args(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;list&gt;</literal></entry>

                  <entry>If<literal> &lt;term&gt;</literal> is a function
                  application then its argument; otherwise
                  <literal>[]</literal>.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.time-functions">
        <title>Time-related functions</title>

        <para><table>
            <title>Time-related functions</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>current-time</literal></entry>

                  <entry><literal>&lt;list&gt;</literal></entry>

                  <entry>Six-tuple describing the urrent absolute time</entry>
                </row>

                <row>
                  <entry><literal>sec(&lt;int&gt;)</literal></entry>

                  <entry><literal>&lt;int&gt;</literal></entry>

                  <entry>Convert &lt;int&gt; into seconds</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.misc-functions">
        <title>Miscellaneous functions</title>

        <para><table>
            <title>Miscellaneous functions</title>

            <tgroup cols="3">
              <colspec align="left" colwidth="3*" />

              <colspec align="left" colwidth="1*" />

              <colspec align="left" colwidth="2*" />

              <thead>
                <row>
                  <entry align="center">Function&#160;</entry>

                  <entry align="center">Result type&#160;</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>process-id</literal></entry>

                  <entry><literal>&lt;int&gt;</literal></entry>

                  <entry>Process id of the current process</entry>
                </row>

                <row>
                  <entry><literal>process-name</literal></entry>

                  <entry><literal>&lt;str&gt;</literal></entry>

                  <entry>Name of the current process</entry>
                </row>

                <row>
                  <entry><literal>quote(&lt;term&gt;)</literal></entry>

                  <entry><literal>&lt;term&gt;</literal></entry>

                  <entry>Quoted (unevaluated) term; only variables are
                  replaced by their values</entry>
                </row>

                <row>
                  <entry><literal>functions</literal></entry>

                  <entry><literal>&lt;list&gt;</literal></entry>

                  <entry>List of all built-in functions</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>
    </section>

    <section xml:id="section.synopsis-toolbus-primitives">
      <title>Synopsis of ToolBus primitives</title>

      <para>In the following two sections all primitives are summarized that
      can occur in a Tscript.</para>

      <section xml:id="section.process-related-primitives">
        <title>Process-related primitives in Tscripts</title>

        <para><table>
            <title>Process-related primitives in Tscripts</title>

            <tgroup cols="3">
              <colspec align="left" colname="col1" colwidth="2*" />

              <colspec align="left" colname="col2" colwidth="3*" />

              <colspec align="left" colname="col3" colwidth="1*" />

              <thead>
                <row>
                  <entry>Primitive</entry>

                  <entry>Synopsis</entry>

                  <entry>See</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>delta</entry>

                  <entry>Inaction (deadlock)</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry>tau</entry>

                  <entry>Internal step</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  +
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry>Choice between
                  <replaceable>P</replaceable><subscript>1</subscript> and
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  .
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  followed by
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  ||
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  parallel with
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><replaceable>P</replaceable><subscript>1</subscript>
                  *
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry>Repeat
                  <replaceable>P</replaceable><subscript>1</subscript> until
                  <replaceable>P</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>if <replaceable>T</replaceable> then
                  <replaceable>P</replaceable> fi</literal></entry>

                  <entry>Guarded command</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>if <replaceable>T</replaceable> then
                  <replaceable>P</replaceable><subscript>1</subscript> else
                  <replaceable>P</replaceable><subscript>2</subscript>
                  fi</literal></entry>

                  <entry>Conditional</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>create(<replaceable>Pnm</replaceable>(<replaceable>T</replaceable>,
                  ...), <replaceable>Pid</replaceable>?)</literal></entry>

                  <entry>Create new process</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>V</replaceable> :=
                  <replaceable>T</replaceable></literal></entry>

                  <entry>Assign <replaceable>T</replaceable> ( seen as
                  expression) to <replaceable>V</replaceable></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-msg(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Send synchronous message</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-msg(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Receive a synchronous message</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-note(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Broadcast an asynchronous note</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-note(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Receive an asynchronous note</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>no-note(<replaceable>T</replaceable>)</literal></entry>

                  <entry>No note available</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>subscribe(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Subscribe to notes</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>A</replaceable>
                  delay(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Relative delay of atom execution</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>A</replaceable>
                  abs-delay(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Absolute delay of atom execution</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>A</replaceable>
                  timeout(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Relative timeout of atom execution</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal><replaceable>A</replaceable>
                  abs-timeout(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Absolute timeout of atom execution</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>shutdown(<replaceable>T</replaceable>)</literal></entry>

                  <entry>Terminate ToolBus application</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>printf(<replaceable>S</replaceable>,
                  <replaceable>T</replaceable>, ...)</literal></entry>

                  <entry>Print terms according to format string S</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>read(<replaceable>T</replaceable><subscript>1</subscript>,
                  <replaceable>T</replaceable><subscript>2</subscript>)</literal></entry>

                  <entry>Give prompt
                  <replaceable>T</replaceable><subscript>1</subscript>and read
                  term that should match with
                  <replaceable>T</replaceable><subscript>2</subscript></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>process
                  <replaceable>Pnm</replaceable>(<replaceable>F</replaceable>,
                  ...) is <replaceable>P</replaceable></literal></entry>

                  <entry>Define process <literal>
                  <replaceable>Pnm</replaceable> </literal></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>let <replaceable>F</replaceable>, ... in
                  <replaceable>P</replaceable> endlet</literal></entry>

                  <entry>Declare local variables in
                  <replaceable>P</replaceable></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>toolbus(<replaceable>Pnm</replaceable>(<replaceable>T</replaceable>,...),
                  ...)</literal></entry>

                  <entry>Define initial ToolBus process configuration</entry>

                  <entry></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="section.tool-related-primitives">
        <title>Tool-related primitives in Tscripts</title>

        <para><table>
            <title>Tool-related primitives in Tscripts</title>

            <tgroup cols="3">
              <colspec align="left" colname="col1" colwidth="2*" />

              <colspec align="left" colname="col2" colwidth="3*" />

              <colspec align="left" colname="col3" colwidth="1*" />

              <thead>
                <row>
                  <entry>Primitive</entry>

                  <entry>Synopsis</entry>

                  <entry>See</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>rec-connect(<replaceable>Tid</replaceable>?)</literal></entry>

                  <entry>Receive connection request from tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-disconnect(<replaceable>Tid</replaceable>?)</literal></entry>

                  <entry>Receive disconnection request from tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>execute(<replaceable>Tnm</replaceable>(<replaceable>T</replaceable>,...),
                  <replaceable>Tid</replaceable>?)</literal></entry>

                  <entry>Execute a tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-terminate(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Terminate execution of a tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-eval(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Send evaluation request to tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-cancel(<replaceable>Tid</replaceable>)</literal></entry>

                  <entry>Cancel previous evaluation request</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-value(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Receive answer to evaluation request</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-do(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Send evaluation request to tool (no return
                  value)</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>rec-event(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>, ...)</literal></entry>

                  <entry>Receive event from tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>snd-ack-event(<replaceable>Tid</replaceable>,
                  <replaceable>T</replaceable>)</literal></entry>

                  <entry>Acknowledge previous event from tool</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>tool <replaceable>Tnm</replaceable> is {
                  <replaceable>Feat</replaceable>, ... }</literal></entry>

                  <entry>Define tool <replaceable>Tnm</replaceable></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>host =
                  <replaceable>Str</replaceable></literal></entry>

                  <entry>Host feature in tool definition</entry>

                  <entry></entry>
                </row>

                <row>
                  <entry><literal>command =
                  <replaceable>Str</replaceable></literal></entry>

                  <entry>Command feature in tool definition</entry>

                  <entry></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>
    </section>
  </section>

  <section>
    <title>Historical notes</title>

    <para>The first generation Toolbus is described in <xref
    linkend="BergstraKlint94" />. In addition to the design, the complete C
    implementation is discussed in detail. The second generation ("discrete
    time") ToolBus includes timing primitives as well as built-in functions.
    It has been formally described using ASF+SDF, see <xref
    linkend="BergstraKlint95" /> and <xref linkend="BergstraKlint98" />. In
    <xref linkend="Olivier00" /> a framework for the debugging of ToolBus
    applications is presented. Initial thoughts about a next generation
    ToolBus were published in <xref linkend="deJongKlint03" />. <xref
    linkend="deJong07" /> describes architectural aspects of ToolBus-based
    applications.<warning>
        <para>Add: theses of Peter Heibrink, Arnold Lankamp, Dennis
        Hendriks.</para>
      </warning></para>
  </section>

  <section>
    <title>Bibliography</title>

    <para><bibliolist>
        <bibliomixed xml:id="BergstraKlint94"></bibliomixed>

        <bibliomixed xml:id="BergstraKlint95"></bibliomixed>

        <bibliomixed xml:id="BergstraKlint98"></bibliomixed>

        <bibliomixed xml:id="deJongKlint03"></bibliomixed>

        <bibliomixed xml:id="deJong07"></bibliomixed>

        <bibliomixed xml:id="Olivier00"></bibliomixed>
      </bibliolist></para>
  </section>

  <section xml:id="section.toolbus-to-do">
    <title>To Do</title>

    <itemizedlist>
      <listitem>
        <para>Write the demo sections.</para>
      </listitem>

      <listitem>
        <para>Write Java section.</para>
      </listitem>

      <listitem>
        <para>Write Tcl/Tk etc. section.</para>
      </listitem>

      <listitem>
        <para>What do we do with the other adapters?</para>
      </listitem>

      <listitem>
        <para>Describe current viewer.</para>
      </listitem>

      <listitem>
        <para>Describe console commands.</para>
      </listitem>

      <listitem>
        <para>Do we describe the global structure of the Java implementation
        (or partially refer to online docs)?</para>
      </listitem>

      <listitem>
        <para>Describe viewer interface.</para>
      </listitem>

      <listitem>
        <para>Add id's to sections.</para>
      </listitem>

      <listitem>
        <para>Add cross references.</para>
      </listitem>
    </itemizedlist>

    <para></para>
  </section>
</chapter>