<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Guide to ToolBus Programming</title>

  <warning>
    <para>This document is in state of creation and will further evolve. It
    provides a description of the classic C-based ToolBus as well as of the
    Java-based ToolBusNG. Eventually, it will exclusively focus on
    ToolBusNG.</para>
  </warning>

  <section>
    <title>Introduction</title>

    <section>
      <title>Background and Motivation</title>

      <para>Building large, heterogeneous, distributed software systems poses
      serious problems for the software engineer. Systems grow
      <emphasis>larger</emphasis> because the complexity of the tasks we want
      to automate increases. They become <emphasis>heterogeneous</emphasis>
      because large systems may be constructed by re-using existing software
      as components. It is more than likely that these components have been
      developed using different implementation languages and run on different
      hardware platforms. Systems become <emphasis>distributed</emphasis>
      because they have to operate in the context of local area
      networks.</para>

      <para>Three aspects of heterogeneous, distributed, systems should be
      considered: <emphasis>coordination</emphasis>,
      <emphasis>representation</emphasis> and
      <emphasis>computation</emphasis>.</para>

      <formalpara>
        <title>Coordination</title>

        <para>Coordination is the way in which program and system parts
        interact with each other using, ordinary procedure calls, remote
        procedure calls (RPC), remote method invocation (RMI), and
        others.</para>
      </formalpara>

      <formalpara>
        <title>Representation</title>

        <para>Representation is the language and machine neutral format for
        data being exchanged between components.</para>
      </formalpara>

      <formalpara>
        <title>Computation</title>

        <para>Computation is done by specialized program code that carries out
        a specific task, e.g., providing a user-interface, providing database
        access, and the like.</para>
      </formalpara>

      <para>Our key assumption is as follows:<important>
          <para>A rigorous separation of coordination from computation is the
          key to flexible and reusable systems.</para>
        </important></para>

      <para>A system organization that respects this separation is shown
      in</para>

      <figure>
        <title>Separating coordination from computation</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="coordination.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>We propose to get control over the possible interactions between
      software components (<emphasis>tools</emphasis>) by forbidding direct
      inter-tool communication. Instead, all interactions are controlled by a
      process-oriented <emphasis>script</emphasis> that formalizes all the
      desired interactions among tools. This leads to a component
      interconnection architecture resembling a hardware communication bus,
      and therefore we call it a ``ToolBus''.</para>
    </section>

    <section>
      <title>The ToolBus architecture</title>

      <para>The global architecture of the ToolBus is shown in <xref
      linkend="figure.toolbus-organization" />. The ToolBus serves the purpose
      of defining the cooperation of a variable number of
      <emphasis>tools</emphasis> <replaceable>T</replaceable><subscript>i
      </subscript>(<replaceable>i</replaceable> = 1, ...,
      <replaceable>m</replaceable>) that are to be combined into a complete
      system. The internal behaviour or implementation of each tool is
      irrelevant: they may be implemented in different programming languages,
      be generated from specifications, etc. Tools may, or may not, maintain
      their own internal state. Here we concentrate on the external behaviour
      of each tool. In general an <emphasis>adapter</emphasis> will be needed
      for each tool to adapt it to the common data representation and message
      protocols imposed by the ToolBus.</para>

      <figure xml:id="figure.toolbus-organization">
        <title>Global organization of the ToolBus</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="architecture.png" scale="60"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The ToolBus itself consists of a variable number of processes
      <replaceable>P</replaceable><subscript>i</subscript>
      (<replaceable>i</replaceable> = 1, ...,
      <replaceable>n</replaceable>)<footnote>
          <para>By ``processes'' we mean here computational activities
          <emphasis>inside</emphasis> the ToolBus as opposed to, for instance,
          processes at the operating system level. When confusing might arise,
          we will call the former ``ToolBus processes'' and the latter
          ``operating system level tasks''.</para>
        </footnote>The parallel composition of the processes
      <replaceable>P</replaceable><subscript>i</subscript> represents the
      intended behaviour of the whole system. Tools are external,
      computational activities, most likely corresponding with operating
      system level tasks. They come into existence either by an execution
      command issued by the ToolBus or their execution is initiated
      externally, in which case an explicit connect command has to be
      performed by the ToolBus. Although a one-to-one correspondence between
      tools and processes seems simple and desirable, we do not enforce this
      and permit tools that are being controlled by more than one process as
      well as clusters of tools being controlled by a single process.</para>

      <formalpara>
        <title>Communication inside the ToolBus</title>

        <para>Inside the ToolBus, there are two communication mechanisms
        available. First, a process can send a <emphasis>message</emphasis>
        (using <literal>snd-msg</literal>) which should be received,
        synchronously, by one other process (using
        <literal>rec-msg</literal>). Messages are intended to request a
        service from another process. When the receiving process has completed
        the desired service it may inform the sender, synchronously, by means
        of another message (using <literal>snd-msg</literal>). The original
        sender can receive the reply using <literal>rec-msg</literal>. By
        convention, part of the the original message is contained in the reply
        (but this is not enforced).</para>
      </formalpara>

      <para>Second, a process can send a <emphasis>note</emphasis> (using
      <literal>snd-note</literal>) which is broadcasted to other, interested,
      processes. The sending process does not expect an answer while the
      receiving processes read notes asynchronously (using
      <literal>rec-note</literal>) at a low priority. Notes are intended to
      notify others of state changes in the sending process. Sending notes
      amounts to <emphasis>asynchronous selective broadcasting</emphasis>.
      Processes will only receive notes to which they have
      <emphasis>subscribed</emphasis>.</para>

      <para><figure xml:id="figure.tool-communication">
          <title>Communication between ToolBus and tools</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="tool-protocol.png" scale="80"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <formalpara>
        <title>Communication between ToolBus and tools</title>

        <para>The communication between ToolBus and tools is based on
        handshaking communication between a ToolBus process and a tool. A
        process may send messages in several formats to a tool
        (<literal>snd-eval</literal>, <literal>snd-do</literal>, and
        <literal>snd-ack-event</literal>) while a tool may send the messages
        <literal>snd-event</literal> and <literal>snd-value</literal> to a
        ToolBus process. There is no direct communication possible between
        tools. These communication patterns are shown in <xref
        linkend="figure.tool-communication" />.</para>
      </formalpara>

      <para>The execution and termination of the tools attached to the ToolBus
      can be explicitly controlled. It is also possible to connect or
      disconnect tools that have been executing independently of the
      ToolBus.</para>

      <formalpara>
        <title>Knowledge separation</title>

        <para>Equipped with the mechanisms provided by the ToolBus, carefull
        control over application knowledge can be achieved as shown in <xref
        linkend="figure.toolbus-application" /> where an application is
        depicted consisting of a user-interface (UI) and a database (DB). In a
        more conventional approach, elements of the user-interface, say a
        button, would be directly connected with functions in the database
        component and a strong coupling between the two components would be
        the result. Using the ToolBus, the two components can be completely
        oblivious of each other. It is only in the ToolBus script that they
        are configured to work together. The extra level of indirection
        introduced by the ToolBus thus leads to extra flexibility and
        decoupling.</para>
      </formalpara>

      <para><figure xml:id="figure.toolbus-application">
          <title>Knowledge separation in ToolBus-based application</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="application.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>

    <section>
      <title>How to go from here?</title>

      <para>After this brief motivation and explanation of the ToolBus
      architecture it is time to delve into more details. In the remainder of
      this chapter, we will have a look at the following topics:</para>

      <itemizedlist>
        <listitem>
          <para>ToolBus scripts (or Tscripts, for short).</para>
        </listitem>

        <listitem>
          <para>How to write ToolBus tools.</para>
        </listitem>

        <listitem>
          <para>A brief peek at the ToolBus implementation.</para>
        </listitem>

        <listitem>
          <para>Historical notes</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Tscripts</title>

    <para>Tscripts describe how the tools in an application cooperate. They
    allow the definition of a collection of concurrent processes that can
    communicate with eachother and with the tools in the application.</para>

    <section>
      <title>Terms</title>

      <para>Tscripts make heavy use of <emphasis>terms</emphasis>, simple
      prefix expressions that are used to exchange structured data between
      processes and tools. Terms are recursively defined as follows:</para>

      <itemizedlist>
        <listitem>
          <para>A Boolean constant, integer constant, real constant, or string
          constant is a term, e.g., <literal>true</literal>,
          <literal>37</literal>, <literal>314e-12</literal>, or
          <literal>"rose"</literal>.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>value occurrence</emphasis> of a variable is a
          term, e.g., <literal>X</literal>, <literal>InitialAmount</literal>,
          or <literal>Highest-Bid</literal>.</para>

          <important>
            <para>Variables always start with a capital letter. A value
            occurence serves the purpose of using the current value of a
            variable.</para>
          </important>
        </listitem>

        <listitem>
          <para>A <emphasis>result occurrence</emphasis> of a variable is a
          term, e.g., <literal>X?</literal>, <literal>InItialAmount?</literal>
          or <literal>Highest-Bid?</literal>.</para>

          <important>
            <para>A result occurrence of a variable plays a role when this
            term is <emphasis>matched</emphasis> with another term. In the
            case that the match succeeds, the corresponding part of the other
            term is assigned to the result variable.</para>
          </important>
        </listitem>

        <listitem>
          <para>A single <emphasis>identifier</emphasis> is a term, e.g.,
          <literal>f</literal>, <literal>pair</literal>, or
          <literal>zero</literal>.</para>

          <important>
            <para>Identifier alwas start with a lowercase letter.</para>
          </important>
        </listitem>

        <listitem>
          <para>A <emphasis>function application</emphasis> is a term, e.g.,
          <literal>pair("rose", address("STREE", 12345)</literal>.</para>
        </listitem>

        <listitem>
          <para>A <emphasis>list</emphasis> is a term, e.g., <literal>[a, b,
          c]</literal> or <literal>[a, 1.25, "lost"]</literal>.</para>
        </listitem>

        <listitem>
          <para>A placeholder is a term, e.g., <literal>&lt;int&gt;</literal>
          or <literal>add(&lt;int&gt;,&lt;int&gt;)</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Matching</title>

      <para>Term matching is used for several purposes in the ToolBus:</para>

      <itemizedlist>
        <listitem>
          <para>To determine which actions can communicate with each other.
          For instance, a <literal>snd-msg</literal> and a
          <literal>rec-msg</literal> can only communicate if their arguments
          match.</para>
        </listitem>

        <listitem>
          <para>To transfer information between sender and receiver.</para>
        </listitem>

        <listitem>
          <para>To do case analysis, for instance, when receiving events from
          a tool.</para>
        </listitem>
      </itemizedlist>

      <para>Intuitively, the matching between two terms works as
      follows:</para>

      <itemizedlist>
        <listitem>
          <para>Two terms match if they are structurally identical.</para>
        </listitem>

        <listitem>
          <para>For a value occurrence of a variable: use its current
          value.</para>
        </listitem>

        <listitem>
          <para>For a result occurrence of a variable: assign the matched
          subterm of the other term to the variable (but make this only
          permanent if the overall match succeeds).</para>
        </listitem>
      </itemizedlist>

      <para>This illustrated in <xref linkend="figure.match-example" />.
      Before the match, two contexts are given. Each context associates some
      variables with a value. For instance, Context 1 associates the value
      <literal>3</literal> with variable <literal>X</literal>. For each
      context a term is given and the challenge is to match these two terms
      and to observe the effects on the two contexts. The matching of the two
      terms can be understood as follows:</para>

      <itemizedlist>
        <listitem>
          <para>The toplevel function names are identical (both
          <literal>f</literal>) and both have the same number of arguments.
          The left term and the right term match if their arguments
          match.</para>
        </listitem>

        <listitem>
          <para>The first argument in the left term is <literal>X</literal>
          and <literal>3</literal> in the right term. Since,
          <literal>X</literal> has value <literal>3</literal> in Context 1,
          they match.</para>
        </listitem>

        <listitem>
          <para>The second argument in the left term is <literal>4</literal>
          and <literal>Z?</literal> in the right term. By assigning
          <literal>4</literal> to <literal>Z</literal> in Context 2 we achieve
          a match.</para>
        </listitem>

        <listitem>
          <para>The third argument in the leftvterm is <literal>Y?</literal>
          and <literal>5</literal> in the right term. Here we achieve a match
          by assigning <literal>5</literal> to <literal>Y</literal> in Context
          1.</para>
        </listitem>

        <listitem>
          <para>The fourth and last argument of both terms is
          <literal>6</literal> and thus matches.</para>
        </listitem>
      </itemizedlist>

      <para>The net result is that both terms match and that Context 1 and
      Context 2 are modified as shown iat the bottom of the figure.</para>

      <para><figure xml:id="figure.match-example">
          <title>Example of term matching</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="match-example.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>

    <section>
      <title>Types</title>

      <para>The ToolBus uses a type system that is a compromise between the
      safety of static checking and the flexibility of dynamic typing. Another
      objective of the type system is to provide sufficient information to
      enable the automatic generation of adapter code for tools. Type are
      defined as follows:</para>

      <itemizedlist>
        <listitem>
          <para><literal>bool</literal>, <literal>int</literal>,
          <literal>real</literal> and <literal>str</literal> are the types of
          the elementary terms.</para>
        </listitem>

        <listitem>
          <para><literal>list</literal> is the type of arbitrary lists.</para>
        </listitem>

        <listitem>
          <para><literal>list(<replaceable>Type</replaceable>)</literal> is
          the type of lists with elements of type
          <replaceable>Type</replaceable>. For instance,
          <literal>list(int)</literal> is the type of lists of
          integers.</para>
        </listitem>

        <listitem>
          <para><replaceable>Id</replaceable> is the type of all terms with
          function symbol <replaceable>Id</replaceable> (this allows the
          declaration of partial types). The type <literal>f</literal>, thus
          corresponds to the terms <literal>f</literal>,
          <literal>f(1)</literal>, <literal>f("abc", 3)</literal> and the
          like.</para>
        </listitem>

        <listitem>
          <para><literal>Id(<replaceable>Type</replaceable><subscript>1</subscript>,
          ...,
          <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript>)</literal>
          is the type of terms with function symbol
          <replaceable>Id</replaceable> and the given types
          <replaceable>Type</replaceable><subscript>1</subscript>, ...,
          <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript>a
          s argument types. For instance, <literal>f(int,str)</literal>
          accepts <literal>f(3,"abc")</literal> but not
          <literal>f(3)</literal>.</para>
        </listitem>

        <listitem>
          <para>[<replaceable>Type</replaceable><subscript>1</subscript>, ...,
          <replaceable>Type</replaceable><subscript><replaceable>n</replaceable></subscript>]
          is the type of a list of elements with the given types
          <replaceable>Type</replaceable><subscript>1</subscript>, ...,
          <replaceable>Type<subscript>n</subscript>.</replaceable> For
          instance, <literal>[int, str]</literal> accepts <literal>[1,
          "abc"]</literal>, but not <literal>[1,2,3]</literal>.</para>
        </listitem>

        <listitem>
          <para><literal>term</literal> is the type of an arbitrary term. And
          is used as escape from the more precise typing by the preceeding
          types.</para>
        </listitem>
      </itemizedlist>

      <para>Types are used in the following ways:</para>

      <itemizedlist>
        <listitem>
          <para>All variables have a type.</para>
        </listitem>

        <listitem>
          <para>Types are statically checked whenever possible. Only in the
          case of type <literal>term</literal>, dynamic checks are
          needed.</para>
        </listitem>

        <listitem>
          <para>Types play a role during matching: a match can also fail if
          the types of corresponding subterms are unequal. For instance, given
          <literal>I</literal> as <literal>int</literal> variable,
          <literal>S</literal> as <literal>str</literal> variable and
          <literal>T</literal> as <literal>term</literal> variable,</para>

          <itemizedlist>
            <listitem>
              <para><literal>f(13)</literal> and <literal>f(I?)</literal> will
              match.</para>
            </listitem>

            <listitem>
              <para><literal>f(13)</literal> and <literal>f(S?)</literal> will
              fail.</para>
            </listitem>

            <listitem>
              <para><literal>f(13)</literal> and <literal>f(T?)</literal> will
              succeed.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Tscripts</title>

      <section>
        <title>Overall structure</title>

        <para>A Tscript can define the following ingredients:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>process definition</emphasis> consisting of a
            process name, optional parameters and a process expression that
            describes the behaviour of this process.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>tool definition</emphasis> consisting of a tool
            name and some operational details, such as the command to execute
            when the tool is started.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>ToolBus configuration</emphasis> consisting of
            one or more process names (optionally followed by actual
            parameters) that will be created when the application is started.
            A Tscript may contain more than one ToolBus configuration.</para>
          </listitem>

          <listitem>
            <para>An <emphasis>include file</emphasis> that contains another
            Tscript that will be literally included.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>constant definition</emphasis>.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>conditional</emphasis> that allows the condional
            inclusion or exclusion of parts of the Tscript.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>A first example</title>

        <para>Beforer delving into the details of Tscripts, it is good to have
        a look at the hello world application
        <filename>hello1.tb</filename>:</para>

        <programlisting>process HELLO <co xml:id="co.hello1-1" />
is <co xml:id="co.hello1-2" />
  printf(“Hello world, my first Tscript!\n”) <co xml:id="co.hello1-3" />

toolbus(HELLO) <co xml:id="co.hello1-4" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="co.hello1-1">
            <para>Here starts the definition of a process with name
            <literal>HELLO</literal>.</para>
          </callout>

          <callout arearefs="co.hello1-2">
            <para>After the keyword <literal>is</literal> follows the process
            expression that defines the behaviour of this process.</para>
          </callout>

          <callout arearefs="co.hello1-3">
            <para>The process expression consists of a single action that
            prints a string.</para>
          </callout>

          <callout arearefs="co.hello1-4">
            <para>Define the initial ToolBus configuration, in this case only
            process HELLO will be started.</para>
          </callout>
        </calloutlist>

        <para>Running this example will yield the following command line
        dialog:</para>

        <screen>1&gt; toolbus hello1.tb
Hello world, my first Tscript!
2&gt;</screen>

        <para>Becoming more courageous, we show now a more ambituous Tscript
        <literal>hello2.tb</literal> that does not print the hello string
        itself, but executes a tool to compute it.</para>

        <programlisting>process HELLO is <co xml:id="co.hello2-1" />
  let H : hello, <co xml:id="co.hello2-2" />
      S : str    <co xml:id="co.hello2-3" />
  in
         execute(hello, H?) <co xml:id="co.hello2-4" /> .   <co
            xml:id="co.hello2-5" />
         snd-eval(H, get-text) .   <co xml:id="co.hello2-6" />
         rec-value(H, text(S?)).   <co xml:id="co.hello2-7" />
         printf(S)                 <co xml:id="co.hello2-8" />
  endlet

tool hello is {command = “hello” } <co xml:id="co.hello2-9" />
toolbus(HELLO)                     <co xml:id="co.hello2-10" /></programlisting>

        <para>Notes:</para>

        <calloutlist>
          <callout arearefs="co.hello2-1">
            <para>Define a process <literal>HELLO</literal>.</para>
          </callout>

          <callout arearefs="co.hello2-2">
            <para>Use a <literal>let ... in ... endlet</literal> construct to
            declare local variables. Variable <literal>H</literal> is declared
            with type <literal>hello</literal>.</para>
          </callout>

          <callout arearefs="co.hello2-3">
            <para>Variable <literal>S</literal> is declared with type
            <literal>str</literal>.</para>
          </callout>

          <callout arearefs="co.hello2-4">
            <para>Execute the <literal>hello</literal> tool (according to the
            tool definition at <xref linkend="co.hello2-9" />). The resulting
            tool identifier is assigned to variable <literal>H</literal>.
            Observe that the name of the tool and the type of
            <literal>H</literal> are identical.</para>
          </callout>

          <callout arearefs="co.hello2-5">
            <para>Use the sequential composition operator <literal>.</literal>
            to combine atom actions into a larger process expression.</para>
          </callout>

          <callout arearefs="co.hello2-6">
            <para>Send an evaluation request to the tool we have just
            executed. <literal>H</literal> identifies the tool instance, and
            <literal>get-text</literal> is the term to be sent to the hello
            tool.</para>
          </callout>

          <callout arearefs="co.hello2-7">
            <para>In response to the evaluation request, the hello tool
            returns a value of the form <literal>text("Hello world from my
            first tool")</literal>. The actual text is extracted by the result
            variable <literal>S?</literal>.</para>
          </callout>

          <callout arearefs="co.hello2-8">
            <para>Print the string value of <literal>S</literal>.</para>
          </callout>

          <callout arearefs="co.hello2-9">
            <para>The definition for the hello tool. It contains the name of
            an executable program to be run when this tool is executed.</para>
          </callout>

          <callout arearefs="co.hello2-10">
            <para>The initial ToolBus configuration consisting of just the
            <literal>HELLO</literal> process.</para>
          </callout>
        </calloutlist>

        <para>All the Tscript primitives (including the ones that occur in
        these two simple examples) will now be described in more depth.</para>
      </section>

      <section>
        <title>Process primitives</title>

        <para>During execution, the ToolBus consists of a parallel composition
        of processes. The ToolBus configurations define the processes that are
        created at the start of the start of the application, but later on
        processes may die and new ones may be created.</para>

        <para>Each process has a local state in the form of private local
        variables. These variables get their value through assignment and
        matching. They are only visible inside each process.</para>

        <para>Processes are built-in up from atomic actions (detailed below)
        and atomic actions can be combined into process expressions using the
        following operators:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Sequential composition</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> .
            <replaceable>P</replaceable><subscript>2</subscript></literal>.
            First the actions in <replaceable>
            P</replaceable><subscript>1</subscript>are executed and then the
            ones in
            <replaceable>P</replaceable><subscript>2</subscript>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Choice</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> +
            <replaceable>P</replaceable><subscript>2</subscript></literal>. A
            choice is made between the first action in
            <replaceable>P</replaceable><subscript>1</subscript>and the first
            action in <replaceable>P</replaceable><subscript>2</subscript>.
            This choice is based on two criteria:</para>

            <itemizedlist>
              <listitem>
                <para>An action to be selected must be
                <emphasis>enabled</emphasis>.</para>
              </listitem>

              <listitem>
                <para>If more than one action is enabled, a random choice is
                made.</para>
              </listitem>
            </itemizedlist>

            <para>There are various ways in which an action can be enabled
            (this depends on the precise action):</para>

            <itemizedlist>
              <listitem>
                <para>An associated condition evaluates to true (see
                conditional and guarded command, below).</para>
              </listitem>

              <listitem>
                <para>An associated timing constraint is true.</para>
              </listitem>

              <listitem>
                <para>Required external tool results are available.</para>
              </listitem>

              <listitem>
                <para>Communication conditions are satisfied.</para>
              </listitem>
            </itemizedlist>

            <para>Once the choice for the first action has been made all
            remaining actions of the selected process expression
            <replaceable>P</replaceable><subscript>1</subscript> or
            <replaceable>P</replaceable><subscript>2</subscript> are executed
            as well.</para>
          </listitem>

          <listitem>
            <para><emphasis>Parallel composition</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> ||
            <replaceable>P</replaceable><subscript>2</subscript></literal>.
            The actions in
            <replaceable>P</replaceable><subscript>1</subscript>and
            <replaceable>P</replaceable><subscript>2</subscript> are executed
            in parallel. This means that the sequential order of the actions
            in
            <replaceable>P</replaceable><subscript>1</subscript>respectively
            <replaceable>P</replaceable><subscript>2</subscript> is respected
            but that apart from this constraint the actions can be executed in
            arbitrary order.</para>
          </listitem>

          <listitem>
            <para><emphasis>Iteration</emphasis>
            <literal><replaceable>P</replaceable><subscript>1</subscript> *
            <replaceable>P</replaceable><subscript>2</subscript></literal>.
            <replaceable>P</replaceable><subscript>1</subscript> is executed
            repeatedly, until an action of
            <replaceable>P</replaceable><subscript>2</subscript> is executed.
            Execution then continues with the remaining actions of
            <replaceable>P</replaceable><subscript>2</subscript>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Conditional</emphasis> <literal>if
            <replaceable>T</replaceable> then
            <replaceable>P</replaceable><subscript>1</subscript> else
            <replaceable>P</replaceable><subscript>2</subscript> fi</literal>.
            The test <replaceable>T</replaceable> is evaluated and if the
            result is true then
            <replaceable>P</replaceable><subscript>1</subscript> is executed,
            otherwise <replaceable>P</replaceable><subscript>2</subscript> is
            executed. Note that the evaluation of the test does not count as a
            separate atomic action; the test is effectively attached to the
            first atom of
            <replaceable>P</replaceable><subscript>1</subscript>respectively
            <replaceable>P</replaceable><subscript>2</subscript>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Guarded command</emphasis> <literal>if
            <replaceable>T</replaceable> then <replaceable>P</replaceable>
            fi</literal>. The test <replaceable>T</replaceable> is evaluated
            and if the result is true then
            <replaceable>P</replaceable><subscript>1</subscript> is executed,
            otherwise this command deadlocks.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Local variables</title>

        <para>As we have seen local variables play a key role in the execution
        of Tscripts. They are defined using the <literal>let</literal>
        construct:</para>

        <itemizedlist>
          <listitem>
            <para>let Var1 : Type1, ... in P endlet. Variables Var1, ... are
            declared with respective type Type1, .... These variables act as
            local variables during the execution of the process expression P.
            P may contain other <literal>let</literal> constructs.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Primitive actions</title>

        <itemizedlist>
          <listitem>
            <para><emphasis>Deadlock</emphasis> <literal>delta</literal>. This
            constant represents the process that cannot execute any further
            steps. During execution deadlock is always avoided as long as this
            is possible. A process that end in deadlock effectively terminates
            and disappears.</para>
          </listitem>

          <listitem>
            <para><emphasis>Silent step</emphasis> <literal>tau</literal>.
            This constant represents one internal step in a process and
            resemble a dummy statement in a conventional programming
            language.</para>
          </listitem>

          <listitem>
            <para>Print printf. An action for generating formatted
            output.</para>
          </listitem>

          <listitem>
            <para><emphasis>Assignment</emphasis>
            <literal><replaceable>V</replaceable> :=
            <replaceable>T</replaceable></literal>. The term
            <literal>T</literal> is evaluated as expression (using the
            built-in functions) and the result is assigned to the local
            variable <replaceable>V</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Messages: synchronous communication primitives</title>

        <para>Synchronous communication resembles an ordinary phone call: it
        involves two processes that can communicate at the same instant in
        time. In ToolBus terminology <emphasis>messages</emphasis> are used
        for synchronous communication. There are two primitives
        involved:</para>

        <itemizedlist>
          <listitem>
            <para><literal>snd-msg</literal> sends a message to another
            process.</para>
          </listitem>

          <listitem>
            <para><literal>rec-msg</literal> receives a message from another
            process.</para>
          </listitem>
        </itemizedlist>

        <para>Two requirements have to be satisfied before communication can
        take place:</para>

        <itemizedlist>
          <listitem>
            <para>The arguments of <literal>snd-msg</literal> and
            <literal>rec-msg</literal> match with each other.</para>
          </listitem>

          <listitem>
            <para>In addition, <literal>snd-msg</literal> respectively
            <literal>rec-msg</literal> are enabled in each process.</para>
          </listitem>
        </itemizedlist>

        <para>When communication takes place, the effects of the argument
        matching is recorded in the local state of each process and both
        continue execution. The observant reader may have noticed that sending
        and receiving is actually symmetric: by way of result variablesin the
        arguments of <literal>snd-msg</literal> and <literal>rec-msg</literal>
        information may flow from sender to receiver and <emphasis>vice
        versa</emphasis>.</para>
      </section>

      <section>
        <title>Notes: asynchronous broadcasting primitives</title>

        <para>Asynchronous communication resembles conventional e-mail: it
        involves one sending and zero or more receiving processes that read
        the communicated information at a later instant in time. In ToolBus
        terminology <emphasis>notes</emphasis> are used for asynchronous
        communication. There four primitives involved:</para>

        <itemizedlist>
          <listitem>
            <para><literal>subscribe(<replaceable>T</replaceable>)</literal>.
            Subscribes a process to notes that match the term
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>unsubscribe(<replaceable>T</replaceable>)</literal>.
            Unsubscribes a process from notes that match
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>snd-note(<replaceable>T</replaceable>)</literal>.
            Broadcast the term <replaceable>T</replaceable> to all subscribed
            processes. Effectively, <replaceable>T</replaceable> is placed in
            the private inbox of each subscribed process to be read at a later
            moment.</para>
          </listitem>

          <listitem>
            <para><literal>rec-note(<replaceable>T</replaceable>)</literal>.
            Receive a note that matches <replaceable>T</replaceable>.
            Effectively, the private inbox is searched for a note that matches
            <replaceable>T</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal>no-note(<replaceable>T</replaceable>)</literal>.
            There is no note that matches <replaceable>T</replaceable> in the
            private inbox.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Using named processes</title>

        <para>A process definition associates a name
        <replaceable>Pnm</replaceable> (optinally followed by parameters) with
        a process expression <replaceable>P</replaceable>. These process names
        can be used in two ways in process expressions:</para>

        <itemizedlist>
          <listitem>
            <para>An <emphasis>inline process expression</emphasis>
            <literal><replaceable>Pnm</replaceable>(...)</literal>:
            Effectively, this amount to macro substitution:
            <replaceable>Pnm</replaceable> is replaced by the process
            expression <replaceable>P</replaceable> (after proper parameter
            substitution).</para>
          </listitem>

          <listitem>
            <para>A <emphasis>process creation</emphasis>
            <literal>create(<replaceable>Pnm</replaceable>(...),
            <replaceable>Pid</replaceable>?)</literal>: a completely new
            process is created that runs in parallel with all other processes
            currently running in the ToolBus. The process identifier of this
            new process is assigned to <replaceable>Pid</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Tool primitives</title>

        <para>There two possible scenarios for a ToolBus tool. In scenario 1,
        the tool is executed from the ToolBus, the tool receives a number of
        evaluation requests and/or generates an number of events, and finally,
        the ToolBus decides to terminate the execution of the tool. A
        variation of scenario 1 is that the tool decides to disconnect from
        the ToolBus and continues execution disconnect from the ToolBus
        application. In scenario 2, the tool is executed separately and
        startes its cooperation by requesting a connection with the ToolBus.
        Once connected, it follows the same steps as in scenario 1. The
        following primitives achieve this (also see <xref
        linkend="figure.tool-communication" /> for the various communication
        patterns between ToolBus and tools):</para>

        <itemizedlist>
          <listitem>
            <para><literal>execute(<replaceable>Tnm</replaceable>,
            <replaceable>Tid</replaceable>?)</literal>: Execute a tool with
            name <replaceable>Tnm</replaceable>. The result is a
            <emphasis>tool identifier</emphasis> that is bound to
            <replaceable>Tid</replaceable>. Tool indentifiers are unique; if
            more than one instance of the same tool is executing they can be
            distinguished via their tool indentifier. There are two additional
            constraints:</para>

            <itemizedlist>
              <listitem>
                <para>The Tscript should contain a tool definition for
                <replaceable>Tnm</replaceable>.</para>
              </listitem>

              <listitem>
                <para>The variable Tid should have a type that corresponds
                with the tool name, i.e., it should be declared as
                <literal><replaceable>Tid</replaceable> :
                <replaceable>Tnm</replaceable></literal>. Why? Well this in
                this way the implementation can track via the type of the tool
                indentifier in each tool request, <emphasis>which</emphasis>
                tool it is and that information is essential for the automatic
                generation of adapter code.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><literal>snd-terminate(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: terminates the execution
            of the tool instance <replaceable>Tid</replaceable>. The term
            <replaceable>T</replaceable> contains a reason for the termination
            and is usually printed by the tool on termination.</para>
          </listitem>

          <listitem>
            <para><literal>rec-connect(<replaceable>Tnm</replaceable>,
            <replaceable>Tid</replaceable>?)</literal>: receive a connection
            request for a tool with name <replaceable>Tnm</replaceable>.
            <literal>rec-connect</literal> is very similar to
            <literal>execute</literal>. The only difference is the initiating
            party: for <literal>execute</literal> the ToolBus and for
            <literal>rec-connect</literal> the tool.</para>
          </listitem>

          <listitem>
            <para><literal>rec-disconnect(<replaceable>Tid</replaceable>?)</literal>:
            receive a disconnection request from a tool. It does not matter
            whether the connection with the tool was originally established
            via <literal>execute</literal> or
            <literal>rec-connect</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>snd-eval(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: send an evaluation
            request to a tool. All value occurrences in
            <replaceable>T</replaceable> are first replaced by their value
            before sending <replaceable>T</replaceable> to the tool. It is up
            to the tool to interpret the term. The usual scenario is that the
            outermost function symbol of <replaceable>T</replaceable> is
            identical to the name of a procedure in the tool and that that
            procedure is called. The ToolBus can only send one evaluation
            request at a time. Only when the request is cancelled, or a value
            is returned by the tool, the next request can be sent to the
            tool.</para>
          </listitem>

          <listitem>
            <para><literal>snd-cancel(<replaceable>Tid</replaceable>)</literal>:
            cancel a previous evaluation request.</para>
          </listitem>

          <listitem>
            <para><literal>rec-value(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: recieve a value from a
            tool in response to a previous <literal>snd-eval</literal>
            request. <replaceable>T</replaceable> has to match the value from
            the tool; this is usefull for case distinctions. In many case, T
            consists of a single result variable, or a is a term that contains
            result variables.</para>
          </listitem>

          <listitem>
            <para><literal>snd-do(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable>)</literal>: send an evaluation
            request to a tool but do not expect a return value. Typically used
            to implement printing or logging activities.</para>
          </listitem>

          <listitem>
            <para><literal>rec-event(<replaceable>Tid</replaceable>,
            <replaceable>T</replaceable><subscript>1</subscript>,
            ...)</literal>: receive an event from a tool. Events need not be
            handled one-by-one. The same tool may generate more than one event
            provided that the value of argument
            <replaceable>T</replaceable><subscript>1</subscript> differs.
            <replaceable>T</replaceable><subscript>1</subscript> thus serves
            as identification for this event.</para>
          </listitem>

          <listitem>
            <para><literal>snd-ack-event(<replaceable>Tid</replaceable>,
            <replaceable><replaceable>T</replaceable><subscript>1</subscript></replaceable>)</literal>:
            acknowledge the completion of the handling of a previous event.
            Since, <replaceable>T</replaceable><subscript>1</subscript> is
            identical to the
            <replaceable>T</replaceable><subscript>1</subscript> in a
            preceeding <literal>snd-event</literal> and is used to identify
            that event.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Timing primitives</title>

        <para><warning>
            <para>Timing primitives not yet enabled in ToolBusNG.</para>
          </warning>Time can play an important role in applications, be it as
        ingredient in a protocol that prescribes certain time constraints, be
        it as watchdog that certain operations are carried out in time. The
        general approach in Tscripts is that a delay or timeout may be
        attached to every atom action. Delays and timeouts may be relative to
        the current time or they may be specified in absolute time. The
        primitives are as follows (for arbitrary atomic action
        <replaceable>A</replaceable>):</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Relative delay</emphasis>:
            <literal><replaceable>A</replaceable>
            delay(<replaceable>E</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> can only become enabled after
            <replaceable>E</replaceable><replaceable> </replaceable>seconds
            have passed.</para>
          </listitem>

          <listitem>
            <para><emphasis>Absolute delay</emphasis>:
            <literal><replaceable>A</replaceable>
            abs-delay(<replaceable>Year</replaceable>,
            <replaceable>Month</replaceable>, <replaceable>Day</replaceable>,
            <replaceable>Hour</replaceable>, <replaceable>Min</replaceable>,
            <replaceable>Sec</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> can only become enabled after the
            specified absolute date and time.</para>
          </listitem>

          <listitem>
            <para><emphasis>Relative timeout</emphasis>:
            <literal><replaceable>A</replaceable>
            timeout(<replaceable>E</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> is only enabled during the next
            <replaceable>E</replaceable> seconds.</para>
          </listitem>

          <listitem>
            <para><emphasis>Absolute timeout</emphasis>:
            <literal><replaceable>A</replaceable>
            abs-timeout(<replaceable>Year</replaceable>,
            <replaceable>Month</replaceable>, <replaceable>Day</replaceable>,
            <replaceable>Hour</replaceable>, <replaceable>Min</replaceable>,
            <replaceable>Sec</replaceable>)</literal>. Atom
            <replaceable>A</replaceable> is only enabled until the specified
            absolute date and time.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Expressions</title>

        <para>Terms can occur in Tscripts on various locations. In the
        majority of cases these terms are used as such; only variables are
        replaced by their value but no further evaluation of terms take place.
        There are, however, two exceptions to this general rule. In three
        cases, terms are evaluated:</para>

        <itemizedlist>
          <listitem>
            <para>The test in <literal>if <replaceable>T</replaceable> then
            ... fi</literal> and <literal>if <replaceable>T</replaceable> then
            ... else ... fi</literal>.</para>
          </listitem>

          <listitem>
            <para>The right-hand side of the assignment
            <literal><replaceable>V</replaceable> :=
            <replaceable>T</replaceable></literal>.</para>
          </listitem>

          <listitem>
            <para>In delays or timeouts.</para>
          </listitem>
        </itemizedlist>

        <para>The term is evaluated in a bottom-up manner, i.e., first
        aguments are evaluated and then the function is applied. Here are some
        examples:</para>

        <itemizedlist>
          <listitem>
            <para><literal>not(true)</literal> evaluates to
            <literal>false</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>add(mul(2,3), 4)</literal> evaluates to
            <literal>9</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>greater(6,5)</literal> evaluates to
            <literal>true</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>first([9, 8, 7])</literal> evaluates to
            <literal>9</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>A detailed overview of all built-in functions is given in XXX.
        They can be summarized as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Functions on <emphasis>Booleans</emphasis>:
            <literal>not</literal>, <literal>and</literal>,
            <literal>or</literal>.</para>
          </listitem>

          <listitem>
            <para>Functions on <emphasis>Integers</emphasis>:
            <literal>add</literal>, <literal>sub</literal>,
            <literal>mul</literal>, <literal>mod</literal>,
            <literal>less</literal>, <literal>less-equal</literal>,
            <literal>greater</literal>,
            <literal>greater-equal</literal>.</para>
          </listitem>

          <listitem>
            <para>Functions on <emphasis>lists</emphasis>:
            <literal>first</literal>, <literal>next</literal>,
            <literal>get</literal>, <literal>put</literal>,
            <literal>join</literal>, <literal>member</literal>,
            <literal>subset</literal>, <literal>diff</literal>,
            <literal>inter</literal>, <literal>size</literal>.</para>
          </listitem>

          <listitem>
            <para><emphasis>Miscellaneous</emphasis> functions:
            <filename>equal</filename>, <literal>not-equal</literal>,
            <literal>process-id</literal>, <literal>process-name</literal>,
            <literal>current-time</literal>, <literal>quote</literal>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section>
    <title>Examples of Tscripts</title>

    <para></para>

    <section>
      <title>Calculator</title>

      <para></para>
    </section>

    <section>
      <title>Wave</title>

      <para></para>
    </section>

    <section>
      <title>Auction</title>

      <para></para>
    </section>
  </section>

  <section>
    <title>Executing Toolbus and tools</title>

    <para>The ToolBus interpreter (<command>toolbus</command>) and all tools
    have some standard program arguments in common, but they have some
    specific arguments as well. In this section we describe all possible
    program arguments and the way to execute <command>toolbus</command> and
    tools.</para>

    <section>
      <title>Common arguments</title>

      <para>ToolBus and tools have the following optional arguments in
      common:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-help</literal>: prints a description of all
          arguments of the toolbus or tool.</para>
        </listitem>

        <listitem>
          <para><literal>-verbose</literal>: produces a log of steps taken by
          toolbus or tool that may be useful to debug your script or tool. The
          same effect may be obtained by setting the environment variable
          <literal>TB_VERBOSE</literal> to <literal>true</literal> and export
          it. In the Korn shell this can, for instance, be achieved by:
          <programlisting>TB_VERBOSE=true 
export TB_VERBOSE</programlisting></para>
        </listitem>

        <listitem>
          <para><literal>-TB_PORT
          <replaceable>port_name</replaceable></literal>: defines the
          <emphasis>well known socket</emphasis> <literal>port_name</literal>
          to which all tools temporarily connect in order to set up their own
          private socket that connects them permanently to the ToolBus
          interpreter. When omitted, socket 8998 will be used.</para>
        </listitem>
      </itemizedlist>

      <para>Note that explicit arguments defining the sockets are
      <emphasis>only</emphasis> needed when several ToolBus interpreters are
      running simultaneously on the <emphasis>same</emphasis> host
      machine.</para>
    </section>

    <section>
      <title>ToolBus arguments</title>

      <para>The <replaceable>script_name</replaceable> (see below) given as
      argument to the ToolBus is always preprocessed by a preprocessor before
      it is parsed as a Tscript. In this way, directives like, e.g.,
      <literal>#define</literal>, <literal>#include</literal> and
      <literal>#ifdef</literal> can be used freely in Tscripts. The following
      preprocessor arguments are accepted by the <command>toolbus</command>
      command:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-I<replaceable>dir</replaceable></literal>: append
          directory <literal><replaceable>dir</replaceable></literal> to the
          list of directories searched for include files.</para>
        </listitem>

        <listitem>
          <para><literal>-D<replaceable>name</replaceable></literal>: defines
          <literal><replaceable>name</replaceable></literal> with the string
          <literal>"1" </literal>as its definition.</para>
        </listitem>

        <listitem>
          <para><literal>D<replaceable>name</replaceable>=<replaceable>defn</replaceable></literal>:
          defines <literal><replaceable>name</replaceable></literal> with
          <literal><replaceable>defn</replaceable></literal> as
          definition.</para>
        </listitem>
      </itemizedlist>

      <para>Other arguments specific for the {\tt toolbus} command are:</para>

      <warning>
        <para>The following arguments will probably be supported differently
        in ToolBusNG.</para>
      </warning>

      <itemizedlist>
        <listitem>
          <para><literal>-logger</literal>: execute a logger tool that will be
          attached to all processes in the ToolBus. If the script contains a
          tool definition for a tool named <literal>logger</literal>, that
          will be used for executing the logger. Otherwise a default tool
          definition is used.</para>
        </listitem>

        <listitem>
          <para><literal>-viewer</literal>: similar as above, for a viewer
          tool. The default viewer is the ``ToolBus viewer'' (previously known
          as the ToolBus debugger).</para>
        </listitem>

        <listitem>
          <para><literal>-controller</literal>: similar as above, for a
          controller tool. Currently, no default controller tool is
          provided.</para>
        </listitem>

        <listitem>
          <para><literal>-gentifs</literal>: only generate tool interfaces for
          all tools used in the script in a language independent format. For a
          script file named <filename>script.tb</filename> the tool interfaces
          are written to <filename>script.tifs</filename>. Do not execute the
          script.</para>
        </listitem>

        <listitem>
          <para><literal>-fixed-seed</literal>: use a fixed seed for the
          random generator used by the interpreter for scheduling processes
          and selecting alternatives in processes. By default, the random
          generator is initialized with the current time the
          <command>toolbus</command> command is given. Using the
          <literal>-fixed-seed</literal> option makes the execution of the
          script reproducible across multiple runs of the
          <command>toolbus</command> command.</para>
        </listitem>

        <listitem>
          <para><literal><replaceable>script_name</replaceable></literal>: any
          other argument is the name of the ToolBus script to be
          interpreted.</para>
        </listitem>
      </itemizedlist>

      <para>As an example, consider first <programlisting>toolbus hello.tb</programlisting>which
      starts interpreting the script <filename>hello.tb</filename>. Next,
      consider<programlisting>toolbus -TB_PORT 4000 hello.tb</programlisting>which
      interprets the same script, but uses socket <literal>4000</literal> to
      find the ToolBus. Next, consider <programlisting>toolbus -Imy-include-dir -DCNT=33 wave.tb</programlisting>which
      searches the directory <filename>my-include-dir</filename> for files
      used in <literal>#include</literal> directives in the script
      <filename>wave.tb</filename> and it will define the name
      <literal>CNT</literal> with value <literal>33</literal>. All occurrences
      of <literal>CNT</literal> in the script will be replaced by this value
      before parsing it as a Tscript. Finally, <programlisting>toolbus -gentifs hello.tb </programlisting>produces
      the tool interfaces file <filename>hello.tifs</filename>.</para>
    </section>

    <section>
      <title>Tool arguments</title>

      <para>Arguments specific for tools are:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-TB_HOST
          <replaceable>host_name</replaceable></literal>: defines the host
          machine <literal><replaceable>host_name</replaceable></literal> on
          which the ToolBus interpreter is running and to which the tool
          should be connected. When omitted, the ToolBus interpreter should be
          running on the same host as the tool.</para>
        </listitem>

        <listitem>
          <para><literal>-TB_TOOL_NAME tool_name</literal>: the tool name as
          defined in the Tscript (added automatically, when a tool is executed
          by the ToolBus).</para>
        </listitem>

        <listitem>
          <para><literal>-TB_TOOL_ID <replaceable>Id</replaceable></literal>:
          internal tool identifier of this tool execution (added
          automatically, when a tool is executed by the ToolBus).</para>
        </listitem>

        <listitem>
          <para><literal>-TB_SINGLE</literal>: execute the tool stand-alone
          and do not connect it with the ToolBus.</para>
        </listitem>
      </itemizedlist>

      <para>The execution of a tool can start in two ways:</para>

      <itemizedlist>
        <listitem>
          <para>The tool is started by an <literal>execute</literal> command
          in the Tscript.</para>
        </listitem>

        <listitem>
          <para>The initiative to execute the tool is taken outside the
          ToolBus. This requires that the script contains a
          <literal>rec-connect</literal> for this particular tool.</para>
        </listitem>
      </itemizedlist>

      <para>When ToolBus and tool are running on different host machines, it
      is important to define the host machine on which the ToolBus interpreter
      is running when starting the execution of the tool. As an example,
      consider the <command>hello</command> application described in Section
      XXX. The <command>hello</command> tool will be executed by the ToolBus
      using the command <programlisting>hello -TB_PORT 8998 -TB_HOST host1.institute.nl</programlisting>when
      running on machine <literal>host1.institute.nl</literal>. Suppose, we
      replace the explicit <literal>execute</literal> in
      Figure~\ref{fig:hello2.tb} by a <literal>rec-connect</literal> as shown
      in Figure~\ref{fig:hello3.tb}. We may then manually start the
      <command>hello</command> tool by typing <programlisting>hello</programlisting>where
      we use the default values for the input/output sockets and assume that
      tool and ToolBus interpreter are both running on the same host (i.e.,
      <literal>host1.institute.nl</literal>). Starting the execution from
      <emphasis>another</emphasis> host is achieved by typing (on, say, {\tt
      host2.institute.nl}): <programlisting>hello -TB_HOST host1.institute.nl </programlisting></para>
    </section>
  </section>

  <section>
    <title>Adapters for tools and languages</title>

    <figure xml:id="figure.organization-tool-adapter">
      <title>Two organizations of a tool adapter</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="tool-adapter.png" scale="60"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The main purpose of adapters is to act as small
    <emphasis>wrappers</emphasis> around existing programs or programming
    languages in order to transform them into tools that can be connected to
    the ToolBus. There exist two global strategies for constructing
    adapters:</para>

    <itemizedlist>
      <listitem>
        <para>The adapter and the program to be adapted are executed as
        separate (Unix) processes. This structure is sketched in <xref
        linkend="figure.organization-tool-adapter" />. The advantage of this
        approach is that no access is needed to the source code of the
        program: it can remain a black box. Another advantage is that adapters
        may be reused for the adaptation of different programs. A possible
        disadvantage is some loss in efficiency.</para>

        <para>In this category a further subdivision is possible:</para>

        <itemizedlist>
          <listitem>
            <para>The program is executed once as a child process of the
            adapter and all
            <literal>snd-eval</literal>/<literal>snd-do</literal> requests are
            directed to this child process. The program can thus maintain an
            internal state between requests.</para>
          </listitem>

          <listitem>
            <para>The same program is executed as a child process of the
            adapter for each
            <literal>snd-eval</literal>/<literal>snd-do</literal>
            request.</para>
          </listitem>

          <listitem>
            <para>A different program is executed as a child process of the
            adapter for each
            <literal>snd-eval</literal>/<literal>snd-do</literal>
            request.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Integrate the adapter and the software to be adapted into a
        single (Unix) process. This approach permits the most detailed
        adaptation of the program and is also the most efficient solution.
        This approach leads, however, to potentially less reusable adapters
        than the previous approach.</para>
      </listitem>
    </itemizedlist>

    <para>In order to achieve some uniformity, the current collection of
    adapters have the following optional program arguments in common:</para>

    <itemizedlist>
      <listitem>
        <para><literal>-cmd</literal>: the (default) program to be executed by
        the adapter. All arguments of the adapter that follow
        <literal>-cmd</literal> are interpreted as the name and arguments of
        the program to be executed.</para>
      </listitem>

      <listitem>
        <para>All tool arguments (see Section~\ref{ToolArgs}.)</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Writing ToolBus Tools</title>

    <para></para>

    <section>
      <title>Writing tools in Java</title>

      <para></para>
    </section>

    <section>
      <title>Writing tools in C</title>

      <para>Although ToolBus tools can be implemented in many languages
      (including Java, C++, Perl, Tcl/Tk, Prolog, ASF+SDF, Cobol and others)
      we start explaining how tools can be written in C. In other languages
      identical notions will be used with only minor adjustements to
      language-specific features and limitations. Writing tools in C amounts
      to:</para>

      <itemizedlist>
        <listitem>
          <para>ATerms: the essential data type that is used to exchange
          information between tool and \TB\ (Section~\ref{ATerms}).</para>
        </listitem>

        <listitem>
          <para>The global structure of a \TB\ tool
          (Section~\ref{GlobalStructureTool}).</para>
        </listitem>

        <listitem>
          <para>The \TB\ Application Programmer's Interface
          (Section~\ref{ToolBusAPI}).</para>
        </listitem>

        <listitem>
          <para>Compiling \TB\ tools written in C
          (Section~\ref{CompilingTools}).</para>
        </listitem>

        <listitem>
          <para>Generating tool interfaces with {\tt tifstoc}
          (Section~\ref{tifstoc}).</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>ATerms: Composing and decomposing terms</title>

        <warning>
          <para>This section will be moved to the ATerm manual</para>
        </warning>

        <para>We use a datatype called ATerms for creating, matching, reading
        and writing terms. ATerms are fully described elsewhere. Here we only
        give a brief overview.</para>
      </section>

      <section>
        <title>Term patterns</title>

        <para>Composition and decomposition of terms is
        <emphasis>not</emphasis> based on the direct manipulation of the
        underlying representation of terms. Instead, <emphasis>term
        patterns</emphasis> are used to guide composition and decomposition.
        Such term patterns play the same role as format strings in the
        printf/scanf paradigm in C. In a first approximation, a term pattern
        is a literal string that would be obtained by a preorder traversal of
        a term. For instance, the term pattern<programlisting>"or(true, false)"</programlisting>
        corresponds to a term whose root is labeled with the symbol
        <literal>or</literal>, and whose children are labeled with,
        respectively, <literal>true</literal> and <literal>false</literal>. In
        this way, term patterns can be used to construct and to match terms.
        Term patterns become, however, much more useful if they can be
        parameterized with subterms that have been computed separately. To
        this end, we introduce the notion of <emphasis>directives</emphasis>
        as follows:</para>

        <itemizedlist>
          <listitem>
            <para><literal>&lt;int&gt;</literal>: corresponds to an integer
            (in C: <literal>int</literal>};</para>
          </listitem>

          <listitem>
            <para><literal>&lt;str&gt;</literal>: corresponds to a string (in
            C: <literal>char *</literal>);</para>
          </listitem>

          <listitem>
            <para><literal>&lt;blob&gt;</literal> corresponds to a binary
            string (in C: a (length, pointer) pair represented by two values
            of types, respectively, <literal>int</literal> and <literal>void
            *</literal>);</para>
          </listitem>

          <listitem>
            <para><literal>&lt;term&gt;</literal>: corresponds to an aterm (in
            C: <literal>ATerm</literal>);</para>
          </listitem>

          <listitem>
            <para><literal>&lt;appl&gt;</literal>: corresponds to one function
            application(in C: <literal>char
            *<replaceable>pattern</replaceable></literal>, followed by
            arguments);</para>
          </listitem>

          <listitem>
            <para><literal>&lt;list&gt;</literal>: corresponds to a list of
            terms (in C: <literal>ATerm</literal>).</para>
          </listitem>
        </itemizedlist>

        <para>The precise interpretation of these directives depends on the
        context in which they are used. When constructing a term, directives
        indicate that a subterm should be obtained from some given variable.
        When matching a term, directives indicate the assignment of subterms
        to given variables. For the implications of these directives for
        memory management, see Section~\ref{Memory}.</para>
      </section>

      <section>
        <title>ATmake</title>

        <para>The function <programlisting>term *ATmake(char *Pattern, ...)</programlisting>constructs
        a term according to <literal>Pattern</literal> where occurrences of
        directives are replaced by the values of the variables occurring in
        <literal>...</literal>. For instance, assuming the
        declarations<programlisting>int n = 10;
char *fun = "pair", name = "any";
ATerm yellow = ATmake("yellow"), t;</programlisting>the call<programlisting>t = ATmake("exam(&lt;appl(&lt;term&gt;,9)&gt;,&lt;int&gt;,&lt;str&gt;)", 
           fun, yellow, n, 10, name)</programlisting>will construct the term
        <literal>t</literal> with value<programlisting>exam(pair(yellow,9),10,10,"any")</programlisting>Binary
        strings (<emphasis>Binary Large OBjects</emphasis> or
        <emphasis>blobs</emphasis>) are used to represent arbitrary length,
        binary data that cannot be represented by ordinary C strings because
        they may contain ``null'' characters. A binary string is represented
        by a character pointer and a length. For instance,
        given<programlisting>char buf[12];
ATerm bstr;
buf[0] = 0; buf[1] = 1; buf[2] = 2;</programlisting>the call<programlisting>bstr = ATmake("exam(&lt;blob&gt;)", 3, buf);</programlisting>will
        construct a term with function symbol <literal>exam</literal> and as
        single argument a binary string of length 3 consisting of the three
        values <literal>0</literal>, <literal>1</literal>, and
        <literal>2</literal>.</para>
      </section>

      <section>
        <title>ATmatch</title>

        <para>Matching terms amounts to</para>

        <itemizedlist>
          <listitem>
            <para>determining whether there is a match or not,</para>
          </listitem>

          <listitem>
            <para>selectively assigning matched subterms to given
            variables.</para>
          </listitem>
        </itemizedlist>

        <para>This is precisely what the function<programlisting>ATbool ATmatch(ATerm <replaceable>Trm</replaceable>, const char *<replaceable>Pattern</replaceable>, ...)</programlisting>does.
        It matches <literal><replaceable>Trm</replaceable></literal> against
        <literal><replaceable>Pattern</replaceable></literal> and, when a
        submatch is found that corresponds to a directive, it makes
        assignments to variables whose addresses appear in
        <literal>...</literal>. For most directives, the values assigned to
        these variables are pointers to subterms of
        <literal><replaceable>Trm</replaceable></literal>.
        <literal><replaceable>Pattern</replaceable></literal> should be a
        well-formed, textual representation of a term which may contain any of
        the directives described earlier. For instance, in the context
        <programlisting>ATerm t = ATmake("exam(pair(yellow,9),10, \"any\")");
ATerm t1;
int n;
char *ex, *s;</programlisting>the call<programlisting>ATmatch(t, "appl(&lt;term&gt;,&lt;int&gt;,&lt;str&gt;)", &amp;ex, &amp;t1, &amp;n, &amp;s);</programlisting>yields
        true and is equivalent to the following assignments: <programlisting>ex = "exam";
t1 = ATmake("pair(yellow,9)");
n = 10;
s = "any";</programlisting>As explained in full detail in
        Section~\ref{Memory}, memory is managed automatically by the ATerm
        library. As a general rule, the values for <literal>ex</literal>,
        <literal>t1</literal>, and <literal>s</literal> are pointers into the
        original term <literal>t</literal> rather than newly created values.
        As a result, they have a life time that is equal to that of
        <literal>t</literal>. Matching binary strings is the inverse of
        constructing them. Given the term <literal>bstr</literal> constructed
        at the end of the previous paragraph, its size and contents can be
        extracted as follows:<programlisting>int n;
char *p;

ATmatch(bstr, "exam(&lt;blob&gt;)", &amp;n, &amp;p);</programlisting><literal>ATmatch</literal>
        will succeed and will assign 3 to the variable <literal>n</literal>
        and will assign a pointer to the character data in the binary string
        to the variable <literal>p</literal>. Here, again, the value of
        <literal>p</literal> is a pointer into the term
        <literal>bstr</literal> rather than a newly allocated string.
        Notes</para>

        <itemizedlist>
          <listitem>
            <para>Double quotes (``<literal>"</literal>'') appearing
            <emphasis>inside</emphasis> the pattern argument of both
            <literal>ATmake</literal> and <literal>ATmatch</literal> have to
            be escaped using ``<literal>\"</literal>''.</para>
          </listitem>

          <listitem>
            <para>The number and type of the variables whose addresses appear
            as arguments of <literal>ATmatch</literal> should correspond,
            otherwise disaster will strike (as usual when using C).</para>
          </listitem>

          <listitem>
            <para>Assignments are being made during matching. As a result,
            some assignments may be performed, even if the match as a whole
            fails.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Input and output of ATerms</title>

        <para>We make a distinction between the ``raw'' input and output of
        terms as they are, for instance, being sent through communication
        channels between ToolBus and tools, versus formatted input and output
        of terms. Raw term i/o is provided by <literal>TBwrite</literal> and
        <literal>TBread</literal>. Formatted term output is provided by
        <literal>TBprintf</literal> and <literal>TBsprintf</literal>. There
        are currently no primitives for formatted term input.</para>
      </section>

      <section>
        <title>Reading and writing ATerms</title>

        <para>ATerms can be read from and written to strings and files. Two
        formats are supported: a human-readable but verbose textual format and
        a very concise binarry format. Here we only discuss the textual
        variant. The function<programlisting>void ATwriteToTextFile(ATerm <replaceable>Trm</replaceable>, FILE *<replaceable>File</replaceable>)</programlisting>
        writes ATerm <replaceable>Trm</replaceable> to the file
        <replaceable>File</replaceable>. For instance, in the context:
        <programlisting>FILE *f = fopen("foo", "wb");
ATerm Trm1 = ATmake("&lt;appl(red,&lt;int&gt;)&gt;", "freq", 17);</programlisting>the
        statement<programlisting>ATwriteToTextFile(Trm1, f);</programlisting>will
        write the value of <literal>Trm1</literal> (i.e.,
        <literal>freq(red,17)</literal>) to file ``<filename>foo</filename>''.
        The function<programlisting>ATerm ATreadFromFile(FILE *File)</programlisting>is
        the inverse of <literal>ATwriteToFile</literal>: it reads a term
        (either in textual format or in internal format) from a file and
        returns it as value. When end of file is encountered or the term could
        not be read, the operation is aborted.The user can redefine this
        behaviour using <literal>ATsetAbortHandler</literal>, which allows the
        definition of a user-defined abort handler. See the \emph{ATerm
        Library User Manual} for further details.</para>
      </section>

      <section>
        <title>ATfprintf</title>

        <para>The function<programlisting>int ATfprintf(FILE *<replaceable>File</replaceable>, const char *<replaceable>Pattern</replaceable>, ...)</programlisting>writes
        formatted output to <replaceable>File</replaceable>.
        <replaceable>Pattern</replaceable> is printed literally except for
        occurrences of directives which are replaced by the textual
        representation of the values appearing in <literal>...</literal>. For
        instance,<programlisting>ATfprintf(stderr, "Wrong event \"%t\" ignored\n", 
                   ATmake("failure(&lt;int&gt;)", 13));</programlisting></para>

        <warning>
          <para>Change %t etc into &lt;term&gt;</para>
        </warning>

        <para>will print:<programlisting>Wrong event "failure(13)" ignored</programlisting>Note
        that <literal>ATprintf</literal> uses the normal
        <literal>printf</literal> conversion specifiers extended with
        aterm-specific specifiers. The most frequently used specifier is {\tt
        \%t} which stands for an aterm argument whose textual representation
        is to be inserted in the output stream.</para>
      </section>

      <section>
        <title>Further ATerm manipulation functions</title>

        <para>The ATerm library acutally provides two interfaces:</para>

        <itemizedlist>
          <listitem>
            <para>The level 1 interface: a simple but expressive interface as
            just sketched.</para>
          </listitem>

          <listitem>
            <para>The level 2 interface: a more detailed interface that allows
            the very efficient coding of operations on ATerms. We will not
            further discuss here the level 2 interface.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Memory Management of ATerms</title>

        <para>The functions in the ATerm library provide automatic memory
        management of terms. Terms that have been created but are no longer
        referenced are removed by a method called <emphasis>garbage
        collection</emphasis>. The global model is that there is a set of
        <emphasis>protected</emphasis> terms that are guaranteed to survive a
        garbage collection. Effectively, all protected terms (and their
        subterms) are conserved and all other terms are considered as garbage
        and can be collected. It is guaranteed that no garbage collection
        takes place during the execution of an event handler, hence it is not
        necessary to protect temporary terms that are constructed during the
        execution of an event handler. However, terms that should have a
        longer life time must be protected in order to survive. In order to
        protect terms from being collected, the function <programlisting>void ATprotect(ATerm *<replaceable>TrmPtr</replaceable>)</programlisting>can
        be used that has as single argument <emphasis>a pointer to a variable
        with an ATerm as value</emphasis>. The protection can be undone by the
        function<programlisting>void ATunprotect(ATerm *TrmPtr)</programlisting>
        The interplay between garbage collection and program variables is
        subtle. The following points are therefore worth mentioning:</para>

        <itemizedlist>
          <listitem>
            <para>Functions that return a term as value (e.g.,
            <literal>TBreadTermfromFile</literal>) do not explicitly protect
            it but the result may, of course, be protected because it is a
            subterm of an already protected term.</para>
          </listitem>

          <listitem>
            <para>The function <literal>ATmake</literal> uses strings and
            terms and includes them into a new term
            <replaceable>T</replaceable>. The implications for memory
            management are:</para>

            <itemizedlist>
              <listitem>
                <para>All string arguments (using
                <literal>&lt;str&gt;</literal>,
                <literal>&lt;blob&gt;</literal> or
                <literal>&lt;appl&gt;</literal>) are copied before they are
                included into <literal><replaceable>T</replaceable></literal>.
                They can thus safely be deallocated (e.g., using
                <literal>free</literal>) by the C program.</para>
              </listitem>

              <listitem>
                <para>All term arguments (using
                <literal>&lt;term&gt;</literal>) are included into
                <replaceable>T</replaceable> by means of a pointer. They thus
                become reachable from <replaceable>T</replaceable> and their
                life time becomes at least as large as that of
                <replaceable>T</replaceable>; it is unnecessary to explicitly
                protect them.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>The function <literal>ATmatch</literal> assigns strings and
            terms to program variables by extracting them from an existing
            term <replaceable>T</replaceable>. The general rule here is that
            extracted values have a life time that is equal to that of
            <replaceable>T</replaceable>. The implications for memory
            management are:</para>

            <itemizedlist>
              <listitem>
                <para>All string values (obtained using
                <literal>&lt;str&gt;</literal>,
                <literal>&lt;blob&gt;</literal> or
                <literal>&lt;appl&gt;</literal>) should be copied if they
                should survive <replaceable>T</replaceable>.</para>
              </listitem>

              <listitem>
                <para>All term values (obtained using
                <literal>&lt;term&gt;</literal>) should be explicitly
                protected if they should survive
                <replaceable>T</replaceable>.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Initializing and using the ATerm library</title>

        <para>Using the ATerm library requires the following:</para>

        <itemizedlist>
          <listitem>
            <para>Include the header file <literal>aterm1.h</literal> (or
            <literal>aterm2.h</literal> if you want to use the level 2
            interface). <literal>aterm1.h</literal> defines:</para>

            <itemizedlist>
              <listitem>
                <para><literal>ATbool</literal>: the boolean data type defined
                by<programlisting>typedef enum ATbool {ATfalse=0, ATtrue} ATbool;</programlisting>It
                is mainly used as the return value of library
                functions.</para>
              </listitem>

              <listitem>
                <para><literal>ATerm</literal>: the type definition of ATerms.
                The ATerm library has been designed in such a way that only
                pointers to terms must be passed to or are returned by library
                functions. The primitives that are provided for constructing
                and decomposing terms are of such a high level that it is
                unnecessary to know the internal representation of terms. When
                necessary, you can access the internal structure of ATerms
                using the level 2 interface.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Declare in your <literal>main</literal> program a local
            ATerm variable that will be used to determine the bottom of C's
            runtime stack.</para>
          </listitem>

          <listitem>
            <para>Call <literal>ATinit</literal> to initialize the ATerm
            library.</para>
          </listitem>

          <listitem>
            <para>Link the ATerm library <literal>libATerm.a</literal> when
            compiling your application. This is achieved using the
            -<literal>lATerm</literal> option of the C compiler.</para>
          </listitem>
        </itemizedlist>

        <para>A typical usage pattern is as follows:<programlisting>#include &lt;aterm1.h&gt;
int main(int argc, char *argv[])
{
  ATerm bottomOfStack;
  ATinit(argc, argv, &amp;bottomOfStack);
  /* ... code that uses ATerms ... */
}</programlisting></para>
      </section>
    </section>

    <section>
      <title>The global structure of a ToolBus tool</title>

      <para><figure xml:id="figure-tool-organization">
          <title>Global tool organization</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="tool-organization.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>In its simplest form, a tool is a box connected via an input
      and an output port to a ToolBus. In the most general case, a tool
      has</para>

      <itemizedlist>
        <listitem>
          <para>one input port from the ToolBus to the tool and can receive
          tree structures (terms) via this port;</para>
        </listitem>

        <listitem>
          <para>one output port from the tool to the ToolBus and can send
          terms to the ToolBus via this port;</para>
        </listitem>

        <listitem>
          <para>zero or more <emphasis>term ports</emphasis> to receive terms
          from other sources;</para>
        </listitem>

        <listitem>
          <para>zero or more <emphasis>character ports</emphasis> to receive
          character data from other sources.</para>
        </listitem>
      </itemizedlist>

      <para>This global, architectural, structure of a tool is shown in <xref
      linkend="figure-tool-organization" />. With each input port, an
      <emphasis>event handler</emphasis> is associated that takes care of the
      processing of the data received via that port and is responsible for
      returning a result (if any). One tool may thus contain several event
      handlers. When a request is received, the following steps are
      taken:</para>

      <itemizedlist>
        <listitem>
          <para>The data received are parsed to check that they form a legal
          ToolBus term <replaceable>T</replaceable>. (If this is impossible, a
          warning message is generated).</para>
        </listitem>

        <listitem>
          <para>The event handler is called with <replaceable>T</replaceable>
          as argument.</para>
        </listitem>

        <listitem>
          <para>The event handler can do arbitrary processing needed to
          decompose <replaceable>T</replaceable>, to determine what has to be
          done, and perform any desired computation.</para>
        </listitem>

        <listitem>
          <para>The event handler returns either:</para>

          <itemizedlist>
            <listitem>
              <para>a legal ToolBus term representing a reply to be sent back
              to the ToolBus.</para>
            </listitem>

            <listitem>
              <para><literal>NULL</literal> indicating that there is no
              reply.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>The global mode of operation of a tool is now:</para>

      <itemizedlist>
        <listitem>
          <para>receive data on any input port and respond to this by sending
          some term (or <literal>NULL</literal>) to the ToolBus; or</para>
        </listitem>

        <listitem>
          <para>take the initiative to send a term to the ToolBus (typically
          to inform the ToolBus about some external event).</para>
        </listitem>
      </itemizedlist>

      <para>A tool is thus on the one hand a reactive engine that responds to
      a request from the \TB\ and returns the result back to the ToolBus in
      the form of a term (e.g., calculate the value of some expression), but
      on the other hand it can also take the initiative to send a term to the
      ToolBus (e.g., generate an event when a user pushes some button). At the
      level of the source code, the global structure of a purely reactive tool
      without additional term or character ports has already been illustrated
      in Figure~\ref{fig:hello.c}.</para>

      <section>
        <title>The include file <literal>atb-tool.h</literal></title>

        <para>Each tool needs to include the file
        <literal>atb-tool.h</literal> which defines some basic types as well
        as the set of library functions available. It consists of</para>

        <itemizedlist>
          <listitem>
            <para>An include of <literal>&lt;aterm1.h&gt;</literal>.</para>
          </listitem>

          <listitem>
            <para>Defines <literal>ATBhandler</literal>: the type of event
            handlers.</para>
          </listitem>

          <listitem>
            <para>Defines the prototypes of all library functions</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>The tool library <literal>libATB.a</literal></title>

        <para>When compiling tools, the library <literal>libATB.a</literal>
        must be specified in order to make the tool library available (using
        the -<literal>lATB</literal> option of the C compiler). It provides
        the following functions:</para>

        <itemizedlist>
          <listitem>
            <para><literal>ATBinit</literal>: tool initialization
            (Sections~\ref{ATBinit}).</para>
          </listitem>

          <listitem>
            <para><literal>ATBconnect</literal>: to connect the tool to the
            ToolBus (Sections~\ref{ATBconnect}).</para>
          </listitem>

          <listitem>
            <para><literal>ATBdisconnect</literal>: to disconnect the tool
            from the ToolBus (Sections~\ref{ATBconnect}).</para>
          </listitem>

          <listitem>
            <para><literal>ATBeventloop</literal>: a standard event loop for a
            tool (Section~\ref{ATBeventloop}).</para>
          </listitem>

          <listitem>
            <para><literal>ATBreadTerm</literal>: process one input event on a
            port (Section~\ref{ATBreadTerm}).</para>
          </listitem>

          <listitem>
            <para><literal>ATBwriteTerm</literal>: send a term to the ToolBus
            (Section~\ref{ATBreadTerm}).</para>
          </listitem>
        </itemizedlist>

        <para>In the following section, we will describe these
        functions.</para>
      </section>
    </section>

    <section>
      <title>The ToolBus API</title>

      <para>During the initialization of each tool, some preparations have to
      made before the tool can be properly connected to the ToolBus. These
      preparations include</para>

      <itemizedlist>
        <listitem>
          <para>Defining the <emphasis>name</emphasis> of the tool as it is
          known from a tool declaration in a Tscript.</para>
        </listitem>

        <listitem>
          <para>Parsing standard program arguments that are passed to the tool
          when it is started.</para>
        </listitem>

        <listitem>
          <para>Creating a pair of socket connections with a ToolBus
          interpreter.</para>
        </listitem>

        <listitem>
          <para>Starting an event loop.</para>
        </listitem>
      </itemizedlist>

      <para>During execution of the event loop, the tool can either
      <emphasis>receive</emphasis> terms from the ToolBus or it can take the
      initiative to <emphasis>send</emphasis> terms to the ToolBus. It is thus
      possible for a tool to both respond to ToolBus requests and
      <emphasis>asynchronously</emphasis> send terms to the ToolBus.</para>

      <section>
        <title><literal>ATBinit</literal></title>

        <para>The initialization of a tool is achieved by<programlisting>ATBinit(int <replaceable>argc</replaceable>, char *<replaceable>argv</replaceable>[], ATerm *<replaceable>bottomOfStack</replaceable>).</programlisting>The
        standard program arguments that are passed (via
        <replaceable>argc</replaceable> and <replaceable>argv</replaceable>)
        are fully described in Section~\ref{Executing}. Particularly important
        is that the tool is initialized with a proper name. It should be
        literally equal (including the case of letters) to a tool name as
        appearing in a tool declaration in the Tscript. This is important
        since the tool name will be used when the tool is connected to the
        ToolBus. Note that <literal>ATBinit</literal> also initializes the
        ATerm library (hence the <replaceable>bottomOfStack</replaceable>
        argument, see Section \ref{ATinit}).</para>
      </section>

      <section>
        <title><literal>ATBconnect</literal></title>

        <para>A tool can be connected to the ToolBus using <replaceable>term
        ports</replaceable> that can be using for sending and receiving data
        in the form of complete terms. Two aspects of term ports are
        important: the input channel used for the actual data transfer and the
        <emphasis>handler</emphasis> that takes care of processing input terms
        when they arrive. The connection is established as
        follows:<programlisting>int ATBconnect(char *<replaceable>toolname</replaceable>, char *<replaceable>host</replaceable>, 
               int <replaceable>port</replaceable>, ATBhandler <replaceable>h</replaceable>);</programlisting>Here,
        <replaceable>toolname</replaceable> is the tool name to be used,
        <replaceable>host</replaceable> is the machine where the ToolBus is
        executing, <replaceable>port</replaceable> is the file descriptior of
        the channel to be used, and <replaceable>h</replaceable> is the
        handler to associated with this connection. If value
        <literal>NULL</literal> is passed as
        <replaceable>toolname</replaceable> or
        <replaceable>host</replaceable>, default values are used that are
        taken from <replaceable>argv</replaceable>. The same is true when
        <literal>-1</literal> is passed as value for
        <replaceable>port</replaceable>. The return value of
        <literal>ATBconnect</literal> is either <literal>-1</literal>
        (failure) or a positive number (the connection succeeded and the
        result is the file descriptor of the resulting socket connection with
        the ToolBus). Handlers for term ports are functions from ATerm to
        ATerm and have the type:<programlisting>ATerm some_handler(int <replaceable>conn</replaceable>, ATerm <replaceable>input</replaceable>)</programlisting>The
        argument <replaceable>conn</replaceable> is the connection along which
        the input term was received and <replaceable>input</replaceable> is
        the actual term received. The term retruned by the handler is the
        reply to be sent to the ToolBus in response to this input event, or
        <literal>NULL</literal> if no reply is needed. In this fashion, an
        arbitrary number of term input ports can be set up which will be read
        in parallel: as soon as a term arrives at one of the ports the
        associated handler is activated. A connection can be terminated as
        follows:<programlisting>void ATBdisconnect(int <replaceable>conn</replaceable>)</programlisting>where
        <replaceable>conn</replaceable> is a previously created
        connection.</para>
      </section>

      <section>
        <title>ATBeventloop</title>

        <para>Many tools first establish a number of term ports and then enter
        an infinite loop that processes input events. The
        function<programlisting>int ATBeventloop(void)</programlisting>captures
        this idea. It never returns, unless something goes wrong. We can now
        give a skeleton that many tools have in common:<programlisting>#include "my_tool.tif.c"

ATerm my_tool_handler(int conn, ATerm input)
{ ... handle input and return a term or NULL ...  }

int main(int argc, char *argv[]) 
{ ATerm bottomOfStack;

  ATBinit(argc, argv, &amp;bottomOfStack);
  if(ATBconnect(NULL, NULL, -1,  my_tool_handler) &gt;= 0)
  {
     ATBeventloop();
  } else 
     fprintf(stderr, "my_tool: Could not connect to the ToolBus, giving up!\n");
  ATBeventloop();
  return 0; 
}</programlisting></para>
      </section>

      <section>
        <title><literal>ATBwriteTerm</literal> and
        <literal>ATBreadTerm</literal></title>

        <para>So far, we have seen primitives for tools that only receive
        terms from the ToolBus. In the case of, for instance, events that are
        generated by a tool, a term needs to be sent from the tool to the
        ToolBus. This can be achieved using<programlisting>int ATBwriteTerm(int <replaceable>conn</replaceable>, ATerm <replaceable>term</replaceable>)</programlisting>which
        sends <replaceable>term</replaceable> along the port
        <replaceable>conn</replaceable>. Failure is indicated by the return
        value <literal>-1</literal>. A typical usage is:<programlisting>ATBwriteTerm(conn, ATmake(snd-event(button("ok")).</programlisting>Symmetrically,
        a term can be read from a ToolBus connection as
        follows:<programlisting>ATerm ATBreadTerm(int <replaceable>conn</replaceable>).</programlisting></para>
      </section>

      <section>
        <title>Advanved control flow</title>

        <para>Tool programming amounts, in essence, to event driven
        programming: most of the time a tool is awaiting the arrival of data
        on one of its ports and when the data are there, a reply is sent to
        the ToolBus by the handler associated with that port. In
        computation-intensive tools, the need may arise to check for the
        availability of incoming data from the ToolBus during computations.
        This is achieved by the function <programlisting>ATbool ATBpeekOne(int <replaceable>conn</replaceable>)</programlisting>which
        returns <literal>ATtrue</literal> if incoming data from the ToolBus
        are available on the connection <replaceable>conn</replaceable>.
        Similarly, the availability of data on <emphasis>any</emphasis>
        connection may be checked by:<programlisting>int ATBpeekAny(void)</programlisting>If
        input is waiting, the appropriate connection is returned. Otherwise
        <literal>-1</literal> is returned. The sequence of activities needed
        for handling (once) the data available from a specific connection is
        captured by the function<programlisting>void ATBhandleOne(int <replaceable>conn</replaceable>)</programlisting>This
        amounts to calling the handler associated with connection
        <replaceable>conn</replaceable> with the available data as input term.
        Similarly, the data from <emphasis>any</emphasis> connection is
        handled by<programlisting>void ATBhandleAny(void)</programlisting>The
        function <literal>ATBeventloop</literal> can be expressed with the
        primitives just introduced:<programlisting>int ATBeventloop(void)
{ int conn;
  while(ATtrue)
  {
    n  = ATBhandleAny();
    if(n &lt; 0)
      return -1;
  }
}</programlisting>Another style mixes the handling of input from the ToolBus,
        with other computations: <programlisting>   while(ATtrue)
   { 
     if(n = ATBpeekAny() &gt;= 0) /* if there is an incoming event */
        ATBhandleOne(n);             /* handle it                     */
     else {
        ...                         /* perform other computation     */
     }
   }</programlisting>In some tools, a mixture of passively awaiting input and
        actively sending terms to the ToolBus can be seen. Using
        <literal>ATBwriteTerm</literal>, the most general global event loop of
        a tool becomes: <programlisting> while(ATtrue)
 {
 ... ATBwriteTerm(c1,e1); ...; ATBwriteTerm(cn,en); ...
   ATBhandleAny();
 }</programlisting>In other words, each iteration starts by sending zero or
        more terms to the ToolBus (using <literal>ATBwriteTerm</literal>) and
        ends with processing one event coming from some port (using
        <literal>ATBhandleAny</literal>). The Tscript being used should, of
        course, be able to receive such events.</para>
      </section>
    </section>

    <section>
      <title>Compiling ToolBus tools written in C</title>

      <para>When compiling a tool written in C the following questions should
      be answered:</para>

      <itemizedlist>
        <listitem>
          <para>Where is the include file <literal>aterm1.h</literal>?</para>
        </listitem>

        <listitem>
          <para>Where is the include file
          <literal>atb-tool.h</literal>?</para>
        </listitem>

        <listitem>
          <para>Where is the ATerm library
          <literal>libATerm.a</literal>?</para>
        </listitem>

        <listitem>
          <para>Where is the ToolBus API library
          <literal>libATB.a</literal>?</para>
        </listitem>

        <listitem>
          <para>Which other libraries are needed to compile the tool?</para>
        </listitem>
      </itemizedlist>

      <para>The answers to these questions are clearly system dependent. There
      are two strategies to answer them. Strategy 1: find the desired
      locations on your system and hard code them in the compilation command.
      This will lead to a call to the C compiler with the following
      arguments:</para>

      <itemizedlist>
        <listitem>
          <para><literal>-I<replaceable>dir-where-aterm1.h-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>-I<replaceable>dir-where-ATB-tool.h-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>hello.c -o hello</literal></para>
        </listitem>

        <listitem>
          <para><literal>-L<replaceable>dir-where-libATerm.a-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>-lATerm</literal></para>
        </listitem>

        <listitem>
          <para><literal>-L<replaceable>dir-where-libATB.a-is</replaceable></literal></para>
        </listitem>

        <listitem>
          <para><literal>-lATB</literal></para>
        </listitem>

        <listitem>
          <para>other libraries.</para>
        </listitem>
      </itemizedlist>

      <para>Strategy 2: write a make file that encodes this information. As a
      result, the location information is hardwired in the make file rather
      than in a command that has to be repeated over and over again.</para>
    </section>

    <section>
      <title>Generating C tool interfaces with tifstoc</title>

      <para><figure xml:id="figure.tifs">
          <title>Automatic generation of tool interfaces</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="tifs.png" scale="60"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>The interface code for each tool depends on the particulars
      of the Tscript in which it is used. Changing the number of arguments in
      an evaluation request to the tool, or adding a new request, requires
      making changes to the interface code that are easily forgotten and
      therefore error prone. As already mentioned in Section~\ref{Hello},
      another observation is that the interface code for different tools has a
      lot in common. An obvious solution to both problems is to
      <emphasis>generate</emphasis> tool interfaces automatically, given a
      Tscript. This generation process is shown in <xref
      linkend="figure.tifs" /> and consists of two steps: </para>

      <itemizedlist>
        <listitem>
          <para>Generate a language-independent description of all tool
          interfaces used in the script. This amounts to a static analysis of
          all tool communication in the script. It is achieved by using the
          <literal>-gentifs</literal> option of the ToolBus interpreter. For
          instance, <programlisting>toolbus -gentifs hello2.tb</programlisting>
          will create a file <filename>hello2.tifs</filename> containing the
          tool interfaces.</para>
        </listitem>

        <listitem>
          <para>Use the language independent interface description to generate
          a tool interface for a specific tool in a specific implementation
          language. The generator <command>tifstoc</command> exists for
          generating C tool interfaces. It is called as follows:
          <programlisting>tifstoc -tool <replaceable>Name</replaceable> <replaceable>TifsFile</replaceable></programlisting>and
          generates a file named
          <literal><replaceable>Name</replaceable>.tif.c</literal>. For the
          hello example, we would have, for instance: <programlisting>tifstoc -tool hello hello2.tifs</programlisting>
          %The resulting file {\tt hello.tif.c} is shown in
          %Figure~\ref{fig:hello.tif.c}. \end{itemize}</para>
        </listitem>
      </itemizedlist>

      <para>In <xref linkend="figure.tifs" /> it is also shown how tool
      interface generators for <emphasis>other</emphasis> languages (e.g.,
      Java, Cobol) fit into this scheme. In addition to
      <command>tifstoc</command>, we alo support the generation of Java
      interfaces by way of <command>tifstojava</command> (See
      Section~\ref{ToolsInJava}).</para>
    </section>

    <section>
      <title>Writing tools in other languages</title>

      <para></para>

      <section>
        <title>Tcl/TK</title>

        <para></para>
      </section>

      <section>
        <title>Python</title>

        <para></para>
      </section>

      <section>
        <title>Perl</title>

        <para></para>
      </section>
    </section>
  </section>

  <section>
    <title>The ToolBus Implementation</title>

    <para></para>
  </section>

  <section>
    <title>Reference Information</title>

    <section>
      <title>The syntax of Tscripts</title>

      <para>A Tscript may contain directives like, e.g.,
      <literal>#define</literal>, <literal>#include</literal> and
      <literal>#ifdef</literal> that are replaced by a preprocessor similar to
      the C preprocessor. We summarize the most frequently used
      directives:</para>

      <itemizedlist>
        <listitem>
          <para><literal>#define <replaceable>Identifier</replaceable>
          <replaceable>Token-sequence</replaceable></literal> causes the
          preprocessor to replace all occurrences of
          <replaceable>Identifier</replaceable> by
          <replaceable>Token-sequence</replaceable>.</para>
        </listitem>

        <listitem>
          <para><literal>#include
          "<replaceable>Filename</replaceable>"</literal> will be replaced by
          the entire contents of the named file.</para>
        </listitem>

        <listitem>
          <para><literal>#ifdef</literal> and <literal>#ifndef</literal> can
          be used for the conditional incorporation or exclusion of parts of a
          script.</para>
        </listitem>
      </itemizedlist>

      <para>The syntax of Tscripts (without preprocessor directives) is as
      follows:</para>

      <warning>
        <para>This definition is slightly out-of-date.</para>
      </warning>

      <programlisting>
exports
  sorts BOOL NAT INT SIGN EXP UNSIGNED-REAL REAL STRING ID 
        NAME VNAME BSTR TERM TERM-LIST VAR GEN-VAR TYPE ATOM 
        ATOMIC-FUN PROC PROC-APPL FORMALS TIMER-FUN 
        FEATURE-ASG FEATURES TB-CONFIG DEF T-SCRIPT
  lexical syntax
        [ \t\n]                              -&gt; LAYOUT
        "%%" ~[\n]*                          -&gt; LAYOUT

        [0-9]+                               -&gt; NAT
        NAT                                  -&gt; INT
        SIGN NAT                             -&gt; INT
        [+\-]                                -&gt; SIGN

        [eE] NAT                             -&gt; EXP
        [eE] SIGN NAT                        -&gt; EXP
        NAT "." NAT                          -&gt; UNSIGNED-REAL
        NAT "." NAT EXP                      -&gt; UNSIGNED-REAL
        UNSIGNED-REAL                        -&gt; REAL
        SIGN UNSIGNED-REAL                   -&gt; REAL

        [a-z][A-Za-z0-9\-]*                  -&gt; ID
        "\"" ~[\"]* "\""                     -&gt; STRING
        [A-Z][A-Za-z0-9\-]*                  -&gt; NAME
        [A-Z][A-Za-z0-9\-]*                  -&gt; VNAME
        [a-z][a-z\-]*                        -&gt; ATOMIC-FUN

        delay                                -&gt; TIMER-FUN
        abs-delay                            -&gt; TIMER-FUN
        timeout                              -&gt; TIMER-FUN
        abs-timeout                          -&gt; TIMER-FUN
  context-free syntax
        true                                 -&gt; BOOL
        false                                -&gt; BOOL
        BOOL                                 -&gt; TERM
        INT                                  -&gt; TERM
        REAL                                 -&gt; TERM
        STRING                               -&gt; TERM

        TERM                                 -&gt; TYPE

        VNAME                                -&gt; VAR
        VNAME ":" TYPE                       -&gt; VAR
        VAR                                  -&gt; GEN-VAR
        VAR "?"                              -&gt; GEN-VAR
        GEN-VAR                              -&gt; TERM
        "&lt;" TERM "&gt;"                         -&gt; TERM
        ID                                   -&gt; TERM
        ID "(" TERM-LIST ")"                 -&gt; TERM
        {TERM ","}*                          -&gt; TERM-LIST
        "[" TERM-LIST "]"                    -&gt; TERM

        NAME                                 -&gt; VNAME

        ATOMIC-FUN "(" TERM-LIST ")"         -&gt; ATOM
        delta                                -&gt; ATOM
        tau                                  -&gt; ATOM
        create "(" NAME "(" TERM-LIST ")" ","  
                   TERM ")"                  -&gt; ATOM
        ATOM TIMER-FUN "(" TERM ")"          -&gt; ATOM
        VNAME ":=" TERM                      -&gt; ATOM

        ATOM                                 -&gt; PROC
        PROC "+" PROC                        -&gt; PROC  {left}
        PROC "." PROC                        -&gt; PROC  {right}
        PROC "||" PROC                       -&gt; PROC  {right}
        PROC "*" PROC                        -&gt; PROC  {left}
        "(" PROC ")"                         -&gt; PROC  {bracket}
        if TERM then PROC else PROC fi       -&gt; PROC
        if TERM then PROC fi                 -&gt; PROC
        execute(TERM-LIST)                   -&gt; PROC
        let {VAR ","}* in PROC endlet        -&gt; PROC

        NAME                                 -&gt; PROC-APPL
        NAME "(" TERM-LIST ")"               -&gt; PROC-APPL
        PROC-APPL                            -&gt; PROC

        "(" {GEN-VAR ","}* ")"               -&gt; FORMALS
                                             -&gt; FORMALS

        process NAME FORMALS is PROC         -&gt; DEF
        ID "=" STRING                        -&gt; FEATURE-ASG
       "{" { FEATURE-ASG  ";"}* "}"          -&gt; FEATURES
        tool ID FORMALS is FEATURES          -&gt; DEF
        toolbus "("{PROC-APPL ","}+ ")"      -&gt; TB-CONFIG
        DEF* TB-CONFIG                       -&gt; T-SCRIPT

 priorities
       PROC "*" PROC -&gt; PROC &gt; PROC "." PROC -&gt; PROC &gt;
       PROC "+" PROC -&gt; PROC &gt; PROC "||" PROC -&gt; PROC
   </programlisting>
    </section>

    <section>
      <title>Boolean functions</title>

      <table>
        <title>Boolean functions</title>

        <tgroup cols="3">
          <colspec align="left" colwidth="3*" />

          <colspec align="left" colwidth="1*" />

          <colspec align="left" colwidth="2*" />

          <thead>
            <row>
              <entry align="center">Function </entry>

              <entry align="center">Result type </entry>

              <entry align="center">Description </entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>not(&lt;bool&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry>¬
              <literal>&lt;bool&gt;<subscript>1</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>and(&lt;bool&gt;<subscript>1</subscript>,
              &lt;bool&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;bool&gt;<subscript>1</subscript> and
              &lt;bool&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>or(&lt;bool&gt;<subscript>1</subscript>,
              &lt;bool&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;bool&gt;<subscript>1</subscript> OR
              &lt;bool&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>equal(&lt;term&gt;<subscript>1</subscript>,
              &lt;term&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;term&gt;<subscript>1</subscript> </literal>=
              <literal>&lt;term&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>not-equal(&lt;term&gt;<subscript>1</subscript>,
              &lt;term&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;term&gt;<subscript>1</subscript> NE
              &lt;term&gt;<subscript>2</subscript></literal></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Integer functions</title>

      <table>
        <title>Integer functions</title>

        <tgroup cols="3">
          <colspec align="left" colwidth="3*" />

          <colspec align="left" colwidth="1*" />

          <colspec align="left" colwidth="2*" />

          <thead>
            <row>
              <entry align="center">Function </entry>

              <entry align="center">Result type </entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>add(&lt;int&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;int&gt;</literal></entry>

              <entry><literal>&lt;int&gt;<subscript>1</subscript></literal> +
              <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>sub(&lt;int&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;int&gt;</literal></entry>

              <entry><literal>&lt;int&gt;<subscript>1</subscript></literal> -
              <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>mul(&lt;int&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;int&gt;</literal></entry>

              <entry
              char="02306"><literal>&lt;int&gt;<subscript>1</subscript></literal>
              TIMES
              <literal>&lt;int&gt;</literal><subscript>2</subscript></entry>
            </row>

            <row>
              <entry><literal>div(&lt;int&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;int&gt;</literal></entry>

              <entry><literal>&lt;int&gt;<subscript>1</subscript></literal> /
              <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>mod(&lt;int&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;int&gt;</literal></entry>

              <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
              <emphasis role="bold">mod</emphasis>
              <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>abs(&lt;int&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;int&gt;</literal></entry>

              <entry>| <literal>&lt;int&gt;<subscript>1</subscript></literal>
              |</entry>
            </row>

            <row>
              <entry><literal>less(&lt;int&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
              &lt;
              <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>less-equal(&lt;int&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;int&gt;<subscript>1</subscript>
              </literal>LEQ
              <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>greater(&lt;int&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
              &gt;
              <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
            </row>

            <row>
              <entry><literal>greater-equal(&lt;int&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;int&gt;<subscript>1</subscript></literal>
              GEQ
              <literal>&lt;int&gt;<subscript>2</subscript></literal></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Real functions</title>

      <para><table>
          <title>Real functions</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function </entry>

                <entry align="center">Result type </entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>radd(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                +
                <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>rsub(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                -
                <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>rmul(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                ×
                <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>rdiv(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                /
                <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>mod(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                <emphasis role="bold">mod</emphasis>
                <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>rabs(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

                <entry><literal>&lt;real&gt;</literal></entry>

                <entry>|
                <literal>&lt;real&gt;<subscript>1</subscript></literal>
                |</entry>
              </row>

              <row>
                <entry><literal>rless(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                &lt;
                <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>rless-equal(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;real&gt;&gt;<subscript>1</subscript></literal>
                ≤
                <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>rgreater(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;real&gt;<subscript>1</subscript></literal>
                &gt;
                <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
              </row>

              <row>
                <entry><literal>rgreater-equal(&lt;real&gt;<subscript>1</subscript>,
                &lt;real&gt;<subscript>2</subscript>)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry><literal>&lt;real&gt;&gt;<subscript>1</subscript></literal>
                ≥
                <literal>&lt;real&gt;<subscript>2</subscript></literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>Goniometric functions</title>

      <table>
        <title>Goniometric functions</title>

        <tgroup cols="3">
          <colspec align="left" colwidth="3*" />

          <colspec align="left" colwidth="1*" />

          <colspec align="left" colwidth="2*" />

          <thead>
            <row>
              <entry align="center">Function </entry>

              <entry align="center">Result type </entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>sin(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;real&gt;</literal></entry>

              <entry><emphasis>sin</emphasis>(<literal>&lt;real&gt;<subscript>1</subscript></literal>)</entry>
            </row>

            <row>
              <entry><literal>cos(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;real&gt;</literal></entry>

              <entry><emphasis>cos</emphasis>(<literal>&lt;real&gt;<subscript>1</subscript></literal>)</entry>
            </row>

            <row>
              <entry><literal>atan(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;real&gt;</literal></entry>

              <entry><emphasis>tan</emphasis><superscript>-1</superscript>(<literal>&lt;real&gt;<subscript>1</subscript></literal>)
              in the range [-π/2, π/2]</entry>
            </row>

            <row>
              <entry><literal>atan2(&lt;real&gt;<subscript>1</subscript>,
              &lt;real&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;real&gt;</literal></entry>

              <entry><emphasis>tan</emphasis><superscript>-1</superscript>(<literal>&lt;real&gt;<subscript>1</subscript></literal>/<literal>&lt;real&gt;<subscript>2</subscript></literal>)
              in the range [-π, π]</entry>
            </row>

            <row>
              <entry><literal>exp(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;real&gt;</literal></entry>

              <entry><emphasis>e</emphasis><superscript>&lt;real&gt;<subscript>1</subscript></superscript></entry>
            </row>

            <row>
              <entry><literal>log(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;real&gt;</literal></entry>

              <entry>natural logarithm
              <emphasis>ln</emphasis>(<literal>&lt;real&gt;<subscript>1</subscript></literal>),
              with <literal>&lt;real&gt;<subscript>1</subscript></literal>
              &gt; 0</entry>
            </row>

            <row>
              <entry><literal>log10(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;real&gt;</literal></entry>

              <entry>base 10 logarithm
              <emphasis>log</emphasis><subscript>10</subscript>(<literal>&lt;real&gt;<subscript>1</subscript></literal>),
              with <literal>&lt;real&gt;<subscript>1</subscript></literal>
              &gt; 0</entry>
            </row>

            <row>
              <entry><literal>sqrt(&lt;real&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;real&gt;</literal></entry>

              <entry>base 10 logarithm
              <emphasis>√</emphasis><literal>&lt;real&gt;<subscript>1</subscript></literal>,
              with <literal>&lt;real&gt;<subscript>1</subscript></literal> ≥
              0</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Functions on lists</title>

      <table>
        <title>Functions on lists</title>

        <tgroup cols="3">
          <colspec align="left" colwidth="3*" />

          <colspec align="left" colwidth="1*" />

          <colspec align="left" colwidth="2*" />

          <thead>
            <row>
              <entry align="center">Function </entry>

              <entry align="center">Result type </entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>first(&lt;list&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;term&gt;</literal></entry>

              <entry>First element of
              <literal>&lt;list&gt;<subscript>1</subscript></literal>; The
              empty list <literal>[]</literal> when applied to non-list or
              empty list.</entry>
            </row>

            <row>
              <entry><literal>next(&lt;list&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;list&gt;</literal></entry>

              <entry>Remaining elements of
              <literal>&lt;list&gt;<subscript>1</subscript></literal>.</entry>
            </row>

            <row>
              <entry><literal>join(&lt;term&gt;<subscript>1</subscript>,
              &lt;term&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;list&gt;</literal></entry>

              <entry>Concatenation of
              <literal>&lt;term&gt;<subscript>1</subscript></literal> and
              <literal>&lt;term&gt;<subscript>2</subscript></literal>. When
              both arguments are lists their elements are spliced into a new
              list. A non-list argument is included as single element in the
              new list.</entry>
            </row>

            <row>
              <entry><literal>size(&lt;list&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;int&gt;</literal></entry>

              <entry>The number of elements in
              <literal>&lt;list&gt;<subscript>1</subscript></literal>.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Functions on lists as arrays</title>

        <tgroup cols="3">
          <colspec align="left" colwidth="3*" />

          <colspec align="left" colwidth="1*" />

          <colspec align="left" colwidth="2*" />

          <thead>
            <row>
              <entry align="center">Function </entry>

              <entry align="center">Result type </entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>index(&lt;list&gt;<subscript>1</subscript>,
              &lt;int&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;term&gt;</literal></entry>

              <entry>The
              <literal>&lt;int&gt;<subscript>1</subscript></literal>-th
              element of
              <literal>&lt;list&gt;<subscript>1</subscript></literal>, if it
              exists; otherwise <literal>[]</literal>.</entry>
            </row>

            <row>
              <entry><literal>replace(&lt;list&gt;<subscript>1</subscript>,&lt;int<subscript>1</subscript>&gt;,&lt;term&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;list&gt;</literal></entry>

              <entry>If the
              &lt;<literal>int&gt;<subscript>1</subscript></literal>-the
              element exists, replace it by
              <literal>&lt;term&gt;<subscript>1</subscript></literal> and
              returned the modifed list; otherwise return
              <literal>&lt;list&gt;<subscript>1</subscript></literal>
              unmodified.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Functions on lists as symbol tables</title>

        <tgroup cols="3">
          <colspec align="left" colwidth="3*" />

          <colspec align="left" colwidth="1*" />

          <colspec align="left" colwidth="2*" />

          <thead>
            <row>
              <entry align="center">Function </entry>

              <entry align="center">Result type </entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>get(&lt;list&gt;<subscript>1</subscript>,
              &lt;term&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;term&gt;</literal></entry>

              <entry>If
              <literal>&lt;list&gt;<subscript>1</subscript></literal>contains
              a pair <literal>[&lt;term&gt;<subscript>1</subscript>,
              &lt;term&gt;<subscript>1</subscript>']</literal> then return
              <literal>&lt;term&gt;<subscript>1</subscript>'</literal>;
              otherwise [].</entry>
            </row>

            <row>
              <entry><literal>put(&lt;list&gt;<subscript>1</subscript>,&lt;term&gt;<subscript>1</subscript>,&lt;term&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;list&gt;</literal></entry>

              <entry>If
              <literal>&lt;list&gt;<subscript>1</subscript></literal>contains
              a pair <literal>[&lt;term&gt;<subscript>1</subscript>,
              &lt;term&gt;<subscript>1</subscript>']</literal> then replace it
              by <literal>[&lt;term&gt;<subscript>1</subscript>,
              &lt;term&gt;<subscript>2</subscript>]</literal>; otherwise add a
              new pair [&lt;term&gt;<subscript>1</subscript>,
              &lt;term&gt;<subscript>2</subscript>] to
              &lt;list&gt;<subscript>1</subscript>.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Functions on lists as multi-sets</title>

        <tgroup cols="3">
          <colspec align="left" colwidth="3*" />

          <colspec align="left" colwidth="1*" />

          <colspec align="left" colwidth="2*" />

          <thead>
            <row>
              <entry align="center">Function </entry>

              <entry align="center">Result type </entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>member(&lt;term&gt;<subscript>1</subscript>,
              &lt;list&gt;<subscript>1</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;term&gt;<subscript>1</subscript></literal>
              IN <literal>&lt;list&gt;<subscript>2</subscript></literal>
              (membership in multi-set)</entry>
            </row>

            <row>
              <entry><literal>subset(&lt;list&gt;<subscript>1</subscript>,&lt;list&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;bool&gt;</literal></entry>

              <entry><literal>&lt;list&gt;<subscript>1</subscript></literal>
              SUBSET <literal>&lt;list&gt;<subscript>2</subscript></literal>
              (subset on multi-set)</entry>
            </row>

            <row>
              <entry><literal>diff(&lt;list&gt;<subscript>1</subscript>,&lt;list&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;list&gt;</literal></entry>

              <entry><literal>&lt;list&gt;<subscript>1</subscript></literal>
              DIFF <literal>&lt;list&gt;<subscript>2</subscript></literal>
              (difference on multi-set)</entry>
            </row>

            <row>
              <entry><literal>inter(&lt;list&gt;<subscript>1</subscript>,&lt;list&gt;<subscript>2</subscript>)</literal></entry>

              <entry><literal>&lt;list&gt;</literal></entry>

              <entry><literal>&lt;list&gt;<subscript>1</subscript></literal>
              INTER <literal>&lt;list&gt;<subscript>2</subscript></literal>
              (intersection on multi-set)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Functions on terms</title>

      <para><table>
          <title>Functions on lterms</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function </entry>

                <entry align="center">Result type </entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>is-bool(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is of type
                <literal>bool</literal> then <literal>true</literal>;
                otherwise <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-int(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is of type
                <literal>int</literal> then <literal>true</literal>; otherwise
                <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-real(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is of type
                <literal>real</literal> then <literal>true</literal>;
                otherwise <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-str(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is of type
                <literal>str</literal> then <literal>true</literal>; otherwise
                <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-bstr(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is of type
                <literal>bstr</literal> then <literal>true</literal>;
                otherwise <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-appl(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is an application
                then <literal>true</literal>; otherwise
                <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-list(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is a list then
                <literal>true</literal>; otherwise
                <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-empty(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> isequal to
                <literal>[] </literal> then <literal>true</literal>; otherwise
                <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-var(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is a variable then
                <literal>true</literal>; otherwise
                <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-var(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is a variable then
                <literal>true</literal>; otherwise
                <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-result-var(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is a result variable
                then <literal>true</literal>; otherwise
                <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>is-formal(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;bool&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is a formal variable
                then <literal>true</literal>; otherwise
                <literal>false</literal>.</entry>
              </row>

              <row>
                <entry><literal>fun(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;str&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is a function
                application then its function symbol; otherwise
                <literal>""</literal>.</entry>
              </row>

              <row>
                <entry><literal>args(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>If<literal> &lt;term&gt;</literal> is a function
                application then its argument; otherwise
                <literal>[]</literal>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>Time-related functions</title>

      <para><table>
          <title>Time-related functions</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function </entry>

                <entry align="center">Result type </entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>current-time</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>Six-tuple describing the urrent absolute time</entry>
              </row>

              <row>
                <entry><literal>sec(&lt;int&gt;)</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry>Convert &lt;int&gt; into seconds</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>Miscellaneous functions</title>

      <para><table>
          <title>Miscellaneous functions</title>

          <tgroup cols="3">
            <colspec align="left" colwidth="3*" />

            <colspec align="left" colwidth="1*" />

            <colspec align="left" colwidth="2*" />

            <thead>
              <row>
                <entry align="center">Function </entry>

                <entry align="center">Result type </entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>process-id</literal></entry>

                <entry><literal>&lt;int&gt;</literal></entry>

                <entry>Process id of the current process</entry>
              </row>

              <row>
                <entry><literal>process-name</literal></entry>

                <entry><literal>&lt;str&gt;</literal></entry>

                <entry>Name of the current process</entry>
              </row>

              <row>
                <entry><literal>quote(&lt;term&gt;)</literal></entry>

                <entry><literal>&lt;term&gt;</literal></entry>

                <entry>Quoted (unevaluated) term; only variables are replaced
                by their values</entry>
              </row>

              <row>
                <entry><literal>functions</literal></entry>

                <entry><literal>&lt;list&gt;</literal></entry>

                <entry>List of all built-in functions</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>

    <section>
      <title>XXX</title>

      <para><table>
          <title>Synopsis of primitives available in Tscripts</title>

          <tgroup cols="3">
            <colspec align="left" colname="col1" colwidth="2*" />

            <colspec align="left" colname="col2" colwidth="3*" />

            <colspec align="left" colname="col3" colwidth="1*" />

            <thead>
              <row>
                <entry>Primitive</entry>

                <entry>Synopsis</entry>

                <entry>See</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>delta</entry>

                <entry>Inaction (deadlock)</entry>

                <entry></entry>
              </row>

              <row>
                <entry>tau</entry>

                <entry>Internal step</entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>P</replaceable><subscript>1</subscript> +
                <replaceable>P</replaceable><subscript>2</subscript></entry>

                <entry>Choice between
                <replaceable>P</replaceable><subscript>1</subscript> and
                <replaceable>P</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>P</replaceable><subscript>1</subscript> .
                <replaceable>P</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>P</replaceable><subscript>1</subscript>
                followed by
                <replaceable>P</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>P</replaceable><subscript>1</subscript> ||
                <replaceable>P</replaceable><subscript>2</subscript></entry>

                <entry><replaceable>P</replaceable><subscript>1</subscript>
                parallel with
                <replaceable>P</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><replaceable>P</replaceable><subscript>1</subscript> *
                <replaceable>P</replaceable><subscript>2</subscript></entry>

                <entry>Repeat
                <replaceable>P</replaceable><subscript>1</subscript> until
                <replaceable>P</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>if <replaceable>T</replaceable> then
                <replaceable>P</replaceable> fi</literal></entry>

                <entry>Guarded command</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>if <replaceable>T</replaceable> then
                <replaceable>P</replaceable><subscript>1</subscript> else
                <replaceable>P</replaceable><subscript>2</subscript>
                fi</literal></entry>

                <entry>Conditional</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>create(<replaceable>Pnm</replaceable>(<replaceable>T</replaceable>,
                ...), <replaceable>Pid</replaceable>?)</literal></entry>

                <entry>Create new process</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal><replaceable>V</replaceable> :=
                <replaceable>T</replaceable></literal></entry>

                <entry>Assign <replaceable>T</replaceable> ( seen as
                expression) to <replaceable>V</replaceable></entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>snd-msg(<replaceable>T</replaceable>)</literal></entry>

                <entry>Send synchronous message</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>rec-msg(<replaceable>T</replaceable>)</literal></entry>

                <entry>Receive a synchronous message</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>snd-note(<replaceable>T</replaceable>)</literal></entry>

                <entry>Broadcast an asynchronous note</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>rec-note(<replaceable>T</replaceable>)</literal></entry>

                <entry>Receive an asynchronous note</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>no-note(<replaceable>T</replaceable>)</literal></entry>

                <entry>No note available</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>subscribe(<replaceable>T</replaceable>)</literal></entry>

                <entry>Subscribe to notes</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal><replaceable>A</replaceable>
                delay(<replaceable>T</replaceable>)</literal></entry>

                <entry>Relative delay of atom execution</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal><replaceable>A</replaceable>
                abs-delay(<replaceable>T</replaceable>)</literal></entry>

                <entry>Absolute delay of atom execution</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal><replaceable>A</replaceable>
                timeout(<replaceable>T</replaceable>)</literal></entry>

                <entry>Relative timeout of atom execution</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal><replaceable>A</replaceable>
                abs-timeout(<replaceable>T</replaceable>)</literal></entry>

                <entry>Absolute timeout of atom execution</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>rec-connect(<replaceable>Tid</replaceable>?)</literal></entry>

                <entry>Receive connection request from tool</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>rec-disconnect(<replaceable>Tid</replaceable>?)</literal></entry>

                <entry>Receive disconnection request from tool</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>execute(<replaceable>Tnm</replaceable>(<replaceable>T</replaceable>,...),
                <replaceable>Tid</replaceable>?)</literal></entry>

                <entry>Execute a tool</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>snd-terminate(<replaceable>Tid</replaceable>,
                <replaceable>T</replaceable>)</literal></entry>

                <entry>Terminate execution of a tool</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>shutdown(<replaceable>T</replaceable>)</literal></entry>

                <entry>Terminate ToolBus application</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>snd-eval(<replaceable>Tid</replaceable>,
                <replaceable>T</replaceable>)</literal></entry>

                <entry>Send evaluation request to tool</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>snd-cancel(<replaceable>Tid</replaceable>)</literal></entry>

                <entry>Cancel previous evaluation request</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>rec-value(<replaceable>Tid</replaceable>,
                <replaceable>T</replaceable>)</literal></entry>

                <entry>Receive answer to evaluation request</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>snd-do(<replaceable>Tid</replaceable>,
                <replaceable>T</replaceable>)</literal></entry>

                <entry>Send evaluation request to tool (no return
                value)</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>rec-event(<replaceable>Tid</replaceable>,
                <replaceable>T</replaceable>, ...)</literal></entry>

                <entry>Receive event from tool</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>snd-ack-event(<replaceable>Tid</replaceable>,
                <replaceable>T</replaceable>)</literal></entry>

                <entry>Acknowledge previous event from tool</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>printf(<replaceable>S</replaceable>,
                <replaceable>T</replaceable>, ...)</literal></entry>

                <entry>Print terms according to format string S</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>read(<replaceable>T</replaceable><subscript>1</subscript>,
                <replaceable>T</replaceable><subscript>2</subscript>)</literal></entry>

                <entry>Give prompt
                <replaceable>T</replaceable><subscript>1</subscript>and read
                term that should match with
                <replaceable>T</replaceable><subscript>2</subscript></entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>process
                <replaceable>Pnm</replaceable>(<replaceable>F</replaceable>,
                ...) is <replaceable>P</replaceable></literal></entry>

                <entry>Define process <literal> <replaceable>Pnm</replaceable>
                </literal></entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>let <replaceable>F</replaceable>, ... in
                <replaceable>P</replaceable> endlet</literal></entry>

                <entry>Declare local variables in
                <replaceable>P</replaceable></entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>tool <replaceable>Tnm</replaceable> is {
                <replaceable>Feat</replaceable>, ... }</literal></entry>

                <entry>Define tool <replaceable>Tnm</replaceable></entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>host =
                <replaceable>Str</replaceable></literal></entry>

                <entry>Host feature in tool definition</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>command =
                <replaceable>Str</replaceable></literal></entry>

                <entry>Command feature in tool definition</entry>

                <entry></entry>
              </row>

              <row>
                <entry><literal>toolbus(<replaceable>Pnm</replaceable>(<replaceable>T</replaceable>,...),
                ...)</literal></entry>

                <entry>Define initial ToolBus process configuration</entry>

                <entry></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>
  </section>
</chapter>