<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY euro "&#8364;">
<!ENTITY % dbcent PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/dbcentx.mod">
%dbcent;
]>
<chapter version="5.0" xml:id="architecture-meta-environment"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>The Architecture of The Meta-Environment</title>

    <pubdate>$Rev$Author: paulk$ at $2006-12-13 22:16:02 +0100 (Wed,
    13 Dec 2006)$</pubdate>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <warning>
    <para>This is work in progress; this document has not yet been reviewed
    and approved. See <link linkend="ToDo">To Do</link> section.</para>
  </warning>

  <section>
    <title>Motivation</title>

    <para>The Meta-Environment is a powerful system that can be viewed from
    different angles. From the angle of the end-user who creates languages and
    tools using the graphical user interface, from the angle of the power-user
    who builds applications using the command line interface and the system
    libraries to the angle of the system developer who is maintaining and
    extending the system. For all these stakeholders we present architectural
    views that will help them to better understand the system and its
    possibilities.</para>
  </section>

  <section>
    <title>Introduction</title>

    <para>The Meta-Environment is a framework for<emphasis> language
    engineering</emphasis> (language design and implementation, source code
    analysis and source code transformation) consisting of:</para>

    <itemizedlist>
      <listitem>
        <para>Syntax analysis tools.</para>
      </listitem>

      <listitem>
        <para>Semantic analysis and transformation tools.</para>
      </listitem>

      <listitem>
        <para>An interactive development environment.</para>
      </listitem>
    </itemizedlist>

    <para>The Meta-Environment is an open framework that</para>

    <itemizedlist>
      <listitem>
        <para>can be easily extended with third-party components;</para>
      </listitem>

      <listitem>
        <para>can be easily tailored, modified, or extended;</para>
      </listitem>

      <listitem>
        <para>is supported by an open source community.</para>
      </listitem>
    </itemizedlist>

    <para>The Meta-Environment is a generalization of the ASF+SDF
    Meta-Environment that has been successfully used in a wide variety of
    analysis, transformation and renovation projects.</para>

    <para>The Meta-Environment can be used for many different purposes,
    including:</para>

    <itemizedlist>
      <listitem>
        <para>Parsing (new and old) programming languages, for further
        processing the trees, (e.g. COBOL, C, Java, PL/I, SQL)</para>
      </listitem>

      <listitem>
        <para>Analysis of source code (fact extraction, type analysis).</para>
      </listitem>

      <listitem>
        <para>Transformation of source code.</para>
      </listitem>

      <listitem>
        <para>Generation of source code.</para>
      </listitem>

      <listitem>
        <para>Design and implementation of domain-specific languages.</para>
      </listitem>

      <listitem>
        <para>Generation and rapid prototyping of IDE's (Integrated
        Development Environments) for programming languages and domain
        specific languages</para>
      </listitem>

      <listitem>
        <para>Generation of documentation from source code.</para>
      </listitem>

      <listitem>
        <para>Compilation of domain specific languages (DSLs).</para>
      </listitem>

      <listitem>
        <para>Formal description of the syntax and semantics of (programming)
        languages.</para>
      </listitem>
    </itemizedlist>

    <para>The <emphasis>objectives</emphasis> of The Meta-Environment can now
    be summarized as follows:</para>

    <itemizedlist>
      <listitem>
        <para>To give non-expert users access to the above mentioned
        techniques and application areas.</para>
      </listitem>

      <listitem>
        <para>To provide expert users with a powerful tool suite.</para>
      </listitem>

      <listitem>
        <para>To create a flexible testbed for experimentation with new
        research approaches and technologies.</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Stakeholders and Views</title>

      <para>We identify the following stakeholders of The
      Meta-Environment:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>End-users</emphasis> that only use the system via
          the graphical user-interface (GUI).</para>
        </listitem>

        <listitem>
          <para><emphasis>Power-users</emphasis> that use both the GUI, the
          command-line interface of the system as well as libraries and
          Application Programming Interfaces (APIs) provided by the
          system.</para>
        </listitem>

        <listitem>
          <para><emphasis>System developers</emphasis> involved in the design,
          implementation, testing, maintenance and deployment of the
          system.</para>
        </listitem>
      </itemizedlist>

      <para>The following views on the system will be described:</para>

      <itemizedlist>
        <listitem>
          <para>The <link linkend="end-user-view">end-user view</link> (USR)
          describes the system as an interactive black box.</para>
        </listitem>

        <listitem>
          <para>The <link linkend="decomposition-view">decomposition
          view</link> (DCP) describes how the system is organized in
          components.</para>
        </listitem>

        <listitem>
          <para>The <link linkend="coordination-view">coordination view</link>
          (CRD) describes the cooperation between components.</para>
        </listitem>

        <listitem>
          <para>The <link linkend="coordination-view">detailed coordination
          view</link> (DCRD) describes the high level design of several main
          coordination processes within The Meta-Environment</para>
        </listitem>

        <listitem>
          <para>The <link linkend="data-layer-view">data layer view</link>
          (DAT) describes shows the relation between datatypes.</para>
        </listitem>

        <listitem>
          <para>The <link linkend="package-view">package view</link> (PCK)
          describes the mapping between architecture elements and
          implementation packages.</para>
        </listitem>

        <listitem>
          <para>The <link linkend="package-dependency-view">package dependency
          view</link> (DEP) shows how the various packages use each
          other.</para>
        </listitem>

        <listitem>
          <para>The <link linkend="power-user-view">power-user view</link>
          (PWR) describes the system as a suite of commands and
          libraries.</para>
        </listitem>
      </itemizedlist>

      <para>Obviously, not all views are relevant for all stakeholders. Table
      <link linkend="table-stakeholders-views">Mapping between stakeholders
      and views</link> shows the details.</para>

      <table border="1" xml:id="table-stakeholders-views">
        <caption>Mapping between stakeholders and views</caption>

        <tr>
          <td><emphasis role="bold">Stakeholder</emphasis></td>

          <td><emphasis role="bold"><link
          linkend="end-user-view">USR</link></emphasis></td>

          <td><emphasis role="bold"><link
          linkend="decomposition-view">DCP</link></emphasis></td>

          <td><emphasis role="bold"><link
          linkend="coordination-view">CRD</link></emphasis></td>

          <td><emphasis role="bold"><link
          linkend="data-layer-view">DAT</link></emphasis></td>

          <td><emphasis role="bold"><link
          linkend="package-view">PCK</link></emphasis></td>

          <td><emphasis role="bold"><link
          linkend="power-user-view">PWR</link></emphasis></td>

          <td><link linkend="package-dependency-view"><emphasis
          role="bold">DEP</emphasis></link></td>
        </tr>

        <tr>
          <td>End-user</td>

          <td>d</td>

          <td>s</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>Power-user</td>

          <td>s</td>

          <td>d</td>

          <td>s</td>

          <td>s</td>

          <td>s</td>

          <td>x</td>

          <td>s</td>
        </tr>

        <tr>
          <td>System developer</td>

          <td>s</td>

          <td>d</td>

          <td>d</td>

          <td>d</td>

          <td>x</td>

          <td>d</td>

          <td>x</td>
        </tr>
      </table>

      <para>Key: d = detailed information, s = some details, overview
      information, x = anything</para>
    </section>

    <section xml:id="elements-in-views">
      <title>The Elements in Views</title>

      <para>For later reference, we give here a comprehensive overview of all
      <link linkend="language-elements">language elements</link>, <link
      linkend="data-elements">data elements</link>, and <link
      linkend="processing-elements">processing elements</link> that occur in
      the various architecture views.</para>

      <section xml:id="language-elements">
        <title>The Language Elements</title>

        <para>The language elements are formalisms for specification,
        programming or scripting. Programs in these languages are read and
        written by humans and are intended to solve specific problems.</para>

        <formalpara xml:id="def-ADT">
          <title>Abstract Data Type (ADT)</title>

          <para>Structural description of the interface of a component. Used
          by APIGEN to generate an Application Programmer's Interface (API)
          for the component.</para>
        </formalpara>

        <formalpara>
          <title>ASF</title>

          <para>Algebraic Specification Formalism. This a notation for
          describing rewrite rules and is mostly used for defining software
          analysis, fact extraction, and software transformation.</para>
        </formalpara>

        <formalpara>
          <title>ASF+SDF</title>

          <para>The combination of the formalisms ASF and SDF. ASF+SDF can
          describe both the syntax of a language and the operations on that
          language (checking, execution, analysis, transformation).</para>
        </formalpara>

        <formalpara xml:id="def-ASFSDF-library">
          <title>ASF+SDF library</title>

          <para>A collection of elementary datatypes (lists, tables, etc.),
          language grammars (C, COBOL, Java, SDF, etc.) and utilities.</para>
        </formalpara>

        <formalpara xml:id="def-ASFSDF-modules">
          <title>ASF+SDF modules</title>

          <para>The ASF+SDF modules describe:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>the syntax of the base language,</para>
          </listitem>

          <listitem>
            <para>the functions that can be applied to base language
            programs.</para>
          </listitem>
        </itemizedlist>

        <para>Note that the ASF+SDF modules may define several base languages
        at the same time.</para>

        <formalpara xml:id="def-input-term">
          <title>Input term</title>

          <para>A text that conforms to the syntax defined in the ASF+SDF
          modules. This includes:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>the syntax of the base language (e.g., C, Java, Boolean
            expressions, a domain-specific language),</para>
          </listitem>

          <listitem>
            <para>the functions that can be applied to base language programs
            (e.g., typecheck, extract facts, compile, remove unused
            methods).</para>
          </listitem>
        </itemizedlist>

        <para>The input term can be freely edited and is checked for syntactic
        correctness before any function is applied to it. It is possible to
        simultaneously edit different input terms in different base
        languages.</para>

        <formalpara xml:id="def-output-term">
          <title>Output term</title>

          <para>A text that describes the result of applying a function to a
          program in the base language. Note that this text conforms to the
          syntax R, where R is the result sort of the function that was
          applied. With Java-to-Java transformation the result sort will be
          Java. When no function is applied, the output term is identical to
          the input term.</para>
        </formalpara>

        <formalpara>
          <title>Rscript</title>

          <para>A small scripting language for defining relational
          expressions. Used for the analysis of facts extracted from
          software.</para>
        </formalpara>

        <warning>
          <para>Rscript is not yet integrated in V2.0.</para>
        </warning>

        <formalpara>
          <title>SDF</title>

          <para>Syntax Definition Formalism. A notation for describing the
          grammar of programming and application languages.</para>
        </formalpara>

        <formalpara>
          <title>Tscript</title>

          <para>The script that describes the cooperation between components
          in a ToolBus-based application.</para>
        </formalpara>
      </section>

      <section xml:id="data-elements">
        <title>The Data Elements</title>

        <para>The data elements are formats for representing domain-specific
        data. The corresponding data are written and read by programs.</para>

        <formalpara xml:id="def-asfix">
          <title>AsFix</title>

          <para>ASF+SDF Fixed format. The dataformat used to represent parse
          trees. AsFix is a specialized view on ATerms. Important features
          are:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>The AsFix format is a full parse trees that contains all the
            original layout and comments from the original source code program
            that was parsed.</para>
          </listitem>

          <listitem>
            <para>The AsFix format is self-descriptive: each subtree contains
            information about the exact grammar production that has been used
            to parse the text that has resulted in that parse tree.</para>
          </listitem>

          <listitem>
            <para>The AsFix format does not contain source code coordinates
            per se, but a separate tool (<command>addPosInfo</command>) can
            easily compute these coordinates and add them to the parse tree in
            the form of annotations.</para>
          </listitem>
        </itemizedlist>

        <formalpara xml:id="def-aterm">
          <title>ATerm</title>

          <para>Annotated terms. A dataformat used for the internal
          representation of all data. Distinguishing features are:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>ATerms are language-independent and can be processed by
            programs in any language.</para>
          </listitem>

          <listitem>
            <para>ATerms can be annotated with auxiliary information that does
            not affect the tree structure.</para>
          </listitem>

          <listitem>
            <para>ATerms preserve <emphasis>maximal subterm
            sharing</emphasis>. This means that common parts of the data are
            not duplicated but shared. This leads to considerable
            size-reduction of the data.</para>
          </listitem>
        </itemizedlist>

        <formalpara xml:id="def-box">
          <title>Box</title>

          <para>Intermediate representation of the prettyprinter. A parse tree
          is first converted to a box term that includes all desired
          formatting directives (alignment, font and color directives, and the
          like). Next, the box term is converted to various output formats
          (plain text, HTML, etc.).</para>
        </formalpara>

        <formalpara xml:id="def-compiled-specification">
          <title>Compiled specification</title>

          <para>It is possible to compile the ASF+SDF into a very efficient
          executable form. Compiled specifications can be used via the command
          line interface of The Meta-Environment by power users.</para>
        </formalpara>

        <formalpara xml:id="def-graph">
          <title>Graph</title>

          <para>Data format to represent graphs. Used as representation of
          import graphs and parse trees that are displayed in the GUI.</para>
        </formalpara>

        <formalpara xml:id="def-location">
          <title>Location</title>

          <para>Data format to describe locations in source code.</para>
        </formalpara>

        <formalpara xml:id="def-summary">
          <title>Summary</title>

          <para>An error or message summary. A dataformat for the internal
          representation of errors and messages. Summaries are produced by
          checker and compilers and are used by the GUI.</para>
        </formalpara>

        <formalpara xml:id="def-parse-table">
          <title>Parse table</title>

          <para>A parse table is an efficient representation (ATerm) of the
          base language as defined by the ASF+SDF modules and enables
          efficient parsing.</para>
        </formalpara>

        <formalpara xml:id="def-parse-tree">
          <title>Parse tree</title>

          <para>Tree-structured representation (in AsFix) of a text that has
          been analyzed by a parser.</para>
        </formalpara>
      </section>

      <section xml:id="processing-elements">
        <title>The Processing Elements</title>

        <para>The processing elements are "active" parts of the system that
        usually transform inputs to outputs. Inputs and outputs may both be
        machine or human readable or writable.</para>

        <formalpara xml:id="def-APIGEN">
          <title>APIGEN</title>

          <para>Application Programming Interface (API) generator. Given a
          datastructure definition (in the form of an Abstract Data Type),
          APIGEN generates C or Java code to access that datastructure.
          Internally, the datastructure is represented as ATerm.</para>
        </formalpara>

        <formalpara xml:id="def-ASF-checker">
          <title>ASF checker</title>

          <para>ASF checker performs static checking on ASF
          definitions.</para>
        </formalpara>

        <formalpara xml:id="def-ASF-compiler">
          <title>ASF compiler</title>

          <para>The ASF compiler transforms ASF specifications to C code. That
          C code is compiled and linked with a run-time library. This leads
          very efficient execution of specifications.</para>
        </formalpara>

        <formalpara xml:id="def-ASF-interpreter">
          <title>ASF interpreter</title>

          <para>The ASF interpreter takes the equation sections from the
          ASF+SDF specification and applies them to the parsed input term. It
          produces another parse tree as output.</para>
        </formalpara>

        <formalpara xml:id="def-ASF-operations">
          <title>ASF operations</title>

          <para>ASF operations provides all operations to read and modify ASF
          definitions.</para>
        </formalpara>

        <formalpara xml:id="def-ASFSDF-checker">
          <title>ASF+SDF checker</title>

          <para>The ASF+SDF checker checks an SDF definition for compatibility
          for use with ASF, and also checks some production attributes that
          are specifically interpreted by ASF rewriting engines. It is an
          extension of the SDF checker.</para>
        </formalpara>

        <formalpara>
          <title>Configuration manager</title>

          <para>The configuration manager handles user settings and
          preferences.</para>
        </formalpara>

        <formalpara xml:id="def-debugger">
          <title>Debugger</title>

          <para>The debugger allows a step-by-step execution of the rewrite
          rules defined in ASF+SDF specifications.</para>
        </formalpara>

        <formalpara xml:id="def-errors-and-warnings">
          <title>Errors &amp; warnings</title>

          <para>Errors &amp; warnings pinpoint any errors in the ASF+SDF
          modules or input terms.</para>
        </formalpara>

        <formalpara xml:id="def-GUI">
          <title>Graphical user interface (GUI)</title>

          <para>The graphical user-interface (GUI) gives end-users access to
          the system's functionality. It is a "sovereign" user-interface that
          occupies the complete desktop window and provides functionality
          like:</para>
        </formalpara>

        <para><itemizedlist>
            <listitem>
              <para>Opening, editing and closing ASF+SDF modules.</para>
            </listitem>

            <listitem>
              <para>Opening, editing, reducing and closing input terms.</para>
            </listitem>

            <listitem>
              <para>A graphical and tree-structured display of the import
              relations between ASF+SDF modules.</para>
            </listitem>

            <listitem>
              <para>A graphical display of parse trees.</para>
            </listitem>

            <listitem>
              <para>Error and progress indications.</para>
            </listitem>
          </itemizedlist></para>

        <formalpara xml:id="def-module-manager">
          <title>Module manager</title>

          <para>The module manager is responsible for all information related
          to the ASF+SDF modules that reside in the system.</para>
        </formalpara>

        <formalpara xml:id="def-parse-table-generator">
          <title>Parse table generator</title>

          <para>The parse table generator takes syntax sections from the
          ASF+SDF specification and converts them to a parse table to be used
          for the parsing of terms.</para>
        </formalpara>

        <formalpara xml:id="def-parser">
          <title>Parser</title>

          <para>The parser takes a parse table (as produced by the parse table
          generator) and text (as provided by a text editor) as input and
          produces a parse tree as output. Any errors are shown in the error
          display of the GUI.</para>
        </formalpara>

        <formalpara xml:id="def-prettyprinter">
          <title>Prettyprinter</title>

          <para>The prettyprinter converts parse trees to text. The
          prettyprinter uses default rules to insert layout in a parse tree so
          that its corresponding text is presented in a uniform way.
          Optionally, the ASF+SDF specification may contain formatting rules
          that can replace this default behaviour.<warning>
              <para>The prettyprinter is not yet fully integrated in
              V2.0.</para>
            </warning></para>
        </formalpara>

        <formalpara>
          <title>Sisyphus</title>

          <para>A system for continuous integration that rebuilds the system
          after each change that is committed by a developer.</para>
        </formalpara>

        <formalpara xml:id="def-SDF-operations">
          <title>SDF operations</title>

          <para>SDF operations provides all operations to read and modify SDF
          definitions.</para>
        </formalpara>

        <formalpara xml:id="def-SDF-checker">
          <title>SDF checker</title>

          <para>SDF checker performs static checking on SDF
          definitions.</para>
        </formalpara>

        <formalpara xml:id="def-structure-editor">
          <title>Structure editor</title>

          <para>A syntax-directed editor that closely cooperates with the text
          editor. It is mostly used for syntax-directed navigation through the
          text. The structure-editor does not appear as such in the GUI but
          all its functionality is visible through the text editor.</para>
        </formalpara>

        <formalpara>
          <title>Term store</title>

          <para>The term store contains all parse tables, parse trees and
          other intermediate data that is generated during execution of The
          Meta-Environment. This includes:</para>
        </formalpara>

        <itemizedlist>
          <listitem>
            <para>The parse tree for each ASF+SDF module.</para>
          </listitem>

          <listitem>
            <para>The parse tree for each parsed input term.</para>
          </listitem>

          <listitem>
            <para>The parse tree for each generated output term.</para>
          </listitem>
        </itemizedlist>

        <formalpara xml:id="def-text-editor">
          <title>Text editor</title>

          <para>The text editor allows text editing on ASF+SDF modules and
          input terms. Multiple editors may be opened; each appears as a
          tabbed window in one of the panes of the GUI.</para>
        </formalpara>

        <formalpara>
          <title>The Meta-Environment</title>

          <para>The architecture of The Meta-Environment (or just "the
          system") is the primary object of study of this document.</para>
        </formalpara>

        <formalpara xml:id="def-toolbus">
          <title>ToolBus</title>

          <para>The ToolBus coordination architecture enables the flexible and
          controlled combination and orchestration of software components. It
          is used as backbone for The Meta-Environment. The ToolBus has the
          following characteristics:</para>
        </formalpara>

        <para><itemizedlist>
            <listitem>
              <para>Components (or <emphasis>tools</emphasis> in ToolBus
              parlance) can be written in different programming
              languages.</para>
            </listitem>

            <listitem>
              <para>Components can be running on different machines.</para>
            </listitem>

            <listitem>
              <para>All interactions between components are regulated by a
              ToolBus script (or Tscript for short) that is executing in the
              ToolBus. Tscript is a concurrent language that allows the
              definition of parallel processes, messaging between these
              processes and interaction between processes and tools.</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>

    <section>
      <title>Rationale for the Architecture</title>

      <para>The following quality attributes guide the design of the
      architecture of the Meta-Environment.</para>

      <formalpara>
        <title>Usability</title>

        <para>We want to support our users at all levels of experience in as
        many ways as possible:</para>
      </formalpara>

      <itemizedlist>
        <listitem>
          <para>Through a GUI that automates many of the tasks involved in
          language engineering. For instance, the user only sees a grammar and
          the fact that it can be used for parsing but is unaware of the fact
          that parse table generation is going on behind the scenes. The same
          is true for rewriting, formatting and the like.</para>
        </listitem>

        <listitem>
          <para>Through a command line interface that allows the batch-like
          combination of components.</para>
        </listitem>

        <listitem>
          <para>Through libraries that package specific functionality that can
          be called directly from user-written programs.</para>
        </listitem>

        <listitem>
          <para>Through ToolBus components that can be included in interactive
          applications.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Adaptability</title>

        <para>The Meta-Environment is at the same time a framework for
        building applications in the area of language engineering and a
        testbed for doing research. This implies that we want to be able to
        combine existing components in new and flexible manners and to enable
        the easy integration of new components.</para>
      </formalpara>

      <formalpara>
        <title>Performance</title>

        <para>The Meta-Environment is not primarily intended for large scale
        industrial or commercial use. However, the performance should be such
        that experiments with real source code of industrial size (millions of
        lines of code) are possible.</para>
      </formalpara>

      <formalpara>
        <title>Testability</title>

        <para>It should be possible to test individual components
        separately.</para>
      </formalpara>

      <para>We pay less attention to other important quality attributes such
      as <emphasis>availability</emphasis> and <emphasis>security</emphasis>,
      but we expect that they will become more important as the system
      evolves.</para>
    </section>

    <section>
      <title>Mapping between Elements and Views</title>

      <para>Figure <link linkend="table-mapping-elements-views">Mapping
      between elements and views</link> keeps track of which elements are used
      in which views.</para>

      <table border="1">
        <caption xml:id="table-mapping-elements-views">Mapping between
        elements and views</caption>

        <tr>
          <td><emphasis role="bold">Element</emphasis></td>

          <td><emphasis role="bold"><link
          linkend="end-user-view">USR</link></emphasis></td>

          <td><emphasis role="bold"><link
          linkend="decomposition-view">DCP</link></emphasis></td>

          <td><emphasis role="bold"><link
          linkend="coordination-view">CRD</link></emphasis></td>

          <td><emphasis role="bold"><link
          linkend="data-layer-view">DAT</link></emphasis></td>

          <td><link linkend="package-view"><emphasis linkend="package-view"
          role="bold">PCK</emphasis></link></td>

          <td><emphasis role="bold"><link
          linkend="power-user-view">PWR</link></emphasis></td>

          <td><link linkend="package-dependency-view"><emphasis
          role="bold">DEP</emphasis></link></td>
        </tr>

        <tr>
          <td>APIGEN</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>ASF checker</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>ASF compiler</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>ASF interpreter</td>

          <td></td>

          <td>x</td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>ASF operations</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>ASF+SDF library</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>ASF+SDF modules</td>

          <td>x</td>

          <td>x</td>

          <td></td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>ASF+SDF checker</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Compiled specification</td>

          <td>x</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Configuration manager</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>Errors &amp; warnings</td>

          <td>x</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Graphical user interface (GUI)</td>

          <td>x</td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Input term</td>

          <td>x</td>

          <td>x</td>

          <td></td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Module manager</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Output term</td>

          <td>x</td>

          <td>x</td>

          <td></td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Parse table generator</td>

          <td></td>

          <td>x</td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Parse table</td>

          <td>x</td>

          <td>x</td>

          <td></td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Parser</td>

          <td></td>

          <td>x</td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Parse tree</td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Prettyprinter</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>SDF checker</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>SDF operations</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Structure editor</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>Term store</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>Text editor</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>

        <tr>
          <td>The Meta- Environment</td>

          <td>x</td>

          <td>x</td>

          <td>x</td>

          <td></td>

          <td>x</td>

          <td>x</td>

          <td>x</td>
        </tr>

        <tr>
          <td>ToolBus</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>

          <td></td>

          <td>x</td>

          <td></td>
        </tr>
      </table>
    </section>
  </section>

  <section xml:id="end-user-view">
    <title>The End-User View (USR)</title>

    <para>Figure <link linkend="fig-end-user-view">End-user view of The
    Meta-Environment</link> shows how simple The Meta-Environment is for an
    end-user. Via a graphical user interface, the user can edit ASF+SDF
    modules that describe the syntax and semantics of some user-defined
    language, let's say Java. The ASF+SDF modules will define the grammar of
    the Java language (this is actually already provided in the ASF+SDF
    library) and some functions on Java programs such as extracting facts or
    describing transformations on the Java code. The user can also edit an
    input term, that is a text that conforms to the definitions in the ASF+SDF
    specification (say, a Java program with a transformation function applied
    to it). Via the user-interface the user can now activate the application
    of the equations in the ASF+SDF specification to the input. The answer is
    an output term that will consist -- in this example -- of a transformed
    Java program. Of course, errors may occur and they are shown in the GUI.
    As an aid for power-users some additional information like compiled
    ASF+SDF specifications and parse tables can be exported.</para>

    <figure xml:id="fig-end-user-view">
      <title>End-user view of The Meta-environment</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="gui-view.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Element Catalog</title>

      <para><link linkend="def-ASFSDF-library">ASF+SDF library</link>, <link
      linkend="def-ASFSDF-modules">ASF+SDF modules</link>, <link
      linkend="def-compiled-specification">Compiled specification</link>,
      <link linkend="def-errors-and-warnings">Errors &amp;
      warnings</link>,<link linkend="def-input-term"> Input term</link>, <link
      linkend="def-output-term">Output term</link>, <link
      linkend="def-parse-table">Parse table.</link></para>
    </section>

    <section xml:id="end-user-view-context">
      <title>Context Diagram</title>

      <figure>
        <title>Context end-user view</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="gui-view-context.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Variability Guide</title>

      <para>The user has the following options for variability:</para>

      <itemizedlist>
        <listitem>
          <para>The filesystem directory from which The Meta-Environment is
          started (using the command <command>asfsdf-meta</command>)
          determines the working directory to be used during the session with
          the system.</para>
        </listitem>

        <listitem>
          <para>The file configuration file <filename>meta.actions</filename>
          (in the current working directory) can be used to extend the
          behaviour of the sytem. This is further explained in Extension
          Points of The Meta-Environment. (<remark>LINK</remark>)</para>
        </listitem>

        <listitem>
          <para>The GUI provides some options to change the overall graphical
          appearance (skinning) and the way in which graphs are
          displayed.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Architecture Background</title>

      <section>
        <title>Design Rationale</title>

        <para>In the end-user view, we try to make life as easy as possible
        for the user and try to automate whatever we can. For instance, when a
        user reduces the input term to the output term, he needs not be aware
        of the fact that first a parse table has to be generated and that the
        input term is then parsed. The fact that after editing an ASF+SDF
        module, it may be necessary to regenerate the parse table is also
        implicit. The end-user is shielded from all internal
        representations.</para>
      </section>

      <section>
        <title>Analysis of Results</title>

        <para>The Meta-Environment mostly satisfies the design goal of
        usability. Some known usability weaknesses are:</para>

        <itemizedlist>
          <listitem>
            <para>The error messages generated by the parser are poor.</para>
          </listitem>

          <listitem>
            <para>There is no support for finding errors in syntax
            definitions.</para>
          </listitem>

          <listitem>
            <para>Certain features found in other IDEs are still missing
            (e.g., autocompletion, context-dependent help menus, and
            others).</para>
          </listitem>

          <listitem>
            <para>The user documentation is still not yet complete and
            up-to-date, but we are working on this ;-)</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Assumptions</title>

        <para>The current system assumes that the user can write ASF+SDF
        specifications without further automatic support. It turns out that
        writing syntax definitions is not so easy and that some automatic
        support is welcome.</para>
      </section>
    </section>

    <section>
      <title>Other Information</title>

      <para>This view does not provide any details on the actual operation of
      the user-interface. Some details are helpful:</para>

      <itemizedlist>
        <listitem>
          <para>The user-interface is a <emphasis>sovereign
          application</emphasis>, i.e., it can occupy the full window of the
          desktop.</para>
        </listitem>

        <listitem>
          <para>The user-interface provides a graphical view on the import
          relations between ASF+SDF modules and the parse trees of selected
          modules or terms.</para>
        </listitem>

        <listitem>
          <para>The user-interface provides a debugging view on the execution
          of ASF+SDF specifications.</para>
        </listitem>

        <listitem>
          <para>This view only shows one input term and corresponding output
          term. In reality, several input terms may be edited and be reduced
          to the corresponding output term.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="decomposition-view">
    <title>The Decomposition View (DCP)</title>

    <para>The decomposition of the system in parts is shown in figure <link
    linkend="decomposition-view">The decomposition view</link>. It emphasizes
    the parts that are needed to transform an input term to an output term.
    Not shown are the interaction with the user-interface, the precise
    processing of the ASF+SDF modules, and the generation of compiled
    specifications and parse tables.</para>

    <para><figure xml:id="fig-decomposition-view">
        <title>The decomposition view</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="decomposition-view.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure></para>

    <section>
      <title>Element Catalog</title>

      <para><link linkend="def-ASF-interpreter">ASF interpreter</link>, <link
      linkend="def-ASFSDF-library">ASF+SDF library</link>, <link
      linkend="def-ASFSDF-modules">ASF+SDF modules</link>, Default prettyprint
      rules, <link linkend="def-errors-and-warnings">Errors &amp;
      warnings</link>, <link linkend="def-input-term">Input term</link>, <link
      linkend="def-output-term">Output term</link>, <link
      linkend="def-parser">Parser</link>, <link
      linkend="def-parse-table">Parse table</link>, <link
      linkend="def-parse-table-generator">Parse table generator</link>.</para>
    </section>

    <section>
      <title>Context Diagram</title>

      <para>Identical to the <link linkend="end-user-view-context">context
      diagram of the end-user view</link>.</para>
    </section>

    <section>
      <title>Variability Guide</title>

      <para>In addition to the ASF+SDF modules that determine the
      characteristics of the languages that are being defined, the user can
      override the default pretty printing rules for each language by giving
      extra ASF+SDF modules containing specialized pretty printing
      rules.</para>
    </section>

    <section>
      <title>Architecture Background</title>

      <section>
        <title>Design Rationale</title>

        <para>This system decomposition is rather traditional. It
        distinguishes parser, semantic operations and prettyprinter. For
        reasons of uniformity, pretty printing rules are also specified in
        ASF+SDF.</para>
      </section>

      <section>
        <title>Analysis of Results</title>

        <para>None.</para>
      </section>

      <section>
        <title>Assumptions</title>

        <para>The following assumptions have been made:</para>

        <itemizedlist>
          <listitem>
            <para>Full parse trees (e.g., parse trees containing all
            structural and textual information, including layout and comments,
            of the original source text) are the best intermediate
            representation for programs. This is motivated by the need in
            software renovation projects to perform source code
            transformations that preserve as much of the original source text
            as possible.</para>
          </listitem>

          <listitem>
            <para>All extra information that has to be attached to parse trees
            can be expressed as annotations to that parse tree. This regards
            source code coordinates, information about constructors, and the
            like.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Other Information</title>

      <para>Various simplifications have been applied in this view:</para>

      <itemizedlist>
        <listitem>
          <para>The graphical user-interface is not shown.</para>
        </listitem>

        <listitem>
          <para>We abstract from the internal processing of ASF+SDF
          specifications.</para>
        </listitem>

        <listitem>
          <para>The various internal formats that play a role are not
          shown.</para>
        </listitem>

        <listitem>
          <para>The compilation of specifications is not shown.</para>
        </listitem>

        <listitem>
          <para>The generation of parse trees (for external) use is not
          shown.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="coordination-view">
    <title>The Coordination View (CRD)</title>

    <para>Figure <link linkend="fig-coordination-view">The coordination
    view</link> shows the interaction between the components of The
    Meta-Environment via the ToolBus middleware layer. This view can be
    separated in three parts:</para>

    <itemizedlist>
      <listitem>
        <para>Kernel: components providing basic functionality, like
        user-interface and editing.</para>
      </listitem>

      <listitem>
        <para>SDF: all components related to SDF and syntax analysis.</para>
      </listitem>

      <listitem>
        <para>ASF: all components related to ASF and term rewriting.</para>
      </listitem>
    </itemizedlist>

    <para>The connections between the components are established by the
    Tscript that is executing in the ToolBus. Note that multiple instances may
    exist of some components. For instance, a separate instance of the text
    editor exists for editing different terms or modules.</para>

    <figure xml:id="fig-coordination-view">
      <title>The coordination view</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="coordination-view.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Element Catalog</title>

      <para><link linkend="def-ASF-checker">ASF checker</link>, <link
      linkend="def-ASF-compiler">ASF compiler</link>, <link
      linkend="def-ASF-operations">ASF operations</link>, <link
      linkend="def-ASF-interpreter">ASF interpreter</link>, <link
      linkend="def-ASFSDF-checker">ASF+SDF checker</link>, Default prettyprint
      rules, <link linkend="def-errors-and-warnings">Errors &amp;
      warnings</link>,<link linkend="def-GUI">GUI</link>, <link
      linkend="def-input-term">Input term</link>, <link
      linkend="def-module-manager">Module manager</link>, <link
      linkend="def-output-term">Output term</link>, <link
      linkend="def-parser">Parser</link>, <link
      linkend="def-parse-table">Parse table</link>, <link
      linkend="def-parse-table-generator">Parse table generator</link>, <link
      linkend="def-prettyprinter">Prettyprinter</link>, <link
      linkend="def-SDF-checker">SDF checker</link>, <link
      linkend="def-SDF-operations">SDF operations</link>, <link
      linkend="def-structure-editor">Structure editor</link>, <link
      linkend="def-text-editor">Text editor</link>, <link
      linkend="def-toolbus">ToolBus</link>.</para>
    </section>

    <section>
      <title>Context Diagram</title>

      <para>None.</para>
    </section>

    <section>
      <title>Variability Guide</title>

      <para>This architecture was designed with variability in mind. By
      replacing the Tscript in the ToolBus, largely different applications can
      be built.</para>
    </section>

    <section>
      <title>Architecture Background</title>

      <section>
        <title>Design Rationale</title>

        <para>The rationale for this architecture is to:</para>

        <itemizedlist>
          <listitem>
            <para>Decouple the components as much as possible.</para>
          </listitem>

          <listitem>
            <para>Enable the composition of components written in different
            languages.</para>
          </listitem>

          <listitem>
            <para>Enable the execution of components in a distributed fashion
            on more than one computer.</para>
          </listitem>

          <listitem>
            <para>Enable variability by allowing the composition of existing
            and new components in new ways.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Analysis of Results</title>

        <para>It is fair to say that the above design goals have been
        achieved. Components become less aware of their context and are more
        easily composable. Unavoidably, the Tscript has to describe all these
        compositions and becomes the central information hub. In large
        applications like The Meta-Environment these Tscripts become quite
        large and complex, but they are fortunately the only location where
        this composition information resides.</para>
      </section>

      <section>
        <title>Assumptions</title>

        <para>The assumptions in this view are as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Components can be written in different programming
            languages.</para>
          </listitem>

          <listitem>
            <para>The information exchange between components and ToolBus is
            by way of ATerms.</para>
          </listitem>

          <listitem>
            <para>For all relevant languages adapters exist to connect
            programs written in those languages to the ToolBus.</para>
          </listitem>

          <listitem>
            <para>It is possible to execute components on different,
            connected, physical computers. In some situations firewall
            settings may prevent this.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Other Information</title>

      <itemizedlist>
        <listitem>
          <para>The ToolBus uses TCP/IP sockets to implement the connections
          with tools.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>The Detailed Coordination View (DCRD)</title>

    <para>As the coordination view explained, the main coordination
    architecture of The Meta-Environment is provided by the ToolBus. The
    ToolBus runs a ToolBus script containing many processes that coordinate
    the features of The Meta-Environment. This Detailed Coordination View
    highlights these processes. There are no diagrams in this view, just a
    number of explanations. These are the major coordination processes:</para>

    <orderedlist>
      <listitem>
        <para>Editing - the process of editing files, which includes
        triggering several tools that provide feedback to the user.</para>
      </listitem>

      <listitem>
        <para>Module management - the process of managing modules, builds and
        dependencies, which includes triggering tools that provide feedback to
        the user.</para>
      </listitem>

      <listitem>
        <para>Configuration management - the processes of managing the
        configuration of The Meta-Environment in terms of the visible menu
        options and other keyboard and mouse user interactions.</para>
      </listitem>

      <listitem>
        <para>Transaction management - a generic mechanism to define critical
        sections that lock the use of certain available data and tools to
        prevent racing conditions</para>
      </listitem>
    </orderedlist>

    <para>Note that the main coordination processes of The Meta-Environment
    are designed to be language independent. They reside in the meta package
    which is a part of the kernel layer. Other packages that depend on the
    meta package, such as sdf-meta (SDF layer) and asfsdf-meta (ASF+SDF
    layer), bind configuration parameters and specialize the generic
    functionality to obtain programming language specific IDE's. The way that
    the language specific layers extend the kernel layer is governed by this
    architecture description.</para>

    <section>
      <title>Processes</title>

      <para>The common scheme of all ToolBus script processes is that there
      are 'listener', 'util', 'action' and 'other' processes. They are grouped
      into files with a straightforward file naming scheme. </para>

      <itemizedlist>
        <listitem>
          <para>Listeners catch notes that are send by other ToolBus
          processes, and forward to util processes.</para>
        </listitem>

        <listitem>
          <para>Actions are processes that are triggered directly by a user
          interaction, which forward to util processes.</para>
        </listitem>

        <listitem>
          <para>Utils are the implementation processes, they do the actual
          work.</para>
        </listitem>
      </itemizedlist>

      <para>Note that communication can be done in ToolBus scripts in three
      ways: sending messages, sending notes and calling processes. In general
      the rules communication of The Meta-Environment management processes
      are:</para>

      <itemizedlist>
        <listitem>
          <para>tool processes - which are single processes each associated
          with a single tool, also called 'idefs' - send and receive
          <emphasis>messages, </emphasis>except for manager tools which can
          also send <emphasis>notes</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>notes</emphasis> are received by listener processes,
          which <emphasis>call </emphasis>util processes</para>
        </listitem>

        <listitem>
          <para>utilitity processes <emphasis>call</emphasis> eachother, and
          send messages to tool processes, where it is tried to wrap single
          messages to tools in simple process definitions</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>Editing</title>

        <para></para>
      </section>

      <section>
        <title>Module management</title>

        <para>The goal of module management is to trigger functionality
        (utils) on source files, such as .sdf or .asf files, at the right time
        and to provide the user with a consistent view of the state of the
        source files that are edited by the user in the environment.</para>

        <itemizedlist>
          <listitem>
            <para>The module-manager tool connects to the Bus and maintains an
            administration of which modules are currently loaded and what
            their dependencies are</para>
          </listitem>

          <listitem>
            <para>The module-manager maintains a list of key-value attributes
            (ATerms) for each module. Each key has a namespace and a name. Any
            T-script can set or change the attributes of a module.</para>
          </listitem>

          <listitem>
            <para>The module-manager broadcasts notifications on the ToolBus
            whenever a module is added or removed, a dependency is added or
            removed, or an attribute is changed.</para>
          </listitem>

          <listitem>
            <para>Language specific scripts in the SDF or ASF+SDF layer
            register 'event rules' with the module-manager. The event rules
            define how some attributes on modules are set automatically by
            propagating information acros the dependency graph between
            modules. This event rule mechanism can deal with cyclic
            dependencies. A single change of an attribute on a module, can
            thus spawn a number of changes on other modules, all changes are
            broadcasted as independently on the ToolBus.</para>
          </listitem>

          <listitem>
            <para>Event listeners (note receivers in T-script) listen to the
            changes in the module manager and trigger appropriate utils. Some
            utils change the attributes of modules, triggering other utils via
            other listeners.</para>
          </listitem>
        </itemizedlist>

        <para>There is one central attribute that is used a lot by The
        Meta-Environment called "status". A particular view on The
        Meta-Environment module management process is that it is a collection
        of state machines, one per each module:</para>

        <itemizedlist>
          <listitem>
            <para>The status attribute of a module can have a fixed set of
            values, called the "states" of the module.</para>
          </listitem>

          <listitem>
            <para>Specific processes are tied to states by the event
            listeners. When the status attribute changes to a particular
            state, the processes that belong to that state are executed using
            listeners</para>
          </listitem>

          <listitem>
            <para>Processes that are finished set the next state of
            modules.</para>
          </listitem>

          <listitem>
            <para>The state attribute can also be updated by event rules, such
            that modules change to a different state without ToolBus script
            intervention.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Configuration management</title>

        <para></para>
      </section>

      <section>
        <title>Transaction management</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>Element Catalog</title>

      <para> <link linkend="def-errors-and-warnings">Errors &amp;
      warnings</link>,<link linkend="def-GUI"> GUI</link>, <link
      linkend="def-module-manager">Module manager</link>, <link
      linkend="def-structure-editor">Structure editor</link>, <link
      linkend="def-text-editor">Text editor</link>, <link
      linkend="def-toolbus">ToolBus</link>, Editor Manager, Configuration
      Manager, Transaction Manager</para>
    </section>

    <section>
      <title>Context Diagram</title>

      <para>See <link linkend="fig-coordination-view">Coordination
      view</link></para>
    </section>

    <section>
      <title>Variability Guide</title>

      <para>For each of the main coordination processes there are different
      variability stories</para>

      <section>
        <title>Editor management</title>

        <para></para>
      </section>

      <section>
        <title>Module management</title>

        <para>The generic nature of the module manager makes it easy to adapt
        and extends it to new programming languages. </para>

        <orderedlist>
          <listitem>
            <para>Add a new 'name space' to add a new language</para>
          </listitem>

          <listitem>
            <para>Add a new 'event rule' to propagate new information acros
            the dependency graph</para>
          </listitem>

          <listitem>
            <para>Add a new note listener to add new automatic features to the
            environment.</para>
          </listitem>
        </orderedlist>
      </section>

      <section>
        <title>Configuration management</title>

        <para></para>
      </section>

      <section>
        <title>Transaction management</title>

        <para>The asynchronous and parallel nature of the other processes -
        i.e. ToolBus scripts implementing module management and configuration
        management using notes as an event mechanism - introduces the default
        problems with shared resources: deadlock and racing conditions.</para>
      </section>
    </section>

    <section>
      <title>Architecture Background</title>

      <section>
        <title>Design Rationale</title>

        <para>In general, the design rationale behind the processes in The
        Meta-Environment is <emphasis>reusability</emphasis>. The main
        processes are to be designed in such a way that they are programming
        language independent. The goal is to be able to instantiate an IDE by
        providing the right parameters to the generic ToolBus scripts to
        obtain language specific IDE behavior. </para>

        <para>The other main rationale behind these designs is
        <emphasis>extensibility</emphasis>. For example, the asynchronous,
        parallel and independently addeable event listeners make sure that the
        system can be layered, and also extended without changing the existing
        functionality. However, this does introduce the need for transaction
        management.</para>

        <para>For <emphasis>traceability</emphasis> of ToolBus scripts we try
        to use ToolBus process calls over snd-messages whenever possible,
        except to communicate with tools. This allows the ToolBus type checker
        to find common mistakes early in the process. Also the trace of
        process calls is more easy to get an overview of than the trace of
        messages and notes, since every process call has a single caller and a
        single callee. Messages on the other hand are send by one message but
        could be received by anybody.</para>
      </section>

      <section>
        <title>Analysis of Results</title>

        <para>The configuration management process of The Meta-Environment is
        not general enough to be easily reusable or extensible. There is still
        a lot of editing in existing source code involved when reusing or
        extending it.</para>

        <para>The focus on reusability and extensibility has introduced
        strains on the ToolBus in terms of efficiency. Specific optimizations
        that help managing large volumes of snd-notes have helped a lot in
        making the systems run more smoothly. There is more to be gained by
        optimizing for large volumes of small messages.</para>
      </section>

      <section>
        <title>Assumptions</title>

        <para>The programmer needs to understand the contracts between tools
        and the ToolBus well in order to handle the management processes of
        the Meta-Environment. These contracts are expressed in the idef files
        for each tool.</para>
      </section>
    </section>

    <section>
      <title>Other Information</title>

      <itemizedlist>
        <listitem>
          <para>The ToolBus uses TCP/IP sockets to implement the connections
          with tools.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="data-layer-view">
    <title>The Data Layer View (DAT)</title>

    <para>The Meta-Environment uses ATerms as pervasive data format to store
    and exchange data. On top of the ATerms, various specialized data formats
    have been defined as shown in figure <link
    linkend="fig-data-layer-view">The data layer view</link>.</para>

    <figure xml:id="fig-data-layer-view">
      <title>The data layer view</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="layer-view.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Element Catalog</title>

      <para><link linkend="def-ADT">ADT</link>, <link
      linkend="def-asfix">AsFix</link>, <link
      linkend="def-aterm">ATerm</link>, <link linkend="def-box">Box</link>,
      <link linkend="def-graph">Graph</link>, <link
      linkend="def-location">Location</link>, <link
      linkend="def-parse-table">Parse table</link>, <link
      linkend="def-summary">Summary</link>.</para>
    </section>

    <section>
      <title>Context Diagram</title>

      <para>None.</para>
    </section>

    <section>
      <title>Variability Guide</title>

      <para>New data formats can be added by writing new data definitions
      (using ADT) and generating the interfaces for these data using
      APIGEN.</para>
    </section>

    <section>
      <title>Architecture Background</title>

      <section>
        <title>Design Rationale</title>

        <para>The fundamental assumption is that tools exchange data in the
        form of ATerms. Since specialized services require specialized data
        formats, it makes sense to build them on top of ATerms.</para>
      </section>

      <section>
        <title>Analysis of Results</title>

        <para>The above data formats have been added out of necessity. It is
        likely that more data format will be added for:</para>

        <itemizedlist>
          <listitem>
            <para>Rstores: (name, relation) pairs as used by Rscript.</para>
          </listitem>

          <listitem>
            <para>Configuration information.</para>
          </listitem>
        </itemizedlist>

        <para>An issue that requires attention is whether the ToolBus should
        be aware of these datatypes. Currently, it just pumps ATerms around,
        but more specialized typing of the tool interfaces would help
        implementors with early error detection.</para>
      </section>

      <section>
        <title>Assumptions</title>

        <para>The assumptions in this view are:</para>

        <itemizedlist>
          <listitem>
            <para>These data format are versatile enough.</para>
          </listitem>

          <listitem>
            <para>The mapping of these data formats is sufficiently
            efficient.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Other information</title>

      <para>None.</para>
    </section>
  </section>

  <section xml:id="package-view">
    <title>The package view (PCK)</title>

    <para>For reasons of modularity, reuse and maintenance, the implementation
    of The Meta-Environment is subdivided in <emphasis>packages</emphasis>. A
    package is the smallest unit of software that can be distributed or
    re-used. Currently, The Meta-Environment provides over 60 packages that
    provide a wide range of functionality. The table <link
    linkend="table-mapping-elements-packages">Mapping between elements and
    packages</link> shows how the architecture elements in the various views
    are implemented by one or more packages. Note that some packages (e.g.,
    aterm, aterm-java, shared-objects, JJTraveler) are used by most package;
    they are not listed in the table.</para>

    <para><table border="1" xml:id="table-mapping-elements-packages">
        <caption>Mapping between elements and packages</caption>

        <tr>
          <td><emphasis role="bold">Element</emphasis></td>

          <td><emphasis role="bold">Implementing packages</emphasis></td>
        </tr>

        <tr>
          <td>APIGEN</td>

          <td>apigen</td>
        </tr>

        <tr>
          <td>ASF checker</td>

          <td>asf</td>
        </tr>

        <tr>
          <td>ASF compiler</td>

          <td>asf, asc-support</td>
        </tr>

        <tr>
          <td>ASF interpreter</td>

          <td>asf</td>
        </tr>

        <tr>
          <td>ASF operations</td>

          <td>asf-support</td>
        </tr>

        <tr>
          <td>ASF+SDF checker</td>

          <td>asf</td>
        </tr>

        <tr>
          <td>ASF+SDF library</td>

          <td>asf-library, sdf-library</td>
        </tr>

        <tr>
          <td>ASF+SDF modules</td>

          <td></td>
        </tr>

        <tr>
          <td>Compiled specification</td>

          <td>asf</td>
        </tr>

        <tr>
          <td>Configuration manager</td>

          <td>config-manager, config-support</td>
        </tr>

        <tr>
          <td>Debugger</td>

          <td>tide, tide-support</td>
        </tr>

        <tr>
          <td>Errors &amp; warnings</td>

          <td>error-gui, error-support</td>
        </tr>

        <tr>
          <td>Graphical user interface (GUI)</td>

          <td>dialog-gui, graph-gui, graph-support, meta-studio,
          module-details-gui, navigator-gui, progress-gui</td>
        </tr>

        <tr>
          <td>Input term</td>

          <td>pt-support</td>
        </tr>

        <tr>
          <td>Module manager</td>

          <td>module-manager, module-support</td>
        </tr>

        <tr>
          <td>Output term</td>

          <td>pt-support, pandora</td>
        </tr>

        <tr>
          <td>Parse table generator</td>

          <td>pgen</td>
        </tr>

        <tr>
          <td>Parse table</td>

          <td>pgen</td>
        </tr>

        <tr>
          <td>Parser</td>

          <td>sglr</td>
        </tr>

        <tr>
          <td>Parse tree</td>

          <td>pt-support</td>
        </tr>

        <tr>
          <td>Prettyprinter</td>

          <td>pandora</td>
        </tr>

        <tr>
          <td>SDF checker</td>

          <td>pgen</td>
        </tr>

        <tr>
          <td>SDF operations</td>

          <td>sdf-support</td>
        </tr>

        <tr>
          <td>Structure editor</td>

          <td>structure-editor</td>
        </tr>

        <tr>
          <td>Text editor</td>

          <td>editor-manager,editor-plugin</td>
        </tr>

        <tr>
          <td>Term store</td>

          <td>term-store, io-support</td>
        </tr>

        <tr>
          <td>The Meta-Environment</td>

          <td>asfsdf-meta, sdf-meta, meta</td>
        </tr>

        <tr>
          <td>ToolBus</td>

          <td>toolbus, toolbuslib, toolbus-java-adapter</td>
        </tr>
      </table></para>

    <section>
      <title>Element Catalog</title>

      <para>All architecture elements and nearly all packages appear in this
      view.</para>
    </section>

    <section>
      <title>Context Diagram</title>

      <para>None.</para>
    </section>

    <section>
      <title>Variability Guide</title>

      <para>The following variability issues have been identified.</para>

      <itemizedlist>
        <listitem>
          <para>All packages have been written with portability in
          mind.</para>
        </listitem>

        <listitem>
          <para>We use configuration tools (autoconf) to adjust packages to
          local installation requirements.</para>
        </listitem>

        <listitem>
          <para>All software development has been done on Linux. However, the
          majority (but certainly not all) of the packages have been compiled
          successfully on Windows as well.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Architecture Background</title>

      <section>
        <title>Design Rationale</title>

        <para>The reasons for splitting up the system in so many packages is
        the following:</para>

        <itemizedlist>
          <listitem>
            <para>Each package represents a clearly defined functionality.
            This localizes the impact of future modifications.</para>
          </listitem>

          <listitem>
            <para>Each package can be reused independently.</para>
          </listitem>

          <listitem>
            <para>The package structure makes explicit dependencies between
            packages mandatory. This makes it easier to study the impact of
            more global changes.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Analysis of Results</title>

        <para>On the positive side, we do have achieved an incredibly modular
        and flexible architecture. On the negative side, we do have to admit
        the following:</para>

        <itemizedlist>
          <listitem>
            <para>Although "all packages are considered equal" in our
            approach, in reality this is not the true. A handful of primary
            packages (asfsdf-meta, aterm, pandora, pgen, sglr, shared-objects,
            toolbus) are frequently downloaded and reused in a variety of
            applications, the others are just implementation details for those
            primary packages.</para>
          </listitem>

          <listitem>
            <para>Initially, we exposed the flat list of all our packages to
            the outside world. This turned out the be very confusing.</para>
          </listitem>

          <listitem>
            <para>In some cases, a more monolithic structure for subcomponents
            would make the life of implementors somewhat easier.</para>
          </listitem>

          <listitem>
            <para>There are some costs involved in creating and maintaining a
            new package. We are therefore continuously simplifying and
            optimizing our build environment to reduce these costs.</para>
          </listitem>
        </itemizedlist>

        <para>Despite these critical notes, we do think that the overall
        package approach is highly effective.</para>
      </section>

      <section>
        <title>Assumptions</title>

        <para>We have made the following assumptions that are mostly hardwired
        in this architecture:</para>

        <itemizedlist>
          <listitem>
            <para>Most packages can read/write data in the form of ATerms or
            any of the dataformats built on top of ATerms.</para>
          </listitem>

          <listitem>
            <para>Most packages provide their functionality in three
            forms;</para>

            <itemizedlist>
              <listitem>
                <para>As command line tools.</para>
              </listitem>

              <listitem>
                <para>As a library that can be called from other
                programs.</para>
              </listitem>

              <listitem>
                <para>As a ToolBus tool that can be connected to a
                ToolBus-based system.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <section xml:id="package-dependency-view">
    <title>The Package Dependency View (DEP)</title>

    <para>The dependencies between the packages of the Meta-Environment are
    shown in figure <link linkend="fig-package-dependency-view">The package
    dependency view</link>. Clearly, four separate layers can be distinguished
    (from bottom to top):</para>

    <itemizedlist>
      <listitem>
        <para>The <emphasis>infrastructure layer</emphasis> that provides
        common facilities.</para>
      </listitem>

      <listitem>
        <para>The <emphasis>kernel layer</emphasis> that provides a kernel
        meta-environment.</para>
      </listitem>

      <listitem>
        <para>The <emphasis>SDF layer</emphasis> that provides a
        meta-environment for editing SDF specifications.</para>
      </listitem>

      <listitem>
        <para>The <emphasis>ASF layer</emphasis> that provides the full
        ASF+SDF Meta-Environment.</para>
      </listitem>
    </itemizedlist>

    <para>In order to reduce the visual clutter in this figure, various
    simplifications have been applied:</para>

    <itemizedlist>
      <listitem>
        <para>All uses by elements in the top layers of facilities in the
        bottom layer are summarized by one arrow: "may use any of".</para>
      </listitem>

      <listitem>
        <para>An element uses all other elements to which it is directly or
        indirectly connected.</para>
      </listitem>
    </itemizedlist>

    <figure xml:id="fig-package-dependency-view">
      <title>The package dependency view</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="package-dependencies.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Element Catalog</title>

      <para>All packages.</para>
    </section>

    <section>
      <title>Context Diagram</title>

      <para>None.</para>
    </section>

    <section>
      <title>Variability Guide</title>

      <para>This package structure has been designed to accommodate
      variability; it enables arbitrary combinations of packages. This
      variability can be achieved by building new packages that depend on
      combinations of existing packages.</para>
    </section>

    <section>
      <title>Architecture Background</title>

      <section>
        <title>Design Rationale</title>

        <para>The design rationale for this package structure is the
        following:</para>

        <itemizedlist>
          <listitem>
            <para>We come from a situation in which many packages had
            dependencies on ASF+SDF. We considered this undesirable, from the
            perspective of modifiability and extensibility.</para>
          </listitem>

          <listitem>
            <para>By organizing the package dependencies in layers, we achieve
            an architecture that can be easily extended. Starting with a
            widely used infrastructure layer, we first provide a kernel
            meta-environment that has a user-interface and basic editing
            facilities. Next, we add an SDF layer that provides syntax
            definitions via SDF, parser generation and parsing. Finally, we
            add ASF to provide semantic definitions and term rewriting.</para>
          </listitem>

          <listitem>
            <para>Each of these layers can form the starting point for the
            implementation of systems with widely varying
            functionality.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Analysis of Results</title>

        <para>The fact that various "clones" of the Meta-Environment exist
        proves the success of this approach.</para>
      </section>

      <section>
        <title>Assumptions</title>

        <itemizedlist>
          <listitem>
            <para>The primary program representation is the parse tree (using
            AsFix). This assumptions is becoming more and more true in the
            context of software analysis, program transformation and software
            renovation. However, in the context of ordinary compilation this
            maybe overkill and lead to inefficiencies.</para>
          </listitem>

          <listitem>
            <para>All packages need to use the same build interface in order
            to cooperate in this package structure.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Further information</title>

      <para>For the record, there are some issues that should be resolved in
      this view:</para>

      <itemizedlist>
        <listitem>
          <para>Only the dependency on graphviz is made explicit in the
          package definitions.</para>
        </listitem>

        <listitem>
          <para>The mutual dependency between tide and meta-studio is curious
          and should be investigated.</para>
        </listitem>

        <listitem>
          <para>It is a pity that there are still dependencies between the
          "meta" layer and asc-support. This means that not yet all ASF
          dependencies have been cut out of the kernel
          meta-environment.</para>
        </listitem>
      </itemizedlist>

      <para>Running The Meta-Environment is currently dependent on the
      following external packages:</para>

      <itemizedlist>
        <listitem>
          <para><link xlink:href="http://www.graphviz.org">Graphviz</link> for
          graph layout algorithms.</para>
        </listitem>

        <listitem>
          <para><link xlink:href="http://prefuse.org">Prefuse</link> for graph
          visualization.</para>
        </listitem>

        <listitem>
          <para><link xlink:href="http://www.infonode.net">Infonode</link> for
          docking windows.</para>
        </listitem>

        <listitem>
          <para><link xlink:href="http://www.gnu.org">GCC</link> the GNU C
          compiler.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="power-user-view">
    <title>The Power-User View (PWR)</title>

    <para>Power-users can use the system in four ways:</para>

    <itemizedlist>
      <listitem>
        <para>By using the GUI.</para>
      </listitem>

      <listitem>
        <para>By using some of the commands.</para>
      </listitem>

      <listitem>
        <para>By writing programs and using the provided libraries.</para>
      </listitem>

      <listitem>
        <para>By modifying or extending the standard ToolBus scripts that are
        provided.</para>
      </listitem>
    </itemizedlist>

    <para>In advanced applications all three ways will play a role. This can
    be used to implement completely tailored Meta-Environments.</para>

    <para>The relevant information is shown in the two tables <link
    linkend="table-main-commands">Main commands</link> and <link
    linkend="table-all-commands-libraries">All commands and libraries per
    package</link>.</para>

    <para>The power-user is also confronted with the various data formats that
    are used: ATerms, AsFix, Parse tables</para>

    <para><table xml:id="table-main-commands">
        <title>Main commands</title>

        <tgroup cols="3">
          <tbody>
            <row>
              <entry><emphasis role="bold">Command</emphasis></entry>

              <entry><emphasis role="bold">Inputs</emphasis></entry>

              <entry><emphasis role="bold">Output</emphasis></entry>
            </row>

            <row>
              <entry>pt-dump</entry>

              <entry>Module name (String)</entry>

              <entry>Parse table (ATerm)</entry>
            </row>

            <row>
              <entry>sdf2table</entry>

              <entry>SDF definition</entry>

              <entry>Parse table (ATerm)</entry>
            </row>

            <row>
              <entry>eqs-dump</entry>

              <entry>Module name (String)</entry>

              <entry>Equations (AsFix)</entry>
            </row>

            <row>
              <entry>asfe</entry>

              <entry>Equations (AsFix)</entry>

              <entry>Parse tree (AsFix)</entry>
            </row>

            <row>
              <entry>asf2c</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>sglr</entry>

              <entry>Parse table (ATerm), String</entry>

              <entry>Parse tree (AsFix)</entry>
            </row>

            <row>
              <entry>unparsePT</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>apply-function</entry>

              <entry>Function name (String), Sort name (String), Module name
              (String), Term (AsFix)</entry>

              <entry>Term (AsFix)</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <table xml:id="table-all-commands-libraries">
      <title>All commands and libraries per package</title>

      <tgroup cols="5">
        <tbody>
          <row>
            <entry><emphasis role="bold">Package</emphasis></entry>

            <entry><emphasis role="bold">Summary</emphasis></entry>

            <entry><emphasis role="bold">Commands</emphasis></entry>

            <entry><emphasis role="bold">Libraries</emphasis></entry>

            <entry><emphasis role="bold">C includes (C), Tscript (T), ASF+SDF
            (ASF), Abstract Data Type (ADT)</emphasis></entry>
          </row>

          <row>
            <entry>apigen</entry>

            <entry>API generator for C and Java</entry>

            <entry></entry>

            <entry></entry>

            <entry></entry>
          </row>

          <row>
            <entry>asc-support</entry>

            <entry>Run-time library used by compiled ASF+SDF
            specifications.</entry>

            <entry></entry>

            <entry>libasc-support-me.a</entry>

            <entry>C</entry>
          </row>

          <row>
            <entry>asf</entry>

            <entry>All tools for implementing ASF</entry>

            <entry>ASFSDFApigen addeqssyntax asfc asfchecker asfe
            asfoperations asfsdfchecker concat-asf lift-asf</entry>

            <entry></entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>asf-library</entry>

            <entry>Source library of ASF+SDF definitions</entry>

            <entry></entry>

            <entry></entry>

            <entry>ASF</entry>
          </row>

          <row>
            <entry>asf-support</entry>

            <entry>Support libraries for ASF tools</entry>

            <entry></entry>

            <entry>libASFME.a</entry>

            <entry>C</entry>
          </row>

          <row>
            <entry>asfsdf-meta</entry>

            <entry>The ASF+SDF Meta-Environment</entry>

            <entry>asfsdf-meta eqs-dump</entry>

            <entry></entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>aterm</entry>

            <entry>ATerm library and supporting tools</entry>

            <entry>atdiff atrmannos atsum baf2taf baf2trm baflle dicttoc
            taf2baf taf2trm termsize trm2baf trm2taf trmcat</entry>

            <entry>libATerm</entry>

            <entry>C</entry>
          </row>

          <row>
            <entry>aterm-java</entry>

            <entry>Java version of ATerm library</entry>

            <entry></entry>

            <entry>aterm-1.6.jar</entry>

            <entry></entry>
          </row>

          <row>
            <entry>config-manager</entry>

            <entry>Configuration manager</entry>

            <entry>configmanager</entry>

            <entry></entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>config-support</entry>

            <entry>Support library for configuration manager</entry>

            <entry></entry>

            <entry>libConfigAPI.a, configapi.jar</entry>

            <entry>C</entry>
          </row>

          <row>
            <entry>dialog-gui</entry>

            <entry>GUI component for dialogs</entry>

            <entry></entry>

            <entry>dialog.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>editor-manager</entry>

            <entry>Editor manager supervises concurrent editing
            sesssions</entry>

            <entry>editor-manager</entry>

            <entry>libEditorManager.a</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>editor-plugin</entry>

            <entry>Java embeddable editor component</entry>

            <entry></entry>

            <entry>editor-plugin-1.0.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>error-gui</entry>

            <entry>GUI components for error display</entry>

            <entry></entry>

            <entry>error-viewer-1.0.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>error-support</entry>

            <entry>Tools for handling errors (Summaries)</entry>

            <entry>error-diff error-support lift-error lower-error</entry>

            <entry>libErrorAPI.a libLocationAPI.a errorapi.jar
            locationapi.jar</entry>

            <entry>C,T</entry>
          </row>

          <row>
            <entry>graph-gui</entry>

            <entry>GUI component for graph display</entry>

            <entry></entry>

            <entry>graph-painter.jar prefuse.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>graph-support</entry>

            <entry>Tools for handling graphs</entry>

            <entry>graph2dot layoutgraph tree2graph</entry>

            <entry>libGraph.a graph-0.2.jar</entry>

            <entry>C, T, ADT</entry>
          </row>

          <row>
            <entry>io-support</entry>

            <entry>ToolBus tool for file i/o.</entry>

            <entry>in-output</entry>

            <entry>libIOAPI.a ioapi.jar</entry>

            <entry>C, T, ADT</entry>
          </row>

          <row>
            <entry>meta</entry>

            <entry>Bare Meta-Environment</entry>

            <entry></entry>

            <entry></entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>meta-autotools</entry>

            <entry></entry>

            <entry></entry>

            <entry></entry>

            <entry></entry>
          </row>

          <row>
            <entry>meta-build-env</entry>

            <entry></entry>

            <entry></entry>

            <entry></entry>

            <entry></entry>
          </row>

          <row>
            <entry>meta-studio</entry>

            <entry>Main GUI component</entry>

            <entry>gui</entry>

            <entry>gui-util.jar gui.jar idw-gpl-1.4.0.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>module-details-gui</entry>

            <entry>GUI component for display detailed info about
            modules</entry>

            <entry></entry>

            <entry>moduledetails.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>module-manager</entry>

            <entry>Manages a collection of modules</entry>

            <entry>module-manager</entry>

            <entry>module-manager-1.0.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>module-support</entry>

            <entry>Tools for handling modules</entry>

            <entry></entry>

            <entry>moduleapi.jar</entry>

            <entry></entry>
          </row>

          <row>
            <entry>navigator-gui</entry>

            <entry>GUI components for navigating through module
            hierarchy</entry>

            <entry></entry>

            <entry>navigator.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>pandora</entry>

            <entry>Generic prettyprinter</entry>

            <entry>pandora</entry>

            <entry></entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>pgen</entry>

            <entry>Parse table generator</entry>

            <entry>parse-sdf2 parsetablegen removevarsyntax sdf2table
            sdfchecker</entry>

            <entry></entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>progress-gui</entry>

            <entry>GUI component that display progress of an operation</entry>

            <entry></entry>

            <entry>progress.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>pt-support</entry>

            <entry>Support libraries for parse trees</entry>

            <entry>addPosInfo ambtracker apply-function comparePT flattenPT
            implodePT liftPT unparsePT unparseProd</entry>

            <entry>libPTMEPT.a libmept.a</entry>

            <entry>C, T</entry>
          </row>

          <row>
            <entry>sdf-library</entry>

            <entry>Source library of SDF definitions</entry>

            <entry></entry>

            <entry></entry>

            <entry>ASF</entry>
          </row>

          <row>
            <entry>sdf-meta</entry>

            <entry>An SDF-only Meta-Environment</entry>

            <entry>def-dump pt-dump sdf-meta</entry>

            <entry></entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>sdf-support</entry>

            <entry>Support libraries for handling SDF definitions</entry>

            <entry>sdf-modules sdf-renaming</entry>

            <entry>libPT2SDF.a libSDF2PT.a libSDFME.a</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>sglr</entry>

            <entry>SGLR parser</entry>

            <entry>dump-actions dump-gotos dump-priorities dump-productions
            restorebrackets sglr</entry>

            <entry>libsglr.a</entry>

            <entry>C, T</entry>
          </row>

          <row>
            <entry>shared-objects</entry>

            <entry>Library for maxiamlly shared objects in Java</entry>

            <entry></entry>

            <entry>shared-objects-1.4.jar</entry>

            <entry></entry>
          </row>

          <row>
            <entry>structure-editor</entry>

            <entry>Tools for syntax-directed editing</entry>

            <entry>structure-editor</entry>

            <entry>libStructureEditor.a</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>term-store</entry>

            <entry>Generic store for terms</entry>

            <entry>term-store</entry>

            <entry></entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>tide</entry>

            <entry>Generic debug framework</entry>

            <entry>tide tide-gdb</entry>

            <entry>tide.jar</entry>

            <entry>T</entry>
          </row>

          <row>
            <entry>tide-support</entry>

            <entry>Tools for connecting C-based tools to tide</entry>

            <entry></entry>

            <entry>libtide-adapter.a</entry>

            <entry>C, T</entry>
          </row>

          <row>
            <entry>toolbus</entry>

            <entry>ToolBus coordination architecture</entry>

            <entry>bc-adapter emacs-adapter idef2tif merge-tifs start-emacs
            tblog toolbus uri-encode ctif gen-adapter informer perl-adapter
            tbgraph tifstoc toolbus-adapter wish-adapter</entry>

            <entry></entry>

            <entry>C</entry>
          </row>

          <row>
            <entry>toolbus-java-adapter</entry>

            <entry>Adapter for coupling of Java to ToolBus</entry>

            <entry>java-adapter tifstojava</entry>

            <entry>toolbus-java-adapter-1.0.jar</entry>

            <entry></entry>
          </row>

          <row>
            <entry>toolbuslib</entry>

            <entry>Library for C-based ToolBus tools</entry>

            <entry>tbunpack</entry>

            <entry>libATB.a</entry>

            <entry>C</entry>
          </row>

          <row>
            <entry>JJTraveler</entry>

            <entry>Traversal pattern in Java.</entry>

            <entry></entry>

            <entry>jjtraveler-0.5.jar</entry>

            <entry></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section>
      <title>Element catalog</title>

      <para>This view shows all packages and some of their most important
      contents.</para>
    </section>

    <section>
      <title>Context diagram</title>

      <para>None.</para>
    </section>

    <section>
      <title>Variability guide</title>

      <para>See <link linkend="package-dependency-view">Package Dependency
      View</link>.</para>
    </section>

    <section>
      <title>Architecture background</title>

      <para>See <link linkend="package-dependency-view">Package Dependency
      View</link>.</para>
    </section>

    <section>
      <title>Other information</title>

      <para>Also see Extension Points for The Meta-Environment and Build
      Environment for The Meta-Environment. <remark>(Add
      Links).</remark></para>
    </section>
  </section>

  <section xml:id="ToDo">
    <title>To Do</title>

    <itemizedlist>
      <listitem>
        <para><remark>Remove all remarks from the text.</remark></para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>