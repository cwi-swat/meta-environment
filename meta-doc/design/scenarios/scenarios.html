<HTML>
<HEAD>
<TITLE>Scenarios</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Scenarios</H1>
Here we describe a number of scenarios on which the design and therefore
the implementation of the new Meta-environment is based. Each scenario
describes a list of actions that is performed to complete a certain
task. These actions are informal descriptions of a subtask, which 
in turn can be scenarios themselves.

The sole purpose of these scenarios is to develop an understanding for
the interaction between the different components, and their responsibilities.

Sofar, we have developed scenarios for the following tasks:
<UL>
<LI> <A HREF="#ParsingTerms">Scenario for Parsing Terms</A>
<LI> <A HREF="#ParserGenerator">Scenario for Generating Parse Tables</A>
<LI> <A HREF="#GetSyntaxRules">Scenarios for Retrieving the Syntax Rules</A>
</UL>

<A NAME="ParsingTerms">
<H2>Scenario for Parsing Terms</H2>
</A>

Given that a user wants to parse a unparsed term over a certain module.
We assume that at least this module and all modules imported by this
module are in the module database.

<OL>
<LI> After indication by the user, the <EM>term editor</EM>
generates a parse request.
This parse request contains the complete text of this term,
a unique identification of the term, and the name of
the module over which the text has to be parsed.
<LI> The <EM>parser</EM> intercepts this request and checks whether it
has a valid parse table for this module.
If the parse table is not available, see <A href="#ParserGenerator">scenario for
generating parse tables</A>.
<LI> Given the parse table the text is parse and either
an error message is generated or a parse tree is constructed.
<LI> A parse result containing the unique identification of the term and
either the error message or the constructed parse tree is generated.
<LI> The term editor intercepts this parse result.
If the user has edited the text in the meantime this parse result is ignored
by the editor. 
Otherwise if the parse result contains an error message
this is presented to the user. If the parse result contains
a parse tree the editor switches to 'structure editing mode'.
</OL>

<A NAME="ParserGenerator">
<H2>Scenario for Generating Parse Tables</H2>
</A>

Given that the parser wants a parse table to be generated for a certain module.
We assume that at least this module and all modules imported by this
module are in the module database.

<OL>
<LI> If the parse table for some module is not available
the <EM>parser</EM> generates a build parse-table request.
This build parse-table request contains the name of
the module for which the parse-table has to be build.
<LI> The <EM>parser generator</EM> intercepts this request.
<LI> Given the module name in the build parse-table request,
the parser generator generates a get-syntax request, for obtaining the
all relevant syntax for this module and its transitive closure.
The module database must provide the requested syntax definitions,
see <A href="#GetSyntaxRules">scenario for retrieving the syntax rules</A>.
<LI> Given the list of syntax rules (consisting of
lexical syntax, context-free syntax, and priority rules) parser generator can
generate the requested parse table. A parse table ready messge will be 
generated by the parser generator, containing the module name and the
corresponding parse table.
</OL>
An alternative scenario could be that given the module name the top module
is identified and the parse table is generated for this top module.
The generated parse table must then contain information which transitions
are valid for each specific module. This will reduce the number of tables
considerably.

<A NAME="GetSyntaxRules">
<H2>Scenarios for Retrieving the Syntax Rules</H2>
</A>

Given that some component wants to retrieve the syntax definitions
based on a given top module. We assume that at least this module and
all modules imported by this module are in the module database.
<OL>
<LI> The module database intercepts a request for the complete set of
     syntax definitions for a given top module. The request contains
     the name of the top module.
<LI> The module database determines the transitive closure of the
     set of modules imported by the top module.
<LI> The module database retrieves all public syntax sections 
     of all modules in this set, together with the hidden syntax sections
     in the top module and combines them in one large set of syntax 
     definitions.
<LI> The resulting set of definitions is returned to the component that
     originally requested the syntax definitions.
</OL>

</BODY>
</HTML>
