<!--

    Meta-Environment - An environment for language prototyping.
    Copyright (C) 2000  Stichting Mathematisch Centrum, Amsterdam, The Netherlands. 

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

-->
<HTML>
<HEAD>
<TITLE>Features offered by the new Asf+Sdf Meta-Environment</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Features offered by the new Asf+Sdf Meta-Environment</H1>
An Asf+Sdf specification consists of a set of modules.
Each modules consists of a syntax definition part (Sdf) and
an equation part (Asf).
The syntax defined in Sdf is used to parse the equations in the Asf part.
Modules can import each other. This implies that syntax defined in
imported modules can be used in the equations of the importing module.

<P> The user interface of the Meta-Environment is based on two components:
<UL>
<LI> A syntax directed editor that can be used to edit both modules
and terms over the specified language(s).
These terms can be evaluated by interpreting the equations in the
specification as rewrite rules.
<LI> A central control tool
that gives an overview of the specifications at the module level.
This control tool allows the user to load and save specifications,
add and delete modules, typeset specifications in TeX or HTML,
and controls the creation of new editors instances. 
</UL>

<A NAME="control-tool">
<H2>Control Tool</H2>

<!-- In the current prototype, the control tool looks something like this:
&lt;IMG SRC="control.gif"&gt; -->
The current prototype shows an overview of the module import graph, giving
a good impression of the internal structure of the specification.
A number of buttons and menu items give access to the functionality
of the tool.
The control tool must provide the following functionality:
<UL>
<LI> Load a module and all its submodules.
<LI> Show the import relation between the currently loaded modules.
<LI> Show a list of all currently loaded modules.
<LI> Save changes in a specific module.
<LI> Save all elements that have been changed since the last 
     save operations, be it modules or terms.
<LI> Remove a module from the Meta-Environment, even if some
     other module still depends on this module. Modules that are now
     no longer in working order, should be 'greyed out' somehow.
<LI> Inspect and change the list of search-paths in which the Meta-Environment
     searches for new modules.
<LI> Set and/or change the directory in which the compiler writes the
     generated C programs.
<LI> Create new module and term editors.
<LI> Show a list of currently active module editors and term editors,
     and enable the user to activate (bring them to the front) and
     remove them.
<LI> Quit the Meta-Environment.
</UL>

<H3>Extensibility</H3>
In the future, we can imagine all kinds of other operations on modules
or even whole specifications. Examples include queries on specifications
to select all modules using a specific function, calculating some
complexity metrics to find possible weak spots in a specification, or 
restructure specifications based on some clustering results.
These kind of extensions can be implemented in separate tools, but the
user interface extension needed to access this new functionality must
be added to the existing user interface. In order to do this, the
control tool must provide a way to add user interface items like
buttons and menu items, from within the controlling ToolBus script.
This allows tools to add new functionality <EM>at runtime!</EM>

<A NAME="hybrid-editor">
<H2>Hybrid Editor</H2>

<!--The structure editor currently looks like this:
&lt;IMG SRC="structedit.gif"&gt; -->
The hybrid editor must provide the following functionality:
<UL>
<LI> Editing of both modules and terms.
<LI> Provide a 'structure editing mode' and a 'text editing' mode.
     In text editing mode, the editor will provide all the usual
     operations like cut/copy/paste, search and replace, etc.
     In structure editing mode, the user can perform operations on
     subtrees of the term/module. Typical operations include:
     <UL> 
     <LI> Show the sort of the current subtree (focus).
     <LI> Provide a notion of placeholders, which represent
          a hole in the tree.
     <LI> Replace the current subtree with another subtree of the same
          sort, for instance with a placeholder.
     <LI> Replace a placeholder with a context-free function
          optionally containing new placeholders, to build a term
          using template expansion.
     </UL> 
<LI> The user must be able to switch from 'structure editing mode'
     to 'text editing mode' by starting to type text.
<LI> To switch from 'text editing mode' to 'structure editing mode',
     the text in the editor must be parsed.
<LI> When editing a term, the user must be able to rewrite the term 
     currently in the editor.
</UL>

<H3>Extensibility</H3>
Just like the control tool, the structure editor needs an extensible
user interface to allow flexible addition of new functionality.
In this way, typecheckers, compilers, and other tools can be connected
to the user interface when they become available.
It should provide facilities to combine results of the evaluation
of different terms.

