%%% $Id$

definition

module Main
imports Sdf2-Syntax
exports
  lexical syntax
    "LAYOUT"            -> Sort    {reject}

  context-free syntax
    "aliases"           -> UQLiteral {reject}
    "lexical"           -> UQLiteral {reject}
    "priorities"        -> UQLiteral {reject}
    "context-free"      -> UQLiteral {reject}
    "definition"        -> UQLiteral {reject}
    "syntax"            -> UQLiteral {reject}
    "variables"         -> UQLiteral {reject}
    "module"            -> UQLiteral {reject}
    "exports"           -> UQLiteral {reject}
    "hiddens"           -> UQLiteral {reject}
    "imports"           -> UQLiteral {reject}
    "left"              -> UQLiteral {reject}
    "right"             -> UQLiteral {reject}
    "assoc"             -> UQLiteral {reject}
    "non-assoc"         -> UQLiteral {reject}
    "bracket"           -> UQLiteral {reject}
    "sorts"             -> UQLiteral {reject}
    "restrictions"      -> UQLiteral {reject}
    "constructor"       -> UQLiteral {reject}
    "memo"              -> UQLiteral {reject}
    "traverse"          -> UQLiteral {reject}

    "aliases"           -> ModuleName {reject}
    "lexical"           -> ModuleName {reject}
    "priorities"        -> ModuleName {reject}
    "context-free"      -> ModuleName {reject}
    "definition"        -> ModuleName {reject}
    "syntax"            -> ModuleName {reject}
    "variables"         -> ModuleName {reject}
    "module"            -> ModuleName {reject}
    "exports"           -> ModuleName {reject}
    "hiddens"           -> ModuleName {reject}
    "imports"           -> ModuleName {reject}
    "left"              -> ModuleName {reject}
    "right"             -> ModuleName {reject}
    "assoc"             -> ModuleName {reject}
    "non-assoc"         -> ModuleName {reject}
    "bracket"           -> ModuleName {reject}
    "sorts"             -> ModuleName {reject}
    "bracket"           -> ModuleName {reject}
    "sorts"             -> ModuleName {reject}
    "restrictions"      -> ModuleName {reject}
    "constructor"       -> ModuleName {reject}
    "memo"              -> ModuleName {reject}
    "traverse"          -> ModuleName {reject}
    Literal "(" {Symbol ","}* ")" -> Symbols {reject}
  restrictions
    <Sort -CF>
    <UQLiteral -CF>
    "aliases"
    "lexical"
    "priorities"
    "context-free"
    "definition"
    "syntax"
    "variables"
    "module"
    "exports"
    "hiddens"
    "imports"
    "left"
    "right"
    "assoc"
    "non-assoc"
    "bracket"
    "sorts"             -/- [A-Za-z0-9]
    <NatCon -CF>        -/- [0-9]
    <LAYOUT?-CF>        -/- [\ \t\n\%]
    <NumChar -CF>       -/- [0-9]
    <ModuleName -CF>    -/- [A-Za-z0-9\_\-]

module Sdf2-Syntax
imports Kernel-Sdf-Syntax
        Basic-Sdf-Syntax
        Modular-Sdf-Syntax
        Regular-Sdf-Syntax
        Priority-Sdf-Syntax
        CC-Sdf-Syntax
        Sorts-Sdf-Syntax
        Literals-Sdf-Syntax
        Label-Sdf-Syntax
        Restrictions-Sdf-Syntax
        Alias-Sdf-Syntax
exports
  sorts SDF
  context-free syntax
    "<START>"                                   -> Symbol	{cons("start")}
    "<Start>"                                   -> Symbol	{cons("file-start")}
    "lexical"      "priorities" Priorities      -> Grammar	{cons("lexical-priorities")}
    "context-free" "priorities" Priorities      -> Grammar	{cons("context-free-priorities")}
    "lexical"      "restrictions" Restrictions  -> Grammar	{cons("lexical-restrictions")}
    "context-free" "restrictions" Restrictions  -> Grammar	{cons("context-free-restrictions")}
    "definition" Definition                     -> SDF		{cons("definition")}
  context-free priorities
    Symbol "|" Symbol  -> Symbol >
    Literal ":" Symbol -> Symbol

module Kernel-Sdf-Syntax
imports Symbols Grammar-Syntax
exports
  sorts Attribute Attributes Production Productions
  context-free syntax
    "{" list:{Attribute ","}* "}"         -> Attributes     {cons("attrs")}
                                          -> Attributes     {cons("no-attrs")}
    Symbols "->" result:Symbol Attributes -> Production     {cons("prod")}
    list:Production*                      -> Productions
    "syntax" Productions                  -> Grammar        {cons("syntax")}

module Basic-Sdf-Syntax
imports Kernel-Sdf-Syntax
exports
  context-free syntax
    "lexical" "syntax"      Productions -> Grammar		{cons("lexical-syntax")}
    "context-free" "syntax" Productions -> Grammar		{cons("context-free-syntax")}
    "variables"             Productions -> Grammar		{cons("variables")}
    "lexical" "variables"   Productions -> Grammar		{cons("lexical-variables")}

    "<" Symbol "-CF"  ">"               -> Symbol		{cons("cf")}
    "<" Symbol "-LEX" ">"               -> Symbol		{cons("lex")}
    "<" Symbol "-VAR" ">"               -> Symbol		{cons("varsym")}

    "LAYOUT"                            -> Symbol		{cons("layout")}

module Modular-Sdf-Syntax
imports Kernel-Sdf-Syntax Renaming-Sdf-Syntax
exports
  sorts ModuleId ModuleName Import Imports
        Section Sections Module Definition ImpSection
  lexical syntax
    [A-Za-z0-9\_\-]+        -> ModuleWord			{cons("word")}
    ModuleWord              -> ModuleId				{cons("word")}
    "/" ModuleId            -> ModuleId				{cons("slash-word")}
    ModuleWord "/" ModuleId -> ModuleId				{cons("word-slash-word")} 
  context-free syntax
    list:Module*                 -> Definition	
    "module" ModuleName list:ImpSection* Sections -> Module		{cons("module")}
    "exports" Grammar            -> Section			{cons("exports")}
    "hiddens" Grammar            -> Section			{cons("hiddens")}
    list:Section*                -> Sections
    ModuleId                     -> ModuleName			{cons("unparameterized")}
    ModuleId "[" params:Symbols "]"     -> ModuleName		{cons("parameterized")}
    "id" "(" ModuleName ")"      -> Attribute			{cons("id")}
    "imports" list:Imports       -> ImpSection			{cons("imports")}
    ImpSection                   -> Grammar			{cons("imp-section")}
    list:Import*                 -> Imports			
    ModuleName                   -> Import			{cons("module")}
    ModuleName Renamings         -> Import			{cons("renamed-module")}
    "(" Import ")"               -> Import {bracket}

module Regular-Sdf-Syntax
imports Kernel-Sdf-Syntax IntCon
exports
  context-free syntax
    "(" ")"                          -> Symbol			{cons("empty")}
    "(" head:Symbol tail:Symbol+ ")" -> Symbol			{cons("seq")}
    Symbol "?"                       -> Symbol			{cons("opt")}
    Symbol "+"                       -> Symbol			{cons("iter")}
    Symbol "*"                       -> Symbol			{cons("iter-star")}
    "{" Symbol sep:Symbol "}" "+"    -> Symbol			{cons("iter-sep")}
    "{" Symbol sep:Symbol "}" "*"    -> Symbol			{cons("iter-star-sep")}
    Symbol  n:NatCon "+"             -> Symbol			{cons("iter-n")}
    "{" Symbol sep:Symbol "}" n:NatCon "+" -> Symbol		{cons("iter-sep-n")}
    "Set" "[" Symbol "]"             -> Symbol			{cons("set")}
    "left":Symbol "#" "right":Symbol -> Symbol 			{right,cons("pair")}
    "(" arguments:Symbols "=>" results:Symbol ")"  -> Symbol	{cons("func")}
    "left":Symbol "|" "right":Symbol -> Symbol 			{right,cons("alt")}
    "<<" Symbols ">>"                -> Symbol			{cons("perm")}
  context-free priorities
    {Symbol "?"               -> Symbol
    Symbol "*"                -> Symbol
    Symbol "+"                -> Symbol
    Symbol NatCon "+"         -> Symbol} >
    Symbol "#" Symbol         -> Symbol  >
    Symbol "|" Symbol         -> Symbol

module Priority-Sdf-Syntax
imports Kernel-Sdf-Syntax
exports
  sorts Associativity Group Priority Priorities
  context-free syntax
    "left"                                    -> Associativity  {cons("left")}
    "right"                                   -> Associativity  {cons("right")}
    "non-assoc"                               -> Associativity  {cons("non-assoc")}
    "assoc"                                   -> Associativity  {cons("assoc")}
    "bracket"                                 -> Attribute      {cons("bracket")}
    Associativity                             -> Attribute      {cons("atr")}
    Production                                -> Group          {cons("simple-group")}
    "{" Productions "}"                       -> Group          {cons("prods-group")}
    "{" Associativity ":" Productions "}"     -> Group          {cons("assoc-group")}
    list:{Group ">"}+                         -> Priority       {cons("chain")}
    "left":Group Associativity "right":Group  -> Priority       {cons("assoc")}
    list:{Priority  ","}*                     -> Priorities
    "priorities" Priorities                   -> Grammar        {cons("priorities")}

module CC-Sdf-Syntax
imports Character-Class-Syntax Kernel-Sdf-Syntax
exports
  context-free syntax
    CharClass -> Symbol						{cons("char-class")}

module Sorts-Sdf-Syntax
imports Kernel-Sdf-Syntax
exports
  sorts Sort
  lexical syntax
    [A-Z]                          -> Sort			{cons("one-char")}
    [A-Z][A-Za-z0-9\-]*[A-Za-z0-9] -> Sort			{cons("more-chars")}
  context-free syntax
    Sort             -> Symbol					{cons("sort")}
    "sorts" Symbols  -> Grammar					{cons("sorts")}

module Literals-Sdf-Syntax
imports Kernel-Sdf-Syntax Literals
exports
  sorts UQLiteral
  lexical syntax
    [a-z]                          -> UQLiteral {cons("one-char")}
    [a-z][A-Za-z0-9\-]*[A-Za-z0-9] -> UQLiteral {cons("more-chars")}
  context-free syntax
    UQLiteral                                            -> Literal	{cons("uqlit")}
    Literal                                              -> Symbol	{cons("lit")}
    function-symbol: Literal "(" arguments:{Symbol ","}* ")" 
      "->" result:Symbol Attributes                      -> Production	{cons("prod-fun")}

module Label-Sdf-Syntax
imports Kernel-Sdf-Syntax Literals-Sdf-Syntax ATerms
exports
  context-free syntax
    label:Literal ":" Symbol   -> Symbol	{cons("label")}
    "cons" "(" term:ATerm ")"  -> Attribute	{cons("cons")}
    "constructor"              -> Attribute	{cons("constructor")}
    "memo"                     -> Attribute	{cons("memo")}
    "traverse"                 -> Attribute	{cons("traverse")}

module Restrictions-Sdf-Syntax
imports CC-Sdf-Syntax
exports
  sorts Restriction Restrictions
  context-free syntax
    CharClass                    	-> Lookahead	{cons("char-class")}
    head:CharClass "." tail:Lookaheads  -> Lookahead  	{cons("seq")}
    Lookahead                    	-> Lookaheads	{cons("single")}
    "left":Lookaheads "|" "right":Lookaheads    
					-> Lookaheads 	{cons("alt"),right}
    "(" Lookaheads ")"           -> Lookaheads 		{bracket}
    "[[" list:{Lookahead ","}* "]]"   -> Lookaheads 		{cons("list")}

    Symbols "-/-" Lookaheads     -> Restriction		{cons("follow")}

    list:Restriction*                 -> Restrictions
    "restrictions" Restrictions  -> Grammar		{cons("restrictions")}
    "reject"                     -> Attribute		{cons("reject")}
    "prefer"                     -> Attribute           {cons("prefer")}
    "avoid"                      -> Attribute           {cons("avoid")}

  context-free priorities
    CharClass "." Lookaheads     -> Lookahead
  >  Lookaheads "|" Lookaheads   -> Lookaheads


module Alias-Sdf-Syntax
imports Kernel-Sdf-Syntax
exports
  sorts Alias Aliases
  context-free syntax
    "aliases" Aliases              -> Grammar  {cons("aliases")}
    Symbol arrow:"->" alias:Symbol -> Alias    {cons("alias")}
    list:Alias*                    -> Aliases

module Symbols
imports Layout
exports
  sorts Symbol Symbols
  context-free syntax
    "(" Symbol ")"       -> Symbol {bracket}
    list:Symbol*         -> Symbols

module Grammar-Syntax
imports Layout
exports
  sorts Grammar
  context-free syntax
    "(/)"                 -> Grammar				{cons("empty-grammar")}
    "left":Grammar "right":Grammar  -> Grammar			{assoc,cons("conc-grammars")}
    "(" Grammar ")"       -> Grammar {bracket}

module Renaming-Sdf-Syntax
imports Kernel-Sdf-Syntax
exports
  sorts Renaming Renamings
  context-free syntax
    "[" list:Renaming* "]"              -> Renamings  {cons("renamings")}
    from:Symbol     "=>" to:Symbol      -> Renaming   {cons("symbol")}
    from:Production "=>" to:Production  -> Renaming   {cons("production")}

module IntCon
imports Layout
exports
  sorts NatCon IntCon
  lexical syntax
    [0-9]+ -> NatCon  {cons("digits")}
  context-free syntax
    NatCon     -> IntCon {cons("natural")}
    pos:"+" NatCon -> IntCon {cons("positive")}
    neg:"-" NatCon -> IntCon {cons("negative")}

module Character-Class-Syntax
imports Character-Syntax
exports
  %% sorts CharRange CharRanges OptCharRanges CharClass
  context-free syntax
    Character                 		-> CharRange	
    start:Character "-" end:Character   -> CharRange           	{cons("range")}

    CharRange                 			-> CharRanges
    "left":CharRanges "right":CharRanges     	-> CharRanges	{cons("conc"),right,memo}
    "(" CharRanges ")"        			-> CharRanges	{bracket}
                              -> OptCharRanges			{cons("absent")}
    CharRanges                -> OptCharRanges			{cons("present")}
    "[" OptCharRanges "]"     -> CharClass			{cons("simple-charclass")}          
    "~" CharClass             -> CharClass          		{cons("comp")}
    "left":CharClass "/" "right":CharClass   -> CharClass	{cons("diff"),left,memo}
    "left":CharClass "/\\" "right":CharClass -> CharClass	{cons("isect"),left,memo}   
    "left":CharClass "\\/" "right":CharClass -> CharClass	{cons("union"),left}   
    "(" CharClass ")"          -> CharClass {bracket}
  context-free priorities
    "~" CharClass             -> CharClass >
    CharClass "/" CharClass   -> CharClass >
    CharClass "/\\" CharClass -> CharClass >
    CharClass "\\/" CharClass -> CharClass

module Literals
imports Layout
exports
  sorts Literal
  lexical syntax
    "\\" ~ []			-> AlphaNumericalEscChar {cons("default")}
    "\\" [01] [0-9] [0-9]	-> DecimalEscChar	 {cons("dec0_199")}
    "\\" "2" [0-4] [0-9]	-> DecimalEscChar	 {cons("dec200_249")}
    "\\" "2" "5" [0-5]		-> DecimalEscChar	 {cons("dec250_255")}
    alpha:AlphaNumericalEscChar	-> EscChar		 {cons("alpha-numeric")}
    decimal:DecimalEscChar	-> EscChar		 {cons("decimal")}
    ~ [\0-\31\"\\] \/ [\t\n]	-> L-Char		 {cons("normal")}
    EscChar			-> L-Char		 {cons("escaped")}
    "\"" chars:L-Char* "\""	-> Literal		 {cons("quoted")}
  lexical restrictions
    AlphaNumericalEscChar -/- [0-9]      

module ATerms
imports Literals IntCon RealCon
exports
  sorts ATerms ATermList ACon AFun ATerm Ann
  context-free syntax
    term:ATerm                        -> ATerms    {cons("aterm")}
    head:ATerm "," tail:ATerms        -> ATerms    {cons("cons")}
    "[" "]"                           -> ATermList {cons("empty")}
    "[" ATerms "]"                    -> ATermList {cons("not-empty")}
    IntCon                            -> ACon      {cons("int")}
    RealCon                           -> ACon      {cons("real")}
    Literal                           -> AFun			
    ACon                              -> ATerm     {cons("constant")}
    list:ATermList                    -> ATerm     {cons("list")}
    fun:AFun                          -> ATerm     {cons("fun")}
    fun:AFun "(" args:ATerms ")"      -> ATerm     {cons("appl")}
    "{" ATerms "}"                    -> Ann       {cons("annotation")}
    ACon Ann                          -> ATerm     {cons("annotated-constant")}
    list:ATermList Ann                -> ATerm     {cons("annotated-list")}
    fun:AFun Ann                      -> ATerm     {cons("annotated-fun")}
    fun:AFun "(" args:ATerms ")" Ann  -> ATerm     {cons("annotated-appl")}

module Layout
exports
  lexical syntax
    [\ \t\n]           -> LAYOUT
    "%%" ~[\n]* [\n]   -> LAYOUT
    "%" ~[\n\%]+ "%"   -> LAYOUT
    "default-"         -> TagId {cons("default")}
  context-free syntax
                       -> TagId {cons("empty")} 

module Character-Syntax
imports Layout
exports
  sorts Character NumChar ShortChar
  lexical syntax
    [\\] [0-9]+                    -> NumChar   {cons("digits")}
    [a-zA-Z0-9]                    -> ShortChar {cons("regular")}
    [\\] ~[\0-\31A-Za-mo-su-z0-9]  -> ShortChar {cons("escaped")}
  context-free syntax
    NumChar   -> Character {cons("numeric")}
    ShortChar -> Character {cons("short")}
    "\\TOP"   -> Character {cons("top")}
    "\\EOF"   -> Character {cons("eof")}

module RealCon
imports IntCon
exports
  sorts OptExp RealCon
  context-free syntax
    "e" IntCon                -> OptExp		{cons("present")}
                              -> OptExp		{cons("absent")}
    IntCon "." NatCon OptExp  -> RealCon	{cons("real-con")}
