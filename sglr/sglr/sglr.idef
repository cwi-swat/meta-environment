/*

    SGLR - the Scannerless Generalized LR parser.
    Copyright (C) 2000  Stichting Mathematisch Centrum, Amsterdam, The Netherlands.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

*/
/* $Id$ */

process Parser is
  let
    P    : sglr,
    L    : str,
    G    : str,
    S    : str,
    Id   : term,
    FN   : str,
    Tbl  : term,
    T    : term,
    Err  : list,
    Start: list,
    Amb  : int
  in
    execute(sglr, P?) .
    (
      (rec-msg(Id?, parse-string(L?, G?, S?)) .
       snd-eval(P, parse-string(L, G, S))
      +
       rec-msg(parse-file(L?, G?, FN?, Id?)) .
       snd-eval(P, parse-file(L, G, FN))
      ).
      (
        rec-value(P, parsetree(T?, Amb?)) .
        snd-msg(parse-result(Id, parsetree(T, Amb)))
      +
        rec-value(P, parse-error(Err?,plain)) .
        snd-msg(parse-result(Id, parse-error(Err,plain)))
      +
        rec-value(P, parse-error(Err?,eof)) .
        snd-msg(parse-result(Id, parse-error(Err,eof)))
      +
        rec-value(P, parse-error(Err?,ambiguities(Amb?))) .
        snd-msg(parse-result(Id, parse-error(Err,ambiguities(Amb))))
      +
        rec-value(P, parse-error(Err?,cycle(T?))) .
        snd-msg(parse-result(Id, parse-error(Err,cycle(T?))))
      )
    +
      rec-msg(Id?, parse-string-as-asfix1(L?, G?, S?)) .
      snd-eval(P, parse-string-as-asfix1(L, G, S)) .
      (
        rec-value(P, asfix1-parsetree(T?)) .
        snd-msg(parse-result-asfix1(Id, parse-tree(T)))
      +
        rec-value(P, parse-error(Err?,plain)) .
        snd-msg(parse-result-asfix1(Id, parse-error(Err,plain)))
      +
        rec-value(P, parse-error(Err?,eof)) .
        snd-msg(parse-result-asfix1(Id, parse-error(Err,eof)))
      +
        rec-value(P, parse-error(Err?,ambiguities(Amb?))) .
        snd-msg(parse-result-asfix1(Id, parse-error(Err,ambiguities(Amb))))
      +
        rec-value(P, parse-error(Err?,cycle(T?))) .
        snd-msg(parse-result-asfix1(Id, parse-error(Err,cycle(T?))))
      )
    +
      (
        rec-msg(open-language-from-term(L?, Tbl?)) .
        snd-eval(P, open-language-from-term(L, Tbl))
      +
        rec-msg(open-language(L?, FN?)) .
        snd-eval(P, open-language(L, FN))
      +
        rec-msg(reopen-language(L?, FN?)) .
        snd-eval(P, reopen-language(L, FN))
      ) .
      (
	rec-value(P, language-opened(L?, FN)) .
	snd-msg(language-opened(L)) .
	snd-note(language-available(L))
      +
	rec-value(P, language-not-opened(L?, FN)) .
	snd-msg(language-not-opened(L))
      )
    +
      rec-msg(close-language(L?)) .
      snd-eval(P, close-language(L)) .
      (
	rec-value(P, language-closed(L?)) .
	snd-note(language-unavailable(L))
      +
	rec-value(P, language-not-open(L?))
      )
    +
      rec-msg(get-top-symbols(L?)) .
      snd-eval(P, get-top-symbols(L)) .
      (
	rec-value(P, startsymbols(L, Start?))
      +
	rec-value(P, language-not-available(L))
      )
    )
    * rec-disconnect(P)
  endlet

tool sglr is {command="sglr"}
