/* $Id$ */

tool sglr is {
  command = "sglr"
}

process SGLR is
let
  SGLR        : sglr,
  ModuleId    : term,
  Nonterminal : str,
  Text        : str,
  ErrorId     : str,
  ToolId      : str,
  Path        : str,
  Id          : term,
  Table       : term,
  Tree        : term,
  Error       : list,
  NrOfAmbs    : int,
  FeedBack    : term
in
  (
    rec-msg(Id?, parse-string-given-table(ModuleId?, Table?, Nonterminal?, Text?, Path?)) .
    execute(sglr, SGLR?) .
    snd-eval(SGLR, open-language(ModuleId, Table)) .
    (
      rec-value(SGLR, language-opened(ModuleId)) .
      snd-eval(SGLR, parse-string(ModuleId, Nonterminal, Text, Path)) .
      (
        rec-value(SGLR, parsetree(Tree?, NrOfAmbs?)) .
        snd-msg(parse-result-asfix2me(Id, parsetree(Tree, NrOfAmbs), no-errors))
      +
        rec-value(SGLR, feedback(ToolId?, ErrorId?, Error?)) .
        snd-msg(parse-result-asfix2me(Id, 
                                      error-tree, 
                                      feedback(ToolId, ErrorId, Error)))
      +
        rec-value(SGLR, ambiguous-tree(Tree?, FeedBack?)) .
        snd-msg(parse-result-asfix2me(Id, Tree, FeedBack))
      )
    +
      rec-value(SGLR, language-not-opened(ModuleId)) .
      snd-msg(parse-result-asfix2me(Id, error-tree, no-parse-table))
    ) .
    snd-terminate(SGLR, "done")
  )
  * delta
endlet

toolbus(SGLR)
