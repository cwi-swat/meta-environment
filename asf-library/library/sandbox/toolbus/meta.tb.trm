



process AbortMetaEnvironment is
let
  TimeOut : int
in



  TimeOut := 0.

  shutdown("Meta-Environment ran out of time!") delay(TimeOut)
endlet




process SetParseTable(ModuleId : term, Continue : term?) is
let
  Type : str,
  ModuleName : str
in
  Type := fun(ModuleId) .
  ModuleName := first(args(ModuleId)).
  if and(equal(Type, "trm"), equal(ModuleName, "Sdf2")) then
    snd-msg(open-sdf2-language) .
    (
      rec-msg(sdf2-language-not-opened) .
      snd-note(ui-status(errorf(
        "Unable to open parse table for %s", [ModuleName]))) .
      Continue := false
    +
      rec-msg(sdf2-language-opened) .
      Continue := true
    )
  else
    snd-msg(set-parsetable(ModuleId)) .
    (
      rec-msg(parsetable-not-set(ModuleId)) .
      snd-note(ui-status(errorf(
        "Unable to open parse table for %s", [ModuleName]))) .
      Continue := false
    +
      rec-msg(parsetable-set(ModuleId)) .
      Continue := true
    )
  fi
endlet

process ParseString(ModuleId : term, Nonterminal : str, Text : str,
                    Tree : term?, ParseError : term?) is
let
  Id : term,
  ErrList : list,
  ErrContent : term,
  Continue : term
in
  Id := process-id .
  SetParseTable(ModuleId, Continue?) .
  if equal(Continue, true) then
    snd-note(ui-status(statf(Id,"Parsing %s", [ModuleId]))).
    snd-msg(Id, parse-string-as-asfix2me(ModuleId, Nonterminal, Text)).
    (
      rec-msg(parse-result-asfix2me(Id, parse-tree(Tree?))) .
      ParseError := no-errors
    +
      rec-msg(parse-result-asfix2me(Id, ambiguous-tree(Tree?,
                                                       ErrList?,
                                                       ErrContent?))) .
      ParseError := quote(ambiguous-parse(ErrList, ErrContent))
    +
      rec-msg(parse-result-asfix2me(Id, parse-error(ErrList?, ErrContent?))) .
      Tree := error-tree .
      ParseError := quote(parse-error(ErrList, ErrContent))
    ) .
    snd-note(ui-status(endstat(Id)))
  else
    Tree := error-tree .
    ParseError := no-parse-table
  fi
endlet

process ProcessTree(ModuleId : term, EditorId : term,
                    Focus : term, Tree : term) is
let
  FileName : str,
  NewTree : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(get-editor-name(EditorId)) .
    rec-msg(editor-name(FileName?)) .
    snd-msg(add-posinfo(FileName, Tree)) .
    rec-msg(tree-with-pos-info(NewTree?)) .
    snd-msg(replace-focus(EditorId, Focus, NewTree)) .
    NewTree := no-tree .
    snd-msg(parse-ok(ModuleId))
  else
    tau
  fi
endlet

process ProcessParseError(ModuleName : str, ParseError: term, Type : str) is
let
  Co : int,
  Li : int,
  I : int,
  Ch : int,
  Cycle : term,
  ErrorList : list,
  ErrorContent : term,
  FunSym : str
in
  FunSym := fun(ParseError) .
  if not-equal(FunSym, "no-errors") then
    ErrorList := first(args(ParseError)) .
    ErrorContent := first(next(args(ParseError))) .
    FunSym := fun(ErrorContent) .
    if equal(FunSym, "ambiguities") then
      I := first(args(ErrorContent)) .
      if greater(I, 1) then
        snd-note(ui-status(errorf("Parse of %s.%s returned %d ambiguities",
                                  [ModuleName,Type,I])))
      else
        snd-note(ui-status(errorf("Parse of %s.%s returned 1 ambiguity",
                                  [ModuleName,Type])))
      fi
    else
      tau
    fi .
    if equal(FunSym, "cycle") then
      Cycle := first(args(ErrorContent)) .
      snd-note(ui-status(errorf("Parse returned a cycle: %t\n",
                                [Cycle])))
    else
      tau
    fi .
      if equal(FunSym, "eof") then
      snd-note(ui-status(errorf("EOF unexpected while parsing %s.%s\n",
                                [ModuleName,Type])))
    else
      tau
    fi .
    if equal(FunSym, "plain") then
      Ch := first(args(first(ErrorList))) .
      Li := first(args(first(next(ErrorList)))) .
      Co := first(args(first(next(next(ErrorList))))) .
      snd-note(ui-status(errorf(
               "Character %d unexpected in %s.%s, line %d, column %d\n",
               [Ch, ModuleName, Type, Li, Co])))
    else
      tau
    fi
  else
    tau
  fi
endlet

process PrepareParseErrorForEditor(ModuleId : term, EditorId : term,
                                   Focus : term, ParseError : term) is
let
  Pos : int,
  Co : int,
  Li : int,
  I : int,
  Ch : int,
  Cycle : term,
  ErrorList : list,
  ErrorContent : term,
  FunSym : str,
  ModuleName : str,
  Type : str
in
  ModuleName := first(args(ModuleId)).
  Type := fun(ModuleId) .
  if equal(Type, "eqs") then
    Type := "asf"
  else
    tau
  fi .
  FunSym := fun(ParseError) .
  if not-equal(FunSym, "no-errors") then
    ErrorList := first(args(ParseError)) .
    snd-msg(get-error-position(Focus, ErrorList)) .
    rec-msg(error-position(Pos?)) .
    snd-note(display-error(EditorId, Pos)) .
    ErrorContent := first(next(args(ParseError))) .
    FunSym := fun(ErrorContent) .
    if equal(FunSym, "ambiguities") then
      I := first(args(ErrorContent)) .
      if greater(I, 1) then
        snd-note(ui-status(errorf("Parse of %s.%s returned %d ambiguities",
                                  [ModuleName,Type,I])))
      else
        snd-note(ui-status(errorf("Parse of %s.%s returned 1 ambiguity",
                                  [ModuleName,Type])))
      fi
    else
      tau
    fi .
    if equal(FunSym, "cycle") then
      Cycle := first(args(ErrorContent)) .
      snd-note(ui-status(errorf("Parse returned a cycle: %t\n", [Cycle]))) .
      snd-msg(parse-failed(ModuleId, Focus))
    else
      tau
    fi .
    if equal(FunSym, "eof") then
      snd-note(ui-status(errorf("EOF unexpected while parsing %s.%s\n",
                                [ModuleName, Type]))) .
      snd-msg(parse-failed(ModuleId, Focus))
    else
      tau
    fi .
    if equal(FunSym, "plain") then
      snd-msg(parse-failed(ModuleId, Focus))
    else
      tau
    fi
  else
    tau
  fi
endlet


process Editors is
let
  Pid : int
in
  create(EditorManager,Pid?) .
  create(EditorCreator,Pid?) .
  create(SE, Pid?)
endlet

process EditorCreator is
let
  EditorId : term,
  ModuleName : str,
  FileName : str,
  Tree : term
in
  (
    rec-msg(edit-syntax(ModuleName?)) .
    SyntaxEditorCreator(ModuleName)
  +
    rec-msg(edit-equations(ModuleName?)) .
    EquationsEditorCreator(ModuleName)
  +
    rec-msg(edit-term-file(ModuleName?, FileName?)).
    TermEditorCreator(ModuleName,FileName,none)
  +
    rec-msg(edit-term-file-with-tree(ModuleName?, FileName?, Tree?)) .
    TermEditorCreator(ModuleName,FileName,Tree)
  +
    rec-msg(delete-editors-for-module(ModuleName?)) .
    KillEditorsForModule(ModuleName)
  )
  * delta
endlet

process SyntaxEditorCreator (ModuleName : str) is
let
  Tree : term,
  Text : str,
  FileName : str,
  Message : str,
  Path : str
in
  Tree := none.
  Text := "".
  snd-msg(get-path-from-db(ModuleName)) .
  rec-msg(path(Path?)) .
  snd-msg(io-get-filename(Path, ModuleName, ".sdf")) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(get-sdf2-asfix(ModuleName)).
  (
    rec-msg(syntax(Tree?))
  +
    rec-msg(unavailable).
    snd-msg(io-read-file(FileName)) .
    (
      rec-msg(io-file-contents(Text?))
    +
      rec-msg(io-error-reading(Message?))
    )
  ) .
  CreateEditor("syntax",ModuleName,FileName,Text,Tree)
endlet

process EquationsEditorCreator (ModuleName : str) is
let
  Tree : term,
  Text : str,
  FileName : str,
  Path : str,
  Time : int,
  Status : term
in
  Status := success .
  Tree := none .
  Text := "" .
  snd-msg(get-path-from-db(ModuleName)) .
  rec-msg(path(Path?)) .
  snd-msg(io-get-filename(Path, ModuleName, ".asf")) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(get-eqs-tree(ModuleName)) .
  (
    rec-msg(tree(Tree?))
  +
    rec-msg(unavailable) .
    snd-msg(get-eqs-text(ModuleName)) .
    (
      rec-msg(eqs-text(ModuleName, Text?))
    +
      rec-msg(no-eqs-text(ModuleName)) .
      snd-msg(create-new-equations(ModuleName)) .
      (
        rec-msg(new-equations-created)
      +
        rec-msg(new-equations-not-created) .
        Status := failure
      )
    )
  ) .
  if equal(Status, success) then
    CreateEditor("equations",ModuleName,FileName,Text,Tree)
  else
    tau
  fi
endlet

process TermEditorCreator (ModuleName : str, FileName : str, Tree : term) is
let
  Text : str,
  ErrorMessage : str
in
  Text := "".
  snd-msg(io-read-file(FileName)) .
  (
    rec-msg(io-file-contents(Text?))
    +
    rec-msg(io-error-reading(ErrorMessage?))
  ).
  CreateEditor("term",ModuleName,FileName,Text,Tree)
endlet

process CreateEditor(Type : str, ModuleName : str,
                     FileName : str,
                     Text : str, Tree : term) is
let
  EditorId : term,
  ButtonList : list,
  Pid : int,
  Focus : term
in




    snd-msg(get-auxilary-buttons(Type, ModuleName)) .
    rec-msg(button-list(ModuleName,ButtonList?)).
    snd-msg(get-editor-id(FileName, ModuleName)) .
    (
      rec-msg(new-editor(EditorId?)) .
      snd-msg(initialize-structure-editor(EditorId, Text, Tree)) .
      rec-msg(initial-focus(Focus?)) .
      create(EditorActionsLoop(EditorId, Type, ModuleName), Pid?) .
      create(TextEditor, Pid?) .
      snd-msg(edit-text(EditorId, FileName, ButtonList)) .
      rec-msg(text-editor-initialized(EditorId)) .
      snd-msg(editor-opened(ModuleName, EditorId))
    +
      rec-msg(existing-editor(EditorId?)) .
      snd-note(move-editor-to-front(EditorId)) .
      snd-msg(editor-opened(ModuleName, EditorId))
    )
endlet

process CloseEditor(ModuleName : str, FileName : str) is
let
  EditorId : term
in
  snd-msg(check-editor-id(FileName, ModuleName)) .
  (
    rec-msg(existing-editor(FileName, EditorId?)) .
    snd-msg(kill-editor(EditorId))
  +
    rec-msg(non-existing-editor(FileName))
  )
endlet

process EditorActionsLoop(EditorId: term, Type : str, ModuleName: str) is
let
  ButtonName : list,
  Pid : int,
  Command : term
in
  subscribe(delete-editor(<term>)) .
  subscribe(syntax-changed(ModuleName)) .
  (
    rec-msg(extra-button-action(EditorId, ButtonName?)) .
    snd-msg(extra-button-action(ButtonName, Type, ModuleName, EditorId))
  +
    rec-msg(text-editor-disconnected(EditorId)) .
    create(KillEditor(EditorId, Type, ModuleName), Pid?)
  +
    rec-msg(kill-editor(EditorId)) .
    snd-note(kill-text-editor(EditorId)) .
    rec-msg(text-editor-killed(EditorId)) .
    create(KillEditor(EditorId, Type, ModuleName), Pid?)
  +
    rec-note(syntax-changed(ModuleName)).
    InvalidateDependendEditor(EditorId,Type)
  +
    rec-msg(get-editor-modulename(EditorId)) .
    snd-msg(editor-modulename(EditorId,ModuleName))
  ) *
  rec-note(delete-editor(EditorId))
endlet

process InvalidateDependendEditor(EditorId : term, Type : str) is
  if not(equal(Type,"syntax")) then
    InvalidateEditor(EditorId)
  else
    tau
  fi

process InvalidateEditor(EditorId : term) is
let
  Focus : term
in
  snd-msg(invalidate-tree(EditorId)) .
  rec-msg(invalidation-done(EditorId,Focus?)) .
  snd-note(set-focus(EditorId, Focus))
endlet

process KillEditor(EditorId : term, Type : str, ModuleName : str) is
  snd-note(delete-editor(EditorId)) .
  if not(equal(type, "term")) then
    KillModuleEditor(EditorId, ModuleName)
  else
    tau
  fi.
  snd-msg(delete-structure-editor(EditorId))

process KillModuleEditor(EditorId : term, ModuleName : str) is
let
  ModifiedStatus : term
in
  snd-msg(get-modified-status(EditorId)) .
  rec-msg(modified-status(EditorId, ModifiedStatus?)) .
  if equal(ModifiedStatus, modified) then
    snd-msg(revert-module(ModuleName)).
    rec-msg(module-reverted(ModuleName)).
    snd-note(ui-status(errorf("Dirty module %s is reread from disk",
                       [ModuleName])))
  else
    tau
  fi
endlet

process KillEditorsForModule(ModuleName: str) is
let
  EditorId : term,
  EditorList : list
in
  snd-msg(get-editors-by-module(ModuleName)) .
  rec-msg(editors-by-module(EditorList?)) .
  (
    if not-equal(EditorList, []) then
      EditorId := first(EditorList) .
      snd-msg(kill-editor(EditorId)) .
      EditorList := next(EditorList)
    fi
  ) *
  if equal(EditorList, []) then
    tau
  fi
endlet

process RestoreTermBrackets is
let
  Table : term,
  Tree : term,
  ModuleName : str
in
  (
    rec-msg(restore-term-brackets(ModuleName?, Tree?)).
    snd-msg(get-parsetable(trm(ModuleName))).
    (
      rec-msg(parse-table(Table?)) .
      snd-msg(restore-brackets(Tree, Table)) .
      rec-msg(brackets-restored(Tree?))
    +
      rec-msg(no-parse-table(trm(ModuleName))) .
      Tree := error-tree
    ).
    snd-msg(restore-term-brackets-result(ModuleName, Tree))
  ) * delta
endlet


process Open-initial-module is
let
  Path : str,
  Module : str,
  Extension : str,
  RealModule : str,
  Imports : list,
  Status : term
in
  (
    rec-msg(open-initial-module(Path?, Module?, ".sdf")) .
    snd-msg(is-module-in-db(Module)).
    (
      rec-msg(not-exists-in-module-db(Module)) .
      Status := success.
      Open-Module(Path, Module, Status?, RealModule?, Imports?).
      snd-msg(open-modules(Imports)).
      rec-msg(finished-opening-modules)
    +
      rec-msg(exists-in-module-db(Module))
    )
  ) *
  delta
endlet

process DrawImportGraph is
let
  ImportRelations : list
in
  snd-msg(get-import-relations) .
  rec-msg(import-relations(ImportRelations?)) .
  snd-note(display-import-graph(ImportRelations)) .
  ImportRelations := []
endlet

process LocateFile(Name : str, Extension : str, Path : str?) is
let
  Directories : list,
  Chosen : str
in
  snd-msg(get-search-paths) .
  rec-msg(search-paths(Directories?)) .
  snd-msg(io-find-file(Directories, Name, Extension)) .
  (
    rec-msg(io-file-not-found) .
    Path := ""
  +
    rec-msg(io-file-found(Directories?)) .
    Path := first(Directories) .
    Directories := next(Directories) .
    if not-equal(Directories, []) then
      snd-msg(io-get-filename(Path, Name, Extension)) .
      rec-msg(io-filename(Chosen?)) .
      DealWithMultipleOccurrences(Chosen, Name, Extension, Directories)
    else
      tau
    fi
  )
endlet

process DealWithMultipleOccurrences(Chosen : str, Name : str,
                                    Extension : str, Peers : list) is
let
  Directories : list,
  Directory : str,
  FileName : str
in
  Directories := Peers .
  if not-equal(Directories, []) then
    Directory := first(Directories) .
    Directories := next(Directories) .
    snd-msg(io-get-filename(Directory, Name, Extension)) .
    rec-msg(io-filename(FileName?)) .
    snd-msg(compare-files(FileName, Chosen)) .
    (
      rec-msg(files-equal) .
      snd-note(ui-status(errorf("Multiple occurrences of %s:\n%s and %s",
                                [Name,Chosen,FileName])))
    +
      rec-msg(files-differ)
    )
  fi
  *
  if equal(Directories, []) then
    tau
  fi
endlet

process Open-modules is
let
  Id : int,
  Modules : list,
  Module : str,
  RealModules : list,
  RealModule : str,
  Imports : list,
  Status : term,
  Path : str,
  FileName : str,
  Changed : term
in
  Id := process-id.
  (
    rec-msg(open-modules(Modules?)).
    Changed := true .
    snd-note(ui-status(stat(Id,"Opening Modules"))).
    RealModules := [].
    if not-equal(Modules, []) then
      Module := first(Modules).
      Modules := next(Modules).
      snd-msg(is-module-in-db(Module)).
      (
        rec-msg(exists-in-module-db(Module))
      +
        rec-msg(not-exists-in-module-db(Module)).
        Status := success.
        LocateFile(Module, ".sdf", Path?) .
        Open-Module(Path, Module, Status?, RealModule?, Imports?).
        Modules := join(Imports, Modules).
        RealModules := join(RealModules, RealModule)
      )
    fi *
    if equal(Modules, []) then
      if equal(Changed, true) then
        DrawImportGraph()
      else
        tau
      fi .
      snd-note(ui-status(endstat(Id))) .
      snd-msg(finished-opening-modules)
    fi
  ) *
  delta
endlet

process Open-Module(Path : str, Module : str, Status : term?,
                    RealModule : str?, Imports : list?)
is
let
  Id : int,
  RealPath : str
in
  Id := process-id.
  snd-note(ui-status(statf(Id,"Opening %s",[Module]))).
  Imports := [].
  (
    Open-Syntax(Path, Module, Status?, RealModule?, RealPath?, Imports?).
    if equal(Status, success) then
      Open-Equations(RealModule, RealPath)
    else
      RealModule := Module.
      Handle-Open-Module-Errors(RealModule, Status)
    fi
  ).
  snd-note(ui-status(endstat(Id)))
endlet

process Error(Message : str, MessageArgs : list) is
  snd-note(ui-status(errorf(Message, MessageArgs)))

process Handle-Open-Module-Errors(Module : str, Status : term) is
  if not-equal(Status, success) then
    Error("Opening module %s failed: %s", [Module, Status])
  else
    tau
  fi

process Open-Syntax(Path : str, Module : str, Status : term?,
                    RealModule : str?, RealPath : str?, Imports : list?) is
let
  Tree : term,
  Text : str,
  Message : str,
  FileName : str
in
  snd-msg(io-get-filename(Path, Module, ".sdf")) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-read-file(FileName)) .
  (
    rec-msg(io-file-contents(Text?)) .
    Parse-Syntax(Text, Status?, Tree?)
  +
    rec-msg(io-error-reading(Message?)) .
    Status := no-such-file
  ) .
  if not-equal(Status, no-such-file) then
    Imports := [].
    snd-msg(add-sdf-module-to-db(Module, Path, Text, Tree)).
    (
      rec-msg(adding-succeeded(Module, RealModule?, RealPath?, Imports?))
    +
      rec-msg(error-opening(Module, Status?))
    )
  else
    tau
  fi
endlet

process Parse-Syntax (Text : str, Status : term?, Tree : term?) is
let
  Id : int,
  Errors : list,
  Error : term
in
  Id := process-id.
  snd-msg(open-sdf2-language).
  rec-msg(sdf2-language-opened).
  snd-msg(Id,parse-string-as-asfix2me(trm("Sdf2"),"Module",Text)).
  (
    rec-msg(parse-result-asfix2me(Id?, parse-tree(Tree?)))
  +
    rec-msg(parse-result-asfix2me(Id?, parse-error(Errors?, Error?))).
    Tree := no-tree.
    Status := parse-error
  )
endlet

process Open-Equations (Module : str, Path : str) is
let
  Tree : term,
  Text : str,
  ErrorMessage : str,
  FileName : str
in
  snd-msg(io-get-filename(Path, Module, ".asf")) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(io-read-file(FileName)) .
  (
    rec-msg(io-file-contents(Text?)) .
    snd-msg(add-eqs-to-db(Module, text(Text))) .
    rec-msg(eqs-added)
  +
    rec-msg(io-error-reading(ErrorMessage?))
  )
endlet




process File-creator is
let
  FileName : str,
  ModuleName : str,
  RealModule : str,
  ErrMsg : str,
  Path : str,
  Text : str
in
  (
    %% Handle request to create a new module.
    rec-msg(create-new-module(Path?, ModuleName?)) .
    snd-msg(is-module-in-db(ModuleName)) .
    (
      rec-msg(exists-in-module-db(ModuleName)) .
      snd-note(ui-status(errorf("Module %s already exists",
                                [ModuleName])))
    +
      rec-msg(not-exists-in-module-db(ModuleName)) .
      snd-msg(io-get-filename(Path, ModuleName, ".sdf")) .
      rec-msg(io-filename(FileName?)) .
      snd-msg(io-exists-file(FileName)) .
      (
        rec-msg(io-file-exists) .
        snd-note(ui-status(
        errorf("Module %s already exists on disk", [ModuleName])))
      +
        rec-msg(io-file-not-exists) .
        snd-msg(io-write-text-file(FileName, ["module ", ModuleName, "\n"])) .
        (
          rec-msg(io-file-written) .
          snd-msg(open-initial-module(Path, ModuleName, ".sdf"))
        +
          rec-msg(io-file-not-written(ErrMsg?)) .
          snd-note(ui-status(errorf("%s: %s", [FileName, ErrMsg])))
        )
      )
    )
  +
    %% Handle request to create a new rules section.
    rec-msg(create-new-equations(ModuleName?)) .
    snd-msg(is-module-in-db(ModuleName)) .
    (
      rec-msg(not-exists-in-module-db(ModuleName))
    +
      rec-msg(exists-in-module-db(ModuleName)) .
      snd-msg(get-path-from-db(ModuleName)) .
      rec-msg(path(Path?)) .
      snd-msg(io-get-filename(Path, ModuleName, ".asf")) .
      rec-msg(io-filename(FileName?)) .
      snd-msg(io-exists-file(FileName)) .
      (
        rec-msg(io-file-exists) .
        snd-msg(io-read-file(FileName)) .
        rec-msg(io-file-contents(text(Text?))) .
        snd-msg(add-eqs-to-db(ModuleName, text(Text))) .
        rec-msg(eqs-added) .
        snd-msg(new-equations-created)
      +
        rec-msg(io-file-not-exists) .
        snd-msg(io-write-text-file(FileName, [])) .
        (
          rec-msg(io-file-written) .
          snd-msg(io-read-file(FileName)) .
          (
            rec-msg(io-file-contents(Text?)) .
            snd-msg(add-eqs-to-db(ModuleName, text(Text))) .
            rec-msg(eqs-added) .
            snd-msg(new-equations-created)
          +
            rec-msg(io-error-reading(ErrMsg?)) .
            snd-note(ui-status(errorf("%s: %s", [FileName,ErrMsg]))) .
            snd-msg(new-equations-not-created)
          )
        +
          rec-msg(io-file-not-written(ErrMsg?)) .
          snd-note(ui-status(errorf("%s: %s", [FileName,ErrMsg]))) .
          snd-msg(new-equations-not-created)
        )
      )
    )
  ) * delta
endlet


process Module-Utilities is
let
  Id : int,
  ModuleName1 : str,
  ModuleName2 : str,
  Extension : str,
  Path : str,
  Option1 : term
in
  Id := process-id.
  (
    rec-msg(rename-module(ModuleName1?, ModuleName2?, Path?)) .
    snd-note(ui-status(statf(Id,
             "Renaming %s to %s",[ModuleName1,ModuleName2]))).
    DoRenameModule(ModuleName1, ModuleName2, Path).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(copy-module(ModuleName1?, ModuleName2?, Path?)).
    snd-note(ui-status(statf(Id,
             "Copying %s to %s",[ModuleName1,ModuleName2]))).
    DoCopyModule(ModuleName1, ModuleName2, Path).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(import-module(ModuleName1?, ModuleName2?, Path?)).
    snd-note(ui-status(statf(Id,
             "Adding %s to imports of %s",[ModuleName2,ModuleName1]))).
    DoImportModule(ModuleName1, ModuleName2, Path).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(delete-module(ModuleName1?)) .
    snd-note(ui-status(statf(Id,
             "Deleting %s",[ModuleName1]))).
    DoDeleteModule(ModuleName1).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(unimport-module(ModuleName1?, ModuleName2?, Path?)).
    snd-note(ui-status(statf(Id,
             "Removing %s from imports of %s",[ModuleName2,ModuleName1]))).
    DoUnimportModule(ModuleName1, ModuleName2, Path).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(revert-module(ModuleName1?)).
    snd-note(ui-status(statf(Id,
             "Reverting %s",[ModuleName1]))).
    DoRevertModule(ModuleName1).
    snd-note(ui-status(endstat(Id)))
  +
    rec-msg(close-module(ModuleName1?, Option1?)).
    snd-note(ui-status(statf(Id,
             "Closing %s",[ModuleName1]))).
    DoCloseModule(ModuleName1, Option1).
    snd-note(ui-status(endstat(Id)))
  ) *
  delta
endlet

process DoCloseModule(ModuleName : str, Recursive : term) is
let
  Status : term,
  Changed : list
in
  Status := success.
  if equal(Recursive,recursive) then
    DoRecursiveCloseModule(ModuleName, Status?)
  else
    SoftCloseModuleInDB(ModuleName, Status?).
    if equal(Status,success) then
      CloseModuleInUI(ModuleName)
    else tau fi
  fi.
  if not(equal(Status, success)) then
    snd-note(ui-status(errorf("Module %s not closed because other modules depend on it", [ModuleName])))
  else tau fi
endlet

process DoRecursiveCloseModule(ModuleName : str, Status : term?) is
let
  Imports : list,
  MoreImports : list,
  Closed : list,
  Import : str
in
  Status := success.
  snd-msg(get-imported-modules(ModuleName)).
  rec-msg(imported-modules(Imports?)).
  SoftCloseModuleInDB(ModuleName, Status?).
  if equal(Status, success) then
    CloseModuleInUI(ModuleName).
    Closed := [].
    if not(equal(Imports, [])) then
      Import := first(Imports).
      Imports := next(Imports).
      FilterElement(Import, Imports?).
      snd-msg(get-imported-modules(Import)).
      rec-msg(imported-modules(MoreImports?)).
      SoftCloseModuleInDB(Import, Status?).
      if equal(Status,success) then
        Closed := join(Import, Closed).

        Imports := join(Imports, MoreImports)
      else tau fi
    fi*
    if equal(Imports,[]) then
      CloseModulesInUI(Closed).

      Status := success
    fi
  else tau fi
endlet

process FilterElement(Elem : term, List : list?) is
let
  OldList : list,
  NewList : list,
  Head : term

in
  OldList := List.
  NewList := [].
  if not(equal(OldList,[])) then
    Head := first(OldList).
    OldList := next(OldList).
    if not(equal(Elem,Head)) then
      NewList := join(Head, NewList)
    else tau fi
  fi *
  if equal(OldList,[]) then
    List := NewList
  fi
endlet

process DoRevertModule(ModuleName : str) is
  HardCloseModuleInDB(ModuleName).
  snd-msg(open-modules([ModuleName])) .
  rec-msg(finished-opening-modules).
  snd-msg(module-reverted(ModuleName))

process DoDeleteModule(ModuleName : str) is
let
  Changed : list
in
    RemoveModuleFromDisk(ModuleName).
    DeleteEditors(ModuleName).
    snd-msg(delete-module-from-db(ModuleName)) .
    rec-msg(changed-modules(Changed?)) .
    CloseModuleInUI(ModuleName).
    SaveSdfModules(Changed).
    snd-msg(notify-about-changed-modules(Changed, "sdf")) .
    rec-msg(notify-about-changed-modules-done)
endlet

process DoRenameModule(Old : str, New : str, Path : str) is
let
  Status : term,
  Changed : list,
  RealNew : str
in
  Status := success.
  GetRealModuleName(New, Path, Status?, RealNew?).
  if equal(Status, success) then
    CheckExistence(New, RealNew, Status?).
    if equal(Status, success) then
      DeleteEditors(Old). tau.
      if equal(Status, success) then
        RenameModuleInDB(Old, New, Path, Changed?) .
        SaveSdfModules(Changed).
        SaveAsfSdfModule(RealNew).
        RemoveModuleFromDisk(Old)
      else tau fi
    else tau fi
  else tau fi.
  HandleRenameModuleErrors(Old, RealNew, Status) . tau
endlet

process DoCopyModule(Old : str, New : str, Path : str) is
let
  Status : term,
  Changed : list,
  RealNew : str
in
  Status := success.
  GetRealModuleName(New, Path, Status?, RealNew?).
  if equal(Status, success) then
    CheckExistence(New, RealNew, Status?).
    if equal (Status, success) then
      CopyModuleInDB(Old, RealNew, Path, Status?, Changed?).
      if equal (Status, success) then
        SaveSdfModules(Changed).
        SaveAsfSdfModule(RealNew)
      else tau fi
    else tau fi
  else tau fi.
  HandleCopyModuleErrors(Old, RealNew, Status) . tau
endlet

process DoImportModule(Mod : str, Import : str, Path : str) is
let
  Status : term,
  Changed : list
in
  snd-msg(is-module-in-db(Import)) .
  (
    rec-msg(exists-in-module-db(Import)) .
    DeleteEditors(Mod).
    AddImportInDB(Mod, Import).
    SaveAsfSdfModule(Mod)
  +
    rec-msg(not-exists-in-module-db(Import)) .
    snd-note(ui-status(
      errorf("Error during adding import %s to %s: module not open",
             [Import, Mod])))
  )
endlet

process DoUnimportModule(Mod : str, Import : str, Path : str) is
let
  Status : term,
  Changed : list
in
  snd-msg(is-module-in-db(Import)) .
  (
    rec-msg(exists-in-module-db(Import)) .
    DeleteEditors(Mod).
    RemoveImportInDB(Mod, Import, Path) .
    SaveAsfSdfModule(Mod)
  +
    rec-msg(not-exists-in-module-db(Import)) .
    snd-note(ui-status(
      errorf("Error during removing import %s to %s: module not open",
             [Import, Mod])))
  )
endlet

process GetRealModuleName(Name : str, Path : str, Status : term?,
                          RealName : str?)
is
let
  ErrMsg : str
in
  Status := success .
  snd-msg(io-get-filename(Path, Name, ".sdf")) .
  rec-msg(io-filename(RealName?))
endlet

process SaveSdfModules(Modules : list) is
let
  Runner : list,
  Module : str
in
  Runner := Modules.
  if not-equal(Runner, []) then
    Module := first(Runner) .
    snd-msg(save-sdf-module(Module)) .
    rec-msg(saved-sdf-module(Module)) .
    Runner := next(Runner)
  fi *
  if equal(Runner, []) then
    tau
  fi
endlet

process SaveAsfSdfModule(Module : str) is
   snd-msg(save-asfsdf-module(Module)) .
   rec-msg(saved-asfsdf-module(Module))

process RemoveModuleFromDisk(Module : str) is
  snd-msg(remove-module(Module)) .
  rec-msg(removed-module)

process SoftCloseModuleInDB(ModuleName : str, Status : term?) is
let
  Depending : list,
  Changed : list
in
  snd-msg(get-all-depending-modules(ModuleName)).
  rec-msg(all-depending-modules(Depending?)).
  if equal(Depending,[]) then
    HardCloseModuleInDB(ModuleName).
    Status := success
  else
    Status := modules-depend-on-this-module
  fi
endlet

process HardCloseModuleInDB(ModuleName : str) is
let
  Changed : list
in
  DeleteEditors(ModuleName).
  snd-msg(close-module-in-db(ModuleName)).
  rec-msg(changed-modules(Changed?)).
  snd-msg(notify-about-changed-modules(Changed, "sdf")) .
  rec-msg(notify-about-changed-modules-done)
endlet


process CloseModuleInUI(ModuleName : str) is
  snd-msg(ui-delete-modules([ModuleName]))

process CloseModulesInUI(Modules : list) is
  snd-msg(ui-delete-modules(Modules))

process RenameModuleInDB(Old : str, New : str, Path : str, Changed : list?)
is
  snd-msg(rename-module-in-db(Old, New, Path)) .
  rec-msg(renaming-module-done(Old, Changed?))

process CopyModuleInDB(Old : str, New : str, Path : str, Status : term?,
                       Changed : list?)
is
  snd-msg(copy-module-in-db(Old, New, Path)) .
  (
    rec-msg(copy-done(Old, Changed?))
  +
    rec-msg(copy-not-done(Old)).
    Status := module-not-copied
  )

process AddImportInDB(Mod : str, Import : str)
is
  snd-msg(add-import-in-db(Mod, Import)) .
  rec-msg(add-import-done(Mod))

process RemoveImportInDB(Mod : str, Import : str, Path : str)
is
  snd-msg(remove-import-in-db(Mod, Import, Path)) .
  rec-msg(remove-import-done)

process CheckExistence(Name : str, FileName : str, Status : term?) is
    snd-msg(is-module-in-db(Name)) .
    (
      rec-msg(exists-in-module-db(Name)).
      Status := module-exists-in-db
    +
      rec-msg(not-exists-in-module-db(Name))
    ).
    snd-msg(io-exists-file(FileName)) .
    (
      rec-msg(io-file-exists) .
      Status := module-exists-on-disk
      +
      rec-msg(io-file-not-exists)
    )

process DeleteEditors(Module : str) is
let
  Depending : list,
  Mod : str
in
  snd-msg(delete-editors-for-module(Module)).
  snd-msg(get-all-depending-modules(Module)) .
  rec-msg(all-depending-modules(Depending?)).
  if not-equal(Depending, []) then
    Mod := first(Depending) .
    snd-msg(delete-editors-for-module(Mod)) .
    Depending := next(Depending)
  fi *
  if equal(Depending, []) then
    tau
  fi
endlet

process HandleRenameModuleErrors(Old : str, New : str, Status : term) is
  if not-equal(Status, success) then
    snd-note(ui-status(errorf("Error during renaming of %s to %s: %s\n",
                            [Old, New, Status])))
  else
    tau
  fi

process HandleCopyModuleErrors(Old : str, New : str, Status : term) is
  if not-equal(Status, success) then
    snd-note(ui-status(errorf("Error during copying of %s to %s: %s\n",
                            [Old, New, Status])))
  else
    tau
  fi



process PrintModule is
let
  Id : term,
  SdfTree : term,
  SdfText : str,
  AsfText : str,
  ModuleName : str,
  Path : str
in
  Id := process-id.
  (
    rec-msg(print-module(ModuleName?)) .
    snd-note(ui-status(statf(Id,"Printing %s",[ModuleName]))) .
    snd-msg(get-sdf2-path-from-db(ModuleName)) .
    rec-msg(path(Path?)) .
    snd-msg(get-sdf2-asfix(ModuleName)) .
    rec-msg(syntax(SdfTree?)) .
    snd-msg(unparse-to-html(SdfTree)) .
    rec-msg(unparsed-text(SdfText?)) .
    snd-msg(get-eqs-text(ModuleName)) .
    (
      rec-msg(eqs-text(ModuleName, AsfText?)) .
      snd-msg(print-module-text(ModuleName, Path, SdfText, AsfText))
    +
      rec-msg(no-eqs-text(ModuleName)) .
      snd-msg(print-module-text(ModuleName, Path, SdfText))
    ) .
    rec-msg(module-text-printed(ModuleName)) .
    snd-note(ui-status(endstat(Id))) .
    snd-msg(module-printed(ModuleName))
  ) *
  delta
endlet



process ClearAll is
let
  Id : term,
  Module : str,
  Modules: list
in
  Id := process-id.
  (
    rec-msg(clear-all) .
    snd-note(ui-status(stat(Id,"Clearing"))) .
    snd-msg(get-all-module-names) .
    rec-msg(all-module-names(Modules?)) .
    (
      if not-equal(Modules, []) then
        Module := first(Modules) .
        snd-msg(delete-editors-for-module(Module)) .
        Modules := next(Modules)
      fi
    ) * if equal(Modules, []) then
      tau
    fi .
    snd-msg(clear-module-db) .
    snd-note(ui-status(endstat(Id))) .
    snd-msg(cleared-all)
  ) *
  delta
endlet


process ProcessEqsTree(Module : str, Tree : term) is
let
  NewTree : term
in
  if not-equal(Tree, error-tree) then
    snd-msg(postprocess-semantics-hook(Tree)) .
    rec-msg(postprocess-semantics-hook-result(NewTree?)) .
    snd-msg(update-eqs-tree-in-db(Module, tree(NewTree))) .
    NewTree := no-tree .
    rec-msg(eqs-updated)
  else
    tau
  fi
endlet

process ParseAllEquations(ModName : str) is
let
  ModuleName : str,
  Module : str,
  Modules : list,
  EqsText : str,
  EqsTree : term,
  Nonterminal : str,
  ParseTree : term,
  Errors : term,
  ModuleId : term
in
  snd-msg(get-rules-top-sort) .
  rec-msg(set-rules-top-sort(sort(Nonterminal?))) .
  snd-msg(eqs-not-available-for-modules(ModName)) .
  rec-msg(eqs-needed-for-modules(Modules?)).
  (
   if not-equal(Modules, []) then
     Module := first(Modules).
     Modules := next(Modules).
     snd-msg(get-eqs-text(Module)).
     (
      rec-msg(eqs-text(Module, EqsText?)).
      ModuleId := quote(eqs(Module)) .
      ParseString(ModuleId, Nonterminal, EqsText, ParseTree?, Errors?) .
      ProcessParseError(Module, Errors, "asf") .
      ProcessEqsTree(Module, ParseTree) .
      ParseTree := no-tree
    +
      rec-msg(no-eqs-text(Module))
    )
    fi
  )*
  if equal(Modules,[]) then
    tau
  fi
endlet

process GetImportsForRenaming(ModuleName : str, Imports : term?) is
let
  Modules : list
in
  printf("DEBUG:all sdf-modules not needed!(%f,%d)\n", "/export/scratch1/jong/meta/install/share/meta/process-eqs.tb", 60) .
  snd-msg(get-all-modules) .
  rec-msg(all-modules(Modules?)) .
  snd-msg(sm-get-all-needed-imports(Modules, ModuleName)) .
  Modules := [] .
  rec-msg(sm-all-needed-imports(Imports?))
endlet


process GetEquations is
let
  ModuleName : str,
  Equations : term,
  AllEquations : term,
  Modules : list,
  NewEquations : list,
  Imports : term,
  Module : str,
  Renamings : term,
  FormalName : term,
  Parameters : term,
  ImportTuple : term,
  ModuleNames : list,
  RenamedEquations : list,
  ImportedModuleName : str
in
  (
    rec-msg(get-all-equations(ModuleName?)) .
    ParseAllEquations(ModuleName) .
    snd-msg(all-equations-available(ModuleName)) .
    (
      rec-msg(equations-available) .
      NewEquations := [] .
      snd-msg(get-all-imported-module-names(ModuleName)) .
      rec-msg(all-imported-module-names(ModuleNames?)) .
      GetImportsForRenaming(ModuleName, Imports?) .
      if not-equal(ModuleNames, []) then
        Module := first(ModuleNames) .
        ModuleNames := next(ModuleNames) .
        snd-msg(get-equations-for-module(Module)) .
        (
           rec-msg(equations(Equations?)) .
           snd-msg(sr-rename-module(Imports, Module, Equations)) .
           Equations := no-tree .
           rec-msg(sr-renamed-module(RenamedEquations?)) .
           NewEquations := join(NewEquations, RenamedEquations) .
           RenamedEquations := []
        +
           rec-msg(no-equations)
        )
      fi
      *
      if equal(ModuleNames,[]) then
        snd-msg(postprocess-collected-semantics-hook(ModuleName, NewEquations)).
        NewEquations := [] .
        rec-msg(postprocess-collected-semantics-hook-result(ModuleName, AllEquations?)).
        snd-msg(all-equations(AllEquations)) .
        AllEquations := no-tree
      fi
    +
      rec-msg(equations-incomplete) .
      snd-msg(equations-incomplete)
    )
  )*delta
endlet




process Compile-module is
let
  ModuleName : str,
  OutputFile : str,
  ErrorMsg : str,
  Id : term,
  Syntax : term,
  Equations : term
in
    Id := process-id.
    (
      rec-msg(compile-module(ModuleName?)) .
      snd-note(ui-status(statf(Id, "Compiling %s", [ModuleName]))).
      snd-msg(get-all-equations(ModuleName)) .
      (
        rec-msg(all-equations(Equations?)) .
        snd-msg(compile-semantics-hook(ModuleName, Equations)).
        rec-msg(compile-semantics-hook-done(ModuleName))
      +
        rec-msg(equations-incomplete) .
        snd-note(ui-status(errorf("Specification incomplete for %s",
                                  [ModuleName])))
      ) .
      snd-msg(compilation-ready(ModuleName)) .
      snd-note(ui-status(endstat(Id)))
    ) *
    delta
endlet



process Save-modules is
let
  Id : term,
  Syntax : term,
  Eqs : term,
  Module : term,
  Path : str,
  Modules : list,
  Table : term,
  Text : str,
  ErrorMessage : str,
  FileName : str
in
  Id := process-id.
  (
    rec-msg(save-module(Module?)).
    snd-note(ui-status(statf(Id, "Saving %s",[Module]))) .
    snd-msg(get-path-from-db(Module)).
    rec-msg(path(Path?)).
    snd-msg(io-get-filename(Path, Module, ".asf.baf")) .
    rec-msg(io-filename(FileName?)) .
    snd-msg(get-eqs-tree(Module)).
    (
      rec-msg(tree(Eqs?)).
      snd-msg(io-write-term-file(FileName, Eqs)).
      (
        rec-msg(io-file-written)
      +
        rec-msg(io-file-not-written(ErrorMessage?)) .
        snd-note(ui-status(errorf("Saving failed: %s", [ErrorMessage])))
      )
    +
      rec-msg(no-eqs)
    +
      rec-msg(unavailable)
    ).
    snd-msg(io-get-filename(Path, Module, ".trm.tbl")) .
    rec-msg(io-filename(FileName?)) .
    snd-msg(get-table-from-db(trm(Module))).
    (
      rec-msg(table(Table?)).
      snd-msg(io-write-term-file(FileName, Table)).
      (
        rec-msg(io-file-written)
      +
        rec-msg(io-file-not-written(ErrorMessage?)) .
        snd-note(ui-status(errorf("Saving failed: %s", [ErrorMessage])))
      )
    +
      rec-msg(no-table)
    ).
    snd-msg(io-get-filename(Path, Module, ".asf.tbl")) .
    rec-msg(io-filename(FileName?)) .
    snd-msg(get-table-from-db(eqs(Module))).
    (
      rec-msg(table(Table?)).
      snd-msg(io-write-term-file(FileName, Table)) .
      (
        rec-msg(io-file-written)
      +
        rec-msg(io-file-not-written(ErrorMessage?)) .
        snd-note(ui-status(errorf("Saving failed: %s", [ErrorMessage])))
      )
    +
      rec-msg(no-table)
    ).
    snd-note(ui-status(endstat(Id))) .
    snd-msg(saved-module(Module))
  +
    rec-msg(save-sdf-module(Module?)).
    snd-note(ui-status(statf(Id, "Saving %s",[Module]))) .
    snd-msg(get-path-from-db(Module)).
    rec-msg(path(Path?)).
    snd-msg(io-get-filename(Path, Module, ".sdf")) .
    rec-msg(io-filename(FileName?)) .
    snd-msg(get-sdf2-asfix(Module)).
    (
      rec-msg(syntax(Syntax?)) .
      snd-msg(unparse(Syntax)) .
      rec-msg(unparsed-text(Text?)) .
      snd-msg(io-write-text-file(FileName, [Text])) .
      (
        rec-msg(io-file-written)
      +
        rec-msg(io-file-not-written(ErrorMessage?)) .
        snd-note(ui-status(errorf("Saving failed: %s", [ErrorMessage])))
      )
    ) .
    snd-note(ui-status(endstat(Id))) .
    snd-msg(saved-sdf-module(Module))
  +
    rec-msg(save-asfsdf-module(Module?)).
    snd-note(ui-status(statf(Id, "Saving %s",[Module]))) .
    snd-msg(get-path-from-db(Module)).
    rec-msg(path(Path?)).
    snd-msg(io-get-filename(Path, Module, ".sdf")) .
    rec-msg(io-filename(FileName?)) .
    snd-msg(get-sdf2-asfix(Module)).
    (
      rec-msg(syntax(Syntax?)) .
      snd-msg(unparse(Syntax)) .
      rec-msg(unparsed-text(Text?)) .
      snd-msg(io-write-text-file(FileName, [Text])) .
      (
        rec-msg(io-file-written)
      +
        rec-msg(io-file-not-written(ErrorMessage?)) .
        snd-note(ui-status(errorf("Saving failed: %s", [ErrorMessage])))
      )
    ) .
    snd-msg(get-eqs-text(Module)).
    (
      rec-msg(eqs-text(Module, Text?)) .
      snd-msg(io-get-filename(Path, Module, ".asf")) .
      rec-msg(io-filename(FileName?)) .
      snd-msg(io-write-text-file(FileName, [Text])) .
      (
        rec-msg(io-file-written)
      +
        rec-msg(io-file-not-written(ErrorMessage?)) .
        snd-note(ui-status(errorf("Saving failed: %s", [ErrorMessage])))
      )
    +
      rec-msg(no-eqs-text(Module))
    ).
    snd-note(ui-status(endstat(Id))) .
    snd-msg(saved-asfsdf-module(Module))

  +
    rec-msg(save-all) .
    snd-note(ui-status(errorf("Saving not yet implemented!",[])))
  )*
  delta
endlet



tool genadapt is {
  command = "gen-adapter"
}

tool termgenadapt is {
  command = "gen-adapter -term-output"
}

process ADAPTER(Id : genadapt, Cmd : str, Inp : str, Outp : str?) is
   snd-eval(Id,cmd(Cmd, input(Inp))).
   rec-value(Id, output(Outp?))

process TERM-IN-ADAPTER(Id : genadapt, Cmd : str, Inp : term, Outp : str?) is
   snd-eval(Id,cmd(Cmd, input-term(Inp))).
   rec-value(Id, output(Outp?))

process TERM-IN-OUT-ADAPTER(Id : termgenadapt, Cmd : str,
                            Inp : term, Outp : term?) is
   snd-eval(Id, cmd(Cmd, input-term(Inp))).
   rec-value(Id, output(Outp?))

process Execute(Cmd : str, Inp : term, Outp : term?) is
let
  TERMGENADAPT : termgenadapt
in
  execute(termgenadapt, TERMGENADAPT?) .
  snd-eval(TERMGENADAPT, cmd(Cmd, input-term(Inp))) .
  rec-value(TERMGENADAPT, output(Outp?)) .
  snd-terminate(TERMGENADAPT, termgenadapt)
endlet

process GenAdapt is
let
  GENADAPT : genadapt,
  TERMGENADAPT : termgenadapt,
  Action : str,
  OutStr : str,
  InStr : str,
  FunSym : str,
  Id : term,
  STree : term,
  RTree : term
in
  execute(genadapt, GENADAPT?) .
  execute(termgenadapt, TERMGENADAPT?) .
  (
    rec-msg(gen-adapter-activate(Id?, Action?)).
    ADAPTER(GENADAPT, Action, "", OutStr?) .
    snd-msg(gen-adapter-result(Id, OutStr))
  +
    rec-msg(gen-adapter-string-to-string-evaluate(Id?,Action?,InStr?)).
    ADAPTER(GENADAPT, Action, InStr, OutStr?) .
    snd-msg(gen-adapter-string-to-string-result(Id,OutStr))
  +
    rec-msg(gen-adapter-term-to-string-evaluate(Id?,Action?,STree?)).
    TERM-IN-ADAPTER(GENADAPT, Action, STree, OutStr?) .
    snd-msg(gen-adapter-term-to-string-result(Id,OutStr))
  +
    rec-msg(gen-adapter-term-evaluate(Id?,Action?,STree?)).
    TERM-IN-OUT-ADAPTER(TERMGENADAPT, Action, STree, RTree?) .
    snd-msg(gen-adapter-term-result(Id,RTree))
  )*
  delta
endlet

toolbus(GenAdapt)


tool se is {
  command = "se"
}







process SE is
let
  EditorId : term,
  Focus : term,
  Error : list,
  Focuses : list,
  FocusList : list,
  Location : int,
  SE : se,
  Text : str,
  Move : term,
  Nonterminal : str,
  Tree : term,
  ModifiedStatus : term,
  Msg : term,
  PosInfo : term
in
  execute(se, SE?) .
  (
    rec-msg(initialize-structure-editor(EditorId?, Text?, Tree?)) .
    if equal(Tree,none) then
      snd-eval(SE, new-editor-given-text(EditorId, Text))
    else
      snd-eval(SE, new-editor-given-tree(EditorId, Tree))
    fi .
    rec-value(SE, initial-focus(Focus?)) .
    snd-msg(initial-focus(Focus))
  +
    rec-msg(replace-focus(EditorId?, Focus?, Tree?)) .
    snd-do(SE, replace-focus(EditorId, Focus, Tree))
  +
    rec-msg(move-focus-to-root(EditorId?)) .
    snd-eval(SE, move-focus-to-root(EditorId)) .
    rec-value(SE, focus(Focus?)) .
    snd-msg(focus-moved(EditorId, Focus))
  +
    rec-msg(move-focus(EditorId?, Move?)) .
    snd-eval(SE, move-focus(EditorId, Move)) .
    rec-value(SE, focus(Focus?)) .
    snd-note(set-focus(EditorId, Focus))
  +
    rec-msg(invalidate-tree(EditorId?)) .
    snd-eval(SE, invalidate-tree(EditorId)) .
    rec-value(SE, focus(Focus?)) .
    snd-msg(invalidation-done(EditorId, Focus))
  +
    rec-msg(set-current-location(EditorId?, Location?)) .
    snd-eval(SE, set-focus(EditorId, Location)) .
    rec-value(SE, focus(Focus?)) .
    snd-note(set-focus(EditorId, Focus))
  +
    rec-msg(set-focus-at-posinfo(EditorId?, PosInfo?)) .
    snd-eval(SE, get-focus-at-posinfo(EditorId, PosInfo)) .
    rec-value(SE, focus(Focus?)) .
    snd-note(set-focus(EditorId, Focus))
  +
    rec-msg(get-tree(EditorId?)) .
    snd-eval(SE, get-parse-tree(EditorId)) .
    (
      rec-value(SE, parse-tree(Tree?)) .
      snd-msg(tree(Tree))
    +
      rec-value(SE, no-such-editor) .
      snd-msg(no-tree)
    )
  +
    rec-msg(get-focussed-tree(EditorId?)) .
    snd-eval(SE, get-focussed-tree(EditorId)) .
    (
      rec-value(SE, parse-tree(Tree?)) .
      snd-msg(tree(Tree))
    +
      rec-value(SE, no-parse-tree) .
      snd-msg(no-tree)
    )
  +
    rec-msg(replace-focussed-tree(EditorId?, Tree?)) .
    snd-eval(SE, replace-focussed-tree(EditorId, Tree)) .
    rec-value(SE, focus(Focus?)) .
    snd-msg(focus(Focus))
  +
    rec-msg(check-tree-sort(Nonterminal?, Tree?)) .
    snd-eval(SE, check-tree-sort(Nonterminal, Tree)) .
    rec-value(SE, msg(Msg?)) .
    snd-msg(Msg)
  +
    rec-msg(get-focus-sort(EditorId?)) .
    snd-eval(SE, get-focus-sort(EditorId)) .
    (
      rec-value(SE, focus-sort(Nonterminal?)) .
      snd-msg(focus-sort(Nonterminal))
    +
      rec-value(SE, no-focus) .
      snd-msg(no-focus)
    )
  +
    rec-msg(get-dirty-focuses(EditorId?)) .
    snd-eval(SE, get-dirty-focuses(EditorId)) .
    (
      rec-value(SE, foci(FocusList?))
      +
      rec-value(SE, no-such-editor) .
      FocusList := []
    ) .
    snd-msg(dirty-focuses(FocusList))
  +
    rec-msg(get-error-position(Focus?, Error?)) .
    snd-eval(SE, calc-error-location(Focus, Error)) .
    rec-value(SE, error-position(Location?)) .
    snd-msg(error-position(Location))
  +
    rec-msg(delete-structure-editor(EditorId?)).
    snd-do(SE, remove-tree(EditorId))
  +
    rec-msg(set-modified(EditorId?)) .
    snd-do(SE, modify(EditorId))
  +
    rec-msg(get-modified-status(EditorId?)).
    snd-eval(SE, get-modification-status(EditorId)).
    rec-value(SE, modification-status(ModifiedStatus?)).
    snd-msg(modified-status(EditorId, ModifiedStatus))
  ) *
  delta
endlet







process GetParseTable is
let
  ModuleId : term,
  TableType : term,
  Table : term,
  Syntax : term,
  ErrorMsg : str,
  Id : int,
  Str : str
in
Id := process-id.
(
  rec-msg(get-parsetable(ModuleId?)) .
  Str := first(args(ModuleId)).
  snd-msg(get-table-from-db(ModuleId)) .
  (
    rec-msg(table(Table?)).
    snd-msg(parse-table(Table))
  +
    rec-msg(no-table) .
    snd-note(ui-status(statf(Id, "Generating parsetable %s",[Str]))).
    snd-msg(get-all-sdf2-definitions(Str)).
    (
      rec-msg(syntax(Syntax?)).
      snd-msg(preprocess-syntax-hook(ModuleId, Syntax)).
      rec-msg(preprocess-syntax-hook-result(ModuleId, Syntax?)).
      snd-msg(generate-parsetable(Syntax, ModuleId)).
      Syntax := no-tree .
      (
        rec-msg(parsetable(Table?)).
        snd-msg(add-parse-table-to-db(ModuleId, Table)) .
        rec-msg(parse-table-added).
        snd-note(ui-status(endstat(Id))) .
        snd-msg(parse-table(Table)) .
        Table := no-table
      +
        rec-msg(no-parsetable).
        snd-note(ui-status(endstat(Id))) .
        snd-note(ui-status(error("Unexpected error in definition"))).
        snd-msg(no-parse-table(ModuleId))
      )
    +
      rec-msg(no-syntax(ErrorMsg?)) .
      snd-note(ui-status(endstat(Id))) .
      snd-note(ui-status(errorf("%s",[ErrorMsg]))).
      snd-msg(no-parse-table(ModuleId))
    )
  )
) *
delta
endlet







process Set-parsetable is
let
  ModuleId : term,
  TableType : term,
  Table : term,
  Id : int
in
Id := process-id.
(
  rec-msg(set-parsetable(ModuleId?)) .
  snd-msg(get-parsetable(ModuleId)) .
  (
    rec-msg(parse-table(Table?)) .
    ReopenLanguage(ModuleId, Table)
  +
    rec-msg(no-parse-table(ModuleId)) .
    snd-msg(parsetable-not-set(ModuleId))
  )
) *
delta
endlet


process ReopenLanguage(ModuleId : term, Table : term) is
  snd-msg(close-language(ModuleId)) .
  snd-msg(open-language-from-term(ModuleId, Table)).
  (
    rec-msg(language-opened(ModuleId)).
    snd-msg(parsetable-set(ModuleId))
    +
    rec-msg(language-not-opened(ModuleId)).
    snd-msg(parsetable-not-set(ModuleId))
  )




process DumpParseTable is
let
  Id : term,
  ModuleName : str,
  FileName : str,
  Table : term,
  Path : str,
  ErrorMessage : str
in
  Id := process-id.

  (
    (
      rec-msg(dump-parse-table(ModuleName?)) .
      FileName := ""
    +
      rec-msg(dump-parse-table-given-file(ModuleName?, FileName?))
    ) .
    snd-note(ui-status(statf(Id,"Dumping parse table for %s",[ModuleName]))) .
    snd-msg(get-parsetable(trm(ModuleName))) .
    (
      rec-msg(parse-table(Table?)) .
      snd-msg(get-path-from-db(ModuleName)) .
      rec-msg(path(Path?)) .
      if equal(FileName, "") then
        snd-msg(io-get-filename(Path, ModuleName, ".trm.tbl")) .
        rec-msg(io-filename(FileName?))
      else
        tau
      fi .
      snd-msg(io-write-term-file(FileName, Table)) .
      (
        rec-msg(io-file-written)
      +
        rec-msg(io-file-not-written(ErrorMessage?))
      )
    +
      rec-msg(no-parse-table(trm(ModuleName)))
    ) .
    snd-note(ui-status(endstat(Id))) .
    snd-msg(parse-table-dumped)
  ) * delta

endlet




process Open-Sdf2-Language is
  (
    rec-msg(open-sdf2-language) .
    snd-msg(open-language(trm("Sdf2"), "/export/scratch1/jong/meta/install/share/pgen/Sdf2.baf")) .
    (
      rec-msg(language-opened(trm("Sdf2"))) .
      snd-msg(sdf2-language-opened)
    +
      rec-msg(language-not-opened(trm("Sdf2"))) .
      snd-msg(sdf2-language-not-opened)
    )
  ) *
    delta




process GetText (EditorId : term, Text : str?, Focus : term?, Status : term?) is
let
  DirtyFoci : list
in
  snd-msg(get-dirty-focuses(EditorId)) .
  rec-msg(dirty-focuses(DirtyFoci?)) .
  if not-equal(DirtyFoci, []) then
    Focus := first(DirtyFoci).
    DirtyFoci := next(DirtyFoci).
    snd-note(get-focus-text(EditorId, Focus)).
    (
      rec-msg(focus-text(EditorId, Text?)) .
      Status := parse-needed
    +

      rec-note(delete-editor(EditorId)) .
      Text := "" .
      Status := no-parse-needed
    )
  else
    Text := "" .
    Status := no-parse-needed
  fi
endlet

process ParseFocusses is
let
  Id : term,
  Focus : term,
  Text : str,
  Type : str,
  ModuleName : str,
  EditorId : term,
  Nonterminal : str,
  Tree : term,
  Errors : term,
  ModuleId : term,
  Status : term
in
  Id := process-id .
  (
    rec-msg(parse-focusses(EditorId?, ModuleId?)) .
    subscribe(delete-editor(EditorId)) .
    Type := fun(ModuleId) .
    ModuleName := first(args(ModuleId)).
    if equal(Type, "eqs") then
      snd-msg(get-rules-top-sort) .
      rec-msg(set-rules-top-sort(sort(Nonterminal?)))
    else
      Nonterminal := ""
    fi .
    GetText(EditorId, Text?, Focus?, Status?) .
    if equal(Status, parse-needed) then
      UpdateTextInModuleDb(Type, ModuleName, Text).
      ParseString(ModuleId, Nonterminal, Text, Tree?, Errors?) .
      PrepareParseErrorForEditor(ModuleId, EditorId, Focus, Errors) .
      ProcessTree(ModuleId, EditorId, Focus, Tree) .
      Tree := no-tree
    else
      snd-msg(parse-ok(ModuleId))
    fi .
    unsubscribe(delete-editor(EditorId))
  )
  *
  delta
endlet

process UpdateTextInModuleDb(Type : str, ModuleName : str, Text : str) is
  if equal(Type, "eqs") then
    snd-msg(update-eqs-text-in-db(ModuleName, text(Text))) .
    rec-msg(eqs-text-updated(ModuleName))
  else
    tau
  fi
process ButtonActionReceiver is
let
  ButtonName : list,
  EditorType : str,
  ModuleName : str,
  Actions : list,
  EditorId : term,
  Argument : term
in
  (
    (
    rec-msg(extra-button-action(ButtonName?, EditorType?, ModuleName?,EditorId?)) .
    Argument := none
    +
    rec-msg(extra-button-action(ButtonName?, Argument?, EditorType?, ModuleName?,
                                EditorId?))
    ) .
    snd-msg(get-button-actions(ButtonName,EditorType,ModuleName)).
    rec-msg(button-actions(ButtonName,EditorType,ModuleName,Actions?)).
    PerformButtonActions(EditorId, Argument, Actions)
  )* delta
endlet

process PerformButtonActions(EditorId : term, StackTop : term, Actions : list) is
let
  ButtonActions : list,
  ButtonAction : term,
  FunName : str,
  Stack : list
in
  if equal(StackTop,none) then
    Stack := []
  else
    Stack := [StackTop]
  fi .
  ButtonActions := quote(Actions) .
  (
    if not-equal(ButtonActions, []) then
      ButtonAction := first(ButtonActions) .
      ButtonActions := next(ButtonActions) .
      FunName := fun(ButtonAction) .
      if equal(FunName, "if-equal") then
        IfEqual(ButtonAction, Stack, ButtonActions, Stack?, ButtonActions?)
      else
        snd-msg(ButtonAction, Stack, EditorId) .
        (
          rec-msg(stack(Stack?), EditorId)
        +
          rec-msg(empty-stack, EditorId) .
          ButtonActions := []
        +
          rec-msg(error-stack, EditorId) .
          ButtonActions := [].
          snd-note(ui-status(
            errorf("An error occurred while processing the action: %t",
                   [ButtonAction])))
        )
      fi
    fi
  )*
  if equal(ButtonActions, []) then
    tau
  fi
endlet

process StackPopTerm(Stack : list, NewStack : list?, Top : term?) is
  Top := first(Stack).
  NewStack := next(Stack)

process StackPopString(Stack : list, NewStack : list?, Top : str?) is
let
  TopTerm : term
in
  StackPopTerm(Stack,NewStack?,TopTerm?).
  Top := first(args(TopTerm))
endlet

process StackPushTerm(Stack : list, NewStack : list?, Top : term) is
  NewStack := join(Top, Stack)

process StackPushString(Stack : list, NewStack : list?, Top : str) is
  StackPushTerm(Stack,NewStack?,quote(str(Top)))

process StackPushInt(Stack : list, NewStack : list?, Top : int) is
  StackPushTerm(Stack,NewStack?, quote(int(Top)))

process StackPushFile(Stack : list, NewStack : list?, Top : str) is
  StackPushTerm(Stack,NewStack?, quote(file(Top)))

process StackPushPath(Stack : list, NewStack : list?, Top : str) is
  StackPushTerm(Stack,NewStack?, quote(path(Top)))

process ReturnSuccess(EditorId : term, Stack : list) is
  snd-msg(stack(Stack), EditorId)

process ReturnFailed(EditorId : term, Stack : list) is
  snd-msg(error-stack, EditorId)

process ReturnAbort(EditorId : term, Stack : list) is
  snd-msg(empty-stack, EditorId)

process ButtonActionExecutor is
let
  ModuleName : str,
  ArgList : list,
  Stack : list,
  EditorId : term,
  EditorId2 : term,
  STree : term,
  SList : list,
  RTree : term,
  Error : term,
  Trees : list,
  ButtonName : str,
  SortName : str,
  FilePath : str,
  NewModName : str,
  FileName : str,
  EditorName : str,
  FuncName : str,
  FunSym : str,
  String : str,
  NrOfArgs : int,
  Location : int,
  Integer : int,
  Query : str,
  Action : str,
  OutStr : str,
  InStr : str,
  Name : str,
  Path : str,
  Tree : term,
  Text : str,
  TimeStamp : int,
  ErrorMessage : str,
  Mode : term,
  Ext : str
in
   (
      rec-msg(apply(FuncName?, SortName?, NrOfArgs?), Stack?, EditorId?) .
      ArgList := [] .
      (
        if greater(NrOfArgs, 0) then
          StackPopTerm(Stack,Stack?,STree?).
          NrOfArgs := sub(NrOfArgs, 1) .
          ArgList := join(ArgList, STree)
        fi
      ) *
      if equal(NrOfArgs, 0) then
        tau
      fi .
      snd-msg(apply-function(FuncName, SortName, ArgList)) .
      rec-msg(tree(RTree?)) .
      if not-equal(RTree, error-tree) then
        StackPushTerm(Stack,Stack?,RTree).
        ReturnSuccess(EditorId,Stack)
      else
        ReturnFailed(EditorId, Stack)
      fi
      +
      rec-msg(activate(Action?), Stack?, EditorId?) .
      snd-msg(gen-adapter-activate(EditorId, Action)).
      rec-msg(gen-adapter-result(EditorId, OutStr?)).
      if not-equal(OutStr, "") then
        StackPushString(Stack,Stack?,OutStr)
      else
        tau
      fi.
      ReturnSuccess(EditorId,Stack)
    +
      rec-msg(activate-given-tree(Action?), Stack?, EditorId?) .
      StackPopTerm(Stack,Stack?,STree?).
      FunSym := fun(STree) .
      if not-equal(FunSym, "str") then
        snd-msg(gen-adapter-term-to-string-evaluate(EditorId,Action,STree)).
        rec-msg(gen-adapter-term-to-string-result(EditorId,OutStr?))
      else
        InStr := first(args(STree)) .
        snd-msg(gen-adapter-string-to-string-evaluate(EditorId,Action,InStr)).
        rec-msg(gen-adapter-string-to-string-result(EditorId,OutStr?))
      fi.
      if not-equal(OutStr, "") then
          StackPushString(Stack,Stack?,OutStr)
      else
          tau
      fi.
      ReturnSuccess(EditorId,Stack)
    +
      rec-msg(execute-action(Action?), Stack?, EditorId?) .
      StackPopTerm(Stack,Stack?,STree?).
      snd-msg(gen-adapter-term-evaluate(EditorId,Action, STree)).
      rec-msg(gen-adapter-term-result(EditorId,RTree?)).
      if not-equal(RTree, error-tree) then
        StackPushTerm(Stack,Stack?,RTree).
        ReturnSuccess(EditorId,Stack)
      else
        ReturnFailed(EditorId,Stack)
      fi
    +
    rec-msg(move-left, Stack?, EditorId?).
    snd-msg(move-focus(EditorId,"Left")) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(move-right, Stack?, EditorId?).
    snd-msg(move-focus(EditorId,"Right")) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(move-up, Stack?, EditorId?).
    snd-msg(move-focus(EditorId,"Up")) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(move-down, Stack?, EditorId?).
    snd-msg(move-focus(EditorId,"Down")) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(parse-action, Stack?, EditorId?) .
    StackPopString(Stack,Stack?,NewModName?) .
    ParseTerm(EditorId, NewModName) .
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(parse-syntax-action, Stack?, EditorId?).
    StackPopString(Stack,Stack?,NewModName?) .
    ParseSyntax(EditorId,NewModName).
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(parse-equations-action, Stack?, EditorId?).
    StackPopString(Stack,Stack?,NewModName?) .
    ParseEquations(EditorId,NewModName).
    ReturnSuccess(EditorId,Stack)
    +
    rec-msg(get-root, Stack?, EditorId?) .
    StackPopString(Stack, Stack?, ModuleName?) .
    GetTree(EditorId, ModuleName, RTree?) .
    if not-equal(RTree, error-tree) then
      StackPushTerm(Stack,Stack?,RTree).
      ReturnSuccess(EditorId,Stack)
    else
      ReturnFailed(EditorId,Stack)
    fi
      +
        rec-msg(set-root, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
        ReplaceRoot(EditorId, STree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(get-focus, Stack?, EditorId?) .
        GetFocus(EditorId, RTree?) .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnFailed(EditorId,Stack)
        fi
      +
        rec-msg(set-focus, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?).
        ReplaceFocus(EditorId, STree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(check-sort(SortName?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?).
        CheckTreeSort(STree, SortName, RTree?) .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnAbort(EditorId,Stack)
        fi
      +
        rec-msg(reduce, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,NewModName?) .
        StackPopTerm(Stack,Stack?,STree?) .
        ReduceTerm(STree, NewModName, RTree?) .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnAbort(EditorId,Stack)
        fi
      +
        rec-msg(get-other-focus(NewModName?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?).
        FunSym := fun(STree) .
        if equal(FunSym, "path") then
          FilePath := first(args(STree)) .
          snd-msg(check-editor-id(FilePath, NewModName)) .
          (
            rec-msg(existing-editor(FilePath?, EditorId2?)).
            GetFocus(EditorId2, RTree?) .
            if not-equal(RTree, error-tree) then
              StackPushTerm(Stack,Stack?,RTree) .
              ReturnSuccess(EditorId,Stack)
            else
              snd-note(ui-status(errorf("please set a focus %s",
                                        [FilePath]))) .
              ReturnAbort(EditorId,Stack)
            fi
          +
            rec-msg(non-existing-editor(FilePath?)).
            snd-note(ui-status(errorf("editor for %s not active",
                                      [FilePath]))) .
            ReturnAbort(EditorId,Stack)
          )
        else
          ReturnFailed(EditorId,Stack)
        fi
      +
        rec-msg(push-editor-name, Stack?, EditorId?) .
        snd-msg(get-editor-name(EditorId)) .
        rec-msg(editor-name(FileName?)) .
        StackPushString(Stack,Stack?,FileName) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(activate-editor, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,NewModName?) .
        StackPopString(Stack,Stack?,FileName?) .
        StackPopTerm(Stack,Stack?,STree?) .
        FunSym := fun(STree) .
        if equal(FunSym, "str") then
          String := first(args(STree)) .
          ActivateEditorWithString(String, NewModName, FileName)
        else
          ActivateEditorWithTree(STree, NewModName, FileName)
        fi .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(close-editor, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,NewModName?) .
        StackPopString(Stack,Stack?,FileName?) .
        CloseEditor(NewModName, FileName) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(send, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
        snd-msg(tree-send(STree)) .
        snd-msg(stack(Stack), EditorId?)
      +
        rec-msg(receive, Stack?, EditorId?) .
        rec-msg(tree-send(RTree?)) .
        StackPushTerm(Stack,Stack?,RTree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(parse(NewModName?, SortName?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
          FunSym := fun(STree) .
          if or(equal(FunSym, "file"), equal(FunSym, "path")) then
            FilePath := first(args(STree)) .
            GetTextFromFile(FilePath, String?) .
            ParseText(String, NewModName, SortName, RTree?, Error?) .
            ProcessParseError(NewModName, Error, "trm")
          else
            if equal(FunSym, "str") then
              String := first(args(STree)) .
              ParseText(String, NewModName, SortName, RTree?, Error?) .
              ProcessParseError(NewModName, Error, "trm")
            else
              RTree := error-tree
            fi
          fi .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnAbort(EditorId,Stack)
        fi
      +
        rec-msg(get-argument(NrOfArgs?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
        StackPushTerm(Stack,Stack?,STree) .
        snd-msg(get-argument-given-number(STree, NrOfArgs)) .
        rec-msg(tree(RTree?)) .
        if not-equal(RTree, error-tree) then
          StackPushTerm(Stack,Stack?,RTree) .
          ReturnSuccess(EditorId,Stack)
        else
          ReturnFailed(EditorId,Stack)
        fi
      +
        rec-msg(exists(FileName?), Stack?, EditorId?) .
        snd-msg(io-exists-file(FileName)) .
        (
          rec-msg(io-file-exists(FileName)) .
          ReturnSuccess(EditorId,Stack)
        +
          rec-msg(io-file-not-exists(FileName)) .
          snd-note(ui-status(errorf("%s does not exist",
                                    [FileName]))) .
          ReturnAbort(EditorId,Stack)
        )
      +
        rec-msg(locate(FileName?), Stack?, EditorId?) .
        snd-msg(locate-file(FileName)) .
        (
          rec-msg(file-location(FileName, FilePath?)) .
          StackPushPath(Stack,Stack?,FilePath) .
          ReturnSuccess(EditorId,Stack)
        +
          rec-msg(file-not-exists(FileName)) .
          snd-note(ui-status(errorf("%s does not exist",
                                    [FileName]))) .
          ReturnAbort(EditorId,Stack)
        )
      +
        rec-msg(push-active-module, Stack?, EditorId?) .
        subscribe(delete-editor(EditorId)) .
        snd-msg(get-editor-modulename(EditorId)) .
        (
          rec-msg(editor-modulename(EditorId,ModuleName?)) .
          StackPushString(Stack,Stack?,ModuleName) .
          ReturnSuccess(EditorId,Stack)
        +
          rec-note(delete-editor(EditorId)) .
          ReturnFailed(EditorId, Stack)
        )
      +
        rec-msg(push-modulename(String?), Stack?, EditorId?) .
        StackPushString(Stack,Stack?,String) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(push-filename(FileName?), Stack?, EditorId?) .
        StackPushFile(Stack,Stack?,FileName) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(push-string(String?), Stack?, EditorId?) .
        StackPushString(Stack,Stack?,String) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(push-integer(Integer?), Stack?, EditorId?) .
        StackPushInt(Stack,Stack?,Integer) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(push-term(Tree?), Stack?, EditorId?) .
        StackPushTerm(Stack,Stack?, Tree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(message(String?), Stack?, EditorId?) .
        snd-note(ui-status(errorf("%s", [String]))) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(show-tree, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?).
        ShowTree(STree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(show-area(NewModName?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,STree?) .
        FileName := first(args(STree)) .
        snd-msg(edit-term-file(NewModName, FileName)) .
        rec-msg(editor-opened(NewModName, EditorId2?)).
        ParseTerm(EditorId2, NewModName) .
        snd-msg(set-focus-at-posinfo(EditorId2, STree)) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(show-list, Stack?, EditorId?) .
        StackPopTerm(Stack, Stack?, STree?) .
        SList := first(args(STree)) .
        snd-msg(update-list-view(SList)) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(show-tree, Stack?, EditorId?) .
        StackPopTerm(Stack, Stack?, STree?) .
        ShowTree(STree) .
        ReturnSuccess(EditorId,Stack)
      +
        rec-msg(save-tree(Name?, Path?), Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,Tree?) .
        FunSym := fun(Tree) .
        if not-equal(FunSym, "str") then
          snd-msg(save-tree(Name,Path,Tree)) .
          rec-msg(save-done(Name))
        else
          Text := first(args(Tree)) .
          snd-msg(io-write-text-file(Path,[Text])).
          (
            rec-msg(io-file-written) .
            ReturnSuccess(EditorId, Stack)
          +
            rec-msg(io-file-not-written(ErrorMessage?)) .
            snd-note(ui-status(errorf("%s: %s",[FileName, ErrorMessage]))) .
            ReturnAbort(EditorId, Stack)
          )
        fi
      +
        rec-msg(read-tree(Path?), Stack?, EditorId?) .
        printf("not yet implemented at line %d", 497) .
        ReturnAbort(EditorId,Stack)
      +
        rec-msg(query(Query?), Stack?, EditorId?) .
        snd-msg(execute-query(EditorId, Query)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(edit-syntax, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(edit-syntax(ModuleName)) .
        rec-msg(editor-opened(ModuleName,EditorId2?)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(edit-equations, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(edit-equations(ModuleName)) .
        rec-msg(editor-opened(ModuleName,EditorId2?)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(save-module, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(save-module(ModuleName)).
        rec-msg(saved-module(ModuleName)).
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(revert-module, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(revert-module(ModuleName)) .
        rec-msg(module-reverted(ModuleName)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(close-module(Mode?), Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(close-module(ModuleName, Mode)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(delete-module, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(delete-module(ModuleName)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(open-module, Stack?, EditorId?) .
        StackPopString(Stack, Stack?, Ext?) .
        StackPopString(Stack, Stack?, Path?) .
        StackPopString(Stack, Stack?, ModuleName?) .
        snd-msg(open-initial-module(Path, ModuleName, Ext)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(new-module, Stack?, EditorId?) .
        StackPopString(Stack, Stack?, Ext?) .
        StackPopString(Stack, Stack?, Path?) .
        StackPopString(Stack, Stack?, ModuleName?) .
        snd-msg(create-new-module(Path, ModuleName)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(prompt-for-file(String?, Path?, Ext?), Stack?, EditorId?) .
        snd-msg(ask-for-file(String, Path, Ext)) .
        rec-msg(ask-for-file-result(FileName?)) .
        StackPushString(Stack,Stack?,FileName) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(edit-term, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,FileName?) .
        StackPopString(Stack,Stack?,NewModName?) .
        snd-msg(edit-term-file(NewModName, FileName)) .
        rec-msg(editor-opened(NewModName, EditorId2?)).
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(ask-question(String?), Stack?, EditorId?) .
        snd-msg(ask-question(String)) .
        rec-msg(ask-question-result(Tree?)) .
        StackPushTerm(Stack,Stack?,Tree) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(split-file-name(Ext?), Stack?, EditorId?) .
        StackPopString(Stack, Stack?, FileName?) .
        snd-msg(decons-file-name(FileName, Ext)) .
        rec-msg(decons-file-name-result(Path?, FileName?, Ext?)) .
        StackPushString(Stack, Stack?, FileName) .
        StackPushString(Stack, Stack?, Path) .
        StackPushString(Stack, Stack?, Ext) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(copy-module, Stack?, EditorId?) .
        StackPopString(Stack, Stack?, Ext?) .
        StackPopString(Stack, Stack?, Path?) .
        StackPopString(Stack, Stack?, NewModName?) .
        StackPopString(Stack, Stack?, ModuleName?) .
        snd-msg(copy-module(ModuleName, NewModName, Path, Ext)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(rename-module, Stack?, EditorId?) .
        StackPopString(Stack, Stack?, Ext?) .
        StackPopString(Stack, Stack?, Path?) .
        StackPopString(Stack, Stack?, NewModName?) .
        StackPopString(Stack, Stack?, ModuleName?) .
        snd-msg(rename-module(ModuleName, NewModName, Path)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(import-module, Stack?, EditorId?) .
        StackPopString(Stack, Stack?, Ext?) .
        StackPopString(Stack, Stack?, Path?) .
        StackPopString(Stack, Stack?, NewModName?) .
        StackPopString(Stack, Stack?, ModuleName?) .
        snd-msg(import-module(ModuleName, NewModName, Path)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(unimport-module, Stack?, EditorId?) .
        StackPopString(Stack, Stack?, Ext?) .
        StackPopString(Stack, Stack?, Path?) .
        StackPopString(Stack, Stack?, NewModName?) .
        StackPopString(Stack, Stack?, ModuleName?) .
        snd-msg(unimport-module(ModuleName, NewModName, Path)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(compile-module, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(compile-module(ModuleName)) .
        rec-msg(compilation-ready(ModuleName)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(dump-equations, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(dump-equations(ModuleName)) .
        rec-msg(equations-dumped) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(dump-parse-table, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(dump-parse-table(ModuleName)) .
        rec-msg(parse-table-dumped) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(print-module, Stack?, EditorId?) .
        StackPopString(Stack,Stack?,ModuleName?) .
        snd-msg(print-module(ModuleName)) .
        rec-msg(module-printed(ModuleName)) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(clear-all, Stack?, EditorId?) .
        snd-msg(clear-all) .
        rec-msg(cleared-all) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(save-all, Stack?, EditorId?) .
        snd-msg(save-all) .
        rec-msg(saved) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(clear-history-list, Stack?, EditorId?) .
        snd-msg(clear-history) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(refresh-buttons, Stack?, EditorId?) .
        snd-msg(refresh-buttons) .
        rec-msg(buttons-refreshed) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(exit, Stack?, EditorId?) .
        shutdown("MetaStudio exiting\n") .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(dup, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,Tree?) .
        StackPushTerm(Stack,Stack?,Tree) .
        StackPushTerm(Stack,Stack?,Tree) .
        ReturnSuccess(EditorId, Stack)
      +
        rec-msg(pop, Stack?, EditorId?) .
        StackPopTerm(Stack,Stack?,Tree?) .
        ReturnSuccess(EditorId, Stack)
  ) * delta
endlet

process IfEqual(ButtonAction : term,
                Stack : list,
                ButtonActions : list,
                RStack : list?,
                RButtonActions : list?) is
let
  Tree1 : term,
  Tree2 : term,
  ThenActions : list,
  ElseActions : list,
  IStack : list
in
  Tree1 := first(Stack) .
  IStack := next(Stack) .
  Tree2 := first(IStack) .
  IStack := next(IStack) .
  snd-msg(equal-trees(Tree1, Tree2)) .
  (
    rec-msg(true) .
    ThenActions := first(args(ButtonAction)) .
    RButtonActions := join(ThenActions, ButtonActions)
  +
    rec-msg(false) .
    ElseActions := first(next(args(ButtonAction))) .
    RButtonActions := join(ElseActions, ButtonActions)
  ) .
  RStack := IStack
endlet





process ShowTree(Tree: term) is
let
  Graph : term,
  Id : int
in
  Id := process-id.
  snd-note(ui-status(stat(Id,"Computing graph layout..."))) .
  snd-msg(tree2graph(Tree)) .
  rec-msg(graph(Graph?)) .
  snd-msg(display-graph("parsetree", Graph)).
  snd-note(ui-status(endstat(Id)))
endlet

process ParseTerm(EditorId: term, ModuleName: str) is
let
  Focus : term
in
  InvalidateEditor(EditorId).
  snd-msg(parse-focusses(EditorId, trm(ModuleName))) .
  (
    rec-msg(parse-ok(trm(ModuleName))) .
    snd-note(clear-focus(EditorId))
  +
    rec-msg(parse-failed(trm(ModuleName), Focus?))
  )
endlet

process GetTextFromFile(FileName: str, Text: str?) is
let
  ErrorMessage : str
in
  snd-msg(io-read-file(FileName)).
  (
    rec-msg(io-file-contents(Text?))
  +
    rec-msg(io-error-reading(ErrorMessage?)) .
    Text := error-text
  )
endlet

process ParseText(Text: str, ModuleName: str, Nonterminal: str,
                  Tree: term?, ParseError: term?) is
let
  Id : term,
  ErrList : list,
  ErrContent : term,
  ModuleId : term
in
  Id := process-id .
  snd-msg(open-modules([ModuleName])) .
  rec-msg(finished-opening-modules) .
  ModuleId := quote(trm(ModuleName)) .
  ParseString(ModuleId, Nonterminal, Text, Tree?, ParseError?)
endlet

process ParseSyntax(EditorId : term, ModuleName : str) is
let
  Tree : term,
  Text : str,
  Focus : term,
  NewModules : list,
  DependingModules : list
in
  InvalidateEditor(EditorId).
  snd-msg(parse-focusses(EditorId, trm("Sdf2"))) .
  (
    rec-msg(parse-ok(trm("Sdf2"))) .
    snd-msg(get-tree(EditorId)) .
    (
      rec-msg(tree(Tree?)) .
      snd-msg(unparse(Tree)) .
      rec-msg(unparsed-text(Text?)) .
      snd-msg(update-module-in-db(ModuleName, Text, Tree)) .
      (
        rec-msg(updating-succeeded(DependingModules?, NewModules?)).
        snd-msg(notify-about-changed-modules(DependingModules, "sdf")) .
        rec-msg(notify-about-changed-modules-done) .
        snd-msg(open-modules(NewModules)).
        rec-msg(finished-opening-modules) .
        snd-note(clear-focus(EditorId))
      +
        rec-msg(error-opening(ModuleName, name-inconsistent)).
        snd-msg(invalidate-sdf-in-db(ModuleName)).
        InvalidateEditor(EditorId).
        snd-note(ui-status(
          errorf("Changing the name of %s is not permitted.",[ModuleName])))
      )
    +
      rec-msg(no-tree)
    )
  +
    rec-msg(parse-failed(trm("Sdf2"), Focus?)) .
    snd-msg(invalidate-sdf-in-db(ModuleName))
  )
endlet

process ParseEquations(EditorId : term, ModuleName : str) is
let
  Tree : term,
  Focus : term
in
  InvalidateEditor(EditorId).
  snd-msg(parse-focusses(EditorId, eqs(ModuleName))) .
  (
    rec-msg(parse-ok(eqs(ModuleName))) .
    snd-msg(get-tree(EditorId)) .
    (
      rec-msg(tree(Tree?)) .
      snd-msg(postprocess-semantics-hook(Tree)).
      rec-msg(postprocess-semantics-hook-result(Tree?)).
      snd-msg(update-eqs-tree-in-db(ModuleName, tree(Tree))) .
      rec-msg(eqs-updated) .
      snd-note(clear-focus(EditorId))
    +
      rec-msg(no-tree)
    )
  +
    rec-msg(parse-failed(eqs(ModuleName), Focus?))
  )
endlet

process GetTree(EditorId: term, ModuleName: str, Tree: term?) is
let
  DirtyFoci : term
in
  Tree := error-tree.
  snd-msg(get-dirty-focuses(EditorId)) .
  rec-msg(dirty-focuses(DirtyFoci?)) .
  if equal(DirtyFoci, []) then
    snd-msg(get-tree(EditorId)) .
    (
      rec-msg(tree(Tree?))
    +
      rec-msg(no-tree)
    )
  else
    ParseTerm(EditorId, ModuleName) .
    snd-msg(get-dirty-focuses(EditorId)) .
    rec-msg(dirty-focuses(DirtyFoci?)) .
    if equal(DirtyFoci, []) then
      snd-msg(get-tree(EditorId)) .
      (
        rec-msg(tree(Tree?))
      +
        rec-msg(no-tree)
      )
    else
      tau
    fi
  fi
endlet

process ReplaceRoot(EditorId: term, Tree: term) is
let
  TotalTree : term,
  Text : str,
  Focus : term,
  FileName : str,
  ErrorMessage : str
in
  snd-msg(move-focus-to-root(EditorId)) .
  rec-msg(focus-moved(EditorId, Focus?)) .
  snd-msg(replace-focussed-tree(EditorId, Tree)) .
  rec-msg(focus(Focus?)) .
  snd-msg(get-tree(EditorId)) .
  (
    rec-msg(tree(TotalTree?)) .
    snd-msg(unparse(TotalTree)) .
    rec-msg(unparsed-text(Text?)) .
    snd-msg(get-editor-name(EditorId)) .
    rec-msg(editor-name(FileName?)) .
    snd-msg(io-write-text-file(FileName,[Text])) .
    (
      rec-msg(io-file-written) .
      snd-note(reload-file(EditorId, FileName)) .
      snd-msg(move-focus-to-root(EditorId)) .
      rec-msg(focus-moved(EditorId, Focus?)) .
      snd-note(set-focus(EditorId, Focus))
    +
      rec-msg(io-file-not-written(ErrorMessage?)) .
      snd-note(ui-status(errorf("%s: %s",[FileName, ErrorMessage])))
    )
  +
    rec-msg(no-tree)
  )
endlet


process GetFocus(EditorId: term, Tree: term?) is
  snd-msg(get-focussed-tree(EditorId)) .
  (
    rec-msg(tree(Tree?))
  +
    rec-msg(no-tree) .
    Tree := error-tree
  )

process ReplaceFocus(EditorId: term, Tree: term) is
let
  TotalTree : term,
  Text : str,
  Focus : term,
  FileName : str,
  ErrorMessage : str
in
  snd-msg(replace-focussed-tree(EditorId, Tree)) .
  rec-msg(focus(Focus?)) .
  snd-msg(get-tree(EditorId)) .
  (
    rec-msg(tree(TotalTree?)) .
    snd-msg(unparse(TotalTree)) .
    rec-msg(unparsed-text(Text?)) .
    snd-msg(get-editor-name(EditorId)) .
    rec-msg(editor-name(FileName?)) .
    snd-msg(io-write-text-file(FileName,[Text])) .
    (
      rec-msg(io-file-written) .
      snd-note(reload-file(EditorId, FileName)) .
      snd-note(set-focus(EditorId, Focus))
    +
      rec-msg(io-file-not-written(ErrorMessage?)) .
      snd-note(ui-status(errorf("%s: %s",[FileName, ErrorMessage])))
    )
  +
    rec-msg(no-tree)
  )
endlet

process CheckTreeSort(Tree: term, Sort: str, RTree: term?) is
let
  TreeSort : str
in
  snd-msg(check-tree-sort(Sort, Tree)) .
  (
    rec-msg(wrong-sort(TreeSort?)) .
    snd-note(ui-status(errorf("Top sort %s of tree does not match %s",
                              [TreeSort, Sort]))) .
    RTree := error-tree
  +
    rec-msg(sort-ok) .
    RTree := Tree
  )
endlet

process ReduceTerm(Tree: term, ModuleName: str, NormalForm: term?) is
let
  Id : int,
  ErrList : list,
  Equations : term
in
  Id := process-id .
  snd-msg(open-modules([ModuleName])) .
  rec-msg(finished-opening-modules) .
  snd-note(ui-status(stat(Id, "Retrieving equations"))) .
  snd-msg(get-all-equations(ModuleName)) .
  (
    rec-msg(all-equations(Equations?)) .
    snd-note(ui-status(endstat(Id))).
    snd-msg(interpret-term-hook(ModuleName, Equations, Tree)).
    rec-msg(interpret-term-hook-result(NormalForm?))
  +
    rec-msg(equations-incomplete) .
    NormalForm := error-tree .
    snd-note(ui-status(endstat(Id))) .
    snd-note(ui-status(errorf("Equations incomplete for %s.asf", [ModuleName])))
  )
endlet

process ActivateEditorWithTree(Tree: term, ModuleName: str, FileName: str) is
let
  Text : str,
  EditorId : term,
  NewModuleName : str,
  ErrorMessage : str
in
  if not-equal(Tree, error-tree) then
    snd-msg(unparse(Tree)) .
    rec-msg(unparsed-text(Text?)) .
    snd-msg(io-write-text-file(FileName,[Text])) .
    (
      rec-msg(io-file-written) .
      snd-msg(edit-term-file-with-tree(ModuleName, FileName, Tree)) .
      rec-msg(editor-opened(ModuleName, EditorId?))
    +
      rec-msg(io-file-not-written(ErrorMessage?)) .
      snd-note(ui-status(errorf("%s: %s",[FileName, ErrorMessage])))
    )
  fi
endlet

process ActivateEditorWithString(Text: str, ModuleName: str, FileName: str) is
let
  EditorId : term,
  NewModuleName : str,
  ErrorMessage : str
in
  snd-msg(io-write-text-file(FileName,[Text])) .
  (
    rec-msg(io-file-written) .
    snd-msg(edit-term-file(ModuleName, FileName)) .
    rec-msg(editor-opened(ModuleName, EditorId?))
  +
    rec-msg(io-file-not-written(ErrorMessage?)) .
    snd-note(ui-status(errorf("%s: %s",[FileName, ErrorMessage])))
  )

endlet




process Notify-about-changed-modules is
let
  ChangedMods : list,
  Type : str,
  ChangedMod : str
in
  (
    rec-msg(notify-about-changed-modules(ChangedMods?,Type?)).
    (



      if not-equal(ChangedMods,[]) then
        ChangedMod := first(ChangedMods).
        ChangedMods := next(ChangedMods).
        if equal(Type, "sdf") then
          snd-note(syntax-changed(ChangedMod)).
          snd-msg(close-language(ChangedMod))
        else
          tau
        fi
      fi
    )*
    if equal(ChangedMods,[]) then



      snd-msg(notify-about-changed-modules-done)
    fi
  )* delta
endlet


process DumpEquations is
let
  Id : int,
  ModuleName : str,
  Equations : term,
  Path : str,
  FileName : str,
  ErrorMessage : str
in
  Id := process-id .
  (
    (
      rec-msg(dump-equations(ModuleName?)) .
      FileName := ""
    +
      rec-msg(dump-equations-given-file(ModuleName?, FileName?))
    ) .
    snd-note(ui-status(statf(Id,"Dumping equations for %s", [ModuleName]))) .
    snd-msg(get-all-equations(ModuleName)) .
    (
      rec-msg(all-equations(Equations?)) .
      if equal(FileName, "") then
        snd-msg(get-path-from-db(ModuleName)) .
        rec-msg(path(Path?)) .
        snd-msg(io-get-filename(Path, ModuleName, ".eqs")) .
        rec-msg(io-filename(FileName?))
      else
        tau
      fi .
      snd-msg(io-write-term-file(FileName, Equations)) .
      (
        rec-msg(io-file-written)
      +
        rec-msg(io-file-not-written(ErrorMessage?)) .
        snd-note(ui-status(errorf("%s: %s", [FileName, ErrorMessage])))
      )
    +
      rec-msg(equations-incomplete) .
      snd-note(ui-status(errorf("Specification incomplete for %s", [ModuleName])))
    ) .
    snd-note(ui-status(endstat(Id))) .
    snd-msg(equations-dumped)
  ) * delta

endlet
process Query is
let
  EditorId : term,
  ModuleName : str,
  ModuleNames : list(<str>),
  Focus : term,
  Module : term,
  Term : term,
  Errors : term,
  PosInfo : term,
  Equations : term,
  FunSym : str
in
  (
    rec-msg(execute-query(EditorId?, "find-production-use")) .
    snd-msg(get-focussed-tree(EditorId)) .
    (
      rec-msg(tree(Focus?)) .
      snd-msg(get-all-module-names) .
      rec-msg(all-module-names(ModuleNames?)) .
      (
        if not-equal(ModuleNames, []) then
          ModuleName := first(ModuleNames) .
          printf("ModuleName: %s\n", ModuleName) .
          snd-msg(process-eqs(ModuleName)).
          rec-msg(eqs-processed(ModuleName)).
          snd-msg(get-eqs-tree(ModuleName)) .
          (
            rec-msg(tree(Equations?)) .
            snd-msg(query("FindProdUse", Equations, Focus)) .
            rec-msg(result("FindProdUse", Term?)) .
            FunSym := fun(Term) .
            if equal(FunSym, "found") then

              snd-msg(edit-equations(ModuleName)) .
              rec-msg(editor-opened(ModuleName, EditorId?)) .
              PosInfo := first(args(Term)) .
              snd-msg(set-focus-at-posinfo(EditorId, PosInfo)) .
              ModuleNames := []
            else
              tau
            fi
          +
            rec-msg(unavailable)
          ) .
          ModuleNames := next(ModuleNames)
        fi
      ) *
      if equal(ModuleNames, []) then
        tau
      fi
    )
    +
    rec-msg(execute-query(EditorId?, "find-production")) .
    snd-msg(get-focussed-tree(EditorId)) .
    (
      rec-msg(tree(Focus?)) .
      snd-msg(get-all-module-names) .
      rec-msg(all-module-names(ModuleNames?)) .
      (
        if not-equal(ModuleNames, []) then
          ModuleName := first(ModuleNames) .
          snd-msg(get-sdf2-asfix(ModuleName)) .
          (
            rec-msg(syntax(Module?)) .
            snd-msg(query("FindProduction", Module, Focus)) .
            rec-msg(result("FindProduction", Term?)) .
            FunSym := fun(Term) .
            if equal(FunSym, "found") then

              snd-msg(edit-syntax(ModuleName)) .
              rec-msg(editor-opened(ModuleName, EditorId?)) .
              PosInfo := first(args(Term)) .
              snd-msg(set-focus-at-posinfo(EditorId, PosInfo)) .
              ModuleNames := []
            else
              tau
            fi
          +
            rec-msg(unavailable) .
            printf("Unable to get parse tree for focus!\n")
          ) .
          ModuleNames := next(ModuleNames)
        fi
      ) *
      if equal(ModuleNames, []) then
        tau
      fi
    +
      rec-msg(no-tree) .
      printf("No tree!\n")
    )
  ) * delta
endlet





process Asfc is
let
  COM : asfc,
  ModuleName : str,
  Equations : term,
  Progress : str
in
  (
    rec-msg(compile-module(ModuleName?, Equations?)) .
    execute(asfc, COM?) .
    snd-eval(COM, compile-module(ModuleName, Equations)) .
    (
      rec-event(COM, asfc-progress(Progress?)).
      snd-note(asfc-progress(Progress)).
      snd-ack-event(COM,asfc-progress(Progress))
    )*
    rec-value(COM, compilation-done) .
    snd-msg(compilation-done(ModuleName)).
    snd-terminate(COM,"done").
    Equations := none
  ) *
  delta
endlet

tool asfc is { command = "asfc -print-gc-info -termtable 20" }



process AsfOperations is
let
  Equations : term,
  Renamings : term,
  AO : asfoperations
in
  execute(asfoperations, AO?) .
  (
    rec-msg(extract-equations(Equations?)).
    snd-eval(AO, extract-equations(Equations)).
    rec-value(AO, extract-equations-result(Equations?)).
    snd-msg(extract-equations-result(Equations))
  )*
  delta
endlet

tool asfoperations is {command = "asfoperations"}



process AsfChecker is
let
  Msgs : list,
  Rules : term,
  AC : asfchecker
in
  execute(asfchecker, AC?) .
  (
    rec-msg(check-asf(Rules?)) .
    snd-eval(AC, check-asf(Rules)) .
    rec-value(AC, messages(Msgs?)) .
    snd-msg(messages(Msgs)) .
    Rules := none
  )*
  delta
endlet

tool asfchecker is {command = "asfchecker"}



process AsfSdfChecker is
let
  Msgs : list,
  Syntax : term,
  ASC : asfsdfchecker
in
  execute(asfsdfchecker, ASC?) .
  (
    rec-msg(check-asfsdf(Syntax?)) .
    snd-eval(ASC, check-asfsdf(Syntax)) .
    rec-value(ASC, messages(Msgs?)) .
    snd-msg(messages(Msgs)) .
    Syntax := none
  )*
  delta
endlet

tool asfsdfchecker is {command = "asfsdfchecker"}


process Asfe is
let
  Eval : asfe,
  ModuleName : str,
  Term : term,
  Equations : term,
  NormalForm : term,
  ErrorList : list,
  Id : term,
  Tide : term,
  EventName : term,
  EventTree : term,
  EventResult : term,
  EventString: str
in
  Id := process-id .
  Tide := off .
  (
    rec-msg(debugging(Tide?))
  +
    rec-msg(rewrite(ModuleName?, Equations?, Term?)) .
    execute(asfe, Eval?) .
    snd-eval(Eval, interpret(ModuleName, Equations, Term, Tide)) .
    (
      rec-event(Eval, event(EventName?,EventTree?,EventString?)).
      if equal(EventName,tb-snd-note) then
        snd-note(EventTree)
      else
        if equal(EventName,tb-snd-msg) then
          snd-msg(EventTree)
        else
          if equal(EventName,tb-rec-msg) then
            rec-msg(EventTree)
          else
            printf("unhandled event: %t\n", EventName)
          fi
        fi
      fi.
      snd-ack-event(Eval,event(EventName,EventTree,EventString))
    ) *
    (
      rec-value(Eval, rewrite-result(NormalForm?)) .
      snd-msg(rewrite-result(NormalForm))
    +
      rec-value(Eval, rewrite-errors(ErrorList?)) .
      snd-msg(rewrite-errors(ErrorList))
    ).
    snd-terminate(Eval,"done").
    %% Equations and terms can be big, so we clear the variables here
    Equations := none.
    Term := none
  ) *
  delta
endlet

tool asfe is { command = "asfe" }



process AddEqSyn is
let
  NewSyntax : term,
  Syntax : term,
  AES : addeqssyntax,
  ModuleName : str
in
  (
    rec-msg(add-eqs-syntax(ModuleName?, Syntax?)).
    execute(addeqssyntax,AES?).
    snd-eval(AES,add-eqs-syntax(ModuleName, Syntax)).
    rec-value(AES,extended-syntax(NewSyntax?)).
    snd-msg(extended-syntax(NewSyntax)).
    snd-terminate(AES,"done").
    Syntax := none.
    NewSyntax := none
  )*
  delta
endlet

tool addeqssyntax is {command = "addeqssyntax"}



process AddAPISyn is
let
  NewSyntax : term,
  Syntax : term,
  AAS : addapisyntax,
  ModuleName : str
in
  (
    rec-msg(add-api-syntax(Syntax?)).
    execute(addapisyntax,AAS?).
    snd-eval(AAS,add-api-syntax(Syntax)).
    rec-value(AAS,extended-syntax(NewSyntax?)).
    snd-msg(extended-syntax(NewSyntax)).
    snd-terminate(AAS,"done").
    Syntax := none.
    NewSyntax := none
  )*
  delta
endlet

tool addapisyntax is {command = "addapisyntax"}



process RemoveVars is
let
  NewSyntax : term,
  Syntax : term,
  RVS : removevarsyntax,
  ModuleName : str
in
  (
    rec-msg(remove-var-syntax(ModuleName?, Syntax?)) .
    execute(removevarsyntax, RVS?) .
    snd-eval(RVS, remove-var-syntax(ModuleName, Syntax)).
    rec-value(RVS, changed-syntax(NewSyntax?)).
    snd-msg(changed-syntax(NewSyntax)).
    snd-terminate(RVS,"done").
    Syntax := none.
    NewSyntax := none
  )*
  delta
endlet

tool removevarsyntax is {command = "removevarsyntax"}







process DisplayErrors is
let
  Error : list,
  Message : str,
  Subject : term,
  SubjectText : str,
  Errors : list,
  ErrorsText : str,
  Tag : term,
  TagText : str
in
  (
    rec-msg(display-rewrite-errors(Errors?)).
    if not-equal(Errors,[]) then
      Error := first(Errors).
      Errors := next(Errors).
      Message := first(Error).
      Error := next(Error).
      Tag := first(Error).
      snd-msg(unparse(Tag)).
      rec-msg(unparsed-text(TagText?)).
      Error := next(Error).
      Subject := first(Error).
      snd-msg(unparse(Subject)).
      rec-msg(unparsed-text(SubjectText?)).
      snd-note(ui-status(errorf("%s (%s, %s)",[Message,TagText,SubjectText])))
    fi *
    if equal(Errors,[]) then
      tau
    fi
  +
    rec-msg(display-asf-errors(Errors?)).
    if not-equal(Errors,[]) then
      Error := first(Errors).
      Errors := next(Errors).
      Message := first(Error).
      Error := next(Error).
      if not-equal(Error,[]) then
        Tag := first(Error).
        snd-msg(unparse(Tag)).
        rec-msg(unparsed-text(TagText?)).
        Error := next(Error).
        Subject := first(Error).
        snd-msg(unparse(Subject)).
        rec-msg(unparsed-text(SubjectText?)).
        snd-note(ui-status(errorf("Equation %s %s: %s)",[TagText, Message, SubjectText])))
      else
        snd-note(ui-status(errorf("%s",[Message])))
      fi
    fi *
    if equal(Errors,[]) then
      tau
    fi
  +
    rec-msg(display-sdf-errors(Errors?)).
    if not-equal(Errors,[]) then
      Message := first(Errors).
      Errors := next(Errors).
      snd-note(ui-status(errorf("WARNING: %s",[Message])))
    fi *
    if equal(Errors,[]) then
      tau
    fi
  ) *
  delta
endlet

process Create-Asf-Processes is
let Pid : int
in
  create(Asfe, Pid?).
  create(AsfSdfChecker, Pid?).
  create(AsfChecker, Pid?).
  create(AsfOperations, Pid?).
  create(AddEqSyn, Pid?).
  create(AddAPISyn, Pid?).
  create(RemoveVars, Pid?).
  create(Asfc, Pid?).
  create(DisplayErrors, Pid?) .
  create(Preprocess-syntax, Pid?) .
  create(Interpret-term, Pid?) .
  create(Postprocess-semantics, Pid?) .
  create(Compile-semantics, Pid?) .
  create(Postprocess-collected-semantics, Pid?)
endlet

process Preprocess-syntax is
let
  Syntax : term,
  ModuleName : str,
  Msgs : list
in
  (
    rec-msg(preprocess-syntax-hook(eqs(ModuleName?), Syntax?)).
    snd-msg(check-asfsdf(Syntax)) .
    rec-msg(messages(Msgs?)) .
    snd-msg(display-sdf-errors(Msgs)) .
    snd-msg(add-api-syntax(Syntax)).
    rec-msg(extended-syntax(Syntax?)).
    snd-msg(add-eqs-syntax(ModuleName, Syntax)) .
    rec-msg(extended-syntax(Syntax?)) .
    snd-msg(preprocess-syntax-hook-result(eqs(ModuleName), Syntax)) .
    Syntax := no-tree
  +
    rec-msg(preprocess-syntax-hook(trm(ModuleName?), Syntax?)).
    snd-msg(check-asfsdf(Syntax)) .
    rec-msg(messages(Msgs?)) .
    snd-msg(display-sdf-errors(Msgs)) .
    snd-msg(remove-var-syntax(ModuleName, Syntax)) .
    rec-msg(changed-syntax(Syntax?)) .
    snd-msg(add-api-syntax(Syntax)).
    rec-msg(extended-syntax(Syntax?)).
    snd-msg(preprocess-syntax-hook-result(trm(ModuleName), Syntax)) .
    Syntax := no-tree
  )*delta
endlet

process Interpret-term is
let
  Id : int,
  Semantics : term,
  ModuleName : str,
  Tree : term,
  NormalForm : term,
  Errors : list,
  Text : str
in
  Id := process-id.
  (
    rec-msg(interpret-term-hook(ModuleName?, Semantics?, Tree?)).
    snd-note(ui-status(stat(Id, "Rewriting"))) .
    snd-msg(rewrite(ModuleName, Semantics, Tree)).
    (
      rec-msg(rewrite-result(NormalForm?)).
      snd-msg(restore-term-brackets(ModuleName, NormalForm)).
      rec-msg(restore-term-brackets-result(ModuleName, NormalForm?))
    +
      rec-msg(rewrite-text(Text?)) .
      NormalForm := quote(str(Text))
    +
      rec-msg(rewrite-errors(Errors?)).
      snd-msg(display-rewrite-errors(Errors)).
      NormalForm := error-tree
    ).
    snd-note(ui-status(endstat(Id))).
    snd-msg(interpret-term-hook-result(NormalForm))
  )*delta
endlet

process Postprocess-semantics is
let
  Semantics : term,
  Msgs : list
in
  (
    rec-msg(postprocess-semantics-hook(Semantics?)).
    snd-msg(check-asf(Semantics)).
    rec-msg(messages(Msgs?)).
    snd-msg(display-asf-errors(Msgs)).
    snd-msg(postprocess-semantics-hook-result(Semantics))
  )*delta
endlet

process Compile-semantics is
let
  Id : int,
  Semantics : term,
  ModuleName : str,
  Progress : str
in
  Id := process-id .
  subscribe(asfc-progress(<term>)) .
  (
    rec-msg(compile-semantics-hook(ModuleName?, Semantics?)).
    snd-msg(compile-module(ModuleName, Semantics)) .
    (
      rec-note(asfc-progress(Progress?)).
      snd-note(ui-status(endstat(Id))).
      snd-note(ui-status(statf(Id,"Compiling %s - %s",
                              [ModuleName, Progress])))
    )*
    rec-msg(compilation-done(ModuleName)).
    snd-note(ui-status(endstat(Id))).
    snd-msg(compile-semantics-hook-done(ModuleName))
  )*delta
endlet

process Postprocess-collected-semantics is
let
  Semantics : term,
  ModuleName : str,
  Modules : list
in
  (
    rec-msg(postprocess-collected-semantics-hook(ModuleName?, Modules?)).
    snd-msg(extract-equations(Modules)).
    rec-msg(extract-equations-result(Semantics?)).
   printf("Equations extracted from parse trees\n") .
   snd-msg(postprocess-collected-semantics-hook-result(ModuleName, Semantics))

  )*delta
endlet

process Meta-Interface is
let
  Id : int
in
  Id := process-id.
  Create-Asf-Processes.
  (
    rec-msg(environment-name-hook).
    snd-msg(environment-name-hook-result("ASF+SDF Meta-Environment"))
  +
    rec-msg(library-location-hook).
    snd-msg(library-location-hook-result("/export/scratch1/jong/meta/install/share/asf/library"))
  +
    rec-msg(file-extensions-hook).
    snd-msg(file-extensions-hook-result(".sdf",".asf",".trm"))
  +
    rec-msg(semantics-top-sort-hook).
    snd-msg(semantics-top-sort-hook-result(sort("Equations")))
  ) * delta
endlet




process Parser is
  let
    P : sglr,
    Lid : term,
    G : str,
    S : str,
    Id : term,
    FN : str,
    Tbl : term,
    T : term,
    Err : list,
    Start: list,
    Amb : int,
    Ambs : list
  in
    execute(sglr, P?) .
    (
      (rec-msg(Id?, parse-string(Lid?, G?, S?)) .
       snd-eval(P, parse-string(Lid, G, S))
      +
       rec-msg(parse-file(Lid?, G?, FN?, Id?)) .
       snd-eval(P, parse-file(Lid, G, FN))
      ).
      (
        rec-value(P, parsetree(T?, Amb?)) .
        snd-msg(parse-result(Id, parsetree(T, Amb)))
      +
        rec-value(P, parse-error(Err?,plain)) .
        snd-msg(parse-result(Id, parse-error(Err,plain)))
      +
        rec-value(P, parse-error(Err?,eof)) .
        snd-msg(parse-result(Id, parse-error(Err,eof)))
      +
        rec-value(P, parse-error(Err?,ambiguities(Amb?, Ambs?))) .
        snd-msg(parse-result(Id, parse-error(Err,ambiguities(Amb, Ambs))))
      +
        rec-value(P, parse-error(Err?,cycle(T?))) .
        snd-msg(parse-result(Id, parse-error(Err,cycle(T))))
      )
    +
      rec-msg(Id?, parse-string-as-asfix2me(Lid?, G?, S?)) .
      snd-eval(P, parse-string-as-asfix2me(Lid, G, S)) .
      (
        rec-value(P, parsetree(T?, Amb?)) .
        snd-msg(parse-result-asfix2me(Id, parse-tree(parsetree(T, Amb))))
      +
        rec-value(P, parse-error(Err?,plain)) .
        snd-msg(parse-result-asfix2me(Id, parse-error(Err,plain)))
      +
        rec-value(P, parse-error(Err?,eof)) .
        snd-msg(parse-result-asfix2me(Id, parse-error(Err,eof)))
      +
        rec-value(P, ambiguous-tree(T?, Err?, ambiguities(Amb?, Ambs?))) .
        snd-msg(parse-result-asfix2me(Id, ambiguous-tree(parsetree(T, Amb), Err,ambiguities(Amb, Ambs))))
      +
        rec-value(P, parse-error(Err?,ambiguities(Amb?, Ambs?))) .
        snd-msg(parse-result-asfix2me(Id, parse-error(Err,ambiguities(Amb, Ambs))))
      +
        rec-value(P, parse-error(Err?,cycle(T?))) .
        snd-msg(parse-result-asfix2me(Id, parse-error(Err,cycle(T))))
      )
    +
      (
        rec-msg(open-language-from-term(Lid?, Tbl?)) .
        snd-eval(P, open-language-from-term(Lid, Tbl))
      +
        rec-msg(open-language(Lid?, FN?)) .
        snd-eval(P, open-language(Lid, FN))
      ) .
      (
        rec-value(P, language-opened(Lid)) .
        snd-msg(language-opened(Lid)) .
        snd-note(language-available(Lid))
      +
        rec-value(P, language-not-opened(Lid)) .
        snd-msg(language-not-opened(Lid))
      )
    +
      rec-msg(close-language(Lid?)) .
      snd-eval(P, close-language(Lid)) .
      (
        rec-value(P, language-closed(Lid?)) .
        snd-note(language-unavailable(Lid))
      +
        rec-value(P, language-not-open(Lid?))
      )
    )
    * rec-disconnect(P)
  endlet

tool sglr is {command="sglr"}

process LAYOUT-GRAPH is
let
  D : layoutgraph,
  Graph : term
in
  (
    rec-msg(layout-graph(Graph?)) .
    execute(layoutgraph, D?) .
    snd-eval(D, layout-graph(Graph)) .
    rec-value(D, graph-layouted(Graph?)) .
    snd-terminate(D,"done").
    snd-msg(graph-layouted(Graph))
  ) * delta
endlet

tool layoutgraph is { command = "layoutgraph" }

process Unparser is
let
  UPT : unparsePT,
  Tree : term,
  Text : term
in
  (
    rec-msg(unparse(Tree?)).
    execute(unparsePT, UPT?).
    snd-eval(UPT, unparse-asfix(Tree)).
    rec-value(UPT, unparsed-text(Text?)).
    snd-terminate(UPT, "done") .
    snd-msg(unparsed-text(Text))
  ) *
  delta
endlet

tool unparsePT is { command = "unparsePT" }
toolbus(Unparser)

tool addPosInfo is { command = "addPosInfo" }


process AddPosInfo is
let
  API : addPosInfo,
  Tree : term,
  Path : str,
  Depth : int
in
  (
    rec-msg(add-posinfo(Path?, Tree?)).
    execute(addPosInfo, API?) .
    snd-eval(API, add-posinfo(Path, Tree)) .
    rec-value(API, tree-with-pos-info(Tree?)) .
    snd-msg(tree-with-pos-info(Tree)) .
    Tree := no-tree .
    snd-terminate(API,"")
  +
    rec-msg(add-posinfo-packed(Path?, Tree?)).
    execute(addPosInfo, API?) .
    snd-eval(API, add-posinfo-packed(Path, Tree)) .
    rec-value(API, tree-with-pos-info(Tree?)) .
    snd-msg(tree-with-pos-info(Tree)) .
    Tree := no-tree .
    snd-terminate(API,"")
  +
    rec-msg(add-posinfo-to-depth(Path?, Tree?, Depth?)).
    execute(addPosInfo, API?).
    snd-eval(API, add-posinfo-to-depth(Path, Tree, Depth)).
    rec-value(API, tree-with-pos-info(Tree?)).
    snd-msg(tree-with-pos-info(Tree)).
    Tree := no-tree .
    snd-terminate(API,"")
  ) *
  delta
endlet

toolbus(AddPosInfo)




process Io is
let
  IO : in-output,
  Name : str,
  Path : str,
  Term : term,
  FileName1 : str,
  FileName2 : str,
  FileName : str,
  Contents : term,
  ContentList: list,
  Extension : str,
  ErrorMessage : str,
  Directory : str,
  Directories : list
in
  execute(in-output,IO?).
  (
    rec-msg(io-relative-to-absolute(Directories?)) .
    snd-eval(IO, relative-to-absolute(Directories)) .
    rec-value(IO, absolute-directories(Directories?)) .
    snd-msg(io-absolute-directories(Directories))
  +
    rec-msg(io-find-file(Directories?, Name?, Extension?)) .
    snd-eval(IO, find-file(Directories, Name, Extension)) .
    (
      rec-value(IO, file-found(Directories?)) .
      snd-msg(io-file-found(Directories))
    +
      rec-value(IO, file-not-found) .
      snd-msg(io-file-not-found)
    )
  +
    rec-msg(io-exists-file(FileName?)) .
    snd-eval(IO, exists-file(FileName)) .
    (
      rec-value(IO, success) .
      snd-msg(io-file-exists)
    +
      rec-value(IO, failure(ErrorMessage?)) .
      snd-msg(io-file-not-exists)
    )
  +
    rec-msg(io-write-text-file(FileName?, ContentList?)) .
    snd-eval(IO, write-text-file(FileName, ContentList)) .
    (
      rec-value(IO, success) .
      snd-msg(io-file-written)
    +
      rec-value(IO, failure(ErrorMessage?)) .
      snd-msg(io-file-not-written(ErrorMessage))
    )
  +
    rec-msg(io-write-term-file(FileName?, Term?)) .
    snd-eval(IO, write-term-file(FileName, Term)) .
    (
      rec-value(IO, success) .
      snd-msg(io-file-written)
    +
      rec-value(IO, failure(ErrorMessage?)) .
      snd-msg(io-file-not-written(ErrorMessage))
    )
  +
    rec-msg(io-read-file(FileName?)) .
    snd-eval(IO,read-text-file(FileName)) .
    (
      rec-value(IO,file-contents(Contents?)).
      snd-msg(io-file-contents(Contents))
    +
      rec-value(IO,failure(ErrorMessage?)).
      snd-msg(io-error-reading(ErrorMessage))
    )
  +
    rec-msg(io-compare-files(FileName1?, FileName2?)) .
    snd-eval(IO, compare-files(FileName1, FileName2)) .
    (
      rec-value(IO, equal) .
      snd-msg(io-files-equal)
    +
      rec-value(IO, different) .
      snd-msg(io-files-differ)
    )
  +
    rec-msg(io-get-filename(Directory?, Name?, Extension?)) .
    snd-eval(IO, get-filename(Directory, Name, Extension)) .
    rec-value(IO, filename(FileName?)) .
    snd-msg(io-filename(FileName))
  ) *
  delta
endlet

tool in-output is { command = "in-output" }






tool sdf-modules is { command = "sdf-modules" }

toolbus(SdfModules)

process SdfModules is
let
 SM : sdf-modules,
 Modules : list,
 Pairs : list,
 ModuleId : str,
 Imports : term,
 ModuleImportPairs : list,
 Import : term,
 Renamings : term,
 Module : term,
 Definition : term,
 Nodes : list,
 Edges : list,
 Path : str,
 From : str,
 To : str,
 ModuleNames : list
in
  execute(sdf-modules, SM?) .
  (
    rec-msg(sm-get-module-id(Module?)) .
    snd-eval(SM, get-module-id(Module)) .
    rec-value(SM, module-id(ModuleId?)) .
    snd-msg(sm-module-id(ModuleId))
  +
    rec-msg(sm-get-module-path(Path?, ModuleId?)) .
    snd-eval(SM, get-module-path(Path, ModuleId)) .
    (
      rec-value(SM, module-path(Path?)) .
      snd-msg(sm-module-path(Path))
    +
      rec-value(SM, module-path-inconsistent) .
      snd-msg(sm-module-path-inconsistent)
    )
  +
    rec-msg(sm-get-all-needed-module-names(ModuleImportPairs?, ModuleId?)) .
    snd-eval(SM, get-all-needed-module-names(ModuleImportPairs, ModuleId)) .
    ModuleImportPairs := [] .
    rec-value(SM, all-needed-module-names(ModuleNames?)) .
    snd-msg(sm-all-needed-module-names(ModuleNames))
  +
    rec-msg(sm-get-all-depending-module-names(ModuleImportPairs?, ModuleId?)) .
    snd-eval(SM, get-all-depending-module-names(ModuleImportPairs, ModuleId)) .
    Modules := [] .
    rec-value(SM, all-depending-module-names(ModuleNames?)) .
    snd-msg(sm-all-depending-module-names(ModuleNames))
  +
    rec-msg(sm-get-all-needed-imports(Modules?, ModuleId?)) .
    snd-eval(SM, get-all-needed-imports(Modules, ModuleId)) .
    Modules := [] .
    rec-value(SM, all-needed-imports(Imports?)) .
    snd-msg(sm-all-needed-imports(Imports))
  +
    rec-msg(sm-get-imported-module-names(Module?)) .
    snd-eval(SM, get-imported-module-names(Module)) .
    rec-value(SM, imported-module-names(ModuleNames?)) .
    snd-msg(sm-imported-module-names(ModuleNames))
  +
    rec-msg(sm-make-sdf-definition(Modules?)) .
    snd-eval(SM, make-sdf-definition(Modules)) .
    Modules := [] .
    rec-value(SM, sdf-definition(Definition?)) .
    snd-msg(sm-sdf-definition(Definition)) .
    Definition := no-tree
  +
    rec-msg(sm-is-valid-modulename-in-path(Path?, ModuleId?)) .
    snd-eval(SM, is-valid-modulename-in-path(Path, ModuleId)) .
    (
      rec-value(SM, result(yes)) .
      snd-msg(sm-modulename-is-valid)
    +
      rec-value(SM, result(no)) .
      snd-msg(sm-modulename-is-invalid)
    )
  +
    rec-msg(sm-rename-import-in-module(Module?, From?, To?)) .
    printf("not yet implemented in %s at %d\n", "/export/scratch1/jong/meta/install/share/sdf-support/sdf-modules.idef", 83) .
    snd-msg(sm-import-renamed-in-module(Module))
  +
    rec-msg(sm-remove-import-from-module(Module?, ModuleId?)) .
    printf("not yet implemented in %s at %d\n", "/export/scratch1/jong/meta/install/share/sdf-support/sdf-modules.idef", 87) .
    snd-msg(sm-import-removed-from-module(Module))
  +
    rec-msg(sm-rename-module(Module?, ModuleId?)) .
    printf("not yet implemented in %s at %d\n", "/export/scratch1/jong/meta/install/share/sdf-support/sdf-modules.idef", 91) .
    snd-msg(sm-module-renamed(Module))
  +
    rec-msg(sm-add-import-to-module(Module?, ModuleId?)) .
    snd-eval(SM, add-import-to-module(Module, ModuleId)) .
    Module := no-tree .
    rec-value(SM, module(Module?)) .
    snd-msg(sm-import-added-to-module(Module)) .
    Module := no-tree
  )
  * delta
endlet

tool sdf-renaming is { command = "sdf-renaming" }

toolbus(SdfRenaming)

process SdfRenaming is
let
 SR : sdf-renaming,
 Imports : term,
 ToBeRenamed : term,
 Renamed : list,
 ModuleName : str
in
  execute(sdf-renaming, SR?) .
  (
    rec-msg(sr-rename-module(Imports?, ModuleName?, ToBeRenamed?)) .
    snd-eval(SR, rename-module(Imports, ModuleName, ToBeRenamed)) .
    rec-value(SR, renamed-module(Renamed?)) .
    snd-msg(sr-renamed-module(Renamed))
  )
  *delta
endlet

tool term-store is { command = "term-store" }

toolbus(TermStore)

process TermStore is
let
 TS : term-store,
 TableName : str,
 Key : term,
 TermValue : term,
 StrValue : str,
 ContainsKey : bool,
 Keys : list,
 Values : list,
 ValueType : str,
 Pairs : list
in
  execute(term-store, TS?).
  (
    rec-msg(ts-add-table(TableName?, ValueType?)).
    snd-do(TS,add-table(TableName, ValueType))
  +
    rec-msg(ts-remove-table(TableName?)).
    snd-do(TS,remove-table(TableName))
  +
    rec-msg(ts-clear-table(TableName?)).
    snd-do(TS,clear-table(TableName))
  +
    rec-msg(ts-put-term-value(TableName?,Key?,TermValue?)).
    snd-do(TS,put-term-value(TableName,Key,TermValue)) .
    TermValue := []
  +
    rec-msg(ts-put-str-value(TableName?,Key?,StrValue?)).
    snd-do(TS,put-str-value(TableName,Key,StrValue)) .
    StrValue := ""
  +
    rec-msg(ts-get-str-value(TableName?,Key?)).
    snd-eval(TS,get-str-value(TableName,Key)) .
    (
      rec-value(TS,result(StrValue?)).
      snd-msg(ts-value(StrValue)) .
      StrValue := ""
    +
      rec-value(TS,no-result) .
      snd-msg(ts-no-value)
    )
  +
    rec-msg(ts-get-term-value(TableName?,Key?)).
    snd-eval(TS,get-term-value(TableName,Key)) .
    (
      rec-value(TS,result(TermValue?)).
      snd-msg(ts-value(TermValue)) .
      TermValue := no-tree
    +
      rec-value(TS,no-result) .
      snd-msg(ts-no-value)
    )
  +
    rec-msg(ts-remove-value(TableName?,Key?)).
    snd-do(TS,remove-value(TableName,Key))
  +
    rec-msg(ts-contains-key(TableName?,Key?)).
    snd-eval(TS,contains-key(TableName,Key)).
    (
      rec-value(TS,result(yes)).
      snd-msg(ts-contains-key)
    +
      rec-value(TS,result(no)).
      snd-msg(ts-not-contains-key)
    )
  +
    rec-msg(ts-get-all-keys(TableName?)).
    snd-eval(TS, get-all-keys(TableName)).
    rec-value(TS,result(Keys?)).
    snd-msg(ts-all-keys(Keys)) .
    Keys := []
  +
    rec-msg(ts-get-key-value-pairs(TableName?)) .
    snd-eval(TS, get-key-value-pairs(TableName)) .
    rec-value(TS, result(Pairs?)) .
    snd-msg(ts-pairs(Pairs)) .
    Pairs := []
  +
    rec-msg(ts-filter-keys(TableName?, Keys?)) .
    snd-eval(TS, filter-keys(TableName, Keys)) .
    rec-value(TS,result(Keys?)).
    snd-msg(ts-keys(Keys)) .
    Keys := []
  +
    rec-msg(ts-get-all-values(TableName?)) .
    snd-eval(TS, get-all-values(TableName)) .
    rec-value(TS,result(Values?)) .
    snd-msg(ts-all-values(Values)) .
    Values := []
  +
    rec-msg(ts-get-values(TableName?, Keys?)) .
    snd-eval(TS, get-values(TableName, Keys)) .
    rec-value(TS, result(Values?)) .
    snd-msg(ts-values(Values)) .
    Values := []
  +
    rec-msg(ts-remove-value-from-all-tables(Key?)).
    snd-do(TS,remove-value-from-all-tables(Key))
  )
  * delta
endlet


process ModuleDB is
let
  Path : str,
  Table : term,
  ModuleId : str,
  Syntax : term,
  OldSyntaxTree : term,
  SyntaxTree: term,
  SyntaxText: str,
  EqsTree : term,
  EqsText : str,
  Name : str,
  OldName : str,
  NewName : str,
  Modules : list,
  DependingModules : list,
  ModuleNames : list,
  FileName : str,
  Pairs : list
in
  MDB-InitializeModuleDb() .
  MDB-InitializeFileExtensions() .
  (
    rec-msg(get-import-relations) .
    snd-msg(ts-get-key-value-pairs("import-relations")) .
    rec-msg(ts-pairs(Pairs?)) .
    snd-msg(import-relations(Pairs)) .
    Pairs := []
  +
    rec-msg(clear-module-db) .
    MDB-ClearModuleDb()
  +
    rec-msg(delete-module-from-db(Name?)).
    MDB-GetAllDependingModules(Name, DependingModules?) .
    snd-msg(ts-remove-value-from-all-tables(Name)) .
    MDB-RemoveImportFromModules(Name, DependingModules) .
    snd-msg(changed-modules(DependingModules))
  +
    rec-msg(close-module-in-db(Name?)) .
    MDB-GetAllDependingModules(Name, DependingModules?) .
    MDB-InvalidateModules(DependingModules) .
    snd-msg(ts-remove-value-from-all-tables(Name)) .
    snd-msg(changed-modules(DependingModules))
  +
    rec-msg(is-module-in-db(Name?)) .
    snd-msg(ts-contains-key("active-modules", Name)) .
    (
      rec-msg(ts-contains-key).
      snd-msg(exists-in-module-db(Name))
    +
      rec-msg(ts-not-contains-key).
      snd-msg(not-exists-in-module-db(Name))
    )
  +
    rec-msg(add-sdf-module-to-db(Name?, Path?, SyntaxText?, SyntaxTree?)) .
    if not-equal(SyntaxTree, no-tree) then
      snd-msg(sm-get-module-id(SyntaxTree)) .
      rec-msg(sm-module-id(ModuleId?)) .
      snd-msg(sm-get-module-path(Path, ModuleId)) .
      rec-msg(sm-module-path(Path?)) .
      snd-msg(ts-put-str-value("module-paths", ModuleId, Path)) .
      MDB-AddModulePosInfo(ModuleId, SyntaxTree, SyntaxTree?) .
      snd-msg(ts-put-term-value("sdf-tree", ModuleId, SyntaxTree)) .
      snd-msg(sm-get-imported-module-names(SyntaxTree)) .
      SyntaxTree := no-tree .
      rec-msg(sm-imported-module-names(Modules?))
    else
      ModuleId := Name .
      snd-msg(ts-put-str-value("module-paths", ModuleId, Path)) .
      Modules := []
    fi .
    snd-msg(ts-put-term-value("import-relations", ModuleId, Modules)) .
    snd-msg(ts-put-str-value("active-modules", ModuleId, Path)) .
    snd-msg(ts-put-str-value("sdf-text", ModuleId, SyntaxText)) .
    SyntaxText := "" .
    snd-msg(ts-filter-keys("active-modules", Modules)) .
    rec-msg(ts-keys(Modules?)) .
    snd-msg(adding-succeeded(Name, ModuleId, Path, Modules))
  +
    rec-msg(invalidate-sdf-in-db(Name?)) .
    snd-msg(ts-remove-value("sdf-tree", Name))
  +
    rec-msg(update-module-in-db(Name?, SyntaxText?, SyntaxTree?)).
    snd-msg(sm-get-module-id(SyntaxTree)) .
    rec-msg(sm-module-id(ModuleId?)) .
    if equal(Name, ModuleId) then
      MDB-AddModulePosInfo(ModuleId, SyntaxTree, SyntaxTree?) .
      snd-msg(ts-put-term-value("sdf-tree", Name, SyntaxTree)) .
      snd-msg(ts-put-str-value("sdf-text", Name, SyntaxText)) .
      snd-msg(sm-get-imported-module-names(SyntaxTree)) .
      SyntaxTree := no-tree .
      SyntaxText := "" .
      rec-msg(sm-imported-module-names(Modules?)) .
      snd-msg(ts-put-term-value("import-relations", ModuleId, Modules)) .
      snd-msg(ts-filter-keys("active-modules", Modules)) .
      rec-msg(ts-keys(Modules?)) .
      MDB-GetAllDependingModules(Name, DependingModules?) .
      MDB-InvalidateModules(DependingModules) .
      snd-msg(updating-succeeded(DependingModules, Modules))
    else
      snd-msg(error-opening(Name, name-inconsistent))
    fi
  +
    rec-msg(rename-module-in-db(OldName?, NewName?, Path?)) .
    MDB-RenameModule(OldName, NewName, Modules?) .
    snd-msg(renaming-module-done(OldName, Modules))
  +
    rec-msg(add-import-in-db(OldName?, NewName?)) .
    MDB-AddImportToModule(OldName, NewName) .
    snd-msg(add-import-done(OldName))
  +
    rec-msg(remove-import-in-db(OldName?, NewName?, Path?)).
    MDB-RemoveImportFromModules(NewName, [OldName]) .
    snd-msg(remove-import-done)
  +
    rec-msg(copy-module-in-db(OldName?, NewName?, Path?)) .
    printf("not yet implemented in %s at %d\n", "/export/scratch1/jong/meta/install/share/meta/module-db.tb", 127) .
    snd-msg(copy-not-done(OldName))
  +
    rec-msg(eqs-not-available-for-modules(Name?)) .
    MDB-AllEquationsAvailable(Name, ModuleNames?) .
    snd-msg(eqs-needed-for-modules(ModuleNames))
  +
    rec-msg(get-eqs-text(Name?)).
    snd-msg(ts-get-str-value("asf-text", Name)) .
    (
      rec-msg(ts-value(EqsText?)) .
      snd-msg(eqs-text(Name, EqsText))
    +
      rec-msg(ts-no-value) .
      snd-msg(no-eqs-text(Name))
    )
  +
    rec-msg(add-eqs-to-db(Name?, text(EqsText?))) .
    snd-msg(ts-put-str-value("asf-text", Name, EqsText)) .
    snd-msg(eqs-added)
  +
    rec-msg(update-eqs-tree-in-db(Name?, tree(EqsTree?))) .
    snd-msg(ts-get-str-value("module-paths", Name)) .
    rec-msg(ts-value(Path?)) .
    snd-msg(io-get-filename(Path, Name, ".asf")) .
    rec-msg(io-filename(FileName?)) .
    printf("DEBUG: magical value 4 for depth of posinfo!\n") .
    snd-msg(add-posinfo-to-depth(FileName,EqsTree,4)) .
    rec-msg(tree-with-pos-info(EqsTree?)) .
    snd-msg(ts-put-term-value("asf-tree", Name, EqsTree)) .
    EqsTree := no-tree .
    snd-msg(eqs-updated)
  +
    rec-msg(update-eqs-text-in-db(Name?, text(EqsText?))).
    snd-msg(ts-remove-value("asf-tree", Name)) .
    snd-msg(ts-put-str-value("asf-text", Name, EqsText)) .
    snd-msg(eqs-text-updated(Name))
  +
    rec-msg(add-parse-table-to-db(eqs(Name?), Table?)) .
    snd-msg(ts-put-term-value("asf-parse-table", Name, Table)) .
    Table := no-table .
    snd-msg(parse-table-added)
  +
    rec-msg(add-parse-table-to-db(trm(Name?), Table?)) .
    snd-msg(ts-put-term-value("term-parse-table", Name, Table)) .
    Table := no-table .
    snd-msg(parse-table-added)
  +
    rec-msg(get-path-from-db(Name?)).
    snd-msg(ts-get-str-value("module-paths", Name)) .
    rec-msg(ts-value(Path?)) .
    snd-msg(path(Path))
  +
    (
      rec-msg(get-table-from-db(eqs(Name?))) .
      snd-msg(ts-get-term-value("asf-parse-table", Name))
    +
      rec-msg(get-table-from-db(trm(Name?))) .
      snd-msg(ts-get-term-value("term-parse-table", Name))
    ).
    (
      rec-msg(ts-value(Table?)) .
      snd-msg(table(Table)) .
      Table := no-table
    +
      rec-msg(ts-no-value) .
      snd-msg(no-table)
    )
  +
    rec-msg(get-all-depending-modules(Name?)).
    MDB-GetAllDependingModules(Name, DependingModules?) .
    snd-msg(all-depending-modules(DependingModules))
  +
    rec-msg(get-all-imported-module-names(Name?)).
    MDB-GetAllImportedModuleNames(Name, ModuleNames?) .
    snd-msg(all-imported-module-names(ModuleNames))
  +
    rec-msg(get-all-modules) .
    snd-msg(ts-get-all-values("sdf-tree")) .
    rec-msg(ts-all-values(Modules?)) .
    snd-msg(all-modules(Modules)) .
    Modules := []
  +
    rec-msg(get-imported-modules(Name?)).
    printf("DEBUG: NYI, should this be transitive?") .
    MDB-GetImportedModules(Name, Modules?) .
    snd-msg(imported-modules(Modules))
  +
    rec-msg(get-all-module-names).
    snd-msg(ts-get-all-keys("active-modules")) .
    rec-msg(ts-all-keys(ModuleNames?)) .
    snd-msg(all-module-names(ModuleNames))
  +
    rec-msg(all-equations-available(Name?)).
    MDB-AllEquationsAvailable(Name, ModuleNames?) .
    if equal(ModuleNames, []) then
      snd-msg(equations-available)
    else
      snd-msg(equations-incomplete)
    fi
  +
    rec-msg(get-all-sdf2-definitions(Name?)) .
    MDB-GetAllImportedModuleNames(Name, ModuleNames?) .
    snd-msg(ts-get-values("sdf-tree", ModuleNames)) .
    rec-msg(ts-values(Modules?)) .
    snd-msg(sm-make-sdf-definition(Modules)) .
    Modules := [] .
    rec-msg(sm-sdf-definition(Syntax?)) .
    snd-msg(syntax(Syntax)) .
    Syntax := no-tree
  +
    rec-msg(get-sdf2-asfix(Name?)) .
    snd-msg(ts-get-term-value("sdf-tree", Name)) .
    (
      rec-msg(ts-value(Syntax?)) .
      snd-msg(syntax(Syntax)) .
      Syntax := no-tree
    +
      rec-msg(ts-no-value) .
      snd-msg(unavailable)
    )
  +
    rec-msg(get-eqs-tree(Name?)) .
    snd-msg(ts-get-term-value("asf-tree", Name)) .
    (
      rec-msg(ts-value(EqsTree?)) .
      snd-msg(tree(EqsTree)) .
      EqsTree := no-tree
    +
      rec-msg(ts-no-value) .
      snd-msg(unavailable)
    )
  +
    rec-msg(get-equations-for-module(Name?)).
    snd-msg(ts-get-term-value("asf-tree", Name)) .
    (
      rec-msg(ts-value(EqsTree?)) .
      snd-msg(equations(EqsTree)) .
      EqsTree := no-tree
    +
      rec-msg(ts-no-value) .
      snd-msg(no-equations)
    )
  +
    rec-msg(invalidate-parse-tables(Name?)).
    MDB-InvalidateModule(Name) .
    MDB-GetAllDependingModules(Name, DependingModules?) .
    MDB-InvalidateModules(DependingModules)
  +
    rec-msg(get-module-info(Name?)) .
    snd-msg(ts-get-str-value("module-paths", Name)) .
    (
      rec-msg(ts-value(Path?)) .
      snd-msg(module-info(Name, [[path, Path]]))
    +
      rec-msg(ts-no-value) .
      snd-msg(module-info(Name, [[path,"not-available"]]))
    )
) *
delta
endlet

process MDB-InitializeModuleDb is
  snd-msg(ts-add-table("extensions", "str")) .
  snd-msg(ts-add-table("active-modules", "str")) .
  snd-msg(ts-add-table("module-paths", "str")) .
  snd-msg(ts-add-table("sdf-tree", "term")) .
  snd-msg(ts-add-table("sdf-text", "str")) .
  snd-msg(ts-add-table("asf-tree", "term")) .
  snd-msg(ts-add-table("asf-text", "str")) .
  snd-msg(ts-add-table("asf-parse-table", "term")) .
  snd-msg(ts-add-table("term-parse-table", "term")) .
  snd-msg(ts-add-table("import-relations", "term"))

process MDB-ClearModuleDb is
  snd-msg(ts-clear-table("extensions")) .
  snd-msg(ts-clear-table("active-modules")) .
  snd-msg(ts-clear-table("module-paths")) .
  snd-msg(ts-clear-table("sdf-tree")) .
  snd-msg(ts-clear-table("sdf-text")) .
  snd-msg(ts-clear-table("asf-tree")) .
  snd-msg(ts-clear-table("asf-text")) .
  snd-msg(ts-clear-table("asf-parse-table")) .
  snd-msg(ts-clear-table("term-parse-table")) .
  snd-msg(ts-clear-table("import-relations"))

process MDB-InitializeFileExtensions is
let
  SyntaxExt : str,
  RulesExt : str,
  TermExt : str
in
  snd-msg(get-file-extensions) .
  rec-msg(set-file-extensions(syntax(SyntaxExt?),
                              rules(RulesExt?),
                              term(TermExt?))) .
  snd-msg(ts-put-str-value("extensions", "syntax", SyntaxExt)) .
  snd-msg(ts-put-str-value("extensions", "equations", RulesExt)) .
  snd-msg(ts-put-str-value("extensions", "term", TermExt))
endlet

process MDB-GetAllDependingModules(Name : str, DependingModules : list?) is
let
  Pairs : list
in
    snd-msg(ts-get-key-value-pairs("import-relations")) .
    rec-msg(ts-pairs(Pairs?)) .
    snd-msg(sm-get-all-depending-module-names(Pairs, Name)) .
    Pairs := [] .
    rec-msg(sm-all-depending-module-names(DependingModules?))
endlet

process MDB-GetAllImportedModuleNames(Name : str, Imported : list?) is
let
  Pairs : list
in
    snd-msg(ts-get-key-value-pairs("import-relations")) .
    rec-msg(ts-pairs(Pairs?)) .
    snd-msg(sm-get-all-needed-module-names(Pairs, Name)) .
    Pairs := [] .
    rec-msg(sm-all-needed-module-names(Imported?))
endlet

process MDB-GetImportedModules(Name : str, Imported : list?) is
let
  Syntax : term
in
    snd-msg(ts-get-term-value("sdf-tree", Name)) .
    rec-msg(ts-value(Syntax?)) .
    snd-msg(sm-all-imports(Syntax)) .
    Syntax := no-tree .
    rec-msg(sm-all-imports(Imported?))
endlet

process MDB-DisplayGraph is
let
  Pairs : list
in
  snd-msg(ts-get-key-value-pairs("import-relations")) .
  rec-msg(ts-pairs(Pairs?)) .
  snd-note(display-import-graph(Pairs)) .
  Pairs := []
endlet

process MDB-StoreModuleTree(Name : str, Syntax : term) is
let
  Modules : list,
  Text : str
in
  snd-msg(ts-put-term-value("sdf-tree", Name, Syntax)) .
  snd-msg(unparse(Syntax)) .
  rec-msg(unparsed-text(Text?)) .
  snd-msg(ts-put-str-value("sdf-text", Name, Text)) .
  snd-msg(sm-get-imported-module-names(Syntax)) .
  rec-msg(sm-imported-module-names(Modules?)) .
  snd-msg(ts-put-term-value("import-relations", Name, Modules)) .
  MDB-InvalidateModule(Name) .
  MDB-GetAllDependingModules(Name, Modules?) .
  MDB-InvalidateModules(Modules)
endlet

process MDB-RemoveImportFromModules(Name : str, ActualModules : list) is
let
  Module : str,
  Modules : list,
  Imports : list,
  Syntax : term,
  Status : term
in
  Modules := ActualModules .
  if not(equal(Modules,[])) then
    Module := first(Modules) .
    Modules := next(Modules) .
    snd-msg(ts-get-term-value("sdf-tree", Module)) .
    rec-msg(ts-value(Syntax?)) .
    snd-msg(sm-get-imported-module-names(Syntax)) .
    rec-msg(sm-imported-module-names(Imports?)) .
    MDB-ContainedIn(Name, Imports, Status?) .
    if equal(Status, success) then
      snd-msg(sm-remove-import-from-module(Syntax, Name)) .
      Syntax := no-tree .
      rec-msg(sm-import-removed-from-module(Syntax?)) .
      MDB-StoreModuleTree(Module, Syntax) .
      Syntax := no-tree
    else
      tau
    fi
  fi
  *
  if equal(Modules,[]) then
    tau
  fi .
  MDB-DisplayGraph
endlet

process MDB-RenameModule(OldName : str, NewName : str, Changed : list?) is
let
  Status : term,
  Modules : list,
  Imports : list,
  Module : str,
  Path : str,
  Syntax : term
in
  MDB-GetAllDependingModules(OldName, Modules?) .
  Changed := [] .
  if not(equal(Modules,[])) then
    Module := first(Modules) .
    Modules := next(Modules) .
    snd-msg(ts-get-term-value("sdf-tree", Module)) .
    rec-msg(ts-value(Syntax?)) .
    snd-msg(sm-get-imported-module-names(Syntax)) .
    rec-msg(sm-imported-module-names(Imports?)) .
    MDB-ContainedIn(OldName, Imports, Status?) .
    if equal(Status, success) then
      snd-msg(sm-remove-import-from-module(Syntax, OldName)) .
      rec-msg(sm-import-removed-from-module(Syntax?)) .
      snd-msg(sm-add-import-to-module(Syntax, NewName)) .
      rec-msg(sm-import-added-to-module(Syntax?)) .
      MDB-StoreModuleTree(Module, Syntax) .
      Syntax := no-tree .
      Changed := join(Changed, Module)
    else
      tau
    fi
  fi
  *
  if equal(Modules,[]) then
    tau
  fi .
  snd-msg(ts-get-term-value("sdf-tree", OldName)) .
  rec-msg(ts-value(Syntax?)) .
  snd-msg(ts-get-str-value("module-paths", OldName)) .
  rec-msg(ts-value(Path?)) .
  snd-msg(ts-put-str-value("module-paths", NewName, Path)) .
  snd-msg(ts-put-str-value("active-modules", NewName, Path)) .
  snd-msg(sm-rename-modulename-in-module(Syntax, NewName)) .
  rec-msg(sm-modulename-renamed-in-module(Syntax?)) .
  MDB-StoreModuleTree(NewName, Syntax) .
  Syntax := no-tree .
  snd-msg(ts-remove-value-from-all-tables(OldName)) .
  MDB-DisplayGraph
endlet

process MDB-AddImportToModule(OldName : str, NewName : str) is
let
  Syntax : term
in
  snd-msg(ts-get-term-value("sdf-tree", OldName)) .
  rec-msg(ts-value(Syntax?)) .
  snd-msg(sm-add-import-to-module(Syntax, NewName)) .
  Syntax := no-tree .
  rec-msg(sm-import-added-to-module(Syntax?)) .
  MDB-StoreModuleTree(OldName, Syntax) .
  Syntax := no-tree .
  MDB-DisplayGraph
endlet

process MDB-AllEquationsAvailable(Name : str, Missing : list?) is
let
  ModuleNames : list,
  ModuleName : str,
  Text : str,
  Tree : term
in
  MDB-GetAllImportedModuleNames(Name, ModuleNames?) .
  Missing := [] .
  if not(equal(ModuleNames, [])) then
    ModuleName := first(ModuleNames) .
    ModuleNames := next(ModuleNames) .
    snd-msg(ts-get-str-value("asf-text", ModuleName)) .
    (
      rec-msg(ts-no-value)
    +
      rec-msg(ts-value(Text?)) .
      Text := "" .
      snd-msg(ts-get-term-value("asf-tree", ModuleName)) .
      (
        rec-msg(ts-no-value) .
        Missing := join(ModuleName, Missing)
      +
        rec-msg(ts-value(Tree?)) .
        Tree := no-tree
      )
    )
  fi
  *
  if equal(ModuleNames, []) then
    tau
  fi
endlet

process MDB-ContainedIn(Name : str, Modules : list, Status : term?) is
let
  Module : str,
  Runner : list
in
  Status := no-success .
  Runner := Modules .
  if not-equal(Runner, []) then
    Module := first(Runner) .
    Runner := next(Runner) .
    if equal(Module, Name) then
      Status := success
    else
      tau
    fi
  fi
  *
  if equal(Runner, []) then
    tau
  fi
endlet

process MDB-InvalidateModules(Modules : list) is
let
  Module : str,
  Runner : list
in
  Runner := Modules .
  if not-equal(Runner, []) then
    Module := first(Runner) .
    Runner := next(Runner) .
    MDB-InvalidateModule(Module)
  fi
  *
  if equal(Runner, []) then
    tau
  fi
endlet

process MDB-InvalidateModule(Module : str) is
  snd-msg(ts-remove-value("asf-tree", Module)) .
  snd-msg(ts-remove-value("asf-parse-table", Module)) .
  snd-msg(ts-remove-value("term-parse-table", Module))

process MDB-AddModulePosInfo(Module : str, In : term , Out : term?) is
let
  Path : str,
  FileName : str
in
  snd-msg(ts-get-str-value("module-paths", Module)) .
  rec-msg(ts-value(Path?)) .
  snd-msg(io-get-filename(Path, Module, ".sdf")) .
  rec-msg(io-filename(FileName?)) .
  snd-msg(add-posinfo-packed(FileName, In)) .
  rec-msg(tree-with-pos-info(Out?))
endlet


tool restorebrackets is
{
  command = "restorebrackets"
}

process RestoreBrackets is
let
  RESTORE : restorebrackets,
  Term : term,
  NewTerm : term,
  Table : term
in
  (
    rec-msg(restore-brackets(Term?, Table?)) .
    execute(restorebrackets, RESTORE?) .
    snd-eval(RESTORE, restore-brackets(Term, Table)) .
    (
      rec-value(RESTORE, brackets-restored(NewTerm?)) .
      snd-terminate(RESTORE, "done") .
      snd-msg(brackets-restored(NewTerm))
    )
  ) * delta
endlet




tool parsetablegen is {
  command = "parsetablegen"
}


process PGen is
let
  GENTABLE : parsetablegen,
  Syntax : term,
  Name : str,
  Extension : str,
  Table : term
in
  (
    (
      rec-msg(generate-parsetable(Syntax?, eqs(Name?))) .
      Extension := "eqs.tbl"
    +
      rec-msg(generate-parsetable(Syntax?, trm(Name?))) .
      Extension := "trm.tbl"
    ) .
    execute(parsetablegen,GENTABLE?) .
    snd-eval(GENTABLE, generate-table(Syntax, Name, Extension)) .
    (
      rec-value(GENTABLE, generation-finished(Table?)) .
      snd-msg(parsetable(Table))
      +
      rec-value(GENTABLE, generation-failed).
      snd-msg(no-parsetable)
    ) .
    snd-terminate(GENTABLE, "done") .
    Syntax := none .
    Table := none
  )*
  delta
endlet


tool text-editor is {
  command = "gvim-editor"
}

process TextEditor is
let
  TE : text-editor,
  Path : term,
  Sort : term,
  Dirty : int,
  Fid : str,
  Location : int,
  SortName : str,
  Direction : str,
  StartPos : int,
  Length : int,
  FocusText : str,
  Focus : term,
  QueryList : list,
  QueryName : str,
  ActionName : str,
  ButtonName : list,
  ButtonItem : str,
  ButtonMenu : str,
  ButtonWalker : list,
  ButtonList : list,
  FileName : str,
  EditorId : term
in
  rec-msg(edit-text(EditorId?, FileName?, ButtonList?)) .
  execute(text-editor, TE?) .
  snd-eval(TE, edit-file(FileName)) .
  rec-value(TE, file-id(Fid?)) .



  ButtonWalker := ButtonList .
  (
    if not-equal(ButtonWalker, []) then
      ButtonName := first(ButtonWalker) .
      ButtonItem := index(ButtonName,size(ButtonName)).
      ButtonMenu := first(diff(ButtonName,[ButtonItem])).
      snd-do(TE, tb-add-menu-item(ButtonMenu, ButtonItem)) .
      ButtonWalker := next(ButtonWalker)
    fi
  )*
  if equal(ButtonWalker, []) then
    tau
  fi .



  subscribe(set-focus(<term>,<term>)).
  subscribe(clear-focus(<term>)).
  subscribe(get-focus-text(<term>,<term>)).
  subscribe(display-error(<term>,<int>)) .
  subscribe(move-editor-to-front(<term>)) .
  subscribe(reload-file(<term>,<term>)) .
  subscribe(kill-text-editor(<term>)) .
  snd-msg(text-editor-initialized(EditorId)) .
  (
    rec-note(set-focus(EditorId,
      focus(Path?, SortName?, area(StartPos?, Length?),Dirty?))) .
    snd-do(TE, tb-set-focus(Fid, SortName, StartPos, Length))
  +
    rec-note(clear-focus(EditorId)) .
    snd-do(TE, tb-unset-focus(Fid))
  +





    rec-note(get-focus-text(EditorId,
      focus(Path?, Sort?, area(StartPos?,Length?),Dirty?))) .
    snd-eval(TE, tb-get-focus-text(Fid, StartPos, Length)) .
    rec-value(TE, focus-text(Fid, FocusText?)) .
    snd-msg(focus-text(EditorId, FocusText))
  +
    rec-note(display-error(EditorId, StartPos?)) .
    snd-do(TE, tb-set-char-pos(Fid, StartPos)).
    snd-do(TE, tb-set-msg("Parse error near cursor"))
  +
    rec-note(move-editor-to-front(EditorId)) .
    snd-do(TE, move-editor-to-front(Fid))
  +
    rec-note(reload-file(EditorId, FileName?)) .
    snd-do(TE, reload-file(FileName))
  +
    rec-event(TE, set-current-location(Fid, Location?)) .
    snd-msg(set-current-location(EditorId, Location)) .
    snd-ack-event(TE, set-current-location(Fid, Location))
  +
    rec-event(TE, modified(Fid)) .
    snd-msg(set-modified(EditorId)) .
    snd-ack-event(TE, modified(Fid))
  +
    rec-event(TE, menu-event(ButtonMenu?, ButtonItem?, Fid)) .
    snd-msg(extra-button-action(EditorId, [ButtonMenu,ButtonItem])) .
    snd-ack-event(TE, menu-event(ButtonMenu, ButtonItem, Fid))
  ) *
  (
    rec-disconnect(TE).
    snd-msg(text-editor-disconnected(EditorId))
  +
    rec-note(kill-text-editor(EditorId)) .
    snd-terminate(TE, "You have been zapped!") .
    snd-msg(text-editor-killed(EditorId))
  )
endlet




process Tree2Graph is
let
  TG : tree2graph,
  Tree : term,
  Graph : term
in
  (
    rec-msg(tree2graph(Tree?)).
    execute(tree2graph, TG?).
    snd-eval(TG, tree2graph(Tree)).
    rec-value(TG, graph(Graph?)).
    snd-terminate(TG, "done") .
    snd-msg(graph(Graph))
  ) *
  delta
endlet

tool tree2graph is { command = "tree2graph" }
process ProcessButtons(CMNG : configmanager) is
let
  Contents : str,
  ErrorMessage : str
in
  snd-msg(io-read-file("meta.buttons")) .
  (
    rec-msg(io-file-contents(Contents?)) .
    snd-eval(CMNG, process-button-file("meta.buttons", Contents))
  +
    rec-msg(io-error-reading(ErrorMessage?)) .
    snd-eval(CMNG, process-button-file("meta.buttons", "buttons([])"))
  ) .
  rec-value(CMNG, buttons-processed) .
  snd-note(search-paths-processed)
endlet

process ConfigManager is
let
  CMNG : configmanager,
  Text : str,
  Fid : str,
  SearchPaths : list,
  ButtonName : list,
  ButtonNames : list,
  ButtonActions : list,
  ModuleName : str,
  EditorType : str,
  Tree : term,
  Term : term,
  Pid : int,
  LibraryPath : str,
  Directories : list,
  ErrorMessage : str
in
  execute(configmanager, CMNG?) .
  snd-msg(io-read-file("meta.conf")) .
  (
    rec-msg(io-file-contents(Text?))
  +
    rec-msg(io-error-reading(ErrorMessage?)) .
    Text := "."
  ) .
  snd-eval(CMNG, parse-config-file(Text)) .
  rec-value(CMNG, directories(Directories?)) .
  snd-msg(io-relative-to-absolute(Directories)) .
  rec-msg(io-absolute-directories(Directories?)) .
  snd-do(CMNG, register-user-directories(Directories)) .

  snd-msg(library-location-hook).
  rec-msg(library-location-hook-result(LibraryPath?)).
  snd-do(CMNG, register-library(LibraryPath)) .
  ProcessButtons(CMNG) .
  (
    rec-msg(refresh-buttons) .
    ProcessButtons(CMNG) .
    snd-msg(buttons-refreshed)
  +
    rec-msg(get-auxilary-buttons(EditorType?, ModuleName?)) .
    snd-eval(CMNG, get-button-names(EditorType, ModuleName)) .
    rec-value(CMNG, button-names(ButtonNames?)) .
    snd-msg(button-list(ModuleName, ButtonNames))
  +
    rec-msg(get-button-actions(ButtonName?, EditorType?, ModuleName?)) .
    snd-eval(CMNG, get-button-actions(ButtonName, EditorType, ModuleName)) .
    rec-value(CMNG, button-actions(ButtonActions?)) .
    snd-msg(button-actions(ButtonName,EditorType,ModuleName,ButtonActions))
  +
    rec-msg(get-search-paths) .
    snd-eval(CMNG, get-search-paths) .
    rec-value(CMNG, search-paths(SearchPaths?)) .
    snd-msg(search-paths(SearchPaths))
  ) * delta
endlet

tool configmanager is { command = "configmanager" }


process EditorManager is
let
  EM : editor-manager,
  Name : str,
  ModuleName: str,
  Editors: list,
  EditorId : term,
  Path : str,
  FileName : str
in
  execute(editor-manager, EM?) .
  subscribe(delete-editor(<term>)) .
  (
    rec-msg(get-editor-id(FileName?, ModuleName?)) .
    snd-eval(EM, get-editor-id(FileName, ModuleName)) .
    (
      rec-value(EM, new-editor(EditorId?)) .
      snd-msg(new-editor(EditorId))
    +
      rec-value(EM, existing-editor(EditorId?)) .
      snd-msg(existing-editor(EditorId))
    )
  +
    rec-msg(check-editor-id(Name?, ModuleName?)) .
    snd-eval(EM, check-editor-id(Name, ModuleName)) .
    (
      rec-value(EM, existing-editor(EditorId?)) .
      snd-msg(existing-editor(EditorId))
    +
      rec-value(EM, non-existing-editor) .
      snd-msg(non-existing-editor(Name))
    )
  +
    rec-msg(get-editor-name(EditorId?)) .
    snd-eval(EM, get-editor-name(EditorId)).
    rec-value(EM, editor-name(Name?)).
    snd-msg(editor-name(Name))
  +
    rec-msg(get-editors-by-module(Name?)) .
    snd-eval(EM, get-editors-by-module(Name)) .
    rec-value(EM, editors-by-module(Editors?)) .
    snd-msg(editors-by-module(Editors))
  +
    rec-note(delete-editor(EditorId?)) .
    snd-do(EM, delete-editor(EditorId))
  ) * delta
endlet

tool editor-manager is {
  command = "editor-manager"
}


process ApplyFunc is
let
  AF : apply-function,
  FuncName : str,
  SortName : str,
  TreeList : list,
  ArgNr : int,
  Tree : term,
  Tree2 : term,
  Result : term,
  ArgTree : term
in
  (
    rec-msg(apply-function(FuncName?, SortName?, TreeList?)).
    execute(apply-function, AF?).
    snd-eval(AF, apply-function-to-args(FuncName, SortName, TreeList)).
    rec-value(AF, tree(Tree?)).
    snd-terminate(AF, "done") .
    snd-msg(tree(Tree))
  +
    rec-msg(get-argument-given-number(Tree?, ArgNr?)).
    execute(apply-function, AF?).
    snd-eval(AF, get-argument-given-nr(Tree, ArgNr)).
    rec-value(AF, tree(ArgTree?)).
    snd-terminate(AF, "done") .
    snd-msg(tree(ArgTree))
  +
    rec-msg(equal-trees(Tree?, Tree2?)).
    execute(apply-function, AF?).
    snd-eval(AF, equal-trees(Tree, Tree2)).
    rec-value(AF, result(Result?)).
    snd-terminate(AF, "done") .
    snd-msg(Result)
  ) *
  delta
endlet

tool apply-function is { command = "apply-function" }

toolbus(ApplyFunc)





process META is
let
  Id : term,
  Syntax : str,
  Semantics : str,
  Term : str,
  Sort : term,
  Pid : int
in
  Id := process-id .
  (
    rec-msg(get-file-extensions) .
    snd-msg(file-extensions-hook).
    rec-msg(file-extensions-hook-result(Syntax?,Semantics?,Term?)).
    snd-msg(set-file-extensions(syntax(Syntax),rules(Semantics),term(Term)))
  +
    rec-msg(get-rules-top-sort) .
    snd-msg(semantics-top-sort-hook).
    rec-msg(semantics-top-sort-hook-result(Sort?)).
    snd-msg(set-rules-top-sort(Sort))
  +
    rec-msg(get-application-status) .
    snd-msg(status(interactive))
  ) * delta
endlet

process MetaCreator is
let
  Pid : int
in
  create(META, Pid?)
  . create(ButtonActionExecutor, Pid?)
  . create(ButtonActionReceiver, Pid?)
  . create(ClearAll, Pid?)
  . create(Compile-module, Pid?)
  . create(ConfigManager, Pid?)
  . create(DumpEquations, Pid?)
  . create(DumpParseTable, Pid?)
  . create(Editors, Pid?)
  . create(File-creator, Pid?)
  . create(GetEquations, Pid?)
  . create(GetParseTable, Pid?)
  . create(Io, Pid?)
  . create(LAYOUT-GRAPH, Pid?)
  . create(Meta-Interface, Pid?)
  . create(Module-Utilities, Pid?)
  . create(ModuleDB, Pid?)
  . create(Notify-about-changed-modules, Pid?)
  . create(Open-Sdf2-Language, Pid?)
  . create(Open-initial-module, Pid?)
  . create(Open-modules, Pid?)
  . create(PGen, Pid?)
  . create(ParseFocusses, Pid?)
  . create(Parser, Pid?)
  . create(PrintModule, Pid?)
  . create(RestoreBrackets, Pid?)
  . create(RestoreTermBrackets, Pid?)
  . create(Save-modules, Pid?)
  . create(Set-parsetable, Pid?)
  . create(Tree2Graph, Pid?)







endlet
tool user-interface is {
  command = "meta-studio"
}

process Status-display(UI: user-interface) is
let
  Lst : list,
  Str : str,
  Id : term
in
  subscribe(ui-status(<term>)) .
  ( rec-note(ui-status(stat(Id?, Str?))) .
    snd-do(UI, add-status(Id, Str))
    +
    rec-note(ui-status(statf(Id?, Str?, Lst?))) .
    snd-do(UI, add-statusf(Id, Str, Lst))
    +
    rec-note(ui-status(endstat(Id?))) .
    snd-do(UI, end-status(Id))
    +
    rec-note(ui-status(error(Str?))) .
    snd-do(UI, error(Str))
    +
    rec-note(ui-status(errorf(Str?, Lst?))) .
    snd-do(UI, errorf(Str, Lst))
  ) *
  delta
endlet

process Ui is
let
  SD : int,
  UI : user-interface,
  Id : term,
  Name : term,
  Str : term,
  Str1 : term,
  Mod : term,
  Pairs : list,
  Mods : list,
  ModName : str,
  FileName : str,
  Path : str,
  Extension : str,
  ErrMsg : str,
  On : term,
  Graph : term,
  Info : list,
  LayoutedGraph : term,
  ModuleName : str,
  LibraryPath : str,
  SyntaxExt : str,
  SemanticsExt : str,
  TermExt : str,
  EnvironmentName : str,
  Recursive : term,
  EditorId : term,
  GraphId : str,
  ButtonName : list,
  Tree : term,
  Lst : list,
  ButtonList : list,
  Title : str,
  Answer : term,
  T : str
in
  subscribe(display-import-graph(<list>)) .
  Id := process-id.
  execute(user-interface,UI?).
  create(Status-display(UI),SD?).

  snd-msg(library-location-hook).
  rec-msg(library-location-hook-result(LibraryPath?)).
  snd-msg(file-extensions-hook).
  rec-msg(file-extensions-hook-result(SyntaxExt?,SemanticsExt?,TermExt?)).
  snd-msg(environment-name-hook).
  rec-msg(environment-name-hook-result(EnvironmentName?)).

  snd-do(UI, initialize-ui(EnvironmentName, LibraryPath, SyntaxExt,
                           SemanticsExt, TermExt)).
  Mods := [] .
  Pairs := [] .
  (
    rec-msg(display-graph(GraphId?, Graph?)) .
    snd-do(UI, display-graph(GraphId, Graph))
  +
    rec-msg(ui-delete-modules(Mods?)).
    snd-do(UI, delete-modules(Mods))
  +
    rec-event(UI,get-module-info(ModName?)).
    snd-msg(get-module-info(ModName)) .
    rec-msg(module-info(ModName, Info?)) .
    snd-do(UI,module-info(ModName,Info)) .
    snd-ack-event(UI,get-module-info(ModName))
  +
    rec-event(UI,clear-all).
    snd-msg(clear-all).
    rec-msg(cleared-all).
    snd-ack-event(UI,clear-all)
  +
   ( rec-event(UI,debugging(On?)) .
     snd-msg(debugging(On)) .
     snd-ack-event(UI,debugging(On))
   ) +
   ( rec-note(display-import-graph(Pairs?)).
     snd-do(UI,new-graph(Pairs)) .
     Pairs := []
   )
   +
   ( rec-event(UI, layout-graph(GraphId?, Graph?)) .
     snd-msg(layout-graph(Graph)) .
     rec-msg(graph-layouted(LayoutedGraph?)) .
     snd-do(UI, graph-layouted(GraphId, LayoutedGraph)) .
     snd-ack-event(UI, layout-graph(GraphId, Graph))
   )
   +
   ( rec-event(UI, get-buttons(T?, ModuleName?)) .
     snd-msg(get-auxilary-buttons(T, ModuleName)) .
     rec-msg(button-list(ModuleName,ButtonList?)).
     snd-do(UI, buttons-found(T, ModuleName, ButtonList)) .
     snd-ack-event(UI, get-buttons(T, ModuleName))
   )
   +
   ( rec-event(UI, button-selected(T?, ModuleName?, ButtonName?)) .
     snd-msg(extra-button-action(ButtonName, str(ModuleName), T, ModuleName, ui-id)) .
     snd-ack-event(UI, button-selected(T, ModuleName, ButtonName))
   )
   +
   ( rec-event(UI, button-selected(T?, ButtonName?)) .
     snd-msg(extra-button-action(ButtonName, T, "*", ui-id)) .
     snd-ack-event(UI, button-selected(T, ButtonName))
   )
   +
   ( rec-msg(ask-for-file(Title?, Path?, Extension?)) .
     snd-eval(UI, show-file-dialog(Title, Path, Extension)) .
     rec-value(UI, file-name(FileName?)) .
     snd-msg(ask-for-file-result(FileName))
   )
   +
   ( rec-msg(ask-question(Title?)) .
     snd-eval(UI, show-question-dialog(Title)) .
     rec-value(UI, answer(Answer?)) .
     snd-msg(ask-question-result(Answer))
   )
   +
   ( rec-msg(decons-file-name(FileName?, Extension?)) .
     snd-eval(UI, decons-filename(FileName, Extension)) .
     rec-value(UI, file-name(Path?, FileName?, Extension?)) .
     snd-msg(decons-file-name-result(Path, FileName, Extension))
   )
   +
   ( rec-msg(clear-history) .
     snd-do(UI, clear-history)
   )
   +
   (
     rec-event(UI, element-selected(ButtonName?, Tree?)).
     snd-msg(extra-button-action(ButtonName, Tree, "message-list", "*", message-id)).
     snd-ack-event(UI, element-selected(ButtonName, Tree))
   )
   +
   (
     rec-msg(update-list-view(Lst?)).
     snd-do(UI, update-list(Lst))
   )
  ) *
  ( rec-event(UI,quit)
  + rec-disconnect(UI)) .
  shutdown("MetaStudio exiting\n")
endlet

process MetaGUI is
let
  ModuleName : str,
  Pid : int
in
  create(Ui, Pid?) .
  create(MetaCreator, Pid?) .
  if not-equal("","") then
    snd-msg(open-modules([""])) .
    rec-msg(finished-opening-modules)
  else
    tau
  fi
endlet

toolbus(MetaGUI)
