%%  Functionality-to-SDF
%%
%%  This module defines how a MetaNotation functionality like
%%  succ _ :: natural -> natural
%%  is to be translated to SDF
%%  succ  Natural -> Natural
%%
%%  Given a general functionality  Symbol :: Terms -> Term,
%%  the place holders in Symbol are filled with the sorts represented by Terms.
%%  Not all Terms can be represented by SDF sorts; only the following
%%  patterns are recognized as useful sorts:
%%  SORT = Alpha | Alpha* | Alpha+ | Alpha Rest | Rest Alpha | ( SORT )
%%
%%  Rest can be something like [ terminating ], and is ignored.
%%
%%  Thus, functionality
%%  sum _ :: (nat, nat) -> nat
%%  is transformed into:
%%  sum "(" nat "," nat ")" -> nat
%%
%%  evaluate _ :: statement -> action [ diverging ]
%%  is translated to
%%  evaluate Statement -> Action
%%
%%
%%  Moreover, functionalities of the MetaNotation can be given in the equations.
%%  Attempts are made to translate equations starting with tag "*" to an SDF rule.
%%  This will be done for:
%%
%%  *    Alpha1 = Alpha2  .         which produces   Alpha2   -> Alpha1
%%  *    Alpha1 = Alpha2* .            "      "      Alpha2*  -> Alpha1
%%  *    Alpha1 = Alpha2+ .            "      "      Alpha2+  -> Alpha1
%%  *    Alpha1 =< Alpha2 .            "      "      Alpha1   -> Alpha2
%%  *    Alpha1 >= Alpha2 .            "      "      Alpha2   -> Alpha1
%%  *    Term : Alpha Rest .           "      "      Term     -> Alpha
%%
%%  These are the cases that are currently recognized.
%%  N.B. a more systematic description (and justification)
%%  of the cases that can be translated to SDF is required.
%%
%%
%%  Authors:  Arie van Deursen, CWI, Amsterdam
%%            Peter D. Mosses, Aarhus, Denmark.
%%  Date: May 1993.


imports SDF-Syntax-Operations
        MetaNotation
        Character-Operations

exports
  context-free syntax
    func2sdf( CLAUSE )                                  -> SECTION  {incremental}

hiddens
  sorts CF-ELEM-LIST-LIST
  context-free syntax
    syms-funcs( SYMBOLS, FUNCTIONALITIES )              -> SECTION  %% {incremental}
    sym-funcs( SYMBOL, FUNCTIONALITIES )                -> SECTION
    sym-func( SYMBOL, FUNCTIONALITY )                   -> SECTION
    form2sdf( FORMULA )                                 -> SECTION
    do-func( SYMBOL, TERMS, TERM  )                     -> SECTION

    sym2cfe( SYMBOL )                                   -> CF-ELEM-LIST
    "\\Box"                                             -> CF-ELEM
    ogpl2cfe( OUTER-GROUP-PLACE* )                      -> CF-ELEM-LIST
    ogp2cfe( OUTER-GROUP-PLACE )                        -> CF-ELEM-LIST
    igpl2cfe( INNER-GROUP-PLACE* )                      -> CF-ELEM-LIST
    igp2cfe( INNER-GROUP-PLACE )                        -> CF-ELEM-LIST

    terms2cfe( TERMS )                                  -> CF-ELEM-LIST-LIST
    term2cfe( TERM )                                    -> CF-ELEM-LIST
    tigpl2cfe( T-INNER-GROUP-PLACE * )                  -> CF-ELEM-LIST
    tigp2cfe( T-INNER-GROUP-PLACE )                     -> CF-ELEM-LIST
    term2output( TERM )                                 -> CF-ELEM-LIST

    constant2cfe( TERM )                                -> CF-ELEM-LIST
    con-ogpl2cfe( T-OUTER-GROUP-PLACE* )                -> CF-ELEM-LIST
    con-ogp2cfe( T-OUTER-GROUP-PLACE )                  -> CF-ELEM-LIST
    con-og2cfe( T-OUTER-GROUP )                         -> CF-ELEM-LIST
    con-igpl2cfe( T-INNER-GROUP-PLACE* )                -> CF-ELEM-LIST
    con-igp2cfe( T-INNER-GROUP-PLACE )                  -> CF-ELEM-LIST

    "[" { CF-ELEM-LIST "," }* "]"                       -> CF-ELEM-LIST-LIST
    CF-ELEM-LIST-LIST "++" CF-ELEM-LIST-LIST            -> CF-ELEM-LIST-LIST
    merge(CF-ELEM-LIST, CF-ELEM-LIST-LIST)              -> CF-ELEM-LIST


  variables
    Form                        -> FORMULA
    Form "+"                    -> { FORMULA ";" }+
    Clause "+"                  -> { TAGGED-CLAUSE ";" }+
    "'" Symbol                  -> SYMBOL
    "'" Symbol "+"              -> { SYMBOL "," }+
    "'" SymCon                  -> SYMBOL-CON
    "'" Symbols                 -> SYMBOLS
    Func                        -> FUNCTIONALITY
    Func "+"                    -> { FUNCTIONALITY ";" }+
    Functionalities             -> FUNCTIONALITIES
    Attributes                  -> { ATTRIBUTE "," }+
    AttributeList               -> ATTRIBUTE-LIST
    Disjoiner                   -> DISJOINER
    Relation                    -> RELATION
    "'" Terms                   -> TERMS
    "'" Term-plus [0-9]*        -> { TERM "," }+
    "'" Term  [0-9]*            -> TERM
    "'" Term-og [0-9]*          -> T-OUTER-GROUP
    "'" Term-ogp-star [0-9]*    -> T-OUTER-GROUP-PLACE*
    "'" Alpha [0-9]*            -> ALPHA
    "'" Non-Alpha [0-9]*        -> NON-ALPHA
    "'" Upper-Alpha [0-9]*      -> UPPER-ALPHA
    "'" Place [0-9]*            -> PLACE
    "'" OGP [0-9]*              -> OUTER-GROUP-PLACE
    "'" OGP-star [0-9]*         -> OUTER-GROUP-PLACE*
    "'" IGP [0-9]*              -> INNER-GROUP-PLACE
    "'" IGP-star [0-9]*         -> INNER-GROUP-PLACE*
    "'" OG [0-9]*               -> OUTER-GROUP
    "'" CF-Elem [0-9]*          -> CF-ELEM
    "'" CF-Elem-star [0-9]*     -> CF-ELEM*
    "'" CF-Elem-plus [0-9]*     -> CF-ELEM+
    "'" CF-List [0-9]*          -> CF-ELEM-LIST
    "'" CF-List-star [0-9]*     -> { CF-ELEM-LIST "," }*
    "'" CF-List-plus [0-9]*     -> { CF-ELEM-LIST "," }+
    "'" TIGP [0-9]*             -> T-INNER-GROUP-PLACE
    "'" TIGP-star [0-9]*        -> T-INNER-GROUP-PLACE*
    "'" TOG [0-9]*              -> T-OUTER-GROUP
    "'" TOGP [0-9]*             -> T-OUTER-GROUP-PLACE
    "'" TOGP-star [0-9]*        -> T-OUTER-GROUP-PLACE*
    "'" T-Place [0-9]*          -> T-PLACE
