%%%% $Id$

equations

%% The function $\mfun{l}\sem{\_}$ generates a production for each literal symbol
%% in the grammar.
%% The production generated for a literal $L$ has the form $\alpha\to{}L$, where
%% $\alpha$ is a list of singleton character classes representing the characters
%% of $L$. This list is produced by the function \fun{chars}.

  [0]         l[[_G]]             = _G syntax literals(symbols(_G))
  [0]         literals({L})       = chars(L) -> L
  [0]         literals({l})       = ci-chars(l) -> l
  [default-0] literals({_A})      =
  [0]         literals({})        =
  [0]         literals({'a+ 'b+}) = literals({'a+}) ++ literals({'b+})

%% The function \fun{chars} scans the characters in the literal string,
%% translating them to short characters. These are then normalized to
%% numeric character codes by character normalization. The third equation
%% tries if the first character of the string is a short-character by
%% normalizing it and then testing whether it has reduced to a numeric
%% character. This works for letters and digits.
%% If this fails, the fourth equation translates the character
%% to an escaped short-character, which succeeds for all other characters.
%% Characters that are already escaped are handled by the second equation.

  [empty]
        chars("")  =

  [newline]
        cc := [shortchar(\\ n)]
        ===========================================
        chars(strcon(\" strchar(\n) C* \")) = 
	cc ++ chars( strcon(\" C* \") )

  [tab]
        cc := [shortchar(\\ t)]
        ===========================================
        chars(strcon(\" strchar(\t) C* \")) = 
	cc ++ chars( strcon(\" C* \") )

  [quote]
        cc := [shortchar(\\ \")]
        ===========================================
        chars(strcon(\" strchar(\") C* \")) = 
	cc ++ chars( strcon(\" C* \") )

  [backslash]
        cc := [shortchar(\\ \\)]
        ===========================================
        chars(strcon(\" strchar(\\) C* \")) = 
	cc ++ chars( strcon(\" C* \") )

  [normal]
        cc := [shortchar(h)], [numchar(\\ d+)] := cc
        ====================================================================
        chars(strcon(\" strchar(h) C* \") ) = 
	cc ++ chars( strcon(\" C* \") )

  [default-special]
        cc := [shortchar(\\ h)], [numchar(\\ d+)] := cc
        ====================================================================
        chars(strcon(\" strchar(h) C* \") ) = 
	cc ++ chars( strcon(\" C* \") )

  [octal]
        cc := [numchar(\\ d1 d2 d3 )]
        =========================================
        chars( strcon(\" strchar(\ d1 d2 d3) C* \") ) = 
	cc ++ chars(strcon(\" C* \"))

equations

  [forward-to-chars-and-extend-classes]
	'a+ := chars(strcon(\" C* \")),
	'a+2 := extend('a+)
	======================================
	ci-chars(singlequotedstrcon(\' C* \')) = 'a+2


equations

[empty] extend() = 

[loop] 	_A2  := extend(_A),
	'a+2 := extend('a+)
	=========================
	extend(_A 'a+) = _A2 'a+2

[lowercase] 
	[_c] := cc,
	a <= _c == true,
	_c <= z == true
	===>
	extend(cc) = [_c char(int(_c) - 32)]

[uppercase] 
	[_c] := cc,
	A <= _c == true,
	_c <= Z == true
	===>
	extend(cc) = [_c char(int(_c) + 32)]

[default] extend(_A) = _A
 
tests

[a] extend([a]) == [aA]  
[z] extend([z]) == [zZ]  
[A] extend([A]) == [Aa] 
[Z] extend([Z]) == [Zz]  
[d] extend([\$]) == [\$]

equations

%% Prefix function productions are translated to normal productions by 
%% enclosing the parentheses and commas in double quotes.

  [0] I ('g) -> _A!       = id2str(I) "(" ++ symbols('g) ++ ")" -> _A!
  [0] $L ('g) -> _A! 	  = $L "(" ++ symbols('g) ++ ")" -> _A!

  [0] symbols()           =
  [0] symbols(_A)         = _A
  [0] symbols('g+1, 'g+2) = symbols('g+1) ++ "," ++ symbols('g+2)

  [0] id2str(idcon(h)) = strcon(\" strchar(h) \")
  [0] id2str(idcon(h1 h2 t)) = strcon(\" strchar(h1) C* \")
	when strcon(\" C* \") := id2str(idcon(h2 t))
