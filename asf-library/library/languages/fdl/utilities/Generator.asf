equations 

[] TypeEnv := construct-type-environment(FeatureModule),
   ValueEnv := construct-value-environment(FeatureModule),
   ParameterEnv := construct-parameter-environment(FeatureModule),
   C-Program1 := generateFunction(FeatureModule, TypeEnv, ValueEnv, ParameterEnv),
   module Modulename ImportSection* FeatureDiagram := FeatureModule,
   C-Program2 := generateGlobals(Modulename, C-Program1, ParameterEnv),
   C-Program3 := addIncludeSection(C-Program2)
   ===
   generate(FeatureModule) = C-Program3

[] Keys := keys(TypeEnv),
   Declaration* := generateFunctionDeclarations(Keys, TypeEnv, ValueEnv),
   module Modulename ImportSection* Section*1 arguments Argument* Section*2 := FeatureModule,
   Statement* := generateFunctionStatements(Argument*, , ParameterEnv)
   ===
   generateFunction(FeatureModule, TypeEnv, ValueEnv, ParameterEnv) = 

void handleOptions(int argc, char **argv) {
  int c;
 
  Declaration* 

  while ((c = getopt(argc, argv, myArguments)) != -1) {
    switch(c) {
      Statement*
    }
  }
}


equations

[] StringConstant := idcon2stringconstant(IdCon)
   ===
   generateGlobals(IdCon, C-Program1, ParameterEnv) = 

static const char programname[] = StringConstant;
static const char myArguments[] = "";
static const char myVersion[] = VERSION;
C-Program1


equations

[] addIncludeSection(C-Program) = 
     
#include <stdio.h> 
#include <stdlib.h> 
     
#include "options.h" 
     
C-Program


equations

[] generateFunctionDeclarations([], TypeEnv, ValueEnv) = 

[] lookup(TypeEnv, AtomicFeature) == boolean,
   Declaration := int af2id(AtomicFeature);
   ===
   generateFunctionDeclarations([AtomicFeature, AtomicFeature*], TypeEnv, ValueEnv) =
    Declaration generateFunctionDeclarations([AtomicFeature*], TypeEnv, ValueEnv)

[] lookup(TypeEnv, AtomicFeature) == string,
   Declaration := char* af2id(AtomicFeature) = NULL;
   ===
   generateFunctionDeclarations([AtomicFeature, AtomicFeature*], TypeEnv, ValueEnv) =
    Declaration generateFunctionDeclarations([AtomicFeature*], TypeEnv, ValueEnv)

[default-generateFunctionDeclarations] 
   Declaration := char* af2id(AtomicFeature) = "Value";
   ===
   generateFunctionDeclarations([AtomicFeature, AtomicFeature*], TypeEnv, ValueEnv) =
    Declaration generateFunctionDeclarations([AtomicFeature*], TypeEnv, ValueEnv)


equations

[] ArgumentChar := lookup(ParameterEnv, AtomicFeature),
   CharacterConstant := ac2cc(ArgumentChar),
   Identifier1 := af2os(AtomicFeature),
   Identifier2 := af2og(AtomicFeature)
   ===
   generateFunctionStatements(AtomicFeature, Statement*, ParameterEnv) = 

Statement* 
case CharacterConstant:
  Identifier1(!Identifier2());
  break;

[] lookup(ParameterEnv, AtomicFeature) == not-in-table
   ===
   generateFunctionStatements(AtomicFeature, Statement*, ParameterEnv) = Statement*


equations

[] identifier(caphead tail) := af2cid(AtomicFeature)
   ===
   af2og(AtomicFeature) = identifier(OPT\_getFlag caphead tail)

[] identifier(caphead tail) := af2cid(AtomicFeature)
   ===
   af2os(AtomicFeature) = identifier(OPT\_setFlag caphead tail)


equations

[] af2id(atomicfeature(head)) = identifier(head)
[] af2id(atomicfeature(head tail)) = identifier(head tail)


equations

[] ac2cc(argumentchar(argchar)) = characterconstant(\' argchar \')


equations

[] bytes(byte(caphead)) := capitalize(bytes(byte(head)))
   ===
   af2cid(atomicfeature(head tail)) = identifier(caphead tail)


equations

[] idcon2stringconstant(idcon(idhead)) = stringconstant(\" stringchar(idhead) \")

[] stringconstant(\" stringchar(idhead) char* \") := idcon2stringconstant(idcon(idhead idtail))
   ===
   idcon2stringconstant(idcon(idhead idmiddle idtail)) = stringconstant(\" stringchar(idhead) stringchar(idmiddle) char* \")

