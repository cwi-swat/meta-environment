module strategies/Operators[X]

imports basic/Whitespace
imports basic/Booleans

hiddens imports asf/Comments

exports sorts Strategy

lexical syntax

[a-z] -> StrategyVar

context-free syntax
    (X=>X) ":" X                     -> X          {cons("rule")}
    (X=>X)                        	 -> Strategy   {cons("func-name")}
    "<" Strategy ">" X 				    	 -> X          {cons("apply")}

context-free syntax
    "fail"                         -> Strategy {cons("fail")}
    "id"                           -> Strategy {cons("id")}
    "(" Strategy ")"               -> Strategy {bracket}
    Strategy ";" Strategy          -> Strategy {cons("seq"), right}
    Strategy "+" Strategy          -> Strategy {cons("choice"), right}
    Strategy "<+" Strategy         -> Strategy {cons("lchoice"), right}
    StrategyVar                    -> Strategy {cons("var")}
    "rec" StrategyVar "(" Strategy ")" -> Strategy {cons("recursion")}

    "some" "(" Strategy ")"        -> Strategy {cons("some")}
    "one" "(" Strategy ")"         -> Strategy {cons("one")}
    "all" "(" Strategy ")"         -> Strategy {cons("all")}



context-free priorities
    Strategy ";" Strategy          -> Strategy {cons("seq"), right} >
  { right: Strategy "+" Strategy          -> Strategy {cons("choice"), right} 
           Strategy "<+" Strategy         -> Strategy {cons("lchoice"), right} }
   
hiddens

context-free syntax
   "fail"             -> X {cons("fail")}    
   some(Strategy,X)   -> X {built-in("strategy-some")}
   all(Strategy,X)    -> X {built-in("strategy-all")}
   one(Strategy,X)    -> X {built-in("strategy-one")}
   choice(Strategy,Strategy,X) -> X
   sequence(Strategy,Strategy,X) -> X
   function((X=>X),X) -> X



context-free syntax
   subst(Strategy,StrategyVar,Strategy) -> Strategy {traversal(trafo,bottom-up)}
 
variables

"f"[0-9\']* -> (X=>X)
"r"[0-9\']* -> (X=>X)
"S"[0-9\']* -> Strategy
"T"[0-9\']* -> X
"x"[0-9\']* -> StrategyVar
