\documentclass{llncs}
 
\usepackage[english]{babel}
\usepackage{epsfig}
\usepackage{url}
\usepackage{alltt}
\usepackage{xspace}
%%\usepackage{fancyheadings}
\usepackage{latexsym}
\usepackage{graphics}
%%\usepackage[dvips]{color}
\usepackage{times}
\usepackage{mathptm}
\usepackage{verbatim}
 
\newcommand{\TB}{\textsc{ToolBus}}
\newcommand{\asfplussdf}{ASF+SDF}
\newcommand{\asdf}{{\sc Asf+Sdf}}
\newcommand{\asf}{{\sc Asf}}
\newcommand{\sdf}{{\sc Sdf}}

\newcommand{\spec}[1]{\texttt{#1}}

%%\newcommand{\note}[1]{{\bf Note}: {\it #1 }}


\title{ToolBus: The Next Generation}
\author{Hayco de Jong\inst{1} and Paul Klint\inst{1,2}}

\institute{Centrum voor Wiskunde en Informatica, The Netherlands
\and
Informatics Institute, University of Amsterdam, The Netherlands}

\begin{document}
\maketitle
 
\begin{abstract}
xxxxx
\end{abstract}

\section{Generic Language Technology}

Our primary interest is \emph{generic language technology}
that aims at the rapid construction of tools for a wide variety
of programming and application languages.
Its central notion is a \emph{language definition}
of some programming or application language.

The common methodology is that a language is identified in a given
domain, that relevant aspects of that language are formally defined
and that desired tools are generated on the basis of this language
definition. This generative approach is illustrated in
Figure~\ref{Fig:generator}. Using a definition for some language $L$
as starting point, a generator can a produce a range of tools for
editing, manipulating, checking or executing $L$ programs.

Language aspects have to be defined, analyzed, and used to generate
appropriate tooling such as compilers, interpreters, typecheckers,
syntax-directed editors, debuggers, partial evaluators, test case
generators, documentation generators, and more.

Language definitions are used, on a daily basis, in application areas
as disparate as Cobol renovation, Java refactoring, smart card
verification and in application generation for domains including
finance, industrial automation and software engineering.  In the case
of Cobol renovation, the language in question is Cobol and those
aspects that are relevant for renovation have to be formalized. In the
case of application generation, the language in question is probably
new and has to be designed from scratch.

\begin{figure}
\epsfig{figure=figs/generator.eps,width=\textwidth,height=12cm}
\vspace*{-7cm}
\caption{\label{Fig:generator}From language definition to generated programming environment}
\end{figure}

\subsection{One realization: the \asdf\ Meta-Environment}

The \asdf\ Meta-Environment~\cite{XXX} is an incarnation of the
approach just described and covers both the interactive development of
language definitions and the generation of tools based on these
language definitions.

In this paper we are primarily interested in the \emph{software engineering
aspects} of building such a system. Starting point is the \asdf\
Meta-Environment as we had completed it in the beginning of the
1990's.  This was a monolithic 200 KLOC Lisp program that was hard to
maintain.  It had all the traits of a legacy system and was the
primary motivation to enter the area of system and software
renovation. 

\subsection{Towards a component-based architecture}

We give a brief timeline of our efforts to transform the old,
monolithic, implementation of the Meta-Environment into a
well-structured, component-based, implementation.

In 1992, first, unsuccessfull, experiments to decompose the system
into separate parts~\cite{BakkerKoorn93}.  The idea was to separate
the user-interface and the text editor from the rest of the system.
The user-interface was completely re-implemented as a separate
component and as text editor we re-used Emacs. In hindsight, we were
unaware of the fact that we made the transition from a completely
sequential system to a system with several concurrent
components. Unavoidably, we encountered hard to explain deadlocks and
race conditions..

In 1993, a next step was to write a formal specification of the
desired system behaviour~\cite{P9415} using PSF, a specification language based on
proces algebra and algebraic specifications (** cite **).  Simulation
of this specification unvealed other, not yet observed, deadlocks.
Although, this was clearly an improvement over the then existing situation,
this specification appraoch also had its limitations and drawbacks:

\begin{itemize}

\item The specification lacked generality. It would, for instance, have
been a major change to add the description of a new component.

\item The effort to write the PSF specification was significant and there was no
way to derive an actual implementation from this specification.

\end{itemize}

In 1994, the first version of the \TB\ was
completed~\cite{BergstraKlint94,TB-COORD96}.  The key idea was to
organize a system along the lines of a software bus and to make this
bus programmable by way of a scripting language (T-script) that was
based on ACP (Algebra of Communicating Processes, \cite{XXX}).
Another idea was to use a uniform data format (called \TB\ terms) to
exchange data between \TB\ and tools.  At the implementation level,
T-scripts were executed by an interpreter and communication between
tools and \TB\ took place using TCP/IP sockets. In this way,
multi-language, distributed, applications could be built with
significantly less effort than using plain C and sockets.

Based on various experiments~\cite{XXX}, in 1995 a new version of the
\TB\ was designed and implemented: the Discrete Time
ToolBus~\cite{BergstraKlint95,TB-AMAST96,TB-SOCP98}.  Its main
innovation were primitives for expressing timing considerations
(delay, timeout) and for operating on a limited set of built-in
datatypes (booleans, integers, reals, lists).
The Discrete Time \TB\ has been used for the restructuring of the
\asdf\ Meta-Environment~\cite{BHK97}. A first version was released
in 2001~\cite{BDHJJKKMOSVVV01}.

In the meantime, the exchange format has also evolved from the toolbus
terms mentioned above to ATerms~\cite{BJKO00}: a term format that
supports maximal subterm sharing and a very concise, sharing
preserving, binary exchange format. ATerms decrease memory usage
thanks to sharing and they permit a very fast equality test since
structural equality can be replaced by pointer equality thanks to the
maximal subterm sharing.

Today, beginning 2003, it turns out that the original software
engineering goals that triggered the development of the \TB\ have been
achieved and that the Meta-Environment can now be even further
stretched than anticipated~\cite{RTA}. Therefore, it is time for some
reflection.  What have we learned from this major renovation project
and what are the implications for the \TB\ design and implementation.

\subsection{Plan of this Paper}

\section{Coordination, Representation and Computation}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/component-architecture.eps,height=12cm}
\end{center}
\vspace*{-7cm}
\caption{\label{Fig:component-architecture}Separating coordination
  from computation}
\end{figure}

It has been observed by various authors~\cite{XXX}, that the overall
architecture of a software system can be improved by separating
\emph{coordination} from \emph{computation}. We also distinguish
\emph{representation} and use the following definitions:

\begin{itemize}
\item Coordination: the way in which program and system parts interact
  (using procedure calls, remote method invocation, middleware, and others).

\item Representation: language and machine neutral data exchanged
  between components.

\item Computation: program code that carries out a specialized task.

\end{itemize}

Our assumption is now that \emph{a rigorous separation of coordination
from computation leads to flexible and reusable systems.} The approach
is illustrated in Figure~\ref{Fig:component-architecture}.

In the case of the \asdf\ Meta-Environment, empirical evidence shows
that
\begin{itemize}
\item The \TB-based version of the \asdf\ Meta-Environment is more
flexible as illustrated by the fact that clones of the
Meta-Environment start to appear for other languages than
\asdf. Examples are Action Semantics~\cite{XXX} and Elan~\cite{XXX}.

\item Various components of the \asdf\ Meta-Environment are being
reused in other projects~\cite{XXX}.

\end{itemize}

\section{The \TB\ Architecture}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/toolbus.eps,height=14cm}
\end{center}
\vspace*{-9cm}
\caption{\label{Fig:toolbus-architecture}The \TB\ architecture}
\end{figure}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/toolbus-scenario.eps,height=14cm}
\end{center}
\vspace*{-8cm}
\caption{\label{toolbus-scenario}A typical cooperation scenario}
\end{figure}

\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline Primitive		& Description	\\ \hline \hline
\spec{delta}			& inaction (``deadlock'') \\
\spec{+}			& choice between two alternatives ($P_1$ or $P_2$)\\
\spec{.}			& sequential composition ($P_1$ followed by $P_2$)\\
\spec{*}			& iteration (zero or more times $P_1$ followed by $P_2$)\\
\spec{create}			& process creation\\ \hline
\spec{snd-msg}			& send a message (binary, synchronous)\\
\spec{rec-msg}			& receive a message (binary, synchronous)\\ \hline
\spec{snd-note}			& send a note (broadcast, asynchronous)\\
\spec{rec-note}			& receive a note (asynchronous)	\\
\spec{no-note}			& no notes available for process\\
\spec{subscribe}		& subscribe to notes\\
\spec{unsubscribe}		& unsubscribe from notes\\ \hline
\spec{snd-eval}			& send evaluation request to tool\\
\spec{rec-value}		& receive a value from a tool	\\
\spec{snd-do}			& send request to tool (no return value)\\
\spec{rec-event}		& receive event from tool\\
\spec{snd-ack-event}		& acknowledge a previous event from a tool\\ \hline
\spec{if ... then ... fi}	& guarded command\\
\spec{if ... then ... else ... fi} 	& conditional\\
				& expressions	\\
\spec{||}			& communication-free merge (parallel composition) \\
\spec{let ... in ... endlet}	& local variables \\
\spec{:=}			& assignment	\\ \hline

\spec{delay}			& relative time delay\\
\spec{abs-delay}		& absolute time delay\\
\spec{timeout}			& relative timeout\\
\spec{abs-timeout}		& absolute timeout\\ \hline

\spec{rec-connect}		& receive a connection request from a tool\\
\spec{rec-disconnect}		& receive a disconnection request from a tool\\
\spec{execute}			& execute a tool\\
\spec{snd-terminate}		& terminate the execution of a tool\\
\spec{shutdown}			& terminate \TB	\\ \hline

\spec{attach-monitor}		& attach a monitoring tool to a process\\
\spec{detach-monitor}		& detach a monitoring tool from a process \\ \hline
\end{tabular}
\end{center}
\caption{\label{Tab:Tscript-features}Overview of \TB\ primitives}

\end{table}

The goals of the\TB\ is to integrate tools written in different
languages running on different machines.  This is achieved by means of
a programmable software bus as illustrated in
Figure~\ref{Fig:toolbus-architecture}.  The \TB\ coordinates the
cooperation of a number of tools.  This cooperation is described by a
T-script that runs inside the \TB. The result is a set of concurrent
processes inside the \TB\ that can communicate with each other and
with the tools. Tools can be written in any language and can run on
different machines. They exchange data by way of ATerms.

A typical cooperation scenario is illustrated in
Figure~\ref{toolbus-scenario}.  A user-interface (UI) and a database
(DB) are combined in an application. Pushing a button in the
user-interface leads to a database action and the result is displayed
in the user-interface. In a traditional approach, the database action
is directly connected to the user-interface button by means of a
call-back function. This implies that the user-interface needs some
knowledge about the database tool and vice versa.  In the \TB\
approach the two components are completely decoupled: pushing the
button only leads to an event that is handled by some process in the
\TB. This process routes the event to the database tool (likely via
some intermediary process) and gets the answer back via the inverse
route. This implies that the configuration knowldege is now
completekly localized in the the Tscript and that UI and DB do not
even know about each others existence.

The primitives that can be used in Tscripts are listed in
Table~\ref{Tab:Tscript-features}. 

\section{An example}

\note{The adress book}

\section{Application to the \asdf\ Meta-Environment}

\begin{figure}
\epsfig{figure=figs/meta-env.eps,width=\textwidth}
\vspace*{-12cm}
\caption{\label{Fig:meta-env}Architecture of the \asdf\ Meta-Environment.}
\end{figure}

As already sketches above, the \TB\ has been used to restructure the
\asdf\ Meta-Environment. It consists of a cooperation of 27 tools
ranging from a user-interface, graph browser, various editors,
compiler and interpreter, to a parser generator and a repository for
parse trees.  A simplified view is shown in Figure~\ref{Fig:meta-env}.

\begin{table}[tb]
\begin{center}
\begin{tabular}{|l|r|r|r|} \hline
Language        & KLOC$^\dagger$ & Generated KLOC & Total KLOC\\ \hline \hline
ASF+SDF         & 12	 & 170 (C) & \\
C 	        & 80$^{\dagger\dagger}$  & & \\
Java, Tcl/Tk    &  5  & &\\
Makefiles, etc	&  5  & &\\
Tscrips   	&  5  & &\\ \hline
Total LOC:	& 107 & 170 & 277 \\\hline

ToolBus script &  4.6\% &  & 1.8\%\\ \hline
\end{tabular}

$^\dagger$ Kilo Lines of Code  excluding third party code
such as emacs, dot, and the like.

$^{\dagger\dagger}$ This includes 10000 LOC (C code) for the \TB\
implementation itself.
\end{center}

\caption{\label{Tab:language-stats}Facts concerning implementation languages}
\end{table}

\begin{table}[tb]
\begin{center}
\begin{tabular}{|l|r|}\hline
Primitive                            & Number of occurrences \\ \hline \hline

process definitions                  & 104\\
tool definitions                     & 27\\
\texttt{.} (sequential composition)  & 4343\\
\texttt{+} (choice)                  & 341\\
\texttt{*} (iteration)               & 243\\
\texttt{||} (parallell composition)  & 3\\

\texttt{snd-msg}                     & 555\\
\texttt{rec-msg}                     & 541\\
\texttt{snd-note}                    & 100\\
\texttt{rec-note}                    & 24\\
\texttt{snd-do}/\texttt{snd-eval}    & 220\\
\texttt{rec-event}                   & 56\\
\texttt{create}                      & 58 \\ \hline
\end{tabular}
\end{center}
\caption{\label{Tab:Tscript-stats}Facts concerning Tscript primitives}
\end{table}


Our insight can be further increased by considering some
statistics. In Table~\ref{Tab:language-stats} the relative sizes of
the various implementation languages used in the Meta-Environment.  In
the column \emph{language} the various language are listed.  In column
\emph{KLOC} the size (in Kilo Lines Of Code) is given for each
language. The result is 107 KLOC for the whole system of which 4.6\%
are Tscripts.  If we consider the fact that \asdf\ specification are
compiled to C code, another view is possible as well: 12 KLOC of \asdf
generates 170 KLOC of C code (!). Taking this generated code into
account, the total size of the whole system amounts to 277 KLOC of
which 1.8\% are Tscripts. This is compatible with the expectation that
Tscripts are relatively small and form high-level ``glue'' to connect
musvh larger components.

\textbf{Part of the C code is generated by ApiGen; it might be
  interesting to measure ApiGen in put and its output.}

Another conclusion from these facts is that low-level information for
building the software (makefiles and configuration scripts) are of the
same size as the high level Tscripts. This points into the direction
that the level of these build scripts should be raised. This
conclusion will, however, not be further explored in this paper.


Another view is given in Table~\ref{Tab:Tscript-stats} where the
frequency of occurrence of Tscript primitives is shown.  Clearly,
sequential composition (\spec{.}) is the dominant operator and
sending/receiving (\spec{snd-msg}, \spec{rec-msg}) messages is the
dominant communication mechanism, followed by communication with tools
(\spec{snd-do},\spec{snd-eval}).  It may be surprising that parallel
composition (\spec{||}) is used so infrequently. However, one used be
aware that at the top level all process run concurrently and that
\spec{||} is only used for explicit concurrency inside a process. The
level of concurrence is therefore circa 100.

\section{Issues in a Next-Generation \TB}

The \TB\ has been used in various applications of which the
Meta-Environment is by far the largests. Some of the questions
posed by our users and ourselves are:

\begin{itemize}

\item I find it difficult to see which messages are requests and
  which are replies; can you provide support this?
  See \S\ref{Sec:message-patterns}.

\item If a tool crashes, what is the best way to describe the recovery
  in the Tscript?
  See \S\ref{Sec:exceptions}.

\item I have huge data values that are exchanged between tools and the
  \TB becomes a data bottleneck; can you improve this?
  See \S\ref{Sec:value-ref}.

\item The \TB and tools are running as separate tasks of the operating
  systems. Would it not be more efficient to run \TB\ and tools in
  single task? See \S\ref{Sec-status}.

\end{itemize}


\subsection{Undisciplined Message Patterns}
  \label{Sec:message-patterns}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/rpc.eps,height=12cm}
\end{center}
\vspace*{-7cm}
\caption{\label{Fig:rpc}Communication pattern for remote procedure call}
\end{figure}

\begin{figure}[tb]
\begin{center}
\epsfig{figure=figs/msg.eps,height=12cm}
\end{center}
\vspace*{-7cm}
\caption{\label{Fig:message}Communication pattern for general messages}
\end{figure}

The classical pattern of a remote procedure call is shown in
Figure~\ref{Fig:rpc}: a caller performs a call to a callee. During the
call the caller suspends execution and the callee executes until he
has computed a reply. At that point in time, the caller continues its
execution.

Compare this simple situation with general message communication as
shown in Figure~\ref{Fig:message}: the caller continues execution
after sending a message msg1 to Callee1 and may even send a message
msg2 to Callee2.  At a certain point in time Callee2 may send message
msg3 back to Caller. In this case, the three parties involved
continue their execution while messages are being exchanged and
there is no obvious pairing of calls and replies.



\begin{verbatim}
call/reply regime has to be encoded in messages
typically a message identifier
error handling is hard
which reply did not come?
Script harder to understand
unstructured combination of
send/receive
Operators . + * ||
\end{verbatim}

\begin{verbatim}
Send and receive occur in pairs
Inbetween arbitrary operations allowed
In fact, a matching send/receive may be an arbitrary expression
provided all alternatives begin with a matching send/receive
\end{verbatim}

\begin{verbatim}
snd-msg(eval(E)) . rec-msg(A?)

snd-msg(eval(E)) { } rec-msg(A?)

snd-msg(eval(E)){
   arbitrary process expression 
    }  rec-msg(A?)

snd-msg (eval(E)) 
{arbitrary process expression 
    } ( rec-msg(A?) 
     + rec-msg(error(M?)
     )

\end{verbatim}


\subsection{Exception Handling} \label{Sec:exceptions}

\begin{verbatim}
Java-style execption handling does not work
always associated with one specific call
We use a LOTOS-style disrupt operator
P >> E
Adds the exception E as alternative to each atom in the process expression P
Solves local error handling
Error propagation: open issue
\end{verbatim}


\subsection{Call-by-value versus Call-by-reference} \label{Sec:value-ref}

\begin{figure}
\epsfig{figure=figs/refs.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\begin{figure}
\epsfig{figure=figs/values.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\begin{verbatim}
Call by ref:
Efficient for infrequent access/update
 Uncontrolled modifications
 New versions of CORBA have call-by-value

Call by value:
Inefficient
 Sharing between calls is lost (recall big parse trees)
 Only works between Java components
 Via IIOP connection with non-Java components
\end{verbatim}

\begin{verbatim}
ToolBus now:
Transparent model
 Shared access can be           expressed in the script
 No distributed garbage        collection
 ToolBus is bottleneck for     large values

ToolBus NG:
Ad hoc data channel
 Transparent model
 Garbage collection of                   channels
 No central bottleneck
\end{verbatim}


\begin{figure}
\epsfig{figure=figs/toolbus-values.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}


\begin{figure}
\epsfig{figure=figs/toolbus-refs.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\section{Current Status} \label{Sec-status}

\begin{verbatim}
Current ToolBus
implemented in C
target: ASF+SDF Meta-Environment
Next generation ToolBus
implemented in Java
Tools on same machine run in a separate thread
Easy connection with RMI/CORBA, database access, ...
target: gamesquare.nl
multi-user game site, thousands of users.
\end{verbatim}

\section{Case study: ToolBus and Java RMI}
\verbatiminput{address-book.tb}
\verbatiminput{AddressBookService.java}

\section{Concluding Remarks}

\section*{Acknowledgements}

Pieter (misschien co-auteur?)


\bibliographystyle{plain} 
\bibliography{fmco02} 
\end{document}
