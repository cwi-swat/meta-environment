
\section{\label{arm-adapter}The arm-adapter}

The arm-adapter is nothing more but a \TB -aware Arm interpreter.
Section \ref{build-arm} describes how to build a \TB -aware Arm interpreter,
Section \ref{using-arm} describes how to use such an interpreter.

\subsection{\label{build-arm}Building a \TB -aware arm interpreter}

First you must locate or install the epic distribution on which you
want to base your arm-adapter. Now set the location of this distribution
when you configure the \TB\ by adding the epic configuration option:
\begin{verbatim}
./configure --with-epic=/usr/local/EP
\end{verbatim}

Now build and install the \TB:
\begin{verbatim}
make
make install
\end{verbatim}
If the epic distribution was installed correctly, your arm-adapter is
now installed correctly in the \TB\ bin directory.

\subsection{\label{using-arm}Using the arm-adapter}

\paragraph{Synopsis.} Start the arm-adapter as a tool.

\paragraph{Example.} {\tt arm-adapter}

\paragraph{Basic communication.} 
\hspace{-0.3cm}\footnote{Communication is described
from the point of view of the \TB, i.e., {\tt snd-} and {\tt rec-}
mean, respectively, send by \TB\ and receive by \TB.}

\begin{itemize}
\item {\tt snd-do($Tid$, clear-arm)}: Remove all loaded arm code.
\item {\tt snd-eval($Tid$, load-arm($Files$, $Paths$))}: Try to load a list
      of arm files, search in the directories in the list $Paths$.
      The result of this evaluation request is received as follows:
      {\tt rec-value($Tid$, $Success?$)}. Success is either {\tt ok} if
      everything went fine, or {\tt error($Msg$)} when something went wrong,
      for instance when an arm file could not be found.
\item {\tt snd-do($Tid$, link-arm)}: Link the arm code after all arm files
      have been loaded.
\item {\tt snd-eval($Tid$, reduce($T$))}: Reduce a term. The result
      of the reduction is received by the \TB\ as follows:
      {\tt rec-value($Tid$, reduct($T$))}.
\end{itemize}

This functionality is enough if you just want to reduce terms.
But we often encounter the situation where we want to store very
large terms in the arm-adapter, and only send operations on them
to the arm-adapter. The result of such operations need to be
split and only subterms need to be transmitted back to the \TB.

In order to implement this functionality, we introduce \emph{interface
variables} in the arm-adapter. A value can be assigned to a interface
variable using \emph{matching}. For example, the following
\TB\ fragment assigns the term {\tt aap(1,2,3)} to the interface variable
named {\tt x}. {\tt A} is the tool identifier of the arm-adapter.
\begin{verbatim}
  snd-eval(A, match(<x>, term(aap(1,2,3)))) .
  rec-value(A, match(ok))
\end{verbatim}

{\tt match} has two arguments, $T_1$ and $T_2$. 
$T_1$ is a template term,
any placeholder occurences (like {\tt <x>} above), result in
an assigment during matching.
$T_2$ has two alternative forms. In both cases, any
plaheholder occurences in $T_2$ are replaced with the value
of the corresponding interface variables.
The two alternatives are:
\begin{itemize}
\item $T_2 =$ {\tt term($T$)}: In this case, $T$ is matched against
      $T_1$, and any placeholder occurences in $T_1$ that match with
      a subterm of $T_2$ result in an assignment of the subterm of $T_2$
      to the corresponding logical variable. 
      In our example above, this means that because {\tt <x>} matched 
      with {\tt aap(1,2,3)}, the value {\tt aap(1,2,3)} was assigned to 
      the interface variable {\tt x}.
\item $T_2 =$ {\tt reduce($T$)}: After replacing all placeholder occurences
      in {\tt $T$}, the resulting term is reduced. The reduction result is
      then used to match against $T_1$, and assignments to interface variables
      occur as described above.
\end{itemize}

A \TB\ process can also retrieve the current value of an interface variable:

\begin{verbatim}
  snd-eval(A, get-value(T)) .
  rec-value(A, value(R?))
\end{verbatim}

All placeholder occurences in {\tt T} are replaced by the value
of the corresponding interface variables. The result is stored in {\tt R}.

Note that replacement of placeholder occurences by the value of the
corresponding interface variable also happens before reducing terms
using {\tt snd-eval(A, reduce(T))}!

\subsection{Commandline interface}

A useful application of the arm-adapter is also included in this
distribution. The \TB\ script {\tt arm.tb} and the program {\tt armcmd}
together form a commandline interface to the arm-adapter, enabling
the user to load arm files and reduce terms from the commandline
or from Makefiles. This setup offers a significant advantage over using
the plain arm interpreter which could also be used to accomplish this.
Using the arm-adapter tools, the arm interpreter can stay resident as
a \TB\ application, so the user only has to load in the arm files once
and then reduce a number of terms \emph{without reloading the arm files!}.
This can result in an enormous performance gain, because loading arm files
can be very time consuming.

\paragraph{starting the resident part} This can be
accomplished by issuing the command:
\begin{verbatim}
arm-resident
\end{verbatim}
This will start the \TB\ in the background, using the \TB\ script arm.tb.

\paragraph{arm interpreter commands}
The command {\tt armcmd} can be used to issue commands to resident
arm interpreters. The arguments of {\tt armcmd} are interpreted
as special arm interpreter commands. {\tt armcmd} first connects to
the resident part of the system, and then let this resident part
execute the commands one by one. After all answers have been received,
{\tt arm-cmd} disconnects from the resident part and exits.
\begin{verbatim}
usage: armcmd <toolbus-options> [<task>|<interpreter>]*
  <interpreter>               - switch uarm-interpreter to use
tasks:
  -create <uarm-id>[:machine] - create new uarm-interpreter
  -load-arm <arm-files>       - load a set of arm files
  -link-arm                   - link loaded arm code (required before reduce)
  -get-var <var-name>         - retrieve the value of a variable
  -set-var <var-name> <term>  - set the value of a variable
  -reduce <term>              - reduce a term
  -apply-reduce <func> <term> - apply func and reduce term
  -path <path>                - add a search path for arm files.
  -clear-paths                - clear all arm search paths
  -query                      - print all the interpreters
  -shutdown                   - kill the resident toolbus
uarm-id    = identifies the uarm-interpreter instance to use
machine    = the machine on which to execute the arm interpreter
arm-files  = a list of arm files (filename may not start with -)
             if one of the entries starts with a @, arm filenames
             are read from file.
var-name   = a variable name
term       = a term, if it starts with a @, it is read from file.
func       = a function symbol (arity=1)
path       = a directory path
in         = input file name
out        = output file name
or: armcmd -help
\end{verbatim}
The script {\tt arm-cmd} is a wrapper around {\tt armcmd} that adds
the \TB\ option {\tt -TB\_TOOL\_NAME armcmd}.




