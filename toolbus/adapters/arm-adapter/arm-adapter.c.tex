
%{{{ arm-adapter

%{{{ proze

The {\tt arm-adapter} interfaces the arm interpreter with the
ToolBus. This adapter performs the following tasks:

\begin{itemize}
\item Load ARM files ({\tt snd-eval(A,load-arm(Files,Dirs))}).
\item Signal succes/failure of this loading process\newline
 ({\tt rec-value(A,loading(Files,Dirs,succes))} or\newline
 ({\tt rec-value(A,loading(Files,Dirs,error(E?)))}).
\item Link all loaded ARM code ({\tt snd-do(A,link-arm)}).
\item Clear all previously loaded ARM code ({\tt snd-do(A,clear-arm)}).
\item Reduce a term ({\tt snd-eval(reduce(T))}).
\item Retrieve the result of a reduction ({\tt rec-value(reduction(T?))}).
\end{itemize}

In addition to these basic tasks, this adapter introduces a
variable system. In this system, placeholders in input terms
are replaced by the value of the internal variable they represent.
To assign values to variables, we use the {\tt match} command.
{\tt match} takes two arguments, the first of which (T) is template
term containing placeholders. The second argument (T') is
matched against this template, and any subterm of T' that matches with
a placeholder is assigned to an internal variable. The name of this
internal variable is taken to be the placeholder.
\newline
Example:
\begin{verbatim}
  ...
  snd-eval(A,match(<abc>,hello(world))) .
  rec-value(A, ok)
  ...
  snd-eval(A,reduce(print(<abc>))) .
  rec-value(A, reduction(T?))
  ...
\end{verbatim}
After this, {\tt T} will contain the result of reducing
{\tt print(hello(world))}.

Note that that placeholders are not interpreted as types in this
situation (in contrast with for example {\tt subscribe(f(<str>))}).
Note also that complex assigments can be modeled in one match instruction,
because {\tt T'} can also contain placeholders, wich are replaced with
the value of their respective variables before matching commences.

If the outer function symbol of {\tt T'} is {\tt reduce}, all of its
arguments are first reduced after substitution of placeholders.
After this reduction, the function symbol {\tt reduction} is put around
the resulting normal forms.

This variable system consists of the following interface:
\begin{itemize}
\item Substitute placeholder values in a term ({\tt snd-eval(A,get-value(T))}).
\item Retrieve resulting term ({\tt rec-value(A, value(T?))}).
\item Match a term against a term containing placeholders, 
      and assign subterms that match with a placeholder
      to the variables corresponding to these placholders
      ({\tt snd-do(A,match(T,T'))}).
\end{itemize}

%}}}

\nwfilename{arm-adapter.c.nw}\nwbegincode{1}\sublabel{NWarmG-armE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-armE-1}}}\moddef{arm-adapter.c*~{\nwtagstyle{}\subpageref{NWarmG-armE-1}}}\endmoddef\let\nwnotused=\nwoutput{}
/*#include <arm.h>*/
#include <codemem.h>
#include <TB.h>
#include "arm.tif.c"

#define MAX_SYMBOL_SIZE 4096
static char buf[MAX_SYMBOL_SIZE];

int TBcid;
unsigned long MAXSIZE = 20*1024*1024;
static fun v_pair;

typedef struct variable
\{
  struct variable *next;
  term *var;
  term *val;
\} variable;

variable *vars = NULL;

\LA{}char_table~{\nwtagstyle{}\subpageref{NWarmG-chaA-1}}\RA{}
\LA{}mappings~{\nwtagstyle{}\subpageref{NWarmG-map8-1}}\RA{}

\LA{}assign~{\nwtagstyle{}\subpageref{NWarmG-ass6-1}}\RA{}
\LA{}value~{\nwtagstyle{}\subpageref{NWarmG-val5-1}}\RA{}
\LA{}substitute~{\nwtagstyle{}\subpageref{NWarmG-subA-1}}\RA{}
\LA{}substitute_list~{\nwtagstyle{}\subpageref{NWarmG-subF-1}}\RA{}
\LA{}del_var~{\nwtagstyle{}\subpageref{NWarmG-del7-1}}\RA{}
\LA{}apply_mappings~{\nwtagstyle{}\subpageref{NWarmG-appE-1}}\RA{}

\LA{}clear_arm~{\nwtagstyle{}\subpageref{NWarmG-cle9-1}}\RA{}
\LA{}load_mappings~{\nwtagstyle{}\subpageref{NWarmG-loaD-1}}\RA{}
\LA{}load_arm~{\nwtagstyle{}\subpageref{NWarmG-loa8-1}}\RA{}
\LA{}link_arm~{\nwtagstyle{}\subpageref{NWarmG-lin8-1}}\RA{}
\LA{}reduce~{\nwtagstyle{}\subpageref{NWarmG-red6-1}}\RA{}

\LA{}match~{\nwtagstyle{}\subpageref{NWarmG-mat5-1}}\RA{}
\LA{}get_value~{\nwtagstyle{}\subpageref{NWarmG-get9-1}}\RA{}
\LA{}delete_value~{\nwtagstyle{}\subpageref{NWarmG-delC-1}}\RA{}

\LA{}arm_backdoor_handler~{\nwtagstyle{}\subpageref{NWarmG-armK-1}}\RA{}
\LA{}arm_backdoor_check_in_sign~{\nwtagstyle{}\subpageref{NWarmG-armQ-1}}\RA{}
\LA{}rec_terminate~{\nwtagstyle{}\subpageref{NWarmG-recD-1}}\RA{}

\LA{}main~{\nwtagstyle{}\subpageref{NWarmG-mai4-1}}\RA{}
\nwnotused{arm-adapter.c*}\nwendcode{}\nwbegindocs{2}\nwdocspar

%}}}

%{{{ char_table

\nwenddocs{}\nwbegincode{3}\sublabel{NWarmG-chaA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-chaA-1}}}\moddef{char_table~{\nwtagstyle{}\subpageref{NWarmG-chaA-1}}}\endmoddef\let\nwnotused=\nwoutput{}
char *char_table[] =
\{
  "\\\\000", "\\\\001", "\\\\002", "\\\\003", "\\\\004", "\\\\005", "\\\\006", "\\\\007",
  "\\\\008", "\\\\t",   "\\\\n",
  "\\\\011", "\\\\012", "\\\\r", "\\\\014", "\\\\015", "\\\\016", "\\\\017", "\\\\018",
  "\\\\019", "\\\\020", "\\\\021", "\\\\022", "\\\\023", "\\\\024", "\\\\025", "\\\\026",
  "\\\\027",
  "\\\\028", "\\\\029", "\\\\030", "\\\\031",
  "' ", "'!", "'\\"", "'#", "'$", "'%", "'&", "''", "'(", "')", "'*", "'+",
  "',", "'-", "'.", "'/",
  "'0", "'1", "'2", "'3",  "'4", "'5", "'6", "'7", "'8", "'9",
  "':", "';", "'<", "'=",  "'>", "'?", "'@",
  "'A", "'B", "'C", "'D",  "'E", "'F", "'G", "'H", "'I", "'J",
  "'K", "'L", "'M", "'N", "'O", "'P",
  "'Q", "'R", "'S", "'T",  "'U", "'V", "'W", "'X", "'Y", "'Z",
  "'[", "\\\\\\\\", "']", "'^", "'_",  "'`",
  "'a", "'b", "'c", "'d",  "'e", "'f", "'g", "'h", "'i", "'j",
  "'k", "'l", "'m", "'n", "'o", "'p",
  "'q", "'r", "'s", "'t",  "'u", "'v", "'w", "'x", "'y", "'z",
  "'\{", "'|", "'\}", "'~", "-"
\};
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

%}}}
%{{{ mappings

\nwenddocs{}\nwbegincode{5}\sublabel{NWarmG-map8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-map8-1}}}\moddef{mappings~{\nwtagstyle{}\subpageref{NWarmG-map8-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term_list *mappings = NULL;
term_list *reverse_mappings = NULL;
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

%}}}

%{{{ int main(int argc, char *argv[])

The {\tt main} function ininializes the ARM interpreter, and
establishes a ToolBus connection.

\nwenddocs{}\nwbegincode{7}\sublabel{NWarmG-mai4-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-mai4-1}}}\moddef{main~{\nwtagstyle{}\subpageref{NWarmG-mai4-1}}}\endmoddef\let\nwnotused=\nwoutput{}
int main(int argc, char *argv[])
\{
  extern int ARM_DBGMSK;

  /*ARM_DBGMSK = 16;  Tracing on */
  TB_init();
  TBprotect(&mappings);
  TBprotect(&reverse_mappings);

  ARM_set_up();

  xfunuse("pair",v_pair);

  TBcid = TB_parseArgs(argc, argv, arm_handler, arm_check_in_sign);
  TB_connect(TBcid);
  TB_eventloop();
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

%}}}

%{{{ void clear_arm(int cid)

\nwenddocs{}\nwbegincode{9}\sublabel{NWarmG-cle9-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-cle9-1}}}\moddef{clear_arm~{\nwtagstyle{}\subpageref{NWarmG-cle9-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void clear_arm(int cid)
\{
  ARM_clear();
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar

%}}}
%{{{ void load_mappings(int cid, term_list *mappings)

\nwenddocs{}\nwbegincode{11}\sublabel{NWarmG-loaD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-loaD-1}}}\moddef{load_mappings~{\nwtagstyle{}\subpageref{NWarmG-loaD-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void load_mappings(int cid, term_list *maps)
\{
  term *map;

  mappings = maps;
  reverse_mappings = NULL;

  while(maps) \{
    map = list_first(maps);
    maps = list_next(maps);
    reverse_mappings = list_concat_term(reverse_mappings, 
                                        list_reverse(list_copy(map)));
  \}

  TBprintf(stderr, "mappings = %t, reverse = %t\\n", mappings, reverse_mappings);
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar

%}}}
%{{{ term *load_arm(int cid, term_list *files, term_list *dirs)

Load a set of arm files. {\tt dirs} gives a list of directories
in which to search.

\nwenddocs{}\nwbegincode{13}\sublabel{NWarmG-loa8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-loa8-1}}}\moddef{load_arm~{\nwtagstyle{}\subpageref{NWarmG-loa8-1}}}\endmoddef\let\nwnotused=\nwoutput{}
\LA{}try_load_arm~{\nwtagstyle{}\subpageref{NWarmG-tryC-1}}\RA{}

term *load_arm(int cid, term_list *files, term_list *dirs)
\{
  term *file, *dir;
  term_list *filelist, *dirlist;
  char *filename, *dirname;
  TBbool loaded;

  filelist = files;
  while(filelist) \{
    file = list_first(filelist);
    filelist = list_next(filelist);
    if(!TB_match(file, "<str>", &filename))
      return TB_make("snd-value(load-arm(<list>,<list>,failure(<str>)))",
                files, dirs, "list of filenames expected");
    if(filename[0] == '/') \{
      if(try_load_arm(filename) < 0)
        return TB_make("snd-value(load-arm(<list>,<list>,failure(<str>)))",
                files, dirs, TBsprintf("couldn't load file: %s", filename));
    \} else \{
      dirlist = dirs;
      loaded = TBfalse;
      while(dirlist && !loaded) \{
        dir = list_first(dirlist);
        dirlist = list_next(dirlist);
        if(!TB_match(dir, "<str>", &dirname))
          return TB_make("snd-value(load-arm(<list>,<list>,failure(<str>)))",
                        files, dirs, "list of directories expected");
        if(try_load_arm(TBsprintf("%s/%s", dirname, filename)) > 0)
          loaded = TBtrue;
      \}
      if(!loaded) \{
        static char error[256];
        sprintf(error, "couldn't load file: %s\\n", filename);
        return TB_make("snd-value(load-arm(<list>,<list>,failure(<str>)))",
                                                        files, dirs, error);
      \}
    \}
  \}
  return TB_make("snd-value(load-arm(<list>,<list>,ok))", files, dirs);
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar

\nwenddocs{}\nwbegincode{15}\sublabel{NWarmG-tryC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-tryC-1}}}\moddef{try_load_arm~{\nwtagstyle{}\subpageref{NWarmG-tryC-1}}}\endmoddef\let\nwnotused=\nwoutput{}
int try_load_arm(char *path)
\{
  FILE *f;

  f = fopen(path, "r");
  fclose(f);
  if(f) \{
    ARM_load_arm_file(path);
    /*fprintf(stderr, "ARM file %s loaded\\n", path);*/
    return 1;
  \}
  return 0;
\}
\nwused{\\{NWarmG-loa8-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

%}}}
%{{{ void link_arm(int cid)

Link all loaded arm code.

\nwenddocs{}\nwbegincode{17}\sublabel{NWarmG-lin8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-lin8-1}}}\moddef{link_arm~{\nwtagstyle{}\subpageref{NWarmG-lin8-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void link_arm(int cid)
\{
  ARM_link();
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

%}}}
%{{{ term *reduce(int cid, term *t)

Load and reduce a term.

\nwenddocs{}\nwbegincode{19}\sublabel{NWarmG-red6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-red6-1}}}\moddef{reduce~{\nwtagstyle{}\subpageref{NWarmG-red6-1}}}\endmoddef\let\nwnotused=\nwoutput{}
\LA{}push_symbol~{\nwtagstyle{}\subpageref{NWarmG-pusB-1}}\RA{}
\LA{}tb_term~{\nwtagstyle{}\subpageref{NWarmG-tb*7-1}}\RA{}
\LA{}push_term~{\nwtagstyle{}\subpageref{NWarmG-pus9-1}}\RA{}
\LA{}ref_to_term~{\nwtagstyle{}\subpageref{NWarmG-refB-1}}\RA{}
\LA{}reftag_to_term~{\nwtagstyle{}\subpageref{NWarmG-refE-1}}\RA{}
\nwalsodefined{\\{NWarmG-red6-2}}\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{20}\nwdocspar

%{{{ term *reduce(int cid, term *t)

\nwenddocs{}\nwbegincode{21}\sublabel{NWarmG-red6-2}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-red6-2}}}\moddef{reduce~{\nwtagstyle{}\subpageref{NWarmG-red6-1}}}\plusendmoddef\let\nwnotused=\nwoutput{}
term *reduce(int cid, term *trm)
\{
  ARM_ref r;
  term *t;

  if(!TB_match(trm, "term(<term>)", &t)) \{
    TBprintf(stderr, "malformed term in reduce: %t\\n", t);
    exit(1);
  \}
  t = apply_mappings(substitute(t), mappings);

  TBprintf(stderr, "reducing term: %t, after subst and maps: %t\\n", trm, t);

  ARM_ready();
  push_term(t);
  r = ARM_reduce();
  /*ARM_display(0,r,0);*/
  t = apply_mappings(ref_to_term(r), reverse_mappings);
  return TB_make("snd-value(reduct(<term>))", t);
\}
\nwendcode{}\nwbegindocs{22}\nwdocspar

%}}}
%{{{ void push_term(term *t)

\nwenddocs{}\nwbegincode{23}\sublabel{NWarmG-pus9-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-pus9-1}}}\moddef{push_term~{\nwtagstyle{}\subpageref{NWarmG-pus9-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void push_term(term *t)
\{
  char *fun;
  term_list *args = NULL;
  int c;

  if(TB_match(t, "<str>", &fun)) \{
    push_symbol(fun);
  \} else
  if(TB_match(t, "<appl>", &fun, &args)) \{
       if(fun_str_sym(t))
         push_symbol(fun);
       else
         ARM_push(fun);
       /*args = list_reverse(args);*/
       while(args) \{
         push_term(list_first(args));
         args = list_next(args);
       \}
  \} else \{
    if(TB_match(t, "<int>", &c)) \{
      assert(c >= 0 && c < 128);
      ARM_push(char_table[c]);
    \} else
      TBmsg("not an application or char (int): %t\\n", t);
  \}
\}
\nwused{\\{NWarmG-red6-1}}\nwendcode{}\nwbegindocs{24}\nwdocspar

%}}}
%{{{ void push_symbol(char *fun)

\nwenddocs{}\nwbegincode{25}\sublabel{NWarmG-pusB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-pusB-1}}}\moddef{push_symbol~{\nwtagstyle{}\subpageref{NWarmG-pusB-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void push_symbol(char *fun)
\{
  int i = 1;

  buf[0] = '"';
  while(*fun) \{
    switch(*fun) \{
      case '"':
      case '\\\\':
                buf[i++] = '\\\\';
    \}
    buf[i++] = *fun++;
  \}
  buf[i++] = '"';
  buf[i++] = '\\0';
  ARM_push(buf);
\}
\nwused{\\{NWarmG-red6-1}}\nwendcode{}\nwbegindocs{26}\nwdocspar

%}}}

%{{{ term *ref_to_term(ARM_ref r)

\nwenddocs{}\nwbegincode{27}\sublabel{NWarmG-refB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-refB-1}}}\moddef{ref_to_term~{\nwtagstyle{}\subpageref{NWarmG-refB-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term_list *reftag_to_term(ARM_ref r);

term *ref_to_term(ARM_ref r)
\{
  term *t;

  switch(tag(r)) \{
    case reftag: t = list_first(reftag_to_term(r));
      break;
    case tkntag: t = tb_term(fun2hdr(tkn2fun((fun)r))->name, NULL);
      break;
    case funtag: t = tb_term(fun2hdr((fun)r)->name, NULL);
      break;
    case numtag: t = TB_make("<int>", detag(r));
      break;
    case opqtag: t = TB_make("opaque(<int>)", r);
      break;
    case nultag: t = TB_make("nul");
      break;
  \}
  return t;
\}
\nwused{\\{NWarmG-red6-1}}\nwendcode{}\nwbegindocs{28}\nwdocspar


Make a ToolBus term out of a reference tag.

\nwenddocs{}\nwbegincode{29}\sublabel{NWarmG-refE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-refE-1}}}\moddef{reftag_to_term~{\nwtagstyle{}\subpageref{NWarmG-refE-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term_list *reftag_to_term(ARM_ref r)
\{
  char *ptr;
  term_list *args = NULL;
  int len;

  /* Descent the lhs */
  if(r->car != NUL)
    args = list_concat_term(args, ref_to_term(r->car));

  /* Descent the rhs */
  if(r->cdr != NUL) \{
    if(tag(r->cdr) == reftag && r->cdr->fsym == v_pair)
      args = list_concat(args, reftag_to_term(r->cdr));
    else
      list_concat_term(args, ref_to_term(r->cdr));
    if(r->fsym == v_pair)
      return args;
  \}

  /* Build an application */
  return TB_make("[<term>]", tb_term(fun2hdr(r->fsym)->name, args));
\}
\nwused{\\{NWarmG-red6-1}}\nwendcode{}\nwbegindocs{30}\nwdocspar

%{{{ descent lhs

\nwenddocs{}\nwbegincode{31}\sublabel{NWarmG-desB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-desB-1}}}\moddef{descent lhs~{\nwtagstyle{}\subpageref{NWarmG-desB-1}}}\endmoddef
\nwnotused{descent\ lhs}\nwendcode{}\nwbegindocs{32}\nwdocspar

%}}}
%{{{ descent rhs

\nwenddocs{}\nwbegincode{33}\sublabel{NWarmG-desB.2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-desB.2-1}}}\moddef{descent rhs~{\nwtagstyle{}\subpageref{NWarmG-desB.2-1}}}\endmoddef
\nwnotused{descent\ rhs}\nwendcode{}\nwbegindocs{34}\nwdocspar

%}}}

%}}}
%{{{ term tb_term(char *id, term_list *args)

\nwenddocs{}\nwbegincode{35}\sublabel{NWarmG-tb*7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-tb*7-1}}}\moddef{tb_term~{\nwtagstyle{}\subpageref{NWarmG-tb*7-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term *tb_term(char *id, term_list *args)
\{
  int i;

/*  TBprintf(stderr, "tb_term: %s\\n", id);*/
  if(!args) \{
    if(id[2] == '\\0' && id[0] == '\\'' || id[0] == '\\\\')
      return TB_make("<int>", id[1]);
    if(id[0] == '\\\\' && strlen(id) == 4)
      return TB_make("<int>", atoi(&id[1]));
  \}
  if(id[0] != '"')
    return TB_make("<appl>", id, args);
  id++;
  for(i=0; *id != '"'; i++, id++) \{
    if(*id == '\\\\')
      id++;
    buf[i] = *id;
  \}
  buf[i] = '\\0';
/*  TBprintf(stderr, "result: %s\\n", buf);*/
  return TB_make("<appl>", buf, args);
\}
\nwused{\\{NWarmG-red6-1}}\nwendcode{}\nwbegindocs{36}\nwdocspar

%}}}

%}}}

%{{{ term *match(int cid, term *m, term *t)

\nwenddocs{}\nwbegincode{37}\sublabel{NWarmG-mat5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-mat5-1}}}\moddef{match~{\nwtagstyle{}\subpageref{NWarmG-mat5-1}}}\endmoddef\let\nwnotused=\nwoutput{}
\LA{}check_match_term~{\nwtagstyle{}\subpageref{NWarmG-cheG-1}}\RA{}
\LA{}check_match_list~{\nwtagstyle{}\subpageref{NWarmG-cheG.2-1}}\RA{}
\LA{}do_match_term~{\nwtagstyle{}\subpageref{NWarmG-do*D-1}}\RA{}
\LA{}do_match_list~{\nwtagstyle{}\subpageref{NWarmG-do*D.2-1}}\RA{}
\nwalsodefined{\\{NWarmG-mat5-2}}\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{38}\nwdocspar

%{{{ match

\nwenddocs{}\nwbegincode{39}\sublabel{NWarmG-mat5-2}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-mat5-2}}}\moddef{match~{\nwtagstyle{}\subpageref{NWarmG-mat5-1}}}\plusendmoddef\let\nwnotused=\nwoutput{}
term *match(int cid, term *m, term *t)
\{
  term *t2;

  t = substitute(t);

  if(TB_match(t, "reduce(<term>)", &t2)) \{
    ARM_ref r;

    ARM_ready();
    push_term(t2);
    r = ARM_reduce();
    t = ref_to_term(r);
  \} else if(!TB_match(t, "term(<term>)", &t)) \{
    TBprintf(stderr, "malformed term in match: %t\\n", t);
  \}

  if(!TB_match(m, "term(<term>)", &m)) \{
    TBprintf(stderr, "malformed match term: %t\\n", m);
  \}

  if(check_match_term(m, t)) \{
    do_match_term(m, t);
    return TB_make("snd-value(match(ok))");
  \} else \{
    return TB_make("snd-value(match(failure))");
  \} 
\}
\nwendcode{}\nwbegindocs{40}\nwdocspar

%}}}

%{{{ TBbool check_match_term(term *m, term *t)

\nwenddocs{}\nwbegincode{41}\sublabel{NWarmG-cheG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-cheG-1}}}\moddef{check_match_term~{\nwtagstyle{}\subpageref{NWarmG-cheG-1}}}\endmoddef\let\nwnotused=\nwoutput{}
TBbool check_match_list(term_list *m, term_list *l);

TBbool check_match_term(term *m, term *t)
\{
  if(tkind(m) == t_placeholder) \{
    return TBtrue;
  \}

  if(tkind(m) != tkind(t)) \{
    return TBfalse;
  \}

  if(m==t)
    return TBtrue;

  switch(tkind(m)) \{
    case t_bool:        return (bool_val(m) == bool_val(t));
    case t_int:         return (int_val(m) == int_val(t));
    case t_real:        return (real_val(m) == real_val(t));
    case t_str:         return streq(str_val(m), str_val(t));
    case t_bstr:        return bstr_len(m) == bstr_len(t) && 
                          memcmp(bstr_val(m), bstr_val(t), bstr_len(m)) == 0;
    case t_var:         return (var_sym(m) == var_sym(t) &&
                                var_formal(m) == var_formal(t) &&
                                var_result(m) == var_result(t) &&
                                check_match_term(var_type(m), var_type(t)));
    case t_appl:        if(fun_sym(m) != fun_sym(t))
                          return TBfalse;
                        return check_match_list(fun_args(m), fun_args(t));
    case t_anno:        return check_match_term(anno_term(m), anno_term(t))&&
                          check_match_term(anno_val(m), anno_val(t));
    case t_list:        return check_match_list(m, t);

    default:            TBmsg("term type not supported: %t\\n", m);
                        return TBfalse;
  \}
\}
\nwused{\\{NWarmG-mat5-1}}\nwendcode{}\nwbegindocs{42}\nwdocspar

%}}}
%{{{ TBbool check_match_list(term_list *m, term_list *l)

Check if two lists match. The list {\tt m} may contain placeholders.

\nwenddocs{}\nwbegincode{43}\sublabel{NWarmG-cheG.2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-cheG.2-1}}}\moddef{check_match_list~{\nwtagstyle{}\subpageref{NWarmG-cheG.2-1}}}\endmoddef\let\nwnotused=\nwoutput{}
TBbool check_match_list(term_list *m, term_list *l)
\{
  if(m == l)
    return TBtrue;
  if(m == NULL || l == NULL)
    return TBfalse;

  return check_match_term(list_first(m), list_first(l)) &&
         check_match_list(list_next(m), list_next(l));
\}
\nwused{\\{NWarmG-mat5-1}}\nwendcode{}\nwbegindocs{44}\nwdocspar

%}}}
%{{{ void do_match_term(term *m, term *t)

\nwenddocs{}\nwbegincode{45}\sublabel{NWarmG-do*D-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-do*D-1}}}\moddef{do_match_term~{\nwtagstyle{}\subpageref{NWarmG-do*D-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void do_match_list(term_list *m, term_list *l);

void do_match_term(term *m, term *t)
\{
  if(tkind(m) == t_placeholder) \{
    assign(m, t);
    return;
  \}

  assert(tkind(m) == tkind(t));

  switch(tkind(m)) \{
    case t_bool:
    case t_int:
    case t_real:
    case t_str:
    case t_bstr:        break;

    case t_var:         do_match_term(var_type(m), var_type(t));
                        break;
    case t_appl:        do_match_list(fun_args(m), fun_args(t));
                        break;
    case t_anno:        do_match_term(anno_term(m), anno_term(t));
                        do_match_term(anno_val(m), anno_val(t));
                        break;
    case t_list:        do_match_list(m, t);
                        break;

    default:            TBmsg("term type not supported: %t\\n", m);
                        break;
  \}
\}
\nwused{\\{NWarmG-mat5-1}}\nwendcode{}\nwbegindocs{46}\nwdocspar

%}}}
%{{{ void do_match_list(term_list *m, term_list *l)

Match two lists, and perform assignments in the process.

\nwenddocs{}\nwbegincode{47}\sublabel{NWarmG-do*D.2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-do*D.2-1}}}\moddef{do_match_list~{\nwtagstyle{}\subpageref{NWarmG-do*D.2-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void do_match_list(term_list *m, term_list *l)
\{
  if(m == NULL || l == NULL) \{
    assert(m==NULL && l==NULL);
    return;
  \}

  do_match_term(list_first(m), list_first(l));
  do_match_list(list_next(m), list_next(l));
\}
\nwused{\\{NWarmG-mat5-1}}\nwendcode{}\nwbegindocs{48}\nwdocspar

%}}}

%}}}
%{{{ term *get_value(int cid, term *t)

Perform substitutions on a term, and return the result.

\nwenddocs{}\nwbegincode{49}\sublabel{NWarmG-get9-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-get9-1}}}\moddef{get_value~{\nwtagstyle{}\subpageref{NWarmG-get9-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term *get_value(int cid, term *t)
\{
  int result;
  term *trm;

  assert(TB_match(t, "term(<term>)", &trm));
  return TB_make("snd-value(value(<term>))", substitute(t));
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{50}\nwdocspar

%}}}

%{{{ void delete_value(int cid, term *v);

\nwenddocs{}\nwbegincode{51}\sublabel{NWarmG-delC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-delC-1}}}\moddef{delete_value~{\nwtagstyle{}\subpageref{NWarmG-delC-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void delete_value(int cid, term *v)
\{
  del_var(v);
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{52}\nwdocspar

%}}}

%{{{ term *arm_backdoor_handler(int cid, term *t)

Handle ToolBus calls that are not handled by the generated
function {\tt arm\_handler}.

\nwenddocs{}\nwbegincode{53}\sublabel{NWarmG-armK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-armK-1}}}\moddef{arm_backdoor_handler~{\nwtagstyle{}\subpageref{NWarmG-armK-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term *arm_backdoor_handler(int cid, term *t)
\{
  term *trm;
  ARM_ref r;

  if(TB_match(t, "rec-eval(<term>)", &trm)) \{
    trm = apply_mappings(substitute(trm), mappings);

    ARM_ready();
    push_term(trm);
    r = ARM_reduce();
    trm = apply_mappings(ref_to_term(r), reverse_mappings);
    return TB_make("snd-value(<term>)", trm);
  \}
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{54}\nwdocspar

%}}}
%{{{ term *arm_backdoor_check_in_sign(int cid, term *t)

\nwenddocs{}\nwbegincode{55}\sublabel{NWarmG-armQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-armQ-1}}}\moddef{arm_backdoor_check_in_sign~{\nwtagstyle{}\subpageref{NWarmG-armQ-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term *arm_backdoor_check_in_sign(int cid, term *t)
\{
  return NULL;
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{56}\nwdocspar

%}}}

%{{{ void rec_terminate(int cid, term *arg)

Quit the arm interpreter.

\nwenddocs{}\nwbegincode{57}\sublabel{NWarmG-recD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-recD-1}}}\moddef{rec_terminate~{\nwtagstyle{}\subpageref{NWarmG-recD-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void rec_terminate(int cid, term *arg)
\{
  exit(1);
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{58}\nwdocspar

%}}}

%{{{ void assign(term *var, term *val)

Assign a new value to a variable. Add the variable when it
is not yet present.

\nwenddocs{}\nwbegincode{59}\sublabel{NWarmG-ass6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-ass6-1}}}\moddef{assign~{\nwtagstyle{}\subpageref{NWarmG-ass6-1}}}\endmoddef\let\nwnotused=\nwoutput{}
void assign(term *var, term *val)
\{
  variable *cur = vars;

  while(cur) \{
    if(term_equal(cur->var, var)) \{
      cur->val = val;
      return;
    \}
    cur = cur->next;
  \}
  cur = malloc(sizeof(variable));
  if(!cur) \{
    fprintf(stderr, "out of memory in assign\\n");
    exit(1);
  \}
  cur->next = vars;
  vars = cur;
  cur->var = var;
  cur->val = val;
  TBprotect(&cur->var);
  TBprotect(&cur->val);
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{60}\nwdocspar

%}}}

%{{{ term *apply_mappings(term *t, term_list *mappings)

\nwenddocs{}\nwbegincode{61}\sublabel{NWarmG-appE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-appE-1}}}\moddef{apply_mappings~{\nwtagstyle{}\subpageref{NWarmG-appE-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term *apply_mappings(term *t, term_list *mappings);

\LA{}str_apply_mappings~{\nwtagstyle{}\subpageref{NWarmG-strI-1}}\RA{}
\LA{}appl_apply_mappings~{\nwtagstyle{}\subpageref{NWarmG-appJ-1}}\RA{}
\LA{}list_apply_mappings~{\nwtagstyle{}\subpageref{NWarmG-lisJ-1}}\RA{}

term *apply_mappings(term *t, term_list *mappings)
\{
  switch(tkind(t)) \{
    case t_str:         return str_apply_mappings(t, mappings);
    case t_appl:        return appl_apply_mappings(t, mappings);
    case t_list:        return list_apply_mappings(t, mappings);
    default: assert(0);
  \}
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{62}\nwdocspar

%{{{ term *str_apply_mappings(term *t, term_list *mappings)

Apply a set of mappings on a term string.

\nwenddocs{}\nwbegincode{63}\sublabel{NWarmG-strI-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-strI-1}}}\moddef{str_apply_mappings~{\nwtagstyle{}\subpageref{NWarmG-strI-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term *str_apply_mappings(term *t, term_list *mappings)
\{
  term *val;

  val = list_get(mappings, t);
  if(!val)
    return t;
  return val;
\}
\nwused{\\{NWarmG-appE-1}}\nwendcode{}\nwbegindocs{64}\nwdocspar

%}}}
%{{{ term *appl_apply_mappings(term *t, term_list *mappings)

Apply a set of mappings to an application.

\nwenddocs{}\nwbegincode{65}\sublabel{NWarmG-appJ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-appJ-1}}}\moddef{appl_apply_mappings~{\nwtagstyle{}\subpageref{NWarmG-appJ-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term *list_apply_mappings(term_list *l, term_list *mappings);
term *appl_apply_mappings(term *t, term_list *mappings)
\{
  sym_idx fun = fun_sym(t);
  term_list *args = fun_args(t);
  TBbool str_sym = fun_str_sym(t);
  term *key, *val;

  assert(tkind(t) == t_appl);

  key = mk_appl(fun, NULL);
  fun_str_sym(key) = str_sym;
  val = list_get(mappings, key);
  if(val) \{
    args = list_apply_mappings(args, mappings);
    if(tkind(val) == t_appl) \{
      t = mk_appl(fun_sym(val), args);
      fun_str_sym(t) = fun_str_sym(val);
    \} else \{
      assert(tkind(val) == t_str);
      t = TB_make("<appl>", str_val(val), args);
      fun_str_sym(t) = TBtrue;      
    \}
  \}
  return t;
\}
\nwused{\\{NWarmG-appE-1}}\nwendcode{}\nwbegindocs{66}\nwdocspar

%}}}
%{{{ term *list_apply_mappings(term_list *l, term_list *mappings)

Apply a set of mappings to a list of terms.

\nwenddocs{}\nwbegincode{67}\sublabel{NWarmG-lisJ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-lisJ-1}}}\moddef{list_apply_mappings~{\nwtagstyle{}\subpageref{NWarmG-lisJ-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term *list_apply_mappings(term_list *l, term_list *mappings)
\{
  term *el, *tail, *result;

  if(l) \{
    el = apply_mappings(list_first(l), mappings);
    tail = list_apply_mappings(list_next(l), mappings);
    if(el != list_first(l) || tail != list_next(l))
      return mk_list(el, tail);
  \}
  return l;
\}
\nwused{\\{NWarmG-appE-1}}\nwendcode{}\nwbegindocs{68}\nwdocspar

%}}}

%}}}
%{{{ term *substitute(term *t)

Construct a new term by replacing all placeholder occurences in t
with corresponding variable values.

\nwenddocs{}\nwbegincode{69}\sublabel{NWarmG-subA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-subA-1}}}\moddef{substitute~{\nwtagstyle{}\subpageref{NWarmG-subA-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term_list *substitute_list(term_list *l);

term *substitute(term *t)
\{
  term *t2;

  if(tkind(t) == t_placeholder)
    return value(t);
  
  switch(tkind(t))
  \{
    case t_bool:
    case t_int:
    case t_real:
    case t_str:
    case t_bstr:        return t;


    case t_var:         return mk_var_idx(var_sym(t), substitute(var_type(t)));
                        break;
    case t_appl:        t2 = mk_appl(fun_sym(t), substitute_list(fun_args(t)));
                        fun_str_sym(t2) = fun_str_sym(t);
                        break;
    case t_anno:        return mk_anno(substitute(anno_term(t)), substitute(anno_val(t)));
                        break;
    case t_list:        return substitute_list(t);
                        break;

    default:            TBmsg("term type not supported: %t\\n", t);
                        break;
  \}
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{70}\nwdocspar

%}}}
%{{{ term_list *substitute_list(term_list *l)

Create a new term by replacing all placeholders in l with
corresponding values.

\nwenddocs{}\nwbegincode{71}\sublabel{NWarmG-subF-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-subF-1}}}\moddef{substitute_list~{\nwtagstyle{}\subpageref{NWarmG-subF-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term_list *substitute_list(term_list *l)
\{
  term_list *result = l;

  while(l) \{
    list_first(l) = substitute(list_first(l));
    l = list_next(l);
  \}

  return result;
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{72}\nwdocspar

%}}}

%{{{ term *value(term *var)

Retrieve the value of a variable.
Return NULL when the variable is not present.

\nwenddocs{}\nwbegincode{73}\sublabel{NWarmG-val5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-val5-1}}}\moddef{value~{\nwtagstyle{}\subpageref{NWarmG-val5-1}}}\endmoddef\let\nwnotused=\nwoutput{}
term *value(term *var)
\{
  variable *cur = vars;

  while(cur) \{
    if(term_equal(cur->var, var))
      return cur->val;
    cur = cur->next;
  \}
  return NULL;
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}\nwbegindocs{74}\nwdocspar

%}}}
%{{{ TBbool del_var(term *var)

Delete one variable from the global list of variables.
Return when the variable is present, false otherwise.

\nwenddocs{}\nwbegincode{75}\sublabel{NWarmG-del7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWarmG-del7-1}}}\moddef{del_var~{\nwtagstyle{}\subpageref{NWarmG-del7-1}}}\endmoddef\let\nwnotused=\nwoutput{}
TBbool del_var(term *var)
\{
  variable *cur = vars, *prev = NULL;

  while(cur) \{
    if(term_equal(cur->var, var)) \{
      if(prev)
        prev->next = cur->next;
      else
        vars = cur->next;
      TBunprotect(&cur->var);
      TBunprotect(&cur->val);
      free(cur);
      return TBtrue;
    \}
    cur = cur->next;
  \}
  return TBfalse;
\}
\nwused{\\{NWarmG-armE-1}}\nwendcode{}

\nwixlogsorted{c}{{appl_apply_mappings}{NWarmG-appJ-1}{\nwixu{NWarmG-appE-1}\nwixd{NWarmG-appJ-1}}}%
\nwixlogsorted{c}{{apply_mappings}{NWarmG-appE-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-appE-1}}}%
\nwixlogsorted{c}{{arm-adapter.c*}{NWarmG-armE-1}{\nwixd{NWarmG-armE-1}}}%
\nwixlogsorted{c}{{arm_backdoor_check_in_sign}{NWarmG-armQ-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-armQ-1}}}%
\nwixlogsorted{c}{{arm_backdoor_handler}{NWarmG-armK-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-armK-1}}}%
\nwixlogsorted{c}{{assign}{NWarmG-ass6-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-ass6-1}}}%
\nwixlogsorted{c}{{char_table}{NWarmG-chaA-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-chaA-1}}}%
\nwixlogsorted{c}{{check_match_list}{NWarmG-cheG.2-1}{\nwixu{NWarmG-mat5-1}\nwixd{NWarmG-cheG.2-1}}}%
\nwixlogsorted{c}{{check_match_term}{NWarmG-cheG-1}{\nwixu{NWarmG-mat5-1}\nwixd{NWarmG-cheG-1}}}%
\nwixlogsorted{c}{{clear_arm}{NWarmG-cle9-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-cle9-1}}}%
\nwixlogsorted{c}{{delete_value}{NWarmG-delC-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-delC-1}}}%
\nwixlogsorted{c}{{del_var}{NWarmG-del7-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-del7-1}}}%
\nwixlogsorted{c}{{descent lhs}{NWarmG-desB-1}{\nwixd{NWarmG-desB-1}}}%
\nwixlogsorted{c}{{descent rhs}{NWarmG-desB.2-1}{\nwixd{NWarmG-desB.2-1}}}%
\nwixlogsorted{c}{{do_match_list}{NWarmG-do*D.2-1}{\nwixu{NWarmG-mat5-1}\nwixd{NWarmG-do*D.2-1}}}%
\nwixlogsorted{c}{{do_match_term}{NWarmG-do*D-1}{\nwixu{NWarmG-mat5-1}\nwixd{NWarmG-do*D-1}}}%
\nwixlogsorted{c}{{get_value}{NWarmG-get9-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-get9-1}}}%
\nwixlogsorted{c}{{link_arm}{NWarmG-lin8-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-lin8-1}}}%
\nwixlogsorted{c}{{list_apply_mappings}{NWarmG-lisJ-1}{\nwixu{NWarmG-appE-1}\nwixd{NWarmG-lisJ-1}}}%
\nwixlogsorted{c}{{load_arm}{NWarmG-loa8-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-loa8-1}}}%
\nwixlogsorted{c}{{load_mappings}{NWarmG-loaD-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-loaD-1}}}%
\nwixlogsorted{c}{{main}{NWarmG-mai4-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-mai4-1}}}%
\nwixlogsorted{c}{{mappings}{NWarmG-map8-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-map8-1}}}%
\nwixlogsorted{c}{{match}{NWarmG-mat5-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-mat5-1}\nwixd{NWarmG-mat5-2}}}%
\nwixlogsorted{c}{{push_symbol}{NWarmG-pusB-1}{\nwixu{NWarmG-red6-1}\nwixd{NWarmG-pusB-1}}}%
\nwixlogsorted{c}{{push_term}{NWarmG-pus9-1}{\nwixu{NWarmG-red6-1}\nwixd{NWarmG-pus9-1}}}%
\nwixlogsorted{c}{{rec_terminate}{NWarmG-recD-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-recD-1}}}%
\nwixlogsorted{c}{{reduce}{NWarmG-red6-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-red6-1}\nwixd{NWarmG-red6-2}}}%
\nwixlogsorted{c}{{reftag_to_term}{NWarmG-refE-1}{\nwixu{NWarmG-red6-1}\nwixd{NWarmG-refE-1}}}%
\nwixlogsorted{c}{{ref_to_term}{NWarmG-refB-1}{\nwixu{NWarmG-red6-1}\nwixd{NWarmG-refB-1}}}%
\nwixlogsorted{c}{{str_apply_mappings}{NWarmG-strI-1}{\nwixu{NWarmG-appE-1}\nwixd{NWarmG-strI-1}}}%
\nwixlogsorted{c}{{substitute}{NWarmG-subA-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-subA-1}}}%
\nwixlogsorted{c}{{substitute_list}{NWarmG-subF-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-subF-1}}}%
\nwixlogsorted{c}{{tb_term}{NWarmG-tb*7-1}{\nwixu{NWarmG-red6-1}\nwixd{NWarmG-tb*7-1}}}%
\nwixlogsorted{c}{{try_load_arm}{NWarmG-tryC-1}{\nwixu{NWarmG-loa8-1}\nwixd{NWarmG-tryC-1}}}%
\nwixlogsorted{c}{{value}{NWarmG-val5-1}{\nwixu{NWarmG-armE-1}\nwixd{NWarmG-val5-1}}}%
\nwbegindocs{76}\nwdocspar

%}}}

\nwenddocs{}
