
%{{{ arm-adapter

%{{{ proze

The {\tt arm-adapter} interfaces the arm interpreter with the
ToolBus. This adapter performs the following tasks:

\begin{itemize}
\item Load ARM files ({\tt snd-eval(A,load-arm(Files,Dirs))}).
\item Signal succes/failure of this loading process\newline
 ({\tt rec-value(A,loading(Files,Dirs,succes))} or\newline
 ({\tt rec-value(A,loading(Files,Dirs,error(E?)))}).
\item Link all loaded ARM code ({\tt snd-do(A,link-arm)}).
\item Clear all previously loaded ARM code ({\tt snd-do(A,clear-arm)}).
\item Reduce a term ({\tt snd-eval(reduce(T))}).
\item Retrieve the result of a reduction ({\tt rec-value(reduction(T?))}).
\end{itemize}

In addition to these basic tasks, this adapter introduces a
variable system. In this system, placeholders in input terms
are replaced by the value of the internal variable they represent.
To assign values to variables, we use the {\tt match} command.
{\tt match} takes two arguments, the first of which (T) is template
term containing placeholders. The second argument (T') is
matched against this template, and any subterm of T' that matches with
a placeholder is assigned to an internal variable. The name of this
internal variable is taken to be the placeholder.
\newline
Example:
\begin{verbatim}
  ...
  snd-eval(A,match(<abc>,hello(world))) .
  rec-value(A, ok)
  ...
  snd-eval(A,reduce(print(<abc>))) .
  rec-value(A, reduction(T?))
  ...
\end{verbatim}
After this, {\tt T} will contain the result of reducing
{\tt print(hello(world))}.

Note that that placeholders are not interpreted as types in this
situation (in contrast with for example {\tt subscribe(f(<str>))}).
Note also that complex assigments can be modeled in one match instruction,
because {\tt T'} can also contain placeholders, wich are replaced with
the value of their respective variables before matching commences.

If the outer function symbol of {\tt T'} is {\tt reduce}, all of its
arguments are first reduced after substitution of placeholders.
After this reduction, the function symbol {\tt reduction} is put around
the resulting normal forms.

This variable system consists of the following interface:
\begin{itemize}
\item Substitute placeholder values in a term ({\tt snd-eval(A,get-value(T))}).
\item Retrieve resulting term ({\tt rec-value(A, value(T?))}).
\item Match a term against a term containing placeholders, 
      and assign subterms that match with a placeholder
      to the variables corresponding to these placholders
      ({\tt snd-do(A,match(T,T'))}).
\end{itemize}

%}}}

<<arm-adapter.c*>>=
/*#include <arm.h>*/
#include <codemem.h>
#include <TB.h>
#include "arm.tif.c"

#define MAX_SYMBOL_SIZE 4096
static char buf[MAX_SYMBOL_SIZE];

int TBcid;
unsigned long MAXSIZE = 20*1024*1024;
static fun v_pair;

typedef struct variable
{
  struct variable *next;
  term *var;
  term *val;
} variable;

variable *vars = NULL;

<<char_table>>
<<mappings>>

<<assign>>
<<value>>
<<substitute>>
<<substitute_list>>
<<del_var>>
<<apply_mappings>>

<<clear_arm>>
<<load_mappings>>
<<load_arm>>
<<link_arm>>
<<reduce>>

<<match>>
<<get_value>>
<<delete_value>>

<<arm_backdoor_handler>>
<<arm_backdoor_check_in_sign>>
<<rec_terminate>>

<<main>>
@

%}}}

%{{{ char_table

<<char_table>>=
char *char_table[] =
{
  "\\000", "\\001", "\\002", "\\003", "\\004", "\\005", "\\006", "\\007",
  "\\008", "\\t",   "\\n",
  "\\011", "\\012", "\\r", "\\014", "\\015", "\\016", "\\017", "\\018",
  "\\019", "\\020", "\\021", "\\022", "\\023", "\\024", "\\025", "\\026",
  "\\027",
  "\\028", "\\029", "\\030", "\\031",
  "' ", "'!", "'\"", "'#", "'$", "'%", "'&", "''", "'(", "')", "'*", "'+",
  "',", "'-", "'.", "'/",
  "'0", "'1", "'2", "'3",  "'4", "'5", "'6", "'7", "'8", "'9",
  "':", "';", "'<", "'=",  "'>", "'?", "'@",
  "'A", "'B", "'C", "'D",  "'E", "'F", "'G", "'H", "'I", "'J",
  "'K", "'L", "'M", "'N", "'O", "'P",
  "'Q", "'R", "'S", "'T",  "'U", "'V", "'W", "'X", "'Y", "'Z",
  "'[", "\\\\", "']", "'^", "'_",  "'`",
  "'a", "'b", "'c", "'d",  "'e", "'f", "'g", "'h", "'i", "'j",
  "'k", "'l", "'m", "'n", "'o", "'p",
  "'q", "'r", "'s", "'t",  "'u", "'v", "'w", "'x", "'y", "'z",
  "'{", "'|", "'}", "'~", "-"
};
@

%}}}
%{{{ mappings

<<mappings>>=
term_list *mappings = NULL;
term_list *reverse_mappings = NULL;
@

%}}}

%{{{ int main(int argc, char *argv[])

The {\tt main} function ininializes the ARM interpreter, and
establishes a ToolBus connection.

<<main>>=
int main(int argc, char *argv[])
{
  extern int ARM_DBGMSK;

  /*ARM_DBGMSK = 16;  Tracing on */
  TB_init();
  TBprotect(&mappings);
  TBprotect(&reverse_mappings);

  ARM_set_up();

  xfunuse("pair",v_pair);

  TBcid = TB_parseArgs(argc, argv, arm_handler, arm_check_in_sign);
  TB_connect(TBcid);
  TB_eventloop();
}
@

%}}}

%{{{ void clear_arm(int cid)

<<clear_arm>>=
void clear_arm(int cid)
{
  ARM_clear();
}
@

%}}}
%{{{ void load_mappings(int cid, term_list *mappings)

<<load_mappings>>=
void load_mappings(int cid, term_list *maps)
{
  term *map;

  mappings = maps;
  reverse_mappings = NULL;

  while(maps) {
    map = list_first(maps);
    maps = list_next(maps);
    reverse_mappings = list_concat_term(reverse_mappings, 
					list_reverse(list_copy(map)));
  }

  TBprintf(stderr, "mappings = %t, reverse = %t\n", mappings, reverse_mappings);
}
@

%}}}
%{{{ term *load_arm(int cid, term_list *files, term_list *dirs)

Load a set of arm files. {\tt dirs} gives a list of directories
in which to search.

<<load_arm>>=
<<try_load_arm>>

term *load_arm(int cid, term_list *files, term_list *dirs)
{
  term *file, *dir;
  term_list *filelist, *dirlist;
  char *filename, *dirname;
  TBbool loaded;

  filelist = files;
  while(filelist) {
    file = list_first(filelist);
    filelist = list_next(filelist);
    if(!TB_match(file, "<str>", &filename))
      return TB_make("snd-value(load-arm(<list>,<list>,failure(<str>)))",
		files, dirs, "list of filenames expected");
    if(filename[0] == '/') {
      if(try_load_arm(filename) < 0)
        return TB_make("snd-value(load-arm(<list>,<list>,failure(<str>)))",
		files, dirs, TBsprintf("couldn't load file: %s", filename));
    } else {
      dirlist = dirs;
      loaded = TBfalse;
      while(dirlist && !loaded) {
        dir = list_first(dirlist);
        dirlist = list_next(dirlist);
        if(!TB_match(dir, "<str>", &dirname))
	  return TB_make("snd-value(load-arm(<list>,<list>,failure(<str>)))",
			files, dirs, "list of directories expected");
        if(try_load_arm(TBsprintf("%s/%s", dirname, filename)) > 0)
          loaded = TBtrue;
      }
      if(!loaded) {
        static char error[256];
	sprintf(error, "couldn't load file: %s\n", filename);
        return TB_make("snd-value(load-arm(<list>,<list>,failure(<str>)))",
						        files, dirs, error);
      }
    }
  }
  return TB_make("snd-value(load-arm(<list>,<list>,ok))", files, dirs);
}
@

<<try_load_arm>>=
int try_load_arm(char *path)
{
  FILE *f;

  f = fopen(path, "r");
  fclose(f);
  if(f) {
    ARM_load_arm_file(path);
    /*fprintf(stderr, "ARM file %s loaded\n", path);*/
    return 1;
  }
  return 0;
}
@

%}}}
%{{{ void link_arm(int cid)

Link all loaded arm code.

<<link_arm>>=
void link_arm(int cid)
{
  ARM_link();
}
@

%}}}
%{{{ term *reduce(int cid, term *t)

Load and reduce a term.

<<reduce>>=
<<push_symbol>>
<<tb_term>>
<<push_term>>
<<ref_to_term>>
<<reftag_to_term>>
@

%{{{ term *reduce(int cid, term *t)

<<reduce>>=
term *reduce(int cid, term *trm)
{
  ARM_ref r;
  term *t;

  if(!TB_match(trm, "term(<term>)", &t)) {
    TBprintf(stderr, "malformed term in reduce: %t\n", t);
    exit(1);
  }
  t = apply_mappings(substitute(t), mappings);

  TBprintf(stderr, "reducing term: %t, after subst and maps: %t\n", trm, t);

  ARM_ready();
  push_term(t);
  r = ARM_reduce();
  /*ARM_display(0,r,0);*/
  t = apply_mappings(ref_to_term(r), reverse_mappings);
  return TB_make("snd-value(reduct(<term>))", t);
}
@

%}}}
%{{{ void push_term(term *t)

<<push_term>>=
void push_term(term *t)
{
  char *fun;
  term_list *args = NULL;
  int c;

  if(TB_match(t, "<str>", &fun)) {
    push_symbol(fun);
  } else
  if(TB_match(t, "<appl>", &fun, &args)) {
       if(fun_str_sym(t))
         push_symbol(fun);
       else
         ARM_push(fun);
       /*args = list_reverse(args);*/
       while(args) {
         push_term(list_first(args));
         args = list_next(args);
       }
  } else {
    if(TB_match(t, "<int>", &c)) {
      assert(c >= 0 && c < 128);
      ARM_push(char_table[c]);
    } else
      TBmsg("not an application or char (int): %t\n", t);
  }
}
@

%}}}
%{{{ void push_symbol(char *fun)

<<push_symbol>>=
void push_symbol(char *fun)
{
  int i = 1;

  buf[0] = '"';
  while(*fun) {
    switch(*fun) {
      case '"':
      case '\\':
		buf[i++] = '\\';
    }
    buf[i++] = *fun++;
  }
  buf[i++] = '"';
  buf[i++] = '\0';
  ARM_push(buf);
}
@

%}}}

%{{{ term *ref_to_term(ARM_ref r)

<<ref_to_term>>=
term_list *reftag_to_term(ARM_ref r);

term *ref_to_term(ARM_ref r)
{
  term *t;

  switch(tag(r)) {
    case reftag: t = list_first(reftag_to_term(r));
      break;
    case tkntag: t = tb_term(fun2hdr(tkn2fun((fun)r))->name, NULL);
      break;
    case funtag: t = tb_term(fun2hdr((fun)r)->name, NULL);
      break;
    case numtag: t = TB_make("<int>", detag(r));
      break;
    case opqtag: t = TB_make("opaque(<int>)", r);
      break;
    case nultag: t = TB_make("nul");
      break;
  }
  return t;
}
@


Make a ToolBus term out of a reference tag.

<<reftag_to_term>>=
term_list *reftag_to_term(ARM_ref r)
{
  char *ptr;
  term_list *args = NULL;
  int len;

  /* Descent the lhs */
  if(r->car != NUL)
    args = list_concat_term(args, ref_to_term(r->car));

  /* Descent the rhs */
  if(r->cdr != NUL) {
    if(tag(r->cdr) == reftag && r->cdr->fsym == v_pair)
      args = list_concat(args, reftag_to_term(r->cdr));
    else
      list_concat_term(args, ref_to_term(r->cdr));
    if(r->fsym == v_pair)
      return args;
  }

  /* Build an application */
  return TB_make("[<term>]", tb_term(fun2hdr(r->fsym)->name, args));
}
@

%{{{ descent lhs

<<descent lhs>>=
@

%}}}
%{{{ descent rhs

<<descent rhs>>=
@

%}}}

%}}}
%{{{ term tb_term(char *id, term_list *args)

<<tb_term>>=
term *tb_term(char *id, term_list *args)
{
  int i;

/*  TBprintf(stderr, "tb_term: %s\n", id);*/
  if(!args) {
    if(id[2] == '\0' && id[0] == '\'' || id[0] == '\\')
      return TB_make("<int>", id[1]);
    if(id[0] == '\\' && strlen(id) == 4)
      return TB_make("<int>", atoi(&id[1]));
  }
  if(id[0] != '"')
    return TB_make("<appl>", id, args);
  id++;
  for(i=0; *id != '"'; i++, id++) {
    if(*id == '\\')
      id++;
    buf[i] = *id;
  }
  buf[i] = '\0';
/*  TBprintf(stderr, "result: %s\n", buf);*/
  return TB_make("<appl>", buf, args);
}
@

%}}}

%}}}

%{{{ term *match(int cid, term *m, term *t)

<<match>>=
<<check_match_term>>
<<check_match_list>>
<<do_match_term>>
<<do_match_list>>
@

%{{{ match

<<match>>=
term *match(int cid, term *m, term *t)
{
  term *t2;

  t = substitute(t);

  if(TB_match(t, "reduce(<term>)", &t2)) {
    ARM_ref r;

    ARM_ready();
    push_term(t2);
    r = ARM_reduce();
    t = ref_to_term(r);
  } else if(!TB_match(t, "term(<term>)", &t)) {
    TBprintf(stderr, "malformed term in match: %t\n", t);
  }

  if(!TB_match(m, "term(<term>)", &m)) {
    TBprintf(stderr, "malformed match term: %t\n", m);
  }

  if(check_match_term(m, t)) {
    do_match_term(m, t);
    return TB_make("snd-value(match(ok))");
  } else {
    return TB_make("snd-value(match(failure))");
  } 
}
@

%}}}

%{{{ TBbool check_match_term(term *m, term *t)

<<check_match_term>>=
TBbool check_match_list(term_list *m, term_list *l);

TBbool check_match_term(term *m, term *t)
{
  if(tkind(m) == t_placeholder) {
    return TBtrue;
  }

  if(tkind(m) != tkind(t)) {
    return TBfalse;
  }

  if(m==t)
    return TBtrue;

  switch(tkind(m)) {
    case t_bool:	return (bool_val(m) == bool_val(t));
    case t_int:		return (int_val(m) == int_val(t));
    case t_real:	return (real_val(m) == real_val(t));
    case t_str:		return streq(str_val(m), str_val(t));
    case t_bstr:	return bstr_len(m) == bstr_len(t) && 
			  memcmp(bstr_val(m), bstr_val(t), bstr_len(m)) == 0;
    case t_var:		return (var_sym(m) == var_sym(t) &&
				var_formal(m) == var_formal(t) &&
				var_result(m) == var_result(t) &&
				check_match_term(var_type(m), var_type(t)));
    case t_appl:	if(fun_sym(m) != fun_sym(t))
			  return TBfalse;
			return check_match_list(fun_args(m), fun_args(t));
    case t_anno:	return check_match_term(anno_term(m), anno_term(t))&&
			  check_match_term(anno_val(m), anno_val(t));
    case t_list:	return check_match_list(m, t);

    default:		TBmsg("term type not supported: %t\n", m);
			return TBfalse;
  }
}
@

%}}}
%{{{ TBbool check_match_list(term_list *m, term_list *l)

Check if two lists match. The list {\tt m} may contain placeholders.

<<check_match_list>>=
TBbool check_match_list(term_list *m, term_list *l)
{
  if(m == l)
    return TBtrue;
  if(m == NULL || l == NULL)
    return TBfalse;

  return check_match_term(list_first(m), list_first(l)) &&
	 check_match_list(list_next(m), list_next(l));
}
@

%}}}
%{{{ void do_match_term(term *m, term *t)

<<do_match_term>>=
void do_match_list(term_list *m, term_list *l);

void do_match_term(term *m, term *t)
{
  if(tkind(m) == t_placeholder) {
    assign(m, t);
    return;
  }

  assert(tkind(m) == tkind(t));

  switch(tkind(m)) {
    case t_bool:
    case t_int:
    case t_real:
    case t_str:
    case t_bstr:	break;

    case t_var:		do_match_term(var_type(m), var_type(t));
			break;
    case t_appl:	do_match_list(fun_args(m), fun_args(t));
			break;
    case t_anno:	do_match_term(anno_term(m), anno_term(t));
			do_match_term(anno_val(m), anno_val(t));
			break;
    case t_list:	do_match_list(m, t);
			break;

    default:		TBmsg("term type not supported: %t\n", m);
			break;
  }
}
@

%}}}
%{{{ void do_match_list(term_list *m, term_list *l)

Match two lists, and perform assignments in the process.

<<do_match_list>>=
void do_match_list(term_list *m, term_list *l)
{
  if(m == NULL || l == NULL) {
    assert(m==NULL && l==NULL);
    return;
  }

  do_match_term(list_first(m), list_first(l));
  do_match_list(list_next(m), list_next(l));
}
@

%}}}

%}}}
%{{{ term *get_value(int cid, term *t)

Perform substitutions on a term, and return the result.

<<get_value>>=
term *get_value(int cid, term *t)
{
  int result;
  term *trm;

  assert(TB_match(t, "term(<term>)", &trm));
  return TB_make("snd-value(value(<term>))", substitute(t));
}
@

%}}}

%{{{ void delete_value(int cid, term *v);

<<delete_value>>=
void delete_value(int cid, term *v)
{
  del_var(v);
}
@

%}}}

%{{{ term *arm_backdoor_handler(int cid, term *t)

Handle ToolBus calls that are not handled by the generated
function {\tt arm\_handler}.

<<arm_backdoor_handler>>=
term *arm_backdoor_handler(int cid, term *t)
{
  term *trm;
  ARM_ref r;

  if(TB_match(t, "rec-eval(<term>)", &trm)) {
    trm = apply_mappings(substitute(trm), mappings);

    ARM_ready();
    push_term(trm);
    r = ARM_reduce();
    trm = apply_mappings(ref_to_term(r), reverse_mappings);
    return TB_make("snd-value(<term>)", trm);
  }
}
@

%}}}
%{{{ term *arm_backdoor_check_in_sign(int cid, term *t)

<<arm_backdoor_check_in_sign>>=
term *arm_backdoor_check_in_sign(int cid, term *t)
{
  return NULL;
}
@

%}}}

%{{{ void rec_terminate(int cid, term *arg)

Quit the arm interpreter.

<<rec_terminate>>=
void rec_terminate(int cid, term *arg)
{
  exit(1);
}
@

%}}}

%{{{ void assign(term *var, term *val)

Assign a new value to a variable. Add the variable when it
is not yet present.

<<assign>>=
void assign(term *var, term *val)
{
  variable *cur = vars;

  while(cur) {
    if(term_equal(cur->var, var)) {
      cur->val = val;
      return;
    }
    cur = cur->next;
  }
  cur = malloc(sizeof(variable));
  if(!cur) {
    fprintf(stderr, "out of memory in assign\n");
    exit(1);
  }
  cur->next = vars;
  vars = cur;
  cur->var = var;
  cur->val = val;
  TBprotect(&cur->var);
  TBprotect(&cur->val);
}
@

%}}}

%{{{ term *apply_mappings(term *t, term_list *mappings)

<<apply_mappings>>=
term *apply_mappings(term *t, term_list *mappings);

<<str_apply_mappings>>
<<appl_apply_mappings>>
<<list_apply_mappings>>

term *apply_mappings(term *t, term_list *mappings)
{
  switch(tkind(t)) {
    case t_str:		return str_apply_mappings(t, mappings);
    case t_appl:	return appl_apply_mappings(t, mappings);
    case t_list:	return list_apply_mappings(t, mappings);
    default: assert(0);
  }
}
@

%{{{ term *str_apply_mappings(term *t, term_list *mappings)

Apply a set of mappings on a term string.

<<str_apply_mappings>>=
term *str_apply_mappings(term *t, term_list *mappings)
{
  term *val;

  val = list_get(mappings, t);
  if(!val)
    return t;
  return val;
}
@

%}}}
%{{{ term *appl_apply_mappings(term *t, term_list *mappings)

Apply a set of mappings to an application.

<<appl_apply_mappings>>=
term *list_apply_mappings(term_list *l, term_list *mappings);
term *appl_apply_mappings(term *t, term_list *mappings)
{
  sym_idx fun = fun_sym(t);
  term_list *args = fun_args(t);
  TBbool str_sym = fun_str_sym(t);
  term *key, *val;

  assert(tkind(t) == t_appl);

  key = mk_appl(fun, NULL);
  fun_str_sym(key) = str_sym;
  val = list_get(mappings, key);
  if(val) {
    args = list_apply_mappings(args, mappings);
    if(tkind(val) == t_appl) {
      t = mk_appl(fun_sym(val), args);
      fun_str_sym(t) = fun_str_sym(val);
    } else {
      assert(tkind(val) == t_str);
      t = TB_make("<appl>", str_val(val), args);
      fun_str_sym(t) = TBtrue;      
    }
  }
  return t;
}
@

%}}}
%{{{ term *list_apply_mappings(term_list *l, term_list *mappings)

Apply a set of mappings to a list of terms.

<<list_apply_mappings>>=
term *list_apply_mappings(term_list *l, term_list *mappings)
{
  term *el, *tail, *result;

  if(l) {
    el = apply_mappings(list_first(l), mappings);
    tail = list_apply_mappings(list_next(l), mappings);
    if(el != list_first(l) || tail != list_next(l))
      return mk_list(el, tail);
  }
  return l;
}
@

%}}}

%}}}
%{{{ term *substitute(term *t)

Construct a new term by replacing all placeholder occurences in t
with corresponding variable values.

<<substitute>>=
term_list *substitute_list(term_list *l);

term *substitute(term *t)
{
  term *t2;

  if(tkind(t) == t_placeholder)
    return value(t);
  
  switch(tkind(t))
  {
    case t_bool:
    case t_int:
    case t_real:
    case t_str:
    case t_bstr:	return t;


    case t_var:		return mk_var_idx(var_sym(t), substitute(var_type(t)));
			break;
    case t_appl:	t2 = mk_appl(fun_sym(t), substitute_list(fun_args(t)));
			fun_str_sym(t2) = fun_str_sym(t);
			break;
    case t_anno:	return mk_anno(substitute(anno_term(t)), substitute(anno_val(t)));
			break;
    case t_list:	return substitute_list(t);
			break;

    default:		TBmsg("term type not supported: %t\n", t);
			break;
  }
}
@

%}}}
%{{{ term_list *substitute_list(term_list *l)

Create a new term by replacing all placeholders in l with
corresponding values.

<<substitute_list>>=
term_list *substitute_list(term_list *l)
{
  term_list *result = l;

  while(l) {
    list_first(l) = substitute(list_first(l));
    l = list_next(l);
  }

  return result;
}
@

%}}}

%{{{ term *value(term *var)

Retrieve the value of a variable.
Return NULL when the variable is not present.

<<value>>=
term *value(term *var)
{
  variable *cur = vars;

  while(cur) {
    if(term_equal(cur->var, var))
      return cur->val;
    cur = cur->next;
  }
  return NULL;
}
@

%}}}
%{{{ TBbool del_var(term *var)

Delete one variable from the global list of variables.
Return when the variable is present, false otherwise.

<<del_var>>=
TBbool del_var(term *var)
{
  variable *cur = vars, *prev = NULL;

  while(cur) {
    if(term_equal(cur->var, var)) {
      if(prev)
        prev->next = cur->next;
      else
        vars = cur->next;
      TBunprotect(&cur->var);
      TBunprotect(&cur->val);
      free(cur);
      return TBtrue;
    }
    cur = cur->next;
  }
  return TBfalse;
}
@

%}}}

