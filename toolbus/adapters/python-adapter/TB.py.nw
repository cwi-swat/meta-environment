
%{{{ Introduction

The python adapter is split into two modules:
\begin{itemize}
  \item {\tt TBstart.py}
  \item {\tt TB.py}
\end{itemize}

User modules can use the functions provided in {\tt TB.py} to
interface with the ToolBus. The module {\tt TBstart.py} initialize
the ToolBus connection, and call functions in the user module
when necessary.

%}}}

%{{{ TBstart.py

{\tt TBstart.py} first initializes the ToolBus connection,
imports the user module, and starts the main eventloop.

<<TBstart.py>>=

<<TBstart imports>>
<<TBstart init>>
<<TBstart eventloop>>

<<initialize python-adapter>>
<<import user module>>

eventloop()

@

%{{{ TBstart imports

The module {\tt TBstart} needs quite a list of imports.

<<TBstart imports>>=
import string
import regsub
import traceback
import regex
import posix
import select
import sys
import time
import select
import socket
import tkinter
import Tkinter
import __main__

import TB 
import TBterm
@

%}}}

%{{{ initialize python-adapter

We need to initialize both this module and the {\tt TB.py} module.
If a {\tt socket.error} exception is raised, a message is printed.
Any other exception indicates a adapter bug, so the actual exception
is printed verbose.

<<initialize python-adapter>>=
try:
	TB.init(sys.argv)	# init function of module TB.py
	init()		# init function of module TBstart.py
except socket.error, e:
	(n, msg) = e
	TB.msg("Cannot connect to ToolBus: %s" % msg)
except:
	TB.msg("Something went wrong while initializing module TB.")
	traceback.print_exc()
	sys.exit(1)
@

%}}}
%{{{ import user module

We try to import the user specified module. If it cannot be
found, a message is printed.

<<import user module>>=
try:
        cmd = "import " + TB.module
        exec cmd
except:
        TB.msg("Could not import module %s" % TB.module)
@

%}}}

%{{{ TBstart init

Much of the knowledge about the startup protocol is hidden in this
function. The main purpos of this function is to actually locate
the ToolBus, and setup the socket connection.

The {\tt TBstart.init} function should be called AFTER {\tt TB.init(argv)}
is called!

<<TBstart init>>=
def init():
	# Find the well-known ToolBus sockets:
        sock_out = connectsocket(TB.HOST, TB.INPORT)
        send_handshake(sock_out, "%s %s %d" %
                                (TB.TOOL_NAME, TB.HOST, TB.TOOL_ID))

        sock_in = connectsocket(TB.HOST, TB.OUTPORT)
        portin = getint(sock_in, TB.TOOL_NAME)
        toolid = getint(sock_in, TB.TOOL_NAME)

	# Check if this went alright
        if portin < 0: raise TB.connect, "Illegal port number: %d" % portin
        if toolid < 0: raise TB.connect, "Illegal tool-id: %d" % toolid

	# The well-known sockets are no longer in use by this tool
        sock_in.close()
        sock_out.close()

	# The input/output ports are always consecutive
        portout = portin+1

	# Do we want global or local ports (AF_INET or AF_UNIX)
        if not TB.HOST:
                TB.HOST = TB.LOCAL_HOST
        if TB.HOST == TB.LOCAL_HOST:
                TB.output = connectsocket("", portin)
                TB.input = createsocket("", portout)
        else:
                TB.output = connectsocket(TB.HOST, portin)
                TB.input = createsocket(TB.LOCAL_HOST, portout)

	# Handshake with the ToolBus after a connection is established
        putint(TB.output, TB.TOOL_NAME, portin)
        n = getint(TB.input, TB.TOOL_NAME)

        if n != portin: raise TB.connect, "Illegal response from ToolBus"
	
	# Let the {\tt TB} module know we found the ToolBus
        TB.connected = 1

<<send_handshake>>
<<getint>>
<<putint>>
<<connectsocket>>
<<createsocket>>
@

%{{{ send_handshake

Send a handshake message to the ToolBus.
<<send_handshake>>=
def send_handshake(sock, msg):
	sock.send('%-512s' % msg)
@

%}}}
%{{{ getint

Read an integer from the ToolBus.
<<getint>>=
def getint(sock, tool):
        data = TB.mread(sock, 512)
        if not data:
                TB.msg("getint failed")
                raise TB.connect
        r = regex.compile("\([a-zA-Z\-_]+\) \([0-9]+\)")
        if r.match(data) <= 0:
                TB.msg("getint got garbled data: %s" % data)
                raise TB.connect
        if r.group(1) != tool:
                TB.msg("getint received illegal tool-name: %s" % r.group(1))
                raise TB.connect
        return string.atoi(r.group(2))
@

%}}}
%{{{ putint

<<putint>>=
def putint(sock, tool, n):
        send_handshake(sock, "%s %d" % (tool, n))
@

%}}}
%{{{ connectsocket

Locate and connect to a socket (both unix domain and internet sockets).

<<connectsocket>>=
def connectsocket(host, port):
	if not host:
		sock = connect_UNIX_socket(port)
	else:
		sock = connect_INET_socket(host, port)
	#sock.setsockopt(socket.IPPROTO_TCP, TCP_NODELAY, sock.fileno())
	return sock

<<connect_UNIX_socket>>
<<connect_INET_socket>>
@

%{{{ def connect_UNIX_socket(port):

<<connect_UNIX_socket>>=
# Connect to a unix domain socket.

def connect_UNIX_socket(port):
    attempts = 0
    while attempts < 100:
	fname = "/usr/tmp/%d" % port
	try:
		sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
		# TB.msg("opening AF_UNIX socket: %s" % fname)

		sock.connect(fname)
		TB.files.append(fname);
	except socket.error, msg:
		# <PO>: socket.error: (2, 'No such file or directory')
		# print "Retry: ", msg
		attempts = attempts + 1
		time.sleep(1)
	else: break
    return sock
@
%}}}
%{{{ def connect_INET_socket(host, port):

<<connect_INET_socket>>=
# Connect to a internet socket.

def connect_INET_socket(host, port):
    attempts = 0
    while attempts < 100:
	try:
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		adr = (socket.gethostbyname(host), port)
		sock.connect(adr)
	except socket.error, msg:
		attempts = attempts + 1
		time.sleep(1)
	else: break
    return sock
@
%}}}
%}}}
%{{{ createsocket

Create a new socket (both unix domain and internet sockets).

<<createsocket>>=
def createsocket(host, port):
        if not host:
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                adr = "/usr/tmp/%d" % port
        else:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                adr = (socket.gethostbyname(host), port)
        # Only use SO_REUSEPORT when present!
        if globals().has_key("SO_REUSEPORT"):
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # Catch: address already in use
        sock.bind(adr)
        if not host:
                posix.chmod(adr, 0777)
        sock.listen(1)
        pair = sock.accept()
        return pair[0]
@
%}}}

%}}}

%{{{ TBstart eventloop

<<TBstart eventloop>>=
def eventloop():
	if TB.use_tk:
		<<Tk eventloop>>
	else:
		<<normal eventloop>>

<<tkhandle_term>>
<<handle_term>>
<<dispatch_term>>
<<dispatch_user>>

<<check_signature>>
<<check_sig>>
<<require>>
@

%{{{ Tk eventloop

<<Tk eventloop>>=
tkinter.createfilehandler(TB.input,
tkinter.__dict__["READABLE"], tkhandle_term)
try:
	Tkinter.Tk().mainloop()
	TB.send("snd-disconnect")
	TB.connected = 0
except KeyboardInterrupt:
	pass
except:
	if TB.connected:
		TB.msg("Something went wrong in Tk mainloop.")
		traceback.print_exc()
		TB.connected = 0
@
%}}}
%{{{ normal eventloop

<<normal eventloop>>=
while 1:
	try:
		select.select([TB.input],[],[])
	except select.error, e:
		(n, msg) = e
		TB.connected = 0
		return
	else:
		handle_term()
@
%}}}

%{{{ tkhandle_term

{\tt tkhandle_term} is just a wrapper to loose the arguments.

<<tkhandle_term>>=
def tkhandle_term(file, mask):
        handle_term()
@

%}}}
%{{{ handle_term

Handle a term send by the ToolBus.

<<handle_term>>=
def handle_term():
        t = TB.read_term(TB.input)
        if t:
                # Parse the term
                try:
                        T = TBterm.parse(t)
                except:
                        TB.msg("Malformed term %s ignored (%s)" % (t, sys.exc_value))
                else:
                        dispatch_term(T)
@

%}}}
%{{{ dispatch_term

<<dispatch_term>>=
def dispatch_term(T):
        if T[0] == 'appl':
                if T[1] == 'rec-do':
                        dispatch_user(T[2][0])
                        TB.send("snd-void()")
                        return
                elif T[1] == 'rec-eval':
                        result = dispatch_user(T[2][0])
                        if result:
                                TB.send(result)
                        else:
                                # <PO>: print warning?
                                TB.send("snd-void()")
                        return
		elif T[1] == 'rec-monitor':
			result = dispatch_user(T[2][0])
			if result:
				TB.send(result)
			else:
				TB.send("snd-void()")
                elif T[1] == 'rec-ack-event':
                        result = dispatch_user(T)
                        return
                elif T[1] == 'rec-terminate':
                        result = dispatch_user(T)
                        sys.exit(0)

        print "python-adapter: Illegal term received", T
        TB.send("snd-void()")
@

%}}}

%{{{ dispatch_user

<<dispatch_user>>=

def dispatch_user(T):
        global A, R

        A = []
        if T[0] == 'appl':
                fun = regsub.gsub("-", "_", T[1])
                if fun == 'signature':
                        check_signature(T[2][0])
                else:
                        (m, f, s, a, r) = TB.functions[fun]
                        # m = module
                        # f = function name
                        # s = which args are singleton
                        # a = argument types
                        # r = result type
                        # print "function = ", (m, f, s, a, r)
                         
			cmd = "R=" + TB.module + "." + fun + "("
                        i = 0
                        A = []
                        for Arg in T[2]:
                                if s[i]:
                                        # Arg is singleton
                                        A.append(Arg[1])
                                else:
                                        A.append(Arg)
                                if i == 0:
                                        cmd = cmd + "A[%d]" % i
                                else:
                                        cmd = cmd + ",A[%d]" % i
                                i = i + 1
                        cmd = cmd + ")"

                        try:
                                exec cmd in globals()
                        except SystemExit, arg:
                                sys.exit(arg)
                        except:
                                TB.error("error while calling %s in module %s"\
                                        % (fun, TB.module))
                        else:
                                return R
	else:
		raise TBillterm, (T, "Term must be an application")

@

%}}}

%{{{ check_signature

<<check_signature>>=

def check_signature(Sig):
        if Sig[0] == 'list':
                for F in Sig[1]:
                        check_sig(F)
        else:
                raise TBillsign, "Malformed signature list: %s" % Sig
@

%}}}
%{{{ check_sig

<<check_sig>>=
def check_sig(F):
        if F[0] == 'appl':
                if F[1] == 'rec-do':
                        TB.register(TB.module, F[2][1][1], F[2][1][2], '')
                        require(TB.module, F[2][1][1], F[2][1][2])
                elif F[1] == 'rec-eval':
                        TB.register(TB.module, F[2][1][1], F[2][1][2], '<term>')
                        require(TB.module, F[2][1][1], F[2][1][2])
                elif F[1] == 'rec-ack-event':
                        TB.register(TB.module, 'rec-ack-event', F[2][1], '')
                        require(TB.module, 'rec-ack-event', F[2][1])
                elif F[1] == 'rec-terminate':
                        TB.register(TB.module, 'rec-terminate', F[2][1], '')
                        require(TB.module, 'rec-terminate', F[2][1])
        else:
                raise TBillsign, "Malformed signature: %s" % F
@

%}}}
%{{{ require

<<require>>=
def require(mod, name, args):
        #print "require: %s,%s,%s", mod, name, str(args)
        name = regsub.gsub("-", "_", name)
        dict = globals()[mod].__dict__
        if not(dict.has_key(name) and callable(dict[name])):
                TB.error("%s: missing function '%s'" % (mod,name))
@

%}}}
 
%}}

%}}}

%}}}
%{{{ TB.py

%{{{ Module TB.py

<<TB.py>>=

# -------------------------------------------------------------------------
# TB.py -- Python adapter library functions. Most of these functions are
#          based on the library code included with the first Python adapter
#          written by Leon Moonen.
#
# Author:       Pieter Olivier
# Date:         Wed Feb  7 15:57:26 MET 1996
# 
# Revised and nowebbed on:	Mon Mar  4 15:05:18 MET 1996
#
# --------------------------------------------------------------------------

<<TB imports>>
<<exception identifiers>>

<<TBstring>>
<<PYstring>>
<<send>>
<<msg>>
<<error>>
<<event>>
<<enable_tk>>

<<read_term>>

<<register>>

<<TB init>>

tool_name = sys.argv[0]
 
@

%}}}

%{{{ TB imports

<<TB imports>>=
import sys
import regsub
import regex
import select
import socket
import string
import regsub
import __main__
import tkinter
import Tkinter
 
@

%}}}
%{{{ exception identifiers

<<exception identifiers>>=
connect = "TB-connect"		# ToolBus connection fails
illterm = "IllegalTerm"		# An illegal term was encountered
illsign = "IllegalSignature"	# Signature format was not legal
@

%}}}

%{{{ TBstring

Convert a Python string to ToolBus format.

<<TBstring>>=
def TBstring(str):
        newstr = regsub.gsub('\"','\\\"',str)
        return('\"%s\"' % newstr)
@

%}}}
%{{{ PYstring

Convert a ToolBus string to a Python string.

<<PYstring>>=
def PYstring(str):
        comp = regex.compile('\"[0-9]+:\(.*\)\"')
        if (comp.match(str) != -1):
                return(comp.group(1))
        else:
                comp = regex.compile('\"\(.*\)\"')
                if (comp.match(str) != -1):
                        return(comp.group(1))
                else:
                        return(str)
@
%}}}
%{{{ send

Send a term to the ToolBus.

<<send>>=
# The following function depends on
# LENSPEC = 8 and MIN_MSG_SIZE = 128 (see utils.[ch])
# THIS SHOULD BE PARAMETERIZED !!!

def send(msg):
        length = len(msg) + 8
        msg = '%.7d:' % length + msg
        output.send('%-128s' % msg)
@

%}}}
%{{{ msg

Print a message.

<<msg>>=
def msg(message):
        sys.stderr.write('%s - %s\n' % (TOOL_NAME, message))
        sys.stderr.flush()
@
%}}}
%{{{ error

Send an error message to the ToolBus.

<<error>>=
def error(msg):
        send('python-adapter-error(%s)' % TBstring(msg))
@
%}}}
%{{{ event

Wrap a message as an event and send it to the ToolBus.

<<event>>=
def event(msg):
        send('snd-event(%s)' % msg)
@

%}}}

%{{{ register

Register a function, so typechecking can be done on the fly.

<<register>>=
def register(mod, fun, args, result):
        global functions

        fun = regsub.gsub("-", "_", fun)
        #print "register: %s,%s,%s - " % (mod, fun, result), args

        if functions.has_key(fun):
                (mod2, fun2, singletons, args2, result2) = functions[fun]
                # <PO>: We might want some more consistency checks here!
                        # Possible candidates (at first glance):
                        # - mod == mod2
                        # - result compatible with result2 (or go to <term>)
                        # - check if arguments are still singletons
                # For now, the args part of a function is the
                # args part of the last time the function was registered!
                function = (mod, fun, singleton, args, result)
        else:
                singletons = []
                for arg in args:
                        if is_singleton(arg):
                                singletons.append(1)
                        else:
                                singletons.append(0)
                function = (mod, fun, singletons, args, result)
 
        functions[fun] = function

        #print "functions = ", functions

def is_singleton(args):
        if args[0] == 'placeholder':
                type = args[1][1]
                if type == 'int' or type == 'str' or type == 'bool' \
                                or type == 'real':
                        return 1
        if args[0] == 'appl' and args[2] == []:
                return 1
        return 0
@

%}}}

%{{{ read_term

Read a term from a file (handler).
<<read_term>>=

def read_term(sock):
        global connected, use_tk, input
        try:
                buf = mread(sock, 128)
                len = string.atoi(buf[0:7])
                # msg("read_term: len = %d" % len)
                if len > 128:
                        extra = mread(sock, len - 128)
                        buf = buf + extra
                return buf[8:len]
        except:
                connected = 0
                if use_tk:
                        tkinter.deletefilehandler(input)
                raise "TBconnect"
        return ""

def mread(sock, size):
        count = 0
        buf = ""
        # msg("mread - start (size = %d)" % size)
        while len(buf) < size:
                # msg("mread - buf = %s, size = %d\n" % (buf, size))
                data = sock.recv(size-count)
                if not data: break
                buf = buf + data
        if len(buf) < size:
                msg("error while reading from socket")
                sys.exit(1)
        return buf
@
%}}}

%{{{ enable_tk

Enable the Tk interface

<<enable_tk>>=
def enable_tk():
        global use_tk
        use_tk = 1
@

%}}}

%{{{ TB init

Initialize the module TB.

<<TB init>>=

def init(argvec):
        global TOOL_NAME, TOOL_ID, HOST, INPORT, OUTPORT
        global LOCAL_HOST, LIB, parser, module, argv
        global use_tk, in_shutdown, connected, functions
        global files

        # Fill in some default values
        use_tk = 0
        in_shutdown = 0
        functions = { }
        files = [ ]
        connected = 0

        # Determine local host and use this when no -TB_HOST option was present
        LOCAL_HOST = socket.gethostname()
        HOST = LOCAL_HOST
        INPORT = 8998
        OUTPORT = 8999

        # Interpret options
        # print "argvec = ", argvec
        argv = [argvec[0]]
        l = argvec[1:]
        while l:
                if l[0] == "-script":
                        idx = string.rfind(l[1],".")
                        if idx > 0:
                                module = l[1][:idx]
                        else:
                                module = l[1]
                        l = l[2:]
                elif l[0] == "-module":
                        module = l[1]
                        l = l[2:]
                elif l[0] == "-TB_LIB":
                        LIB = l[1]
                        l = l[2:]
                elif l[0] == "-TB_TOOL_NAME":
                        TOOL_NAME = l[1]
                        l = l[2:]
                elif l[0] == "-TB_TOOL_ID":
                        TOOL_ID = string.atoi(l[1])
                        l = l[2:]
                elif l[0] == "-TB_HOST":
                        HOST = l[1]
                        l = l[2:]
                elif l[0] == "-TB_INPORT":
                        INPORT = string.atoi(l[1])
                        l = l[2:]
                elif l[0] == "-TB_OUTPORT":
                        OUTPORT = string.atoi(l[1])
                        l = l[2:]
                elif l[0][0:8] == "-details":
                        l = l[1:]
                elif l[0] == "-script-args" or l[0] == "-args":
                        argv[1:1] = l[1:]
                        l = []
                else:
                        sys.stderr.write("python-adapter: " \
                                "unrecognized option %s" % l[0])
                        l = l[1:]

        # Print some debugging output:
        # print "MODULE         = ", module
        # print "LIB            = ", LIB
        # print "TOOL_NAME      = ", TOOL_NAME
        # print "TOOL_ID                = ", TOOL_ID
        # print "HOST           = ", HOST
        # print "LOCAL_HOST     = ", LOCAL_HOST
        # print "INPORT         = ", INPORT
        # print "OUTPORT                = ", OUTPORT
        # print "argv           = ", argv 
@

%}}}

%}}}
%{{{ TBterm.py

<<TBterm.py>>=

<<TBterm imports>>
<<TBterm exception identifiers>>
<<character classes>>

<<parse>>
<<drop_application>>
<<drop_list>>
<<drop_placeholder>>
<<drop_result_var>>
<<lex>>
<<scan_string>>
<<scan_bstring>>

<<testing>>
@

%{{{ TBterm imports

The basic module {\tt TBterm} only needs {\tt strings}.

<<TBterm imports>>=
import string
@

%}}}
%{{{ TBterm exception identifiers

During parsing, parse errors and syntax errors can occur.

<<TBterm exception identifiers>>=
TermParseError	= "TermParseError"
SyntaxError	= "LexicalSyntaxError"
@

%}}}
%{{{ character classes

These character classes summarize the format of some tokens.

<<character classes>>=
CCstart_appl	= string.lowercase
CCappl		= string.letters + string.digits + '-' + '_'
CCstart_var	= string.uppercase
CCvar		= CCappl
CCstart_int	= string.digits + '-'
CCint		= string.digits
CCreal		= CCint + '.E' + '-'
@

%}}}

%{{{ parse

The {\tt parse} function does the actual parsing of ToolBus terms.
This function should be fairly efficient. If you know of any way
to do this more efficient, please let me know!

The parse algorithm is a straightforward bottom-up parsing scheme.

<<parse>>=
def parse(Str):
	global S, i

	S = Str+"$"
	i = 0
	l = len(S)
	Stack = []
	while S[i] != '$':
		(Token, Word, Skip) = lex(S, i)
		#print "lex(%s,%d) = " % (S,i), (Token, Word, Skip), \
			#	"stack = ", Stack
		i = i + Skip
		if Token == 'appl':
			Stack.append(['appl', Word, []])
		if Token == 'int':
			Stack.append(['int', Word])
		elif Token == 'var':
			Stack.append(['var', Word, 'value', []])
		elif Token == 'push':
			Stack.append(Word)
		elif Token == ')':
			drop_application(Stack)
		elif Token == ']':
			drop_list(Stack)
		elif Token == '>':
			drop_placeholder(Stack)
		elif Token == '?':
			drop_result_var(Stack)
		elif Token == 'str':
			Stack.append(['str', Word])
		elif Token == 'bstr':
			Stack.append(['bstr', Word])
		elif Token == 'bool':
			Stack.append(['bool', Word])
		elif Token == 'real':
			Stack.append(['real', Word])

	if len(Stack) > 1:
		raise TermParseError, "unexpected end of string %s" % S

	return Stack[0]
@

%}}}
%{{{ drop_application

When a ')' character is encountered, the function {\tt drop_application}
pops a number of arguments from the stack, until it encounters a ')'.
At this point, the function symbol is popped of the stack and the complete
'appl' term is constructed on pushed on the stack.

<<drop_application>>=
def drop_application(Stack):
	Args = []
	# print 'dropping application from: ', Stack
	# First, get the list of arguments
	El = Stack[-1]
	Stack[-1:] = []
	if El != '(':
		Args.insert(0, El)
		while Stack[-1] == ',':
			El = Stack[-2]
			Stack[-2:] = []
			Args.insert(0, El)
		El = Stack[-1]
		Stack[-1:] = []
	if El != '(':
		raise TermParseError, "( expected: %s - %s" % \
						(str(Stack), Str[i:])
	El = Stack[-1]
	if len(El) != 3 or El[0] != 'appl':
		raise TermParseError, "function symbol expected: %s - %s" % \
						(str(Stack), Str[i:])
	Stack[-1][2] = Args
@

%}}}
%{{{ drop_list

When a ']' character is encountered, the function {\tt drop_application}
pops a number of arguments from the stack, until it encounters a ']'.
Now the complete 'list' term is constructed on pushed on the stack.

<<drop_list>>=
def drop_list(Stack):
	Elems = []
	# print 'dropping list from: ', Stack
	# Get all the elements of the stack
	El = Stack[-1]
	Stack[-1:] = []
	if El != '[':
		Elems.insert(0, El)
		while Stack[-1] == ',':
			El = Stack[-2]
			Stack[-2:] = []
			Elems.insert(0, El)
		El = Stack[-1]
		Stack[-1:] = []
	if El != '[':
		raise TermParseError, "[ expected: %s - %s" % \
						(str(Stack), Str[i:])
	Stack.append(['list', Elems])
@

%}}}
%{{{ drop_placeholder

When a '<' character is encountered, the top element is popped from
the stack, and is made into a placeholder term.

<<drop_placeholder>>=
def drop_placeholder(Stack):
	T = Stack[-1]
	left = Stack[-2]
	Stack[-2:] = []
	if left != '<':
		raise TermParseError, "< expected: %s - %s" % \
						(str(Stack), str[i:])
	# <PO>: We might want to check if it is a valid term 
	# before placing a 'placeholder' around it!
	Stack.append(['placeholder', T])
@

%}}}
%{{{ drop_result_var

When a '?' character is found, the top element on the stack must
be a variable. If it is, it is made into a result variable, else
a parse error exception is raised.

<<drop_result_var>>=
def drop_result_var(Stack):
	V = Stack[-1]
	if len(V) != 4 or V[0] != 'var':
		raise TermParseError, "? can only follow a variable: %s - %s"\
						(str(Stack), str[i:])
	Stack[-1][2] = 'result'
@

%}}}
%{{{ lex

The function {\tt lex} does the actual lexical analyzing. Most of the time,
the first character determines what kind of token is reached. Only int/real
and bool/appl disambiguation must be handled differently.

<<lex>>=
def lex(S, i):
	start = i
	while S[i] in string.whitespace:
		i = i + 1
	if S[i] in CCstart_int:
		j = i
		while S[j] in CCint:
			j = j + 1
		if S[j] in CCreal:
			while S[j] in CCreal:
				j = j + 1
			return ('real', string.atof(S[i:j]), j-start)
		else:				
			return ('int', string.atoi(S[i:j]), j-start)
        if S[i:i+4] == 'true' and S[i+4] not in CCappl:
                return ('bool', 'true', i+4-start)
        if S[i:i+5] == 'false' and S[i+5] not in CCappl:
                return ('bool', 'false', i+5-start)
	if S[i] in CCstart_appl:
		j = i
		while S[j] in CCappl:
			j = j + 1
		return ('appl', S[i:j], j-start)
	if S[i] == '"':
		if S[i+1] == '\377':
			# Binary string
			return scan_bstring(S[i:], i-start+1)
		else:
			# Normal string
			return scan_string(S[i:], i-start)
	if S[i] in ",([<":
		return ('push', S[i], i-start+1)
	if S[i] in ")]>?":
		return (S[i], S[i], i-start+1)
	if S[i] in CCstart_var:
		j = i
		while S[j] in CCvar:
			j = j + 1
		return ('var', S[i:j], j-start)
@

%}}}
%{{{ scan_string

String scanning must be done carefully, because '\\' and '\"' sequences
must be translated into '\' and '"' respectively.

<<scan_string>>=
def scan_string(str, xtra):
        state = 0
        result = ""
        len = 0
        for c in str:
                len = len + 1
                if state == 1:
                        if c == '"':
                                return ('str', result, len+xtra)
                        elif c == '\\':
                                state = 2
                                continue
                        else:
                                result = result + c
                if state == 2:
                        if c == '"':
                                result = result + c
                        elif c == '\\':
                                result = result + '\\'
                        else:
                                result = result + '\\' + c
                        state = 1
                if state == 0:
                        state = 1
        raise SyntaxError, "Lexical parse failure in string: %s" % str
@

%}}}
%{{{ scan_bstring

Binary string scanning relatively straightforward. First determine
the length op the binary string, and then extract the actual sequence
of bytes.

<<scan_bstring>>=
def scan_bstring(str, xtra):
        len = string.atoi(str[2:8])
        return ('bstr', str[9:len], len+xtra)
@

%}}}

%{{{ testing

The rest of this file contains test functions.

<<testing>>=
<<test_parser>>
<<test_it>>
<<bench_it>>
<<bench_it2>>
<<doprof>>

<<test code>>
@

%{{{ test_parser

<<test_parser>>=
def test_parser(str):
        R = parse(str)
        print "Parsing '%s' results in: " % str, R
@

%}}}
%{{{ test_it

<<test_it>>=
def test_it():
        test_parser("abc")
        test_parser("justTesting")
        test_parser("xyz(abc)")
	test_parser("xyz(abc,def)")
	test_parser("true")
	test_parser("false")
	test_parser("xyz(abc, true)")
	test_parser("def(true, false)")
	test_parser("Abc")
	test_parser("f(A, true, B)")
	test_parser('"abc"')
	test_parser('"\377000023\377Binary String!"')
	test_parser("Var?")
	test_parser('f(true, Var ?, "abc")')
	test_parser("<123>")
	test_parser("f(<term>,true, V?)")
	test_parser("[]")
	test_parser("[a]")
	test_parser("[a,b,c]")
	test_parser('["abc", true, 356]')
	test_parser("234.56E-5")
@

%}}}
%{{{ bench_it

Do a simple benchmark to locate speedups.

<<bench_it>>=
def bench_it(count):
        start = time.time()
        print 'start timing at: ', start
        for i in range(1,count):
                DoParse('abc(1,def)')
        end = time.time()
        print 'end timing at: ', end
        print 'difference: ', end-start
@

%}}}
%{{{ bench_it2

<<bench_it2>>=
def bench_it2(count):
        start = time.time()
        print 'start timing at: ', start
        for i in range(1,count):
                DoParse('abc(1,def)')
        	DoParse("abc")
        	DoParse("justTesting")
        	DoParse("xyz(abc)")
		DoParse("xyz(abc,def,3456,123)")
		DoParse("true")
		DoParse("false")
		DoParse("xyz(abc, true)")
		DoParse("def(true, false)")
		DoParse("Abc")
		DoParse("f(A, true, B)")
		DoParse('"abc"')
		DoParse('"\377000023\377Binary String!"')
		DoParse("Var?")
		DoParse('f(true, Var ?, "abc")')
		DoParse("<123>")
		DoParse("f(<term>,true, V?)")
        end = time.time()
        print 'end timing at: ', end
        print 'difference: ', end-start
@

%}}}
%{{{ doprof

<<doprof>>=
def doprof():
	import profile

	profile.run("bench_it(1000)", "bench_it")
	profile.run("bench_it2(100)", "bench_it2")

	import pstats

	b1 = pstats.Stats("bench_it")
	b2 = pstats.Stats("bench_it2")

	b1.strip_dirs()
	b1.sort_stats("cumulative")
	b1.print_stats(10)

	print "\n\n"

	b2.strip_dirs()
	b2.sort_stats("cumulative")
	b2.print_stats(10)
@

%}}}

%{{{ test code

<<test code>>=
#test_it()
# bench_it(5000)
# bench_it2(600)
@

%}}}
%}}}

%}}}



