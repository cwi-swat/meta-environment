
\section{\label{ToolsInPython}Writing tools in Python}

You can write \TB\ tools in Python using a \TB -aware Python interpreter.
How to build such a \TB -aware Python interpreter is explained in
Section \ref{build-python}. Section \ref{using-python} explains how
to connect your python scripts that are executed by a \TB -aware
Python interpreter to the \TB.

\subsection{\label{build-python}Building a \TB -aware Python interpreter.}

Before adding \TB\ support to Python, you first have to retrieve and
install Python, version 1.3. 
If you need more information about Python or more
specific information about installing Python, you can visit the
\emp{Python home page} at {\tt http://www.python.org/}. In this document
we assume you have succesfully installed python and are only interested
in adding \TB\ support.

The first thing to do, is to copy the file 
{\tt adapters/python-adapter/TBmodule.c}, located in this \TB\ distribution
to the Python {\tt Modules} directory:
\begin{verbatim}
cp ToolBus/python-adapter/TBmodule.c Python-1.3/Modules
\end{verbatim}
Now you have to add the two lines to the file {\tt Setup} 
in the Python {\tt Modules} directory.
If you have enabled the {\tt tkinter} module in the {\tt Setup} file,
these lines are:
\begin{verbatim}
TBBASE=<your ToolBus location>
TB TBmodule.c -I$(TBBASE)/include -I/home/olivierp/include $(TBBASE)/lib/libtb.a
\end{verbatim}
If you do not have the {\tt tkinter} module enabled in the {\tt Setup} file,
you have to add the following two lines instead:
\begin{verbatim}
TBBASE=<your ToolBus location>
TB TBmodule.c -DNO_TK -I$(TBBASE)/include TBBASE)/lib/libtb.a
\end{verbatim}
Now type {\tt make} and keep your fingers crossed. If all goes well,
a new \TB -aware python interpreter will be build, which you can install
using the command {\tt make install}.

The script {\tt python-adapter}, located in
{\tt adapters/python-adapter}, is used by your \TB\ scripts to start
the \TB -aware python interpreter with the right arguments. This
script is automatically moved to the \TB\ {\tt bin} directory during
the ToolBus installation.

\subsection{\label{using-python}Using the \TB -aware python interpreter}

\paragraph{Synopsis.} Start a python script as a tool.

\paragraph{Example.} {\tt python-adapter -script hello.py}

\paragraph{Specific arguments.}
\begin{itemize}
\item {\tt -program $Name$}: Use $Name$ rather than {\tt python} as the
(\TB -aware) python interpreter.
\item {\tt -trace-calls}: Trace the calls made by the python-adapter.
      a list of function calls is printed to {\tt stderr}.
\item {\tt -script $Script$}: Execute the python script $Script$.
\item {\tt -arg $Arg$}: Pass the argument $Arg$ as a command line option
to the python interpreter. This option can be repeated multiple times.
\item {\tt -script-args $Arg1, Arg2, ...$}: This must be the last option.
The arguments $Arg1, Arg2, ...$ are passed to the python script in the
variable $TB.argv$.
\end{itemize}

\paragraph{Communication.} \hspace{-0.3cm}\footnote{Communication is described
from the point of view of the \TB, i.e., {\tt snd-} and {\tt rec-}
mean, respectively, send by \TB\ and receive by \TB.}

\begin{itemize}
\item {\tt snd-do($Tid$, $Fun$($A_1$, ..., $A_n$))}: perform the Python
function call
{\tt $Fun$($cid$,$A_1$, ..., $A_n$)}. Here $Tid$ is a tool identifier
(as produced by {\tt execute} or {\tt rec-connect}) for an instance of the {\tt
python-adapter}, and $cid$ is the connection id for this tool instance 
as returned by {\tt TB.parseArgs} or {\tt TB.newConnection}.
\item {\tt snd-eval($Tid$, $Fun$($A_1$, ..., $A_n$))}: perform the Python
function call
{\tt $Fun$($Tid$, $A_1$, ..., $A_n$}. $Tid$ and $cid$ as above.
Note that the function {\tt $Fun$} must send an anser back to the
ToolBus using {\tt return TB.make("snd-value(...)", ...)}.
\item {\tt rec-value($Tid$,$Res$)}: the return value for a previous evaluation request.
\item {\tt rec-event($Tid$, $A_1$, ..., $A_n$)}: event generated by python.
\item {\tt snd-ack-event($Tid$, $A_1$)}: acknowledgement of
a previously generated event. Perform the Python function call
{\tt rec\_ack\_event($cid$, $A_1$)}.
\item {\tt snd-terminate($Tid$, $A_1$)}: terminate execution of the
python tool. Perform the Python function call
{\tt rec\_terminate($cid$, $A_1$)}.
\end{itemize}


\subsection{\label{Python-functions}Predefined Python functions}
The following Python functions are predefined and can be used freely in Python
scripts executed by a \TB -aware Python interpreter.

\begin{itemize}

\item {\tt TB.parseArgs($Args$, $Module$)}:  Parse the commandline
      options in $Args$, and create a new tool instance. $Module$ is
      the Python module associated with this tool, for instance
      \verb@ "__main__"@. The tool is not yet connected to the \TB, until
      {\tt TB.connect} is called. This function returns the new tool
      instance id, or raises an exception.

\item {\tt TB.newConnection($Tool$, $Host$, $Port$, $Module$)}: An alternate
      way to create a new tool instance. $Tool$, $Host$, and $Module$ are
      strings, $Port$ is an integer. $Host$ can also be {\tt None}, in which
      case the local host is always used. This function returns the new
      tool instance id, or raises an exception.

\item {\tt TB.connect($Cid$)}: Create the actual connection with the \TB,
      or raise an exception.

\item {\tt TB.eventloop()}: Start the ToolBus eventloop. Please do not use
      this function when you use the {\tt Tkinter} module. If you use
      {\tt Tkinter}, use {\tt TB.enableTk} in combination with the
      {\tt Tkinter} eventloop.

\item {\tt TB.enableTk()}: Instruct the {\tt TB} module to register
      its callback functions with {\tt Tkinter}, so the {\tt Tkinter}
      eventloop can be used instead of the \TB\ eventloop.

\item {\tt TB.send($cid$, $Term$)}: Send a term to the ToolBus. $Term$ must
      be a Python term object.

\item {\tt TB.make($Fmt$, ...)}: Build a new \emp{term} object. You can use
      the following format directives in $Fmt$:
      \begin{itemize}
      \item {\tt <bool>}: Build a boolean term. This directive consumes
	one Python object from the argument list. If this object happens
	to be {\tt None}, the created term is {\tt false}, else the created
	term is {\tt true}.
      \item {\tt <int>}: Build an integer term. This directive consumes
	one Python integer object from the argument list.
      \item {\tt <str>}: Build a string term. This directive consumes one
	Python string object from the argument list.
      \item {\tt <bstr>}: Build a binary string term. 
        This directive consumes one Python string object from the argument 
        list.
      \item {\tt <real>}: Build a real term. This directive consumes one
	Python float object from the argument list.
      \item {\tt <appl>}: Build a term application. This directive consumes
	two arguments: a string defining the function symbol, and a Python list
	of terms giving the arguments.
      \item {\tt <list>}: Build a list of terms. This directive consumes
	one argument: a Python list of terms.
      \item {\tt <term>}: Build a term. This directive consumes one
        argument: a Python term object.
      \end{itemize}

\end{itemize}

\subsection{\label{term-methods}Methods of the class {\tt term}}

The module {\tt TB} introduces a new Python class called {\tt term}.
This class supports the following methods:

\begin{itemize}
\item {\tt $Term$.kind()}: Returns the type of the term. This type is
      represented by one of the following strings:
      \begin{itemize}
	\item {\tt bool}
	\item {\tt int}
	\item {\tt real}
	\item {\tt str}
	\item {\tt bstr}
	\item {\tt bstr}
	\item {\tt appl}
	\item {\tt list}
      \end{itemize}
\item Value retrieval functions. Strictly speaking, these are not
      functions, but rather 'context sensitive attributes'. These
      attributes are only valid when the term is of the appropriate type.
      \begin{itemize}
	\item {\tt $Term$.bool}: $Term$ must be a boolean. Returns 1 if the
	      term is {\tt true}, {\tt None} otherwise.
	\item {\tt $Term$.int}: $Term$ must be a integer. Returns a Python
	      integer object representing the same value.
	\item {\tt $Term$.real}: $Term$ must be a real. Returns a Python
	      float object representing the same value.
	\item {\tt $Term$.str}: $Term$ must be a string. Returns a Python
	      string object representing the same string.
	\item {\tt $Term$.bstr}: $Term$ must be a binary string. Returns
	      a Python string object representing the same string.
	\item {\tt $Term$.appl}: $Term$ must be a application. Returns a
	      tuple containing the function symbol as a string and the
	      arguments as a Python list of terms.
	\item {\tt $Term$.list}: $Term$ must be a list. Returns a
	      Python list of terms.
      \end{itemize}
\item {\tt $Term$.simplify()}: Maps the term onto a native Python object.
      For instance, a term of type {\tt <str>} is translated into a Python
      string object. 
\item {\tt $T$.match($Fmt$)}: Check if a term matches with a certain string.
      The string $Fmt$ is first parsed into a term and then the two terms
      are matched. The function returns {\tt None} when the two terms do not
      match. When the two terms do match, a list is returned that contains
      the subterms of $T$ matching with the placeholders of $Fmt$.
\item {\tt $T$.matchTerm($Fmt$)}: As {\tt $T$.match}, but $Fmt$ is now a
      term containing placeholders, and does not have to be parsed before
      matching.
\end{itemize}

\subsection{term example}
\begin{verbatim}
Python 1.3 (Jun  6 1996)  [GCC 2.6.3]
Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam
>>> import TB
>>> T = TB.make("[1,2,3]")
>>> print T
<term, [1,2,3]>
>>> print T.list
[<term, 1>, <term, 2>, <term, 3>]
>>> L = T.match("[<int>,2,<term>]")
>>> print L
[1, <term, 3>]
>>> print L[1].str
Traceback (innermost last):
  File "<stdin>", line 1, in ?
TB.error: term is not of type str
>>> print L[1].int
3
\end{verbatim}

\subsection{\label{Ex-hello.py}The hello example in Python: {\tt hello.py}}

Writing the hello tool in Python requires two steps:
\begin{itemize}
\item Write the required Python code {\tt hello.py}. 
      The result is shown in Figure~\ref{fig:hello.py}.
\item Replace {\tt hello}'s tool definition in {\tt hello2.tb} by:
\begin{verbatim}
      tool hello is {command = "python-adapter -script hello.py"}
\end{verbatim}
\end{itemize}


\begin{figure}
\rule{\textwidth}{0.5mm}
\input{../demos/hello/hello.py.tex}
  \caption{{\tt hello.py}: the hello tool in Python}
  \label{fig:hello.py}
\rule{\textwidth}{0.5mm}
\end{figure}
