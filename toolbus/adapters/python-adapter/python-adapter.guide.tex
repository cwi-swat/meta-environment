
\section{\label{ToolInPython}Writing tools in Python}

The {\tt python-adapter} is used to write \TB\ tools in Python.
First we will discuss the python-adapter command line options, and
the interface to your python script,
then we will present the \TB\ related functions that can be called
from your python script, and we will finish by giving a small example
script.

\subsection{\label{python-adapter}{\tt python-adapter}}

\paragraph{Synopsis.} Execute Tcl/Tk's windowing shell {\tt wish} as a tool.

\paragraph{Example.} {\tt python-adapter -module example.py}

\paragraph{Specific arguments.}
\begin{itemize}
\item {\tt -script}: The Python script/module to be executed.
\item {\tt -script-args}: The arguments for the Python script to be executed.
	These arguments are available to the Python script through the
        variable {\tt TB.argv}.
\end{itemize}

\paragraph{Communication.} \hspace{-0.3cm}\footnote{Communication is described
from the point of view of the \TB, i.e., {\tt snd-} and {\tt rec-}
mean, respectively, send by \TB\ and receive by \TB.}

\begin{itemize}
\item {\tt snd-do($Tid$, $Fun$($A_1$, ..., $A_n$))}: perform the Python function call
{\tt $Fun$ $A_1$  ... $A_n$}. Here $Tid$ is a tool identifier
(as produced by {\tt execute} or {\tt rec-connect}) for an instance of the {\tt
python-adapter}.
\item {\tt snd-eval($Tid$, $Fun$($A_1$, ..., $A_n$))}: perform the Python function call
{\tt $Fun$ $A_1$  ... $A_n$}. Here $Tid$ is a tool identifier 
(as produced by {\tt execute} or {\tt rec-connect}) for an instance of the {\tt python-adapter}.
Note that the function {\tt $Fun$} must send an anser back to the
ToolBus (using {\tt TBsend "snd-eval(...)"}).
\item {\tt rec-value($Tid$,$Res$)}: the return value for a previous evaluation request.
\item {\tt rec-event($Tid$, $A_1$, ..., $A_n$)}: event generated by Python.
\item {\tt snd-ack-event($Tid$, $A_1$)}: acknowledgement of
a previously generated event.
\item {\tt snd-terminate($Tid$, $A_1$)}: terminate execution of python-adapter.
\item {\bf The monitor commands are not implemented yet! ***}
	\txttt{snd-monitor(\emph{Trm})}: in this case the Python
  function \txttt{monitor\_atom \{\emph{ProcId} \emph{AtFun},
    \emph{Src} \emph{Blino} \emph{Bpos} \emph{Elino} \emph{Epos}\}}
  is called where \emph{ProcId} is the process-id of the process to
  which this atom belongs, \emph{AtFun} is the action function name of
  the atom (printf, tau, snd-do, snd-eval, rec-msg etc.), \emph{Src} the
  source file where the atom is defined, \emph{Blino} the number of
  the line where the atom starts, \emph{Bpos} the column of the
  line where the atom starts, \emph{Elino} the number of the line
  where the atom ends and \emph{Epos} is the column of the line where
  the atom ends (this information can be used for example for
  highlightning a piece of source code). 
  After calling this function the term is further analyzed,
  possibly resulting in (several) other Python function
  calls. The following situations are considered:
  \begin{itemize}
  \item \emph{process creation}:
    \txttt{create\_proc \{\emph{ProcId} \emph{ProcName}\}} is
    called.
  \item \emph{tool creation}: \txttt{create\_tool \{\emph{ToolId}
      \emph{ToolName}\}} is called.
  \item \emph{process to tool communication}:
    \txttt{proc\_tool\_comm \{\emph{ToolId} \emph{ProcId}\}} is
    called.
  \item \emph{tool to process communication}:
    \txttt{tool\_proc\_comm \{\emph{ProcId} \emph{ToolId}\}} is
    called.
  \item \emph{process to process communication}:
    \txttt{proc\_proc\_comm \{\emph{ProcId1} \emph{ProcId2}\}} is
    called.
  \item \emph{update the value of a variable in a process}:
    \txttt{update\_var \{\emph{ProcId} \emph{VarName}
      \emph{NewValue}\}} is called.
  \item \emph{update the list of subscribtions of a process}:
    \txttt{update\_subs \{\emph{ProcId} \emph{Subs}\}} is called.
  \item \emph{update the list of notes of a process}:
    \txttt{update\_notes \{\emph{ProcId} \emph{Notes}\}} is called.
  \end{itemize}
\end{itemize}

\noindent The command {\tt python} is executed once, an initial Python script
is read, and all further requests are directed to this incarnation
of {\tt python}. A small set of Python procedures is available to interact
with the \TB\ (see below).

\subsection{\label{Python-functions}Predefined Python functions}
The following Python functions are predefined in the module {\tt TB},
and can be used freely in a Python script executed by the Python adapter:
\begin{itemize}
\item {\tt TB.TBstring($Str$)\/}: converts a Python string to a \TB\ string by
surrounding it with double quotes and escaping double quotes occurring
inside $Str$.

\item {\tt TB.PYstring($Str$)\/}: converts a \TB\ string into  a Python string
by removing surrounding double quotes.

\item {\tt TB.error($Msg$)\/}: constructs an error message that can be sent
to the \TB.

\item {\tt TB.send($Trm$)\/}: send $Trm$ back to the \TB. For now, $Trm$ must
be a Python string. Later we will implement a special class {\tt TBterm}.

\item {\tt TB.event($Event$)\/}: send event $Event$ to the \TB. For now, $Trm$ must
be a Python string. Later we will implement a special class {\tt TBterm}.

\item {\tt TB.enable\_tk()\/}: enable the Python/Tk code. 
This function must be called in the initialization phase of your
application, to make sure that both Tk and \TB\ events are handled properly.

\end{itemize}

paragraph{Note.} The complete python-adapter is written in native Python.
This means that the Python interpreter does not have to be modified
to connect it to the \TB.


\subsection{\label{Ex-hello.py}The hello example in Python/Tk: {\tt hello.py}}

Writing the hello tool in Python requires two steps:
\begin{itemize}
\item Write the required Python code {\tt hello.py}. 
The result is shown in Figure~\ref{fig:hello.py}.
\item Replace {\tt hello}'s tool definition in {\tt hello2.tb} by:
\begin{verbatim}
      tool hello is {command = "python-adapter -script hello.py"}
\end{verbatim}
\end{itemize}


\begin{figure}
\rule{\textwidth}{0.5mm}
\input{../demos/hello/hello.py.tex}
  \caption{{\tt hello.py}: the hello tool in Python}
  \label{fig:hello.py}
\rule{\textwidth}{0.5mm}
\end{figure}
