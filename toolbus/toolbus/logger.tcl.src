#! __WISH__ -f        			    -*- C -*-
#
#    ToolBus -- The ToolBus Application Architecture
#    Copyright (C) 1998-2000  Stichting Mathematisch Centrum, Amsterdam,
#                             The  Netherlands.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
#

# User interface for ToolBus logger

# The following functions are called by the wish-adapter:
#
# create_proc: create a new process with given process-id and name
# create_tool: create a new tool instance with given tool-id and name
# update_var: update the value of a variable in a process
# update_subs: update the subscriptions of a process
# update_notes: update the notes of a process
# proc_proc_comm: communication between processes pid1 and pid2
# proc_tool_comm: communication from process pid to tool tid
# tool_proc_comm: communication from tool tid to process pid
# monitor_atom: execute an atom

# procs(pid)      = name
# procs(name,inst) = # instances
# procs(name,natom) = total # of atoms
# procs(name,nmsg) = total # of messages sent/received
# procs(name,ntool) = total # of tool related actions
# procs(name,nnote) = total # of note related actions

# set procs(0) INIT
# set procs(INIT,inst) 1
# set procs(INIT,natom) 0

# tools(tid)       = name
# tools(name,inst) = # instances
# tools(name,natom) = total # of atoms
# tools(name,size) = total volume (bytes) of communication

set proc_names {}

proc create_proc {pid name} {
  global procs proc_names

  if { [lsearch $proc_names $name] < 0 } {
     lappend proc_names $name
  }

  if { [info exists procs($name,inst)] } {
     incr procs($name,inst)
     set procs($pid) $name
  } else {
     set procs($name,inst) 1
     set procs($name,natom) 0
     set procs($name,nmsg) 0
     set procs($name,ntool) 0
     set procs($name,nnote) 0
     set procs($pid) $name
     add_proc $name
   }
}

proc create_tool {tid name} {
  global tools
  if { [info exists tools($name,inst)] } {
     incr tools($name,inst)     
     set tools($tid) $name
  } else {
     set tools($name,inst) 1
     set tools($name,natom) 0
     set tools($name,size) 0
     set tools($tid) $name
     add_tool $name
   }
}

proc update_var {pid var val} {
 if { [info exists procs($pid)] } {
      incr procs($procs($pid),natom)
   }
}

proc update_subs {pid subs} {
 if { [info exists procs($pid)] } {
      incr procs($procs($pid),nnote)
   }
}

proc update_notes {pid notes} {
 if { [info exists procs($pid)] } {
      incr procs($procs($pid),nnote)
   }
}

# Note: for a binary communication between pid1 and pid2, we get
#    proc_proc_com pid1 pid2
# and
#    proc_proc_com pid2 pid1
# We do not draw (the same) connection for the second call.

proc proc_proc_comm {pid1 pid2 dir} {
  if { [info exists procs($pid1)] } {
      incr procs($procs($pid1),nmsg)
   }
  if { [info exists procs($pid2)] } {
      incr procs($procs($pid2),nmsg)
   }
}

proc proc_tool_comm {pid tid size} {
   global procs tools
  if { [info exists procs($pid)] } {
      incr procs($procs($pid),ntool)
   }

   incr tools($tools($tid),natom)
   incr tools($tools($tid),size) $size
}

proc tool_proc_comm {pid tid size} {   
   global procs tools
   if { [info exists procs($pid)] } {
      incr procs($procs($pid),ntool)
   }
   incr tools($tools($tid),size) $size
}

proc monitor_atom {pid atfun src blino bpos elino epos} {
   global procs

   if { [info exists procs($pid)] } {
      incr procs($procs($pid),natom)
   }
   TBsend "snd-continue($pid)"
}

proc print_proc_statistics {} {
  global procs proc_names

  puts stderr "\n\t\t\t====== ToolBus Process Statistics =====\n"

  set natoms 1
  set ntools 1
  set nmsgs 1
  set nnotes 1
  foreach name $proc_names {
      incr natoms $procs($name,natom)
      incr ntools $procs($name,ntool)
      incr nmsgs $procs($name,nmsg)
      incr nnotes $procs($name,nnote)
  }
  set ntotal [expr $natoms + $ntools +$nmsgs +$nnotes]
  puts stderr [format "%15s%19s%21s%21s%21s%21s\n" Process "Atomic Steps" Messages Notes "Tool Comm." Total]
  foreach name $proc_names {
      set name_total [expr $procs($name,natom) + $procs($name,nmsg) + $procs($name,nnote) + $procs($name,ntool)]
      puts -nonewline stderr [format "%15s" $name]
      puts -nonewline stderr [format "%10d (%5.1f%%)  " $procs($name,natom) [expr 100.0 * $procs($name,natom) / $natoms]]
      puts -nonewline stderr [format "%10d (%5.1f%%)  " $procs($name,nmsg) [expr 100.0 * $procs($name,nmsg) / $nmsgs]]
      puts -nonewline stderr [format "%10d (%5.1f%%)  " $procs($name,nnote) [expr 100.0 * $procs($name,nnote) / $nnotes]]
      puts -nonewline stderr [format "%10d (%5.1f%%)  " $procs($name,ntool) [expr 100.0 * $procs($name,ntool) / $ntools]]
      puts -nonewline stderr [format "%10d (%5.1f%%)  " $name_total [expr 100.0 * $name_total / $ntotal]]
      puts stderr ""
  }
  puts stderr "\n\t\t\t=========== End of Statistics ========="
}

proc rec-terminate { n } {
  print_proc_statistics
  destroy .; exit
}
#-------------------------------------------------------------
# Set default options
#-------------------------------------------------------------

option add *Background ivory
option add *Foreground black

option add *selectForeground snow
option add *selectBackground SeaGreen

option add *activeForeground snow
option add *activeBackground SeaGreen

option add *Scrollbar.Foreground honeydew2
option add *Scrollbar.activeForeground SeaGreen

option add *Scale.Foreground honeydew2
option add *Scale.activeForeground SeaGreen

# option add *font "-adobe-palatino-medium-r-normal--17-120-100-100-p-89-iso8859-1"
option add *Text.font 8x13

set auto_path "$tk_library/demos $auto_path"

proc mkLogger {} {

   set w .logprocs
   toplevel .logprocs
   set f .logprocs.title
   frame $f
   label $f.name -text Name -width 10
   label $f.inst -text "# inst" -width 10
   label $f.natom -text "# atoms" -width 10
   pack $f.name $f.inst $f.natom -side left -anchor w
   pack $f -side top -anchor w   

   wm title .logprocs "Process Logger"
   wm minsize .logprocs 10 10

   toplevel .logtools
   set f .logtools.title
   frame $f
   label $f.name -text Name -width 10
   label $f.inst -text "# inst" -width 10
   label $f.size -text "# bytes" -width 10
   pack $f.name $f.inst $f.size -side left -anchor w
   pack $f -side top -anchor w   
   
   wm title .logtools "Tool Logger"
   wm minsize .logtools 10 10

   puts stderr "mkLogger ... done\n"
}

proc add_proc {name} {
     global procs

     set f .logprocs.proc-$name
     frame $f
     label $f.name -text $name -width 10
     label $f.inst -textvariable procs($name,inst) -width 10 -relief sunken -anchor w
     label $f.natom -textvariable procs($name,natom) -width 10 -relief sunken -anchor w
     pack $f.name $f.inst $f.natom -side left -anchor w
     pack $f -side top -anchor w
}

proc add_tool {name} {
     global tools
     set f .logtools.tool-$name
     frame $f
     label $f.name -text $name -width 10
     label $f.inst -textvariable tools($name,inst) -width 10 -relief sunken -anchor w
     label $f.size -textvariable tools($name,size) -width 10 -relief sunken -anchor w
     pack $f.name $f.inst $f.size -side left -anchor w
     pack $f -side top -anchor w
}

wm withdraw .      ; # withdraw the main window of wish

mkLogger
create_proc 0 INIT
