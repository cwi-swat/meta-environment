%%
%%    ToolBus -- The ToolBus Application Architecture
%%    Copyright (C) 1998-2000  Stichting Mathematisch Centrum, Amsterdam, 
%%                             The  Netherlands.
%%
%%    This program is free software; you can redistribute it and/or modify
%%    it under the terms of the GNU General Public License as published by
%%    the Free Software Foundation; either version 2 of the License, or
%%    (at your option) any later version.
%%
%%    This program is distributed in the hope that it will be useful,
%%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%    GNU General Public License for more details.
%%
%%    You should have received a copy of the GNU General Public License
%%    along with this program; if not, write to the Free Software
%%    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
%%
\documentclass[twoside]{article} % -*-latex-*-
\setlength{\oddsidemargin}{0.235cm}
\setlength{\evensidemargin}{0.235cm}
\setlength{\textwidth}{16cm}
\setlength{\textheight}{22cm}
\topmargin 0.5cm  % was: 0.2cm
\pagestyle{myheadings}
\usepackage{psfig}
\begin{document}

\newcommand{\TB}{{\sc ToolBus}}
\newcommand{\T}{{\bf T}}
\newcommand{\spec}[1]{{\rm #1}}
\newcommand{\script}[1]{{\tt #1}}
\newcommand{\ASFSDF}{{\sc Asf+Sdf}}
\newcommand{\ASF}{{\sc Asf}}
\newcommand{\SDF}{{\sc Sdf}}
\newcommand{\GEL}{{\sc Gel}}
\newcommand{\iter}{\,^*\,}
\newcommand{\emp}[1]{{\em #1}}
\newcommand{\txttt}[1]{{\tt #1}}

%\input{psfig.tex}

\title{A Guide to \TB\ Programming\\
%% Version $$Version: $$
}
\author{P. Klint$^{1,2}$}
\date{\today}
\maketitle
\begin{center}
       {\footnotesize $^1$ Programming Research Group, University of Amsterdam\\
        P.O. Box 41882, 1009 DB Amsterdam, The Netherlands\\
        $^2$ Department of Software Technology\\
        Centre for Mathematics and Computer Science\\
        P.O. Box 4079, 1009 AB Amsterdam, The Netherlands}
\end{center}

\begin{abstract}
The \TB\ is a new software architecture intended for building
cooperating, distributed applications.  This guide aims at providing a
comprehensive but complete explanation of ``\TB\ programming'':
writing \TB\ scripts (or \T\ scripts for short) describing the overall architecture of an
application and writing tools that actually implement the application's
functionality.

\end{abstract}
\tableofcontents

\newpage

\section{Introduction}

\subsection{Background and motivation}
Building large, heterogeneous, distributed software systems poses
serious problems for the software engineer.  Systems grow {\em larger}
because the complexity of the tasks we want to automate
increases.  They become {\em heterogeneous} because large systems may be
constructed by re-using existing software as components.
It is more than likely that these components have been developed
using different implementation languages and run on different
hardware platforms.
Systems become {\em distributed} because they have to operate
in the context of local area networks.

We propose to get control over the possible
interactions between software components (``tools'') by forbidding
direct inter-tool communication.  Instead, all interactions are
controlled by a process-oriented ``script'' that formalizes all the
desired interactions among tools.  This leads to a component
interconnection architecture resembling a hardware communication bus,
and therefore we call it a ``\TB''.

\subsection{The \TB\ architecture}

\begin{figure}[tb]
\rule{\textwidth}{0.5mm}

  \input{Arch.tex}
  \centerline{\box\graph}
  \caption{Global organization of the \TB}
  \label{fig:Arch}

\rule{\textwidth}{0.5mm}
\end{figure}

The global architecture of the \TB\  is shown in
Figure~\ref{fig:Arch}.  The \TB\  serves the purpose of defining the
cooperation of a variable number of {\em tools} $T _ i$ ($i = 1,...,m$) that
are to be combined into a complete system. The internal behaviour or
implementation of each tool is irrelevant: they may be implemented in
different programming languages, be generated from specifications, etc.
Tools may, or may not, maintain their own internal state.
Here we concentrate on the external behaviour of each tool.
In general an {\em adapter} will be needed for each tool
to adapt it to the common data representation and message protocols
imposed by the \TB.

The \TB\ itself consists of a variable number of processes\footnote{By
``processes'' we mean here computational activities {\em inside} the
\TB\ as opposed to, for instance, processes at the operating system
level.  When confusing might arise, we will call the former \TB\
processes'' and the latter ``operating system level processes''.} $P _
i$ ($i = 1,...,n$).  The parallel composition of the processes $P_ i$
represents the intended behaviour of the whole system.  Tools are
external, computational activities, most likely corresponding with
operating system level processes. They come into existence either by
an execution command issued by the \TB\ or their execution is initiated
externally, in which case an explicit connect command has to be
performed by the \TB.  Although a one-to-one correspondence between
tools and processes seems simple and desirable, we do not enforce this
and permit tools that are being controlled by more than one process as
well as clusters of tools being controlled by a single process.

\paragraph{Communication inside the \TB.}
Inside the \TB, there are two communication mechanisms available.
First, a process can send a {\em message} (using \script{snd-msg}) which
should be received, synchronously, by one other process (using
\script{rec-msg}). Messages are intended to request a service from another
process. When the receiving process has completed the desired service
it may inform the sender, synchronously, by means of another message (using
\script{snd-msg}). The original sender can receive the reply using
\script{rec-msg}.  By convention, part of the the original message is contained
in the reply (but this is not enforced).

Second, a process can send a {\em note} (using \script{snd-note}) which is
broadcasted to other, interested, processes. The sending process does
not expect an answer while the receiving processes read notes
asynchronously (using \script{rec-note}) at a low priority. Notes are
intended to notify others of state changes in the sending process.
Sending notes amounts to {\em asynchronous selective broadcasting}.
Processes will only receive notes to which they have {\em subscribed}.

\paragraph{Communication between \TB\ and tools.}
The communication between \TB\ and tools is based on handshaking
communication between a \TB\ process and a tool.  A process may send
messages in several formats to a tool (\script{snd-eval}, \script{snd-do},
and \script{snd-ack-event}) while a tool may send the messages \script{snd-event}
and \script{snd-value} to a \TB\ process.  There is no direct communication
possible between tools.

The execution and termination of the tools attached to the \TB\ can be
explicitly controlled. It is also possible to connect or disconnect
tools that have been executing independently of the \TB.

\subsection{Purpose of this guide}
This guide is a companion to the various \TB\ papers\footnote{The most comprehensive
publication is J.A. Bergstra and P.~Klint,
``The discrete time {T}ool{B}us -- a software coordination
  architecture'', {\em Science of Computer Programming}, 31(2-3):205--229, July 1998.  

Technical reports giving detailed descriptions of the semantics (using ASF+SDF specifications)
and implementation of the \TB\ are:
J.A. Bergstra and
P. Klint, ``The ToolBus---a component interconnection architecture'',
Report P9408, Programming Research Group, University of Amsterdam,
1994, and J.A. Bergstra and P. Klint, ``The Discrete Time ToolBus'',
Report P9502, Programming Research Group, University of Amsterdam, 1995.}
fully describing the motivation and overall architecture of the
\TB\ and explaining the \T\ scripts used to describe cooperating sets
of tools. The reader is also referred to these reports for several examples
of systems that have been described using the \TB\ approach.

Here, the main  emphasis is on explaining {\em all} details needed to actually
implement systems using the \TB. First, we will give a ``hello world'' example
in the context of the \TB.

\begin{figure}[tb]
\rule{\textwidth}{0.5mm}
\input{hello1.tb.tex}
  \caption{{\tt hello1}: first script for the {\tt hello} application.}
  \label{fig:hello1.tb}
\rule{\textwidth}{0.5mm}
\end{figure}

\begin{figure}[tb]
\rule{\textwidth}{0.5mm}
\input{hello2.tb.tex}
  \caption{{\tt hello2}: second script for the {\tt hello} application.}
  \label{fig:hello2.tb}
\rule{\textwidth}{0.5mm}
\end{figure}

\begin{figure}[tb]
\rule{\textwidth}{0.5mm}
\input{hello.c.tex}
  \caption{{\tt hello.c}: simple C code for the {\tt hello} tool.}
  \label{fig:hello.c}
\rule{\textwidth}{0.5mm}
\end{figure}

\begin{figure}[tb]
\rule{\textwidth}{0.5mm}
\input{hello-gen.c.tex}
  \caption{{\tt hello-gen.c}: C code for the {\tt hello} tool using a generated tool interface.}
  \label{fig:hello-gen.c}
\rule{\textwidth}{0.5mm}
\end{figure}

\subsection{\label{Hello}Hello world}
The most simple program that is frequently used to learn a new
programming language is a program which prints some string (e.g.,
``hello world'') as proof of competence of its author to write,
compile, and execute a program in the language in question.  Clearly,
it is the road to arrive at this result that counts and not the result
itself (as the old proverb says).

The simplest hello program possible is shown in Figure~\ref{fig:hello1.tb}.
Typing the command
\begin{quote}
{\tt toolbus hello1.tb}
\end{quote}
will simply print the desired message.



Let's now be more ambitious. In the above example, the text to be printed
appears as a literal string in the script. We complicate the example
by introducing a ``{\tt hello}'' tool that will provide the text to be printed.
This results in the script given in Figure~\ref{fig:hello2.tb}.
But how do we implement the {\tt hello} tool itself?
We will explain in this guide the range of implementation languages that 
can be used (i.e., C, Tcl, Perl, \ASFSDF\ ...).
For the sake of this example we only show what a C implementation will look like.

In Figure~\ref{fig:hello.c} a first, simple, version of the {\tt hello} tool
is shown. It consists of the following parts\footnote{
You are not yet supposed to understand every detail of these
listings, but you {\em will} be able to do so after reading this guide!}:
\begin{itemize}
\item An include of a standard header file ({\tt atb-tool.h}) that contains
common definitions for all tools.
\item A declaration of a function {\tt hello\_handler} that is called when there is
input available from the \TB:
its argument {\tt inp} is the input term, and its result (either a term
or {\tt NULL}) will be sent back to the \TB.\footnote{It is important
to stress that the handler should {\bf always} return a value: 
either a term or NULL.}
The input is analyzed by using {\tt ATmatch}, a library function for matching
terms. For the {\tt get-text} case, 
the term
\begin{quote}
\verb+snd-value("Hello World, my first ToolBus tool in C!\n")+
\end{quote}
is constructed and returned to the \TB.

\item A main program that calls an initialization function and
then enters an event loop.

\end{itemize}

Although it is not yet clear from the examples given so far,
it turns out that there is much commonality among the handlers
written for different tools. In particular, the code for analyzing
terms coming from the \TB\ is similar. This code also duplicates
information in the script concerning the requests sent to each tool.
For this reason, we also provide a {\em tool interface generator}
that automatically generates tool interfaces from a given script.

This approach is shown in a second version of
the {\tt hello} tool (Figure~\ref{fig:hello-gen.c}).
From the script {\tt hello2.tb} we generate automatically\footnote{In
  section~\ref{tifstoc} this is fully explained.} the following two files:

\begin{itemize}
  
\item {\tt hello.tif.h}: this includes necessary header files, and declares
  prototypes for application functions {\tt get\_text}, {\tt rec\_terminate} and
  the ToolBus interfacing functions {\tt hello\_handler} (handles all requests
  coming from the \TB) and {\tt hello\_checker} (checks that the interface as
  expected by the \TB\ is compatible with the interface as provided by the
  tool).  %% A listing of {\tt hello.tif.h} appears later on in
          %% Figure~\ref{fig:hello.tif.h}.
  
\item \begin{sloppypar} {\tt hello.tif.c}: includes {\tt hello.tif.h} and
    contains the declarations for {\tt hello\_handler} and {\tt
      hello\_checker}.
    %% A listing of {\tt hello.tif.c} appears later on in
    %% Figure~\ref{fig:hello.tif.c}.
    \end{sloppypar}

\end{itemize}

The actual program {\tt hello.c} consists of the following parts:
\begin{itemize}
\item An include of {\tt hello.tif.c}

\item A declaration of the function {\tt get\_text} that handles the
eval request coming from the \TB\ 
Note that {\tt get\_text} is called by {\tt hello\_handler} and that
its return value will be sent back to the \TB.

\item A declaration of the function {\tt rec\_terminate} that is always
  called on termination of a tool.

\item A main program that calls an initialization function and
then enters an event loop.

\end{itemize}


What we see in these examples is that
building an application with the \TB\ requires the following steps:
\begin{itemize}
\item Design the overall behaviour of the application by writing a \T\ script ({\tt hello2.tb}).
\item Write and compile the tools needed by the script ({\tt hello.c}).
The required interfacing code can be written by hand or be generated
automatically from the \T\ script ({\tt hello.tif.c}).
\item Execute the \TB\ interpreter with the script as input.
\end{itemize}

\subsection{Further reading}
If you have come this far, you may be interested to learn more about the details
of \TB\ programming.
In Section~\ref{Executing} the ways to execute the \TB\ interpreter
and tools are described.
Next follows an intermezzo explaining the overall structure of \TB\ adapters
(Section~\ref{Adapters}).
In Section~\ref{ToolsInC} you will find a complete description
of the library functions provided for writing tools in C.

In the sections that follow we explain how to write tools in various languages
and systems:
arbitrary Unix commands (Section~\ref{ToolsFromUnix}),
Java (Section~\ref{ToolsInJava}),
Perl (Section~\ref{ToolsInPerl}),
Python (Section~\ref{ToolsInPython}), and
Tcl/Tk (Section~\ref{ToolsInTcl2}).

Four appendices with summaries conclude this guide.

\section{\label{Executing}Executing \TB\ and tools}

The \TB\ interpreter ({\tt toolbus}) and all tools have some
standard program arguments in common, but they have some specific
arguments as well. In this section we describe all possible program arguments
and the way to execute {\tt toolbus} and tools.

\subsection{Common arguments}

\TB\ and tools have the following optional arguments in common:
\begin{itemize}

\item {\tt -help}: prints a description of all arguments of the toolbus or tool.

\item {\tt -verbose}: produces a log of steps taken by toolbus or tool
that may be useful to debug your script or tool. The same effect may be obtained
by setting the environment variable {\tt TB\_VERBOSE}
to {\tt true} and export it.
In the Korn shell this can, for instance, be achieved by:
\begin{verbatim}
      TB_VERBOSE=true
      export TB_VERBOSE
\end{verbatim}

\item {\tt -TB\_PORT} {\em port\_name}: defines the ``well known socket'' {\em port\_name}
to which all tools temporarily connect in order to set up their
own private socket that connects them permanently to the \TB\ interpreter.
When omitted, socket 8998 will be used.

\end{itemize}

Note that explicit arguments defining the sockets are {\em only}
needed when several \TB\ interpreters are running simultaneously on
the {\em same} host machine.

\subsection{\label{TB-args}\TB\ arguments}
The $script\_name$ (see below) given as argument to the \TB\ is always
preprocessed by the C preprocessor before it is parsed as a \T\ script.
In this way, directives like, e.g., {\tt \#define}, {\tt \#include} and
{\tt \#ifdef} can be used freely in \T\ scripts. The following
preprocessor arguments are accepted by the {\tt toolbus} command:

\begin{itemize}

\item {\tt -I$dir$}: append directory $dir$ to the list of directories
searched for include files.

\item {\tt -D$macro$}: define macro $macro$ with the string ``{\tt 1}'' as
its definition.

\item {\tt -D$macro$=$defn$}: define macro $macro$ with $defn$
as definition.

\end{itemize}

\noindent Other arguments specific for the {\tt toolbus} command are:
\begin{itemize}
\item {\tt -logger}: execute a logger tool that will be attached to all
processes in the \TB.
If the script contains a tool definition for a tool named ``{\tt logger}'',
that will be used for executing the logger. Otherwise a default tool definition
is used.
\item {\tt -viewer}: similar as above, for a viewer tool.
The default viewer is the ``\TB\ viewer'' (previously known
as the \TB\ debugger).

\item {\tt -controller}: similar as above, for a controller tool.
Currently, no default controller tool is provided.

\item {\tt -gentifs}: only generate tool interfaces 
for all tools used in the script
in a language independent format. For a script file named {\tt script.tb}
the tool interfaces are written to {\tt script.tifs}.
Do not execute the script.

\item {\tt -fixed-seed}: use a fixed seed for the random generator
used by the interpreter for scheduling processes and selecting
alternatives in processes.  By default, the random generator is
initialized with the current time the {\tt toolbus} command is given.
Using the {\tt -fixed-seed} option makes the execution of the script
reproducible across multiple runs of the {\tt toolbus} command.

\item {\em script\_name}: any other argument is the name of the
\TB\ script to be interpreted.
\end{itemize}

\noindent As an example, consider first
\begin{verbatim}
      toolbus hello.tb
\end{verbatim}
which starts interpreting the script ``{\tt hello.tb}''. Next, consider
\begin{verbatim}
      toolbus -TB_PORT 4000 hello.tb
\end{verbatim}
which interprets the same script, but uses socket {\tt 4000} to find
the ToolBus.
Next, consider,
\begin{verbatim}
      toolbus -Imy-include-dir -DCNT=33 wave.tb
\end{verbatim}
which searches the directory {\tt my-include-dir} for files used in {\tt \#include}
directives in the script {\tt wave.tb} and it will define the macro
{\tt CNT} with value {\tt 33}. All occurrences of {\tt CNT} in the script
will be replaced by this value before parsing it as a \T\ script.
Finally,
\begin{verbatim}
      toolbus -gentifs hello.tb
\end{verbatim}
produces the tool interfaces file {\tt hello.tifs}.

\subsection{\label{ToolArgs}Tool arguments}
Arguments specific for tools are:
\begin{itemize}
\item {\tt -TB\_HOST} {\em host\_name}: defines the host machine {\em host\_name}
on which the \TB\ interpreter is running and to which the tool should be connected.
When omitted, the \TB\ interpreter should be running on the same
host as the tool.
\item {\tt -TB\_TOOL\_NAME} {\em tool\_name}: the tool name as
defined in the \T\ script (added automatically, when a tool is executed
by the \TB).
\item {\tt -TB\_TOOL\_ID} {\em Id}: internal tool identifier of this tool execution
(added automatically, when a tool is executed by the \TB).
\item {\tt -TB\_SINGLE}: execute the tool stand-alone and do not connect it
with the \TB.
\end{itemize}

\noindent The execution of a tool can start in two ways:
\begin{itemize}
\item The tool is started by an {\tt execute} command in the \T\ script.

\item The initiative to execute the tool is taken
outside the \TB. This requires that the script contains a {\tt rec-connect}
for this particular tool.
\end{itemize}

\noindent When \TB\ and tool are running on different host machines,
it is important
to define the host machine on which the \TB\ interpreter is running
when starting the execution of the tool.
As an example, consider the ``{\tt hello}'' application described in Section~\ref{Hello}.
The {\tt hello} tool will be executed by the \TB\ using
the command
\begin{verbatim}
      hello -TB_PORT 8998 -TB_HOST host1.institute.nl
\end{verbatim}
when running on machine {\tt host1.institute.nl}.

Suppose, we replace the explicit {\tt execute} in Figure~\ref{fig:hello2.tb}
by a {\tt rec-connect} as shown in Figure~\ref{fig:hello3.tb}.
We may then manually start the
{\tt hello} tool by typing
\begin{verbatim}
      hello
\end{verbatim}
where we use the default values for the input/output sockets and assume
that tool and \TB\ interpreter are both running on the same host (i.e., {\tt host1.institute.nl}).
Starting the execution from {\em another} host is achieved by typing
(on, say, {\tt host2.institute.nl}):
\begin{verbatim}
      hello -TB_HOST host1.institute.nl
\end{verbatim}

\begin{figure}[tb]
\rule{\textwidth}{0.5mm}
\input{hello3.tb.tex}
  \caption{{\tt hello3}: {\tt hello} application with {\tt rec-connect}.}
  \label{fig:hello3.tb}
\rule{\textwidth}{0.5mm}
\end{figure}


\section{\label{Adapters}Adapters for tools and languages}
\begin{figure}[tb]
\rule{\textwidth}{0.5mm}
  \input{Adapter.tex}
  \centerline{\box\graph}
  \caption{General structure of a tool adapter}
  \label{fig:adapter}
\rule{\textwidth}{0.5mm}
\end{figure}

The main purpose of adapters is to act as small ``wrappers'' around existing
programs or programming languages in order to transform them into tools that
can be connected to the \TB. There exist two global strategies for
constructing adapters:

\begin{itemize}
\item The adapter and the program to be adapted are executed as separate
(Unix) processes. This structure is sketched in Figure~\ref{fig:adapter}.
The advantage of this approach is that no access is
needed to the source code of the program: it can remain a black box.
Another advantage is that adapters may be reused for the adaptation of
different programs. A possible disadvantage is some loss in
efficiency.

\item Integrate the adapter and the software to be adapted into a single
(Unix) process. This approach permits the most detailed adaptation of
the program and is also the most efficient solution. This approach
leads, however, to potentially less reusable adapters than the
previous approach.

\end{itemize}

Our experience so far is restricted to adapters of the first category.
In this category a further subdivision is possible:
\begin{itemize}
\item The program is executed once as a child process of the adapter
and all {\tt snd-eval}/{\tt snd-do} requests are directed to this child process.
The program can thus maintain an internal state between requests.

\item The same program is executed as a child process of the adapter
for each {\tt snd-eval}/{\tt snd-do} request.

\item A different program is executed as a child process of the adapter
for each {\tt snd-eval}/{\tt snd-do} request.

\end{itemize}

\paragraph{Common arguments of adapters.} In order to achieve some uniformity,
the current collection of adapters have the following optional program arguments
in common:

\begin{itemize}

\item {\tt -cmd}: the (default) program to be executed by the adapter.
All arguments of the adapter that follow {\tt -cmd} are interpreted as
the name and arguments of the program to be executed.

\item all tool arguments (see Section~\ref{ToolArgs}.)
\end{itemize}


\section{\label{ToolsInC}Writing tools in C}

Although \TB\ tools can be implemented in many languages (including Java, C++,
Perl, Tcl/Tk, Prolog, ASF+SDF, Cobol and others) we start explaining how tools
can be written in C. In other languages identical notions will be used with
only minor adjustements to language-specific features and limitations.
Writing tools in C amounts to:

\begin{itemize}

\item ATerms: the essential data type that is used to exchange
information between tool and \TB\ (Section~\ref{ATerms}).

\item The global structure of a \TB\ tool (Section~\ref{GlobalStructureTool}).

\item The \TB\ Application Programmer's Interface  (Section~\ref{ToolBusAPI}).

\item Compiling \TB\ tools written in C (Section~\ref{CompilingTools}).
  
\item Generating tool interfaces with {\tt tifstoc} (Section~\ref{tifstoc}).

\end{itemize}

\subsection{\label{ATerms}ATerms: Composing and decomposing terms}

We use a datatype called ATerms for creating, matching, reading and
writing terms. ATerms are fully described elsewhere.\footnote{H. A. de
Jong and P. A. Olivier, ``ATerm Library User Manual'' and M.G.J. van
den Brand, H.A. de Jong, P. Klint and P.A. Olivier, ``Efficient
Annotated Terms'', \emph{Software Practice and Experience},
30:259--291, 2000.}  Here we only give a brief overview.


\subsubsection{\label{Patterns}Term patterns}
Composition and decomposition of terms is {\em not} based on the
direct manipulation of the underlying representation of terms.
Instead, {\em term patterns} are used to guide composition and
decomposition.  Such term patterns play the same role as format
strings in the printf/scanf paradigm in C.  In first approximation, a
term pattern is a literal string that would be obtained by a preorder
traversal of a term.  For instance, the term pattern {\tt "or(true,
false)"}, corresponds to a term whose root is labeled with the symbol
{\tt or}, and whose children are labeled with, respectively, {\tt
true} and {\tt false}. In this way, term patterns can be used to
construct and to match terms.

Term patterns become, however, much more useful if they can be parameterized
with subterms that have been computed separately.
To this end, we introduce the notion of {\em directives} as follows:

\begin{description}
\item[{\tt <int>}]: corresponds to an integer (in C: {\tt int});
\item[{\tt <str>}]: corresponds to a string (in C: {\tt char *});
\item[{\tt <blob>}]: corresponds to a binary string (in C: a (length, pointer) pair 
represented by two values of types, respectively, {\tt int} and {\tt void *});
\item[{\tt <term>}]: corresponds to an aterm (in C: {\tt ATerm });
\item[{\tt <appl>}]: corresponds to one function application(in C: {\tt char *pattern}, followed by arguments);
\item[{\tt <list>}]: corresponds to a list of terms (in C: {\tt ATerm}).
\end{description}

The precise interpretation of these directives depends on the context
in which they are used.  When constructing a term, directives indicate
that a subterm should be obtained from some given variable.  When
matching a term, directives indicate the assignment of subterms to
given variables.
For the implications of these directives for memory management,
see Section~\ref{Memory}.

\subsubsection{\label{ATmake}{\tt ATmake}}
The function
\begin{verbatim}
      term *ATmake(char *Pattern, ...)
\end{verbatim}
constructs a term according to {\tt Pattern}, where occurrences of
directives are replaced by the values of the variables
occurring in {\tt ...}.

For instance, assuming the declarations
\begin{verbatim}
      int n = 10;
      char *fun = "pair", name = "any";
      ATerm yellow = ATmake("yellow"), t;
\end{verbatim}
the call
\begin{verbatim}
      t = ATmake("exam(<appl(<term>,9)>,<int>,<str>)", fun, yellow, n, 10, name)
\end{verbatim}
will construct the term {\tt t} with value
\begin{verbatim}
      exam(pair(yellow,9),10,10,"any")
\end{verbatim}

Binary strings (\emph{Binary Large OBjects} or \emph{blob\/}s) are used to represent arbitrary length, binary data
that cannot be represented by ordinary C strings because they may
contain ``null'' characters. A binary string is represented by
a character pointer and a length. For instance, given
\begin{verbatim}
      char buf[12];
      ATerm bstr;
      buf[0] = 0; buf[1] = 1; buf[2] = 2;
\end{verbatim}
the call
\begin{verbatim}
      bstr = ATmake("exam(<blob>)", 3, buf);
\end{verbatim}
will construct a term with function symbol ``{\tt exam}'' and as single
argument a binary string of length {\tt 3} consisting of the three
values {\tt 0}, {\tt 1}, and {\tt 2}.

\subsubsection{\label{ATmatch}{\tt ATmatch}}
Matching terms amounts to
\begin{itemize}
\item determining whether there is a match or not,
\item selectively assigning matched subterms to given variables.
\end{itemize}

\noindent This is precisely what the function
\begin{verbatim}
      ATbool ATmatch(ATerm Trm, const char *Pattern, ...)
\end{verbatim}
does. It matches {\tt Trm} against {\tt Pattern} and, when a submatch
is found that corresponds to a directive, it makes assignments to
variables whose addresses appear in {\tt ...}.
For most directives, the values assigned to these variables are pointers to
subterms of {\tt Trm}.
{\tt Pattern} should
be a well-formed, textual representation of a term which may contain
any of the directives described earlier.  For instance, in the context
\begin{verbatim}
      ATerm t = ATmake("exam(pair(yellow,9),10, \"any\")");
      ATerm t1;
      int n;
      char *ex, *s;
\end{verbatim}
the call 
\begin{verbatim}
      ATmatch(t, "appl(<term>,<int>,<str>)", &ex, &t1, &n, &s);
\end{verbatim}
yields true and is equivalent to the following assignments:
\begin{verbatim}
      ex = "exam";
      t1 = ATmake("pair(yellow,9)");
      n = 10;
      s = "any";
\end{verbatim}
As explained in full detail in Section~\ref{Memory}, memory is managed
automatically by the ATerm library.  As a general rule, the values for {\tt ex},
{\tt t1}, and {\tt s} are pointers into the original term {\tt t}
rather than newly created values. As a result, they have a life time
that is equal to that of {\tt t}.

Matching binary strings is the inverse of constructing them. Given
the term {\tt bstr} constructed at the end of the previous paragraph,
its size and contents can be extracted as follows:
\begin{verbatim}
      int n;
      char *p;

      ATmatch(bstr, "exam(<blob>)", &n, &p);
\end{verbatim}
{\tt ATmatch} will succeed and will assign {\tt 3} to the variable
{\tt n} and will assign a pointer to the character data in the binary
string to the variable {\tt p}.

Here, again, the value of {\tt p} is a pointer into the term {\tt bstr}
rather than a newly allocated string.

\paragraph{Notes}
\begin{itemize}
\item Double quotes (``{\tt "}'') appearing {\em inside} the pattern argument
of both {\tt ATmake} and {\tt ATmatch} have to be escaped using ``\verb-\"-''.
\item The number and type of the variables whose addresses appear
as arguments of {\tt ATmatch} should correspond, otherwise disaster
will strike (as usual when using C).
\item Assignments are being made during matching. As a result, some assignments
may be performed, even if the match as a whole fails.

\end{itemize}

\subsubsection{\label{ATermIO}Input and output of ATerms}
We make a distinction between the ``raw'' input and output of terms
as they are, for instance, being sent through communication
channels between \TB\ and tools, versus formatted input and output
of terms. Raw term i/o is provided by {\tt TBwrite} and {\tt TBread}.
Formatted term output is provided by {\tt TBprintf} and {\tt TBsprintf}.
There are currently no primitives for formatted term input.

\subsubsection{\label{ATread/write}Reading and writing ATerms}

ATerms can be read from and written to strings and files.
Two formats are supported: a human-readable but verbose textual format
and a very concise binarry format. Here we only discuss the textual
variant.

The function
\begin{verbatim}
      void ATwriteToTextFile(ATerm Trm, FILE *File)
\end{verbatim}
writes ATerm {\tt Trm} to the file {\tt File}.
For instance, in the context:
\begin{verbatim}
      FILE *f = fopen("foo", "wb");
      ATerm Trm1 = ATmake("<appl(red,<int>)>", "freq", 17);
\end{verbatim}
the statement
\begin{verbatim}
      ATwriteToTextFile(Trm1, f);
\end{verbatim}
will write the value of {\tt Trm1} (i.e., {\tt freq(red,17)})
to file ``{\tt foo}''.

The function
\begin{verbatim}
      ATerm ATreadFromFile(FILE *File)
\end{verbatim}
is the inverse of {\tt ATwriteToFile}: it reads a term (either in textual format or in internal format)
from a file and returns it as value. When end of file is encountered
or the term could not be read, the operation is aborted.\footnote{The user can redefine this behaviour
using {\tt ATsetAbortHandler}, which allows the definition of a user-defined abort handler.
See the \emph{ATerm Library User Manual} for further details.}

\subsubsection{\label{ATprintf}{\tt ATfprintf}}
The function
\begin{verbatim}
      int ATfprintf(FILE *File, const char *Pattern, ...)
\end{verbatim}
writes formatted output to {\tt File}.
{\tt Pattern} is printed literally except for occurrences
of directives which are replaced by the textual representation
of the values appearing in {\tt ...}. For instance,
\begin{verbatim}
      ATfprintf(stderr, "Wrong event \"%t\" ignored\n", ATmake("failure(<int>)", 13));
\end{verbatim}
will print:
\begin{verbatim}
Wrong event "failure(13)" ignored
\end{verbatim}

Note that {\tt ATprintf} uses the normal {\tt printf} conversion
specifiers extended with aterm-specific specifiers. The most
frequently used specifier is {\tt \%t} which stands for an aterm
argument whose textual representation is to be inserted in the output
stream.


\subsubsection{\label{ATermManipulation}Further ATerm manipulation functions}

The ATerm library acutally provides two interfaces:

\begin{itemize}

\item The level 1 interface: a simple but expressive interface as just sketched.

\item The level 2 interface: a more detailed interface that allows the
very efficient coding of operations on ATerms. We will not further
discuss here the level 2 interface.

\end{itemize}

\subsubsection{\label{Memory}Memory Management of ATerms}
The functions in the ATerm library provide automatic memory management
of terms.  Terms that have been created but are no longer referenced
are removed by a method called {\em garbage collection}.  The global
model is that there is a set of {\em protected} terms that are
guaranteed to survive a garbage collection.  Effectively, all
protected terms (and their subterms) are conserved and all other terms
are considered as garbage and can be collected.

It is guaranteed that no garbage collection takes place during
the execution of an event handler, hence it is not necessary to
protect temporary terms that are constructed during the execution
of an event handler.
However, terms that should have a longer life time must be protected
in order to survive.

In order to protect terms from being collected, the function
\begin{verbatim}
      void ATprotect(ATerm *TrmPtr)
\end{verbatim}
can be used that has as single argument {\em a pointer to a variable
with an ATerm  as value}. The protection can be undone
by the function
\begin{verbatim}
      void ATunprotect(ATerm *TrmPtr)
\end{verbatim}

The interplay between garbage collection and program variables
is subtle. The following points are therefore worth  mentioning:

\begin{itemize}

\item Functions that return a term as value (e.g., {\tt TBreadTermfromFile}) 
do not explicitly protect it but the result may, of course, be
protected because it is a subterm of an already protected term.

\item The function {\tt ATmake} uses strings and terms and includes
them into a new term $T$. The implications for memory management are:
\begin{itemize}
\item All string arguments (using {\tt <str>}, {\tt <blob>} or {\tt <appl>})
are copied before they are included into $T$.
They can thus safely be deallocated (e.g., using {\tt free}) by the C program.

\item All term arguments (using {\tt <term>}) are included
into $T$ by means of a pointer.
They thus become reachable from $T$ and
their life time becomes at least as large as that of $T$;
it is unnecessary to explicitly protect them.
\end{itemize}

\item The function {\tt ATmatch} assigns strings and terms to program variables
by extracting them from an existing term $T$. The general rule here is that
extracted values have a life time that is equal to that of $T$.
The implications for memory management are:
\begin{itemize}
\item All string values (obtained using {\tt <str>}, {\tt <blob>} or {\tt <appl>})
should be copied if they should survive $T$.
\item All term values (obtained using {\tt <term>}) should
be explicitly protected if they should survive $T$.
\end{itemize}

\end{itemize}


\subsubsection{Initializing and using the ATerm library}\label{ATinit}

Using the ATerm library requires the following:

\begin{itemize}
\item Include the header file {\tt aterm1.h} (or {\tt aterm2.h} if you want to
use the level 2 interface). {\tt aterm1.h} defines:
   \begin{itemize}
   \item {\tt ATbool}: the boolean data type defined by
\begin{verbatim}
      typedef enum ATbool {ATfalse=0, ATtrue} ATbool;
\end{verbatim}
It is mainly used as the return value of library functions.

\item {\tt ATerm}: the type definition of ATerms. The ATerm library has been
  designed in such a way that only pointers to terms must be passed to or are
  returned by library functions. The primitives that are provided for
  constructing and decomposing terms are of such a high level that it is
  unnecessary to know the internal representation of terms.  When necessary,
  you can access the internal structure of ATerms using the level 2 interface.
  \end{itemize}

\item Declare in your {\tt main} program a local ATerm variable
that will be used to determine the bottom of C's runtime stack.
\item Call {\tt ATinit} to initialize the ATerm library.
\item Link the ATerm library {\tt libATerm.a} when compiling your application.
This is achieved using the {\tt -lATerm} option of the C compiler.
\end{itemize}

\noindent A typical usage pattern is as follows:

\begin{verbatim}
      #include <aterm1.h>
      int main(int argc, char *argv[])
      {
        ATerm bottomOfStack;
        ATinit(argc, argv, &bottomOfStack);
       /* ... code that uses ATerms ... */
      }
\end{verbatim}


\subsection{\label{GlobalStructureTool}The global structure of a \TB\ tool}

\begin{figure}[tb]
\rule{\textwidth}{0.5mm}
  \input{Tool.tex}
  \centerline{\box\graph}
  \caption{Global organization of a tool}
  \label{fig:Tool}
\rule{\textwidth}{0.5mm}
\end{figure}

In its simplest form, a tool is a box connected via an input and an output port to a \TB.
In the most general case, a tool has
\begin{itemize}

\item one input port from the \TB\ to the tool and
can receive tree structures (terms) via this port;

\item one output port from the tool to the \TB\ and
can  send terms to the \TB\ via this port;

\item zero or more {\em term ports} to receive terms from other sources;

\item zero or more {\em character ports} to receive character data
from other sources.
\end{itemize}

This global, architectural, structure of a tool is shown in Figure~\ref{fig:Tool}.
With each input port, an {\em event handler} is associated that takes care
of the processing of the data received via that port and is responsible
for returning a result (if any). One tool may thus contain several event handlers.
When a request is received, the following steps
are taken:
\begin{itemize}
\item The data received are parsed to check that they form a legal \TB\ term $T$.
(If this is impossible, a warning message is generated).
\item The event handler is called with $T$ as argument.
\item The event handler can do arbitrary processing needed to decompose
$T$, to determine what has to be done, and perform any desired computation.
\item The event handler returns either:
\begin{itemize}
\item a legal \TB\ term representing a reply to be sent back to the \TB.
\item {\tt NULL} indicating that there is no reply.
\end{itemize}
\end{itemize}

The global mode of operation of a tool is now:
\begin{itemize}
\item receive data on any input port and respond to this
by sending some term (or {\tt NULL}) to the \TB; or
\item take the initiative to send a term to the \TB\ (typically to inform
the \TB\ about some external event).
\end{itemize}

A tool is thus on the one hand a reactive engine that responds to a
request from the \TB\ and returns the result back to the \TB\ in the
form of a term (e.g., calculate the value of some expression), but on
the other hand it can also take the initiative to send a term to the
\TB\   (e.g., generate an event when a user pushes some button).

At the level of the source code, the global structure of a purely
reactive tool without additional term or character ports
has already
been illustrated in Figure~\ref{fig:hello.c}.

\subsubsection{The include file {\tt atb-tool.h}}

Each tool needs to include the file {\tt atb-tool.h}
which defines some basic types as well as the set
of library functions available.
It consists of
\begin{itemize}
\item An include of {\tt <aterm1.h>}.
\item Defines {\tt ATBhandler}: the type of event handlers.
\item Defines the prototypes of all library functions
\end{itemize}

\subsubsection{The tool library {\tt libATB.a}}

When compiling tools, the library {\tt libATB.a} must be specified in order to
make the tool library available (using the {\tt -lATB} option of the C
compiler). It provides the following functions\footnote{For an
  exhaustive description, see H. A. de Jong and P. A. Olivier, ``ATerm Library
  User Manual''}:

\begin{itemize}
\item {\tt ATBinit}: tool initialization (Sections~\ref{ATBinit}).

\item {\tt ATBconnect}: to connect the tool to the \TB\
  (Sections~\ref{ATBconnect}).

\item {\tt ATBdisconnect}: to disconnect the tool from the \TB\ (Sections~\ref{ATBconnect}).

\item {\tt ATBeventloop}: a standard event loop for a tool
  (Section~\ref{ATBeventloop}).

\item {\tt ATBreadTerm}: process one input event on a port (Section~\ref{ATBreadTerm}).

\item {\tt ATBwriteTerm}: send a term to the \TB\ (Section~\ref{ATBreadTerm}).

\end{itemize}

In the following section, we will describe these functions.


\subsection{\label{ToolBusAPI}The \TB\ API}

During the initialization of each tool, some preparations have to made
before the tool can be properly connected to the \TB. These preparations
include
\begin{itemize}
\item Defining the {\em name} of the tool as it is known from a tool declaration
in a \T\ script.
\item Parsing standard program arguments that are passed to the tool
when it is started.
\item Creating a pair of socket connections with a \TB\ interpreter.
\item Starting an event loop.
\end{itemize}

During execution of the event loop, the tool can either \emph{receive} terms from
the \TB\ or it can take the initiative to \emph{send} terms to the \TB.
It is thus possible for a tool to both respond to \TB\ requests
and \emph{asynchronously} send terms to the \TB.

\subsubsection{\label{ATBinit}{\tt ATBinit}}

The initialization of a tool is achieved by
\begin{verbatim}
      ATBinit(int argc, char *argv[], ATerm *bottomOfStack).
\end{verbatim}

The standard program arguments that are passed (via {\tt argc} and {\tt argv})
are fully described in Section~\ref{Executing}. Particularly important is that
the tool is initialized with a proper name.  It should be literally equal
(including the case of letters) to a tool name as appearing in a tool
declaration in the \T\ script. This is important since the tool name will be
used when the tool is connected to the \TB. Note that {\tt ATBinit} also
initializes the ATerm library (hence the {\tt bottomOfStack} argument, see Section
\ref{ATinit}).

\subsubsection{\label{ATBconnect}{\tt ATBconnect} and {\tt ATBdisconnect}}

A tool can be connected to the ToolBus using {\em term ports} that can be
using for sending and receiving data in the form of complete terms.  Two
aspects of term ports are important: the input channel used for the actual
data transfer and the {\em handler} that takes care of processing input terms
when they arrive. The connection is established as follows:

\begin{verbatim}
      int ATBconnect(char *toolname, char *host, int port, ATBhandler h);
\end{verbatim}

Here, {\tt toolname} is the tool name to be used, {\tt host} is the machine
where the \TB\ is executing, {\tt port} is the file descriptior of the channel
to be used, and {\tt h} is the handler to associated with this connection.  If
value {\tt NULL} is passed as {\tt toolname} or {\tt host}, default values are
used that are taken from {\tt argv}.  The same is true when {\tt -1} is passed
as value for {\tt port}. The return value of {\tt ATBconnect} is either {\tt
  -1} (failure) or a positive number (the connection succeeded and the result
is the file descriptor of the resulting socket connection with the \TB).

Handlers for term ports are functions from ATerm to ATerm and have the
type:
\begin{verbatim}
      ATerm some_handler(int conn, ATerm input)
\end{verbatim}
The argument {\tt conn} is the connection along which the
input term was received and {\tt input} is the actual term received.
The term retruned by the handler is the reply to be sent  to the \TB\ in response
to this input event, or {\tt NULL} if no reply is needed.

In this fashion, an arbitrary number of term input ports can be set up which
will be read in parallel: as soon as a term arrives at one of the ports
the associated handler is activated.

A connection can be terminated as follows:
\begin{verbatim}
      void ATBdisconnect(int conn)
\end{verbatim}
where {\tt int} is a previously created connection.

\subsubsection{\label{ATBeventloop}{\tt ATBeventloop}}
Many tools first establish a number of term ports
and then enter an infinite loop that processes input events.
The function
\begin{verbatim}
      int ATBeventloop(void)
\end{verbatim}
captures this idea. It never returns, unless something goes wrong.
We can now give a skeleton that many tools have in common:

\begin{verbatim}
      #include "my_tool.tif.c"

      ATerm my_tool_handler(int conn, ATerm input)
      { ... handle input and return a term or NULL ...  }

      int main(int argc, char *argv[]) 
      { ATerm bottomOfStack;

        ATBinit(argc, argv, &bottomOfStack);
        if(ATBconnect(NULL, NULL, -1,  my_tool_handler) >= 0)
        {
           ATBeventloop();
        } else 
           fprintf(stderr, "my_tool: Could not connect to the ToolBus, giving up!\n");
        ATBeventloop();
        return 0; 
      }
\end{verbatim}


\subsubsection{\label{ATBreadTerm}{\tt ATBwriteTerm} and {\tt ATBreadTerm}}
So far, we have seen primitives for tools that only receive
terms from the \TB. In the case of, for instance,
events that are generated by a tool, a term needs to be sent from the tool
to the \TB. This can be achieved using
\begin{verbatim}
      int ATBwriteTerm(int conn, ATerm term)
\end{verbatim}
which sends {\tt term} along the port {\tt conn}. Failure is indicated by the
return value {\tt -1}. A typical usage is:
\begin{verbatim}
      ATBwriteTerm(conn, ATmake(snd-event(button("ok")).
\end{verbatim}

Symmetrically, a term can be read from a \TB\ connection as follows:
\begin{verbatim}
      ATerm ATBreadTerm(int conn).
\end{verbatim}

\subsubsection{\label{AdvancedControl}Advanved control flow}

Tool programming amounts, in essence, to event driven programming: most of the time
a tool is awaiting the arrival of data on one of its
ports and when the data are there, a reply is sent to the \TB\ by the
handler associated with that port.

In computation-intensive tools, the need may arise to
check for the availability of incoming data from the \TB\ during
computations. This is achieved by the function
\begin{verbatim}
      ATbool ATBpeekOne(int conn)
\end{verbatim}
which returns {\tt ATtrue} if incoming data from the \TB\ are available
on the connection {\tt conn}.

Similarly, the availability of data on \emph{any} connection may be checked
by:
\begin{verbatim}
      int ATBpeekAny(void)
\end{verbatim}
If input is waiting, the appropriate connection is returned. Otherwise {\tt
  -1} is returned.

The sequence of activities needed for handling (once) the data available from
a specific connection is captured by the function
\begin{verbatim}
      void ATBhandleOne(int conn)
\end{verbatim}
This amounts to calling the handler associated with connection {\tt conn}
with the available data as input term.

Similarly, the data from \emph{any} connection is handled by
\begin{verbatim}
      void ATBhandleAny(void)
\end{verbatim}

The function {\tt ATBeventloop} can be expressed with the primitives just
introduced:

\begin{verbatim}
      int ATBeventloop(void)
      { int conn;

        while(ATtrue)
        {
           n  = ATBhandleAny();
           if(n < 0)
             return -1;
        }
      }
\end{verbatim}
Another style mixes the handling of input from the \TB, with other
computations:
\begin{verbatim}
        while(ATtrue)
        { 
          if(n = ATBpeekAny() >= 0)      /* if there is an incoming event */
            ATBhandleOne(n);             /* handle it                     */
          else {
             ...                         /* perform other computation     */
          }
        }
\end{verbatim}

In some tools, a mixture of passively awaiting input
and actively sending terms to the \TB\ can be seen.

Using {\tt ATBwriteTerm}, the most general global event loop of a tool becomes:

\begin{verbatim}
      while(ATtrue)
      {
        ... ATBwriteTerm(c1,e1); ...; ATBwriteTerm(cn,en); ...
        ATBhandleAny();
      }
\end{verbatim}

In other words, each iteration starts by sending zero or more terms
to the \TB\ (using {\tt ATBwriteTerm}) and ends with processing one event
coming from some port (using {\tt ATBhandleAny}).  The \T\ script being used
should, of course, be able to receive such events.

\subsection{\label{CompilingTools}Compiling \TB\ tools written in C}
When compiling a tool written in C the following questions
should be answered:
\begin{itemize}
\item Where is the include file {\tt aterm1.h}?
\item Where is the include file {\tt atb-tool.h}?
\item Where is the ATerm library {\tt libATerm.a}?
\item Where is the \TB\ API library {\tt libATB.a}?
\item Which other libraries are needed to compile the tool?
\end{itemize}

The answers to these questions are clearly system dependent.
There are two strategies to answer them.

\paragraph{Strategy 1:} find the desired locations on your system and hard code them in
the compilation command. This will lead to a call to the C compiler
with the following arguments:

\begin{itemize}
\item {\tt -I}\emph{dir-where-aterm1.h-is}
\item {\tt -I}\emph{dir-where-ATB-tool.h-is}
\item {\tt hello.c -o hello}
\item {\tt -L}\emph{dir-where-libATerm.a-is}

\item {\tt -lATerm}
\item {\tt -L}\emph{dir-where-libATB.a-is}
\item {\tt -lATB}
\item \emph{other libraries}.
\end{itemize}

\paragraph{Strategy 2:}  write a make file that encodes this information.
As a result, the location information is hardwired in the make file
rather than in a command that has to be repeated over and over again.

\begin{figure}[h]
\rule{\textwidth}{0.5mm}
  \input{Tifs.tex}  
  \centerline{\box\graph}
  \caption{Automatic generation of tool interfaces.}
  \label{fig:Tifs}
\rule{\textwidth}{0.5mm}
\end{figure}

\subsection{\label{tifstoc}Generating C tool interfaces with {\tt tifstoc}}

The interface code for each tool depends on the particulars
of the \T\ script in which it is used. Changing the number
of arguments in an evaluation request to the tool,
or adding a new request, requires making changes to the interface
code that are easily forgotten and therefore error prone.

As already mentioned in Section~\ref{Hello}, another observation
is that the interface code for different tools has a lot in common.

An obvious solution to both problems is to {\em generate}
tool interfaces automatically, given a \T\ script.
This generation process is shown in Figure~\ref{fig:Tifs}
and consists of two steps:

\begin{itemize}
\item Generate a language-independent
description of all tool interfaces used in the script.
This amounts to a static analysis of all tool communication
in the script. It is achieved by using the ``{\tt -gentifs}''
option of the \TB\ interpreter. For instance,
\begin{verbatim}
      toolbus -gentifs hello2.tb
\end{verbatim}
will create a file {\tt hello2.tifs} containing the tool interfaces.

\item Use the language independent interface description
to generate a tool interface for a specific tool in a specific
implementation language. The generator {\tt tifstoc}\footnote{
This is an ATerm-compatible version of a similar generator called {\tt ctif}.
{\tt ctif} is still in use for some older tools but will be gradually phased out.}
exists for generating C tool interfaces. It is called as follows:
\begin{quote}
      {\tt tifstoc -tool $Name  $ $TifsFile$}
\end{quote}
and generates a file named {\tt $Name$.tif.c}.
For the hello example, we would have, for instance:
\begin{verbatim}
      tifstoc -tool hello hello2.tifs
\end{verbatim}
%The resulting file {\tt hello.tif.c} is shown in
%Figure~\ref{fig:hello.tif.c}.
\end{itemize}

%\begin{figure}[tb]
%\rule{\textwidth}{0.5mm}
%\input{hello.tif.c.tex}
%  \caption{{\tt hello.tif.c}: generated tool interface {\tt hello.tif.c}.}
%  \label{fig:hello.tif.c}
%\rule{\textwidth}{0.5mm}
%\end{figure}

In Figure~\ref{fig:Tifs} it is also shown how tool interface generators for
{\em other} languages (e.g., Java, Cobol) fit into this scheme.  In addition
to {\tt tifstoc}, we alo support the generation of Java interfaces by way of
{\tt javatif} (See Section~\ref{ToolsInJava}).

\input{adapters}

\section*{Acknowledgements}
Hayco de Jong and Pieter Olivier made major contributions to the
documentation of the \TB\ in their ``Aterm Library User Manual''.
Information from that manual has been used in this guide as well.
Simon Gray and Mark van den Brand commented on drafts of this guide.

\appendix


\newpage
\section{Incompatibilities with older \TB\ versions}

\subsection{Include files, Libraries and API's}

In older versions, tools had to include the file {\tt TB.h}.
Currently, this is {\tt atb-tool.h}.

In older versions, the \TB\ API was provided by {\tt libTB}.  Currently, this
is split over to libraries: {\tt libATerm.a} (the ATerm functions) and {\tt
  libATB.a} (the \TB\ API).
As a consequence, older tools have to be compiled with the compiler flag {\tt
  -lTB}.

In the older API's, all functions begin with the prefix {\tt TB}.  Currently,
functions begin with either {\tt AT} (ATerms) or {\tt ATB} (\TB\ API).

The old and the new API's can be compared as follows:

\begin{center}
\begin{tabular}{|l|l|} \hline
Old                & New \\ \hline \hline

{\tt TBinit}       & {\tt ATinit}\\
{\tt TBmake}       & {\tt ATmake}\\
{\tt TBmatch}      & {\tt ATmatch}\\
{\tt TBwrite}      & {\tt ATwriteTerm}\\
{\tt TBread}       & {\tt ATreadTerm}\\
{\tt TBreadTerm}   & ---\\
{\tt TBprintf}     & {\tt ATprintf}\\
{\tt TBsprintf}    & {\tt ATsprintf}\\
{\tt TBprotect}    & {\tt ATprotect}\\
{\tt TBunprotect}  & {\tt ATunprotect}\\
{\tt TBcollect}    & ---\\ \hline

{\tt TBinit}       & {\tt ATBinit}\\
---                & {\tt ATBconnect}\\
---                & {\tt ATBdisconnect}\\

{\tt TBaddTermPort}& ---\\
{\tt TBaddCharPort}& ---\\
{\tt TBreceive}    & {\tt ATBreadTerm}\\
{\tt TBsend}       & {\tt ATBwriteTerm}\\
{\tt TBeventloop}  & {\tt ATBeventloop}\\
{\tt TBpeek}       & {\tt ATBpeekAny}\\
                   & {\tt ATBpeekOne}\\
---                & {\tt ATBhandleOne}\\
---                & {\tt ATBhandleAny}\\
---                & {\tt ATBgetDescriptors}\\ \hline
\end{tabular}
\end{center}

In addition, the new API's provide other functions taht are not listed in this
table.

\section{Limitations/extensions current implementation}

The current implementation is a faithful implementation of the
system described in ``The Discrete Time \TB''. There are some
minor differences that are summarized here.

\paragraph{Extensions}
\begin{itemize}
\item The types {\tt <bstr>} and {\tt <real>}.
\item The atomic actions {\tt printf} and {\tt read}.
\end{itemize}

\paragraph{Limitations}
\begin{itemize}
\item Certain functions in expressions have not yet been implemented
(see Appendix~\ref{AppExpr}).

\item The atomic actions {\tt attach-monitor}, {\tt detach-monitor},
and {\tt reconfigure} have not yet been implemented.
\end{itemize}

\newpage
\section{The syntax of \T\ scripts}
\subsection{Preprocessor directives}

The $script\_name$ given as argument to the \TB\ is always
preprocessed by the C preprocessor before it is parsed as \T\ script.
In this way, directives like, e.g., {\tt \#define}, {\tt \#include} and
{\tt \#ifdef} can be used freely in \T\ scripts. We summarize the
most frequently used directives:
\begin{itemize}
\item {\tt \#define {\em identifier} {\em token-sequence}} causes
the preprocessor to replace all occurrences of {\em identifier}
by {\em token-sequence}.
\item {\tt \#define {\em identifier} ( {\em identifier-list} ) {\em token-sequence}} is
a macro definition with parameters given by {\em identifier-list}.
Textual occurrences of the identifier followed by an argument list
containing an appropriate number of tokens separated by comma's
will be replaced by {\em token-sequence} after parameter substitution.
\item {\tt \#include "{\em filename}"} will be replaced by the
entire contents of the named file.
\item {\tt \#if}, {\tt \#ifdef}, and {\tt \#ifndef} can be used for
the conditional incorporation or exclusion of parts of a script.
\end{itemize}

\noindent We refer to any ANSII C manual for a detailed description of these
directives. 

See Section~\ref{TB-args} for a description
of the preprocessor related arguments {\tt -I$dir$}, {\tt -D$macro$}, and
{\tt -D$macro$=$defn$} of the {\tt toolbus} command.

\subsection{Context-free syntax}
\input{Syntax-T-scripts.tex}
  
\newpage
\section{\label{AppExpr}Expressions in \T\ scripts}

\subsection{Boolean and arithmetic functions}

\begin{tabular}{|l|l|p{8cm}|} \hline
 Function                       & Result type   & Description \\ \hline
 {\tt not(<bool>$_1$)}          & {\tt  <bool>} & {\tt $\neg$ <bool>$_1$}\\
 {\tt and(<bool>$_1$,<bool>$_2$)}       & {\tt  <bool>} & {\tt <bool>$_1$ $\wedge$ <bool>$_2$} \\
 {\tt or(<bool>$_1$,<bool>$_2$)}        & {\tt  <bool>} & {\tt <bool>$_1$ $\vee$ <bool>$_2$} \\ \hline
 {\tt equal(<term>$_1$, <term>$_2$)}    & {\tt  <bool>} & {\tt <term>$_1$ $\equiv$ <term>$_2$}; for lists multi-set equality\\ 
 {\tt not-equal(<term>$_1$, <term>$_2$)}& {\tt  <bool>} & {\tt not(equal(<term>$_1$, <term>$_2$))}\\ \hline
 {\tt add(<int>$_1$,<int>$_2$)}         & {\tt  <int>}  & {\tt <int>$_1$ $+$ <int>$_2$} \\ 
 {\tt sub(<int>$_1$,<int>$_2$)}         & {\tt  <int>} & {\tt <int>$_1$ $-$ <int>$_2$} \\ 
 {\tt mul(<int>$_1$,<int>$_2$)}         & {\tt  <int>} & {\tt <int>$_1$ $\times$ <int>$_2$} \\ 
 {\tt div(<int>$_1$,<int>$_2$)}         & {\tt  <int>} & {\tt <int>$_1$ $/$ <int>$_2$} \\ 
 {\tt mod(<int>$_1$,<int>$_2$)}         & {\tt  <int>} & {\tt <int>$_1$ {\bf mod} <int>$_2$} \\
 {\tt abs(<int>$_1$)}                   & {\tt  <int>} & absolute value $|$ {\tt <int>$_1$} $|$ \\

 {\tt less(<int>$_1$,<int>$_2$)}        & {\tt  <bool>} & {\tt <int>$_1$ $<$ <int>$_2$} \\ 
 {\tt less-equal(<int>$_1$,<int>$_2$)}  & {\tt  <bool>} & {\tt <int>$_1$ $\leq$ <int>$_2$} \\ 
 {\tt greater(<int>$_1$,<int>$_2$)}     & {\tt  <bool>} & {\tt <int>$_1$ $>$ <int>$_2$} \\ 
 {\tt greater-equal(<int>$_1$,<int>$_2$)}& {\tt  <bool>} & {\tt <int>$_1$ $\geq$ <int>$_2$} \\ \hline

 {\tt radd(<real>$_1$,<real>$_2$)}      & {\tt  <real>}  & {\tt <real>$_1$ $+$ <real>$_2$} \\ 
 {\tt rsub(<real>$_1$,<real>$_2$)}      & {\tt  <real>} & {\tt <real>$_1$ $-$ <real>$_2$} \\ 
 {\tt rmul(<real>$_1$,<real>$_2$)}      & {\tt  <real>} & {\tt <real>$_1$ $\times$ <real>$_2$} \\ 
 {\tt rdiv(<real>$_1$,<real>$_2$)}      & {\tt  <real>} & {\tt <real>$_1$ $/$ <real>$_2$} \\
 {\tt rabs(<real>$_1$)}                 & {\tt  <real>}  & absolute value $|${\tt <real>}$_1 |$ \\
 {\tt rless(<real>$_1$,<real>$_2$)}     & {\tt  <bool>} & {\tt <real>$_1$ $<$ <real>$_2$} \\ 
 {\tt rless-equal(<real>$_1$,<real>$_2$)}& {\tt  <bool>} & {\tt <real>$_1$ $\leq$ <real>$_2$} \\ 
 {\tt rgreater(<real>$_1$,<real>$_2$)}  & {\tt  <bool>} & {\tt <real>$_1$ $>$ <real>$_2$} \\ 
 {\tt rgreater-equal(<real>$_1$,<real>$_2$)}& {\tt  <bool>} & {\tt <real>$_1$ $\geq$ <real>$_2$} \\ \hline
 {\tt sin(<real>$_1$)}                  & {\tt  <real>}  & $sin(${\tt <real>}$_1)$ \\ 
 {\tt cos(<real>$_1$)}                  & {\tt  <real>}  & $cos(${\tt <real>}$_1)$ \\ 
 {\tt atan(<real>$_1$)}                 & {\tt  <real>}  & $tan^{-1}(${\tt <real>}$_1)$ in range $[-\pi/2, \pi/2]$ \\ 
 {\tt atan2(<real>$_1$, <real>$_2$)}    & {\tt  <real>}  & $tan^{-1}(${\tt <real>}$_1 / ${\tt <real>}$_2 )$ in range $[-\pi, \pi]$ \\ 
 {\tt exp(<real>$_1$)}                  & {\tt  <real>}  & exponential function $e^{\mbox{{\tt <real>}}_1}$ \\ 
 {\tt log(<real>$_1$)}                  & {\tt  <real>}  & natural logarithm $ln(${\tt <real>}$_1)$, 
                                                           {\tt <real>}$_1 > 0$  \\ 
 {\tt log10(<real>$_1$)}                & {\tt  <real>}  &  base 10 logarithm $log_{10}(${\tt <real>}$_1)$,
                                                           {\tt <real>}$_1 > 0$  \\ 
 {\tt sqrt(<real>$_1$)}                 & {\tt  <real>}  & $\sqrt{\mbox{{\tt <real>}$_1$}}$,
                                                           {\tt <real>}$_1 \geq 0$  \\ \hline
\end{tabular}

\newpage

\subsection{Functions on lists and multi-sets}

\begin{tabular}{|l|l|p{8cm}|} \hline
 Function                       & Result type   & Description \\ \hline
 {\tt first(<list>$_1$)}                & {\tt  <term>}  & first element of {\tt <list>$_1$}; {\tt []} for non-lists\\
 {\tt next(<list>$_1$)}                 & {\tt  <list>}  & remaining elements of {\tt <list>$_1$}; {\tt []} for non-lists \\
 {\tt join(<term>$_1$,<term>$_2$)}      & {\tt  <list>}  & concatenation of {\tt <term>$_1$} and {\tt <term>$_2$};
                                                           for a list argument {\tt <term>$_i$} ($i=1,2$),
                                                           the list elements are spliced into the new list;
                                                           non-list arguments are included as single element of the
                                                           new list. \\
 {\tt size(<list>$_1$)}                 & {\tt  <int>}   & {\tt $|$<list>$_1|$} (number of elements in list)\\ \hline

 {\tt index(<list>$_1$,<int>$_1$)}      & {\tt <term>}   & If {\tt |<list>$_1$|} $\leq$ {\tt <int>$_1$} return the
                                                           {\tt <int>$_1$}th element from {\tt <list>$_1$};
                                                           otherwise {\tt []} and give a warning.\\
 {\tt replace(<list>$_1$,<int$_1$>,<term>$_1$)} & {\tt <list>}   &  If {\tt |<list>$_1$|} $\leq$ {\tt <int>$_1$} replace the
                                                           {\tt <int>$_1$}th element of {\tt <list>$_1$} by 
                                                           {\tt <term>$_1$} and return the modified (and partially
                                                           copied) version of {\tt <list>$_1$};
                                                           otherwise return {\tt <list>$_1$} and give a warning.\\  \hline

 {\tt get(<list>$_1$,<term>$_1$)}       & {\tt <term>}   & If {\tt <list>$_1$} contains a pair
                                                           {\tt [<term>$_1$, <term>$_1'$]} then {\tt <term>$_1'$};
                                                           otherwise {\tt []}.\\
 {\tt put(<list>$_1$,<term>$_1$, <term>$_2$)}   & {\tt <list>}   & If {\tt <list>$_1$} contains a pair
                                                           {\tt [<term>$_1$, <term>$_1'$]} then replace it by
                                                           {\tt [<term>$_1$, <term>$_2$]}; otherwise add a new pair     
                                                           {\tt [<term>$_1$, <term>$_2$]} to {\tt <list>$_1$}. \\ \hline


 {\tt member(<term>$_1$,<list>$_2$)}    & {\tt  <bool>}  & {\tt <term>$_1$ $\in$ <list>$_2$} (membership in multi-set)\\
 {\tt subset(<list>$_1$, <list>$_2$)}   & {\tt  <bool>}  & {\tt <list>$_1$ $\subseteq$ <list>$_2$} (subset on multi-sets)\\
 {\tt diff(<list>$_1$, <list>$_2$)}     & {\tt  <list>}  & {\tt <list>$_1$ $-$ <list>$_2$} (difference on multi-sets)\\
 {\tt inter(<list>$_1$, <list>$_2$)}    & {\tt  <list>}  & {\tt <list>$_1$ $\cap$ <list>$_2$} (intersection on multi-sets)\\ \hline
\end{tabular}

\subsection{Predicates and functions on terms}
\begin{tabular}{|l|l|p{8cm}|} \hline
 Function                               & Result type   & Description \\ \hline
 {\tt is-bool(<term>)}                  & {\tt  <bool>} & If {\tt <term>} is of type {\tt bool} then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-int(<term>)}                   & {\tt  <bool>} & If {\tt <term>} is of type {\tt int} then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-real(<term>)}                  & {\tt  <bool>} & If {\tt <term>} is of type {\tt real} then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-str(<term>)}                   & {\tt  <bool>} & If {\tt <term>} is of type {\tt str} then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-bstr(<term>)}                  & {\tt  <bool>} & If {\tt <term>} is of type {\tt bstr} then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-appl(<term>)}                  & {\tt  <bool>} & If {\tt <term>} is an application then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-list(<term>)}                  & {\tt  <bool>} & If {\tt <term>} is a list then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-empty(<term>)}                 & {\tt  <bool>} & If {\tt <term>} equals {\tt []} then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-var(<term>)}                   & {\tt  <bool>} & If {\tt <term>} is a variable then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-result-var(<term>)}            & {\tt  <bool>} & If {\tt <term>} is a result variable then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt is-formal(<term>)}                & {\tt  <bool>} & If {\tt <term>} is a formal variable then {\tt true};
                                                          otherwise {\tt false}.\\
 {\tt fun(<term>)}                      & {\tt  <str>} & If {\tt <term>} is an application then its function symbol;
                                                          otherwise {\tt ""}.\\
 {\tt args(<term>)}                     & {\tt  <list>} & If {\tt <term>} is an application then its argument list;
                                                          otherwise {\tt []}.\\ \hline
\end{tabular}


\subsection{Miscellaneous functions}

\begin{tabular}{|l|l|p{8cm}|} \hline
 Function                               & Result type   & Description \\ \hline
 {\tt process-id}                       & {\tt  <int>}   & id of current process \\
 {\tt process-name}                     & {\tt  <str>}   & name of current process\\
 {\tt quote(<term>)}                    & {\tt  <term>}  & quoted (unevaluated) term,
                                                           only variables are replaced by their value \\
 {\tt functions}                        & {\tt  <list>}  & list of built-in functions\\ \hline
 {\tt current-time}                     & {\tt <list>}   & six-tuple describing current absolute time\\
 {\tt sec(<int>$_1$)}                   & {\tt <int>}    & convert {\tt <int>$_1$} in seconds \\
 {\tt msec(<int>$_1$)}\dag              & {\tt <int>}    & convert {\tt <int>$_1$} in milli-seconds\\ \hline
\end{tabular}

\vspace{\baselineskip}
\noindent \dag Not yet implemented in the current version
\newpage


\section{Synopsis of primitives available in \T\ scripts}

\begin{center}
\begin{tabular}{|l|l|}
\hline Primitive                & Description                           \\ \hline \hline
\script{delta}                  & inaction (deadlock)                   \\
\script{tau}                    & internal step                         \\
\script{$P_1$+$P_2$}            & choice                                \\
\script{$P_1$.$P_2$}            & sequential composition                \\
\script{$P_1$||$P_2$}           & parallel composition                  \\
\script{$P_1$*$P_2$}            & iteration                             \\
\script{if $T$ then $P$ fi}     & guarded command                       \\
\script{if $T$ then $P_1$ else $P_2$ fi} & conditional                  \\ \hline
\script{create($Pnm$($T$,...), $Pid$?)} & process creation$^1$          \\ \hline
\script{$V$ := $T$}             & assignment, $T$ expression (see~\ref{AppExpr}) \\ \hline
\script{snd-msg($T$,...)}       & send a message (binary, synchronous)  \\
\script{rec-msg($T$,...)}       & receive a message (binary, synchronous)\\
\script{snd-note($T$)}          & send a note (broadcast, asynchronous) \\              
\script{rec-note($T$)}          & receive a note (asynchronous)         \\
\script{no-note($T$)}           & no notes available for process        \\
\script{subscribe($T$)}         & subscribe to notes                    \\
\script{unsubscribe($T$)}       & unsubscribe from notes                \\ \hline
\script{delay($T$)}             & relative time delay of atom           \\
\script{abs-delay($T$,...)}     & absolute time delay of atom$^2$       \\
\script{timeout($T$)}           & relative timeout of atom              \\
\script{abs-timeout($T$,...)}   & absolute timeout of atom$^2$          \\ \hline
\script{rec-connect($Tid$?)}    & receive a connection request from a tool \\
\script{rec-disconnect($Tid$?)} & receive a disconnection request form a tool   \\
\script{execute($Tnm$($T$,...), $Tid$?)}        & execute a tool$^1$            \\
\script{snd-terminate($Tid$, $T$)}& terminate the execution of a tool\\
\script{shutdown($T$)}          & terminate \TB                         \\
\script{reconfigure}            & reconfigure \TB\dag           \\ \hline
\script{attach-monitor}         & attach a monitoring tool to a process\dag      \\
\script{detach-monitor}         & detach a monitoring tool from a process\dag\\ \hline
\script{snd-eval($Tid$, $T$)}   & send evaluation request to tool       \\
\script{snd-cancel($Tid$)}      & cancel an evaluation request to tool\dag \\
\script{rec-value($Tid$, $T$)}  & receive a value from a tool           \\
\script{snd-do($Tid$, $T$)}     & send request to tool (no return value)\\ \hline
\script{rec-event($Tid$, $T$, ...)}& receive event from tool            \\
\script{snd-ack-event($Tid$, $T$)}& acknowledge a previous event from a tool \\ \hline
\script{printf($S$, $T$, ...)}  & print terms (after variable replacement) according to format $S$\\
\script{read($T_1$, $T_2$)}     & give prompt $T_1$, read term, should match with $T_2$ \\ \hline
\script{process $Pnm$($F$, ...) is $P$} & process definition$^3$        \\
\script{let $F$, ... in $P$ endlet} & declare variables in $P$          \\ \hline
\script{tool $Tnm$($F$,...) is \{ $Feat$, ... \}} & tool definition$^3$ \\
\script{host = $Str$}           & host feature in tool definition       \\
\script{command = $Str$}        & command feature in tool definition    \\
\script{details = << $Lines$ >>}& details feature in tool definition    \\ \hline
\script{toolbus($Pnm$($T$,...), ...)} & \TB\ configuration              \\ \hline
\end{tabular}
\end{center}

\newpage

\begin{tabular}{ll}
{\bf Notes}\\
$^1$    &  {\tt ($T$, ...)} is optional\\
$^2$    &  Absolute time described by a 6-tuple ($year$, $month$, $day$, $hour$, $minutes$, $seconds$) \\
        &  with $year \ge 95$, $1 \le month \le 12$, $1 \le day \le 31 $, $0 \le hour \le 23$, $0 \le minutes \le 59$, \\
        &  and $0 \le seconds \le 61$ (seconds can be greater than 59 to allow leap seconds).\\
        &  Absolute time may be abbreviated, by omitting, at most, the first three elements\\
        &  of the 6-tuple. Omitted elements default to their current value.\\
$^3$    &  {\tt ($F$, ...)} is optional\\
\dag    &  Not yet implemented\\
\end{tabular}

\begin{tabular}{ll}
{\bf Legendum}\\
$T$     & term \\
{\tt $T$, ...} & list of terms separated by comma's\\
$V$             & variable\\
$F$             & declaration of formal or local variable of the form {\tt $V$:$Type$}\\
$P$, $P_1$, $P_2$       & process expression \\
$Tid$           & tool identifier, a variable of type $Tnm$ (with $Tnm$ declared as tool name)\\
$Tnm$           & tool name \\
$Pnm$           & process name \\
$Pid$           & process identifier, a variable of type {\tt int}\\
$Str$           & a string constant\\
$Lines$         & list of lines\\
\end{tabular}



\end{document}

