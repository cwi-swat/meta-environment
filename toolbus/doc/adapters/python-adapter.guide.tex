
\section{\label{ToolsInPython}Writing tools in Python}

Writing \TB\ tools in Python is greatly simplified by the {\tt
python-adapter} to be explained in Section~\ref{python-adapter}.
Next, a small Python module is described which is loaded by the
\texttt{python-adapter} and can be used in any Python script
to interface with the adapter (Section~\ref{Python-functions}) .
Finally, we present in Section~\ref{Ex-hello.py} the Python
version of the \texttt{hello} tool.

\subsection{\label{python-adapter}\texttt{python-adapter}}

\subsubsection{Synopsis:} 

Execute a Python interpreter as a tool.

\subsubsection{Example:} 

\texttt{python-adapter -script calculator.py}

\subsubsection{Specific arguments:}

\begin{itemize}
\item \texttt{-help}: Display short help message.
\item \texttt{-python \emph{Name\/}}: Use \emph{Name} rather than {\tt
  python} as Python interpreter.
\item \texttt{-lazy-exec}: Postpone execution of interpreter until 
  needed.
\item \texttt{-script}: The Python script to be executed.
\item \texttt{-script-args $A_1$ \ldots $A_n$}: The arguments for
  the Python script to be executed. These arguments are available
  to the Python script through the variable \texttt{argv}.
\end{itemize}

\subsubsection{Communication:\protect\footnote{Communication is described from the point of view of the \TB, i.e., \texttt{snd-} and \texttt{rec-} mean, respectively, send by \TB\ and receive by \TB.}}

\begin{itemize}
\item \texttt{snd-eval(\emph{ToolId}, \emph{Fun}($A_1$, \ldots,
    $A_n$))}: perform the Python function call \emph{Fun($A_1$,
    \ldots, $A_n$)}. Here \emph{ToolId} is a tool identifier (as
  produced by \texttt{execute} or \texttt{rec-connect}) for an
  instance of the {\tt python-adapter}. A return value has to be send
  by the called function.
\item \texttt{rec-value(\emph{ToolId}, \emph{Res\/})}: receive the
  return value for the previous evaluation request.
\item \texttt{snd-do(\emph{ToolId}, \emph{Fun}($A_1$, \ldots, $A_n$))}:
  perform the Python function call \emph{Fun($A_1$, \ldots, $A_n$)}.
  No return value has to be send by the called function.
\item \texttt{rec-event(\emph{ToolId}, $A_1$, \ldots, $A_n$)}: receive an
  event generated by the Python script.
\item \texttt{snd-ack-event(\emph{ToolId}, $A_1$)}: send
  acknowledgment of a previously generated event.
\item \texttt{snd-terminate(\emph{ToolId}, $A_1$)}: terminate
  execution of the python-adapter (and its script). 
\item \texttt{snd-monitor(\emph{Trm})}: in this case the Python
  function \texttt{monitor\_atom(\emph{ProcId}, \emph{AtFun},
    \emph{Src}, \emph{Blino}, \emph{Bpos}, \emph{Elino}, \emph{Epos})}
  is called where \emph{ProcId} is the process-id of the process to
  which this atom belongs, \emph{AtFun} the action function name of
  the atom (printf, tau, snd-do, snd-eval, rec-msg etc.), \emph{Src}
  the source file where the atom is defined, \emph{Blino} the number
  of the line where the atom starts, \emph{Bpos} the column of the
  line where the atom starts, \emph{Elino} the number of the line
  where the atom ends and \emph{Epos} the column of the line where the
  atom ends (this information can be used for example for
  highlighting a piece of source code). After calling this function
  the term is further analyzed, possibly resulting in (several) other
  Python function calls. The following situations are considered:
  \begin{itemize}
  \item \emph{process creation}: then
    \texttt{create\_proc(\emph{ProcId}, \emph{ProcName})} is
    called.
  \item \emph{tool creation}: then \texttt{create\_tool(\emph{ToolId},
      \emph{ToolName})} is called.
  \item \emph{process to tool communication}: then  
    \texttt{proc\_tool\_comm(\emph{ToolId}, \emph{ProcId})} is
    called.
  \item \emph{tool to process communication}: then  
    \texttt{tool\_proc\_comm(\emph{ProcId}, \emph{ToolId})} is
    called.
  \item \emph{process to process communication}: then  
    \texttt{proc\_proc\_comm(\emph{ProcId1}, \emph{ProcId2})} is
    called.
  \item \emph{update the value of a variable in a process}: then  
    \texttt{update\_var(\emph{ProcId}, \emph{VarName},
      \emph{NewValue})} is called.
  \item \emph{update the list of subscribtions of a process}: then  
    \texttt{update\_subs(\emph{ProcId}, \emph{Subs})} is called.
  \item \emph{update the list of notes of a process}: then  
    \texttt{update\_notes(\emph{ProcId}, \emph{Notes})} is called.
  \end{itemize}
\end{itemize}

\noindent The Python interpreter is executed once, a Python \TB\
interface module (\texttt{TB.py}) is loaded, and all further requests
are directed to this incarnation of the interpreter. Besides
communication functions, the interface module defines a small set
of Python functions for unpacking and packing \TB\ terms (see
below).

\subsubsection{Incoming term conversion:}

\begin{center}
\begin{tabular}{|l|p{10cm}|}\hline
Type           & \TB\ to Python conversion \\\hline\hline
bool           & true $\mapsto$ 1 and false $\mapsto$ 0 \\\hline
int            & not converted. \\\hline
real           & not converted. \\\hline
str            & surrounded by single quotes and all non-printable
                 characters are converted to octal type
                 (\texttt{$\backslash$\emph{ooo}}). \\\hline 
bstr           & surrounded by single quotes and all non-printable
                 characters are converted to octal type
                 (\texttt{$\backslash$\emph{ooo}}). \\\hline 
appl           & outermost application is surrounded by triple quotes
                 (```), arguments are converted according to their
                 types, applications inside an application are not
                 converted. \\\hline   
list           & elements are converted according to their types, rest
                 of list format is the same (comma separated and
                 surrounded by square brackets). \\\hline  
placeholder    & converted to strings of the form
                 \texttt{'<\emph{type}>'}.\\\hline   
variable       & converted to strings of the form 
                 \texttt{'<\emph{name}:\emph{type}>'} for value 
                 occurrences and \texttt{'<\emph{name}:\emph{type}?>'} 
                 for result occurrences. \\\hline
function names & hyphens are translated to underscores. \\\hline
\end{tabular}
\end{center}

\subsection{\label{Python-functions}Predefined Python functions}

The following Python functions are predefined in the "built-in"
module \texttt{TB} and can be used freely in Python scripts executed
via the python-adapter (note that you'll have to ``import TB'' in
your Python script):

\begin{itemize} 
\item \texttt{TB.TBstring(\emph{Str\/})}: converts a Python string to
  a \TB\ string by surrounding it with double quotes and escaping
  double quotes occurring inside \emph{Str\/}.
\item \texttt{TB.PYstring(\emph{Msg\/})}: converts a \TB\ message to a
  Python string by stripping the length information and the
  surrounding double quotes.
\item \texttt{TB.send(\emph{Msg\/})}: send \emph{Msg\/} back to the
  \TB.
\item \texttt{TB.event(\emph{Msg\/})}: constructs an event message
  from \emph{Msg\/} which is sent to the \TB\ (shorthand for
  \texttt{TB.send('snd-event(\%s)' \% Msg)}).
\item \texttt{TB.error(\emph{Msg\/})}: constructs an error message
  from \emph{Msg\/} which is sent to the \TB\ (shorthand for
  \texttt{TB.send('python-adapter-error(\%s)' \% TB.TBstring(Msg)}).
\item \texttt{TB.require(\emph{Mod}, \emph{Fun}, \emph{Args\/})} check
  that the Python module \emph{Mod} contains a function declaration for
  \emph{Fun} with \emph{Args} arguments. This function is used by the
  Python adapter to check compatibility of the Python code
  with the expected input signature of the tool.
\end{itemize}

\paragraph{Note.} 

All communication between the python-adapter and a tool written
in Python is done via standard input/output. {\bf Only use the
standard error stream for print statements in the Python script,
since using standard output will disrupt the communication with the
\TB}.

\subsection{\label{Ex-hello.py}
  The hello example in Python: \texttt{hello.py}} 

Writing the hello tool in Python requires two steps:
\begin{itemize}
\item Write the required Python code \texttt{hello.py}. 
  The result is shown in Figure~\ref{fig:hello.py}.
\item Replace \texttt{hello}'s tool definition in \texttt{hello2.tb} by:
\begin{verbatim}
      tool hello is {command = "python-adapter -script hello.py"}
\end{verbatim}
\end{itemize}

\begin{figure}[t]
\rule{\textwidth}{0.5mm}
\input{hello.py.tex}
\caption{\label{fig:hello.py}\texttt{hello.py}: the hello tool in Python}
\rule{\textwidth}{0.5mm}
\end{figure}

