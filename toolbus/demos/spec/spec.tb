process TERM-EDITOR is
  let S : str, Counter : term, X : int, Y : int, Msg : str,
      G : gel(<bstr>), RewCount : rew-counter, RewBool : rew-bool, 
      ParseBool : prs-bool, Uid : ui
  in 
     execute(ui, Uid?) .
     execute(rew-counter, RewCount?) . 
     execute(rew-bool, RewBool?) .
     execute(prs-bool, ParseBool?) .

     snd-eval(RewCount, input(init)) . rec-value(RewCount, output(Counter?)) .
     ( rec-event(Uid,text(S?)) .
       snd-eval(ParseBool, input(S)).
       ( rec-value(ParseBool, syntax-error(X?, Y?, Msg?)) .
 	 snd-do(Uid, displayError(X, Y, Msg))
       + rec-value(ParseBool, output(G?)) .
	 snd-eval(RewBool, input(G)) .
	 ( rec-value(RewBool, output(true)) . snd-do(Uid, displayResult("true"))
	 +
	   rec-value(RewBool, output(false)) . snd-do(Uid, displayResult("false"))
         ) . 
	 snd-eval(RewCount, input(inc(Counter))). rec-value(RewCount, output(Counter?)) .
	 snd-do(Uid, displayCounter(Counter))
       ) . snd-ack-event(Uid, text(S))
     ) * rec-event(Uid, quit)
  endlet

tool ui       is { command = "wish-adapter -script ui-spec.tcl" }
tool prs-bool is { command = "parser-adapter -cmd bgelo pBooleans" }
tool rew-bool is { command = "asf+sdf-adapter -result term -cmd bgelio Booleans -r1 -w1"
	           details = <<
		  	inout   true       Booleans: "true" -> BOOL
			inout   false      Booleans: "false" -> BOOL
			in      and(%t,%t) Booleans: and ( BOOL , BOOL ) -> BOOL
	  	   >>
                 }
tool rew-counter is
	      { command = "asf+sdf-adapter -result term -cmd bgelio Counters -r1 -w1"
	        details = <<
			in	init	    Counters: init -> NAT
			in	inc(%t)	    Counters: inc ( NAT ) -> NAT
			inout   zero        Counters: "0" -> NAT
			inout   succ(%t)    Counters: succ ( NAT ) -> NAT
		 >>
            }

%% tool pretty   { command = "gen-adapter -prefix u -cmd Booleans" }

toolbus(TERM-EDITOR)
