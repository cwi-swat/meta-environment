
\section{The ToolBus script}

%{{{ hearts.tb

\subsection{Script overview}

The ToolBus script {\tt hearts.tb} controls the hearts system.
It defines six processes and two tools. The ToolBus configuraton
command at the end of the script starts the
{\tt MASTER}, {\tt UMPIRE}, and {\tt CONNECT-PLAYERS} processes,
and creates three robot players.

<<hearts.tb*>>=
<<process MASTER>>

<<process UMPIRE>>
<<process MATCH>>

<<process CONNECT-PLAYERS>>
<<process START-PLAYER>>
<<process PLAYER>>

<<tool definitions>>

toolbus(MASTER, UMPIRE, CONNECT-PLAYERS, 
	START-PLAYER, START-PLAYER, START-PLAYER)
@

%}}}

%{{{ tool definitions

\subsection{Tool definitions}

The hearts system uses two tool types:
\begin{itemize}
\item {\tt player} tools can either be human or robot players.
Normally, {\tt player} tools only connect to the ToolBus and are
never executed, but during debugging we use the command {\tt ./robot}
to start some robot players automatically.
<<tool definitions>>=
/*tool player is { command = "swipl-adapter -program braindead -goal toolbus" }*/
tool player is { command = "./randi" }
@

\item The {\tt umpire} tool sets the rules for the game and
makes sure nobody cheats. 
<<tool definitions>>=
tool umpire is { command = "./umpire" }
@

\end{itemize}

%}}}

%{{{ process MASTER

\subsection{the {\tt MASTER} process}

The {\tt MASTER} process administrates which matches and players are
active, and keeps track of which players participate in which matches.

<<process MASTER>>=
process MASTER is
let
  Players  : list,
  Matches  : list,
  PidCount : int,
  MidCount : int
in
  PidCount := 1 .
  MidCount := 1 .
  Players := [] .
  Matches := [] .
  ( <<MASTER: new-player>>
    +
    <<MASTER: new-match>>
    +
    <<MASTER: join-match>>
    +
    <<MASTER: player-quits>>
    +
    <<MASTER: deal>>
    +
    <<MASTER: card-played>>
    +
    <<MASTER: trick-done>>
    +
    <<MASTER: game-done>>
    +
    <<MASTER: match-done>>
    +
    <<MASTER: game-aborted>>
    +
    <<MASTER: msg2match>>
  ) * delta
endlet
@

%{{{ new-player

A new player comes to the scene. We hand out a new player-id ({\tt Pid}),
and let everybody know who is playing.

<<MASTER: new-player>>=
let
  Name  : str, Type  : str,
  Level : str, Version : str
in
  rec-msg(fresh-player(PidCount)) .
  rec-msg(new-player(Name?,Type?,Level?,Version?)) .
  Players := put(Players, PidCount, [Name,Type,Level,Version]) .
  PidCount := add(PidCount,1) .
  snd-note(players(Players)) .
  snd-note(matches(Matches))
endlet
@

%}}}
%{{{ new-match

Start a new match. Hand out a new match-id ({\tt Mid}), register the new match,
and tell everyone about it.

<<MASTER: new-match>>=
let
  Pid : int
in
  rec-msg(new-match(Pid?)) .
  Matches := put(Matches, MidCount, [[Pid], false]) .
  snd-msg(new-match(MidCount)) .
  MidCount := add(MidCount, 1) .
  snd-note(matches(Matches))
endlet
@

%}}}
%{{{ join-match

A player wants to join a match. First we lookup the match, and check
if the player may join.

<<MASTER: join-match>>=
let
  Mid  : int,  Pid : int,
  Match : list, Started : bool,
  Participants : list
in
  rec-msg(join-match(Pid?, Mid?)) .
  Match := get(Matches, Mid) .
  if equal(Match, []) then
    tau
  else
    Participants := index(Match, 1) .
    Started := index(Match, 2) .
    if Started then
      tau
    else  
      if member(Pid, Participants) then
	tau
      else
	<<join>>
      fi
    fi
  fi
endlet
@

It didn't start yet, so add the new player. We need to check if the
match can start now.

<<join>>=
  Participants := join(Participants, Pid) .
  if equal(size(Participants), 4) then
@
Enough players are there, so we can start the match. The {\tt UMPIRE} process
takes care of this. We just register the match as being started.

<<join>>=
    Started := true .
    snd-msg(start-match(Mid, Participants))
  else
    tau
  fi .
  Match   := [Participants, Started] .
  Matches  := put(Matches, Mid, Match) .
  snd-note(matches(Matches))
@

%}}}

%{{{ player-quits

A player has left the arena. Remove him from the list of players.

<<MASTER: player-quits>>=
let
  Pid : int, Player : list
in
  rec-msg(player-quits(Pid?)) .
  Player := get(Players, Pid) .
  Players := diff(Players, [[Pid, Player]]) .
  snd-note(players(Players))
endlet
@

%}}}

%{{{ deal

Distribute a number of hands.

<<MASTER: deal>>=
let
  Mid   : int,
  Pid   : int,
  Hands : list,
  Hand  : list,
  Cards : list
in
  rec-msg(deal(Mid?, Hands?)) .
  ( if not-equal(Hands, []) then
      Hand := index(Hands, 1) .
      Pid  := index(Hand, 1) .
      Cards := index(Hand, 2) .
      snd-msg(deal(Pid, Mid, Cards)) .
      Hands := next(Hands)
    fi
  ) * 
  if equal(Hands, []) then
    tau
  fi
endlet
@

%}}}
%{{{ card-played

When a player played a card, the master tool relays this information
to all the players in the match.

<<MASTER: card-played>>=
let
  Mid    : int, Pid  : int,
  Round  : int, Card : int,
  Player : int, Match : list,
  Participants : list
in
  rec-msg(card-played(Mid?, Round?, Pid?, Card?)) .
  Match := get(Matches, Mid) .
  Participants := index(Match, 1) .
  ( if not-equal(Participants, []) then
      Player := first(Participants) .
      Participants := next(Participants) .
      snd-msg(card-played(Player, Mid, Round, Pid, Card))
    fi
  ) * if equal(Participants, []) then
    tau
  fi
endlet
@

%}}}
%{{{ trick-done

The players played one trick. Relay the information to
all the participants.

<<MASTER: trick-done>>=
let
  Mid    : int,  Round  : int,
  Winner : int,  Score  : int,  
  Played : list, Player : int,
  Match   : list, Participants : list
in
  rec-msg(trick-done(Mid?, Round?, Winner?, Score?, Played?)) .
  Match := get(Matches, Mid) .
  Participants := index(Match, 1) .
  ( if not-equal(Participants, []) then
      Player := first(Participants) .
      Participants := next(Participants) .
      snd-msg(trick-done(Player, Mid, Round, Winner, Score, Played))
    fi
  ) * if equal(Participants, []) then
    tau
  fi
endlet
@

%}}}
%{{{ game-done

The players finished a single game. Relay the scores to all the participants.

<<MASTER: game-done>>=
let
  Mid    : int,  Game   : list,
  Scores : list, Player : int,
  Participants : list
in
  rec-msg(game-done(Mid?,Scores?)) .
  Game := get(Matches, Mid) .
  Participants := index(Game, 1) .
  ( if not-equal(Participants, []) then
      Player := first(Participants) .
      Participants := next(Participants) .
      snd-msg(game-done(Player, Mid, Scores))
    fi
  ) * if equal(Participants, []) then
    tau
  fi
endlet
@

%}}}

%{{{ match-done

The match is over. Send all participants a message stating the
players that did not want to continue. Knowing who does want to
go on and who doesn't, makes it easier to invite people for
a new match.

<<MASTER: match-done>>=
let
  Mid    : int,  Quitting : list,
  Match   : list, Player   : int, 
  Participants : list
in
  rec-msg(match-done(Mid?,Quitting?)) .
  Match := get(Matches, Mid) .
  Participants := index(Match, 1) .
  ( if not-equal(Participants, []) then
      Player := first(Participants) .
      Participants := next(Participants) .
      snd-msg(match-done(Player, Mid, Quitting))
    fi
  ) * if equal(Participants, []) then
    Match := get(Matches, Mid) .
    Matches := diff(Matches, [[Mid, Match]]) .
    snd-note(matches(Matches))
  fi
endlet
@

%}}}
%{{{ game-aborted

The game was aborted prematuraly. Relay the information about who's at
fault to all the participants.

<<MASTER: game-aborted>>=
let
  Mid  : int,  Pid    : int,
  Match : list, Player : int,
  Participants : list
in
  rec-msg(game-aborted(Mid?,Pid?)) .
  Match := get(Matches, Mid) .
  Participants := index(Match, 1) .
  ( if not-equal(Participants, []) then
      Player := first(Participants) .
      Participants := next(Participants) .
      snd-msg(game-aborted(Player, Mid, Pid))
    fi
  ) * if equal(Participants, []) then
    Match := get(Matches, Mid) .
    Matches := diff(Matches, [[Mid, Match]]) .
    snd-note(matches(Matches))
  fi
endlet
@

%}}}

%{{{ msg2match

Send a message to all players in a one match.

<<MASTER: msg2match>>=
let
  Mid  : int,  Pid    : int,
  Match : list, Player : int,
  Participants : list,
  Msg  : str
in
  rec-msg(msg2match(Pid?, Msg?, Mid?)) .
  Match := get(Matches, Mid) .
  Participants := index(Match, 1) .
  ( if not-equal(Participants, []) then
      Player := first(Participants) .
      Participants := next(Participants) .
      snd-msg(message(Player, Mid, Msg, Pid))
    fi
  ) * if equal(Participants, []) then
    tau
  fi
endlet
@

%}}}

%}}}

%{{{ process UMPIRE

\subsection{The {\tt UMPIRE} process}

The {\tt UMPIRE} process just starts new matches.

<<process UMPIRE>>=
process UMPIRE is
let
  U       : umpire, 
  Id      : int,
  Mid     : int,
  Players : list
in
  execute(umpire, U?) .
  ( rec-msg(start-match(Mid?, Players?)) .
    snd-do(U, start-match(Mid, Players)) .
    create(MATCH(U, Mid), Id?)
  ) * delta
endlet
@

%}}}
%{{{ process MATCH

\subsection{The {\tt MATCH} process}
The process {\tt MATCH} handles a single match of hearts.
It starts by dealing out cards to the four participating players.
Then it is up to the {\tt umpire} tool to initiate the playing
sequence.

<<process MATCH>>=
process MATCH(U:umpire, Mid : int) is
let
  AbortPid : int,
  Abort    : bool,
  Finish   : bool
in
  Abort  := false .
  Finish := false .
  ( <<deal-cards>>
    +
    <<play-card>>
    +
    <<trick-done>>
    +
    <<next-trick>>
    +
    <<game-done>>
    +
    <<next-game>>
    +
    <<match-done>>
    +
    <<abort-game>>
  ) *
  ( if Finish then
      tau
    fi
  +
    if Abort then
      snd-do(U, abort-game(Mid, AbortPid)) .
      snd-msg(game-aborted(Mid, AbortPid))
    fi
  )
endlet
@

%{{{ deal-cards

Distribute dealt cards among the players.

<<deal-cards>>=
let
  Hands : list
in
  rec-event(U, deal-cards(Mid, Hands?)) .
  snd-msg(deal(Mid, Hands)) .
  snd-ack-event(U, deal-cards(Mid, Hands))
endlet
@

%}}}
%{{{ play-card

The {\tt umpire} is ready to play another card. 
He asks the next player to play a legal card.

<<play-card>>=
let
  Pid    : int,  Round : int,  
  Played : list, Legal : list, 
  Card   : int
in
  rec-event(U, play-card(Pid?, Mid, Round?, Played?, Legal?)) .
  snd-ack-event(U, play-card(Pid, Mid, Round, Played, Legal)) .
  Card := -1 .
  ( if not(or(Abort,member(Card, Legal))) then
      snd-msg(play-card(Pid, Mid, Round, Played, Legal)) .
      ( rec-msg(play-card(Pid, Mid, Round, Card?)) .
        if not(member(Card, Legal)) then
          snd-msg(cheating(Pid, Mid, Round, Legal, Card))
        else
          tau
        fi
        +
        rec-msg(abort-game(Pid, Mid)) .
	AbortPid := Pid .
	Abort := true
      )
      +
      <<abort-game>>
    fi
  ) *
  ( if member(Card, Legal) then
      snd-msg(card-played(Mid, Round, Pid, Card)) .
      snd-do(U, card-played(Pid, Mid, Round, Card))
    fi
  +
    if Abort then
      tau
    fi
  )
endlet
@

%}}}
%{{{ trick-done

One trick has passed. The players need to know the winner (looser?),
his/her score, and the cards played.

<<trick-done>>=
let
  Round : int, Winner : int,
  Score : int, Played : list
in
  rec-event(U, trick-done(Mid, Round?, Winner?, Score?, Played?)) .
  snd-msg(trick-done(Mid, Round, Winner, Score, Played)) .
  snd-ack-event(U, trick-done(Mid, Round, Winner, Score, Played))
endlet
@

%}}}
%{{{ next-trick


One of the players in a game is ready for the next trick.
Notify the {\tt umpire} tool.

<<next-trick>>=
let
  Pid : int
in
  rec-msg(next-trick(Pid?, Mid)) .
  snd-do(U, next-trick(Pid, Mid))
endlet
@

%}}}
%{{{ game-done

A game has finished. Let the players now the scores in this game.

<<game-done>>=
let
  Scores : list
in
  rec-event(U, game-done(Mid, Scores?)) .
  snd-msg(game-done(Mid, Scores)) .
  snd-ack-event(U, game-done(Mid, Scores))
endlet
@

%}}}
%{{{ next-game

A match participant indicates if he wants to play another game.
Notify the {\tt umpire} tool.

<<next-game>>=
let
  Pid : int, Yes : bool
in
  rec-msg(next-game(Pid?, Mid, Yes?)) .
  snd-do(U, next-game(Pid, Mid, Yes))
endlet
@

%}}}

%{{{ match-done

<<match-done>>=
let
  Players : list
in
  rec-event(U, match-done(Mid, Players?)) .
  Finish := true .
  snd-msg(match-done(Mid, Players)) .
  snd-ack-event(U, match-done(Mid, Players))
endlet
@

%}}}
%{{{ abort-game

<<abort-game>>=
rec-msg(abort-game(AbortPid?, Mid)) .
Abort := true
@

%}}}

%}}}

%{{{ process CONNECT-PLAYERS

\subsection{The {\tt CONNECT-PLAYERS} process}

The process {\tt CONNECT-PLAYERS} waits for players to connect,
and creates a new {\tt PLAYER} process for each of them.

<<process CONNECT-PLAYERS>>=
process CONNECT-PLAYERS is
let
  P    : player, Pid  : int, Id : int,
  Name : str,  Type : str, 
  Level: str,  Version: str
in
  ( rec-connect(P?) .
    snd-msg(fresh-player(Pid?)) .
    snd-eval(P, who-am-i(Pid)) .
    rec-value(P, i-am(Name?,Type?,Level?,Version?)) .
    create(PLAYER(P, Pid, Name), Id?) .
    snd-msg(new-player(Name,Type,Level,Version))
  ) * delta
endlet
@

%}}}
%{{{ process START-PLAYER

\subsection{The {\tt START-PLAYER} process}

The process {\tt START-PLAYER} starts a new player. Useful for
robot players and during debugging.

<<process START-PLAYER>>=
process START-PLAYER is
let
  P    : player,
  Pid  : int,
  Cid  : int,
  Name : str,
  Type : str,
  Level: str,
  Version: str
in
  execute(player, P?)  .
  snd-msg(fresh-player(Cid?)) .
  snd-eval(P, who-am-i(Cid)) .
  rec-value(P, i-am(Name?,Type?,Level?,Version?)) .
  create(PLAYER(P, Cid, Name), Pid?) .
  snd-msg(new-player(Name,Type,Level,Version))
endlet
@

%}}}
%{{{ process PLAYER

\subsection{The {\tt PLAYER} process}

The process {\tt PLAYER} represents a human or robot player.

<<process PLAYER>>=
process PLAYER(P : player, Pid : int, Name : str) is
  subscribe(players(<list>)) .
  subscribe(matches(<list>)) .
  subscribe(broadcast(<str>,<int>)) .
  ( <<note players>>
    +
    <<note matches>>
    +
    <<new matches>>
    +
    <<playing cards>>
    +
    <<trick done>>
    +
    <<game done>>
    +
    <<match done>>
    +
    <<invitations>>
    +
    <<messages>>
  ) * 
  rec-disconnect(P) .
  snd-msg(player-quits(Pid))
@

%{{{ note players

The player tool is notified of any changes in the list of players.

<<note players>>=
let
  Players : list
in
  rec-note(players(Players?)) .
  snd-do(P, players(Players))
endlet
@

%}}}
%{{{ note matches

And in the list of matches.

<<note matches>>=
let
  Matches : list
in
  rec-note(matches(Matches?)) .
  snd-do(P, matches(Matches))
endlet
@

%}}}
%{{{ new matches

Before a match begins, someone has to start it, and enough
players must join (or accept an invitation).

<<new matches>>=
let
  Mid : int, Cards : list
in
  rec-event(P, new-match(Pid)) .
  snd-msg(new-match(Pid)) .
  rec-msg(new-match(Mid?)) .
  snd-ack-event(P, new-match(Pid, Mid))
  +
  rec-event(P, join-match(Pid, Mid?)) .
  snd-msg(join-match(Pid, Mid)) .
  snd-ack-event(P, join-match(Pid, Mid))
  +
  rec-msg(deal(Pid, Mid?, Cards?)) .
  snd-do(P, deal(Pid, Mid, Cards))
endlet
@

%}}}

%{{{ playing cards

The card-playing scenario goes like this:
\begin{enumerate}
\item The {\tt umpire} tool sends an event to the {\tt UMPIRE}
      process, to ask for the next card.
\item The {\tt UMPIRE} process sends a message to the apropriate
      {\tt PLAYER} process, forwarding the request.
\item The {\tt PLAYER} process asks its {\tt player} tool to 
      play a new card.
\item When the {\tt player} tool has decided which card to play,
      it sends an event to the {\tt PLAYER} process.
\item The {\tt PLAYER} process sends the card to play to
      the {\tt UMPIRE} process (using the {\tt play-card} message).
\item The {\tt UMPIRE} process sends the message {\tt card-played}
      to the {\tt MASTER} process, so the {\tt MASTER} process can
      notify all the players in the game.
\item The {\tt UMPIRE} process also notifies the {\tt umpire} tool,
      so this tool can decide what to do next (for instance, play
      the next card).
\end{enumerate}

<<playing cards>>=
let
  Mid    : int,  Round : int, 
  Player : int,  Card  : int,
  Played : list, Legal : list
in
  rec-msg(play-card(Pid, Mid?, Round?, Played?, Legal?)) .
  snd-do(P, play-card(Pid, Mid, Round, Played, Legal))
  +
  rec-msg(cheating(Pid, Mid, Round, Legal, Card)) .
  snd-do(P, cheating(Pid, Mid, Round, Legal, Card))
  +
  rec-event(P, play-card(Pid, Mid?, Round?, Card?)) .
  snd-msg(play-card(Pid, Mid, Round, Card)) .
  snd-ack-event(P, play-card(Pid, Mid, Round, Card))
  +
  rec-msg(card-played(Pid, Mid?, Round?, Player?, Card?)) .
  snd-do(P, card-played(Pid, Mid, Round, Player, Card))
endlet
@

%}}}
%{{{ trick done

<<trick done>>=
let
  Mid    : int, Round  : int,
  Winner : int, Score  : int, Played : list
in
  rec-msg(trick-done(Pid, Mid?, Round?, Winner?, Score?, Played?)) .
  snd-do(P, trick-done(Pid, Mid, Round, Winner, Score, Played))
  +
  rec-event(P, next-trick(Pid, Mid?)) .
  snd-msg(next-trick(Pid, Mid)) .
  snd-ack-event(P, next-trick(Pid, Mid))
endlet
@

%}}}
%{{{ game-done

<<game done>>=
let
  Mid : int, Scores : list, Yes : bool  
in
  rec-msg(game-done(Pid, Mid?, Scores?)) .
  snd-do(P, game-done(Pid, Mid, Scores))
  +
  rec-event(P, next-game(Pid, Mid?, Yes?)) .
  snd-msg(next-game(Pid, Mid, Yes)) .
  snd-ack-event(P, next-game(Pid, Mid, Yes))
endlet
@

%}}}
%{{{ match done

A match can end in two ways:
\begin{itemize}
\item At the end of a game, one or more of the players decide to quit
      ({\tt Quitting contains a list of those players}).
\item One of the players decides to abort a running game.
\end{itemize}

<<match done>>=
let
  Mid : int, Quitting : list, Pid2 : int
in
  rec-msg(match-done(Pid, Mid?, Quitting?)) .
  snd-do(P, match-done(Pid, Mid, Quitting))
  +
  rec-msg(game-aborted(Pid, Mid?, Pid2?)) .
  snd-do(P, game-aborted(Pid, Mid, Pid2))
  +
@
A player can also abort a game himself:
<<match done>>=
  rec-event(P, abort-game(Pid, Mid?)) .
  snd-msg(abort-game(Pid, Mid)) .
  snd-ack-event(P, abort-game(Pid, Mid))
endlet
@

%}}}
%{{{ invitations

Players can invitate other players to join a game.

<<invitations>>=
let
  Pid2 : int, Mid : int,
  Accepted : bool
in
  rec-msg(invite(Pid2?, Mid?, Pid)) .
  snd-eval(P, invited(Pid, Mid, Pid2)) .
  ( rec-value(P, invited(Pid, Mid, Pid2, true)) .
    snd-msg(invitation(Pid2, Mid, Pid, true)) .
    snd-msg(join-match(Pid, Mid))
    +
    rec-value(P, invited(Pid, Mid, Pid2, false)) .
    snd-msg(invitation(Pid2, Mid, Pid, false))
  )
  +
  rec-msg(invitation(Pid, Mid?, Pid2?, Accepted?)) .
  snd-do(P, invitation(Pid, Mid, Pid2, Accepted))
  +
  rec-event(P, invite(Pid, Mid?, Pid2?)) .
  snd-msg(invite(Pid, Mid, Pid2)) .
  snd-ack-event(P, invite(Pid, Mid, Pid2))
endlet
@

%}}}
%{{{ messages

Players can send messages to:
\begin{itemize}
\item a single player,
\item all the players in a single game (match),
\item all the players in the system.
\end{itemize}

<<messages>>=
let
  Mid  : int, Msg : str, 
  From : int, To  : int
in
  rec-msg(message(Pid, Mid?, Msg?, From?)) .
  snd-do(P, message(Pid, Mid, Msg, From))
  +
  rec-note(broadcast(Msg?, From?)) .
  snd-do(P, broadcast(Pid, Msg, From)) 
  +
  rec-event(P, msg2player(Pid, Msg?, To?)) .
  snd-msg(message(To, -1, Msg, Pid)) .
  snd-ack-event(P, msg2player(Pid, Msg, To))
  +
  rec-event(P, msg2match(Pid, Msg?, Mid?)) .
  snd-msg(msg2match(Pid, Msg, Mid)) .
  snd-ack-event(P, msg2match(Pid, Msg, Mid))
  +
  rec-event(P, msg2all(Pid, Msg?)) .
  snd-note(broadcast(Msg, Pid)) .
  snd-ack-event(P, msg2all(Pid, Msg))
endlet
@

%}}}

%}}}


