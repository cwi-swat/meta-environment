%{{{ heart-breaker.tcl

<<heart-breaker.tcl>>=
<<proc who-am-i>>
<<proc message>>
<<proc broadcast>>
<<proc players>>
<<proc matches>>
<<proc invited>>
<<proc invitation>>
<<proc deal>>
<<proc play-card>>
<<proc card-played>>
<<proc cheating>>
<<proc trick-done>>
<<proc game-done>>
<<proc match-done>>
<<proc game-aborted>>

<<proc rec-terminate>>
<<proc rec-ack-event>>

<<proc createMainWindow>>
<<proc selectedPlayer>>
<<proc selectedMatch>>
<<proc getName>>
<<proc updateButtons>>

<<proc startMatch>>
<<proc restartGame>>
<<proc cleanUp>>
<<proc createGameWindow>>
<<proc calcGeometry>>
<<proc drawCardOutlines>>
<<proc drawCards>>
<<proc drawCard>>

<<proc DoQuit>>
<<proc DoInvite>>
<<proc DoNewMatch>>
<<proc DoJoinMatch>>
<<proc SendToPlayer>>
<<proc SendToMatch>>
<<proc SendToAll>>

<<proc DoPlayCard>>
<<proc DoNextTrick>>
<<proc DoAbort>>

source "bitmaps/decks"

set myName [lindex $argv 0]
set myLevel [lindex $argv 1]

set myType "human"
set myVersion "0.1"
set myMatches {}
set activeMatches {}

createMainWindow
updateButtons
@

%}}}

%{{{ proc who-am-i { Pid }

Request the name of this player.

<<proc who-am-i>>=
proc who-am-i { Pid } {
  global myName myType myLevel myVersion
  global myPid

  set myPid $Pid
  wm title . "Hearts: $Pid ($myName, level $myLevel)"

  set Name	[TBstring $myName]
  set Type	[TBstring $myType]
  set Level	[TBstring $myLevel]
  set Version	[TBstring $myVersion]

  TBsend "snd-value(i-am($Name,$Type,$Level,$Version))"
}
@

%}}}
%{{{ proc message { Pid Mid Message From }

<<proc message>>=
proc message {Pid Mid Message From} {
  global win players

  if { $Mid != -1 } {
    $win(msg) insert end "$Mid> $players($From,name): $Message\n"
  } else {
    $win(msg) insert end "> $players($From,name): $Message\n"
  }
  $win(msg) see end
}
@

%}}}
%{{{ proc broadcast { Pid Message From }

<<proc broadcast>>=
proc broadcast {Pid Message From} {
  global win players

  $win(msg) insert end ">>> $players($From,name): $Message\n"
  $win(msg) see end
}
@

%}}}
%{{{ proc players { Players }

The set of players that are logged on has changed. We must update
the display to reflect this.

<<proc players>>=
proc players { Players } {
  global win players allPlayers

  set allPlayers {}
  $win(players) delete 0 end
  foreach Player $Players {
    set Pid [lindex $Player 0]
    set Info [lindex $Player 1]
    set Name [lindex $Info 0]
    set Type [lindex $Info 1]
    set Level [lindex $Info 2]

    if { $Name == "" } {
      set Name "<anonymous>"
    }
    if { $Level == "" } {
      set Level "<unknown>"
    }

    lappend allPlayers $Pid
    set players($Pid,name) $Name
    set players($Pid,type) $Type
    set players($Pid,level) $Level

    if {$Type == "robot"} {
      $win(players) insert end "[format "%3d" $Pid]\[$Level\]: $Name"
    } else {
      $win(players) insert end "[format "%3d" $Pid]($Level): $Name"
    }
    $win(players) insert end 
  }
  updateButtons
}
@

%}}}
%{{{ proc matches { Matches }

The list of active matches has changed. Update the appropriate listbox
to reflect this change.

<<proc matches>>=
proc matches { Matches } {
  global win myPid myMatches allMatches

  set myMatches {}
  set sel [$win(matches) curselection]
  $win(matches) delete 0 end
  foreach Match $Matches {
    set Mid [lindex $Match 0]
    set Info [lindex $Match 1]
    set Players [lindex $Info 0]
    set Started [lindex $Info 1]

    set allMatches($Mid) $Players
    set allMatches($Mid,started) $Started
    foreach Player $Players {
      if { $Player == $myPid } {
        lappend myMatches $Mid
      }
    }

    if { $Started == "true" } {
      $win(matches) insert end [format " %3d: [join $Players ,]" $Mid]   
    } else {
      $win(matches) insert end [format "?%3d: [join $Players ,]" $Mid]
    }
  }
  foreach item $sel {
    $win(matches) selection set $item
  }
  updateButtons
}
@

%}}}
%{{{ proc invited { Pid Mid By }

The player received an invitation from another player.
Display a dialog box, so the player can accept or decline
the invitation.

<<proc invited>>=
proc invited { Pid Mid By } {
  set result [tk_dialog .invite "Invitation" \
		"Player $By invites you to join match $Mid" \
		{} \
		0 \
		"Accept" "Decline"]

  if { $result == 0 } {
    TBsend "snd-value(invited($Pid,$Mid,$By,true))"
  } else {
    TBsend "snd-value(invited($Pid,$Mid,$By,false))"
  } 
}
@

%}}}
%{{{ proc invitation { Pid Mid By Accepted }

<<proc invitation>>=
proc invitation { Pid Mid By Accepted } {
  global win

  if { $Accepted == "true" } {
    $win(msg) insert end \
	"- Player $By accepted your invitation to join match $Mid\n"
  } else {
    $win(msg) insert end \
	"- Player $By declined your invitation to join match $Mid\n"
  }
  $win(msg) see end
}
@

%}}}

%{{{ proc deal { Pid Mid Cards }

A new match has started. Initialize a new game window.

<<proc deal>>=
proc deal { Pid Mid Cards } { 
  global activeMatches

  if { [lsearch $activeMatches $Mid] == -1 } {
    startMatch $Pid $Mid [lsort -integer $Cards]
  } else {
    restartGame $Pid $Mid [lsort -integer $Cards]
  }
}
@

%}}}
%{{{ proc play-card { Pid Mid Round Played Legal }

Request to play a card. Notify the player, and raise the cards
that he can play.

<<proc play-card>>=
proc play-card { Pid Mid Round Played Legal } {
  global matches Msg myName

  set matches($Mid,$Pid,raised) {}
  foreach card $Legal {
    set idx [lsearch $matches($Mid,$Pid,cards) $card]
    if { $idx != -1 } {
      set item [lindex $matches($Mid,$Pid,items) $idx]
      set coords [$matches($Mid,canvas) coords $item]
      set x [lindex $coords 0]
      set y [lindex $coords 1]
      $matches($Mid,canvas) coords $item $x [expr $y-16]
      $matches($Mid,canvas) bind $item <Button-1> "DoPlayCard $Pid $Mid $Round $card"
      lappend matches($Mid,$Pid,raised) [list $item $x $y]
    }

    set Msg($Mid) "Round $Round, your turn $myName. You can play any one of the raised cards."
  }
}
@

%}}}
%{{{ proc card-played { Pid Mid Round Player Card }

Some player has played a card.

<<proc card-played>>=
proc card-played { Pid Mid Round Player Card } {
  global matches activeMatches myPid

  # puts stderr "card-played: $Mid,$Round,$Player,$Card ($activeMatches)"
  if { [lsearch $activeMatches $Mid] != -1 } {
    incr matches($Mid,$Player,nr_cards) -1
    if { $Player == $myPid } {
      set idx [lsearch $matches($Mid,$myPid,cards) $Card]
      set matches($Mid,$myPid,cards) \
		[lreplace $matches($Mid,$myPid,cards) $idx $idx]
    } else {
      set idx $matches($Mid,$Player,nr_cards)
    }
    set item [lindex $matches($Mid,$Player,items) $idx]
    $matches($Mid,canvas) delete $item
    set matches($Mid,$Player,items) \
			[lreplace $matches($Mid,$Player,items) $idx $idx]

    set pos [lindex {south west north east} [lsearch $matches($Mid,pids) $Player]] 
    drawCard $Mid $pos $Card
  }
}
@

%}}}
%{{{ proc cheating { Pid Mid Round Legal Card }

This user interface has been built in such a way that
cheating is not possible. This function is called by
the ToolBus when the user did manage to cheat.

<<proc cheating>>=
proc cheating { Pid Mid Round Legal Card } {
  global activeMatches players

  if { [lsearch $activeMatches $Mid] != -1 } {
    tk_dialog .cheat$Mid "You cheated!" {} 0 "Try again"
  }
}
@

%}}}
%{{{ proc trick-done { Pid Mid Round Winner Score Played }

A trick has finished. Clean up the cards and update the score.

<<proc trick-done>>=
proc trick-done { Pid Mid Round Winner Score Played } {
  global matches Msg activeMatches

  if {[lsearch $activeMatches $Mid] != -1} {
    set Msg($Mid) "[getName $Winner] won trick $Round, he scored $Score points. Press left button to continue."
    set matches($Mid,next-trick) 1
    set matches($Mid,$Winner,gscore) [expr $matches($Mid,$Winner,gscore)+$Score]
  }
}
@

%}}}
%{{{ proc game-done { Pid Mid Scores }

A game is finished. Display the score, and ask the user if she/he wants
to play again.

<<proc game-done>>=
proc game-done { Pid Mid Scores } {
  global matches Msg activeMatches players

  if {[lsearch $activeMatches $Mid] != -1} {
    set m "Scoring:\n"
    foreach Pair $Scores {
      set PPid [lindex $Pair 0]
      set Player $players([lindex $Pair 0],name)
      set Score  [lindex $Pair 1]
      set matches($Mid,$PPid,score) $Score
      set m "$m\n[format "%4d points for player $Player" $Score]"
    }
    set m "$m\n\nDo you want to play again?"
    set choice [tk_dialog .done$Mid "Game $Mid is done!" $m {} 0 \
		"Play Again" "I've had enough"]
    if { $choice == 0 } {
      TBsend "snd-event(next-game($Pid,$Mid,true))"
    } else {
      TBsend "snd-event(next-game($Pid,$Mid,false))"
    }
  }
}
@

%}}}
%{{{ proc match-done { Pid Mid Quitting }

Some players didn't want to continue, so the match ends here.

<<proc match-done>>=
proc match-done { Pid Mid Quitting } {
  global activeMatches players

  set Names ""
  foreach Player $Quitting {
    set Names "$Names $players($Player,name),"
  }

  if { [lsearch $activeMatches $Mid] != -1 } {
    tk_dialog .over$Mid "Game Over!" "The match is over.
The following players did not want to continue:
$Names." {} 0 "Ok"
    cleanUp $Pid $Mid
  }
}
@

%}}}
%{{{ proc game-aborted { Pid Mid Player }

One of the players aborted the game. Display a message and exit.

<<proc game-aborted>>=
proc game-aborted { Pid Mid Player } {
  global activeMatches players

  if { [lsearch $activeMatches $Mid] != -1 } {
    tk_dialog .abort$Mid "Game Aborted!" \
	"Player $players($Player,name) aborted the game!" {} 0 "Shame on him!"
    cleanUp $Pid $Mid
  }
}
@

%}}}

%{{{ proc rec-terminate

<<proc rec-terminate>>=
proc rec-terminate {arg} {
  exit 1
}
@

%}}}
%{{{ proc rec-ack-event

<<proc rec-ack-event>>=
proc rec-ack-event {event} {

}
@

%}}}

%{{{ proc createMainWindow

<<proc createMainWindow>>=

proc createMainWindow {} {
  global tk_version win button

  <<window manager interaction>>

  frame .top

  <<frame .top.players>>
  <<frame .top.matches>>
  <<frame .message>>

  pack append .top \
	.top.players {left frame center expand fill} \
	.top.matches {left frame center expand fill}

  pack append . \
	.top  {top frame center expand fill} \
	.message {bottom frame center expand fill}
}
<<bindSSL>>
@

%{{{ window manager interaction

We need to specify the way in which our toplevel window interacts
with the window manager.

<<window manager interaction>>=
  wm positionfrom . program
  wm sizefrom . program
  wm maxsize . 1152 900
  wm title . "Hearts"
  wm geometry . 400x300
@

%}}}

%{{{ frame .top.players 

The topleft frame contains a list of players logged on, and
`Quit' and `Invite' buttons.

<<frame .top.players>>=
  frame .top.players -relief groove -borderwidth 2

  label .top.players.label -text "Players:"
  frame .top.players.list
  if { $tk_version == "3.6"} {
    listbox .top.players.list.box -borderwidth 2 -relief sunken \
	-geometry 1x1 \
	-yscrollcommand ".top.players.list.vbar set" \
	-xscrollcommand ".top.players.hbar set"
	-exportselection 0
	bindSSL .top.players.list.box
  } else {
    listbox .top.players.list.box -borderwidth 2 -relief sunken \
	-width 1 -height 1 \
	-yscrollcommand ".top.players.list.vbar set" \
	-xscrollcommand ".top.players.hbar set" \
	-selectmode single \
	-exportselection 0
    bind .top.players.list.box <1> { tkListboxBeginSelect %W [%W index @%x,%y]
                                     updateButtons
                                   }
  }
  set win(players) .top.players.list.box

  scrollbar .top.players.list.vbar \
	-command ".top.players.list.box yview" \
	-orient vert

  scrollbar .top.players.hbar \
	-command ".top.players.list.box xview" \
	-orient hor
  
  pack append .top.players.list \
	.top.players.list.box {left frame center expand fill} \
	.top.players.list.vbar {left frame center filly}

  frame .top.players.buttons
  button .top.players.buttons.quit -text "Quit" -command DoQuit
  button .top.players.buttons.invite -text "Invite" -command DoInvite
  set button(quit) .top.players.buttons.quit
  set button(invite) .top.players.buttons.invite

  pack append .top.players.buttons \
	.top.players.buttons.quit {left frame center expand fillx} \
	.top.players.buttons.invite {left frame center expand fillx}

  pack append .top.players \
	.top.players.label {top frame center fillx} \
	.top.players.list {top frame center expand fill} \
	.top.players.hbar {top frame center fillx} \
	.top.players.buttons {top frame center fillx}
@

%}}}
%{{{ frame .top.matches

The topright frame contains a list of ongoing matches, and
`new' and `join' buttons.

<<frame .top.matches>>=
  frame .top.matches -relief groove -borderwidth 2
  label .top.matches.label -text "Matches:"
  frame .top.matches.list
  if { $tk_version == "3.6"} {
    listbox .top.matches.list.box -borderwidth 2 -relief sunken \
	-geometry 1x1 \
	-yscrollcommand ".top.matches.list.vbar set" \
	-xscrollcommand ".top.matches.hbar set"
	-exportselection 0
	bindSSL .top.matches.list.box
  } else {
    listbox .top.matches.list.box -borderwidth 2 -relief sunken \
	-width 1 -height 4 \
	-yscrollcommand ".top.matches.list.vbar set" \
	-xscrollcommand ".top.matches.hbar set" \
	-selectmode browse \
	-exportselection 0
    bind .top.matches.list.box <1> { tkListboxBeginSelect %W [%W index @%x,%y]
                                   updateButtons
                                 }
  }
  set win(matches) .top.matches.list.box

  scrollbar .top.matches.list.vbar \
	-command ".top.matches.list.box yview" \
	-orient vert

  scrollbar .top.matches.hbar \
	-command ".top.matches.list.box xview" \
	-orient hor
  
  pack append .top.matches.list \
	.top.matches.list.box {left frame center expand fill} \
	.top.matches.list.vbar {left frame center filly}

  frame .top.matches.buttons
  button .top.matches.buttons.new -text "New" -command DoNewMatch
  button .top.matches.buttons.join -text "Join" -command DoJoinMatch
  set button(new) .top.matches.buttons.new
  set button(join) .top.matches.buttons.join

  pack append .top.matches.buttons \
	.top.matches.buttons.new {left frame center expand fillx} \
	.top.matches.buttons.join {left frame center expand fillx}


  pack append .top.matches \
	.top.matches.label {top frame center fillx} \
	.top.matches.list {top frame center expand fill} \
	.top.matches.hbar {top frame center fillx} \
	.top.matches.buttons {top frame center fillx}
@

%}}}
%{{{ frame .message

The {\tt .message} frame consists of a text window that contains
messages from the system and from other players, an entry widget
where the user can type messages, and three buttons:
\begin{itemize}
\item The {\tt Player} button, to send a message to one player;
\item The {\tt Match} button, to send a message to all the players
      in a single match;
\item The {\tt All} button, to send a message to all the players
      that are logged on.
\end{itemize}

<<frame .message>>=
  frame .message -relief groove -borderwidth 2
  label .message.label -text Messages:
  frame .message.msg
  text  .message.msg.text -height 1 -width 1 \
	-yscrollcommand ".message.msg.vbar set"
  set win(msg) .message.msg.text

  scrollbar .message.msg.vbar -orient vert -command ".message.msg.text yview"
  entry .message.entry -textvariable MainMsg
  frame .message.buttons
  
  label .message.buttons.label -text "Send to:"

  button .message.buttons.player -text "Player" -command SendToPlayer
  button .message.buttons.match -text "Match" -command SendToMatch
  button .message.buttons.all -text "All" -command SendToAll
  set button(msg2player) .message.buttons.player
  set button(msg2match) .message.buttons.match
  set button(msg2all) .message.buttons.all

  pack append .message.msg \
	.message.msg.text {left frame center expand fill} \
	.message.msg.vbar {left frame center filly}

  pack append .message.buttons \
	.message.buttons.label {left frame center} \
	.message.buttons.player {left frame center expand fill} \
	.message.buttons.match {left frame center expand fill} \
	.message.buttons.all {left frame center expand fill}

  pack append .message \
	.message.label {top frame center fillx} \
	.message.msg  {top frame center expand fill} \
	.message.entry {top frame center fillx} \
	.message.buttons {top frame center fillx}
@

%}}}
%{{{ bindSSL

procedure {\tt bindSSL}: adjust binding for single selection listbox
(Tk 3.6 only).

<<bindSSL>>=
# procedure: bindSSL, 
proc bindSSL { Box } {
  global tk_version

 bind $Box <1> {updateButtons}
 if { $tk_version == "3.6" } {
    bind $Box <B1-Motion> {%W select from [%W nearest %y]; updateButtons}
    bind $Box <Shift-B1-Motion> {%W select from [%W nearest %y]; updateButtons}
    bind $Box <Shift-Button-1> {%W select from [%W nearest %y]; updateButtons}
  } else {
    $Box configure -selectmode single
  }
}
@

%}}}

%}}}
%{{{ proc selectedPlayer {}

Get the pid of the selected player.

<<proc selectedPlayer>>=
proc selectedPlayer {} {
  global win

  set sel [$win(players) curselection]
  set players {}
  set val ""
  foreach el $sel {
    set val [string trimleft [$win(players) get $el]]
    regexp {([0-9]+)} $val val player
    lappend players $player
  }

  return $players
}
@

%}}}
%{{{ proc selectedMatch {}

Get the pid of the selected player.

<<proc selectedMatch>>=
proc selectedMatch {} {
  global win

  set sel [$win(matches) curselection]
  set matches {}
  foreach el $sel {
    set val [string trimleft [$win(matches) get $el]]
    regexp {([0-9]+)} $val val match
    lappend matches $match
  }  

  return [lindex $matches 0]
}
@

%}}}
%{{{ proc getName { Pid }

Retrieve the name of the player with a given pid.

<<proc getName>>=
proc getName { Pid } {
  global players

  return $players($Pid,name)
}
@

%}}}
%{{{ proc updateButtons {}

Enable/disable buttons depending on listbox selections.

<<proc updateButtons>>=
proc updateButtons {} {
  global win button myPid myMatches allMatches

  set pid [selectedPlayer]
  set Mid [selectedMatch]

  if { $pid == "" || $pid == $myPid } {
    $button(invite) configure -state disabled
    $button(msg2player) configure -state disabled
  } else {
    if { $Mid != "" && [lsearch $myMatches $Mid] != -1 && \
	               [lsearch $allMatches($Mid) $pid] == -1 && \
		       $allMatches($Mid,started) != "true" } {
      $button(invite) configure -state normal
    } else {
      $button(invite) configure -state disabled
    }
    $button(msg2player) configure -state normal
  }

  if { $Mid == "" } {
    $button(join) configure -state disabled
    $button(msg2match) configure -state disabled  
  } else {
    if { [lsearch $myMatches $Mid] != -1 || $allMatches($Mid,started) == "true"} {
      $button(join) configure -state disabled
    } else {
      $button(join) configure -state normal
    }
    $button(msg2match) configure -state normal
  }

  if { $myMatches == {}} {
    $button(quit) configure -state normal
  } else {
    $button(quit) configure -state disabled
  }
}
@

%}}}

%{{{ proc startMatch { Pid Mid Cards }

<<proc startMatch>>=
proc startMatch { Pid Mid Cards } {
  global matches activeMatches allMatches decks

  lappend activeMatches $Mid
  set matches($Mid,pid) $Pid
  set matches($Mid,$Pid,cards) $Cards
  set matches($Mid,deck) $decks(default)
  set matches($Mid,next-trick) 0

  set matches($Mid,color,card) white
  set matches($Mid,color,cardcover) blue

  set Pids $allMatches($Mid)
  set start [lsearch $Pids $Pid]
  set Pid1 [lindex $Pids $start]
  set Pid2 [lindex $Pids [expr ($start+1)%4]]
  set Pid3 [lindex $Pids [expr ($start+2)%4]]
  set Pid4 [lindex $Pids [expr ($start+3)%4]]

  set matches($Mid,pids) [list $Pid1 $Pid2 $Pid3 $Pid4]
  
  foreach pid $matches($Mid,pids) {
    set matches($Mid,$pid,nr_cards) 13
    set matches($Mid,$pid,items) {}
    set matches($Mid,$pid,gscore) 0
    set matches($Mid,$pid,score) 0
  }

  set matches($Mid,$Pid1,place) south
  set matches($Mid,$Pid2,place) west
  set matches($Mid,$Pid3,place) north
  set matches($Mid,$Pid4,place) east

  createGameWindow $Mid
  calcGeometry $Mid
  drawCards $Mid
}
@

%}}}
%{{{ proc restartGame { Pid Mid Cards }

<<proc restartGame>>=
proc restartGame { Pid Mid Cards } {
  global matches activeMatches allMatches decks

  set matches($Mid,$Pid,cards) $Cards
  set matches($Mid,next-trick) 0

  foreach pid $matches($Mid,pids) {
    set matches($Mid,$pid,nr_cards) 13
    set matches($Mid,$pid,gscore) 0
  }

  foreach side {north east south west} {
    if { $matches($Mid,$side,heap_item) != "" } {
      $matches($Mid,canvas) delete $matches($Mid,$side,heap_item)
      set matches($Mid,$side,heap_item) ""
    }
  }

  drawCards $Mid
}
@

%}}}
%{{{ proc cleanUp { Pid Mid }

Cleanup after a match has ended.

<<proc cleanUp>>=
proc cleanUp { Pid Mid } {
  global matches activeMatches

  # Remove $Mid from the list of active matches.
  set idx [lsearch $activeMatches $Mid]
  set activeMatches [lreplace $activeMatches $idx $idx]

  destroy $matches($Mid)
  # We might want to use a bunch of "unset's" here to really clean up!
}
@

%}}}
%{{{ proc createGameWindow { Mid }

Create a new game window.

<<proc createGameWindow>>=
proc createGameWindow { Mid } {
  global matches players myName

  set w .g$Mid
  set matches($Mid) $w

  toplevel $w
   
#  puts stderr "createGameWindow $Mid"  
  # Window manager configuration
  wm positionfrom $w user
  wm sizefrom $w ""
  wm maxsize $w 1152 900
  wm title $w "Hearts: $myName ($matches($Mid,pid)) in match $Mid" 
  # wm geometry $w "600x350"

  frame $w.scores -borderwidth 2 -relief sunken
  label $w.scores.label -text "Scores:"
  frame $w.scores.b
  frame $w.scores.b.b1
  frame $w.scores.b.b2
  frame $w.scores.b.b3
  frame $w.scores.b.b4
 
  frame $w.table -borderwidth 2 -relief groove
  frame $w.table.top
  canvas $w.table.top.cards \
	-width 748 \
	-height 582 \
	-xscrollcommand "$w.table.scroll.hbar set" \
	-yscrollcommand "$w.table.top.vbar set" \
	-confine true
  set matches($Mid,canvas) $w.table.top.cards
  bind $matches($Mid,canvas) <Button-1> "DoNextTrick $Mid"

  frame $w.table.top.cards.scores -borderwidth 2 -relief sunken
  frame $w.table.top.cards.scores.names
  frame $w.table.top.cards.scores.scores
  frame $w.table.top.cards.scores.gscores
  label $w.table.top.cards.scores.names.l -text "Player:"
  label $w.table.top.cards.scores.scores.l -text "Match:"
  label $w.table.top.cards.scores.gscores.l -text "Game:"

  pack append $w.table.top.cards.scores.names \
	$w.table.top.cards.scores.names.l {top frame center}
  pack append $w.table.top.cards.scores.scores \
	$w.table.top.cards.scores.scores.l {top frame center}
  pack append $w.table.top.cards.scores.gscores \
	$w.table.top.cards.scores.gscores.l {top frame center}

  foreach pid $matches($Mid,pids) {
    label $w.table.top.cards.scores.names.name$pid \
			-text $players($pid,name) -width 10
    label $w.table.top.cards.scores.scores.score$pid \
			-textvariable matches($Mid,$pid,score)
    label $w.table.top.cards.scores.gscores.gscore$pid \
			-textvariable matches($Mid,$pid,gscore)
    pack append $w.table.top.cards.scores.names \
	$w.table.top.cards.scores.names.name$pid {top frame center}
    pack append $w.table.top.cards.scores.scores \
	$w.table.top.cards.scores.scores.score$pid {top frame center}
    pack append $w.table.top.cards.scores.gscores \
	$w.table.top.cards.scores.gscores.gscore$pid {top frame center}
  }

  pack append $w.table.top.cards.scores \
	$w.table.top.cards.scores.names {left frame center} \
	$w.table.top.cards.scores.scores {left frame center} \
	$w.table.top.cards.scores.gscores {left frame center}

  $w.table.top.cards create window 0 0 -anchor nw -window $w.table.top.cards.scores

  scrollbar $w.table.top.vbar -orient vert -command "$w.table.top.cards yview"
  frame $w.table.scroll

  scrollbar $w.table.scroll.hbar -orient hor -command "$w.table.top.cards xview"
  frame $w.table.scroll.dummy -width 22 -height 19 -borderwidth 2 -relief flat

  frame $w.message
  label $w.message.label -textvariable Msg($Mid)

  frame $w.buttons
  button $w.buttons.quit -text "Abort" -command "DoAbort $Mid"

  pack append $w.table.top \
	$w.table.top.cards {left frame center expand fill} \
	$w.table.top.vbar {left frame center filly}

  pack append $w.table.scroll \
	$w.table.scroll.hbar {left frame center expand fillx} \
	$w.table.scroll.dummy {left frame center}

  pack append $w.table \
	$w.table.top {top frame center expand fill} \
	$w.table.scroll {top frame center fillx}

  pack append $w.message \
	$w.message.label {top frame center expand fillx}

  pack append $w.buttons \
	$w.buttons.quit {left frame center expand fillx}

  pack append $w \
	$w.table {top frame center expand fill} \
	$w.message {top frame center fillx} \
	$w.buttons {top frame center fillx}
}
@

%}}}
%{{{ proc calcGeometry { Mid }

This function calculates where the cards are located on the table top.
Also draw some 'stable' items, like the players names.

<<proc calcGeometry>>=
proc calcGeometry { Mid } {
  global matches decks

  set deck $decks(default)
  set cw $decks($deck,width)
  set ch $decks($deck,height)
  set overlap_w [expr $cw/3]
  set overlap_h [expr $ch+4]

  set ew_width [expr 4*$overlap_w+$cw]
  set ew_height [expr 2*$overlap_h+$ch]
  set ns_width [expr 12*$overlap_w+$cw]
  set ns_height $ch

  set xoff 10
  set yoff 24
  set xspace 0
  set yspace 24

  set north_x [expr $xoff+$ew_width+$xspace]
  set north_y $yoff

  set west_x $xoff
  set west_y [expr $north_y+$ns_height+$yspace]

  set east_x [expr $north_x+$ns_width+$xspace]
  set east_y $west_y

  set south_x $north_x
  set south_y [expr $west_y+$ew_height+$yspace]

  set north_heap_x [expr $north_x+($ns_width-$cw)/2]
  set north_heap_y [expr $north_y+$ns_height+$yspace]

  set west_heap_x [expr $west_x+$ew_width+$xspace] 
  set west_heap_y [expr $west_y+($ew_height-$ch)/2]

  set east_heap_x [expr $east_x-$xspace-$cw]
  set east_heap_y $west_heap_y

  set south_heap_x $north_heap_x
  set south_heap_y [expr $south_y-$yspace-$ch]

  set matches($Mid,card,width) $cw
  set matches($Mid,card,height) $ch

  set north {}
  for { set i 0 } { $i < 13 } { incr i } {
    lappend north [list [expr $north_x+$i*$overlap_w] $north_y]
  }

  set south {}
  for { set i 0 } { $i < 13 } { incr i } {
    lappend south [list [expr $south_x+$i*$overlap_w] $south_y]
  }

  set west {}
  for { set i 0 } { $i < 3 } { incr i } {
    for { set j 0 } { $j < 4 } { incr j } {
      lappend west \
	[list [expr $west_x+$j*$overlap_w] [expr $west_y+$i*$overlap_h]]
    }
  }
  lappend west [list [expr $west_x+4*$overlap_w] [expr $west_y+1*$overlap_h]]

  set east {}
  for { set i 0 } { $i < 3 } { incr i } {
    for { set j 0 } { $j < 4 } { incr j } {
      lappend east \
	[list [expr $east_x+$j*$overlap_w] [expr $east_y+$i*$overlap_h]]
    }
  }
  lappend east [list [expr $east_x+4*$overlap_w] [expr $east_y+1*$overlap_h]]

  <<set geometry values in {\tt matches} array>>
  <<draw names>>
}
@

%{{{ set geometry values in {\tt matches} array

To avoid an abundance of global variables, we use the
{\tt matches} array to tie all the variables of one match
together. This array holds the geometry values just
calculated.

<<set geometry values in {\tt matches} array>>=
  set matches($Mid,north) $north
  set matches($Mid,north,heap) [list $north_heap_x $north_heap_y]
  set matches($Mid,south) $south
  set matches($Mid,south,heap) [list $south_heap_x $south_heap_y]
  set matches($Mid,east) $east
  set matches($Mid,east,heap) [list $east_heap_x $east_heap_y]
  set matches($Mid,west) $west
  set matches($Mid,west,heap) [list $west_heap_x $west_heap_y]
@

%}}}
%{{{ draw names

Draw the names of the players above their hand of cards.

<<draw names>>=
  $matches($Mid,canvas) configure \
	-scrollregion "0 0 \
	  [expr $east_x+$ew_width] [expr $south_y+$ns_height]"

  $matches($Mid,canvas) create text [expr $south_x+$ns_width/2] [expr $south_y-16] \
		-text [getName [lindex $matches($Mid,pids) 0]] \
		-anchor n

  $matches($Mid,canvas) create text $west_x [expr $west_y-16] \
		-text [getName [lindex $matches($Mid,pids) 1]] \
		-anchor nw

  $matches($Mid,canvas) create text [expr $north_x+$ns_width/2] \
				  [expr $north_y-16] \
		-text [getName [lindex $matches($Mid,pids) 2]] \
		-anchor n

  $matches($Mid,canvas) create text $east_x [expr $east_y-16] \
		-text [getName [lindex $matches($Mid,pids) 3]] \
		-anchor nw
@

%}}}

%}}}
%{{{ proc drawCardOutlines { Mid }

<<proc drawCardOutlines>>=
proc drawCardOutlines { Mid } {
  global matches

  set c $matches($Mid,canvas)
  set cw $matches($Mid,card,width)
  set ch $matches($Mid,card,height)

  foreach player { north east south west } {
    foreach card $matches($Mid,$player) {
      set x [lindex $card 0]
      set y [lindex $card 1]
      $c create rectangle $x $y [expr $x+$cw-1] [expr $y+$ch-1] \
						-outline black
    }
  }  
}
@

%}}}
%{{{ proc drawCards { Mid }

Draw all cards, and remember their item id's.

<<proc drawCards>>=
proc drawCards { Mid } {
  global matches myPid decks

  <<draw open cards>>
  <<draw closed cards>>
}

<<proc drawClosedCards>>
@

<<draw open cards>>=
  foreach item $matches($Mid,$myPid,items) {
    $matches($Mid,canvas) delete $item
  }
  set matches($Mid,$myPid,items) {}
  for { set i 0 } { $i < $matches($Mid,$myPid,nr_cards) } { incr i } {
    set card [lindex $matches($Mid,$myPid,cards) $i]
    set bitmap "@bitmaps/$matches($Mid,deck)/$decks(table,$card)"
    set pos [lindex $matches($Mid,south) $i]
    set x [lindex $pos 0]
    set y [lindex $pos 1]
    set suit [expr $card/16]
    if { $suit == 0 || $suit == 3 } {
      set fg "black"
    } else {
      set fg "red"
    }
    set bg $matches($Mid,color,card)
    set item [$matches($Mid,canvas) create bitmap $x $y \
		-bitmap $bitmap -background $bg -foreground $fg -anchor nw]
    lappend matches($Mid,$myPid,items) $item    
  }
@

<<draw closed cards>>=
  drawClosedCards $Mid [lindex $matches($Mid,pids) 1] west
  drawClosedCards $Mid [lindex $matches($Mid,pids) 2] north
  drawClosedCards $Mid [lindex $matches($Mid,pids) 3] east
@
%{{{ proc drawClosedCards

Draw one hand, all cards facing down.

<<proc drawClosedCards>>=
proc drawClosedCards { Mid Pid Pos } {
  global matches

  foreach item $matches($Mid,$Pid,items) {
    $matches($Mid,canvas) delete $item
  }
  set $matches($Mid,$Pid,items) {}
  for { set i 0 } { $i < $matches($Mid,$Pid,nr_cards) } { incr i } {
    set pos [lindex $matches($Mid,$Pos) $i]
    set x [lindex $pos 0]
    set y [lindex $pos 1]

    set bg $matches($Mid,color,cardcover)

    set item [$matches($Mid,canvas) create bitmap $x $y \
		-bitmap "@bitmaps/$matches($Mid,deck)/facedown" \
		-foreground black -background $bg \
		-anchor nw]
    lappend matches($Mid,$Pid,items) $item
  }
}
@

%}}}

%}}}
%{{{ proc drawCard { Mid Pos Card }

Display a played card.

<<proc drawCard>>=
proc drawCard { Mid Pos card } {
  global matches decks

  set bitmap "@bitmaps/$matches($Mid,deck)/$decks(table,$card)"
  set at $matches($Mid,$Pos,heap)
  set x [lindex $at 0]
  set y [lindex $at 1]

  set suit [expr $card/16]
  if { $suit == 0 || $suit == 3 } {
    set fg "black"
  } else {
    set fg "red"
  }
  set bg $matches($Mid,color,card)
  set item [$matches($Mid,canvas) create bitmap $x $y \
	-bitmap $bitmap -background $bg -foreground $fg -anchor nw]
  set matches($Mid,$Pos,heap_item) $item
}
@

%}}}

%{{{ proc DoQuit {}

The user pushed the ``Quit'' button. Exit gracefully.

<<proc DoQuit>>=
proc DoQuit {} {
  global activeMatches

  if { $activeMatches == {} } {
    TBsend "snd-disconnect"
    exit 0
  }
}
@

%}}}
%{{{ proc DoInvite {}

Invite a player to a match. Make sure the player is not inviting himself.

<<proc DoInvite>>=
proc DoInvite {} {
  global myPid

  set Mid [selectedMatch]
  set pid [selectedPlayer]

  if { $Mid >= 0 && $pid > 0 && $pid != $myPid } {
    TBsend "snd-event(invite($myPid,$Mid,$pid))" 
  }
}
@

%}}}
%{{{ proc DoNewMatch {}

<<proc DoNewMatch>>=
proc DoNewMatch {} {
  global myPid

  TBsend "snd-event(new-match($myPid))"
}
@

%}}}
%{{{ proc DoJoinMatch {}

<<proc DoJoinMatch>>=
proc DoJoinMatch {} {
  global myPid

  set Mid [selectedMatch]

  if { $Mid >= 0 } {
    TBsend "snd-event(join-match($myPid,$Mid))"
  }
}
@

%}}}
%{{{ proc SendToPlayer {}

Send a message to a specific player.

<<proc SendToPlayer>>=
proc SendToPlayer {} {
  global MainMsg myPid

  set pid [selectedPlayer]

  if { $pid >= 0 } {
    TBsend "snd-event(msg2player($myPid,[TBstring $MainMsg],$pid))"
  }
}
@

%}}}
%{{{ proc SendToMatch {}

Send a message to all the players in a match.

<<proc SendToMatch>>=
proc SendToMatch {} {
  global MainMsg myPid

  set Mid [selectedMatch]
 
  if { $Mid >= 0 } {
    TBsend "snd-event(msg2match($myPid,[TBstring $MainMsg],$Mid))"
  }
}
@

%}}}
%{{{ proc SendToAll {}

Send a message to all the players in the system.

<<proc SendToAll>>=
proc SendToAll {} {
  global MainMsg myPid

  TBsend "snd-event(msg2all($myPid,[TBstring $MainMsg]))"
}
@

%}}}

%{{{ proc DoPlayCard { Pid Mid Round Card }

Play a card selected by the user.

<<proc DoPlayCard>>=
proc DoPlayCard { Pid Mid Round Card } {
  global matches

  # unraise and unbind cards
  foreach triple $matches($Mid,$Pid,raised) {
    set item [lindex $triple 0]
    set x [lindex $triple 1]
    set y [lindex $triple 2]
    $matches($Mid,canvas) coord $item $x $y
    $matches($Mid,canvas) bind $item <Button-1> {}
  }
  set matches($Mid,$Pid,raised) {}

  TBsend "snd-event(play-card($Pid,$Mid,$Round,$Card))"
}
@

%}}}
%{{{ proc DoNextTrick { Mid }

The user clicked on the left mouse button, to signal that
the next trick may begin. First we remove the played cards,
then we send an event to indicate that we are ready to
continue.

<<proc DoNextTrick>>=
proc DoNextTrick { Mid } {
  global matches myPid Msg

  if { $matches($Mid,next-trick) } {
    foreach side {north east south west} {
      if { $matches($Mid,$side,heap_item) != "" } {
        $matches($Mid,canvas) delete $matches($Mid,$side,heap_item)
        set matches($Mid,$side,heap_item) ""
      }
    }

    TBsend "snd-event(next-trick($myPid,$Mid))"
    set matches($Mid,next-trick) 0
    set Msg($Mid) "Waiting for other players before continuing..."
  }
}
@

%}}}
%{{{ proc DoAbort { Mid }

The user pushed the ``Abort'' button. Forfeit the game.

<<proc DoAbort>>=
proc DoAbort {Mid} {
  global myPid

  TBsend "snd-event(abort-game($myPid,$Mid))"
}
@

%}}}
