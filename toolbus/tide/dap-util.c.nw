
%{{{ dap-util.h

<<dap-util.h*>>=
#ifndef __DAP_UTIL_H__
#define __DAP_UTIL_H__

#include <TB.h>

<<function entry>>
<<function table>>
<<action entry>>
<<action table>>
<<information table>>
<<exported functions>>
<<imported functions>>
<<exec state constants>>
#endif
@

%{{{ function entry/table

A function entry describes a function that can be used in
expressions. The field {\tt name} describes the name of the
function. {\tt arity} supplies the number of arguments the
function has. -1 indicates that the function does not have
a fixed number of arguments.
{\tt eval} contains a pointer to a function that must be
called to evaluate the function.
{\tt typecheck} contains a pointer to a function that can be
used to typecheck the use of the function without evaluating
it.
<<function entry>>=
typedef struct
{
  char *name;
  int arity;
  TBbool (* eval)(term_list *args, int pid, term **result, char **msg);
  TBbool (* typecheck)(term_list *args, int pid, term **result, char **msg);
  char *doc;
} func_entry;
@

Every debug-adapter must supply a function table containing
the functions it supports.

<<function table>>=
typedef func_entry *function_table;
@

%}}}
%{{{ action entry/table

An action entry describes an action that can be used in
action lists. The field {\tt name} describes the name of the
action. {\tt arity} supplies the number of arguments the
action has. -1 indicates that the action does not have
a fixed number of arguments.
{\tt eval} contains a pointer to a function that must be
called to execute the action.
{\tt typecheck} contains a pointer to a action that can be
used to typecheck the use of the action without executing
it.
<<action entry>>=
typedef struct
{
  char *name;
  int arity;
  TBbool (* execute)(term_list *args, int pid, term **result, char **msg);
  TBbool (* typecheck)(term_list *args, int pid, term **result, char **msg);
  char *doc;
} act_entry;
@

Every debug-adapter must supply an action table containing
the actions it supports.

<<action table>>=
typedef act_entry *action_table;
@

%}}}
%{{{ information table

Every debug adapter must export a table of string pairs containing
information about the adapter. The first element of such a pair
contains the information class, the second element contains the
value(s). A {\tt NULL} pointer as value means that the information
should be requested by calling {\tt supply\_info(char *class)},
which must be supplied by the debug adapter.

<<information table>>=
extern char *information_table[];
@

%}}}
%{{{ exported functions

This section declares all the functions exported by
this utility module.
<<exported functions>>=
void   dap_init(int cid, function_table ftable, action_table atable);
term  *dap_get_info(int cid);
term  *dap_set_observation_point(int cid, term *pids, term *port, term *cond, term *acts);
void   dap_clear_observation_point(int cid, term *pids, int oid);
void   dap_rec_ack_event(int cid, term *event);
void   dap_rec_terminate(int cid, term *arg);
void   dap_change_cpe(int cid, term *pids, term *cpe);

void   dap_process_created(int pid, char *name, int exec_state);
void   dap_process_destroyed(int pid);
void   dap_check_obs_points(int pid, term *port);
TBbool dap_evaluate(term *t, int pid, term **result, char **msg); 
TBbool dap_execute(term *t, int pid, term **result, char **msg);
void   dap_stop_process(int pid);

void   dap_exception(int pid, char *exception, char *msg, char *details);

int    dap_exec_state(int pid);

int    dap_term2es(term *t);
term  *dap_es2term(int es);

/*TBbool dap_typecheck_expr(term *t, int pid, term **result, char **msg);
TBbool dap_typecheck_action(term *t, int pid, term **result, char **msg);
*/
@

%}}}
%{{{ imported functions

The functions in this section must be supplied by the
debug adapter.
<<imported functions>>=
term *supply_info(int cid, char *key);
void continue_process(int pid);
void stop_process(int pid);
@

%}}}
%{{{ exec state constants

<<exec state constants>>=
#define ES_UNKNOWN		0
#define ES_STOP			1
#define ES_RUN			2
#define ES_SINGLE_STEP		3
#define ES_STEP_OVER		4
#define ES_RUN_UNTIL_PARENT	5
#define ES_HIGH_WATER		6
@

%}}}

%}}}
%{{{ dap-util.c

<<dap-util.c*>>=
<<includes>>
<<typedefs>>
<<variables>>

<<portlocation>>
<<portwhen>>
<<porttype>>

<<dap_init>>
<<post_event>>
<<find_proc>>
<<lookup_proc>>
<<dap_create_process>>
<<dap_destroy_process>>
<<dap_watchpoint>>
<<dap_exception>>

<<typecheck_expr>>
<<typecheck_action>>
<<dap_evaluate>>
<<dap_execute>>
<<create_obs_point>>
<<remove_obs_point>>
<<check observation points>>

<<dap_get_info>>
<<dap_set_observation_point>>
<<dap_clear_observation_point>>
<<dap_exec_control>>
<<dap_stop_process>>

<<dap_rec_ack_event>>
<<dap_rec_terminate>>

<<dap_exec_state>>
<<dap_stop_level>>
<<dap_term2es>>
<<dap_es2term>>
<<exec/eval>>
@

%}}}

%{{{ includes 

<<includes>>=
#include "dap-util.h"
#include "evq.h"
@

%}}}
%{{{ typedefs

<<typedefs>>=
<<location>>
<<obs_point>>
<<process>>
@

%{{{ struct location

<<location>>=
typedef struct location {
  int start_line;
  int start_col;
  int end_line;
  int end_col;
} location;
@

%}}}
%{{{ obs_point

This structure represents an observation point.

<<obs_point>>=
typedef struct obs_point
{
  struct obs_point *next;
  int id;
  term *pids;
  int type;
  int when;
  char *mod;
  term *cond;
  term_list *acts;
  union {
    struct location loc;
    char *function;
    char *exception;
  } u;
} obs_point;

#define PORT_ON_HALT	0
#define PORT_EVERY_STAT	1
#define PORT_LOC	2
#define PORT_CALL	3
#define PORT_RETRY	4
#define PORT_FAIL	5
#define PORT_SUCCEED	6
#define PORT_EXCEPTION	7
#define NR_PORT_TYPES	8

#define LOC_LCP		0
#define LOC_LC		1
#define LOC_LP		2
#define LOC_L		3

#define WHEN_AT		0
#define WHEN_BEFORE	1
#define WHEN_AFTER	2
@

%}}}
%{{{ process

This structure represents one process.

<<process>>=
#define PROC_HASH_SIZE	4077

typedef struct process
{
  struct process *hnext;
  int pid;			/* process id of this process */
  char *name;			/* name of this process */
  char *module;			/* current module */
  term *cpe;			/* current point of execution */
  int exec_state;		/* execution state */
  int hw_exec_state;		/* execution state when high water reached */
  int stop_level;		/* stop level for ES_STEP_OVER and RUN_UNTIL_PARENT */
  int oid;			/* current observation point id */
} process;

static process *proc_table[PROC_HASH_SIZE] = { NULL };
@

%}}}

%}}}
%{{{ variables

<<variables>>=
static int tide_cid;
static function_table func_table;
static action_table act_table;
static obs_point *obs_points[NR_PORT_TYPES] = { NULL };
static int OID = 0;
static int max_pid = -1;

/* Some event queues */
#define EVQ_WATCHPOINT          0
#define EVQ_EXEC_STATE          1
#define EVQ_PROCESS_CREATED     2
#define EVQ_PROCESS_DESTROYED   3
#define EVQ_COMMUNICATION       4
#define EVQ_LAST                EVQ_COMMUNICATION

/* Queue limits */
#define MAX_QUEUE_SIZE          512
#define HIGH_WATER_MARK         128     /* Must be <<< MAX_QUEUE_SIZE */
#define LOW_WATER_MARK          8       /* Not all events have to be ack'd */

static event_queue *evq[EVQ_LAST+1] = { NULL };
static int outstanding_events = 0;
static TBbool high_water_reached = TBfalse;

TBbool eval_cpe_0(term_list *args, int pid, term **result, char **msg);
TBbool eval_cpe_1(term_list *args, int pid, term **result, char **msg);
TBbool eval_always(term_list *args, int pid, term **result, char **msg);
TBbool exec_watch_1(term_list *args, int pid, term **result, char **msg);
TBbool exec_halt_0(term_list *args, int pid, term **result, char **msg);

/* Default function/action tables */
func_entry default_func_table[] =
{
  { "cpe", 0, eval_cpe_0, NULL, 
	"returns the current point of execution in the current process." },
  { "cpe", 1, eval_cpe_1, NULL, 
	"returns the current point of execution in a specific process" },
  { "always", 0, eval_always, NULL,
        "returns true." },
  { NULL, 0, NULL, NULL, NULL }
};

act_entry default_act_table[] =
{
  { "watch", 1, exec_watch_1, NULL, "generate a watchpoint event" }, 
  { "halt",  0, exec_halt_0,  NULL, "stop execution of a process" },
  { "break", 0, exec_halt_0,  NULL, "stop execution of a process" },
  { NULL,    0, NULL,         NULL, NULL }
};
@

%}}}

%{{{ exec/eval

<<exec/eval>>=
<<eval_cpe_0>>
<<eval_cpe_1>>
<<eval_always>>

<<exec_halt_0>>
<<exec_watch_1>>
@

%{{{ TBbool eval_cpe_0(term_list *args, int pid, term **result, char **msg)

<<eval_cpe_0>>=
TBbool eval_cpe_0(term_list *args, int pid, term **result, char **msg)
{
  process *p = lookup_proc(pid);

  assert(!args);
  TBprintf(stderr, "eval_cpe_0: p=%d, cpe=%t\n", p, p->cpe);
  *result = p->cpe;

  return TBtrue;  
}
@

%}}}
%{{{ TBbool eval_cpe_1(term_list *args, int pid, term **result, char **msg)

<<eval_cpe_1>>=
TBbool eval_cpe_1(term_list *args, int pid, term **result, char **msg)
{
  process *p;

  if(TBmatch(args, "[<int>]", &pid)) {
    p = lookup_proc(pid);

    *result = p->cpe;
    return TBtrue;
  }
  *msg = "function cpe expects an integer argument";
  *result = list_first(args);

  return TBfalse;
}
@

%}}}
%{{{ TBbool eval_always(term_list *args, int pid, term **result, char **msg)

<<eval_always>>=
TBbool eval_always(term_list *args, int pid, term **result, char **msg)
{
  *result = TB_make("1");

  return TBtrue;  
}
@

%}}}
%{{{ TBbool exec_halt_0(term_list *args, int pid, term **result, char **msg)

<<exec_halt_0>>=
TBbool exec_halt_0(term_list *args, int pid, term **result, char **msg)
{
  dap_stop_process(pid);
  return TBtrue;
}
@

%}}}
%{{{ TBbool exec_watch_1(term_list *args, int pid, term **result, char **msg)

<<exec_watch_1>>=
TBbool exec_watch_1(term_list *args, int pid, term **result, char **msg)
{
  process *p = lookup_proc(pid);

  if(!dap_evaluate(list_first(args), pid, result, msg))
    return TBfalse;

  dap_watchpoint(pid, p->oid, list_first(args), *result);

  return TBtrue;
}
@

%}}}

%}}}

%{{{ void dap_init(int cid, function_table ftable, action_table atable)

Initialize some variables and the event queues.

<<dap_init>>=
void dap_init(int cid, function_table ftable, action_table atable)
{
  int i;

  tide_cid = cid;
  func_table = ftable;
  act_table  = atable;

  for(i=0; i<=EVQ_LAST; i++) {
    evq[i] = TBevq_create(MAX_QUEUE_SIZE, tide_cid);
    if(!evq[i]) {
      fprintf(stderr, "event queues exhausted\n");
      exit(1);
    }
  }  
}
@

%}}}
%{{{ process *find_proc(int pid)

Lookup the process {\tt pid} in the process table. Return NULL when
it does not exist.

<<find_proc>>=
process *find_proc(int pid)
{
  int hnr = pid % PROC_HASH_SIZE;
  process *cur = proc_table[hnr];

  while(cur && cur->pid != pid) {
    cur = cur->hnext;
  }
  return cur;
}
@

%}}}
%{{{ process *lookup_proc(int pid)

Lookup the process {\tt pid} in the process table. Create a
new process structure when it does not exist.

<<lookup_proc>>=
process *lookup_proc(int pid)
{
  int hnr = pid % PROC_HASH_SIZE;
  process *cur = proc_table[hnr];

  while(cur && cur->pid != pid)
    cur = cur->hnext;

  if(!cur) {
    cur = (process *)malloc(sizeof(process));
    if(!cur) {
      fprintf(stderr, "out of memory in get_proc\n");
      exit(1);
    }
    cur->hnext = proc_table[hnr];
    proc_table[hnr] = cur;
    cur->pid  = pid;
    cur->name = NULL;
    cur->module = NULL;
    cur->cpe = NULL;
    cur->exec_state = ES_STOP;
    TBprotect(&cur->cpe);
    if(pid > max_pid)
      max_pid = pid;
  }
  return cur;
}
@

%}}}
%{{{ void dap_create_process(int pid, char *name, int exec_state)

Create a new process.

<<dap_create_process>>=
void dap_create_process(int pid, char *name, int exec_state)
{
  process *p = lookup_proc(pid);

  assert(p);
  p->name = strdup(name);
  p->exec_state = exec_state;
  post_event(EVQ_PROCESS_CREATED, 
	TB_make("process-created(<int>,<str>)", pid, name));
  post_event(EVQ_EXEC_STATE, TB_make("exec-state([<int>],<term>)",
					pid, dap_es2term(exec_state)));
}
@

%}}}
%{{{ void dap_destroy_process(int pid)

Destroy an existing process.

<<dap_destroy_process>>=
void dap_destroy_process(int pid)
{
  int hnr = pid % PROC_HASH_SIZE;
  process *prev = NULL, *cur = proc_table[hnr];

  while(cur && cur->pid != pid) {
    prev = cur;
    cur = cur->hnext;
  }
  if(cur) {
    if(prev)
      prev->hnext = cur->hnext;
    else
      proc_table[hnr] = cur->hnext;
    TBunprotect(&cur->cpe);
    free(cur->name);
    free(cur);
  }
  post_event(EVQ_PROCESS_DESTROYED, TB_make("process-destroyed(<int>)",pid));
}
@

%}}}

%{{{ term *typecheck_expr(term *expr, int pid, term **at, char **msg)

Typecheck an expression. Return {\tt TBtrue} when the term
is type correct, {\tt TBfalse} otherwise. When the term
contains an illegal construct, {\tt at} will point to the
erroneous subterm, and {\tt msg} will indicate the error.

<<typecheck_expr>>=
TBbool typecheck_expr(term *expr, int pid, term **at, char **msg)
{
  /* This function is not implemented yet */
  return TBtrue;
}
@

%}}}
%{{{ term *typecheck_action(term *action, int pid, term **at, char **msg)

Typecheck an action. Return {\tt TBtrue} when the term
is type correct, {\tt TBfalse} otherwise. When the term
contains an illegal construct, {\tt at} will point to the
erroneous subterm, and {\tt msg} will indicate the error.

<<typecheck_action>>=
TBbool typecheck_action(term *action, int pid, term **at, char **msg)
{
  /* This function is not implemented yet */
  return TBtrue;
}
@

%}}}
%{{{ TBbool dap_evaluate(term *expr, int pid, term **result, char *msg)

Dap_Evaluate a term. Return {\tt TBfalse} when something goes wrong,
{\tt TBtrue} otherwise. On error, {\tt result} points to the
offending construct, and {\tt msg} will contain an error message.
On succes, {\tt result} points to the result, and {\tt msg} will
be unchanged.

<<dap_evaluate>>=
<<dap_evaluate_list>>
<<dap_evaluate_appl>>
TBbool dap_evaluate(term *expr, int pid, term **result, char **msg)
{
  switch(tkind(expr)) {
    case t_appl:	return dap_evaluate_appl(expr, pid, result, msg);
    case t_list:	return dap_evaluate_list(expr, pid, result, msg);
  }
  *result = expr;
  return TBtrue;
}
@

%{{{ TBbool dap_evaluate_list(term_list *exprs, int pid, term **result, char **msg)

Dap_Evaluate a list of expressions.

<<dap_evaluate_list>>=
TBbool dap_evaluate(term *expr, int pid, term **result, char **msg);

TBbool dap_evaluate_list(term_list *exprs, int pid, term **result, char **msg)
{
  term_list *el, *l = NULL;

  while(exprs) {
    if(!dap_evaluate(list_first(exprs), pid, &el, msg)) {
      *result = el;
      return TBfalse;
    }
    l = list_concat_term(l, el);
    exprs = list_next(exprs);
  }
  *result = l;
  return TBtrue;
}
@

%}}}
%{{{ TBbool dap_evaluate_appl(term *appl, int pid, term **result, char **msg)

Dap_Evaluate a function application.

<<dap_evaluate_appl>>=
TBbool dap_evaluate_appl(term *appl, int pid, term **result, char **msg)
{
  int i, arity;
  char *func;
  term_list *args, *args_eval;

  TB_match(appl, "<appl>", &func, &args);
  arity = list_length(args);
  
  if(!dap_evaluate_list(args, pid, &args_eval, msg)) {
    /* An error occured while evaluating the arguments */
    *result = args_eval;
    return TBfalse;
  }

  /* Search for the appropriate function in the function table */
  for(i=0; func_table[i].name; i++) {
    if(streq(func_table[i].name, func) && 
       (func_table[i].arity == -1 || func_table[i].arity == arity)) {
      return (func_table[i].eval)(args, pid, result, msg);
    }
  }

  /* Search for the appropriate function in the function table */
  for(i=0; default_func_table[i].name; i++) {
    if(streq(default_func_table[i].name, func) && 
       (default_func_table[i].arity == -1 || 
        default_func_table[i].arity == arity)) {
      return (default_func_table[i].eval)(args, pid, result, msg);
    }
  }

  /* The function does not exist */
  *msg = "no such function";
  *result = appl;
  return TBfalse;
}
@

%}}}

%}}}
%{{{ TBbool dap_execute(term *action, int pid, term **result, char *msg)

Dap_Evaluate an action. Return {\tt TBfalse} when something goes wrong,
{\tt TBtrue} otherwise. On error, {\tt result} points to the
offending construct, and {\tt msg} will contain an error message.
On succes, {\tt result} points to the result, and {\tt msg} will
be unchanged.

<<dap_execute>>=
<<dap_execute_list>>
<<dap_execute_appl>>
TBbool dap_execute(term *action, int pid, term **result, char **msg)
{
  switch(tkind(action)) {
    case t_appl:	return dap_execute_appl(action, pid, result, msg);
    case t_list:	return dap_execute_list(action, pid, result, msg);
  }
  *result = action;
  *msg = "illegal action";
  return TBfalse;
}
@

%{{{ TBbool dap_execute_list(term_list *actions, int pid, term **result, char **msg)

Dap_Execute a list of actions.

<<dap_execute_list>>=
static TBbool dap_execute_list(term_list *actions, int pid, term **result, char **msg)
{
  term_list *el, *l = NULL;

  while(actions) {
    if(!dap_execute(list_first(actions), pid, &el, msg)) {
      *result = el;
      return TBfalse;
    }
    l = list_concat_term(l, el);
    actions = list_next(actions);
  }
  *result = l;
  return TBtrue;
}
@

%}}}
%{{{ TBbool dap_execute_appl(term *appl, int pid, term **result, char **msg)

Execute a function application.

<<dap_execute_appl>>=
static TBbool dap_execute_appl(term *appl, int pid, term **result, char **msg)
{
  int i, arity;
  char *func;
  term_list *args, *args_eval;

  TB_match(appl, "<appl>", &func, &args);
  arity = list_length(args);
  
  if(!dap_evaluate_list(args, pid, &args_eval, msg)) {
    /* An error occured while evaluating the arguments */
    *result = args_eval;
    return TBfalse;
  }

  /* Search for the appropriate function in the action table */
  for(i=0; act_table[i].name; i++) {
    if(streq(act_table[i].name, func) && 
       (act_table[i].arity == -1 || act_table[i].arity == arity)) {
      return (act_table[i].execute)(args, pid, result, msg);
    }
  }

  /* Search for the appropriate function in the action table */
  for(i=0; default_act_table[i].name; i++) {
    if(streq(default_act_table[i].name, func) && 
       (default_act_table[i].arity == -1 || 
	default_act_table[i].arity == arity)) {
      return (default_act_table[i].execute)(args, pid, result, msg);
    }
  }

  /* The action does not exist */
  *msg = "no such action";
  *result = appl;
  return TBfalse;
}
@

%}}}

%}}}
%{{{ term *dap_get_info(int cid)

Retrieve information about a debug adapter.

<<dap_get_info>>=
term *dap_get_info(int cid)
{
  int i,j;
  term *key, *val;
  term_list *info = NULL;

  for(i=0; information_table[2*i] != NULL; i++) {
    key = TBmake(information_table[2*i]);
    if(streq(information_table[2*i], "expressions")) {
      val = NULL;
      for(j=0; func_table[j].name; j++) {
        val = list_concat_term(val, TB_make("[<str>,<int>,<str>]", 
		func_table[j].name, func_table[j].arity, func_table[j].doc));
      }
      for(j=0; default_func_table[j].name; j++) {
        val = list_concat_term(val, TB_make("[<str>,<int>,<str>]", 
		default_func_table[j].name, default_func_table[j].arity,
				   		default_func_table[j].doc));
      }
    } else if(streq(information_table[2*i], "actions")) {
      val = NULL;
      for(j=0; act_table[j].name; j++) {
        val = list_concat_term(val, TB_make("[<str>,<int>,<str>]", 
		act_table[j].name, act_table[j].arity, act_table[j].doc));
      }
      for(j=0; default_act_table[j].name; j++) {
        val = list_concat_term(val, TB_make("[<str>,<int>,<str>]",
		 default_act_table[j].name, default_act_table[j].arity,
					  default_act_table[j].doc));
      }
    } else {
      if(information_table[2*i+1]) {
        val = TBmake(information_table[2*i+1]);
      } else {
        val = supply_info(cid, information_table[2*i]);
      }
    }
    info = list_concat_term(info, mk_list2(key, val));
  }
  return TB_make("snd-value(info(<list>))", info);
}
@

%}}}

%{{{ void dap_exec_control(int pid, int es, int stack_level)

Change the execution state of a set of processes.

<<dap_exec_control>>=
void dap_exec_control(int pid, int es, int stack_level)
{
  process *p;

  fprintf(stderr, "dap_exec_control: %d, %d, %d\n", pid, es, stack_level);
  if(pid == -1) {
    for(pid=0; pid<=max_pid; pid++) {
      p = find_proc(pid);
      if(p) {
        if(p->exec_state != es)
          p->exec_state = es;
      }
    }
    post_event(EVQ_EXEC_STATE, TB_make("exec-state(all,<term>)", 
						dap_es2term(es)));
  } else {
    p = lookup_proc(pid);
    if(es != p->exec_state) {
      p->exec_state = es;
      switch(es) {
        case ES_STEP_OVER:		p->stop_level = stack_level;
					break;
        case ES_RUN_UNTIL_PARENT:	p->stop_level = stack_level-1;
					break;
      }
      post_event(EVQ_EXEC_STATE, TB_make("exec-state([<int>],<term>)",
						pid, dap_es2term(es)));
    }
  }
}
@

%}}}

%{{{ term *dap_set_observation_point(int cid, term *pids, term *port, term *cond, term_list *acts)

Set an observation point.

<<dap_set_observation_point>>=
term *dap_set_observation_point(int cid, term *pids, term *port, term *cond, term_list *acts)
{
  int oid;

  TBprintf(stderr, "setting observation point at %t,%t,%t\n", port, cond, acts);
  oid = create_obs_point(pids, port, cond, acts);
  return TB_make("snd-value(set-observation-point" \
		 "(<term>,<term>,<term>,<term>,<int>))",
		pids, port, cond, acts, oid);
}
@

%}}}
%{{{ void dap_clear_observation_point(int cid, term *pids, int oid)

Delete an observation point.

<<dap_clear_observation_point>>=
void dap_clear_observation_point(int cid, term *pids, int oid)
{
  remove_obs_point(oid);
}
@

%}}}

%{{{ int create_obs_point(term *pids, term *port, term *cond, term_list *acts)

<<create_obs_point>>=
int create_obs_point(term *pids, term *port, term *cond, term_list *acts)
{
  obs_point *point;
  term *tdata;
  char *mod;
  int type, when;

  type  = porttype(list_index(port, 1));
  when  = portwhen(list_index(port, 2));
  mod   = str_val(list_index(port, 3));
  tdata = list_next(list_next(list_next(port)));

  point = (obs_point *)malloc(sizeof(obs_point));
  point->next = obs_points[type];
  obs_points[type] = point;

  point->id   = type | OID;
  OID += NR_PORT_TYPES;
  point->pids = pids;
  point->type = type;
  point->when = when;
  point->mod  = mod;
  point->cond = cond;
  point->acts = acts;
  TBprotect(&point->pids);
  TBprotect(&point->cond);
  TBprotect(&point->acts);

  switch(type) {
    case PORT_LOC:	portlocation(&point->u.loc, tdata);
			break;
    case PORT_CALL:
    case PORT_RETRY:
    case PORT_FAIL:
    case PORT_SUCCEED:	TB_match(tdata, "[<str>]", &point->u.function);
			break;
    case PORT_EXCEPTION:
			TB_match(tdata, "[<str>]", &point->u.exception);
			break;
  }

  return point->id;
}
@

%}}}
%{{{ void remove_obs_point(int oid)

Remove an existing observation point.

<<remove_obs_point>>=
<<del_obs_point>>
void remove_obs_point(int oid)
{
  int res, type = oid % NR_PORT_TYPES;

  res = del_obs_point(&obs_points[type], oid);
  assert(res);
}
@

This function does the actual work, by deleting an observation
point from a list if it exists.
<<del_obs_point>>=
static int del_obs_point(obs_point **l, int oid)
{
  obs_point *prev = NULL, *cur = *l;
  
  while(cur) {
    if(cur->id == oid) {
      if(prev)
        prev->next = cur->next;
      else
        *l = cur->next;
      TBunprotect(&cur->pids);
      TBunprotect(&cur->cond);
      TBunprotect(&cur->acts);
      free(cur);
      return 1;
    }
    prev = cur;
    cur = cur->next;
  }
  return 0;
}
@

%}}}
%{{{ void dap_check_observation_points(int pid, term *port)

<<check observation points>>=
<<check_module>>
<<check_function>>
<<check_exception>>
<<check_location>>
<<check_pid>>

<<cond_trigger_obs_point>>
<<dap_check_observation_points>>
@

%{{{ void dap_check_observation_points(int pid, term *port)

<<dap_check_observation_points>>=
void dap_check_observation_points(int pid, term *port)
{
  obs_point *cur;
  process *p = lookup_proc(pid);
  int   type  = porttype(list_index(port, 1));
  int   when  = portwhen(list_index(port, 2));
  char *mod   = str_val(list_index(port, 3));
  term *tdata = list_next(list_next(list_next(port)));

  if(p->module)
    free(p->module);
  p->module = strdup(mod);

  if(type == PORT_LOC)
    p->cpe = port;

  TBprintf(stderr, "dap_check_observation_points: %d, %d, %t\n", p, pid, port);
  for(cur = obs_points[type]; cur; cur = cur->next) {
    TBprintf(stderr, "checking observation point: %d (mod=%s, pids=%t)\n", 
					cur->id, cur->mod, cur->pids);
    if(check_module(cur->mod, mod) && check_pid(cur->pids, pid) &&
	when == cur->when) {
      switch(type) {
	case PORT_ON_HALT:
	case PORT_EVERY_STAT:	cond_trigger_obs_point(pid, cur);
				break;

        case PORT_LOC:		if(check_location(&cur->u.loc, tdata))
				  cond_trigger_obs_point(pid, cur);
				break;

        case PORT_CALL:
	case PORT_RETRY:
	case PORT_FAIL:
	case PORT_SUCCEED:	if(!check_function(cur->u.function, tdata))
				  cond_trigger_obs_point(pid, cur);
				break;

	case PORT_EXCEPTION:	if(!check_exception(cur->u.exception, tdata))
				  cond_trigger_obs_point(pid, cur);
				break;
      }
    }
  }
}
@

%}}}
%{{{ void cond_trigger_obs_point(int pid, obs_point *p)

Trigger an observation point, only when its conditions are satisfied.

<<cond_trigger_obs_point>>=
void cond_trigger_obs_point(int pid, obs_point *p)
{
  term *res;
  char *msg;
  process *proc;

  TBprintf(stderr, "cond_trigger_obs_point: %t\n", p->cond);
  if(p->cond) {
    if(!dap_evaluate(p->cond, pid, &res, &msg)) {
      TBprintf(stderr, "evaluating condition failed: %t - %s\n", res, msg);
      return;
    }
    if(TB_match(res, "false"))
      return;
    if(TB_match(res, "0"))
      return;
    if(TB_match(res, "[]"))
      return;
  }

  TBprintf(stderr, "triggering opoint: %t\n", p->acts);
  proc = lookup_proc(pid);
  proc->oid = p->id;
  if(!dap_execute_list(p->acts, pid, &res, &msg))
    TBprintf(stderr, "execution failed: %t - %s\n", res, msg);
}
@

%}}}

%{{{ TBbool check_module(char *pattern, char *module)

<<check_module>>=
TBbool check_module(char *pattern, char *module)
{
  if(!pattern || streq(pattern, "") || streq(pattern, module))
    return TBtrue;
  fprintf(stderr, "module check failed: %s != %s\n", pattern, module);
  return TBfalse;
}
@

%}}}
%{{{ TBbool check_function(char *pattern, term *tdata)

<<check_function>>=
TBbool check_function(char *pattern, term *tdata)
{
  char *function;

  if(!tdata)
    return TBtrue;

  assert(tkind(list_first(tdata)) == t_str);

  function = str_val(list_first(tdata));
  
  if(!pattern || streq(pattern, "") || streq(pattern, function))
    return TBtrue;
  return TBfalse;
}
@

%}}}
%{{{ TBbool check_exception(char *pattern, term *tdata)

<<check_exception>>=
TBbool check_exception(char *pattern, term *tdata)
{
  char *exception;

  if(!tdata)
    return TBtrue;

  assert(tkind(list_first(tdata)) == t_str);

  exception = str_val(list_first(tdata));
  
  if(!pattern || streq(pattern, "") || streq(pattern, exception))
    return TBtrue;
  return TBfalse;
}
@

%}}}
%{{{ TBbool check_location(struct location *loc, term *loc_data)

<<check_location>>=
TBbool check_location(struct location *loc, term *loc_data)
{
  struct location loc2;
  TBbool start_before_end = TBfalse;
  TBbool end_after_start  = TBfalse;

  portlocation(&loc2, loc_data);
  if(loc->start_line < loc2.end_line || 
     (loc->start_line == loc2.end_line && 
		(loc->start_col <= loc2.end_col |+ loc2.end_col == -1)))
    start_before_end = TBtrue;
  if(loc->end_line > loc2.start_line || 
     (loc->end_line == loc2.start_line && 
		(loc->end_col > loc2.start_col || loc->end_col == -1)))
    end_after_start = TBtrue;

  if(start_before_end && end_after_start)
    return TBtrue;

  fprintf(stderr, "check_location failed: %d.%d,%d.%d != %d.%d,%d.%d\n",
	loc->start_line, loc->start_col, loc->end_line, loc->end_col,
	loc2.start_line, loc2.start_col, loc2.end_line, loc2.end_col);

  return TBfalse;
}
@

%}}}
%{{{ TBbool check_pid(term *pids, int pid)

Check if a specific pid is part of a list of pids.

<<check_pid>>=
TBbool check_pid(term *pids, int pid)
{
  if(TBmatch(pids, "all"))
    return TBtrue;

  while(pids) {
    if(int_val(list_first(pids)) == pid)
      return TBtrue;
    pids = list_next(pids);
  }
  return TBfalse;
}
@

%}}}

%}}}
%{{{ void portlocation(struct location *l, term *loc_data)

<<portlocation>>=
void portlocation(struct location *l, term *loc_data)
{
  if(TB_match(loc_data, "[lcp,<int>,<int>,<int>,<int>]", 
		&l->start_line, &l->start_col, &l->end_line, &l->end_col))
    return;

  if(TB_match(loc_data, "[lc,<int>,<int>]", &l->start_line, &l->start_col)) {
    l->end_line = l->start_line;
    l->end_col = l->start_col;
    return;
  }
   
  if(TB_match(loc_data, "[lp,<int>,<int>]", &l->start_line, &l->end_line)) {
    l->start_col = 0;
    l->end_col = -1;
    return;
  }

  if(TB_match(loc_data, "[l,<int>]", &l->start_line)) {
    l->start_col = 0;
    l->end_line = l->start_line;
    l->end_col = -1;
  }

  TBprintf(stderr, "Illegal location data: %t\n", loc_data);
  l->start_line = -1;
  l->end_line = -1;
  return;
}
@

%}}}
%{{{ int portwhen(term *when)

<<portwhen>>=
int portwhen(term *when)
{
  if(TBmatch(when, "before"))
    return WHEN_BEFORE;
  if(TBmatch(when, "after"))
    return WHEN_AFTER;
  if(TBmatch(when, "at"))
    return WHEN_AT;

  TBprintf(stderr, "illegal when spec: %t\n", when);
  return WHEN_AT;
}
@

%}}}
%{{{ int porttype(term *type)

<<porttype>>=
int porttype(term *type)
{
  if(TBmatch(type, "on-halt"))
    return PORT_ON_HALT;
  if(TBmatch(type, "every-stat"))
    return PORT_EVERY_STAT;
  if(TBmatch(type, "loc"))
    return PORT_LOC;
  if(TBmatch(type, "call"))
    return PORT_CALL;
  if(TBmatch(type, "retry"))
    return PORT_RETRY;
  if(TBmatch(type, "fail"))
    return PORT_FAIL;
  if(TBmatch(type, "succeed"))
    return PORT_SUCCEED;
  if(TBmatch(type, "exception"))
    return PORT_EXCEPTION;

  TBprintf(stderr, "illegal port type: %t\n", type);
  return PORT_ON_HALT;
}
@

%}}}

%{{{ void dap_watchpoint(int pid, int oid, term *expr, term *val)

Post a watchpoint.

<<dap_watchpoint>>=
void dap_watchpoint(int pid, int oid, term *expr, term *val)
{
  post_event(EVQ_WATCHPOINT, TB_make(
	"watchpoint([<int>],<int>,<term>,<term>)", pid, oid, expr, val));
}
@

%}}}
%{{{ void dap_exception(int pid, char *exception, char *msg, char *details)

Post an exception watchpoint.

<<dap_exception>>=
void dap_exception(int pid, char *exception, char *msg, char *details)
{
  process *p = lookup_proc(pid);
  assert(p);

  dap_watchpoint(pid, -1, TB_make("exception"), TB_make(
    "exception(<term>,<str>,<str>,<str>)", p->cpe, exception, msg, details));
}
@

%}}}
%{{{ void dap_stop_process(int pid)

<<dap_stop_process>>=
void dap_stop_process(int pid)
{
  int old_es;
  process *p = lookup_proc(pid);

  if(p->exec_state == ES_HIGH_WATER) {
    old_es = p->hw_exec_state;
    p->hw_exec_state = ES_STOP;
  } else {
    old_es = p->exec_state;
    p->exec_state = ES_STOP;
  }
  if(old_es != ES_STOP) {
    stop_process(pid);
    post_event(EVQ_EXEC_STATE, TB_make("exec-state([<int>],<term>)",
						pid, dap_es2term(ES_STOP)));
  }
  dap_check_observation_points(pid, TB_make("[on-halt,at,<str>]", p->module));
}
@

%}}}

%{{{ void post_event(int queue, term *event)

Post an event. Implement a simple control-flow mechanism
by setting a flag when the high-water mark of outstanding
events is reached.
<<post_event>>=
void post_event(int queue, term *event)
{
  TBprintf(stderr, "posting event %t in queue %d\n", event, queue);
  TBevq_post(evq[queue], event);
  outstanding_events++;
  if(outstanding_events >= HIGH_WATER_MARK)
    high_water_reached = TBtrue;
}
@

%}}}
%{{{ void dap_rec_ack_event(int cid, term *event)

Acknowledge an event. When the number of outstanding events
reaches the {\tt LOW\_WATER\_MARK}, all stopped processes can
be started.

<<dap_rec_ack_event>>=
void dap_rec_ack_event(int cid, term *event)
{
  int i;

  /*TBprintf(stderr, "Received acknowledment: %t", ev);*/
  for(i=0; i<=EVQ_LAST; i++) {
    if(TBevq_ack_event(evq[i], event)) {
      outstanding_events--;
      if(high_water_reached && outstanding_events <= LOW_WATER_MARK) {
        int i;
        high_water_reached = TBfalse;
        for(i=0; i<PROC_HASH_SIZE; i++) {
          process *cur = proc_table[i];
          while(cur) {
            if(cur->exec_state == ES_HIGH_WATER) {
              cur->exec_state = cur->hw_exec_state;
              continue_process(i);
            }
            cur = cur->hnext;
          }
        }
      }
      return;
    }
  }
}
@

%}}}
%{{{ void dap_rec_terminate(int cid, term *arg)

<<dap_rec_terminate>>=
void dap_rec_terminate(int cid, term *arg)
{
  if(cid != tide_cid) {
    TB_send(tide_cid, TB_make("snd-disconnect"));
  }
}
@

%}}}

%{{{ int dap_stop_level(int pid)

<<dap_stop_level>>=
int dap_stop_level(int pid)
{
  process *p = lookup_proc(pid);
  return p->stop_level;
}
@

%}}}
%{{{ int dap_exec_state(int pid)

<<dap_exec_state>>=
int dap_exec_state(int pid)
{
  process *p = lookup_proc(pid);
  assert(p);
  return p->exec_state;
}
@

%}}}
%{{{ int dap_term2es(term *t)

Interpret an exec-state term.

<<dap_term2es>>=
int dap_term2es(term *t)
{
  if(TBmatch(t, "stop"))
    return ES_STOP;
  if(TBmatch(t, "single-step"))
    return ES_SINGLE_STEP;
  if(TBmatch(t, "step-over"))
    return ES_STEP_OVER;
  if(TBmatch(t, "run"))
    return ES_RUN;
  if(TBmatch(t, "run-until-parent"))
    return ES_RUN_UNTIL_PARENT;

  TBprintf(stderr, "illegal exec-control: %t, stop assumed\n", t);
  return ES_STOP;
}
@

%}}}
%{{{ int dap_es2term(term *t)

Translate an exec-state to a term.

<<dap_es2term>>=
term *dap_es2term(int es)
{
  switch(es) {
    case ES_STOP:		return TBmake("stop");
    case ES_SINGLE_STEP:	return TBmake("single-step");
    case ES_STEP_OVER:		return TBmake("step-over");
    case ES_RUN:		return TBmake("run");
    case ES_RUN_UNTIL_PARENT:	return TBmake("run-until-parent");
  }
  return TBmake("unknown");
}
@

%}}}
