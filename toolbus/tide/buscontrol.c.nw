%{{{ buscontrol.c

The file {\tt buscontrol.c} implements a tool that acts
as a bridge between a ToolBus system being debugged (the 
\emph{slave}) a ToolBus system that does the debugging
(the \emph{master}). From the slave point of view, this
tool is a \emph{viewer} tool, from the master point of 
view, it is a \emph{debug-nub}.

<<buscontrol.c*>>=
<<includes>>
<<typedefs>>
<<global variables>>

<<post_event>>
<<change_exec_state>>
<<init>>

<<term_true>>
<<term_eval>>
<<in_pid_list>>

<<get_var_value>>
<<set_var_value>>
<<init_process>>
<<continue_process>>
<<update_process>>
<<create_process>>
<<start_processes>>
<<stop_processes>>
<<create_obs_point>>
<<remove_obs_point>>
<<check_obs_points>>

<<rec_monitor>>
<<rec_ack_event>>
<<rec_terminate>>

<<get_info>>

<<set_observation_point>>
<<clear_observation_point>>
<<exec_control>>
<<execute_actions>>

<<sigint_handler>>
<<main>>
@

%}}}

%{{{ includes

<<includes>>=
#include <signal.h>
#include <sys/time.h>
#include <sys/types.h>
#include <limits.h>

#include <TB.h>
#include <tool2.h>
#include "evq.h"
#include "viewer.tif.c"
#include "debug-adapter.tif.c"
@

%}}}
%{{{ typedefs

<<typedefs>>=
typedef struct obs_point
{
  struct obs_point *next;
  int id;
  term *pids;
  char *module;
  int line;
  int col;
  term *cond;
  term_list *actions;
} obs_point;
@

%}}}
%{{{ global variables

<<global variables>>=
#define MAX(a,b) 	((a)>(b)?(a):(b))
#define INITIAL_PROCS	256
#define INIT_PID 	0

#define ES_NONE		0
#define ES_STOP		1
#define ES_RUN		2
#define ES_SINGLE_STEP	3
#define ES_HIGH_WATER	4
int global_exec_state = ES_STOP;
static char *state_name[] =
{ "unknown",
  "stop",
  "run",
  "single-step",
  "high-water",
  NULL
};

int Tid = -1;
int control_bus;
int viewer;

typedef struct {
  char *name;
  term_list *vars;
  term *cpe;
  int exec_state;
  TBbool waiting;
} proc;

proc **proc_db;
int last_proc = 0;

/* Some event queues */
#define MAX_QUEUE_SIZE		512
#define HIGH_WATER_MARK		128	/* Must be <<< MAX_QUEUE_SIZE */
#define LOW_WATER_MARK		8	/* Not all events have to be ack'd */
#define EVQ_WATCHPOINT		0
#define EVQ_EXEC_STATE		1
#define EVQ_PROCESS_CREATED	2
#define EVQ_PROCESS_DESTROYED	3
#define EVQ_COMMUNICATION	4
#define EVQ_LAST		EVQ_COMMUNICATION

event_queue *evq[EVQ_LAST+1] = { NULL };
int outstanding_events = 0;
TBbool high_water_reached = TBfalse;

obs_point *obs_points_halt = NULL;
obs_point *obs_points_cpe  = NULL;
int OID = 0;
@

%}}}

%{{{ void init()

The {\tt init} process takes care of the initialization
of the {\tt buscontrol} tool.

<<init>>=
void init()
{
  int i;
  void init_process(int pid);
@


The event queues need to be created.

<<init>>=
  for(i=0; i<=EVQ_LAST; i++) {
    evq[i] = TBevq_create(MAX_QUEUE_SIZE, control_bus);
    if(!evq[i]) {
      fprintf(stderr, "not enough memory!\n");
      exit(1);
    }
  }
@

{\tt init} needs to initialize the process database.

<<init>>=
  proc_db = malloc(sizeof(proc *)*INITIAL_PROCS);
  if(!proc_db) {
    fprintf(stderr, "not enough memory!\n");
    exit(1);
  }

  for(i=0; i<INITIAL_PROCS; i++)
    proc_db[i] = NULL;
@

and creating the ever-present cpe observation point.
This observation point is activated on halt of every process
on every source position.
<<init>>=
obs_points_halt = malloc(sizeof(obs_point));
if(!obs_points_halt) {
  fprintf(stderr, "not enough memory!\n");
  exit(1);
}
obs_points_halt->next = NULL;
obs_points_halt->id   = OID++;
obs_points_halt->pids = TB_make("all");	/* every process */
obs_points_halt->line = -1;     /* every source position */
obs_points_halt->col  = -1;
obs_points_halt->module = NULL;
obs_points_halt->cond = NULL;   /* no conditions */
obs_points_halt->actions = TB_make("[watch(cpe)]"); /* show the current point of execution */
TBprotect(&obs_points_halt->pids);
TBprotect(&obs_points_halt->actions);
@

The {\tt INIT} process is always present, so initialize
it.

<<init>>=
  /* Initialize INIT process */
  init_process(INIT_PID);
  proc_db[INIT_PID]->name = "INIT";
@

Now we can notify the world that {\tt INIT} is already there!
<<init>>=
  post_event(EVQ_PROCESS_CREATED, 
      TB_make("process-created(<int>,<str>)", INIT_PID, proc_db[INIT_PID]->name));
}
@

%}}}

%{{{ term *term_eval(term *t, term *cpe)

Evaluate a term.

<<term_eval>>=
term *term_eval(term *t, term *cpe)
{
  term *mod;

  if(TB_match(t, "cpe")) {
    if(cpe) {
      mod = list_first(cpe);
      cpe = list_next(cpe);
      return list_concat(mk_list4(TB_make("loc"), TB_make("after"),
			 mod, TB_make("lcp")), cpe);
    } else {
      return TB_make("[loc,after,\"\",lcp,-1,-1,-1,-1]");
    }
  }
  if(TB_match(t, "\"\"")) {
    return NULL;
  }

  /* <PO> We need to propagate an evaluation error here! */
  return t;
}
@

%}}}
%{{{ TBbool term_true(term *t)

Check if a term represents a `true' value.
<<term_true>>=
TBbool term_true(term *t)
{
  if(TB_match(t, "false"))
    return TBfalse;
  if(TB_match(t, "0"))
    return TBfalse;
  if(TB_match(t, "[]"))
    return TBfalse;

  return TBtrue;
}
@

%}}}
%{{{ TBbool in_pid_list(term *pids, int pid)

Check if a specific pid is part of a list of pids.

<<in_pid_list>>=
TBbool in_pid_list(term *pids, int pid)
{
  if(TBmatch(pids, "all"))
    return TBtrue;

  while(pids) {
    if(int_val(list_first(pids)) == pid)
      return TBtrue;
    pids = list_next(pids);
  }
  return TBfalse;
}
@

%}}}

%{{{ get_var_value

<<get_var_value>>=
TBbool get_var_value(int pid, term *var, term **val)
{
  term *vars, *cur_var;
  assert(proc_db[pid]);

  /*TBprintf(stderr, "get_var_value in %s: %t vars: %t\n",
	proc_db[pid]->name, var, proc_db[pid]->vars);*/
  vars = proc_db[pid]->vars;

  while(vars) {
    /* Now search for the variable */
    cur_var = first(vars);

    if(term_equal(var, first(cur_var))) {
      /*TBprintf(stderr, "\tvalue: %t=%t\n", var, first(next(cur_var)));*/
      *val = first(next(cur_var));
      return TBtrue;
    } else {
      /*TBprintf(stderr, "\t*** %t != %t\n", var, first(cur_var));*/
    }

    /*TBprintf(stderr, "\t*** env_next(%t) = %t\n", vars, next(vars));*/
    vars = next(vars);
  }
  /*TBprintf(stderr, "\tnot found!\n");*/
  return TBfalse;
}
@

%}}}
%{{{ set_var_value

<<set_var_value>>=
void set_var_value(int pid, term *var, term *val)
{
  /* A variable is identified by a term represention. */
  term *vars, *cur_var;
  assert(proc_db[pid]);

  /*TBprintf(stderr, "set_var_value in %s: %t vars: %t\n", proc_db[pid]->name,
	var, proc_db[pid]->vars);*/
  vars = proc_db[pid]->vars;

  while(vars) {
    cur_var = first(vars);

    if(term_equal(first(cur_var), var)) {
      /*TBprintf(stderr, "\tset value: %t=%t\n", var, first(next(cur_var)));*/
      first(next(cur_var)) = val;
      return;
    }
    vars = next(vars);
  }
  /*TBprintf(stderr, "\tnot found, adding var %t (%t)!\n", var, val);*/
  proc_db[pid]->vars = list_concat_term(proc_db[pid]->vars, 
						mk_list2(var, val));
}
@

%}}}
%{{{ init_process

Initialize a process.

<<init_process>>=
void init_process(int pid)
{
  if(!proc_db[pid]) {
    proc_db[pid] = (proc *)malloc(sizeof(proc));
    if(!proc_db[pid]) {
      TBmsg("out of memory!");
      exit(1);
    }
    proc_db[pid]->name = "<unknown>";
    proc_db[pid]->vars = NULL;
    proc_db[pid]->cpe  = NULL;
    proc_db[pid]->exec_state = ES_NONE;
    proc_db[pid]->waiting = TBfalse;
    TBprotect(&proc_db[pid]->vars);
    TBprotect(&proc_db[pid]->cpe);

    change_exec_state(pid, global_exec_state);
   
    if(pid > last_proc)
      last_proc = pid;
  }
}
@

%}}}
%{{{ void change_exec_state(int pid, int state)

<<change_exec_state>>=
void change_exec_state(int pid, int state)
{
  fprintf(stderr, "exec_state: %d\n", state);
  if(proc_db[pid]->exec_state != state) {
    proc_db[pid]->exec_state = state;
    post_event(EVQ_EXEC_STATE, TB_make("exec-state([<int>],<appl>)", pid,
						state_name[state], NULL));
  }
}
@

%}}}
%{{{ continue_process

Send a continue message to a process (only when needed).

<<continue_process>>=
void continue_process(int pid)
{
  if(proc_db[pid]->waiting) {
    TB_send(viewer, TB_make("snd-continue(<int>)", pid));
    proc_db[pid]->waiting = TBfalse;
  }
}
@

%}}}
%{{{ update_process

When a process executes an action, this process takes care
of the updating of variables etc.

<<update_process>>=
void update_process(int pid, term *env)
{
  term *var, *val;
  TBbool changed = TBfalse;

  /*TBprintf(stderr, "update_process: %d, %t\n", pid, env);*/

  if(!proc_db[pid])
    init_process(pid);

  while(env) {
    var = first(env);
    if(get_var_value(pid, first(var), &val)) {
      if(!term_equal(val, first(next(var)))) {
	set_var_value(pid, first(var), first(next(var)));
        changed = TBtrue;
      }
    } else {
      set_var_value(pid, first(var), first(next(var)));
      changed = TBtrue;
    }
    env = next(env);    
  }
  if(changed) {
    /*TBmsg("VARIABLES OF PROCESS %d CHANGED: %t\n", pid, proc_db[pid]->vars);
    TBevq_post(evq[EVQ_VARS_CHANGED], TB_make("vars-changed([[<int>,<str>,<term>]])",
 		pid, proc_db[pid]->name, proc_db[pid]->vars));
    */
  } else {
    /*TBmsg("VARIABLES OF PROCESS %d DIDN'T CHANGE!\n");*/
  }
}
@

%}}}
%{{{ create_process

<<create_process>>=
void create_process(int pid, term *args)
{
  int new_pid;
  term *pid_trm;

  /* The pid is stored in the variable indicated by the second
     argument of creating process */
  pid_trm = NULL;
  /*TBprintf(stderr, "create_process: args = %t\n", args);*/
  get_var_value(pid,  first(next(args)), &pid_trm);
  if(pid_trm) {
    TBmatch(pid_trm, "%d", &new_pid);
    if(!proc_db[new_pid])
      init_process(new_pid);
    TBmatch(first(args), "%f", &proc_db[new_pid]->name);
    /*TBprintf(stderr, "create_process: %t (%d, %s)\n", 
		args, new_pid, proc_db[new_pid]->name);*/
    post_event(EVQ_PROCESS_CREATED, 
	TB_make("process-created(<int>,<str>)", new_pid, proc_db[new_pid]->name));
  } else {
    TBprintf(stderr, "cannot find pid of created process: %t", args);
  }  
}
@

%}}}
%{{{ void post_event(int queue, term *event)

Post an event. Implement a simple control-flow mechanism
by setting a flag when the high-water mark of outstanding
events is reached.
<<post_event>>=
void post_event(int queue, term *event)
{
  TBprintf(stderr, "posting event %t in queue %d\n", event, queue);
  TBevq_post(evq[queue], event);
  outstanding_events++;
  if(outstanding_events >= HIGH_WATER_MARK)
    high_water_reached = TBtrue;
}
@

%}}}
%{{{ void start_processes(term *procs, int es)

Start a number of processes. Start all processes when
the list is empty.

<<start_processes>>=
void start_processes(term_list *procs, int es)
{
  int pid;

  if(!procs) {
    global_exec_state = es;
    for(pid=0; pid <= last_proc; pid++) {
       /* Only continue a process when it wasn't stopped */
       if(proc_db[pid]->exec_state == ES_STOP) {
	 continue_process(pid);
	 change_exec_state(pid, es);
       }
    }
  } else {
    while(procs) {
      if(!TBmatch(first(procs), "%d", &pid)) {
	TBmsg("%t is not a list of proc-ids!\n", procs);
      } else {
	TBmsg("proc_db[%d]->exec_state = %d, waiting = %d\n", pid,
		proc_db[pid]->exec_state, proc_db[pid]->waiting);
        if(proc_db[pid]->exec_state == ES_STOP)
          continue_process(pid);
	change_exec_state(pid, es);
      }
      procs = next(procs);
    }
  }
}
@

%}}}
%{{{ void stop_processes(term *procs)

Stop a list of processes.

<<stop_processes>>=

void stop_processes(term_list *procs)
{
  int pid;

  if(!procs) {
    global_exec_state = ES_STOP;
    for(pid=0; pid <= last_proc; pid++)
      change_exec_state(pid, ES_STOP);
  } else {
    while(procs) {
      if(!TBmatch(first(procs), "%d", &pid)) {
        TBmsg("%t is not a list of proc-ids!\n", procs);
        return;
      } else {
	change_exec_state(pid, ES_STOP); /* Stop this process */
      }
      procs = next(procs);
    }
  }
}

@

%}}}
%{{{ int create_obs_point(term *pids, term *port, term *cond, term_list *acts)

<<create_obs_point>>=
int create_obs_point(term *pids, term *port, term *cond, term_list *acts)
{
  char *module;
  int line = -1, col = -1;
  obs_point *cur, *prev;
  obs_point **list;

  if(TB_match(port, "on-halt")) {
    list = &obs_points_halt;
  } else if(TB_match(port, "every-stat")) {
    list = &obs_points_cpe;
  } else if(TB_match(port, "[loc,after,<str>,lc,<int>,<int>]", 
						&module, &line, &col)) {
    list = &obs_points_cpe;
  } else {
    return -1;
  }
  
  prev = NULL;
  cur = *list;
  while(cur) {
    if(term_equal(cur->pids, pids) && cur->line == line && cur->col == col)
      return cur->id;
    prev = cur;
    cur = cur->next;
  }
  cur = (obs_point *)malloc(sizeof(obs_point));
  if(prev)
    prev->next = cur;
  else
    *list = cur;
  cur->id   = OID++;
  cur->pids = pids;
  cur->module = module;
  cur->line = line;
  cur->col  = col;
  cur->actions = acts;
  cur->cond = cond;
  cur->next = NULL;

  TBprotect(&cur->pids);
  TBprotect(&cur->actions);
  TBprotect(&cur->cond);

  return cur->id;
}
@

%}}}
%{{{ void remove_obs_point(int oid)

Remove an existing observation point.

<<remove_obs_point>>=
<<del_obs_point>>
void remove_obs_point(int oid)
{
  if(!del_obs_point(&obs_points_cpe, oid))
    del_obs_point(&obs_points_halt, oid);
}
@

This function does the actual work, by deleting an observation
point from a list if it exists.
<<del_obs_point>>=
static int del_obs_point(obs_point **l, int oid)
{
  obs_point *prev = NULL, *cur = *l;
  
  while(cur) {
    if(cur->id == oid) {
      if(prev)
        prev->next = cur->next;
      else
        *l = cur->next;
      free(cur);
      return 1;
    }
    prev = cur;
    cur = cur->next;
  }
  return 0;
}
@

%}}}
%{{{ void check_obs_points(obs_point **l, int pid, term *cpe)

<<check_obs_points>>=
<<cond_trigger_obs_point>>

void check_obs_points(obs_point *l, int pid, term *cpe)
{
  char *module;
  int start_line, start_col;
  int end_line, end_col;
  obs_point *cur = l;
  TBbool after_start = TBfalse;
  TBbool before_end = TBfalse;

  TBprintf(stderr, "checking obs points: cpe=%t, pid=%d\n", cpe, pid);
  while(cur) {
    TBprintf(stderr, "  obs point, id=%d, pids=%t, ",
		cur->id, cur->pids);
    TBprintf(stderr, "mod=%s, line=%d, col=%d, cond=%t, actions: %t\n",
		cur->module, cur->line, cur->col, cur->cond, cur->actions);

    if(in_pid_list(cur->pids, pid)) {
      TBprintf(stderr, "\t-> in pid list\n");

      TB_match(cpe, "[<str>,<int>,<int>,<int>,<int>]", &module,
		 &start_line, &start_col, &end_line, &end_col);

      /* Check if we are talking about the same module */
      if(cur->module && (!module || !streq(module, cur->module)))
        return;
      TBprintf(stderr, "\t-> modules are ok\n");

      if(cur->line == -1)
        cond_trigger_obs_point(cur, pid, cpe);

      if(cur->line > start_line || 
         (cur->line == start_line && cur->col >= start_col))
        after_start = TBtrue;
      if(cur->line < end_line ||
         (cur->line == end_line && cur->col < end_col))
        before_end = TBtrue;
      TBprintf(stderr, "\t  after_start=%d, before_end=%d\n", 
					after_start, before_end);
      if(after_start && before_end)
        cond_trigger_obs_point(cur, pid, cpe);
    }
    cur = cur->next;
  }
}
@

Trigger an observation point, only when its conditions are satisfied.

<<cond_trigger_obs_point>>=
void check_obs_points(obs_point *l, int pid, term *cpe);

void cond_trigger_obs_point(obs_point *p, int pid, term *cpe)
{
  term_list *acts;
  term *act, *expr;

  TBprintf(stderr, "cond_trigger_obs_point: %d, %t\n", pid, cpe);

  if(p->cond && !term_true(term_eval(p->cond, cpe)))
    return;

  acts = p->actions;
  TBprintf(stderr, "triggering opoint! (%d): %t\n", 
				proc_db[pid]->exec_state, acts);

  while(acts) {
    act = list_first(acts);
    acts = list_next(acts);
    if(TBmatch(act, "break")) {
      if(proc_db[pid]->exec_state != ES_STOP) {
	change_exec_state(pid, ES_STOP);
	check_obs_points(obs_points_halt, pid, cpe);
      }
    } else if(TB_match(act, "watch(<term>)", &expr)) {
      	post_event(EVQ_WATCHPOINT, 
		TB_make("watchpoint([<int>],<int>,<term>,<term>)",
		       pid, p->id, expr, term_eval(expr, cpe)));
    } else {
      TBprintf(stderr, "illegal action: %t\n", act);
    }
  }
}
@

%}}}

%{{{ rec_monitor

<<rec_monitor>>=
<<is_to_tool_comm>>
<<is_from_tool_comm>>

term *rec_monitor(int cid, term *T)
{
  char *mon_point, *at_fun;
  int pid1, pid2;
  term *at_args, *at_coords, *env, *subs, *notes, *pe;

  /*TBprintf(stderr, "monitor command received: %t\n", T);*/
  if(TBmatch(T, "%f(%d,%f,%t,%t,%t,%t,%t,%d,%t)",
	     &mon_point, &pid1, &at_fun, &at_args, &at_coords,
	     &env, &subs, &notes, &pid2, &pe)) {
    /* Any common code prefix goes here */
    update_process(pid1, env);
    proc_db[pid1]->waiting = TBtrue;

    if(streq(at_fun, "create")) {
      /* Process creation monitoring */
      create_process(pid1, at_args); 
    } else if(streq(at_fun, "rec-connect")) {
      /* Tool connection monitoring */
    } else if(is_to_tool_comm(at_fun)) {
      /* Process -> Tool communication monitoring */
    } else if(is_from_tool_comm(at_fun)) {
      /* Tool -> Process communication monitoring */
    } else if(streq(at_fun, "endlet")) {
      /* Endlet monitoring */
    } else if(pid2 >= 0) {
      /* Process <-> process communication */
        /*TBevq_post(evq[EVQ_COMMUNICATION],
	  TB_make("communication(proc-proc,<int>,<int>,<appl>,<term>)", 
					pid1, pid2, at_fun, NULL, at_args));
        */
    } else {
      /* Other atoms (assignment, printf, tau, etc.) */
    }

    /* Now we can check for observation points */
    check_obs_points(obs_points_cpe, pid1, at_coords);

    /* Any common code postfix goes here */
    switch(proc_db[pid1]->exec_state) {
	case ES_STOP:
	case ES_SINGLE_STEP:	/* Later, we need to do something more
				   sophisticated here later. */
				change_exec_state(pid1, ES_STOP);
				check_obs_points(obs_points_halt, pid1, at_coords);
				break;
	case ES_RUN:		if(high_water_reached)
				  proc_db[pid1]->exec_state = ES_HIGH_WATER;
				else
				  continue_process(pid1);
				break;
        case ES_HIGH_WATER:	break;
	default:	/* An illegal exec state? better crash and burn! */
			TBmsg("process %d, exec_state = %d\n",
					pid1, proc_db[pid1]->exec_state);
			assert(0);
    }
  } else {
    err_fatal("badly formed monitor function: %t\n", T);
  }
  return NULL;
}
@

%{{{ is_to_tool_comm

<<is_to_tool_comm>>=
TBbool is_to_tool_comm(char *s)
{
  return streq(s, "snd-eval") 
         || streq(s, "snd-cancel") 
         || streq(s, "snd-do") 
         || streq(s, "snd-ack-event") 
         || streq(s, "snd-terminate");
}
@

%}}}
%{{{ is_from_tool_comm

<<is_from_tool_comm>>=
TBbool is_from_tool_comm(char *s)
{
  return streq(s, "rec-value") 
         ||  streq(s, "rec-event") 
         || streq(s, "rec-disconnect");
}
@

%}}}

%}}}
%{{{ rec_ack_event

<<rec_ack_event>>=
void rec_ack_event(int cid, term *ev)
{
  int i;

  /*TBprintf(stderr, "Received acknowledment: %t", ev);*/
  for(i=0; i<=EVQ_LAST; i++) {
    if(TBevq_ack_event(evq[i], ev)) {
      outstanding_events--;
      if(high_water_reached && outstanding_events <= LOW_WATER_MARK) {
        int i;
        high_water_reached = TBfalse;
        for(i=0; i<last_proc; i++) {
          if(proc_db[i] && proc_db[i]->exec_state == ES_HIGH_WATER) {
            proc_db[i]->exec_state = ES_RUN;
            continue_process(i);
          }
        }
      }
      return;
    }
  }
  /*TBprintf(stderr, ", not handled by any queue\n");*/
}
@

%}}}
%{{{ rec_terminate

<<rec_terminate>>=
void rec_terminate(int cid, term *Arg)
{
  TBprintf(stderr, "Received termination request: %t\n", Arg);
  TB_send(control_bus, TB_make("snd-disconnect"));
  sleep(1); /* Incoming traffic must be consumed first */
  exit(0);
}
@

%}}}

%{{{ get_info

<<get_info>>=
<<info_search_paths>>
<<info_observation_ports>>
<<info_observation_conditions>>
<<info_observation_actions>>
<<info_expressions>>
<<info_exec_control>>
<<info_parallelism>>

term *get_info(int cid)
{
  return TB_make("snd-value(info([<term>,<term>,<term>,<term>,<term>,<term>,<term>]))",
	info_search_paths(), info_observation_ports(), 
	info_observation_conditions(), info_observation_actions(),
	info_expressions(), info_exec_control(), info_parallelism());
}
@

%{{{ term *info_search_paths()

Return information about the search-paths for this debugging adapter.

<<info_search_paths>>=
term *info_search_paths()
{
  static char path[_POSIX_PATH_MAX];
  getcwd(path, _POSIX_PATH_MAX);

  return TB_make("[search-paths, [[config, [<str>]], [source, [<str>]]]]", 
								path, path);
}
@

%}}}
%{{{ term *info_observation_ports()

<<info_observation_ports>>=
term *info_observation_ports()
{
  return TB_make("[observation-ports,"\
	"[[on-halt,at,[]], [every-stat,after,[]], [loc,after,[lc]]]]");
}
@

%}}}
%{{{ term *info_observation_conditions()

<<info_observation_conditions>>=
term *info_observation_conditions()
{
  return TB_make("[observation-conditions, [always, expr]]");
}
@

%}}}
%{{{ term *info_observation_actions()

<<info_observation_actions>>=
term *info_observation_actions()
{
  return TB_make("[observation-actions, [break, watch]]");
}
@

%}}}
%{{{ term *info_expressions()

<<info_expressions>>=
term *info_expressions()
{
  return TB_make("[expressions, [functions, [cpe, eval]]]");
}
@

%}}}
%{{{ term *info_exec_control()

Return information about the execution control capabilities of this
debugging adapter.

<<info_exec_control>>=
term *info_exec_control()
{
  return TB_make("[exec-control, [single-step, run, stop]]");
}
@

%}}}
%{{{ term *info_parallelism()

Return information about the parallel debugging capabilities of this
debugging tool.

<<info_parallelism>>=
term *info_parallelism()
{
  return TB_make("[multi-process]");
}
@

%}}}

%}}}

%{{{ void set_observation_point(int cid, term *pids, term *port, term *cond, term *acts)

Set an observation point.

<<set_observation_point>>=
term *set_observation_point(int cid, term *pids, term *port, term *cond, term_list *acts)
{
  int oid;

  oid = create_obs_point(pids, port, cond, acts);
  return TB_make("snd-value(set-observation-point" \
		 "(<term>,<term>,<term>,<term>,<int>))",
		pids, port, cond, acts, oid);
}
@

%}}}
%{{{ void clear_observation_point(int cid, term *pids, int oid)

Remove an observation point.

<<clear_observation_point>>=
void clear_observation_point(int cid, term *pids, int oid)
{
  remove_obs_point(oid);
}
@

%}}}
%{{{ void exec_control(int cid, term_list *procs, term *mode)

<<exec_control>>=
void exec_control(int cid, term_list *procs, term *mode)
{
  if(!procs)
    return;

  if(TB_match(procs, "all"))
    procs = NULL;
  if(TB_match(mode, "stop")) {
    stop_processes(procs);
  } else {
    int action;

    if(!is_list(procs))
      procs = mk_list1(procs);
    if(TB_match(mode, "single-step"))
      action = ES_SINGLE_STEP;
    if(TB_match(mode, "run"))
      action = ES_RUN;

    start_processes(procs, action);
  }
}
@

%}}}
%{{{ term *execute_actions(int cid, term *pids, term_list *actions)

<<execute_actions>>=
term *execute_actions(int cid, term *pids, term_list *actions)
{
  return TB_make("snd-value(execute-actions(<ter>,<term>,error(<str>)))",
			pids, actions, "not implemented yet");
}
@

%}}}

%{{{ sigint_handler

<<sigint_handler>>=
void sigint_handler(int sig)
{
  /* There are three possibilities here:
     1) Some outside source issued a SIGINT (not very likely)
     2) The ToolBus system being debugged issued a SIGINT
     3) The debugger ToolBus system issued a SIGINT
     
     In all three cases, we want to shutdown gracefully.
     This means disconnect any living ToolBus connections
     in a peaceful manner.
  */

/**** OLD, NON-WORKING DETECTION CODE ****
  extern toToolBus;
  fd_set set;
  int result;
  struct timeval zero_time = { 0, 0 };
  
  fprintf(stderr, 
    "received SIGINT, using select to check for dead ToolBus connections\n");
  

  FD_ZERO(&set);
  FD_SET(toToolBus, &set);
  FD_SET(control_bus, &set);
  select(MAX(toToolBus, control_bus), NULL, &set, NULL, &zero_time);
  if(result) {
    if(FD_ISSET(toToolBus, &set))
      fprintf(stderr, "debugged ToolBus system is ready to receive data!\n");
    if(FD_ISSET(control_bus, &set))
      fprintf(stderr, "debugging ToolBus system is ready to receive data!\n");
  } else {
    fprintf(stderr, "Nobody is ready for writing!\n");
  }
*/

  fprintf(stderr, "SIGINT received, disconnecting from debugger\n");
  TB_send(control_bus, TB_make("snd-disconnect"));
  sleep(1); /* Incoming traffic must be consumed first */
  exit(0);
}
@

%}}}
%{{{ main

<<main>>=
int main(int argc, char *argv[])
{
  /*char host[MAXHOSTNAMELEN];
  gethostname(host, MAXHOSTNAMELEN);*/

  TB_init();

  fprintf(stderr, "Opening initial connection for viewer\n");
  viewer = TB_parseArgs(argc, argv, viewer_handler, viewer_check_in_sign);
  TB_connect(viewer);

  fprintf(stderr, "Opening second connection to debugging toolbus\n");
  control_bus = TB_newConnection("debug-adapter", NULL, 9500,
	         debug_adapter_handler, debug_adapter_check_in_sign);
  TB_connect(control_bus);

  init();
  signal(SIGINT, sigint_handler);

  return TB_eventloop();
}
@

%}}}
