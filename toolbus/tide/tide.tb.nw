
%{{{ tide.tb

<<tide.tb*>>=
<<process DAP-CONNECT>>
<<process EVENT-RULES>>
<<process BROADCAST>>
<<process SOURCE-VIEWER>>
<<process RULE-VIEWER>>
<<process PROCESS-LIST>>
<<process WATCHPOINT-VIEWER>>
<<process MASTER-CONTROL>>

<<tool definitions>>

toolbus(DAP-CONNECT, MASTER-CONTROL, BROADCAST, 
	SOURCE-VIEWER, RULE-VIEWER, WATCHPOINT-VIEWER, PROCESS-LIST)
@

%}}}

%{{{ tool definitions

\subsection{Tool definitions}

In this section, we define the tools used in this ToolBus script.

<<tool definitions>>=
tool debug-adapter is { }
tool master-control is { command = "tcltk-adapter -script master-control.tcl" }
tool source-viewer  is { command = "tcltk-adapter -script source-viewer.tcl" }
tool rule-viewer  is { command = "tcltk-adapter -script rule-viewer.tcl" }
tool watchpoint-viewer is { command = "tcltk-adapter -script watchpoint-viewer.tcl" }
tool process-list is { command = "java-adapter -class toolbus.tide.ProcessList" }
%%tool viewer is { command = "./buscontrol" }
@

%}}}

%{{{ process DAP-CONNECT

<<process DAP-CONNECT>>=
process DAP-CONNECT is
let
  D    : debug-adapter,
  P    : list,
  Pid  : int,
  Info : list
in
  ( rec-connect(D?) .
    snd-eval(D, get-info) .
    rec-value(D, info(Info?)) .
    snd-eval(D, get-processes) .
    rec-value(D, processes(P?)) .
    %% printf("%t info: %t, procs: %t\n", D, Info, P) .
    snd-note(event(proc(D,all), dap-connected(Info,P))) .
    create(EVENT-RULES(D), Pid?)
    +
    rec-disconnect(D?) .
    snd-note(event(proc(D,all),dap-disconnected))
  ) * delta
endlet
@

%}}}
%{{{ process EVENT-RULES
\subsection{The event rule ToolBus process}

Figure \ref{event-rules} shows the event processing inside a debug
adapter. First the event port is used to determine which event
rules are activated. Then the event condition is used to filter
these activated event rules. Finally, triggering the event rule results in
the execution of actions that either change the
(execution) state of the process that generated the original
primitive event, or actions that generate watchpoint events
for the \master\ bus.

\begin{figure}[htb]
  \centerline{\epsfig{file=events.ps,scale=0.7}}
  \caption{\label{adapter-figure}Event processing inside a debug adapter}
\end{figure}

Because the interaction between a debug adapter and the \master\ 
is completely based on event rules, the 
interface between them can be described using the {\tt EVENT-RULE} 
\TB\ process given below.

By unifying all primitive debugging events using event rules,
the interaction between the debug adapters and the
\master\ can be described in one simple \TB\ process.
This process can:
\begin{itemize}
\item Create a new event rule. After creating the event rule,
      a message is broadcasted to inform all \master\ components
      that a new event rule exists.
\item Destroy an existing event rule. A message is broadcasted to
      inform everyone the event rule no longer exists.
\item Receive and broadcast watchpoint events. When a watchpoint is
      triggered, a message is broadcasted so all tools that depend on this
      watchpoint can update their view. 
\end{itemize}

<<process EVENT-RULES>>=
process EVENT-RULES(D:debug-adapter) is
let
  P     : term,   %% list of process-id's, or `all' indicating all
                  %% processes controlled by the debug adapter.
  Port  : term,   %% event port and modifier
  Cond  : term,   %% event condition
  Life  : term,   %% lifetime of an event rule
  Acts  : list,   %% event actions
  Rid   : int,    %% event rule identifier
  Expr  : term,   %% Watchpoint expression
  Exprs : term,   %% List of expression/value pairs.
  Result: term    %% ok or error(<str>)
in
  ( rec-msg(proc(D,P?), create-rule(Port?,Cond?,Acts?,Life?)) .
    snd-eval(D, create-rule(P, Port,Cond,Acts,Life)) .
    rec-value(D, create-rule(P, Port,Cond,Acts,Life,Rid?)) .
    snd-note(event(proc(D,P), rule-created(Rid,Port,Cond,Acts,Life))) .
    snd-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid))
    +
    rec-msg(proc(D,P?), modify-rule(Rid?,Port?,Cond?,Acts?,Life?)) .
    snd-do(D, modify-rule(Rid,P,Port,Cond,Acts,Life)) .
    snd-note(event(proc(D,P), rule-modified(Rid,Port,Cond,Acts,Life)))
    +
    rec-msg(proc(D,P?), destroy-rule(Rid?)) .
    snd-do(D, destroy-rule(P,Rid))
    +
    rec-event(D, watchpoint(P?, Rid?, Exprs?)) .
    snd-note(event(proc(D,P), watchpoint(Rid, Exprs))) .
    snd-ack-event(D, watchpoint(P, Rid, Exprs))
    +
    rec-event(D, rule-destroyed(Rid?)) .
    snd-note(event(proc(D,P), rule-destroyed(Rid))) .
    snd-ack-event(D, rule-destroyed(Rid))
   ) * delta
endlet
@

%}}}
%{{{ process BROADCAST

This process just waits for event messages, and broadcasts them as
notes. When a process has an event to share it just sends it as a message.
Now the process can receive the note also.

<<process BROADCAST>>=
process BROADCAST is
let
  From : term,
  Ev   : term
in
  ( rec-msg(event(From?, Ev?)) .
    snd-note(event(From, Ev))
  ) * delta
endlet
@

%}}}

%{{{ process MASTER-CONTROL

The master control window gives the user an overview of all
debuggable systems currently running, and enables the user to 
activate the other debugger components.

<<process MASTER-CONTROL>>=
process MASTER-CONTROL is
let
  M     : master-control,
  D     : debug-adapter,
  P     : term,
  Name  : str,
  Tool  : term,
  Info  : list,
  Event : term
in
  subscribe(new-tool(<str>,<term>,<term>)) .
  execute(master-control, M?) .
  subscribe(event(<term>, dap-connected(<list>,<list>))) .
  subscribe(event(<term>, dap-disconnected)) .
  ( rec-note(new-tool(Name?, Tool?, Event?)) .
    snd-do(M, new-tool(Name, Tool, Event))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    printf("dap-connected received: %t\n", D) .
    snd-do(M, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(M, dap-disconnected(D))
    +
    rec-event(M, button(Tool?, Event?, D?)) .
    snd-msg(Tool, Event, D) .
    snd-ack-event(M, button(Tool, Event, D))
  ) * rec-event(M, tide-shutdown) .
  snd-ack-event(M, tide-shutdown) .
  shutdown("Thank you for using tide!\n")
endlet
@

%}}}
%{{{ process SOURCE-VIEWER

<<process SOURCE-VIEWER>>=
process SOURCE-VIEWER is
let
  S : source-viewer,
  D : debug-adapter,	%% Which debug adapter
  P : term,		%% List of processes (or in some cases 'all')
  Info : list,		%% Information about a debug adapter
  Rid : int,		%% Event rule identifier
  Port : term,		%% Event rule port
  Cond : term,		%% Event rule condition
  Acts : term,		%% Event rule actions
  Life : term,		%% Event rule lifetime
  Exprs: term,		%% A list of expression,value pairs
  Type : term		%% Rule type (handy to recognize the ack w.o. matching)
in
  execute(source-viewer, S?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,[[cpe,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-name,<term>]]))) .
  subscribe(event(<term>,current-port(<term>))) .
  snd-note(new-tool("View source", S, view-source)) .
  ( rec-msg(S, view-source, D?) .
    snd-do(S, view-source(D))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(S, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(S, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(S, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(S, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(S, rule-destroyed(D,P, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?,Exprs?))) .
    snd-do(S, watchpoint(D, P, Rid, Exprs))
    +
    rec-note(event(proc(D?,P?), current-port(Port?))) .
    snd-do(S, current-port(D,P,Port))
    +
    rec-event(S, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(S, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(S, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(S, destroy-rule(D,P,Rid))
    +
    rec-event(S, current-port(D?,P?,Port?)) .
    snd-msg(event(proc(D,P),current-port(Port))) .
    snd-ack-event(S, current-port(D,P,Port))
  ) * delta
endlet
@

%}}}
%{{{ process RULE-VIEWER

<<process RULE-VIEWER>>=
process RULE-VIEWER is
let
  R : rule-viewer,
  D : debug-adapter,
  P : term,
  Info : list,
  Port : term,
  Cond : term,
  Acts : term,
  Life : term,
  Rid  : int,
  Exprs: list, %% A list of [expression, value] pairs
  Type : term
in
  execute(rule-viewer, R?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-name,<term>]]))) .
  subscribe(event(<term>,current-port(<term>))) .
  snd-note(new-tool("View rules", R, view-rules)) .
  ( rec-msg(R, view-rules, D?) .
    snd-do(R, view-rules(D))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(R, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(R, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(R, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(R, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(R, rule-destroyed(D,P, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?, Exprs?))) .
    snd-do(R, watchpoint(D, P, Rid, Exprs))
    +
    rec-note(event(proc(D?,P?), current-port(Port?))) .
    snd-do(R, current-port(D,P,Port))
    +
    rec-event(R, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(R, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(R, modify-rule(Rid?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),modify-rule(Rid,Port,Cond,Acts,Life)) .
    snd-ack-event(R, modify-rule(Rid,D,P,Port,Cond,Acts,Life))
    +
    rec-event(R, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(R, destroy-rule(D,P,Rid))    
  ) * delta
endlet
@

%}}}
%{{{ process WATCHPOINT-VIEWER

<<process WATCHPOINT-VIEWER>>=
process WATCHPOINT-VIEWER is
let
  V    : watchpoint-viewer,
  D    : debug-adapter,
  P    : term,
  Info : list,
  Port : term,
  Cond : term,
  Acts : term,
  Life : term,
  Rid  : int,
  Exprs: list, %% A list of [expression, value] pairs
  Type : term
in
  execute(watchpoint-viewer, V?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,<list>))) .
  snd-note(new-tool("Create watchpoint", V, view-watchpoint)) .
  ( rec-msg(V, view-watchpoint, D?) .
    snd-do(V, view-watchpoint(D))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(V, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(V, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(V, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(V, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(V, rule-destroyed(D,P, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?, Exprs?))) .
    snd-do(V, watchpoint(D, P, Rid, Exprs))
    +
    rec-event(V, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    printf("watchpoint viewer created rule: %d\n", Rid) .
    snd-ack-event(V, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(V, modify-rule(Rid?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),modify-rule(Rid,Port,Cond,Acts,Life)) .
    snd-ack-event(V, modify-rule(Rid,D,P,Port,Cond,Acts,Life))
    +
    rec-event(V, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(V, destroy-rule(D,P,Rid))    
  ) * delta
endlet
@

%}}}

%{{{ process PROCESS-LIST

The process-list tool presents the user with a list of processes,
and their current execution state.

<<process PROCESS-LIST>>=
process PROCESS-LIST is
let
  PL : process-list,
  D : debug-adapter,	%% Which debug adapter
  P : term,		%% List of processes (or in some cases 'all')
  Info : list,		%% Information about a debug adapter
  Exprs: term,		%% A list of expression,value pairs
  Rid : int		%% Event rule identifier
in
  execute(process-list, PL?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-name,<term>]]))) .
  snd-note(new-tool("List processes", PL, list-processes)) .
  ( rec-msg(PL, list-processes, D?) .
    snd-do(PL, list-processes(D))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(PL, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(PL, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?,Exprs?))) .
    snd-do(PL, watchpoint(D, P, Rid, Exprs))
  ) * delta
endlet
@

%}}}






