
%{{{ tide.tb

<<tide.tb*>>=
<<process DAP-CONNECT>>
<<process TOOL-CONNECT>>
<<process EVENT-RULES>>
<<process TOOL>>
<<process BROADCAST>>
<<process MEMO>>
<<process MASTER-CONTROL>>

<<tool definitions>>

toolbus(DAP-CONNECT, TOOL-CONNECT, MASTER-CONTROL, MEMO, BROADCAST)
@

%}}}

%{{{ tool definitions

\subsection{Tool definitions}

In this section, we define the tools used in this ToolBus script.

<<tool definitions>>=
tool debug-adapter is { }
tool synthesizer is { command = "./synthesizer" }
tool master-control is { command =
	"tcltk-adapter -script master-control.tcl" }
%%tool viewer is { command = "./buscontrol" }
@

%}}}

%{{{ process DAP-CONNECT

<<process DAP-CONNECT>>=
process DAP-CONNECT is
let
  D    : debug-adapter,
  Pid  : int,
  Info : list
in
  ( rec-connect(D?) .
    snd-msg(get-info(D)) .
    rec-msg(get-info(D, Info?)) .
    printf("%t info: %t\n", D, Info) .
    snd-note(dap-connected(D, Info)) .
    create(EVENT-RULES(D), Pid?)
    +
    rec-disconnect(D?) .
    snd-note(dap-disconnected(D))
  ) * delta
endlet
@

%}}}
%{{{ process EVENT-RULES
\subsection{The event rule ToolBus process}

Figure \ref{event-rules} shows the event processing inside a debug
adapter. First the event port is used to determine which event
rules are activated. Then the event condition is used to filter
these activated event rules. Finally, triggering the event rule results in
the execution of actions that either change the
(execution) state of the process that generated the original
primitive event, or actions that generate watchpoint events
for the \master\ bus.

\begin{figure}[htb]
  \centerline{\epsfig{file=events.ps,scale=0.7}}
  \caption{\label{adapter-figure}Event processing inside a debug adapter}
\end{figure}

Because the interaction between a debug adapter and the \master\ 
is completely based on event rules, the 
interface between them can be described using the {\tt EVENT-RULE} 
\TB\ process given below.

By unifying all primitive debugging events using event rules,
the interaction between the debug adapters and the
\master\ can be described in one simple \TB\ process.
This process can:
\begin{itemize}
\item Create a new event rule. After creating the event rule,
      a message is broadcasted to inform all \master\ components
      that a new event rule exists.
\item Destroy an existing event rule. A message is broadcasted to
      inform everyone the event rule no longer exists.
\item Receive and broadcast watchpoint events. When a watchpoint is
      triggered, a message is broadcasted so all tools that depend on this
      watchpoint can update their view. 
\end{itemize}

<<process EVENT-RULES>>=
process EVENT-RULES(D:debug-adapter) is
let
  P     : term,   %% list of process-id's, or `all' indicating all
                  %% processes controlled by the debug adapter.
  Port  : term,   %% event port and modifier
  Cond  : term,   %% event condition
  Life  : term,   %% lifetime of an event rule
  Acts  : list,   %% event actions
  Rid   : int,    %% event rule identifier
  Expr  : term,   %% Watchpoint expression
  Value : term,   %% Value of an evaluated watchpoint expression
  Result: term    %% ok or error(<str>)
in
  ( rec-msg(proc(D,P?), create-rule(Port?,Cond?,Acts?,Life?)) .
    snd-eval(D, create-rule(P, Port,Cond,Acts,Life)) .
    rec-value(D, create-rule(P, Port,Cond,Acts,Life,Rid?)) .
    snd-note(event(proc(D,P), rule-created(Port,Cond,Acts,Life,Rid)))
    +
    rec-msg(proc(D,P?), destroy-rule(Rid?)) .
    snd-do(D, destroy-rule(P,Rid)) .
    snd-note(event(proc(D,P), rule-destroyed(Rid)))
    +
    rec-event(D, watchpoint(P?,Port?,Rid?,Expr?,Value?)) .
    snd-note(event(proc(D,P), watchpoint(Port,Rid,Expr,Value))) .
    snd-ack-event(D, watchpoint(P,Port,Rid,Expr,Value))
    +
    rec-event(D, rule-destroyed(Rid?)) .
    snd-note(event(proc(D,P), rule-destroyed(Rid))) .
    snd-ack-event(D, rule-destroyed(Rid))
   ) * delta
endlet
@

%}}}
%{{{ process SYNTHESIZER

<<process SYNTHESIZER>>=
process SYNTHESIZER is
let
  S     : synthesizer,
  Src   : term,
  Event : term,
  Port  : term,
  Cond  : term,
  Acts  : term,
  Life  : term
in
  execute(synthesizer, S?) .
  subscribe(event(<term>, <term>)) .
  ( rec-note(event(Src?, Event?)) .
    snd-do(S, event(Src, Event))
    +
    rec-event(S, event(Src?, Event?)) .
    snd-note(event(Src, Event)) .
    snd-ack-event(S, event(Src, Event))
    +
    rec-msg(synthesize-on(Event?)) .
    snd-eval(S, synthesize-on(Event)) .
    rec-value(S, synthesize-on(Event, Id?)) .
    snd-msg(synthesize-on(Event, Id))
    +
    rec-msg(synthesize-off(Id?)) .
    snd-do(synthesize-off(Id))
    +
    rec-event(S, create-rule(Src?, Port?, Cond?, Acts?, Life?)) .
    snd-msg(Src, create-rule(Port, Cond, Acts, Life)) .
    snd-ack-event(S, create-rule(Src, Port, Cond, Acts, Life))
  ) * delta
endlet
@

%}}}

%{{{ process MASTER-CONTROL

The master control window gives the user an overview of all
debuggable systems currently running, and enables the user to 
activate the other debugger components.

<<process MASTER-CONTROL>>=
process MASTER-CONTROL is
let
  M     : master-control,
  D     : debug-adapter,
  Name  : str,
  Info  : list,
  Event : term
in
  subscribe(tool-connected(<str>,<list>)) .
  execute(master-control, M?) .
  subscribe(dap-connected(<debug-adapter>,<list>)) .
  subscribe(dap-disconnected(<debug-adapter>)) .
  ( rec-note(new-tool(Name?, Event?)) .
    snd-do(M, new-tool(Name, Event))
    +
    rec-note(dap-connected(D?, Info?)) .
    snd-do(M, dap-connected(D, Info))
    +
    rec-note(dap-disconnected(D?)) .
    snd-do(M, dap-disconnected(D))
    +
    rec-event(M, button(Event?)) .
    snd-msg(Event) .
    snd-ack-event(M, button(Event))
  ) * rec-event(M, tide-shutdown) .
  snd-ack-event(M, tide-shutdown) .
  shutdown("Thank you for using tide!\n")
endlet
@

%}}}

%{{{ process BROADCAST

This process just waits for event messages, and broadcasts them as
notes. When a process has an event to share it just sends it as a message.
Now the process can receive the note also.

<<process BROADCAST>>=
process BROADCAST is
let
  From : term,
  Ev   : term
in
  ( rec-msg(event(From?, Ev?)) .
    snd-note(event(From, Ev))
  ) * delta
endlet
@

%}}}




