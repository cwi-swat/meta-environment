
%{{{ tbview.py

The file {\tt tbview.py} implements the ToolBus viewer.
It controls a number of view windows that each show a ToolBus
in action.  Each {\tt TBObject} ({\tt Tool}, or
{\tt Process}) can have a number of features that are dynamically
changing.
From within the ToolBus buttons and menus can be added
and actions can be attached to them. These user interface objects
can be activated/deactivated based on the features of the currently
selected {\tt TBObject}.

<<tbview.py>>=
<<imports>>
<<utility>>

<<class TBObject>>
<<class Tool>>
<<class Process>>

<<class TBViewer>>
<<class ToolBus>>

<<ToolBus interface functions>>

tbs = { }

# Every ToolBus instance starts with these lists of UI items:
button_list = [ ]
toolbar_button_list = [ ]
menu_list = [ ]

TB.enableTk()
cid = TB.parseArgs(sys.argv, __main__)
TB.connect(cid)

dummy = Frame()
dummy.master.withdraw()
dummy.mainloop()
@

%}}}

%{{{ imports

<<imports>>=
import __main__
import sys
import types
import string
import regexp

import TB

from Tkinter import *

from fset import *
from extui import *
@

%}}}
%{{{ utility
Here, some handy utility functions are defined.
<<utility>>=
def is_odd(i):
	return i % 2 == 1

def is_even(i):
	return i % 2 == 0 
@
%}}}

%{{{ class TBObject

The class {\tt TBObject} is used as an abstract base class
for the two object types: {\tt Tool}, and {\tt Process}.
It implements the common interface of the two.
<<class TBObject>>=
class TBObject(FeatureSet):
	<<TBObject.__init__>>
	<<TBObject.get_id>>
	<<TBObject.get_name>>
	<<TBObject.set_name>>
	<<TBObject.get_info>>
	<<TBObject.get_position>>
	<<TBObject.set_size>>
	<<TBObject.get_size>>
	<<TBObject.get_canvas>>
	<<TBObject.move>>
	<<TBObject.map>>
	<<TBObject.unmap>>
	<<TBObject.select>>
	<<TBObject.unselect>>
	<<TBObject.add_item>>
	<<TBObject.remove_item>>
	<<TBObject.set_peer>>
	<<TBObject.get_peer>>
	<<TBObject.remove_communication>>

	ObjectNotMapped = "ObjectNotMapped"
@

%{{{ __init__

<<TBObject.__init__>>=
def __init__(self, ID, name, features):
	FeatureSet.__init__(self, features)
	self.ID = ID
	self.name = name
	self.ismapped = 0
	self.selected = 0
	self.canvas = None
	self.peer = None
	self.com_item = None
@

%}}}
%{{{ get_id

<<TBObject.get_id>>=
def get_id(self):
	return self.ID
@

%}}}
%{{{ get_name

<<TBObject.get_name>>=
def get_name(self):
	return self.name
@

%}}}
%{{{ set_name

<<TBObject.set_name>>=
def set_name(self, name):
	self.name = name
@

%}}}
%{{{ get_info

<<TBObject.get_info>>=
def get_info(self):
	return str(self.ID)
@

%}}}
%{{{ get_position

<<TBObject.get_position>>=
def get_position(self):
	if not self.ismapped:
		raise TBObject.ObjectNotMapped
	else:
		return self.pos
@

%}}}
%{{{ set_size

<<TBObject.set_size>>=
def set_size(self, size):
	self.size = size
@

%}}}
%{{{ get_size

<<TBObject.get_size>>=
def get_size(self):
	return self.size
@

%}}}
%{{{ get_canvas

<<TBObject.get_canvas>>=
def get_canvas(self):
	return self.canvas
@

%}}}

%{{{ move

<<TBObject.move>>=
def move(self, pos):
	if not self.ismapped:
		raise TBObject.ObjectNotMapped
	else:
		delta = pos - self.pos
		for item in self.items:
			coords = self.canvas.coords(item)
			coords = coords + delta
			self.canvas.coords(item, coords)
@

%}}}
%{{{ map

<<TBObject.map>>=
def map(self, canvas, pos):
	self.canvas = canvas
	self.pos = pos
	self.ismapped = 1
	self.items = []
@

%}}}
%{{{ unmap

<<TBObject.unmap>>=
def unmap(self):
	if not self.ismapped:
		raise TBObject.ObjectNotMapped
	else:
		for item in self.items:
			self.canvas.delete(item)
		self.items = []
		self.selected = 0
		self.ismapped = 0
@

%}}}
%{{{ select

<<TBObject.select>>=
def select(self):
	if not self.ismapped:
		raise TBObject.ObjectNotMapped
	else:
		if not self.selected:
			size = self.get_size()
			self.selected_item = self.canvas.create_rectangle(
				self.pos[0]+2,self.pos[1]+2, 
				self.pos[0]+size[0]-2, self.pos[1]+size[1]-2,
				{"outline":"blue"})
			self.selected = 1
			self.add_item(self.selected_item)
@

%}}}
%{{{ unselect

<<TBObject.unselect>>=
def unselect(self):
	if not self.ismapped:
		raise TBObject.ObjectNotMapped
	else:
		if self.selected:
			self.canvas.delete(self.selected_item)
			self.selected = 0
			self.remove_item(self.selected_item)
@

%}}}
%{{{ add_item

{\tt add\_item} registers graphic items drawn on behalf of this object.
<<TBObject.add_item>>=
def add_item(self, item):
	self.items.append(item)
@

%}}}
%{{{ remove_item

{\tt remove\_item} removes a graphic item from the objects list of items.
<<TBObject.remove_item>>=
def remove_item(self, item):
	self.items.remove(item)
@

%}}}

%{{{ set_peer

<<TBObject.set_peer>>=
def set_peer(self, peer, item):
	self.peer = peer
	self.com_item = item
@

%}}}
%{{{ get_peer

<<TBObject.get_peer>>=
def get_peer(self):
	return self.peer
@

%}}}
%{{{ remove_communication

<<TBObject.remove_communication>>=
def remove_communication(self):
	#print "removing communication from object: %s(%d)"%(self.name,self.ID)
	if self.ismapped and self.peer != None and self.com_item != None:
		self.canvas.delete(self.com_item)
		self.peer.set_peer(None, None)
		self.peer = None
		self.com_item = None
@

%}}}

%}}}
%{{{ class Tool
The class Tool represents a tool connected to the ToolBus.

<<class Tool>>=
class Tool(TBObject):
	<<Tool.get_tid>>
	<<Tool.map>>
	<<Tool.satisfies>>
	<<Tool.set_chook>>
	<<Tool.get_anchor>>
	<<Tool.get_connection_stub>>
	<<Tool.is_process>>
@

%{{{ get_tid

<<Tool.get_tid>>=
def get_tid(self):
	return self.get_id()
@

%}}}
%{{{ map

The {\tt map} function draws a tool on a canvas.
<<Tool.map>>=
def map(self, canvas, pos):
	if not self.ismapped:
		TBObject.map(self, canvas, pos)
		(x,y) = pos
		(w,h) = self.get_size()
		canvas.create_rectangle(x+4, y+4, x+w-4, y+h-4,
			{ "outline":"black", "fill":"LightSeaGreen" })
		# Draw text in the tool
		name = str(self.get_id())
		index = string.rfind(name,"(")
		if index >= 0:
			ID = name[index+1:-1]
			name = name[:index]
		else:
			ID = ""
		text = ""
		if self.has_feature("language"):
			text = str(self.get_feature("language"))[:7] + "\n"
		text = text + self.get_name() + "\n"
		text = text + str(self.get_id())
		canvas.create_text(x+(w/2), y+(h/2), { "text":text,
			"justify":"center", "fill":"black", 
				"font":"*misc*fixed*medium*10*" })

		canvas.create_line(self.get_connection_stub(0),
					{ "fill":"black", "width":"1" })
@

%}}}
%{{{ satisfies

Every {\tt Tool} object also satisfies the constraint "tool".

<<Tool.satisfies>>=
def satisfies(self, constraint):
	if constraint == "tool":
		return 1
	else:
		return TBObject.satisfies(self, constraint)
@

%}}}
%{{{ set_chook

Set the communication hook position of this tool.
Do not forget to shift the starting position because
of the fact that the tool picture is actually smaller
than the slot size.

<<Tool.set_chook>>=
def set_chook(self, chook):
	# Account for shifting of tool within
	# tool slot
	(anchor, cx1, cy1, cx2, cy2) = chook
	if anchor == "north":
		dx = 0
		dy = -4
	if anchor == "south":
		dx = 0
		dy = 4
	if anchor == "east":
		dx = 4
		dy = 0
	if anchor == "west":
		dx = -4
		dy = 0

	self.chook = (anchor, cx1+dx, cy1+dy, cx2, cy2)
@

%}}}
%{{{ get_anchor

<<Tool.get_anchor>>=
def get_anchor(self):
	(anchor, cx1, cy1, cx2, cy2) = self.chook
	return anchor
@

%}}}
%{{{ get_connection_stub

<<Tool.get_connection_stub>>=
def get_connection_stub(self, src):
	if not self.ismapped:
		raise TBObject.ObjectNotMapped
	else:
		(anchor, cx1, cy1, cx2, cy2) = self.chook
		if src:
			return [(cx1,cy1),(cx2,cy2)]
		else:
			return [(cx2,cy2),(cx1,cy1)]
@

%}}}
%{{{ is_process

<<Tool.is_process>>=
def is_process(self):
	return 0
@

%}}}

%}}}
%{{{ class Process

The class Process represents a process inside the ToolBus.

<<class Process>>=
class Process(TBObject):
	<<Process.get_pid>>
	<<Process.map>>
	<<Process.highlight>>
	<<Process.unhighlight>>
	<<Process.satisfies>>
	<<Process.is_process>>
@

%{{{ get_pid

<<Process.get_pid>>=
def get_pid(self):
	return self.get_id()
@

%}}}
%{{{ map

The {\tt map} function draws a process on a canvas.
<<Process.map>>=
def map(self, canvas, pos):
	if not self.ismapped:
		TBObject.map(self, canvas, pos)
		(x,y) = pos
		(w,h) = self.get_size()
		self.oval = canvas.create_oval(x+6, y+6, x+w-6, y+h-6,
			{ "outline":"black", "fill":"MediumSeaGreen" })
		# Draw text in the process
		name = self.get_name()
		pid = str(self.get_id())
		text = name[:7] + "\n" + pid
		canvas.create_text(x+(w/2), y+(h/2), { "text":text,
			"justify":"center", "fill":"black", 
				"font":"*misc*fixed*medium*10*" })
@

%}}}
%{{{ highlight

<<Process.highlight>>=
def highlight(self):
	if self.ismapped:
		self.canvas.itemconfig(self.oval, {"fill":"green"})
@

%}}}
%{{{ unhighlight

<<Process.unhighlight>>=
def unhighlight(self):
	if self.ismapped:
		self.canvas.itemconfig(self.oval, {"fill":"MediumSeaGreen"})
@

%}}}
%{{{ satisfies

Every {\tt Process} object also satisfies the constraint "proc".

<<Process.satisfies>>=
def satisfies(self, constraint):
	if constraint == "proc":
		return 1
	else:
		return TBObject.satisfies(self, constraint)
@

%}}}
%{{{ is_process

<<Process.is_process>>=
def is_process(self):
	return 1
@

%}}}

%}}}

%{{{ class TBViewer

The class {\tt TBviewer} implements the display capabilities of the
{\tt ToolBus} class.



\footnote{I think I should have made TBViewer a super-class of
ToolBus, but I'm not sure. This is probably worth investigating.}

<<class TBViewer>>=
class TBViewer(Toplevel,ExtensibleUI):
	<<TBViewer.__init__>>
	<<TBViewer.hide>>
	<<TBViewer.show>>
	<<TBViewer.get_tb_canvas>>
	<<TBViewer.get_current_object>>
	<<TBViewer.create_widgets>>

	# The following methods are 'private'
	<<TBViewer.get_button_frame>>
	<<TBViewer.get_scroll_pos>>
@

%{{{ __init__

<<TBViewer.__init__>>=
def __init__(self, tb, master=None):
	Toplevel.__init__(self,master)
	self.withdraw()
	self.create_widgets()
	ExtensibleUI.__init__(self, tb, 
		self.menu, self.toolbar, self.view.buttons)
	#self.pack({ "expand":"1", "fill":"both" })
	self.geometry("460x324")
	self.title("ToolBus viewer")
        self.tb = tb
@

%}}}
%{{{ hide

<<TBViewer.hide>>=
def hide(self):
	self._root().withdraw()
@

%}}}
%{{{ show

<<TBViewer.show>>=
def show(self):
	self.deiconify()
@

%}}}
%{{{ create_widgets

Create the widgets associated with a certain ToolBus viewer window.

<<TBViewer.create_widgets>>=
def create_widgets(self):
	self.menu = Frame(self)
	self.toolbar = Frame(self, {"borderwidth":"0"})
	self.view = Frame(self, {"borderwidth":"2", "relief":"groove"})
	self.view.buttons = Frame(self.view, {"borderwidth":"2", "relief":"sunken"})
	self.view.toolbus = Frame(self.view, { "borderwidth":"2", "relief":"groove"})
	self.view.toolbus.canvas = Canvas(self.view.toolbus,
		{ "width" : "385",	"height" : "320",
		  "bg"    : "white",
		#  "scrollregion"     : ("0", "0", "385", "320"),
		  "borderwidth" : "2",	"relief" : "groove"})
	self.view.toolbus.canvas.scrollx = \
	    Scrollbar(self.view.toolbus.canvas, {"orient" : "horizontal"})
	self.view.toolbus.canvas.scrolly = \
	    Scrollbar(self.view.toolbus.canvas, {"orient" : "vertical"})

	self.view.buttons.label = Label(self.view.buttons, {"text":"Buttons:"})
	self.info = Frame(self, {"borderwidth":"2", "relief":"groove"})

	# Connect scrollbars to canvas
	self.view.toolbus.canvas["xscrollcommand"] = self.view.toolbus.canvas.scrollx.set
	self.view.toolbus.canvas["yscrollcommand"] = self.view.toolbus.canvas.scrolly.set
	self.view.toolbus.canvas.scrollx["command"] = self.view.toolbus.canvas.xview
	self.view.toolbus.canvas.scrolly["command"] = self.view.toolbus.canvas.yview

	# Pack all widgets
	self.menu.pack({"side":"top", "fill":"x"})
	self.toolbar.pack({"side":"top", "fill":"x"})
	self.view.pack({"side":"top", "fill":"both", "expand":"1"})
	self.info.pack({"side":"top", "fill":"x"})

	self.view.buttons.pack({"side":"left", "fill":"y"})
	self.view.buttons.label.pack({"side":"top", "fill":"x"})
	self.view.toolbus.pack({"side":"right", "fill":"both", "expand":"1"})
	self.view.toolbus.canvas.pack({"side":"left", "expand" : "1", "fill":"both"})
	self.view.toolbus.canvas.scrollx.pack({"side":"bottom", "fill":"x"})
	self.view.toolbus.canvas.scrolly.pack({"side":"right", "fill":"y"})
@

%}}}
%{{{ get_tb_canvas

<<TBViewer.get_tb_canvas>>=
def get_tb_canvas(self):
	return self.view.toolbus.canvas
@

%}}}
%{{{ get_current_object

<<TBViewer.get_current_object>>=
def get_current_object(self):
	return self.tb.get_current_object()	
@

%}}}

%{{{ get_button_frame

<<TBViewer.get_button_frame>>=
def get_button_frame(self):
	return self.view.buttons
@

%}}}
%{{{ get_scroll_pos

<<TBViewer.get_scroll_pos>>=
def get_scroll_pos(self):
	sx = self.view.toolbus.canvas.scrollx
	sy = self.view.toolbus.canvas.scrolly
	xpair = sx.tk.call(sx._w, 'get')
	ypair = sy.tk.call(sy._w, 'get')
	xlist = map(string.atof, string.split(xpair))
	ylist = map(string.atof, string.split(ypair))
	return (xlist[0], ylist[0])
@

%}}}

%}}}
%{{{ class ToolBus

The class {\tt ToolBus} represents a ToolBus object. It contains
all processes and tools.

<<class ToolBus>>=
class ToolBus(FeatureSet):
	<<ToolBus.__init__>>
	<<ToolBus.show>>
	<<ToolBus.hide>>
	<<ToolBus.add_button>>
	<<ToolBus.add_toolbar_button>>
	<<ToolBus.delete_button>>
	<<ToolBus.add_tool>>
	<<ToolBus.add_process>>
	<<ToolBus.change_tool>>
	<<ToolBus.change_tool_name>>
	<<ToolBus.change_process>>
	<<ToolBus.get_tool>>
	<<ToolBus.get_process>>
	<<ToolBus.get_current_object>>
	<<ToolBus.communication>>
	<<ToolBus.remove_communication>>
	<<ToolBus.highlight_process>>
	<<ToolBus.disconnected>>
	<<ToolBus.action>>

	# These methods are 'private'
	<<ToolBus.mouse_down>>
	<<ToolBus.shift_mouse_down>>
	<<ToolBus.draw_toolbus>>
	<<ToolBus.calc_slots>>
	<<ToolBus.outline_slots>>
	<<ToolBus.get_proc_slot_pos>>
	<<ToolBus.get_tool_slot_pos>>
	<<ToolBus.get_object_at_pos>>
	<<ToolBus.get_tool_slot_nr>>
	<<ToolBus.get_proc_slot_nr>>
	<<ToolBus.get_free_tool_slot>>
	<<ToolBus.get_free_proc_slot>>
	<<ToolBus.get_tool_chook>>
	<<ToolBus.is_proc>>
	<<ToolBus.is_tool>>
	<<ToolBus.get_gp>>
	<<ToolBus.gp_pos>>
	<<ToolBus.gps_to_positions>>
	<<ToolBus.plan_path>>
@
%{{{ __init__

<<ToolBus.__init__>>=
def __init__(self, ID, features = []):
	# Calll base class constructor
	FeatureSet.__init__(self, features)

	# Guess some sizes
	self.ph = 11
	self.pv = 3
	self.th = 15
	self.tv = 6

	# The corner tool slots are not interesting.
	self.forbidden_tools = [0, self.th-1, self.th, self.th*2-1]

	self.tool_size	= (48, 64)
	self.proc_size	= (48, 48)
	self.tb_size	= (self.proc_size[0]*(self.ph+1),
			   self.proc_size[1]*(self.pv+1))
	self.tb_pos = (self.tool_size[0]*1.5, self.tool_size[1]*1.5)

	# Initialize attributes
	self.slots = { }
	self.tools = { }
	self.procs = { }
	self.tool_by_tid = { }
	self.proc_by_pid = { }
	self.ID = ID
	self.viewer = TBViewer(self)
	self.viewer._root().withdraw()
	self.ismapped = 0
	self.last_highlighted = None
	self.canvas = self.viewer.get_tb_canvas()
	self.canvas["scrollregion"] = "%d %d %d %d" % \
	    (0, 0, self.th*self.tool_size[0], self.tv*self.tool_size[1])
	self.canvas["xscrollincrement"] = self.tool_size[0]
	self.canvas["yscrollincrement"] = self.tool_size[1]
	self.current_objects = []
	Widget.bind(self.canvas, "<1>", self.mouse_down)
	Widget.bind(self.canvas, "<Shift-Button-1>", self.shift_mouse_down)
	
	self.draw_toolbus()
	self.calc_slots()

	# Just for debugging:
	#self.outline_slots()
@

%}}}
%{{{ show

The {\tt show} method maps the ToolBus window so it is
visible, and brings it to the front of the display list.
<<ToolBus.show>>=
def show(self):
	if not self.ismapped:
		self.ismapped = 1
		self.viewer.show()
	self.viewer.tkraise()		
@

%}}}
%{{{ hide

The {\tt show} method unmaps the ToolBus window so it is
no longer visible.
<<ToolBus.hide>>=
def hide(self):
	if self.ismapped:
		self.ismapped = 0
		self.viewer.hide()
@

%}}}
%{{{ add_button

<<ToolBus.add_button>>=
def add_button(self, group, text, event, constraints):
	self.viewer.add_button(group, text, event, constraints)
	self.viewer.update_ui(self.current_objects)
@

%}}}
%{{{ add_toolbar_button

<<ToolBus.add_toolbar_button>>=
def add_toolbar_button(self, group, file, event, constraints):
	self.viewer.add_toolbar_button(group, file, event, constraints)
	self.viewer.update_ui(self.current_objects)
@

%}}}
%{{{ delete_button

<<ToolBus.delete_button>>=
def delete_button(self, text):
	self.viewer.delete_button(self, text)
@

%}}}
%{{{ add_tool

For now, when adding a tool the first free position is used.
Later we might want to use a more sophisticated placing strategy.
<<ToolBus.add_tool>>=
def add_tool(self, tool):
	self.tools[tool.get_id()] = tool
	self.tool_by_tid[tool.get_tid()] = tool
	tool.set_size(self.tool_size)
	slot_nr = self.get_free_tool_slot()
	if slot_nr == -1:
		# Now we should expand the ToolBus to allow for more tools
		print "expanding of ToolBus not implemented yet!"
	self.tool_slots[slot_nr] = tool.get_id()
	chook = self.get_tool_chook(slot_nr)
	tool.set_chook(chook)
	tool.map(self.canvas, self.get_tool_slot_pos(slot_nr))
@

%}}}
%{{{ add_process

For now, when adding a process the first free position is used.
Later we might want to use a more sophisticated placing strategy.
<<ToolBus.add_process>>=
def add_process(self, proc):
	self.procs[proc.get_id()] = proc
	self.proc_by_pid[proc.get_pid()] = proc
	proc.set_size(self.proc_size)
	slot_nr = self.get_free_proc_slot()
	if slot_nr == -1:
		# Now we should expand the ToolBus to allow for more tools
		print "expanding of ToolBus not implemented yet!"
	self.proc_slots[slot_nr] = proc.get_id()
	proc.map(self.canvas, self.get_proc_slot_pos(slot_nr))
@

%}}}
%{{{ change_tool

Change some features of a tool.
<<ToolBus.change_tool>>=
def change_tool(self, ID, new_features):
	self.tools[ID].change(new_features)
@

%}}}
%{{{ change_tool_name

Change the name of a tool.

<<ToolBus.change_tool_name>>=
def change_tool_name(self, Tid, name):
	self.tools[Tid].set_name(name)
@

%}}}
%{{{ change_process

<<ToolBus.change_process>>=
def change_process(self, ID, new_features):
	self.procs[ID].change(new_features)
@

%}}}
%{{{ get_tool

{\tt get\_tool} retrieves a tool with a given {\tt ID}. {\tt None} 
is returned when a tool with {\tt ID} is not present.
<<ToolBus.get_tool>>=
def get_tool(self, ID):
	if self.tools.has_key(ID):
		return self.tools[ID]
	else:
		return None
@

%}}}
%{{{ get_process

{\tt get\_process} retrieves a process with a given {\tt ID}. {\tt None} 
is returned when a process with {\tt ID} is not present.

<<ToolBus.get_process>>=
def get_process(self, ID):
	if self.procs.has_key(ID):
		return self.procs[ID]
	else:
		return None
@

%}}}
%{{{ get_current_objects

Retrieve the set of current objects.

<<ToolBus.get_current_object>>=
def get_current_objects(self):
	return self.current_objects
@

%}}}
%{{{ communication

<<ToolBus.communication>>=
def communication(self, type, src, dest, term):
	#print "type: %s, src: %s, dest: %s (%s)" % (type, str(src), str(dest),str(term))

	src_id = src.get_id()
	dest_id = dest.get_id()
		
	# Calculate the positions from which to start
	src_gp = self.get_gp(src)
	dest_gp = self.get_gp(dest)
	src_pos = self.gp_pos(src_gp)
	dest_pos = self.gp_pos(dest_gp)

	if type == "tool-proc":
		prefix = self.tools[src].get_connection_stub(1)
	else:
		prefix = []

	if type == "proc-tool":
		postfix = self.tools[dest_id].get_connection_stub(0)
	else:
		postfix = []

	gps = self.plan_path(src_gp, dest_gp)
	# "3", "black", "last"
	#print "To come from %s to %s we could do: " % (str(src_gp), str(dest_gp))
	
	positions = self.gps_to_positions(gps)

	# Only draw arrows until process borders (somewhat of a hack ;-()
	<<chop lines at process borders (*hack*)>>

	# Possibly add tool connection stub
	positions[0:0] = prefix
	positions[-1:-1] = postfix

	# Draw the actual lines
	item = self.canvas.create_line(positions, 
	 {"width":"1", "fill":"red", "arrow":"last", "arrowshape":"2 4 5"})

	if src != None:
		src.set_peer(dest, item)
	if dest != None:
		dest.set_peer(src, item)

@
%{{{ chop lines at process borders (*hack*)

<<chop lines at process borders (*hack*)>>=
if src.is_process():
	first = positions[0]
	next = positions[1]
	if first[0] == next[0] or first[1] == next[1]:
		first = ((next[0]+(first[0]-next[0])*0.25), 
		 	 (next[1]+(first[1]-next[1])*0.25))
	else:
		first = ((next[0]+(first[0]-next[0])*.45),
			 (next[1]+(first[1]-next[1])*.45))
	positions[0] = first
if dest.is_process():
	last = positions[-1]
	prev = positions[-2]
	if last[0] == prev[0] or last[1] == prev[1]:
		last = ((prev[0]+(last[0]-prev[0])*0.25), 
		 	 (prev[1]+(last[1]-prev[1])*0.25))
	else:
		last = ((prev[0]+(last[0]-prev[0])*.45),
			 (prev[1]+(last[1]-prev[1])*.45))
	positions[-1] = last
@

%}}}

%}}}
%{{{ remove_communication

<<ToolBus.remove_communication>>=
def remove_communication(self, pid):
	proc = self.get_process(pid)

	if proc != None:
		proc.remove_communication()
@

%}}}
%{{{ highlight_process

Highlight a process that has just executed an atom.

<<ToolBus.highlight_process>>=
def highlight_process(self, pid):
	proc = self.get_process(pid)

	if self.last_highlighted != None:
		self.last_highlighted.unhighlight()
	if proc != None:
		proc.highlight()
		self.last_highlighted = proc
@

%}}}

%{{{ disconnected

A slave ToolBus has been disconnected. 
Destroy the window associated with it.

<<ToolBus.disconnected>>=
def disconnected(self):
	# I've got a hunch that this doesn't free all
	# the resources (not even after garbage collection)
	self.viewer.destroy()
        self.viewer._root().withdraw()
@

%}}}
%{{{ action

The user activated one of the user interface elements.
Sent the apropriate event.

<<ToolBus.action>>=
def action(self, type, event, constraints):
	global cid

	try:
		if self.current_objects:
			tools = []
			procs = []
			for obj in self.current_objects:
				if obj.is_process():
					procs.append(TB.make("<int>", obj.get_pid()))
				else:
					tools.append(TB.make("<int>", obj.get_tid()))
			Ev = TB.make("snd-event(%s(%s,%s,<list>,<list>))" % 
				(type, self.ID, event), tools, procs)
			TB.send(cid, Ev)
		else:
			Ev = TB.make("snd-event(%s(%s,%s,[],[]))" % 
							(type, self.ID, event))
			TB.send(cid, Ev)
	except:
		print sys.exc_type
		print sys.exc_value
		print sys.exc_trace
@

%}}}

The following methods are sort of private to the ToolBus class.
They should not be called by objects other than ToolBus objects.

%{{{ mouse_down

This method is called when the user presses the left
mouse-button in the ToolBus canvas window. When possible,
the old selection is cleared, and a new tool/process
is selected. Also, the apropriate user interface items
are (de-)activated.

<<ToolBus.mouse_down>>=
def mouse_down(self, event):
	(sx,sy) = self.viewer.get_scroll_pos()
	(w,h) = (self.th*self.tool_size[0],self.tv*self.tool_size[1])
	(px,py) = (int(sx*w),int(sy*h))
	(x,y) = (px+event.x, py+event.y) 
	if self.current_objects != []:
		for obj in self.current_objects:
			obj.unselect()
	new_obj = self.get_object_at_pos((x, y))
	if new_obj == None:
		self.current_objects = []
	else:
		new_obj.select()
		self.current_objects = [new_obj]
	self.viewer.update_ui(self.current_objects)
@

%}}}
%{{{ shift_mouse_down

This method is called when the user presses the left
mouse-button together with the shift button in the ToolBus 
canvas window. 
When possible, a new tool/process is added to the selection.

<<ToolBus.shift_mouse_down>>=
def shift_mouse_down(self, event):
	print "shift_mouse_down!"
	(sx,sy) = self.viewer.get_scroll_pos()
	(w,h) = (self.th*self.tool_size[0],self.tv*self.tool_size[1])
	(px,py) = (int(sx*w),int(sy*h))
	(x,y) = (px+event.x, py+event.y)
	new_obj = self.get_object_at_pos((x, y))
	if new_obj != None:
		self.current_objects.append(new_obj)
		new_obj.select()
		self.viewer.update_ui(self.current_objects)
@

%}}}

%{{{ draw_toolbus

<<ToolBus.draw_toolbus>>=
def draw_toolbus(self):
	(x1,y1) = self.tb_pos
	x2 = x1 + self.tb_size[0]
	y2 = y1 + self.tb_size[1]

	self.canvas.create_rectangle(x1, y1, x2, y2,
		{"outline":"black", "fill":"lavender"})
	#self.canvas.create_text(x1+8,y1+8,
	#	{ "text":str(self.ID), "fill":"black", "anchor":"w" })
@

%}}}
%{{{ calc_slots

The method {\tt calc\_slots} creates as much tool and proc
slots as are needed for this ToolBus object.

<<ToolBus.calc_slots>>=
def calc_slots(self):
	self.nr_tool_slots = self.th*2 + (self.tv - 2)*2
	self.tool_slots = [ ]
	for i in range(self.nr_tool_slots):
		self.tool_slots.append(None)

	self.nr_proc_slots = self.ph * self.pv
	self.proc_slots = [ ]
	for i in range(self.nr_proc_slots):
		self.proc_slots.append(None)
@
%}}}
%{{{ outline_slots

This methods outlines all the proc and tool slots,
just for debugging purposes.

<<ToolBus.outline_slots>>=
def outline_slots(self):
	for i in range(self.nr_tool_slots):
		if i not in self.forbidden_tools:
			(x,y) = self.get_tool_slot_pos(i)
			(w,h) = self.tool_size
			(anchor, cx1, cy1, cx2, cy2) = self.get_tool_chook(i)
			self.canvas.create_rectangle(x, y, x+w, y+h,
				{"outline":"grey"})
			# Draw the connection hook
			self.canvas.create_line(cx1,cy1,cx2,cy2,{"fill":"grey"})
			self.canvas.create_text(x+4, y+8, 
				{"text":"%d" % i, "anchor":"w", "fill":"grey"})
	for i in range(self.nr_proc_slots):
		(x,y) = self.get_proc_slot_pos(i)
		(w,h) = self.proc_size
		self.canvas.create_rectangle(x, y, x+w, y+h,
			{"outline":"grey"})
		self.canvas.create_text(x+4,y+8, 
			{"text":"%d" % i, "anchor":"w", "fill":"grey"})
@

%}}}

%{{{ get_proc_slot_pos

The method {\tt get\_proc\_slot\_pos} calculates the position of a
certain (numbered) proc slot.

<<ToolBus.get_proc_slot_pos>>=
def get_proc_slot_pos(self, nr):
	x = nr % self.ph
	y = nr / self.ph
	px = self.tb_pos[0] + (x+0.5)*self.proc_size[0]
	py = self.tb_pos[1] + (y+0.5)*self.proc_size[1]
	return (px, py)
@

%}}}
%{{{ get_tool_slot_pos

The method {\tt get\_tool\_slot\_pos} calculates the position of a
certain (numbered) tool slot.

<<ToolBus.get_tool_slot_pos>>=
def get_tool_slot_pos(self, nr):
	if nr < self.th:
		# It's a northern tool
		x = nr*self.tool_size[0]
		y = 0

	elif nr < 2*self.th:
		# It's a southern tool
		x = (nr-self.th)*self.tool_size[0]
		y = (self.tv-1)*self.tool_size[1]

	elif nr < 2*self.th+self.tv-2:
		# It's an western tool
		x = 0
		y = (nr-2*self.th+1)*(self.tool_size[1])

	else: 
		# It must be an eastern tool
		x = (self.th-1)*self.tool_size[0]
		y = (nr-2*self.th+1-self.tv+2)*(self.tool_size[1])

	return (x, y)
@

%}}}
%{{{ get_object_at_pos

The method {\tt get\_object\_at\_pos} retrieves the object at a certain
canvas position. It hides much of the meat of the position calculation
(together with {\tt get\_tool/proc\_slot\_pos}, which in a sense does the
inverse of this function).

<<ToolBus.get_object_at_pos>>=
def get_object_at_pos(self, (x,y)):
	if (y < self.tool_size[1] and 
	    x < self.tool_size[0]*self.th):
		# It must be a tool on the first row
		#print "tool on the first row"
		nr = x/self.tool_size[0]
	elif (y > self.tool_size[1]*(self.tv-1) and
	      y < self.tool_size[1]*self.tv and
              x < self.tool_size[0]*self.th) :
		# It must be a tool on the last row
		#print "tool on the last row"
		nr = x/self.tool_size[0] + self.th
	elif (x < self.tool_size[0] and 
	      y < self.tool_size[1]*self.tv):
		# It must be a tool on the first column
		#print "tool on the first column"
		nr = y/self.tool_size[1] + 2*self.th - 1
	elif (x > self.tool_size[0]*(self.th-1) and 
	      x < self.tool_size[0]*self.th and
	      y < self.tool_size[1]*self.tv):
		# It must be a tool on the last column
		#print "tool on the last column"
		nr = y/self.tool_size[1] + 2*self.th + self.tv - 3
	else:
		# It's not a tool!
		#print "tb_pos = %d,%d" % self.tb_pos
		if x > self.tb_pos[0] and x < self.tb_pos[0]+self.tb_size[0] \
		    and y > self.tb_pos[1] and y < self.tb_pos[1]+self.tb_size[1]:
			xrel = int((x - self.tb_pos[0])/self.proc_size[0] - 0.5)
			yrel = int((y - self.tb_pos[1])/self.proc_size[1] - 0.5)
			if xrel >= 0 and xrel < self.ph and yrel >= 0 and yrel < self.pv:
				#print "rel = %d,%d, self.ph=%d" % (xrel, yrel, self.ph)
				nr = xrel + yrel*self.ph
				#print "proc nr %d" % nr
				if self.proc_slots[nr] == None:
					return None
				return self.procs[self.proc_slots[nr]]

		#print "no object underneath"
		return None

	# It was a tool
	# print "tool nr %d" % nr
	if self.tool_slots[nr] == None:
		return None
	return self.tools[self.tool_slots[nr]]
@

%}}}
%{{{ get_tool_slot_nr

Retrieve the slot number of a tool.

<<ToolBus.get_tool_slot_nr>>=
def get_tool_slot_nr(self, id):
	if id in self.tool_slots:
		return self.tool_slots.index(id)
	else:
		return -1
@

%}}}
%{{{ get_proc_slot_nr

Retrieve the slot number of a process.

<<ToolBus.get_proc_slot_nr>>=
def get_proc_slot_nr(self, id):
	if id in self.proc_slots:
		return self.proc_slots.index(id)
	else:
		return -1
@

%}}}
%{{{ get_tool_chook

The method {\tt get\_tool\_chook} calculates the 
geometry of the communication hook of a certain tool slot.

<<ToolBus.get_tool_chook>>=
def get_tool_chook(self, nr):
	# dx and dy give the x,y replacements of the connection
	# hook when a tool is one of the corner tools.
	dx = self.tool_size[0]/4
	dy = self.tool_size[1]/4
	if nr < self.th:
		# It's a northern tool
		anchor = "north"
		x = nr*self.tool_size[0]
		y = 0 
		hx1 = x + self.tool_size[0]/2
		hx2 = hx1
		hy1 = y + self.tool_size[1]
		hy2 = y + self.tool_size[1]*1.5
		if nr == 1:
			# It's the tool in the upper left corner
			hx2 = hx2 + dx
		if nr == self.th-2:
			hx2 = hx2 - dx

	elif nr < 2*self.th:
		# It's a southern tool
		anchor = "south"
		x = (nr-self.th)*self.tool_size[0]
		y = (self.tv-1)*self.tool_size[1]
		hx1 = x + self.tool_size[0]/2
		hx2 = hx1
		hy1 = y
		hy2 = y - self.tool_size[1]/2
		if nr == self.th+1:
			hx2 = hx2 + dx
		if nr == self.th*2-2:
			hx2 = hx2 - dx

	elif nr < 2*self.th+self.tv-2:
		# It's an western tool
		anchor = "west"
		x = 0
		y = (nr-2*self.th+1)*(self.tool_size[1])
		hx1 = x + self.tool_size[0]
		hx2 = x + self.tool_size[0]*1.5
		hy1 = y + self.tool_size[1]/2
		hy2 = hy1
		if nr == 2*self.th:
			hy2 = hy2 + dy
		if nr == 2*self.th+self.tv-3:
			hy2 = hy2 - dy

	else: 
		# It must be an eastern tool
		anchor = "east"
		x = (self.th-1)*self.tool_size[0]
		y = (nr-2*self.th+1-self.tv+2)*(self.tool_size[1])
		hx1 = x
		hx2 = x - self.tool_size[0]/2
		hy1 = y + self.tool_size[1]/2
		hy2 = hy1
		if nr == 2*self.th+self.tv-2:
			hy2 = hy2 + dy
		if nr == 2*self.th + 2*self.tv - 5:
			hy2 = hy2 - dy

	return (anchor, hx1, hy1, hx2, hy2)
@

%}}}
%{{{ get_free_tool_slot

Retrieve the next free tool slot.

<<ToolBus.get_free_tool_slot>>=
def get_free_tool_slot(self):
	for i in range(len(self.tool_slots)):
		if self.tool_slots[i] == None:
			if i not in self.forbidden_tools:
				return i
@

%}}}
%{{{ get_free_proc_slot

Get the next free process slot.

<<ToolBus.get_free_proc_slot>>=
def get_free_proc_slot(self):
	for i in range(len(self.proc_slots)):
		if self.proc_slots[i] == None:
			return i
@

%}}}
%{{{ is_proc

Check if the object with a certain ID is a process.

<<ToolBus.is_proc>>=
def is_proc(self, id):
	if id[0] in string.uppercase:
		return 1
	return 0
@

%}}}
%{{{ is_tool

Check if the object with a certain ID is a tool.

<<ToolBus.is_tool>>=
def is_tool(self, id):
	if id[0] in string.lowercase:
		return 1
	return 0
@

%}}}
%{{{ get_gp

The method {\tt get\_gp} retrieves the gridpoint from
which to draw communication lines.

<<ToolBus.get_gp>>=
def get_gp(self, obj):
	id = obj.get_id()
	if obj.is_process():
		snr = self.get_proc_slot_nr(id)
		x = snr % self.ph
		y = snr / self.ph
		return (2*x+1,2*y+1)
	else:
		snr = self.get_tool_slot_nr(id)
		if snr < self.th:
			gp = (snr*2-3, 0)
		elif snr < self.th*2:
			gp = ((snr-self.th)*2-3, self.pv*2)
		elif snr < self.th*2+self.tv-2:
			gp = (0, (snr-self.th*2)*2)
		else:
			gp = (self.ph*2,(snr-self.th*2-self.tv+2)*2)
		if gp[0] < 0:
			gp = (0, gp[1])
		if gp[0] > self.ph*2:
			gp = (self.ph*2, gp[1])
	return gp
@

%}}}
%{{{ gp_pos

Calculate the coordinates (window position) of a gridpoint.

<<ToolBus.gp_pos>>=
def gp_pos(self, gp):
	(gx, gy) = gp
	x = self.tb_pos[0] + (gx+1)*self.proc_size[0]/2
	y = self.tb_pos[1] + (gy+1)*self.proc_size[1]/2
	return (x,y)
@

%}}}
%{{{ gps_to_positions

Translate a list of gridpoints into a list of positions (window coordinates).

<<ToolBus.gps_to_positions>>=
def gps_to_positions(self, gps):
	pos_list = []
	for gp in gps:
		pos_list.append(self.gp_pos(gp))
	return pos_list
@

%}}}
%{{{ plan_path

Plan a path between two gridpoints. Avoid objects while doing so.

<<ToolBus.plan_path>>=
def plan_path(self, start_gp, end_gp):
	# print "plan_path: %s to %s" % (str(start_gp), str(end_gp))
	# Check if start and endpoint have met
	if start_gp == end_gp:
		return [start_gp]

	if start_gp[0] == end_gp[0] and abs(start_gp[1]-end_gp[1]) == 2:
		mid = (start_gp[0], (start_gp[1]+end_gp[1])/2)
		return [start_gp, mid, end_gp]
	if start_gp[1] == end_gp[1] and abs(start_gp[0]-end_gp[0]) == 2:
		mid = ((start_gp[0]+end_gp[0])/2, start_gp[1])
		return [start_gp, mid, end_gp]

	<<even start coordinates>>
	<<even end coordinates>>
	# Now, all the coordinates are even.
	
	# Things are very simple when the coordinates are
	# on the same row or column.
	if start_gp[0] == end_gp[0]:
		return [start_gp, end_gp]
	if start_gp[1] == end_gp[1]:
		return [start_gp, end_gp]

	# I guess we have to move one of the two to a different
	# row/column. I choose to move the start point to the
	# end points column.
	new_start = (end_gp[0], start_gp[1])
	points = self.plan_path(new_start, end_gp)
	points.insert(0, start_gp)	
	return points
@

%{{{ even start coordinates

<<even start coordinates>>=
# Make sure the start coordinates are even
if (is_odd(start_gp[0]) and is_odd(start_gp[1])):
	if start_gp[0] < end_gp[0]:
		start_x = start_gp[0]+1
	else:
		start_x = start_gp[0]-1
	if start_gp[1] < end_gp[1]:
		start_y = start_gp[1]+1
	else:
		start_y = start_gp[1]-1
	points = self.plan_path((start_x,start_y), end_gp)
	points.insert(0, start_gp)
	return points

if is_odd(start_gp[0]):
	print "evening x"
	if(start_gp[0] < end_gp[0]):
		new_start = (start_gp[0]+1, start_gp[1])
	else:
		new_start = (start_gp[0]-1, start_gp[1])
	points = self.plan_path(new_start, end_gp) 
	points.insert(0, start_gp)
	return points

if is_odd(start_gp[1]):
	# and ((abs(start_gp[0] - end_gp[0]) +
	#		     abs(start_gp[1] - end_gp[1])) > 2):
	print "evening y"
	if(start_gp[1] < end_gp[1]):
		new_start = (start_gp[0], start_gp[1]+1)
	else:
		new_start = (start_gp[0], start_gp[1]-1)
	points = self.plan_path(new_start, end_gp) 
	points.insert(0, start_gp)
	return points
@

%}}}
%{{{ even end coordinates

<<even end coordinates>>=
# Make sure the end coordinates are even
if (is_odd(end_gp[0]) and is_odd(end_gp[1]) and
		((abs(end_gp[0] - start_gp[0]) +
		abs(end_gp[1] - start_gp[1]) > 2) or
		end_gp[0] != start_gp[0] and end_gp[1] != start_gp[1])):
	if end_gp[0] < start_gp[0]:
		end_x = end_gp[0]+1
	else:
		end_x = end_gp[0]-1
	if end_gp[1] < start_gp[1]:
		end_y = end_gp[1]+1
	else:
		end_y = end_gp[1]-1
	points = self.plan_path(start_gp, (end_x,end_y))
	points.append(end_gp)
	return points

if is_odd(end_gp[0]):
	if(end_gp[0] < start_gp[0]):
		new_end = (end_gp[0]+1, end_gp[1])
	else:
		new_end = (end_gp[0]-1, end_gp[1])
	points = self.plan_path(start_gp, new_end) 
	points.append(end_gp)
	return points

if is_odd(end_gp[1]):
	if(end_gp[1] < start_gp[1]):
		new_end = (end_gp[0], end_gp[1]+1)
	else:
		new_end = (end_gp[0], end_gp[1]-1)
	points = self.plan_path(start_gp, new_end) 
	points.append(end_gp)
	return points
@

%}}}

%}}}

%}}}

%{{{ ToolBus interface functions

<<ToolBus interface functions>>=
<<toolbus_connected>>
<<toolbus_disconnected>>
<<toolbus_changed>>
<<view_toolbus>>

<<tool_connected>>
<<tool_disconnected>>
<<tool_changed>>

<<nub_connected>>
<<nub_disconnected>>
<<nub_changed>>

<<process_created>>
<<process_destroyed>>
<<process_changed>>
<<communication>>

<<atom_executed>>

<<add_button>>
<<add_toolbar_button>>
<<delete_button>>

<<rec_ack_event>>
<<rec_terminate>>
@

%{{{ toolbus_connected

A new slave ToolBus has made a connection. We need to start
some administration on it.

<<toolbus_connected>>=
def toolbus_connected(cid, ID, info):
  global tbs, button_list

  if tbs.has_key(ID):
    tbs[ID].change(info)
  else:
    tb = ToolBus(ID, info)
    tbs[ID] = tb
    for (group, text, event, constraints) in button_list:
	tb.add_button(group, text, event, constraints)
@

%}}}
%{{{ toolbus_disconnected

A slave ToolBus has been disconnected. Remove its window and other
associated data structures.

<<toolbus_disconnected>>=
def toolbus_disconnected(cid, id):
	global tbs

	tbs[id].disconnected()
	del tbs[id]
@

%}}}
%{{{ toolbus_changed
Some of the features of a ToolBus changed.
<<toolbus_changed>>=
def toolbus_changed(cid, id, info):
	global tbs

	tbs[tbid].change(info)
@
%}}}
%{{{ view_toolbus

Create a new view for a certain slave ToolBus.
If a view already exists for this slave, bring it
to the front.

<<view_toolbus>>=
def view_toolbus(cid, ID):
	global tbs

	try:
		tb = tbs[ID]
		tb.show()
	except:
		print sys.exc_type
		print sys.exc_value
		print sys.exc_trace
@

%}}}

%{{{ tool_connected

A new tool has established a connection with the
slave ToolBus. Take care that this connection sequence
can happen twice (in any order): once to connect the original
tool, and once when its debugging nub is connected.

<<tool_connected>>=
def tool_connected(cid, tbid, tid, name, info):
	global tbs

	print "tool_connected: ",tid

	if tbs.has_key(tbid):
		if tbs[tbid].get_tool(tid) == None:
			tool = Tool(tid, name, info)
			tbs[tbid].add_tool(tool)
		else:
			tbs[tbid].change_tool(tid, info)
			tbs[tbid].set_tool_name(tid, name)
	else:
		# The ToolBus does not exist yet!
		tb = ToolBus(tbid, [])
		tbs[tbid] = tb
		for (group, text, event, constraints) in button_list:
			tb.add_button(group, text, event, constraints)
		tool = Tool(tid, name, info)
		tbs[tbid].add_tool(tool)
		
@

%}}}
%{{{ tool_disconnected

A tool has been disconnected from the slave ToolBus.
<<tool_disconnected>>=
def tool_disconnected(cid, tbid, tid):
	global tbs

	tbs[tid].remove_tool(tid)	
@

%}}}
%{{{ tool_changed

Some of the features of a tool have changed.
<<tool_changed>>=
def tool_changed(cid, tbid, tid, info):
	global tbs

	tbs[tbid].change_tool(tid, info)
@

%}}}

%{{{ nub_connected
A nub connection with the master ToolBus was established.
Either create an apropriate tool object, or update the
existing one.
<<nub_connected>>=
def nub_connected(cid, tbid, tid, name, tinfo):
	tool_connected(cid, tbid, tid, name, tinfo)
@

%}}}
%{{{ nub_disconnected

A nub has been disconnected. Update the Tool object (if it is
present), that it can no longer be debugged.
<<nub_disconnected>>=
def nub_disconnected(cid, tbid, tid):
	global tbs

	if tbs.has_key(tbid):
		tool = tbs[tbid].get_tool(tid)
		if tool != None:
			# Remove debugging support from Tool object
			tool.remove_debugging()
@

%}}}
%{{{ nub_changed
Some of the features of a nub have changed. Modify
the apropriate {\tt Tool} object to reflect these changes.
<<nub_changed>>=
def nub_changed(cid, tbid, tid, tinfo):
	tool_changed(cid, tbid, tid, tinfo)
@

%}}}

%{{{ process_created

A process has been created in a slave ToolBus.

<<process_created>>=
def process_created(cid, tbid, pid, name):
	global tbs

	proc = tbs[tbid].get_process(pid)
	if proc == None:
		proc = Process(pid, name, [])
		tbs[tbid].add_process(proc)
	else:
		proc.set_name(name)
@

%}}}
%{{{ process_destroyed

A process has been destroyed in a slave ToolBus.

<<process_destroyed>>=
def process_destroyed(cid, tbid, pid):
	global tbs

	tbs[tbid].remove_process(pid)
@

%}}}
%{{{ process_changed

Some of the features of a process changed.
<<process_changed>>=
def process_changed(cid, tbid, pid, info):
	global tbs

	tbs[tbid].change_process(pid, info)
@

%}}}
%{{{ communication

<<communication>>=
def communication(cid, tbid, type, id1, id2, act):
	global tbs

	#print "communication: ", type, id1, id2, act
	if type == "proc-proc" or type == "proc-tool":
		src = tbs[tbid].get_process(id1)
	else:
		src = tbs[tbid].get_tool(id1)
	if type == "proc-tool":
		dest = tbs[tbid].get_tool(id2)
	else:
		dest = tbs[tbid].get_process(id2)
	if act != "rec-msg":
		tbs[tbid].communication(type, src, dest, act)
@

%}}}

%{{{ atom_executed

Every time a slave ToolBus executes an atom, this function is
called.

<<atom_executed>>=
def atom_executed(cid, tbid, pid1, atom, pid2):
	global tbs

	tbs[tbid].highlight_process(pid1)
	if pid2 == -1:
		tbs[tbid].remove_communication(pid1)
@

%}}}

%{{{ add_button

<<add_button>>=
def add_button(cid, tbid, group, text, event, constraints):
	global tbs, button_list

	if str(tbid) == "all":
		for tbid in tbs.keys():
			tbs[tbid].add_button(group, text, event, constraints)
		button_list.append((group, text, event, constraints))
	else:
		tbs[tbid].add_button(group, text, event, constraints)
@

%}}}
%{{{ add_toolbar_button

<<add_toolbar_button>>=
def add_toolbar_button(cid, tbid, group, file, event, constraints):
    global tbs, button_list

    if str(tbid) == "all":
	for tbid in tbs.keys():
	    tbs[tbid].add_toolbar_button(group, file, event, constraints)
	    toolbar_button_list.append((group, file, event, constraints))
    else:
	tbs[tbid].add_toolbar_button(group, file, event, constraints)
@

%}}}
%{{{ delete_button

<<delete_button>>=
def delete_button(cid, tbid, text):
	global tbs

	tbs[tbid].delete_button(text)
@

%}}}

%{{{ rec_ack_event

<<rec_ack_event>>=
def rec_ack_event(cid, event):
	pass
@

%}}}
%{{{ rec_terminate

<<rec_terminate>>=
def rec_terminate(cid, arg):
	sys.exit(0)
@

%}}}

%}}}



