#line 38 "tide.tb.nw"
process DAP-CONNECT is
let
  D    : debug-adapter,
  P    : list,
  Pid  : int,
  Info : list
in
  ( rec-connect(D?) .
    snd-eval(D, get-info) .
    rec-value(D, info(Info?)) .
    snd-eval(D, get-processes) .
    rec-value(D, processes(P?)) .
    printf("%t info: %t, procs: %t\n", D, Info, P) .
    snd-note(event(proc(D,all), dap-connected(Info,P))) .
    create(EVENT-RULES(D), Pid?)
    +
    rec-disconnect(D?) .
    snd-note(event(proc(D,all),dap-disconnected))
  ) * delta
endlet
#line 99 "tide.tb.nw"
process EVENT-RULES(D:debug-adapter) is
let
  P     : term,   %% list of process-id's, or `all' indicating all
                  %% processes controlled by the debug adapter.
  Port  : term,   %% event port and modifier
  Cond  : term,   %% event condition
  Life  : term,   %% lifetime of an event rule
  Acts  : list,   %% event actions
  Rid   : int,    %% event rule identifier
  Expr  : term,   %% Watchpoint expression
  Exprs : term,   %% List of expression/value pairs.
  Result: term    %% ok or error(<str>)
in
  ( rec-msg(proc(D,P?), create-rule(Port?,Cond?,Acts?,Life?)) .
    snd-eval(D, create-rule(P, Port,Cond,Acts,Life)) .
    rec-value(D, create-rule(P, Port,Cond,Acts,Life,Rid?)) .
    snd-note(event(proc(D,P), rule-created(Rid,Port,Cond,Acts,Life))) .
    snd-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid))
    +
    rec-msg(proc(D,P?), modify-rule(Rid?,Port?,Cond?,Acts?,Life?)) .
    snd-do(D, modify-rule(Rid,P,Port,Cond,Acts,Life)) .
    snd-note(event(proc(D,P), rule-modified(Rid,Port,Cond,Acts,Life)))
    +
    rec-msg(proc(D,P?), destroy-rule(Rid?)) .
    snd-do(D, destroy-rule(P,Rid))
    +
    rec-event(D, watchpoint(P?, Rid?, Exprs?)) .
    snd-note(event(proc(D,P), watchpoint(Rid, Exprs))) .
    snd-ack-event(D, watchpoint(P, Rid, Exprs))
    +
    rec-event(D, rule-destroyed(Rid?)) .
    snd-note(event(proc(D,P), rule-destroyed(Rid))) .
    snd-ack-event(D, rule-destroyed(Rid))
   ) * delta
endlet
#line 144 "tide.tb.nw"
process BROADCAST is
let
  From : term,
  Ev   : term
in
  ( rec-msg(event(From?, Ev?)) .
    snd-note(event(From, Ev))
  ) * delta
endlet
#line 201 "tide.tb.nw"
process SOURCE-VIEWER is
let
  S : source-viewer,
  D : debug-adapter,	%% Which debug adapter
  P : term,		%% List of processes (or in some cases 'all')
  Info : list,		%% Information about a debug adapter
  Rid : int,		%% Event rule identifier
  Port : term,		%% Event rule port
  Cond : term,		%% Event rule condition
  Acts : term,		%% Event rule actions
  Life : term,		%% Event rule lifetime
  Exprs: term,		%% A list of expression,value pairs
  Type : term		%% Rule type (handy to recognize the ack w.o. matching)
in
  execute(source-viewer, S?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,[[cpe,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-name,<term>]]))) .
  subscribe(event(<term>,current-port(<term>))) .
  snd-note(new-tool("View source", S, view-source)) .
  ( rec-msg(S, view-source, D?) .
    snd-do(S, view-source(D))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(S, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(S, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(S, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(S, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(S, rule-destroyed(D,P, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?,Exprs?))) .
    snd-do(S, watchpoint(D, P, Rid, Exprs))
    +
    rec-note(event(proc(D?,P?), current-port(Port?))) .
    snd-do(S, current-port(D,P,Port))
    +
    rec-event(S, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(S, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(S, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(S, destroy-rule(D,P,Rid))
    +
    rec-event(S, current-port(D?,P?,Port?)) .
    snd-msg(event(proc(D,P),current-port(Port))) .
    snd-ack-event(S, current-port(D,P,Port))
  ) * delta
endlet
#line 270 "tide.tb.nw"
process RULE-VIEWER is
let
  R : rule-viewer,
  D : debug-adapter,
  P : term,
  Info : list,
  Port : term,
  Cond : term,
  Acts : term,
  Life : term,
  Rid  : int,
  Exprs: list, %% A list of [expression, value] pairs
  Type : term
in
  execute(rule-viewer, R?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-name,<term>]]))) .
  subscribe(event(<term>,current-port(<term>))) .
  snd-note(new-tool("View rules", R, view-rules)) .
  ( rec-msg(R, view-rules, D?) .
    snd-do(R, view-rules(D))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(R, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(R, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(R, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(R, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(R, rule-destroyed(D,P, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?, Exprs?))) .
    snd-do(R, watchpoint(D, P, Rid, Exprs))
    +
    rec-note(event(proc(D?,P?), current-port(Port?))) .
    snd-do(R, current-port(D,P,Port))
    +
    rec-event(R, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(R, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(R, modify-rule(Rid?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),modify-rule(Rid,Cond,Acts,Life))
    +
    rec-event(R, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(R, destroy-rule(D,P,Rid))    
  ) * delta
endlet
#line 164 "tide.tb.nw"
process MASTER-CONTROL is
let
  M     : master-control,
  D     : debug-adapter,
  P     : term,
  Name  : str,
  Tool  : term,
  Info  : list,
  Event : term
in
  subscribe(new-tool(<str>,<term>,<term>)) .
  execute(master-control, M?) .
  subscribe(event(<term>, dap-connected(<list>,<list>))) .
  subscribe(event(<term>, dap-disconnected)) .
  ( rec-note(new-tool(Name?, Tool?, Event?)) .
    snd-do(M, new-tool(Name, Tool, Event))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    printf("dap-connected received: %t\n", D) .
    snd-do(M, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(M, dap-disconnected(D))
    +
    rec-event(M, button(Tool?, Event?, D?)) .
    snd-msg(Tool, Event, D) .
    snd-ack-event(M, button(Tool, Event, D))
  ) * rec-event(M, tide-shutdown) .
  snd-ack-event(M, tide-shutdown) .
  shutdown("Thank you for using tide!\n")
endlet

#line 26 "tide.tb.nw"
tool debug-adapter is { }
tool master-control is { command = "tcltk-adapter -script master-control.tcl" }
tool source-viewer  is { command = "tcltk-adapter -script source-viewer.tcl" }
tool rule-viewer  is { command = "tcltk-adapter -script rule-viewer.tcl" }
%%tool viewer is { command = "./buscontrol" }

#line 14 "tide.tb.nw"
toolbus(DAP-CONNECT, MASTER-CONTROL, BROADCAST, SOURCE-VIEWER, RULE-VIEWER)
