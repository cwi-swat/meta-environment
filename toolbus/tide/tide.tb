#line 41 "tide.tb.nw"
process DAP-CONNECT is
let
  D    : debug-adapter,
  P    : list,
  Pid  : int,
  Info : list
in
  ( rec-connect(D?) .
    snd-eval(D, get-info) .
    rec-value(D, info(Info?)) .
    snd-eval(D, get-processes) .
    rec-value(D, processes(P?)) .
    %% printf("%t info: %t, procs: %t\n", D, Info, P) .
    snd-note(event(proc(D,all), dap-connected(Info,P))) .
    create(EVENT-RULES(D), Pid?)
    +
    rec-disconnect(D?) .
    snd-note(event(proc(D,all),dap-disconnected))
  ) * delta
endlet
#line 102 "tide.tb.nw"
process EVENT-RULES(D:debug-adapter) is
let
  P     : term,   %% list of process-id's, or `all' indicating all
                  %% processes controlled by the debug adapter.
  Port  : term,   %% event port and modifier
  Cond  : term,   %% event condition
  Life  : term,   %% lifetime of an event rule
  Acts  : list,   %% event actions
  Rid   : int,    %% event rule identifier
  Expr  : term,   %% Watchpoint expression
  Exprs : term,   %% List of expression/value pairs.
  Result: term    %% ok or error(<str>)
in
  ( rec-msg(proc(D,P?), create-rule(Port?,Cond?,Acts?,Life?)) .
    snd-eval(D, create-rule(P, Port,Cond,Acts,Life)) .
    rec-value(D, create-rule(P, Port,Cond,Acts,Life,Rid?)) .
    snd-note(event(proc(D,P), rule-created(Rid,Port,Cond,Acts,Life))) .
    snd-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid))
    +
    rec-msg(proc(D,P?), modify-rule(Rid?,Port?,Cond?,Acts?,Life?)) .
    snd-do(D, modify-rule(Rid,P,Port,Cond,Acts,Life)) .
    snd-note(event(proc(D,P), rule-modified(Rid,Port,Cond,Acts,Life)))
    +
    rec-msg(proc(D,P?), destroy-rule(Rid?)) .
    snd-do(D, destroy-rule(P,Rid))
    +
    rec-msg(proc(D,P?), exec-actions(Acts?)) .
	printf("exec-actions(%t) to debug-adapter %t\n", Acts, D) .
    snd-eval(D, exec-actions(P, Acts)) .
    rec-value(D, exec-result(Result?)) .
    snd-msg(proc(D,P), exec-result(Result))
    +
    rec-event(D, watchpoint(P?, Rid?, Exprs?)) .
    snd-note(event(proc(D,P), watchpoint(Rid, Exprs))) .
    snd-ack-event(D, watchpoint(P, Rid, Exprs))
    +
    rec-event(D, rule-destroyed(Rid?)) .
    snd-note(event(proc(D,P), rule-destroyed(Rid))) .
    snd-ack-event(D, rule-destroyed(Rid))
   ) * delta
endlet
#line 153 "tide.tb.nw"
process BROADCAST is
let
  From : term,
  Ev   : term
in
  ( rec-msg(event(From?, Ev?)) .
    snd-note(event(From, Ev))
  ) * delta
endlet
#line 169 "tide.tb.nw"
process SOURCE-VIEWER is
let
  S : source-viewer,
  D : debug-adapter,	%% Which debug adapter
  P : term,		%% List of processes (or in some cases 'all')
  Info : list,		%% Information about a debug adapter
  Rid : int,		%% Event rule identifier
  Port : term,		%% Event rule port
  Cond : term,		%% Event rule condition
  Acts : term,		%% Event rule actions
  Life : term,		%% Event rule lifetime
  Exprs: term,		%% A list of expression,value pairs
  Type : term		%% Rule type (handy to recognize the ack w.o. matching)
in
  execute(source-viewer, S?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,[[cpe,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-name,<term>]]))) .
  subscribe(event(<term>,current-port(<term>))) .
  snd-note(new-tool("View source", S, view-source)) .
  snd-note(new-tool("View source", S, view-source, [adapter])) .
  ( rec-msg(S, view-source, D?) .
    snd-do(S, view-source(D))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(S, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(S, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(S, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(S, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(S, rule-destroyed(D,P, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?,Exprs?))) .
    snd-do(S, watchpoint(D, P, Rid, Exprs))
    +
    rec-note(event(proc(D?,P?), current-port(Port?))) .
    snd-do(S, current-port(D,P,Port))
    +
    rec-event(S, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(S, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(S, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(S, destroy-rule(D,P,Rid))
    +
    rec-event(S, current-port(D?,P?,Port?)) .
    snd-msg(event(proc(D,P),current-port(Port))) .
    snd-ack-event(S, current-port(D,P,Port))
  ) * delta
endlet
#line 239 "tide.tb.nw"
process RULE-VIEWER is
let
  R : rule-viewer,
  D : debug-adapter,
  P : term,
  Info : list,
  Port : term,
  Cond : term,
  Acts : term,
  Life : term,
  Rid  : int,
  Exprs: list, %% A list of [expression, value] pairs
  Type : term
in
  execute(rule-viewer, R?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-name,<term>]]))) .
  subscribe(event(<term>,current-port(<term>))) .
  snd-note(new-tool("View rules", R, view-rules)) .
  snd-note(new-tool("View rules", R, view-rules, [adapter])) .
  ( rec-msg(R, view-rules, D?) .
    snd-do(R, view-rules(D))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(R, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(R, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(R, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(R, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(R, rule-destroyed(D,P, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?, Exprs?))) .
    snd-do(R, watchpoint(D, P, Rid, Exprs))
    +
    rec-note(event(proc(D?,P?), current-port(Port?))) .
    snd-do(R, current-port(D,P,Port))
    +
    rec-event(R, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(R, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(R, modify-rule(Rid?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),modify-rule(Rid,Port,Cond,Acts,Life)) .
    snd-ack-event(R, modify-rule(Rid,D,P,Port,Cond,Acts,Life))
    +
    rec-event(R, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(R, destroy-rule(D,P,Rid))    
  ) * delta
endlet
#line 377 "tide.tb.nw"
process PROCESS-VIEWER is
let
  V : process-viewer,
  D : debug-adapter,	%% Which debug adapter
  Name : str,		%% The name of a tool
  Tool : term,		%% The tool-id of a tool
  Event : term,		%% The event needed to activate a tool
  Args  : list,		%% A list describing arguments needed for activation
  P : term,		%% List of processes (or in some cases 'all')
  Info : list,		%% Information about a debug adapter
  Exprs: term,		%% A list of expression,value pairs
  Port : term,		%% Event rule port
  Cond : term,		%% Event rule condition
  Acts : term,		%% Event rule actions
  Life : term,		%% Event rule lifetime
  Rid : int,		%% Event rule identifier
  Type : term,		%% The type of rule
  Result : term		%% ok(<term>) or error(<str>)
in
  subscribe(new-tool(<str>,<term>,<term>,<list>)) .
  execute(process-viewer, V?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-name,<term>]]))) .
  ( rec-note(new-tool(Name?, Tool?, Event?, Args?)) .
    snd-do(V, new-tool(Name, Tool, Event, Args))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(V, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(V, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?,Exprs?))) .
    snd-do(V, watchpoint(D, P, Rid, Exprs))
    +
    rec-event(V, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(V, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(V, exec-actions(D?, P?, Acts?)) .
	printf("rec-event exec-actions.\n") .
    snd-msg(proc(D,P), exec-actions(Acts)) .
    rec-msg(proc(D,P), exec-result(Result?)) .
	printf("exec-result = %t\n", Result) .
    snd-ack-event(V, exec-actions(D, P, Acts, Result))
    +
    rec-event(V, button(Tool?, Event?, D?)) .
    snd-msg(Tool, Event, D) .
    snd-ack-event(V, button(Tool, Event, D))
  ) * rec-event(V, tide-shutdown) .
  snd-ack-event(V, tide-shutdown) .
  shutdown("Thank you for using tide!\n")
endlet
#line 308 "tide.tb.nw"
process WATCHPOINT-VIEWER is
let
  V    : watchpoint-viewer,
  D    : debug-adapter,
  P    : term,
  Info : list,
  Port : term,
  Cond : term,
  Acts : term,
  Life : term,
  Rid  : int,
  Exprs: list, %% A list of [expression, value] pairs
  Type : term
in
  execute(watchpoint-viewer, V?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,<list>))) .
  snd-note(new-tool("Create watchpoint", V, view-watchpoint)) .
  snd-note(new-tool("Create watchpoint", V, view-watchpoint, [adapter])) .
  ( rec-msg(V, view-watchpoint, D?) .
    snd-do(V, view-watchpoint(D))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(V, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(V, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(V, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(V, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(V, rule-destroyed(D,P, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?, Exprs?))) .
    snd-do(V, watchpoint(D, P, Rid, Exprs))
    +
    rec-event(V, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    printf("watchpoint viewer created rule: %d\n", Rid) .
    snd-ack-event(V, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(V, modify-rule(Rid?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),modify-rule(Rid,Port,Cond,Acts,Life)) .
    snd-ack-event(V, modify-rule(Rid,D,P,Port,Cond,Acts,Life))
    +
    rec-event(V, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(V, destroy-rule(D,P,Rid))    
  ) * delta
endlet

#line 28 "tide.tb.nw"
tool debug-adapter is { }
tool source-viewer  is { command = "tcltk-adapter -script source-viewer.tcl" }
tool rule-viewer  is { command = "tcltk-adapter -script rule-viewer.tcl" }
tool watchpoint-viewer is { command = "tcltk-adapter -script watchpoint-viewer.tcl" }
tool process-viewer is { command = "java-adapter -class toolbus.tide.ProcessViewerTool" }
%%tool viewer is { command = "./buscontrol" }

#line 15 "tide.tb.nw"
toolbus(DAP-CONNECT, BROADCAST, 
	SOURCE-VIEWER, RULE-VIEWER, WATCHPOINT-VIEWER, PROCESS-VIEWER)
