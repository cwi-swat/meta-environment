#line 43 "tide.tb.nw"
process DAP-CONNECT is
let
  D    : debug-adapter,
  P    : list,
  Pid  : int,
  Info : list
in
  ( rec-connect(D?) .
    snd-eval(D, get-info) .
    rec-value(D, info(Info?)) .
    snd-eval(D, get-processes) .
    rec-value(D, processes(P?)) .
    printf("%t info: %t, procs: %t\n", D, Info, P) .
    snd-note(event(proc(D,all), dap-connected(Info,P))) .
    create(DEBUG-ADAPTER(D), Pid?)
    +
    rec-disconnect(D?) .
    snd-note(event(proc(D,all),dap-disconnected))
  ) * delta
endlet
#line 105 "tide.tb.nw"
process DEBUG-ADAPTER(D:debug-adapter) is
let
  P     : term,   %% list of process-id's, or `all' indicating all
                  %% processes controlled by the debug adapter.
  Port  : term,   %% event port and modifier
  Cond  : term,   %% event condition
  Life  : term,   %% lifetime of an event rule
  Acts  : list,   %% event actions
  Rid   : int,    %% event rule identifier
  Expr  : term,   %% Watchpoint expression
  Exprs : term,   %% List of expression/value pairs.
  Result: term,   %% ok or error(<str>)
  Callsign : term %% Name of an external process
in
  ( rec-msg(proc(D,P?), create-rule(Port?,Cond?,Acts?,Life?)) .
    printf("$$$ creating rule: %t,%t,%t,%t,%t,%t\n", D, P, Port, Cond, Acts, Life) .
    snd-eval(D, create-rule(P, Port,Cond,Acts,Life)) .
    rec-value(D, create-rule(P, Port,Cond,Acts,Life,Rid?)) .
    snd-note(event(proc(D,P), rule-created(Rid,Port,Cond,Acts,Life))) .
    snd-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid))
    +
    rec-msg(proc(D,P?), modify-rule(Rid?,Port?,Cond?,Acts?,Life?)) .
    snd-do(D, modify-rule(Rid,P,Port,Cond,Acts,Life)) .
    snd-note(event(proc(D,P), rule-modified(Rid,Port,Cond,Acts,Life)))
    +
    rec-msg(proc(D,P?), destroy-rule(Rid?)) .
    snd-do(D, destroy-rule(P,Rid))
    +
    rec-msg(proc(D,P?), exec-actions(Acts?)) .
    snd-eval(D, exec-actions(P, Acts)) .
    rec-value(D, exec-result(Result?)) .
    snd-msg(proc(D,P), exec-result(Result))
    +
    rec-event(D, watchpoint(P?, Rid?, Exprs?)) .
    printf("*** watchpoint(%t,%t,%t)\n", P, Rid, Exprs) .
    snd-note(event(proc(D,P), watchpoint(Rid, Exprs))) .
    snd-ack-event(D, watchpoint(P, Rid, Exprs))
    +
    rec-event(D, rule-destroyed(Rid?)) .
    snd-note(event(proc(D,P), rule-destroyed(Rid))) .
    snd-ack-event(D, rule-destroyed(Rid))
    +
    rec-event(D, synchronize) .
    snd-note(synchronize(D)) .
    rec-msg(synchronize(D)) .
    snd-ack-event(D, synchronize)
    +
    rec-event(D, connected(Callsign?)) .
    snd-note(event(proc(D,all), connected(Callsign))) .
    snd-ack-event(D, connected(Callsign))
    +
    rec-event(D, disconnected(Callsign?)) .
    snd-note(event(proc(D,all),disconnected(Callsign))) .
    snd-ack-event(D, disconnected(Callsign))
   ) * delta
endlet
#line 171 "tide.tb.nw"
process BROADCAST is
let
  From : term,
  Ev   : term
in
  ( rec-msg(event(From?, Ev?)) .
    snd-note(event(From, Ev))
  ) * delta
endlet
#line 261 "tide.tb.nw"
process SOURCE-VIEWER is
let
  S : source-viewer,
  D : debug-adapter,	%% Which debug adapter
  P : term,		%% List of processes (or in some cases 'all')
  Info : list,		%% Information about a debug adapter
  Rid : int,		%% Event rule identifier
  Port : term,		%% Event rule port
  Cond : term,		%% Event rule condition
  Acts : term,		%% Event rule actions
  Life : term,		%% Event rule lifetime
  Result : term,        %% The result of execution a list of actions 
  CPE  : term,          %% Current point of execution (a debug port)
  ES   : term,          %% The current state of execution of a process (run)
  Name : str,           %% The name of a newly created process
  Aliases : list,       %% A list of the aliases of a process
  Type : term		%% Rule/Watchpoint type (handy to recognize the ack w.o. matching)
in
  execute(source-viewer, S?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,connected(<term>))) .
  subscribe(event(<term>,disconnected(<term>))) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,[[cpe,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,
		[[process-creation(process-name,aliases),<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-destruction,<term>]]))) .
  subscribe(event(<term>,current-port(<term>))) .
  snd-note(new-tool("View source", S, [["Current process", "process"]])) .
  ( rec-msg(tool-cmd(S, "Current process", [proc(D?, P?)])) .
    snd-do(S, view-process(D, P))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(S, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(S, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(S, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(S, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(S, rule-destroyed(D, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?, [[cpe, CPE?]]))) .
    snd-do(S, cpe(D, P, CPE))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?, [[exec-state,ES?]]))) .
    snd-do(S, exec-state(D, P, ES))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?,
	[[process-creation(process-name,aliases),
	  process-creation(Name?,Aliases?)]]))) .
    snd-do(S, process-creation(D, P, Name, Aliases))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?, 
	process-destruction, process-destruction))) .
    snd-do(S, process-destruction(D, P))
    +
    rec-note(event(proc(D?,P?), current-port(Port?))) .
    snd-do(S, current-port(D,P,Port))
    +
    rec-event(S, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(S, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(S, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(S, destroy-rule(D,P,Rid))
    +
    rec-event(S, exec-actions(D?, P?, Acts?)) .
    snd-msg(proc(D,P), exec-actions(Acts)) .
    rec-msg(proc(D,P), exec-result(Result?)) .
    snd-ack-event(S, exec-actions(D, P, Acts, Result))
    +
    rec-event(S, current-port(D?,P?,Port?)) .
    snd-msg(event(proc(D,P),current-port(Port))) .
    snd-ack-event(S, current-port(D,P,Port))
    +
    rec-event(S, ask-watchpoint(D?,P?,Port?,Type?)) .
    snd-msg(ask-watchpoint(D,P,Port,Type)) .
    snd-ack-event(S, ask-watchpoint(D,P,Port,Type))
  ) * delta
endlet
#line 497 "tide.tb.nw"
process PROCESS-VIEWER is
let
  V : process-viewer,
  D : debug-adapter,	%% Which debug adapter
  Name : str,		%% The name of a tool
  Tool : term,		%% The tool-id of a tool
  Args  : list,		%% A list describing arguments needed for activation
  P : term,		%% List of processes (or in some cases 'all')
  Info : list,		%% Information about a debug adapter
  Exprs: term,		%% A list of expression,value pairs
  Port : term,		%% Event rule port
  Cond : term,		%% Event rule condition
  Acts : term,		%% Event rule actions
  Life : term,		%% Event rule lifetime
  Rid : int,		%% Event rule identifier
  Type : term,		%% The type of rule
  Result : term,	%% ok(<term>) or error(<str>)
  Callsign : term       %% Callsign of an external process
in
  subscribe(new-tool(<str>,<term>,<list>)) .
  subscribe(synchronize(<term>)) .
  execute(process-viewer, V?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,connected(<term>))) .
  subscribe(event(<term>,disconnected(<term>))) .
  subscribe(event(<term>,watchpoint(<int>,[[exec-state,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,
		[[process-creation(process-name,aliases),<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[process-destruction,<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[send(msg,peer),<term>]]))) .
  subscribe(event(<term>,watchpoint(<int>,[[receive(msg,peer),<term>]]))) .
  ( rec-note(new-tool(Name?, Tool?, Args?)) .
    snd-do(V, new-tool(Name, Tool, Args))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(V, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(V, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?,Exprs?))) .
    snd-do(V, watchpoint(D, P, Rid, Exprs)) .
    snd-msg(event(proc(D,P), continue))
    +
    rec-note(event(proc(D?,all), connected(Callsign?))) .
    snd-do(V, connected(Callsign))
    +
    rec-note(event(proc(D?,all), disconnected(Callsign?))) .
    snd-do(V, disconnected(Callsign))
    +
    rec-note(synchronize(D?)) .
    snd-msg(synchronize(D))
    +
    rec-event(V, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(V, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(V, exec-actions(D?, P?, Acts?)) .
    snd-msg(proc(D,P), exec-actions(Acts)) .
    rec-msg(proc(D,P), exec-result(Result?)) .
    snd-ack-event(V, exec-actions(D, P, Acts, Result))
    +
    rec-event(V, tool-cmd(Tool?, Name?, Args?)) .
    printf("tool-cmd: %t, %t, %t\n", Tool, Name, Args) .
    snd-msg(tool-cmd(Tool, Name, Args)) .
    snd-ack-event(V, tool-cmd(Tool, Name, Args))
  ) * rec-event(V, tide-shutdown) .
  snd-ack-event(V, tide-shutdown) .
  shutdown("Thank you for using tide!\n")
endlet
#line 427 "tide.tb.nw"
process WATCHPOINT-VIEWER is
let
  V    : watchpoint-viewer,
  D    : debug-adapter,
  P    : term,
  Info : list,
  Port : term,
  Cond : term,
  Acts : term,
  Life : term,
  Rid  : int,
  Exprs: list, %% A list of [expression, value] pairs
  Type : term
in
  execute(watchpoint-viewer, V?) .
  subscribe(event(<term>,dap-connected(<list>,<list>))) .
  subscribe(event(<term>,dap-disconnected)) .
  subscribe(event(<term>,rule-created(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-modified(<int>,<term>,<term>,<term>,<term>))) .
  subscribe(event(<term>,rule-destroyed(<int>))) .
  subscribe(event(<term>,watchpoint(<int>,<list>))) .
  snd-note(new-tool("Watchpoint", V, [["Create", "process"]])) .
  ( rec-msg(tool-cmd(V, "Create", [proc(D?,P?)])) .
    snd-do(V, create-watchpoint(D, P))
    +
    rec-msg(ask-watchpoint(D?,P?,Port?,Type?)) .
    snd-do(V, ask-watchpoint(D,P,Port,Type))
    +
    rec-note(event(proc(D?,all), dap-connected(Info?,P?))) .
    snd-do(V, dap-connected(D, Info, P))
    +
    rec-note(event(proc(D?,P?), dap-disconnected)) .
    snd-do(V, dap-disconnected(D))
    +
    rec-note(event(proc(D?,P?), rule-created(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(V, rule-created(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-modified(Rid?,Port?,Cond?,Acts?,Life?))) .
    snd-do(V, rule-modified(D,P,Rid,Port,Cond,Acts,Life))
    +
    rec-note(event(proc(D?,P?), rule-destroyed(Rid?))) .
    snd-do(V, rule-destroyed(D,P, Rid))
    +
    rec-note(event(proc(D?,P?), watchpoint(Rid?, Exprs?))) .
    snd-do(V, watchpoint(D, P, Rid, Exprs))
    +
    rec-event(V, create-rule(Type?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),create-rule(Port,Cond,Acts,Life)) .
    rec-msg(proc(D,P), create-rule(Port, Cond, Acts, Life, Rid?)) .
    snd-ack-event(V, create-rule(Type,D,P,Port,Cond,Acts,Life,Rid))
    +
    rec-event(V, modify-rule(Rid?,D?,P?,Port?,Cond?,Acts?,Life?)) .
    snd-msg(proc(D,P),modify-rule(Rid,Port,Cond,Acts,Life)) .
    snd-ack-event(V, modify-rule(Rid,D,P,Port,Cond,Acts,Life))
    +
    rec-event(V, destroy-rule(D?,P?,Rid?)) .
    snd-msg(proc(D,P), destroy-rule(Rid)) .
    snd-ack-event(V, destroy-rule(D,P,Rid))    
  ) * delta
endlet

#line 27 "tide.tb.nw"
tool debug-adapter is { }
tool source-viewer  is 
	{ command = "java-adapter -class toolbus.tide.SourceViewerTool" }
#tool rule-viewer  is { command = "tcltk-adapter -script rule-viewer.tcl" }
tool watchpoint-viewer is 
	{ command = "java-adapter -class toolbus.tide.WatchpointViewerTool" }
tool process-viewer is
	{ command = "java-adapter -class toolbus.tide.ProcessViewerTool" }
%%tool viewer is { command = "./buscontrol" }

#line 14 "tide.tb.nw"
toolbus(DAP-CONNECT, BROADCAST, 
	SOURCE-VIEWER, WATCHPOINT-VIEWER, PROCESS-VIEWER)
