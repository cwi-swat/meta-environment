
The class {\tt FeatureSet} keeps track of a set of features
and changes to these features. A feature consists of a name
(a string), and a value (any object).

<<fset.py>>=
import types

class FeatureSet:
	<<FeatureSet.__init__>>
	<<FeatureSet.get_feature>>
	<<FeatureSet.set_feature>>
	<<FeatureSet.has_feature>>
	<<FeatureSet.delete_feature>>
	<<FeatureSet.delete_features>>
	<<FeatureSet.all_features>>
	<<FeatureSet.change>>
	<<FeatureSet.satisfies>>
	<<FeatureSet.remove_debugging>>

	debugging_features = []
@

%{{{ __init__

The class {\tt FeatureSet} constructor, {\tt \_\_init\_\_}, takes an
optional dictionary argument to initialize the feature set.
<<FeatureSet.__init__>>=
def __init__(self, features = []):
	self.features = { }
	self.change(features)
@

%}}}
%{{{ get_feature

{\tt get\_feature} retrieves the value of a certain feature.
<<FeatureSet.get_feature>>=
def get_feature(self, name):
	return self.features[name]
@

%}}}
%{{{ set_feature

{\tt set\_feature} changes the value of a certain feature, and
adds the feature when it was not already present.
<<FeatureSet.set_feature>>=
def set_feature(self, name, value):
	self.features[name] = value
@

%}}}
%{{{ has_feature

{\tt has\_feature} checks if a feature with a certain name
is in a feature set.
<<FeatureSet.has_feature>>=
def has_feature(self, name):
	return self.features.has_key(name)
@

%}}}
%{{{ delete_feature

{\tt delete\_feature} deletes a features when it is present in
a feature set, and does nothing otherwise.
<<FeatureSet.delete_feature>>=
def delete_feature(self, name):
	if self.has_feature(name):
		del self.features[name]
@

%}}}
%{{{ delete_features

Delete a list of features from a feature set.

<<FeatureSet.delete_features>>=
def delete_features(self, list):
	features = self.all_features
	for feature in list:
		self.delete_feature(feature)
@

%}}}
%{{{ all_features

{\tt all\_features} returns a list containing the names of all
features in a feature set (in random order).
<<FeatureSet.all_features>>=
def all_features(self):
	return self.features.keys()
@

%}}}
%{{{ change

{\tt change} adds/changes a number of features from a list.
<<FeatureSet.change>>=
def change(self, list):
	for el in list:
		name = el[0]
		val  = el[1]
		self.features[name] = val
@

%}}}
%{{{ satisfies

Check if a featureset satisfies a certain constraint.
Constraint can be:
\begin{itemize}
\item a single value, in which case the feature it 
represents must be present in the FeatureSet to be satisfied.
\item a list of length two with the second element of
      type string. In this case the string is treated as a
      regular expression that much match the value of the
      feature.
\item a list of length two with the second element any other
      type. In this case the first element is again treated
      as a feature name, and the second element much be equal
      to the value of this feature for the {\tt FeatureSet}
      to satisfy the constraint.
\end{itemize}

<<FeatureSet.satisfies>>=
def satisfies(self, constraint):
	if not type(constraint) == types.ListType:
		if self.has_feature(constraint):
			return 1
		return 0
	[feature, pattern] = constraint
	if not self.has_feature(feature):
		return 0
	val = self.get_feature(feature)
	if type(val) == types.StringType:
		if regexp.match(pattern, str(val)) >= 0:
			return 1
		return 0
	if val == self.get_feature(feature):
		return 1
	return 0
@

%}}}
%{{{ remove_debugging
<<FeatureSet.remove_debugging>>=
def remove_debugging(self):
	self.delete_features(FeatureSet.debugging_features)
@
%}}}





