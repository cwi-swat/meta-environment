\documentclass{llncs}
 
\usepackage[english]{babel}
\usepackage{epsfig}
\usepackage{url}
\usepackage{alltt}
\usepackage{xspace}
%%\usepackage{fancyheadings}
\usepackage{latexsym}
\usepackage{graphics}
%%\usepackage[dvips]{color}
\usepackage{times}
\usepackage{mathptm}
\usepackage{verbatim}
 
\newcommand{\TB}{\textsc{ToolBus}}
\newcommand{\asfplussdf}{ASF+SDF}
\newcommand{\asdf}{{\sc Asf+Sdf}}
\newcommand{\asf}{{\sc Asf}}
\newcommand{\sdf}{{\sc Sdf}}

\newcommand{\spec}[1]{\texttt{#1}}

\title{ToolBus: The Next Generation}
\author{Hayco de Jong\inst{1} and Paul Klint\inst{1,2}}

\institute{Centrum voor Wiskunde en Informatica, The Netherlands
\and
Informatics Institute,	University of Amsterdam, The Netherlands}

\begin{document}
\maketitle
 
\begin{abstract}
xxxxx
\end{abstract}

\section{Generic Language Technology}

Our primary interest is \emph{generic language technology}
that aims at the rapid construction of tools for a wide variety
of programming and application languages.
Its central notion is a \emph{language definition}
of some programming or application language.

The common methodology is that a language is identified in a given
domain, that relevant aspects of that language are formally defined
and that desired tools are generated on the basis of this language
definition. This generative approach is illustrated in
Figure~\ref{Fig:generator}. Using a definition for some language $L$
as starting point, a generator can a produce a range of tools for
editing, manipulating, checking or executing $L$ programs.

Language aspects have to be defined, analyzed, and used to generate
appropriate tooling such as compilers, interpreters, typecheckers,
syntax-directed editors, debuggers, partial evaluators, test case
generators, documentation generators, and more.

Language definitions are used, on a daily basis, in application areas
as disparate as Cobol renovation, Java refactoring, smart card
verification and in application generation for domains including
finance, industrial automation and software engineering.  In the case
of Cobol renovation, the language in question is Cobol and those
aspects that are relevant for renovation have to be formalized. In the
case of application generation, the language in question is probably
new and has to be designed from scratch.

\begin{figure}
\epsfig{figure=figs/generator.eps,width=\textwidth,height=12cm}
\vspace*{-7cm}
\caption{\label{Fig:generator}From language definition to generated programming environment}
\end{figure}

\subsection{One realization: the \asdf\ Meta-Environment}

The \asdf\ Meta-Environment~\cite{XXX} is an incarnation of the
approach just described and covers both the interactive development of
language definitions and the generation of tools based on these
language definitions.

In this paper we are primarily interested in the \emph{software
aspects} of building such a system. Starting point is the \asdf\
Meta-Environment as we had completed it in the beginning of the
1990's.  This was a monolithic 200 KLOC Lisp program that was hard to
maintain.  It had all the traits of a legacy system and was the
primary motivation to enter the area of system and software
renovation. To place this in historic perspective, we give a brief
timeline of our efforts to transform the old, monolithic, implementation
of the Meta-Environment into a well-structured, component-based,
implementation:

\begin{itemize}
\item[1992] First, unsuccessfull, experiments to decompose the system
into separate parts.  The idea was to separate the user-interface and
the text editor from the rest of the system.  The user-interface was
completely re-implemented as a separate component and as text editor
we re-used Emacs. In hindsight, we were unaware of the fact that we
made the transition from a completely sequential system to a system
with several concurrent components. Unavoidably, we encountered hard
to explain deadlocks and race conditions. (** Wilco/Huub **).

\item[1993] A next step was to write a formal specification of the
desired system behaviour using PSF, a specification language based on
proces algebra and algebraic specifications (** cite **).  Simulation
of this specification unvealed other, not yet observed, deadlocks.
Although, this was clearly an improvement over the then existing situation,
this specification appraoch also had its limitations and drawbacks:

\begin{itemize}

\item The specification lacked generality. It would, for instance, have
been a major change to add the description of a new component.

\item The effort to write the PSF specification was significant and there was no
way to derive an actual implementation from this specification.

\end{itemize}

\item[1994:] First ToolBus, AMAST96
\item[1995:] Discrete time ToolBus, SCP98
\item[2001:] Meta-Environment restructured, CC01
\item[2002:] preparing for the next generation ...
\end{itemize}


\subsection{Plan of this Paper}

\section{Coordination, Representation and Computation}

\begin{verbatim}
Coordination: the way in which program and system parts interact (procedure calls, RMI, ...)
Representation: language and machine neutral data exchanged between components
Computation: program code that carries out a specialized task

A rigorous separation of coordination
from computation is the key to 
flexible and reusable systems
\end{verbatim}

\begin{verbatim}
Applicative, prefix terms
Maximal subterm sharing (=> DAG)
cheap equality test, efficient rewriting
Annotations
Very concise, binary, sharing preserving encoding
Language & machine independent exchange format
Software Practice & Experience 2000
\end{verbatim}

\begin{figure}
\epsfig{figure=figs/component-architecture.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}


\section{The \TB\ Architecture}

\begin{verbatim}
Goals: integrate tools written in different languages running on different machines
A programmable software bus
Scripts describe the cooperation of tools
Scripts are based on Process Algebra
Science of Computer Programming 1998
\end{verbatim}

\begin{figure}
\begin{center}
\begin{tabular}{|l|l|}
\hline Primitive		& Description	\\ \hline \hline
\spec{delta}			& inaction (``deadlock'') \\
\spec{+}			& choice between two alternatives ($P_1$ or $P_2$)\\
\spec{.}			& sequential composition ($P_1$ followed by $P_2$)\\
\spec{*}			& iteration (zero or more times $P_1$ followed by $P_2$)\\
\spec{create}			& process creation\\ \hline
\spec{snd-msg}			& send a message (binary, synchronous)\\
\spec{rec-msg}			& receive a message (binary, synchronous)\\ \hline
\spec{snd-note}			& send a note (broadcast, asynchronous)\\
\spec{rec-note}			& receive a note (asynchronous)	\\
\spec{no-note}			& no notes available for process\\
\spec{subscribe}		& subscribe to notes\\
\spec{unsubscribe}		& unsubscribe from notes\\ \hline
\spec{snd-eval}			& send evaluation request to tool\\
\spec{rec-value}		& receive a value from a tool	\\
\spec{snd-do}			& send request to tool (no return value)\\
\spec{rec-event}		& receive event from tool\\
\spec{snd-ack-event}		& acknowledge a previous event from a tool\\ \hline
\spec{if ... then ... fi}	& guarded command\\
\spec{if ... then ... else ... fi} 	& conditional\\
				& expressions	\\
\spec{||}			& communication-free merge (parallel composition) \\
\spec{let ... in ... endlet}	& local variables \\
\spec{:=}			& assignment	\\ \hline

\spec{delay}			& relative time delay\\
\spec{abs-delay}		& absolute time delay\\
\spec{timeout}			& relative timeout\\
\spec{abs-timeout}		& absolute timeout\\ \hline

\spec{rec-connect}		& receive a connection request from a tool\\
\spec{rec-disconnect}		& receive a disconnection request from a tool\\
\spec{execute}			& execute a tool\\
\spec{snd-terminate}		& terminate the execution of a tool\\
\spec{shutdown}			& terminate \TB	\\ \hline

\spec{attach-monitor}		& attach a monitoring tool to a process\\
\spec{detach-monitor}		& detach a monitoring tool from a process \\ \hline
\end{tabular}
\caption{Overview of \TB\ primitives.}
\label{fig:Features}
\end{center}
\end{figure}

\begin{figure}
\epsfig{figure=figs/toolbus.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\begin{figure}
\epsfig{figure=figs/toolbus-scenario.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\section{Application to the \asdf\ Meta-Environment}

\begin{figure}
\epsfig{figure=figs/meta-env.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\begin{tabular}{|l|r|r|r|} \hline

Language        & KLOC$^\dagger$ & Generated KLOC & Total KLOC\\ \hline \hline

ASF+SDF         & 12	 & 170 (C) & \\
C 	        & 80$^{\dagger\dagger}$  & & \\
Java, Tcl/Tk    &  5  & &\\
Makefiles, etc	&  5  & &\\
ToolBus scripts	&  5  & &\\ \hline
Total LOC:	& 107 & 170 & 277 \\\hline

ToolBus script &  4.6\% &  & 1.8\%\\ \hline
\end{tabular}

$^\dagger$ Kilo Lines of Code  excluding third party code
such as emacs, dot, and the like.

$^{\dagger\dagger}$ This includes 10000 LOC (C code) for the \TB\
implementation itself.

\begin{tabular}{|l|r|}\hline
Primitive                            & Number of occurrences \\ \hline \hline

process definitions                  & 104\\
tool definitions                     & 27\\
\texttt{.} (sequential composition)  & 4343\\
\texttt{+} (choice)                  & 341\\
\texttt{*} (iteration)               & 243\\
\texttt{||} (parallell composition)  & 3\\

\texttt{snd-msg}                     & 555\\
\texttt{rec-msg}                     & 541\\
\texttt{snd-note}                    & 100\\
\texttt{rec-note}                    & 24\\
\texttt{snd-do}/\texttt{snd-eval}    & 220\\
\texttt{rec-event}                   & 56\\
\texttt{create}                      & 58 \\ \hline
\end{tabular}

\section{Issues in a Next-Generation \TB}

\subsection{Undisciplined Message Patterns}

\begin{figure}
\epsfig{figure=figs/rpc.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\begin{figure}
\epsfig{figure=figs/msg.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\begin{verbatim}
call/reply regime has to be encoded in messages
typically a message identifier
error handling is hard
which reply did not come?
Script harder to understand
unstructured combination of
send/receive
Operators . + * ||
\end{verbatim}

\begin{verbatim}
Send and receive occur in pairs
Inbetween arbitrary operations allowed
In fact, a matching send/receive may be an arbitrary expression
provided all alternatives begin with a matching send/receive
\end{verbatim}

\begin{verbatim}
snd-msg(eval(E)) . rec-msg(A?)

snd-msg(eval(E)) { } rec-msg(A?)

snd-msg(eval(E)){
   arbitrary process expression 
    }  rec-msg(A?)

snd-msg (eval(E)) 
{arbitrary process expression 
    } ( rec-msg(A?) 
     + rec-msg(error(M?)
     )

\end{verbatim}


\subsection{Exception Handling}

\begin{verbatim}
Java-style execption handling does not work
always associated with one specific call
We use a LOTOS-style disrupt operator
P >> E
Adds the exception E as alternative to each atom in the process expression P
Solves local error handling
Error propagation: open issue
\end{verbatim}


\subsection{Call-by-value versus Call-by-reference}

\begin{figure}
\epsfig{figure=figs/refs.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\begin{figure}
\epsfig{figure=figs/values.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\begin{verbatim}
Call by ref:
Efficient for infrequent access/update
 Uncontrolled modifications
 New versions of CORBA have call-by-value

Call by value:
Inefficient
 Sharing between calls is lost (recall big parse trees)
 Only works between Java components
 Via IIOP connection with non-Java components
\end{verbatim}

\begin{verbatim}
ToolBus now:
Transparent model
 Shared access can be           expressed in the script
 No distributed garbage        collection
 ToolBus is bottleneck for     large values

ToolBus NG:
Ad hoc data channel
 Transparent model
 Garbage collection of                   channels
 No central bottleneck
\end{verbatim}


\begin{figure}
\epsfig{figure=figs/toolbus-values.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}


\begin{figure}
\epsfig{figure=figs/toolbus-refs.eps,width=\textwidth}
\vspace*{-10cm}
\caption{XXX}
\end{figure}

\section{Current Status}

\begin{verbatim}
Current ToolBus
implemented in C
target: ASF+SDF Meta-Environment
Next generation ToolBus
implemented in Java
Tools on same machine run in a separate thread
Easy connection with RMI/CORBA, database access, ...
target: gamesquare.nl
multi-user game site, thousands of users.
\end{verbatim}

\section{Case study: ToolBus and Java RMI}
\verbatiminput{addrbook.tb}

\section{Concluding Remarks}

\section*{Acknowledgements}

Pieter (misschien co-auteur?)


\bibliographystyle{plain} 
\bibliography{fmco02} 
\end{document}
